/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 84 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef float LADSPA_Data;
#line 94 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef int LADSPA_Properties;
#line 152 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef int LADSPA_PortDescriptor;
#line 200 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef int LADSPA_PortRangeHintDescriptor;
#line 337 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
struct _LADSPA_PortRangeHint {
   LADSPA_PortRangeHintDescriptor HintDescriptor ;
   LADSPA_Data LowerBound ;
   LADSPA_Data UpperBound ;
};
#line 337 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef struct _LADSPA_PortRangeHint LADSPA_PortRangeHint;
#line 363 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef void *LADSPA_Handle;
#line 373 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
struct _LADSPA_Descriptor {
   unsigned long UniqueID ;
   char const   *Label ;
   LADSPA_Properties Properties ;
   char const   *Name ;
   char const   *Maker ;
   char const   *Copyright ;
   unsigned long PortCount ;
   LADSPA_PortDescriptor const   *PortDescriptors ;
   char const   * const  *PortNames ;
   LADSPA_PortRangeHint const   *PortRangeHints ;
   void *ImplementationData ;
   LADSPA_Handle (*instantiate)(struct _LADSPA_Descriptor  const  *Descriptor , unsigned long SampleRate ) ;
   void (*connect_port)(LADSPA_Handle Instance , unsigned long Port , LADSPA_Data *DataLocation ) ;
   void (*activate)(LADSPA_Handle Instance ) ;
   void (*run)(LADSPA_Handle Instance , unsigned long SampleCount ) ;
   void (*run_adding)(LADSPA_Handle Instance , unsigned long SampleCount ) ;
   void (*set_run_adding_gain)(LADSPA_Handle Instance , LADSPA_Data Gain ) ;
   void (*deactivate)(LADSPA_Handle Instance ) ;
   void (*cleanup)(LADSPA_Handle Instance ) ;
};
#line 373 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
typedef struct _LADSPA_Descriptor LADSPA_Descriptor;
#line 41 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
struct __anonstruct_fft_vars_27 {
   int nfft ;
   int numfreqs ;
   float *fft_data ;
};
#line 41 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
typedef struct __anonstruct_fft_vars_27 fft_vars;
#line 179 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
struct __anonstruct_Autotalent_28 {
   LADSPA_Data *m_pfTune ;
   LADSPA_Data *m_pfFixed ;
   LADSPA_Data *m_pfPull ;
   LADSPA_Data *m_pfA ;
   LADSPA_Data *m_pfBb ;
   LADSPA_Data *m_pfB ;
   LADSPA_Data *m_pfC ;
   LADSPA_Data *m_pfDb ;
   LADSPA_Data *m_pfD ;
   LADSPA_Data *m_pfEb ;
   LADSPA_Data *m_pfE ;
   LADSPA_Data *m_pfF ;
   LADSPA_Data *m_pfGb ;
   LADSPA_Data *m_pfG ;
   LADSPA_Data *m_pfAb ;
   LADSPA_Data *m_pfAmount ;
   LADSPA_Data *m_pfSmooth ;
   LADSPA_Data *m_pfShift ;
   LADSPA_Data *m_pfScwarp ;
   LADSPA_Data *m_pfLfoamp ;
   LADSPA_Data *m_pfLforate ;
   LADSPA_Data *m_pfLfoshape ;
   LADSPA_Data *m_pfLfosymm ;
   LADSPA_Data *m_pfLfoquant ;
   LADSPA_Data *m_pfFcorr ;
   LADSPA_Data *m_pfFwarp ;
   LADSPA_Data *m_pfMix ;
   LADSPA_Data *m_pfPitch ;
   LADSPA_Data *m_pfConf ;
   LADSPA_Data *m_pfInputBuffer1 ;
   LADSPA_Data *m_pfOutputBuffer1 ;
   LADSPA_Data *m_pfLatency ;
   fft_vars *fmembvars ;
   unsigned long fs ;
   unsigned long cbsize ;
   unsigned long corrsize ;
   unsigned long cbiwr ;
   unsigned long cbord ;
   float *cbi ;
   float *cbf ;
   float *cbo ;
   float *cbwindow ;
   float *acwinv ;
   float *hannwindow ;
   int noverlap ;
   float *ffttime ;
   float *fftfreqre ;
   float *fftfreqim ;
   float aref ;
   float inpitch ;
   float conf ;
   float outpitch ;
   float vthresh ;
   float pmax ;
   float pmin ;
   unsigned long nmax ;
   unsigned long nmin ;
   float lrshift ;
   int ptarget ;
   float sptarget ;
   float lfophase ;
   float phprdd ;
   double inphinc ;
   double outphinc ;
   double phincfact ;
   double phasein ;
   double phaseout ;
   float *frag ;
   unsigned long fragsize ;
   int ford ;
   float falph ;
   float flamb ;
   float *fk ;
   float *fb ;
   float *fc ;
   float *frb ;
   float *frc ;
   float *fsig ;
   float *fsmooth ;
   float fhp ;
   float flp ;
   float flpa ;
   float **fbuff ;
   float *ftvec ;
   float fmute ;
   float fmutealph ;
};
#line 179 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
typedef struct __anonstruct_Autotalent_28 Autotalent;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 112
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x )  __asm__("__log10_finite")  ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y )  __asm__("__pow_finite")  ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x )  __asm__("__sqrt_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gamma)(double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) lgamma_r)(double  ,
                                                                                  int *__signgamp )  __asm__("__lgamma_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammaf)(float __d ) ;
#line 271
extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__)) lgammaf_r)(float  ,
                                                                                  int *__signgamp )  __asm__("__lgammaf_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammal)(long double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) lgammal_r)(long double  ,
                                                                                        int *__signgamp )  __asm__("__lgammal_r_finite")  ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) 
{ 
  int __local_signgam ;
  double tmp ;

  {
  {
#line 259
  __local_signgam = 0;
#line 260
  tmp = lgamma_r(__d, & __local_signgam);
  }
#line 260
  return ((double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 265
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float tmp ;

  {
  {
#line 268
  __local_signgam = 0;
#line 269
  tmp = lgammaf_r(__d, & __local_signgam);
  }
#line 269
  return ((float __attribute__((__gnu_inline__))  )tmp);
}
}
#line 275
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 275 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double tmp ;

  {
  {
#line 278
  __local_signgam = 0;
#line 279
  tmp = lgammal_r(__d, & __local_signgam);
  }
#line 279
  return ((long double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 427
extern double __gamma_r_finite(double  , int * ) ;
#line 428
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 428 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) 
{ 
  int __local_signgam ;
  double __res ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 430
  __local_signgam = 0;
#line 431
  tmp = __gamma_r_finite(__d, & __local_signgam);
#line 431
  __res = tmp;
  }
#line 432
  if (__local_signgam < 0) {
#line 432
    tmp___0 = - __res;
  } else {
#line 432
    tmp___0 = __res;
  }
#line 432
  return ((double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 434
extern float __gammaf_r_finite(float  , int * ) ;
#line 435
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 435 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float __res ;
  float tmp ;
  float tmp___0 ;

  {
  {
#line 437
  __local_signgam = 0;
#line 438
  tmp = __gammaf_r_finite(__d, & __local_signgam);
#line 438
  __res = tmp;
  }
#line 439
  if (__local_signgam < 0) {
#line 439
    tmp___0 = - __res;
  } else {
#line 439
    tmp___0 = __res;
  }
#line 439
  return ((float __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 442
extern long double __gammal_r_finite(long double  , int * ) ;
#line 443
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 443 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double __res ;
  long double tmp ;
  long double tmp___0 ;

  {
  {
#line 445
  __local_signgam = 0;
#line 449
  tmp = __gammal_r_finite(__d, & __local_signgam);
#line 449
  __res = tmp;
  }
#line 451
  if (__local_signgam < 0) {
#line 451
    tmp___0 = - __res;
  } else {
#line 451
    tmp___0 = __res;
  }
#line 451
  return ((long double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 589 "/home/june/collector/temp/autotalent-0.2/ladspa.h"
LADSPA_Descriptor const   *ladspa_descriptor(unsigned long Index ) ;
#line 6 "/home/june/collector/temp/autotalent-0.2/mayer_fft.h"
void mayer_realfft(int n , float *real ) ;
#line 7
void mayer_realifft(int n , float *real ) ;
#line 49 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
fft_vars *fft_con(int nfft ) 
{ 
  fft_vars *membvars ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 51
  tmp = malloc(sizeof(fft_vars ));
#line 51
  membvars = (fft_vars *)tmp;
#line 53
  membvars->nfft = nfft;
#line 54
  membvars->numfreqs = nfft / 2 + 1;
#line 56
  tmp___0 = calloc((size_t )nfft, sizeof(float ));
#line 56
  membvars->fft_data = (float *)tmp___0;
  }
#line 58
  return (membvars);
}
}
#line 62 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void fft_des(fft_vars *membvars ) 
{ 


  {
  {
#line 64
  free((void *)membvars->fft_data);
#line 66
  free((void *)membvars);
  }
#line 67
  return;
}
}
#line 77 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void fft_forward(fft_vars *membvars , float *input , float *output_re , float *output_im ) 
{ 
  int ti ;
  int nfft ;
  int hnfft ;
  int numfreqs ;

  {
#line 84
  nfft = membvars->nfft;
#line 85
  hnfft = nfft / 2;
#line 86
  numfreqs = membvars->numfreqs;
#line 88
  ti = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (ti < nfft)) {
#line 88
      goto while_break;
    }
#line 89
    *(membvars->fft_data + ti) = *(input + ti);
#line 88
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  mayer_realfft(nfft, membvars->fft_data);
#line 94
  *(output_im + 0) = (float )0;
#line 95
  ti = 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (ti < hnfft)) {
#line 95
      goto while_break___0;
    }
#line 96
    *(output_re + ti) = *(membvars->fft_data + ti);
#line 97
    *(output_im + (ti + 1)) = *(membvars->fft_data + ((nfft - 1) - ti));
#line 95
    ti ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *(output_re + hnfft) = *(membvars->fft_data + hnfft);
#line 100
  *(output_im + hnfft) = (float )0;
#line 101
  return;
}
}
#line 111 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void fft_inverse(fft_vars *membvars , float *input_re , float *input_im , float *output ) 
{ 
  int ti ;
  int nfft ;
  int hnfft ;
  int numfreqs ;

  {
#line 118
  nfft = membvars->nfft;
#line 119
  hnfft = nfft / 2;
#line 120
  numfreqs = membvars->numfreqs;
#line 122
  ti = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (ti < hnfft)) {
#line 122
      goto while_break;
    }
#line 123
    *(membvars->fft_data + ti) = *(input_re + ti);
#line 124
    *(membvars->fft_data + ((nfft - 1) - ti)) = *(input_im + (ti + 1));
#line 122
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  *(membvars->fft_data + hnfft) = *(input_re + hnfft);
#line 128
  mayer_realifft(nfft, membvars->fft_data);
#line 130
  ti = 0;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (ti < nfft)) {
#line 130
      goto while_break___0;
    }
#line 131
    *(output + ti) = *(membvars->fft_data + ti);
#line 130
    ti ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 289 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
LADSPA_Handle instantiateAutotalent(LADSPA_Descriptor const   *Descriptor , unsigned long SampleRate ) 
{ 
  unsigned long ti ;
  Autotalent *membvars ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  double tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  double tmp___17 ;
  void *tmp___18 ;
  double tmp___19 ;
  void *tmp___20 ;
  double tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
  {
#line 295
  tmp = malloc(sizeof(Autotalent ));
#line 295
  membvars = (Autotalent *)tmp;
#line 297
  membvars->aref = (float )440;
#line 299
  membvars->fs = SampleRate;
  }
#line 301
  if (SampleRate >= 88200UL) {
#line 302
    membvars->cbsize = 4096UL;
  } else {
#line 305
    membvars->cbsize = 2048UL;
  }
#line 307
  membvars->corrsize = membvars->cbsize / 2UL + 1UL;
#line 309
  membvars->pmax = (float )1 / (float )70;
#line 310
  membvars->pmin = (float )1 / (float )700;
#line 312
  membvars->nmax = (unsigned long )((float )SampleRate * membvars->pmax);
#line 313
  if (membvars->nmax > membvars->corrsize) {
#line 314
    membvars->nmax = membvars->corrsize;
  }
  {
#line 316
  membvars->nmin = (unsigned long )((float )SampleRate * membvars->pmin);
#line 318
  tmp___0 = calloc(membvars->cbsize, sizeof(float ));
#line 318
  membvars->cbi = (float *)tmp___0;
#line 319
  tmp___1 = calloc(membvars->cbsize, sizeof(float ));
#line 319
  membvars->cbf = (float *)tmp___1;
#line 320
  tmp___2 = calloc(membvars->cbsize, sizeof(float ));
#line 320
  membvars->cbo = (float *)tmp___2;
#line 322
  membvars->cbiwr = 0UL;
#line 323
  membvars->cbord = 0UL;
#line 325
  membvars->lfophase = (float )0;
#line 328
  membvars->ford = 7;
#line 329
  tmp___3 = pow(0.001, (double )((float )80 / (float )SampleRate));
#line 329
  membvars->falph = (float )tmp___3;
#line 330
  tmp___4 = atan(0.06583 * (double )SampleRate);
#line 330
  tmp___5 = sqrt(tmp___4);
#line 330
  membvars->flamb = (float )(- (0.8517 * tmp___5 - 0.1916));
#line 331
  tmp___6 = calloc((size_t )membvars->ford, sizeof(float ));
#line 331
  membvars->fk = (float *)tmp___6;
#line 332
  tmp___7 = calloc((size_t )membvars->ford, sizeof(float ));
#line 332
  membvars->fb = (float *)tmp___7;
#line 333
  tmp___8 = calloc((size_t )membvars->ford, sizeof(float ));
#line 333
  membvars->fc = (float *)tmp___8;
#line 334
  tmp___9 = calloc((size_t )membvars->ford, sizeof(float ));
#line 334
  membvars->frb = (float *)tmp___9;
#line 335
  tmp___10 = calloc((size_t )membvars->ford, sizeof(float ));
#line 335
  membvars->frc = (float *)tmp___10;
#line 336
  tmp___11 = calloc((size_t )membvars->ford, sizeof(float ));
#line 336
  membvars->fsig = (float *)tmp___11;
#line 337
  tmp___12 = calloc((size_t )membvars->ford, sizeof(float ));
#line 337
  membvars->fsmooth = (float *)tmp___12;
#line 338
  membvars->fhp = (float )0;
#line 339
  membvars->flp = (float )0;
#line 340
  tmp___13 = pow(0.001, (double )((float )10 / (float )SampleRate));
#line 340
  membvars->flpa = (float )tmp___13;
#line 341
  tmp___14 = malloc((unsigned long )membvars->ford * sizeof(float *));
#line 341
  membvars->fbuff = (float **)tmp___14;
#line 342
  ti = 0UL;
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (ti < (unsigned long )membvars->ford)) {
#line 342
      goto while_break;
    }
    {
#line 343
    tmp___15 = calloc(membvars->cbsize, sizeof(float ));
#line 343
    *(membvars->fbuff + ti) = (float *)tmp___15;
#line 342
    ti ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  tmp___16 = calloc((size_t )membvars->ford, sizeof(float ));
#line 345
  membvars->ftvec = (float *)tmp___16;
#line 346
  membvars->fmute = (float )1;
#line 347
  tmp___17 = pow(0.001, (double )((float )1 / (float )SampleRate));
#line 347
  membvars->fmutealph = (float )tmp___17;
#line 350
  tmp___18 = calloc(membvars->cbsize, sizeof(float ));
#line 350
  membvars->hannwindow = (float *)tmp___18;
#line 351
  ti = 0UL;
  }
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    if (! (ti < membvars->cbsize)) {
#line 351
      goto while_break___0;
    }
    {
#line 352
    tmp___19 = cos((double )((((float )2 * (float )3.14159265358979323846) * (float )ti) / (float )membvars->cbsize));
#line 352
    *(membvars->hannwindow + ti) = (float )(- 0.5 * tmp___19 + 0.5);
#line 351
    ti ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 356
  tmp___20 = calloc(membvars->cbsize, sizeof(float ));
#line 356
  membvars->cbwindow = (float *)tmp___20;
#line 357
  ti = 0UL;
  }
  {
#line 357
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 357
    if (! (ti < membvars->cbsize / 2UL)) {
#line 357
      goto while_break___1;
    }
    {
#line 358
    tmp___21 = cos((double )((((float )4 * (float )3.14159265358979323846) * (float )ti) / (float )(membvars->cbsize - 1UL)));
#line 358
    *(membvars->cbwindow + (ti + membvars->cbsize / 4UL)) = (float )(- 0.5 * tmp___21 + 0.5);
#line 357
    ti ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 361
  membvars->noverlap = 4;
#line 363
  membvars->fmembvars = fft_con((int )membvars->cbsize);
#line 365
  tmp___22 = calloc(membvars->cbsize, sizeof(float ));
#line 365
  membvars->ffttime = (float *)tmp___22;
#line 366
  tmp___23 = calloc(membvars->corrsize, sizeof(float ));
#line 366
  membvars->fftfreqre = (float *)tmp___23;
#line 367
  tmp___24 = calloc(membvars->corrsize, sizeof(float ));
#line 367
  membvars->fftfreqim = (float *)tmp___24;
#line 371
  tmp___25 = calloc(membvars->cbsize, sizeof(float ));
#line 371
  membvars->acwinv = (float *)tmp___25;
#line 372
  ti = 0UL;
  }
  {
#line 372
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 372
    if (! (ti < membvars->cbsize)) {
#line 372
      goto while_break___2;
    }
#line 373
    *(membvars->ffttime + ti) = *(membvars->cbwindow + ti);
#line 372
    ti ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 375
  fft_forward(membvars->fmembvars, membvars->cbwindow, membvars->fftfreqre, membvars->fftfreqim);
#line 376
  ti = 0UL;
  }
  {
#line 376
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 376
    if (! (ti < membvars->corrsize)) {
#line 376
      goto while_break___3;
    }
#line 377
    *(membvars->fftfreqre + ti) = *(membvars->fftfreqre + ti) * *(membvars->fftfreqre + ti) + *(membvars->fftfreqim + ti) * *(membvars->fftfreqim + ti);
#line 378
    *(membvars->fftfreqim + ti) = (float )0;
#line 376
    ti ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 380
  fft_inverse(membvars->fmembvars, membvars->fftfreqre, membvars->fftfreqim, membvars->ffttime);
#line 381
  ti = 1UL;
  }
  {
#line 381
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 381
    if (! (ti < membvars->cbsize)) {
#line 381
      goto while_break___4;
    }
#line 382
    *(membvars->acwinv + ti) = *(membvars->ffttime + ti) / *(membvars->ffttime + 0);
#line 383
    if ((double )*(membvars->acwinv + ti) > 0.000001) {
#line 384
      *(membvars->acwinv + ti) = (float )1 / *(membvars->acwinv + ti);
    } else {
#line 387
      *(membvars->acwinv + ti) = (float )0;
    }
#line 381
    ti ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 390
  *(membvars->acwinv + 0) = (float )1;
#line 394
  membvars->lrshift = (float )0;
#line 395
  membvars->ptarget = 0;
#line 396
  membvars->sptarget = (float )0;
#line 398
  membvars->vthresh = (float )0.7;
#line 401
  membvars->phprdd = (float )0.01;
#line 402
  membvars->inphinc = (double )((float )1 / (membvars->phprdd * (float )SampleRate));
#line 403
  membvars->phincfact = (double )1;
#line 404
  membvars->phasein = (double )0;
#line 405
  membvars->phaseout = (double )0;
#line 406
  tmp___26 = calloc(membvars->cbsize, sizeof(float ));
#line 406
  membvars->frag = (float *)tmp___26;
#line 407
  membvars->fragsize = 0UL;
  }
#line 410
  return ((LADSPA_Handle )membvars);
}
}
#line 415 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void connectPortToAutotalent(LADSPA_Handle Instance , unsigned long Port , LADSPA_Data *DataLocation ) 
{ 
  Autotalent *psAutotalent ;

  {
#line 422
  psAutotalent = (Autotalent *)Instance;
  {
#line 424
  if (Port == 0UL) {
#line 424
    goto case_0;
  }
#line 427
  if (Port == 1UL) {
#line 427
    goto case_1;
  }
#line 430
  if (Port == 2UL) {
#line 430
    goto case_2;
  }
#line 433
  if (Port == 3UL) {
#line 433
    goto case_3;
  }
#line 436
  if (Port == 4UL) {
#line 436
    goto case_4;
  }
#line 439
  if (Port == 5UL) {
#line 439
    goto case_5;
  }
#line 442
  if (Port == 6UL) {
#line 442
    goto case_6;
  }
#line 445
  if (Port == 7UL) {
#line 445
    goto case_7;
  }
#line 448
  if (Port == 8UL) {
#line 448
    goto case_8;
  }
#line 451
  if (Port == 9UL) {
#line 451
    goto case_9;
  }
#line 454
  if (Port == 10UL) {
#line 454
    goto case_10;
  }
#line 457
  if (Port == 11UL) {
#line 457
    goto case_11;
  }
#line 460
  if (Port == 12UL) {
#line 460
    goto case_12;
  }
#line 463
  if (Port == 13UL) {
#line 463
    goto case_13;
  }
#line 466
  if (Port == 14UL) {
#line 466
    goto case_14;
  }
#line 469
  if (Port == 15UL) {
#line 469
    goto case_15;
  }
#line 472
  if (Port == 16UL) {
#line 472
    goto case_16;
  }
#line 475
  if (Port == 17UL) {
#line 475
    goto case_17;
  }
#line 478
  if (Port == 18UL) {
#line 478
    goto case_18;
  }
#line 481
  if (Port == 19UL) {
#line 481
    goto case_19;
  }
#line 484
  if (Port == 20UL) {
#line 484
    goto case_20;
  }
#line 487
  if (Port == 21UL) {
#line 487
    goto case_21;
  }
#line 490
  if (Port == 22UL) {
#line 490
    goto case_22;
  }
#line 493
  if (Port == 23UL) {
#line 493
    goto case_23;
  }
#line 496
  if (Port == 24UL) {
#line 496
    goto case_24;
  }
#line 499
  if (Port == 25UL) {
#line 499
    goto case_25;
  }
#line 502
  if (Port == 26UL) {
#line 502
    goto case_26;
  }
#line 505
  if (Port == 27UL) {
#line 505
    goto case_27;
  }
#line 508
  if (Port == 28UL) {
#line 508
    goto case_28;
  }
#line 511
  if (Port == 29UL) {
#line 511
    goto case_29;
  }
#line 514
  if (Port == 30UL) {
#line 514
    goto case_30;
  }
#line 517
  if (Port == 31UL) {
#line 517
    goto case_31;
  }
#line 423
  goto switch_break;
  case_0: /* CIL Label */ 
#line 425
  psAutotalent->m_pfTune = DataLocation;
#line 426
  goto switch_break;
  case_1: /* CIL Label */ 
#line 428
  psAutotalent->m_pfFixed = DataLocation;
#line 429
  goto switch_break;
  case_2: /* CIL Label */ 
#line 431
  psAutotalent->m_pfPull = DataLocation;
#line 432
  goto switch_break;
  case_3: /* CIL Label */ 
#line 434
  psAutotalent->m_pfA = DataLocation;
#line 435
  goto switch_break;
  case_4: /* CIL Label */ 
#line 437
  psAutotalent->m_pfBb = DataLocation;
#line 438
  goto switch_break;
  case_5: /* CIL Label */ 
#line 440
  psAutotalent->m_pfB = DataLocation;
#line 441
  goto switch_break;
  case_6: /* CIL Label */ 
#line 443
  psAutotalent->m_pfC = DataLocation;
#line 444
  goto switch_break;
  case_7: /* CIL Label */ 
#line 446
  psAutotalent->m_pfDb = DataLocation;
#line 447
  goto switch_break;
  case_8: /* CIL Label */ 
#line 449
  psAutotalent->m_pfD = DataLocation;
#line 450
  goto switch_break;
  case_9: /* CIL Label */ 
#line 452
  psAutotalent->m_pfEb = DataLocation;
#line 453
  goto switch_break;
  case_10: /* CIL Label */ 
#line 455
  psAutotalent->m_pfE = DataLocation;
#line 456
  goto switch_break;
  case_11: /* CIL Label */ 
#line 458
  psAutotalent->m_pfF = DataLocation;
#line 459
  goto switch_break;
  case_12: /* CIL Label */ 
#line 461
  psAutotalent->m_pfGb = DataLocation;
#line 462
  goto switch_break;
  case_13: /* CIL Label */ 
#line 464
  psAutotalent->m_pfG = DataLocation;
#line 465
  goto switch_break;
  case_14: /* CIL Label */ 
#line 467
  psAutotalent->m_pfAb = DataLocation;
#line 468
  goto switch_break;
  case_15: /* CIL Label */ 
#line 470
  psAutotalent->m_pfAmount = DataLocation;
#line 471
  goto switch_break;
  case_16: /* CIL Label */ 
#line 473
  psAutotalent->m_pfSmooth = DataLocation;
#line 474
  goto switch_break;
  case_17: /* CIL Label */ 
#line 476
  psAutotalent->m_pfShift = DataLocation;
#line 477
  goto switch_break;
  case_18: /* CIL Label */ 
#line 479
  psAutotalent->m_pfScwarp = DataLocation;
#line 480
  goto switch_break;
  case_19: /* CIL Label */ 
#line 482
  psAutotalent->m_pfLfoamp = DataLocation;
#line 483
  goto switch_break;
  case_20: /* CIL Label */ 
#line 485
  psAutotalent->m_pfLforate = DataLocation;
#line 486
  goto switch_break;
  case_21: /* CIL Label */ 
#line 488
  psAutotalent->m_pfLfoshape = DataLocation;
#line 489
  goto switch_break;
  case_22: /* CIL Label */ 
#line 491
  psAutotalent->m_pfLfosymm = DataLocation;
#line 492
  goto switch_break;
  case_23: /* CIL Label */ 
#line 494
  psAutotalent->m_pfLfoquant = DataLocation;
#line 495
  goto switch_break;
  case_24: /* CIL Label */ 
#line 497
  psAutotalent->m_pfFcorr = DataLocation;
#line 498
  goto switch_break;
  case_25: /* CIL Label */ 
#line 500
  psAutotalent->m_pfFwarp = DataLocation;
#line 501
  goto switch_break;
  case_26: /* CIL Label */ 
#line 503
  psAutotalent->m_pfMix = DataLocation;
#line 504
  goto switch_break;
  case_27: /* CIL Label */ 
#line 506
  psAutotalent->m_pfPitch = DataLocation;
#line 507
  goto switch_break;
  case_28: /* CIL Label */ 
#line 509
  psAutotalent->m_pfConf = DataLocation;
#line 510
  goto switch_break;
  case_29: /* CIL Label */ 
#line 512
  psAutotalent->m_pfInputBuffer1 = DataLocation;
#line 513
  goto switch_break;
  case_30: /* CIL Label */ 
#line 515
  psAutotalent->m_pfOutputBuffer1 = DataLocation;
#line 516
  goto switch_break;
  case_31: /* CIL Label */ 
#line 518
  psAutotalent->m_pfLatency = DataLocation;
#line 519
  *(psAutotalent->m_pfLatency) = (LADSPA_Data )(psAutotalent->cbsize - 1UL);
#line 520
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 522
  return;
}
}
#line 526 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void runAutotalent(LADSPA_Handle Instance , unsigned long SampleCount ) 
{ 
  LADSPA_Data *pfInput ;
  LADSPA_Data *pfOutput ;
  float fAmount ;
  float fSmooth ;
  int iNotes[12] ;
  int iPitch2Note[12] ;
  int iNote2Pitch[12] ;
  int numNotes ;
  float fTune ;
  float fFixed ;
  float fPull ;
  float fShift ;
  int iScwarp ;
  float fLfoamp ;
  float fLforate ;
  float fLfoshape ;
  float fLfosymm ;
  int iLfoquant ;
  int iFcorr ;
  float fFwarp ;
  float fMix ;
  Autotalent *psAutotalent ;
  unsigned long lSampleIndex ;
  long N ;
  long Nf ;
  long fs ;
  float pmin ;
  float pmax ;
  unsigned long nmin ;
  unsigned long nmax ;
  long ti ;
  long ti2 ;
  long ti3 ;
  long ti4 ;
  float tf ;
  float tf2 ;
  float indd ;
  int ind0 ;
  int ind1 ;
  int ind2 ;
  int ind3 ;
  float vald ;
  float val0 ;
  float val1 ;
  float val2 ;
  float val3 ;
  int lowersnap ;
  int uppersnap ;
  float lfoval ;
  float pperiod ;
  float inpitch ;
  float conf ;
  float outpitch ;
  float aref ;
  float fa ;
  float fb ;
  float fc ;
  float fk ;
  float flamb ;
  float frlamb ;
  float falph ;
  float foma ;
  float f1resp ;
  float f0resp ;
  float flpa ;
  int ford ;
  double tmp ;
  LADSPA_Data *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  LADSPA_Data *tmp___7 ;

  {
#line 602
  psAutotalent = (Autotalent *)Instance;
#line 604
  pfInput = psAutotalent->m_pfInputBuffer1;
#line 605
  pfOutput = psAutotalent->m_pfOutputBuffer1;
#line 606
  fAmount = *(psAutotalent->m_pfAmount);
#line 607
  fSmooth = (float )((double )*(psAutotalent->m_pfSmooth) * 0.8);
#line 608
  fTune = *(psAutotalent->m_pfTune);
#line 609
  iNotes[0] = (int )*(psAutotalent->m_pfA);
#line 610
  iNotes[1] = (int )*(psAutotalent->m_pfBb);
#line 611
  iNotes[2] = (int )*(psAutotalent->m_pfB);
#line 612
  iNotes[3] = (int )*(psAutotalent->m_pfC);
#line 613
  iNotes[4] = (int )*(psAutotalent->m_pfDb);
#line 614
  iNotes[5] = (int )*(psAutotalent->m_pfD);
#line 615
  iNotes[6] = (int )*(psAutotalent->m_pfEb);
#line 616
  iNotes[7] = (int )*(psAutotalent->m_pfE);
#line 617
  iNotes[8] = (int )*(psAutotalent->m_pfF);
#line 618
  iNotes[9] = (int )*(psAutotalent->m_pfGb);
#line 619
  iNotes[10] = (int )*(psAutotalent->m_pfG);
#line 620
  iNotes[11] = (int )*(psAutotalent->m_pfAb);
#line 621
  fFixed = *(psAutotalent->m_pfFixed);
#line 622
  fPull = *(psAutotalent->m_pfPull);
#line 623
  fShift = *(psAutotalent->m_pfShift);
#line 624
  iScwarp = (int )*(psAutotalent->m_pfScwarp);
#line 625
  fLfoamp = *(psAutotalent->m_pfLfoamp);
#line 626
  fLforate = *(psAutotalent->m_pfLforate);
#line 627
  fLfoshape = *(psAutotalent->m_pfLfoshape);
#line 628
  fLfosymm = *(psAutotalent->m_pfLfosymm);
#line 629
  iLfoquant = (int )*(psAutotalent->m_pfLfoquant);
#line 630
  iFcorr = (int )*(psAutotalent->m_pfFcorr);
#line 631
  fFwarp = *(psAutotalent->m_pfFwarp);
#line 632
  fMix = *(psAutotalent->m_pfMix);
#line 636
  ti2 = 0L;
#line 637
  ti = 0L;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (ti < 12L)) {
#line 637
      goto while_break;
    }
#line 638
    if (iNotes[ti] >= 0) {
#line 639
      iPitch2Note[ti] = (int )ti2;
#line 640
      iNote2Pitch[ti2] = (int )ti;
#line 641
      ti2 ++;
    } else {
#line 644
      iPitch2Note[ti] = -1;
    }
#line 637
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  numNotes = (int )ti2;
  {
#line 648
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 648
    if (! (ti2 < 12L)) {
#line 648
      goto while_break___0;
    }
#line 649
    iNote2Pitch[ti2] = -1;
#line 650
    ti2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 652
  if (numNotes == 0) {
#line 653
    ti = 0L;
    {
#line 653
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 653
      if (! (ti < 12L)) {
#line 653
        goto while_break___1;
      }
#line 654
      iNotes[ti] = 1;
#line 655
      iPitch2Note[ti] = (int )ti;
#line 656
      iNote2Pitch[ti] = (int )ti;
#line 653
      ti ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 658
    numNotes = 12;
  }
  {
#line 660
  iScwarp = (iScwarp + numNotes * 5) % numNotes;
#line 662
  ford = psAutotalent->ford;
#line 663
  falph = psAutotalent->falph;
#line 664
  foma = (float )1 - falph;
#line 665
  flpa = psAutotalent->flpa;
#line 666
  flamb = psAutotalent->flamb;
#line 667
  tmp = pow((double )((float )2), (double )(fFwarp / (float )2));
#line 667
  tf = (float )((tmp * (double )((float )1 + flamb)) / (double )((float )1 - flamb));
#line 668
  frlamb = (tf - (float )1) / (tf + (float )1);
#line 670
  psAutotalent->aref = fTune;
#line 672
  N = (long )psAutotalent->cbsize;
#line 673
  Nf = (long )psAutotalent->corrsize;
#line 674
  fs = (long )psAutotalent->fs;
#line 676
  pmax = psAutotalent->pmax;
#line 677
  pmin = psAutotalent->pmin;
#line 678
  nmax = psAutotalent->nmax;
#line 679
  nmin = psAutotalent->nmin;
#line 681
  aref = psAutotalent->aref;
#line 682
  pperiod = psAutotalent->pmax;
#line 683
  inpitch = psAutotalent->inpitch;
#line 684
  conf = psAutotalent->conf;
#line 685
  outpitch = psAutotalent->outpitch;
#line 691
  lSampleIndex = 0UL;
  }
  {
#line 691
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 691
    if (! (lSampleIndex < SampleCount)) {
#line 691
      goto while_break___2;
    }
#line 694
    tmp___0 = pfInput;
#line 694
    pfInput ++;
#line 694
    tf = *tmp___0;
#line 695
    ti4 = (long )psAutotalent->cbiwr;
#line 696
    *(psAutotalent->cbi + ti4) = tf;
#line 698
    if (iFcorr >= 1) {
#line 703
      fa = tf - psAutotalent->fhp;
#line 704
      psAutotalent->fhp = tf;
#line 705
      fb = fa;
#line 706
      ti = 0L;
      {
#line 706
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 706
        if (! (ti < (long )ford)) {
#line 706
          goto while_break___3;
        }
#line 707
        *(psAutotalent->fsig + ti) = (fa * fa) * foma + *(psAutotalent->fsig + ti) * falph;
#line 708
        fc = (fb - *(psAutotalent->fc + ti)) * flamb + *(psAutotalent->fb + ti);
#line 709
        *(psAutotalent->fc + ti) = fc;
#line 710
        *(psAutotalent->fb + ti) = fb;
#line 711
        fk = (fa * fc) * foma + *(psAutotalent->fk + ti) * falph;
#line 712
        *(psAutotalent->fk + ti) = fk;
#line 713
        tf = (float )((double )fk / ((double )*(psAutotalent->fsig + ti) + 0.000001));
#line 714
        tf = tf * foma + *(psAutotalent->fsmooth + ti) * falph;
#line 715
        *(psAutotalent->fsmooth + ti) = tf;
#line 716
        *(*(psAutotalent->fbuff + ti) + ti4) = tf;
#line 717
        fb = fc - tf * fa;
#line 718
        fa -= tf * fc;
#line 706
        ti ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 720
      *(psAutotalent->cbf + ti4) = fa;
    } else {
#line 725
      *(psAutotalent->cbf + ti4) = tf;
    }
#line 730
    (psAutotalent->cbiwr) ++;
#line 731
    if (psAutotalent->cbiwr >= (unsigned long )N) {
#line 732
      psAutotalent->cbiwr = 0UL;
    }
#line 741
    if (psAutotalent->cbiwr % (unsigned long )(N / (long )psAutotalent->noverlap) == 0UL) {
#line 746
      ti2 = (long )psAutotalent->cbiwr;
#line 747
      ti = 0L;
      {
#line 747
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 747
        if (! (ti < N)) {
#line 747
          goto while_break___4;
        }
#line 748
        *(psAutotalent->ffttime + ti) = *(psAutotalent->cbi + ((ti2 - ti) + N) % N) * *(psAutotalent->cbwindow + ti);
#line 747
        ti ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 752
      fft_forward(psAutotalent->fmembvars, psAutotalent->ffttime, psAutotalent->fftfreqre,
                  psAutotalent->fftfreqim);
#line 755
      *(psAutotalent->fftfreqre + 0) = (float )0;
#line 756
      *(psAutotalent->fftfreqim + 0) = (float )0;
#line 759
      ti = 1L;
      }
      {
#line 759
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 759
        if (! (ti < Nf)) {
#line 759
          goto while_break___5;
        }
#line 760
        *(psAutotalent->fftfreqre + ti) = *(psAutotalent->fftfreqre + ti) * *(psAutotalent->fftfreqre + ti) + *(psAutotalent->fftfreqim + ti) * *(psAutotalent->fftfreqim + ti);
#line 761
        *(psAutotalent->fftfreqim + ti) = (float )0;
#line 759
        ti ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 765
      fft_inverse(psAutotalent->fmembvars, psAutotalent->fftfreqre, psAutotalent->fftfreqim,
                  psAutotalent->ffttime);
#line 768
      tf = (float )1 / *(psAutotalent->ffttime + 0);
#line 769
      ti = 1L;
      }
      {
#line 769
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 769
        if (! (ti < N)) {
#line 769
          goto while_break___6;
        }
#line 770
        *(psAutotalent->ffttime + ti) *= tf;
#line 769
        ti ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 772
      *(psAutotalent->ffttime + 0) = (float )1;
#line 783
      tf2 = (float )0;
#line 784
      pperiod = pmin;
#line 785
      ti = (long )nmin;
      {
#line 785
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 785
        if (! ((unsigned long )ti < nmax)) {
#line 785
          goto while_break___7;
        }
#line 786
        ti2 = ti - 1L;
#line 787
        ti3 = ti + 1L;
#line 788
        if (ti2 < 0L) {
#line 789
          ti2 = 0L;
        }
#line 791
        if (ti3 > Nf) {
#line 792
          ti3 = Nf;
        }
#line 794
        tf = *(psAutotalent->ffttime + ti);
#line 796
        if (tf > *(psAutotalent->ffttime + ti2)) {
#line 796
          if (tf >= *(psAutotalent->ffttime + ti3)) {
#line 796
            if (tf > tf2) {
#line 797
              tf2 = tf;
#line 798
              ti4 = ti;
            }
          }
        }
#line 785
        ti ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 801
      if (tf2 > (float )0) {
#line 802
        conf = tf2 * *(psAutotalent->acwinv + ti4);
#line 803
        if (ti4 > 0L) {
#line 803
          if (ti4 < Nf) {
#line 805
            tf = *(psAutotalent->ffttime + (ti4 - 1L)) * (float )(ti4 - 1L);
#line 806
            tf += *(psAutotalent->ffttime + ti4) * (float )ti4;
#line 807
            tf += *(psAutotalent->ffttime + (ti4 + 1L)) * (float )(ti4 + 1L);
#line 808
            tf /= (*(psAutotalent->ffttime + (ti4 - 1L)) + *(psAutotalent->ffttime + ti4)) + *(psAutotalent->ffttime + (ti4 + 1L));
#line 809
            pperiod = tf / (float )fs;
          } else {
#line 812
            pperiod = (float )ti4 / (float )fs;
          }
        } else {
#line 812
          pperiod = (float )ti4 / (float )fs;
        }
      }
      {
#line 817
      tmp___1 = log10((double )(aref * pperiod));
#line 817
      tf = (float )(((double )((float )-12) * tmp___1) * (double )((float )3.32192809488736218171));
      }
#line 818
      if (conf >= psAutotalent->vthresh) {
#line 819
        inpitch = tf;
#line 820
        psAutotalent->inpitch = tf;
      }
#line 822
      psAutotalent->conf = conf;
#line 824
      *(psAutotalent->m_pfPitch) = inpitch;
#line 825
      *(psAutotalent->m_pfConf) = conf;
#line 832
      outpitch = inpitch;
#line 835
      outpitch = ((float )1 - fPull) * outpitch + fPull * fFixed;
#line 838
      ti = (long )((int )(outpitch / (float )12 + (float )32) - 32);
#line 839
      tf = outpitch - (float )(ti * 12L);
#line 840
      ti2 = (long )((int )tf);
#line 841
      ti3 = ti2 + 1L;
#line 843
      if (iNotes[ti2 % 12L] < 0) {
#line 844
        lowersnap = 1;
#line 845
        uppersnap = 1;
      } else
#line 843
      if (iNotes[ti3 % 12L] < 0) {
#line 844
        lowersnap = 1;
#line 845
        uppersnap = 1;
      } else {
#line 848
        lowersnap = 0;
#line 849
        uppersnap = 0;
#line 850
        if (iNotes[ti2 % 12L] == 1) {
#line 851
          lowersnap = 1;
        }
#line 853
        if (iNotes[ti3 % 12L] == 1) {
#line 854
          uppersnap = 1;
        }
      }
      {
#line 859
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 859
        if (! (iNotes[(ti2 + 12L) % 12L] < 0)) {
#line 859
          goto while_break___8;
        }
#line 860
        ti2 --;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 863
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 863
        if (! (iNotes[ti3 % 12L] < 0)) {
#line 863
          goto while_break___9;
        }
#line 864
        ti3 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 866
      tf = (tf - (float )ti2) / (float )(ti3 - ti2) + (float )iPitch2Note[(ti2 + 12L) % 12L];
#line 867
      if (ti2 < 0L) {
#line 868
        tf -= (float )numNotes;
      }
#line 870
      outpitch = tf + (float )((long )numNotes * ti);
#line 874
      ti = (long )((int )(outpitch + (float )128) - 128);
#line 875
      tf = (float )((double )(outpitch - (float )ti) - 0.5);
#line 876
      ti2 = ti3 - ti2;
#line 877
      if (ti2 > 2L) {
#line 878
        tf2 = (float )ti2 / (float )2;
      } else {
#line 881
        tf2 = (float )1;
      }
#line 883
      if ((double )fSmooth < 0.001) {
#line 884
        tf2 = (float )((double )(tf * tf2) / 0.001);
      } else {
#line 887
        tf2 = (tf * tf2) / fSmooth;
      }
#line 889
      if ((double )tf2 < - 0.5) {
#line 889
        tf2 = (float )(- 0.5);
      }
#line 890
      if ((double )tf2 > 0.5) {
#line 890
        tf2 = (float )0.5;
      }
      {
#line 891
      tmp___2 = sin((double )((float )3.14159265358979323846 * tf2));
#line 891
      tf2 = (float )(0.5 * tmp___2 + 0.5);
#line 892
      tf2 += (float )ti;
      }
#line 893
      if ((double )tf < 0.5) {
#line 893
        if (lowersnap) {
#line 894
          outpitch = fAmount * tf2 + ((float )1 - fAmount) * outpitch;
        } else {
#line 893
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 893
      if ((double )tf >= 0.5) {
#line 893
        if (uppersnap) {
#line 894
          outpitch = fAmount * tf2 + ((float )1 - fAmount) * outpitch;
        }
      }
#line 898
      outpitch += fShift;
#line 901
      tf = (fLforate * (float )N) / (float )((long )psAutotalent->noverlap * fs);
#line 902
      if (tf > (float )1) {
#line 902
        tf = (float )1;
      }
#line 903
      psAutotalent->lfophase += tf;
#line 904
      if (psAutotalent->lfophase > (float )1) {
#line 904
        psAutotalent->lfophase -= (float )1;
      }
#line 905
      lfoval = psAutotalent->lfophase;
#line 906
      tf = (fLfosymm + (float )1) / (float )2;
#line 907
      if (tf <= (float )0) {
#line 907
        goto _L___0;
      } else
#line 907
      if (tf >= (float )1) {
        _L___0: /* CIL Label */ 
#line 908
        if (tf <= (float )0) {
#line 908
          lfoval = (float )1 - lfoval;
        }
      } else
#line 911
      if (lfoval <= tf) {
#line 912
        lfoval /= tf;
      } else {
#line 915
        lfoval = (float )1 - (lfoval - tf) / ((float )1 - tf);
      }
#line 918
      if (fLfoshape >= (float )0) {
        {
#line 920
        tmp___3 = cos((double )(lfoval * (float )3.14159265358979323846));
#line 920
        lfoval = (float )((0.5 - 0.5 * tmp___3) * (double )fLfoshape + (double )(lfoval * ((float )1 - fLfoshape)));
#line 921
        lfoval = fLfoamp * (lfoval * (float )2 - (float )1);
        }
      } else {
#line 925
        tf = (float )1 + fLfoshape;
#line 926
        if ((double )tf < 0.001) {
#line 927
          lfoval = (float )((((double )lfoval - 0.5) * (double )2) / 0.001);
        } else {
#line 930
          lfoval = (float )((((double )lfoval - 0.5) * (double )2) / (double )tf);
        }
#line 932
        if (lfoval > (float )1) {
#line 932
          lfoval = (float )1;
        }
#line 933
        if (lfoval < (float )-1) {
#line 933
          lfoval = (float )-1;
        }
        {
#line 934
        tmp___4 = sin((double )(lfoval * (float )3.14159265358979323846) * 0.5);
#line 934
        lfoval = (float )((double )fLfoamp * tmp___4);
        }
      }
#line 937
      if (iLfoquant >= 1) {
#line 938
        outpitch = (outpitch + (float )((int )((double )((float )numNotes * lfoval + (float )numNotes) + 0.5))) - (float )numNotes;
      }
#line 943
      outpitch += (float )iScwarp;
#line 944
      ti = (long )((int )(outpitch / (float )numNotes + (float )32) - 32);
#line 945
      tf = outpitch - (float )(ti * (long )numNotes);
#line 946
      ti2 = (long )((int )tf);
#line 947
      ti3 = ti2 + 1L;
#line 948
      outpitch = (float )(iNote2Pitch[ti3 % (long )numNotes] - iNote2Pitch[ti2]);
#line 949
      if (ti3 >= (long )numNotes) {
#line 950
        outpitch += (float )12;
      }
#line 952
      outpitch = outpitch * (tf - (float )ti2) + (float )iNote2Pitch[ti2];
#line 953
      outpitch += (float )(12L * ti);
#line 954
      outpitch -= (float )(iNote2Pitch[iScwarp] - iNote2Pitch[0]);
#line 957
      if (iLfoquant <= 0) {
#line 958
        outpitch += lfoval * (float )2;
      }
#line 962
      if (outpitch < (float )-36) {
#line 962
        outpitch = (float )-48;
      }
#line 963
      if (outpitch > (float )24) {
#line 963
        outpitch = (float )24;
      }
      {
#line 965
      psAutotalent->outpitch = outpitch;
#line 970
      tmp___5 = pow((double )2, (double )(inpitch / (float )12));
#line 970
      psAutotalent->inphinc = ((double )aref * tmp___5) / (double )fs;
#line 971
      tmp___6 = pow((double )2, (double )(outpitch / (float )12));
#line 971
      psAutotalent->outphinc = ((double )aref * tmp___6) / (double )fs;
#line 972
      psAutotalent->phincfact = psAutotalent->outphinc / psAutotalent->inphinc;
      }
    }
#line 986
    psAutotalent->phasein += psAutotalent->inphinc;
#line 987
    psAutotalent->phaseout += psAutotalent->outphinc;
#line 990
    if (psAutotalent->phasein >= (double )1) {
#line 991
      psAutotalent->phasein -= (double )1;
#line 992
      ti2 = (long )(psAutotalent->cbiwr - (unsigned long )(N / 2L));
#line 993
      ti = - N / 2L;
      {
#line 993
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 993
        if (! (ti < N / 2L)) {
#line 993
          goto while_break___10;
        }
#line 994
        *(psAutotalent->frag + (ti + N) % N) = *(psAutotalent->cbf + ((ti + ti2) + N) % N);
#line 993
        ti ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 999
    if (psAutotalent->phaseout >= (double )1) {
#line 1000
      psAutotalent->fragsize *= 2UL;
#line 1001
      if (psAutotalent->fragsize > (unsigned long )N) {
#line 1002
        psAutotalent->fragsize = (unsigned long )N;
      }
#line 1004
      psAutotalent->phaseout -= (double )1;
#line 1005
      ti2 = (long )(psAutotalent->cbord + (unsigned long )(N / 2L));
#line 1006
      ti3 = (long )((double )((float )psAutotalent->fragsize) / psAutotalent->phincfact);
#line 1007
      if (ti3 >= N / 2L) {
#line 1008
        ti3 = N / 2L - 1L;
      }
#line 1010
      ti = - ti3 / 2L;
      {
#line 1010
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1010
        if (! (ti < ti3 / 2L)) {
#line 1010
          goto while_break___11;
        }
#line 1011
        tf = *(psAutotalent->hannwindow + (N / 2L + (ti * N) / ti3));
#line 1013
        indd = (float )(psAutotalent->phincfact * (double )ti);
#line 1014
        ind1 = (int )indd;
#line 1015
        ind2 = ind1 + 1;
#line 1016
        ind3 = ind1 + 2;
#line 1017
        ind0 = ind1 - 1;
#line 1018
        val0 = *(psAutotalent->frag + ((long )ind0 + N) % N);
#line 1019
        val1 = *(psAutotalent->frag + ((long )ind1 + N) % N);
#line 1020
        val2 = *(psAutotalent->frag + ((long )ind2 + N) % N);
#line 1021
        val3 = *(psAutotalent->frag + ((long )ind3 + N) % N);
#line 1022
        vald = (float )0;
#line 1023
        vald -= ((((float )0.166666666667 * val0) * (indd - (float )ind1)) * (indd - (float )ind2)) * (indd - (float )ind3);
#line 1024
        vald += ((((float )0.5 * val1) * (indd - (float )ind0)) * (indd - (float )ind2)) * (indd - (float )ind3);
#line 1025
        vald -= ((((float )0.5 * val2) * (indd - (float )ind0)) * (indd - (float )ind1)) * (indd - (float )ind3);
#line 1026
        vald += ((((float )0.166666666667 * val3) * (indd - (float )ind0)) * (indd - (float )ind1)) * (indd - (float )ind2);
#line 1027
        *(psAutotalent->cbo + ((ti + ti2) + N) % N) += vald * tf;
#line 1010
        ti ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1029
      psAutotalent->fragsize = 0UL;
    }
#line 1031
    (psAutotalent->fragsize) ++;
#line 1034
    tf = *(psAutotalent->cbo + psAutotalent->cbord);
#line 1036
    *(psAutotalent->cbo + psAutotalent->cbord) = (float )0;
#line 1037
    (psAutotalent->cbord) ++;
#line 1038
    if (psAutotalent->cbord >= (unsigned long )N) {
#line 1039
      psAutotalent->cbord = 0UL;
    }
#line 1046
    ti4 = (long )((psAutotalent->cbiwr + 2UL) % (unsigned long )N);
#line 1047
    if (iFcorr >= 1) {
#line 1055
      tf2 = tf;
#line 1056
      fa = (float )0;
#line 1057
      fb = fa;
#line 1058
      ti = 0L;
      {
#line 1058
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1058
        if (! (ti < (long )ford)) {
#line 1058
          goto while_break___12;
        }
#line 1059
        fc = (fb - *(psAutotalent->frc + ti)) * frlamb + *(psAutotalent->frb + ti);
#line 1060
        tf = *(*(psAutotalent->fbuff + ti) + ti4);
#line 1061
        fb = fc - tf * fa;
#line 1062
        *(psAutotalent->ftvec + ti) = tf * fc;
#line 1063
        fa -= *(psAutotalent->ftvec + ti);
#line 1058
        ti ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1065
      tf = - fa;
#line 1066
      ti = (long )(ford - 1);
      {
#line 1066
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1066
        if (! (ti >= 0L)) {
#line 1066
          goto while_break___13;
        }
#line 1067
        tf += *(psAutotalent->ftvec + ti);
#line 1066
        ti --;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1069
      f0resp = tf;
#line 1071
      fa = (float )1;
#line 1072
      fb = fa;
#line 1073
      ti = 0L;
      {
#line 1073
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1073
        if (! (ti < (long )ford)) {
#line 1073
          goto while_break___14;
        }
#line 1074
        fc = (fb - *(psAutotalent->frc + ti)) * frlamb + *(psAutotalent->frb + ti);
#line 1075
        tf = *(*(psAutotalent->fbuff + ti) + ti4);
#line 1076
        fb = fc - tf * fa;
#line 1077
        *(psAutotalent->ftvec + ti) = tf * fc;
#line 1078
        fa -= *(psAutotalent->ftvec + ti);
#line 1073
        ti ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1080
      tf = - fa;
#line 1081
      ti = (long )(ford - 1);
      {
#line 1081
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1081
        if (! (ti >= 0L)) {
#line 1081
          goto while_break___15;
        }
#line 1082
        tf += *(psAutotalent->ftvec + ti);
#line 1081
        ti --;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1084
      f1resp = tf;
#line 1086
      tf = (float )2 * tf2;
#line 1087
      tf2 = tf;
#line 1088
      tf = ((float )1 - f1resp) + f0resp;
#line 1089
      if (tf != (float )0) {
#line 1090
        tf2 = (tf2 + f0resp) / tf;
      } else {
#line 1093
        tf2 = (float )0;
      }
#line 1096
      fa = tf2;
#line 1097
      fb = fa;
#line 1098
      ti = 0L;
      {
#line 1098
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1098
        if (! (ti < (long )ford)) {
#line 1098
          goto while_break___16;
        }
#line 1099
        fc = (fb - *(psAutotalent->frc + ti)) * frlamb + *(psAutotalent->frb + ti);
#line 1100
        *(psAutotalent->frc + ti) = fc;
#line 1101
        *(psAutotalent->frb + ti) = fb;
#line 1102
        tf = *(*(psAutotalent->fbuff + ti) + ti4);
#line 1103
        fb = fc - tf * fa;
#line 1104
        fa -= tf * fc;
#line 1098
        ti ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1106
      tf = tf2;
#line 1107
      tf += flpa * psAutotalent->flp;
#line 1108
      psAutotalent->flp = tf;
#line 1111
      if ((double )psAutotalent->fmute > 0.5) {
#line 1112
        tf = (float )(((double )tf * ((double )psAutotalent->fmute - 0.5)) * (double )2);
      } else {
#line 1115
        tf = (float )0;
      }
#line 1117
      tf2 = psAutotalent->fmutealph;
#line 1118
      psAutotalent->fmute = ((float )1 - tf2) + tf2 * psAutotalent->fmute;
    } else {
#line 1123
      psAutotalent->fmute = (float )0;
    }
#line 1128
    tmp___7 = pfOutput;
#line 1128
    pfOutput ++;
#line 1128
    *tmp___7 = fMix * tf + ((float )1 - fMix) * *(psAutotalent->cbi + ti4);
#line 691
    lSampleIndex ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1133
  *(psAutotalent->m_pfLatency) = (LADSPA_Data )(N - 1L);
#line 1134
  return;
}
}
#line 1141 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void cleanupAutotalent(LADSPA_Handle Instance ) 
{ 
  int ti ;

  {
  {
#line 1144
  fft_des(((Autotalent *)Instance)->fmembvars);
#line 1145
  free((void *)((Autotalent *)Instance)->cbi);
#line 1146
  free((void *)((Autotalent *)Instance)->cbf);
#line 1147
  free((void *)((Autotalent *)Instance)->cbo);
#line 1148
  free((void *)((Autotalent *)Instance)->cbwindow);
#line 1149
  free((void *)((Autotalent *)Instance)->hannwindow);
#line 1150
  free((void *)((Autotalent *)Instance)->acwinv);
#line 1151
  free((void *)((Autotalent *)Instance)->frag);
#line 1152
  free((void *)((Autotalent *)Instance)->ffttime);
#line 1153
  free((void *)((Autotalent *)Instance)->fftfreqre);
#line 1154
  free((void *)((Autotalent *)Instance)->fftfreqim);
#line 1155
  free((void *)((Autotalent *)Instance)->fk);
#line 1156
  free((void *)((Autotalent *)Instance)->fb);
#line 1157
  free((void *)((Autotalent *)Instance)->fc);
#line 1158
  free((void *)((Autotalent *)Instance)->frb);
#line 1159
  free((void *)((Autotalent *)Instance)->frc);
#line 1160
  free((void *)((Autotalent *)Instance)->fsmooth);
#line 1161
  free((void *)((Autotalent *)Instance)->fsig);
#line 1162
  ti = 0;
  }
  {
#line 1162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1162
    if (! (ti < ((Autotalent *)Instance)->ford)) {
#line 1162
      goto while_break;
    }
    {
#line 1163
    free((void *)*(((Autotalent *)Instance)->fbuff + ti));
#line 1162
    ti ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1165
  free((void *)((Autotalent *)Instance)->fbuff);
#line 1166
  free((void *)((Autotalent *)Instance)->ftvec);
#line 1167
  free((void *)((Autotalent *)Instance));
  }
#line 1168
  return;
}
}
#line 1171 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
LADSPA_Descriptor *g_psDescriptor  ;
#line 1174 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void _init(void) 
{ 
  char **pcPortNames ;
  LADSPA_PortDescriptor *piPortDescriptors ;
  LADSPA_PortRangeHint *psPortRangeHints ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1181
  tmp = malloc(sizeof(LADSPA_Descriptor ));
#line 1181
  g_psDescriptor = (LADSPA_Descriptor *)tmp;
  }
#line 1184
  if (g_psDescriptor) {
    {
#line 1186
    g_psDescriptor->UniqueID = 4262UL;
#line 1188
    tmp___0 = strdup("autotalent");
#line 1188
    g_psDescriptor->Label = (char const   *)tmp___0;
#line 1190
    g_psDescriptor->Properties = 4;
#line 1192
    tmp___1 = strdup("Autotalent");
#line 1192
    g_psDescriptor->Name = (char const   *)tmp___1;
#line 1194
    tmp___2 = strdup("Tom Baran");
#line 1194
    g_psDescriptor->Maker = (char const   *)tmp___2;
#line 1196
    tmp___3 = strdup("2010");
#line 1196
    g_psDescriptor->Copyright = (char const   *)tmp___3;
#line 1198
    g_psDescriptor->PortCount = 32UL;
#line 1200
    tmp___4 = calloc((size_t )32, sizeof(LADSPA_PortDescriptor ));
#line 1200
    piPortDescriptors = (LADSPA_PortDescriptor *)tmp___4;
#line 1202
    g_psDescriptor->PortDescriptors = (LADSPA_PortDescriptor const   *)piPortDescriptors;
#line 1204
    *(piPortDescriptors + 0) = 5;
#line 1206
    *(piPortDescriptors + 1) = 5;
#line 1208
    *(piPortDescriptors + 2) = 5;
#line 1210
    *(piPortDescriptors + 3) = 5;
#line 1212
    *(piPortDescriptors + 4) = 5;
#line 1214
    *(piPortDescriptors + 5) = 5;
#line 1216
    *(piPortDescriptors + 6) = 5;
#line 1218
    *(piPortDescriptors + 7) = 5;
#line 1220
    *(piPortDescriptors + 8) = 5;
#line 1222
    *(piPortDescriptors + 9) = 5;
#line 1224
    *(piPortDescriptors + 10) = 5;
#line 1226
    *(piPortDescriptors + 11) = 5;
#line 1228
    *(piPortDescriptors + 12) = 5;
#line 1230
    *(piPortDescriptors + 13) = 5;
#line 1232
    *(piPortDescriptors + 14) = 5;
#line 1234
    *(piPortDescriptors + 15) = 5;
#line 1236
    *(piPortDescriptors + 16) = 5;
#line 1238
    *(piPortDescriptors + 17) = 5;
#line 1240
    *(piPortDescriptors + 18) = 5;
#line 1242
    *(piPortDescriptors + 19) = 5;
#line 1244
    *(piPortDescriptors + 20) = 5;
#line 1246
    *(piPortDescriptors + 21) = 5;
#line 1248
    *(piPortDescriptors + 22) = 5;
#line 1250
    *(piPortDescriptors + 23) = 5;
#line 1252
    *(piPortDescriptors + 24) = 5;
#line 1254
    *(piPortDescriptors + 25) = 5;
#line 1256
    *(piPortDescriptors + 26) = 5;
#line 1258
    *(piPortDescriptors + 27) = 6;
#line 1260
    *(piPortDescriptors + 28) = 6;
#line 1262
    *(piPortDescriptors + 29) = 9;
#line 1264
    *(piPortDescriptors + 30) = 10;
#line 1266
    *(piPortDescriptors + 31) = 6;
#line 1268
    tmp___5 = calloc((size_t )32, sizeof(char *));
#line 1268
    pcPortNames = (char **)tmp___5;
#line 1270
    g_psDescriptor->PortNames = (char const   * const  *)((char const   **)pcPortNames);
#line 1272
    *(pcPortNames + 0) = strdup("Concert A (Hz)");
#line 1274
    *(pcPortNames + 1) = strdup("Fixed pitch (semitones w.r.t. A)");
#line 1276
    *(pcPortNames + 2) = strdup("Pull to fixed pitch");
#line 1278
    *(pcPortNames + 3) = strdup("A");
#line 1280
    *(pcPortNames + 4) = strdup("Bb");
#line 1282
    *(pcPortNames + 5) = strdup("B");
#line 1284
    *(pcPortNames + 6) = strdup("C");
#line 1286
    *(pcPortNames + 7) = strdup("Db");
#line 1288
    *(pcPortNames + 8) = strdup("D");
#line 1290
    *(pcPortNames + 9) = strdup("Eb");
#line 1292
    *(pcPortNames + 10) = strdup("E");
#line 1294
    *(pcPortNames + 11) = strdup("F");
#line 1296
    *(pcPortNames + 12) = strdup("Gb");
#line 1298
    *(pcPortNames + 13) = strdup("G");
#line 1300
    *(pcPortNames + 14) = strdup("Ab");
#line 1302
    *(pcPortNames + 15) = strdup("Correction strength");
#line 1304
    *(pcPortNames + 16) = strdup("Correction smoothness");
#line 1306
    *(pcPortNames + 17) = strdup("Pitch shift (scale notes)");
#line 1308
    *(pcPortNames + 18) = strdup("Output scale rotate (scale notes)");
#line 1310
    *(pcPortNames + 19) = strdup("LFO depth");
#line 1312
    *(pcPortNames + 20) = strdup("LFO rate (Hz)");
#line 1314
    *(pcPortNames + 21) = strdup("LFO shape (square->sine->tri)");
#line 1316
    *(pcPortNames + 22) = strdup("LFO symmetry");
#line 1318
    *(pcPortNames + 23) = strdup("LFO quantization");
#line 1320
    *(pcPortNames + 24) = strdup("Formant correction");
#line 1322
    *(pcPortNames + 25) = strdup("Formant warp");
#line 1324
    *(pcPortNames + 26) = strdup("Mix");
#line 1326
    *(pcPortNames + 27) = strdup("Detected pitch (semitones w.r.t. A)");
#line 1328
    *(pcPortNames + 28) = strdup("Pitch detection confidence");
#line 1330
    *(pcPortNames + 29) = strdup("Input");
#line 1332
    *(pcPortNames + 30) = strdup("Output");
#line 1334
    *(pcPortNames + 31) = strdup("latency");
#line 1336
    tmp___6 = calloc((size_t )32, sizeof(LADSPA_PortRangeHint ));
#line 1336
    psPortRangeHints = (LADSPA_PortRangeHint *)tmp___6;
#line 1338
    g_psDescriptor->PortRangeHints = (LADSPA_PortRangeHint const   *)psPortRangeHints;
#line 1340
    (psPortRangeHints + 0)->HintDescriptor = 707;
#line 1344
    (psPortRangeHints + 0)->LowerBound = (LADSPA_Data )400;
#line 1346
    (psPortRangeHints + 0)->UpperBound = (LADSPA_Data )480;
#line 1348
    (psPortRangeHints + 1)->HintDescriptor = 515;
#line 1352
    (psPortRangeHints + 1)->LowerBound = (LADSPA_Data )-36;
#line 1354
    (psPortRangeHints + 1)->UpperBound = (LADSPA_Data )12;
#line 1356
    (psPortRangeHints + 2)->HintDescriptor = 515;
#line 1360
    (psPortRangeHints + 2)->LowerBound = (LADSPA_Data )0;
#line 1362
    (psPortRangeHints + 2)->UpperBound = (LADSPA_Data )1;
#line 1364
    (psPortRangeHints + 3)->HintDescriptor = 547;
#line 1369
    (psPortRangeHints + 3)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1371
    (psPortRangeHints + 3)->UpperBound = (LADSPA_Data )1.1;
#line 1373
    (psPortRangeHints + 4)->HintDescriptor = 99;
#line 1378
    (psPortRangeHints + 4)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1380
    (psPortRangeHints + 4)->UpperBound = (LADSPA_Data )1.1;
#line 1382
    (psPortRangeHints + 5)->HintDescriptor = 547;
#line 1387
    (psPortRangeHints + 5)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1389
    (psPortRangeHints + 5)->UpperBound = (LADSPA_Data )1.1;
#line 1391
    (psPortRangeHints + 6)->HintDescriptor = 547;
#line 1396
    (psPortRangeHints + 6)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1398
    (psPortRangeHints + 6)->UpperBound = (LADSPA_Data )1.1;
#line 1400
    (psPortRangeHints + 7)->HintDescriptor = 99;
#line 1405
    (psPortRangeHints + 7)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1407
    (psPortRangeHints + 7)->UpperBound = (LADSPA_Data )1.1;
#line 1409
    (psPortRangeHints + 8)->HintDescriptor = 547;
#line 1414
    (psPortRangeHints + 8)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1416
    (psPortRangeHints + 8)->UpperBound = (LADSPA_Data )1.1;
#line 1418
    (psPortRangeHints + 9)->HintDescriptor = 99;
#line 1423
    (psPortRangeHints + 9)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1425
    (psPortRangeHints + 9)->UpperBound = (LADSPA_Data )1.1;
#line 1427
    (psPortRangeHints + 10)->HintDescriptor = 547;
#line 1432
    (psPortRangeHints + 10)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1434
    (psPortRangeHints + 10)->UpperBound = (LADSPA_Data )1.1;
#line 1436
    (psPortRangeHints + 11)->HintDescriptor = 547;
#line 1441
    (psPortRangeHints + 11)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1443
    (psPortRangeHints + 11)->UpperBound = (LADSPA_Data )1.1;
#line 1445
    (psPortRangeHints + 12)->HintDescriptor = 99;
#line 1450
    (psPortRangeHints + 12)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1452
    (psPortRangeHints + 12)->UpperBound = (LADSPA_Data )1.1;
#line 1454
    (psPortRangeHints + 13)->HintDescriptor = 547;
#line 1459
    (psPortRangeHints + 13)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1461
    (psPortRangeHints + 13)->UpperBound = (LADSPA_Data )1.1;
#line 1463
    (psPortRangeHints + 14)->HintDescriptor = 99;
#line 1468
    (psPortRangeHints + 14)->LowerBound = (LADSPA_Data )(- 1.1);
#line 1470
    (psPortRangeHints + 14)->UpperBound = (LADSPA_Data )1.1;
#line 1472
    (psPortRangeHints + 15)->HintDescriptor = 579;
#line 1476
    (psPortRangeHints + 15)->LowerBound = (LADSPA_Data )0;
#line 1478
    (psPortRangeHints + 15)->UpperBound = (LADSPA_Data )1;
#line 1480
    (psPortRangeHints + 16)->HintDescriptor = 515;
#line 1484
    (psPortRangeHints + 16)->LowerBound = (LADSPA_Data )0;
#line 1486
    (psPortRangeHints + 16)->UpperBound = (LADSPA_Data )1;
#line 1488
    (psPortRangeHints + 17)->HintDescriptor = 515;
#line 1492
    (psPortRangeHints + 17)->LowerBound = (LADSPA_Data )-12;
#line 1494
    (psPortRangeHints + 17)->UpperBound = (LADSPA_Data )12;
#line 1496
    (psPortRangeHints + 18)->HintDescriptor = 547;
#line 1501
    (psPortRangeHints + 18)->LowerBound = (LADSPA_Data )(- 5.1);
#line 1503
    (psPortRangeHints + 18)->UpperBound = (LADSPA_Data )5.1;
#line 1505
    (psPortRangeHints + 19)->HintDescriptor = 515;
#line 1509
    (psPortRangeHints + 19)->LowerBound = (LADSPA_Data )0;
#line 1511
    (psPortRangeHints + 19)->UpperBound = (LADSPA_Data )1;
#line 1513
    (psPortRangeHints + 20)->HintDescriptor = 195;
#line 1517
    (psPortRangeHints + 20)->LowerBound = (LADSPA_Data )0;
#line 1519
    (psPortRangeHints + 20)->UpperBound = (LADSPA_Data )10;
#line 1521
    (psPortRangeHints + 21)->HintDescriptor = 515;
#line 1525
    (psPortRangeHints + 21)->LowerBound = (LADSPA_Data )-1;
#line 1527
    (psPortRangeHints + 21)->UpperBound = (LADSPA_Data )1;
#line 1529
    (psPortRangeHints + 22)->HintDescriptor = 515;
#line 1533
    (psPortRangeHints + 22)->LowerBound = (LADSPA_Data )-1;
#line 1535
    (psPortRangeHints + 22)->UpperBound = (LADSPA_Data )1;
#line 1537
    (psPortRangeHints + 23)->HintDescriptor = 516;
#line 1540
    (psPortRangeHints + 24)->HintDescriptor = 516;
#line 1543
    (psPortRangeHints + 25)->HintDescriptor = 515;
#line 1547
    (psPortRangeHints + 25)->LowerBound = (LADSPA_Data )-1;
#line 1549
    (psPortRangeHints + 25)->UpperBound = (LADSPA_Data )1;
#line 1551
    (psPortRangeHints + 26)->HintDescriptor = 579;
#line 1555
    (psPortRangeHints + 26)->LowerBound = (LADSPA_Data )0;
#line 1557
    (psPortRangeHints + 26)->UpperBound = (LADSPA_Data )1;
#line 1559
    (psPortRangeHints + 27)->HintDescriptor = 0;
#line 1561
    (psPortRangeHints + 28)->HintDescriptor = 0;
#line 1563
    (psPortRangeHints + 29)->HintDescriptor = 0;
#line 1565
    (psPortRangeHints + 30)->HintDescriptor = 0;
#line 1567
    (psPortRangeHints + 31)->HintDescriptor = 0;
#line 1570
    g_psDescriptor->instantiate = & instantiateAutotalent;
#line 1572
    g_psDescriptor->connect_port = & connectPortToAutotalent;
#line 1574
    g_psDescriptor->activate = (void (*)(LADSPA_Handle Instance ))((void *)0);
#line 1576
    g_psDescriptor->run = & runAutotalent;
#line 1578
    g_psDescriptor->run_adding = (void (*)(LADSPA_Handle Instance , unsigned long SampleCount ))((void *)0);
#line 1580
    g_psDescriptor->set_run_adding_gain = (void (*)(LADSPA_Handle Instance , LADSPA_Data Gain ))((void *)0);
#line 1582
    g_psDescriptor->deactivate = (void (*)(LADSPA_Handle Instance ))((void *)0);
#line 1584
    g_psDescriptor->cleanup = & cleanupAutotalent;
    }
  }
#line 1588
  return;
}
}
#line 1592 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void deleteDescriptor(LADSPA_Descriptor *psDescriptor ) 
{ 
  unsigned long lIndex ;

  {
#line 1595
  if (psDescriptor) {
    {
#line 1596
    free((void *)((char *)psDescriptor->Label));
#line 1597
    free((void *)((char *)psDescriptor->Name));
#line 1598
    free((void *)((char *)psDescriptor->Maker));
#line 1599
    free((void *)((char *)psDescriptor->Copyright));
#line 1600
    free((void *)((LADSPA_PortDescriptor *)psDescriptor->PortDescriptors));
#line 1601
    lIndex = 0UL;
    }
    {
#line 1601
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1601
      if (! (lIndex < psDescriptor->PortCount)) {
#line 1601
        goto while_break;
      }
      {
#line 1602
      free((void *)((char *)*(psDescriptor->PortNames + lIndex)));
#line 1601
      lIndex ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1603
    free((void *)((char **)psDescriptor->PortNames));
#line 1604
    free((void *)((LADSPA_PortRangeHint *)psDescriptor->PortRangeHints));
#line 1605
    free((void *)psDescriptor);
    }
  }
#line 1607
  return;
}
}
#line 1611 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
void _fini(void) 
{ 


  {
  {
#line 1613
  deleteDescriptor(g_psDescriptor);
  }
#line 1614
  return;
}
}
#line 1618 "/home/june/collector/temp/autotalent-0.2/autotalent.c"
LADSPA_Descriptor const   *ladspa_descriptor(unsigned long Index ) 
{ 


  {
  {
#line 1621
  if (Index == 0UL) {
#line 1621
    goto case_0;
  }
#line 1623
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1622
  return ((LADSPA_Descriptor const   *)g_psDescriptor);
  switch_default: /* CIL Label */ 
#line 1624
  return ((LADSPA_Descriptor const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 114 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
static float halsec[20]  = 
#line 114 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
  {      (float )0,      (float )0,      (float ).54119610014619698439972320536638942006107206337801,      (float ).50979557910415916894193980398784391368261849190893, 
        (float ).50241928618815570551167011928012092247859337193963,      (float ).50060299823519630134550410676638239611758632599591,      (float ).50015063602065098821477101271097658495974913010340,      (float ).50003765191554772296778139077905492847503165398345, 
        (float ).50000941253588775676512870469186533538523133757983,      (float ).50000235310628608051401267171204408939326297376426,      (float ).50000058827484117879868526730916804925780637276181,      (float ).50000014706860214875463798283871198206179118093251, 
        (float ).50000003676714377807315864400643020315103490883972,      (float ).50000000919178552207366560348853455333939112569380,      (float ).50000000229794635411562887767906868558991922348920,      (float ).50000000057448658687873302235147272458812263401372};
#line 133 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
static float costab[20]  = 
#line 133
  {      (float ).00000000000000000000000000000000000000000000000000,      (float ).70710678118654752440084436210484903928483593768847,      (float ).92387953251128675612818318939678828682241662586364,      (float ).98078528040323044912618223613423903697393373089333, 
        (float ).99518472667219688624483695310947992157547486872985,      (float ).99879545620517239271477160475910069444320361470461,      (float ).99969881869620422011576564966617219685006108125772,      (float ).99992470183914454092164649119638322435060646880221, 
        (float ).99998117528260114265699043772856771617391725094433,      (float ).99999529380957617151158012570011989955298763362218,      (float ).99999882345170190992902571017152601904826792288976,      (float ).99999970586288221916022821773876567711626389934930, 
        (float ).99999992646571785114473148070738785694820115568892,      (float ).99999998161642929380834691540290971450507605124278,      (float ).99999999540410731289097193313960614895889430318945,      (float ).99999999885102682756267330779455410840053741619428};
#line 152 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
static float sintab[20]  = 
#line 152
  {      (float )1.0000000000000000000000000000000000000000000000000,      (float ).70710678118654752440084436210484903928483593768846,      (float ).38268343236508977172845998403039886676134456248561,      (float ).19509032201612826784828486847702224092769161775195, 
        (float ).09801714032956060199419556388864184586113667316749,      (float ).04906767432741801425495497694268265831474536302574,      (float ).02454122852291228803173452945928292506546611923944,      (float ).01227153828571992607940826195100321214037231959176, 
        (float ).00613588464915447535964023459037258091705788631738,      (float ).00306795676296597627014536549091984251894461021344,      (float ).00153398018628476561230369715026407907995486457522,      (float ).00076699031874270452693856835794857664314091945205, 
        (float ).00038349518757139558907246168118138126339502603495,      (float ).00019174759731070330743990956198900093346887403385,      (float ).00009587379909597734587051721097647635118706561284,      (float ).00004793689960306688454900399049465887274686668768};
#line 171 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
static float coswrk[20]  = 
#line 171
  {      (float ).00000000000000000000000000000000000000000000000000,      (float ).70710678118654752440084436210484903928483593768847,      (float ).92387953251128675612818318939678828682241662586364,      (float ).98078528040323044912618223613423903697393373089333, 
        (float ).99518472667219688624483695310947992157547486872985,      (float ).99879545620517239271477160475910069444320361470461,      (float ).99969881869620422011576564966617219685006108125772,      (float ).99992470183914454092164649119638322435060646880221, 
        (float ).99998117528260114265699043772856771617391725094433,      (float ).99999529380957617151158012570011989955298763362218,      (float ).99999882345170190992902571017152601904826792288976,      (float ).99999970586288221916022821773876567711626389934930, 
        (float ).99999992646571785114473148070738785694820115568892,      (float ).99999998161642929380834691540290971450507605124278,      (float ).99999999540410731289097193313960614895889430318945,      (float ).99999999885102682756267330779455410840053741619428};
#line 190 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
static float sinwrk[20]  = 
#line 190
  {      (float )1.0000000000000000000000000000000000000000000000000,      (float ).70710678118654752440084436210484903928483593768846,      (float ).38268343236508977172845998403039886676134456248561,      (float ).19509032201612826784828486847702224092769161775195, 
        (float ).09801714032956060199419556388864184586113667316749,      (float ).04906767432741801425495497694268265831474536302574,      (float ).02454122852291228803173452945928292506546611923944,      (float ).01227153828571992607940826195100321214037231959176, 
        (float ).00613588464915447535964023459037258091705788631738,      (float ).00306795676296597627014536549091984251894461021344,      (float ).00153398018628476561230369715026407907995486457522,      (float ).00076699031874270452693856835794857664314091945205, 
        (float ).00038349518757139558907246168118138126339502603495,      (float ).00019174759731070330743990956198900093346887403385,      (float ).00009587379909597734587051721097647635118706561284,      (float ).00004793689960306688454900399049465887274686668768};
#line 214 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
void mayer_fht(float *fz , int n ) 
{ 
  int k ;
  int k1 ;
  int k2 ;
  int k3 ;
  int k4 ;
  int kx ;
  float *fi ;
  float *fn ;
  float *gi ;
  int t_lam ;
  float aa ;
  float f0 ;
  float f1 ;
  float f2 ;
  float f3 ;
  float bs1 ;
  float bc1 ;
  float bs2 ;
  float bc2 ;
  float bs3 ;
  float bc3 ;
  float bs4 ;
  float bc4 ;
  float bg0 ;
  float bf0 ;
  float bf1 ;
  float bg1 ;
  float bf2 ;
  float bg2 ;
  float bf3 ;
  float bg3 ;
  float s1 ;
  float c1 ;
  int ii ;
  float g0 ;
  float f0___0 ;
  float f1___0 ;
  float g1 ;
  float f2___0 ;
  float g2 ;
  float f3___0 ;
  float g3 ;
  int i ;
  float c2 ;
  float s2 ;
  int i___0 ;
  int j ;
  float a ;
  float b ;
  float g0___0 ;
  float f0___1 ;
  float f1___1 ;
  float g1___0 ;
  float f2___1 ;
  float g2___0 ;
  float f3___1 ;
  float g3___0 ;

  {
#line 221
  t_lam = 0;
#line 223
  k1 = 1;
#line 223
  k2 = 0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (k1 < n)) {
#line 223
      goto while_break;
    }
#line 226
    k = n >> 1;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      k2 ^= k;
#line 226
      if (k2 & k) {
#line 226
        goto while_break___0;
      }
#line 226
      k >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 227
    if (k1 > k2) {
#line 229
      aa = *(fz + k1);
#line 229
      *(fz + k1) = *(fz + k2);
#line 229
      *(fz + k2) = aa;
    }
#line 223
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  k = 0;
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (! (1 << k < n)) {
#line 232
      goto while_break___1;
    }
#line 232
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 233
  k &= 1;
#line 234
  if (k == 0) {
#line 236
    fi = fz;
#line 236
    fn = fz + n;
    {
#line 236
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 236
      if (! ((unsigned long )fi < (unsigned long )fn)) {
#line 236
        goto while_break___2;
      }
#line 239
      f1 = *(fi + 0) - *(fi + 1);
#line 240
      f0 = *(fi + 0) + *(fi + 1);
#line 241
      f3 = *(fi + 2) - *(fi + 3);
#line 242
      f2 = *(fi + 2) + *(fi + 3);
#line 243
      *(fi + 2) = f0 - f2;
#line 244
      *(fi + 0) = f0 + f2;
#line 245
      *(fi + 3) = f1 - f3;
#line 246
      *(fi + 1) = f1 + f3;
#line 236
      fi += 4;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 251
    fi = fz;
#line 251
    fn = fz + n;
#line 251
    gi = fi + 1;
    {
#line 251
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 251
      if (! ((unsigned long )fi < (unsigned long )fn)) {
#line 251
        goto while_break___3;
      }
#line 255
      bc1 = *(fi + 0) - *(gi + 0);
#line 256
      bs1 = *(fi + 0) + *(gi + 0);
#line 257
      bc2 = *(fi + 2) - *(gi + 2);
#line 258
      bs2 = *(fi + 2) + *(gi + 2);
#line 259
      bc3 = *(fi + 4) - *(gi + 4);
#line 260
      bs3 = *(fi + 4) + *(gi + 4);
#line 261
      bc4 = *(fi + 6) - *(gi + 6);
#line 262
      bs4 = *(fi + 6) + *(gi + 6);
#line 263
      bf1 = bs1 - bs2;
#line 264
      bf0 = bs1 + bs2;
#line 265
      bg1 = bc1 - bc2;
#line 266
      bg0 = bc1 + bc2;
#line 267
      bf3 = bs3 - bs4;
#line 268
      bf2 = bs3 + bs4;
#line 269
      bg3 = (float )(((double )2 * 0.70710678118654752440084436210484) * (double )bc4);
#line 270
      bg2 = (float )(((double )2 * 0.70710678118654752440084436210484) * (double )bc3);
#line 271
      *(fi + 4) = bf0 - bf2;
#line 272
      *(fi + 0) = bf0 + bf2;
#line 273
      *(fi + 6) = bf1 - bf3;
#line 274
      *(fi + 2) = bf1 + bf3;
#line 275
      *(gi + 4) = bg0 - bg2;
#line 276
      *(gi + 0) = bg0 + bg2;
#line 277
      *(gi + 6) = bg1 - bg3;
#line 278
      *(gi + 2) = bg1 + bg3;
#line 251
      fi += 8;
#line 251
      gi += 8;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 281
  if (n < 16) {
#line 281
    return;
  }
  {
#line 283
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 287
    k += 2;
#line 288
    k1 = 1 << k;
#line 289
    k2 = k1 << 1;
#line 290
    k4 = k2 << 1;
#line 291
    k3 = k2 + k1;
#line 292
    kx = k1 >> 1;
#line 293
    fi = fz;
#line 294
    gi = fi + kx;
#line 295
    fn = fz + n;
    {
#line 296
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 299
      f1___0 = *(fi + 0) - *(fi + k1);
#line 300
      f0___0 = *(fi + 0) + *(fi + k1);
#line 301
      f3___0 = *(fi + k2) - *(fi + k3);
#line 302
      f2___0 = *(fi + k2) + *(fi + k3);
#line 303
      *(fi + k2) = f0___0 - f2___0;
#line 304
      *(fi + 0) = f0___0 + f2___0;
#line 305
      *(fi + k3) = f1___0 - f3___0;
#line 306
      *(fi + k1) = f1___0 + f3___0;
#line 307
      g1 = *(gi + 0) - *(gi + k1);
#line 308
      g0 = *(gi + 0) + *(gi + k1);
#line 309
      g3 = (float )(((double )2 * 0.70710678118654752440084436210484) * (double )*(gi + k3));
#line 310
      g2 = (float )(((double )2 * 0.70710678118654752440084436210484) * (double )*(gi + k2));
#line 311
      *(gi + k2) = g0 - g2;
#line 312
      *(gi + 0) = g0 + g2;
#line 313
      *(gi + k3) = g1 - g3;
#line 314
      *(gi + k1) = g1 + g3;
#line 315
      gi += k4;
#line 316
      fi += k4;
#line 296
      if (! ((unsigned long )fi < (unsigned long )fn)) {
#line 296
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 318
    i = 2;
    {
#line 318
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 318
      if (! (i <= k)) {
#line 318
        goto while_break___6;
      }
#line 318
      coswrk[i] = costab[i];
#line 318
      sinwrk[i] = sintab[i];
#line 318
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 318
    t_lam = 0;
#line 318
    c1 = (float )1;
#line 318
    s1 = (float )0;
#line 319
    ii = 1;
    {
#line 319
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 319
      if (! (ii < kx)) {
#line 319
        goto while_break___7;
      }
#line 322
      t_lam ++;
#line 322
      i___0 = 0;
      {
#line 322
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 322
        if (! (! ((1 << i___0) & t_lam))) {
#line 322
          goto while_break___8;
        }
#line 322
        i___0 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 322
      i___0 = k - i___0;
#line 322
      s1 = sinwrk[i___0];
#line 322
      c1 = coswrk[i___0];
#line 322
      if (i___0 > 1) {
#line 322
        j = (k - i___0) + 2;
        {
#line 322
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 322
          if (! ((1 << j) & t_lam)) {
#line 322
            goto while_break___9;
          }
#line 322
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 322
        j = k - j;
#line 322
        sinwrk[i___0] = halsec[i___0] * (sinwrk[i___0 - 1] + sinwrk[j]);
#line 322
        coswrk[i___0] = halsec[i___0] * (coswrk[i___0 - 1] + coswrk[j]);
      }
#line 323
      c2 = c1 * c1 - s1 * s1;
#line 324
      s2 = (float )2 * (c1 * s1);
#line 325
      fn = fz + n;
#line 326
      fi = fz + ii;
#line 327
      gi = (fz + k1) - ii;
      {
#line 328
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 331
        b = s2 * *(fi + k1) - c2 * *(gi + k1);
#line 332
        a = c2 * *(fi + k1) + s2 * *(gi + k1);
#line 333
        f1___1 = *(fi + 0) - a;
#line 334
        f0___1 = *(fi + 0) + a;
#line 335
        g1___0 = *(gi + 0) - b;
#line 336
        g0___0 = *(gi + 0) + b;
#line 337
        b = s2 * *(fi + k3) - c2 * *(gi + k3);
#line 338
        a = c2 * *(fi + k3) + s2 * *(gi + k3);
#line 339
        f3___1 = *(fi + k2) - a;
#line 340
        f2___1 = *(fi + k2) + a;
#line 341
        g3___0 = *(gi + k2) - b;
#line 342
        g2___0 = *(gi + k2) + b;
#line 343
        b = s1 * f2___1 - c1 * g3___0;
#line 344
        a = c1 * f2___1 + s1 * g3___0;
#line 345
        *(fi + k2) = f0___1 - a;
#line 346
        *(fi + 0) = f0___1 + a;
#line 347
        *(gi + k3) = g1___0 - b;
#line 348
        *(gi + k1) = g1___0 + b;
#line 349
        b = c1 * g2___0 - s1 * f3___1;
#line 350
        a = s1 * g2___0 + c1 * f3___1;
#line 351
        *(gi + k2) = g0___0 - a;
#line 352
        *(gi + 0) = g0___0 + a;
#line 353
        *(fi + k3) = f1___1 - b;
#line 354
        *(fi + k1) = f1___1 + b;
#line 355
        gi += k4;
#line 356
        fi += k4;
#line 328
        if (! ((unsigned long )fi < (unsigned long )fn)) {
#line 328
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 319
      ii ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 283
    if (! (k4 < n)) {
#line 283
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 363 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
void mayer_fft(int n , float *real , float *imag ) 
{ 
  float a ;
  float b ;
  float c ;
  float d ;
  float q ;
  float r ;
  float s ;
  float t ;
  int i ;
  int j ;
  int k ;

  {
#line 368
  i = 1;
#line 368
  j = n - 1;
#line 368
  k = n / 2;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < k)) {
#line 368
      goto while_break;
    }
#line 369
    a = *(real + i);
#line 369
    b = *(real + j);
#line 369
    q = a + b;
#line 369
    r = a - b;
#line 370
    c = *(imag + i);
#line 370
    d = *(imag + j);
#line 370
    s = c + d;
#line 370
    t = c - d;
#line 371
    *(real + i) = (float )((double )(q + t) * .5);
#line 371
    *(real + j) = (float )((double )(q - t) * .5);
#line 372
    *(imag + i) = (float )((double )(s - r) * .5);
#line 372
    *(imag + j) = (float )((double )(s + r) * .5);
#line 368
    i ++;
#line 368
    j --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  mayer_fht(real, n);
#line 375
  mayer_fht(imag, n);
  }
#line 376
  return;
}
}
#line 378 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
void mayer_ifft(int n , float *real , float *imag ) 
{ 
  float a ;
  float b ;
  float c ;
  float d ;
  float q ;
  float r ;
  float s ;
  float t ;
  int i ;
  int j ;
  int k ;

  {
  {
#line 383
  mayer_fht(real, n);
#line 384
  mayer_fht(imag, n);
#line 385
  i = 1;
#line 385
  j = n - 1;
#line 385
  k = n / 2;
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (i < k)) {
#line 385
      goto while_break;
    }
#line 386
    a = *(real + i);
#line 386
    b = *(real + j);
#line 386
    q = a + b;
#line 386
    r = a - b;
#line 387
    c = *(imag + i);
#line 387
    d = *(imag + j);
#line 387
    s = c + d;
#line 387
    t = c - d;
#line 388
    *(imag + i) = (float )((double )(s + r) * 0.5);
#line 388
    *(imag + j) = (float )((double )(s - r) * 0.5);
#line 389
    *(real + i) = (float )((double )(q - t) * 0.5);
#line 389
    *(real + j) = (float )((double )(q + t) * 0.5);
#line 385
    i ++;
#line 385
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return;
}
}
#line 393 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
void mayer_realfft(int n , float *real ) 
{ 
  float a ;
  float b ;
  int i ;
  int j ;
  int k ;

  {
  {
#line 398
  mayer_fht(real, n);
#line 399
  i = 1;
#line 399
  j = n - 1;
#line 399
  k = n / 2;
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i < k)) {
#line 399
      goto while_break;
    }
#line 400
    a = *(real + i);
#line 401
    b = *(real + j);
#line 402
    *(real + j) = (float )((double )(a - b) * 0.5);
#line 403
    *(real + i) = (float )((double )(a + b) * 0.5);
#line 399
    i ++;
#line 399
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return;
}
}
#line 407 "/home/june/collector/temp/autotalent-0.2/mayer_fft.c"
void mayer_realifft(int n , float *real ) 
{ 
  float a ;
  float b ;
  int i ;
  int j ;
  int k ;

  {
#line 412
  i = 1;
#line 412
  j = n - 1;
#line 412
  k = n / 2;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (i < k)) {
#line 412
      goto while_break;
    }
#line 413
    a = *(real + i);
#line 414
    b = *(real + j);
#line 415
    *(real + j) = a - b;
#line 416
    *(real + i) = a + b;
#line 412
    i ++;
#line 412
    j --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  mayer_fht(real, n);
  }
#line 419
  return;
}
}
