/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 43 "./libcompat/regions.h"
struct region_;
#line 43 "./libcompat/regions.h"
typedef struct region_ *region;
#line 53 "./libcompat/regions.h"
typedef int type_t;
#line 42 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nconfig.h"
typedef long long largest_int;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nconfig.h"
typedef unsigned long long largest_uint;
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nconfig.h"
typedef unsigned char bool;
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cstring.h"
struct __anonstruct_cstring_25 {
   char *data ;
   int length ;
};
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cstring.h"
typedef struct __anonstruct_cstring_25 cstring;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
struct typelist;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef struct typelist *typelist;
#line 27
struct type;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef struct type *type;
#line 28
struct known_cst;
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef struct known_cst *known_cst;
#line 29
struct ivalue;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef struct ivalue *ivalue;
#line 36
struct AST_node;
#line 34 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
struct dd_list;
#line 34 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
typedef struct dd_list *dd_list;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/graph.h"
struct gnode;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/graph.h"
typedef struct gnode *gnode;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
enum __anonenum_source_language_27 {
    l_c = 0,
    l_interface = 1,
    l_component = 2,
    l_implementation = 3,
    l_parameter = 4,
    l_type = 5,
    l_any = 6
} ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
typedef enum __anonenum_source_language_27 source_language;
#line 29
struct nesc_declaration;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
struct location {
   char const   *filename ;
   struct nesc_declaration *container ;
   unsigned long lineno ;
   bool in_system_header ;
};
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
typedef struct location *location;
#line 44
enum rid {
    RID_UNUSED = 0,
    RID_INT = 1,
    RID_CHAR = 2,
    RID_FLOAT = 3,
    RID_DOUBLE = 4,
    RID_VOID = 5,
    RID_UNSIGNED = 6,
    RID_SHORT = 7,
    RID_LONG = 8,
    RID_SIGNED = 9,
    RID_COMPLEX = 10,
    RID_LASTTYPE = 11,
    RID_INLINE = 11,
    RID_DEFAULT = 12,
    RID_NORACE = 13,
    RID_AUTO = 14,
    RID_STATIC = 15,
    RID_EXTERN = 16,
    RID_REGISTER = 17,
    RID_TYPEDEF = 18,
    RID_COMMAND = 19,
    RID_EVENT = 20,
    RID_TASK = 21,
    RID_ASYNC = 22,
    RID_MAX = 23,
    RID_NESC = 256
} ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-ndoc.h"
struct docstring {
   char const   *short_s ;
   char const   *long_s ;
   location loc ;
};
#line 39
struct data_declaration;
#line 40
struct AST_function_declarator;
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_node *node;
#line 5
struct AST_declaration;
#line 5 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_declaration *declaration;
#line 6
struct AST_statement;
#line 6 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_statement *statement;
#line 7
struct AST_expression;
#line 7 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_expression *expression;
#line 8
struct AST_type_element;
#line 8 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_type_element *type_element;
#line 9
struct AST_declarator;
#line 9 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_declarator *declarator;
#line 10
struct AST_label;
#line 10 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_label *label;
#line 11
struct AST_asm_decl;
#line 11 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_asm_decl *asm_decl;
#line 12
struct AST_data_decl;
#line 12 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_data_decl *data_decl;
#line 13
struct AST_extension_decl;
#line 13 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_extension_decl *extension_decl;
#line 14
struct AST_ellipsis_decl;
#line 14 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_ellipsis_decl *ellipsis_decl;
#line 17
struct AST_function_decl;
#line 17 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_function_decl *function_decl;
#line 20
struct AST_field_decl;
#line 20 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_field_decl *field_decl;
#line 21
struct AST_asttype;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_asttype *asttype;
#line 22
struct AST_typename;
#line 22 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_typename *typename;
#line 23
struct AST_typeof_expr;
#line 23 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_typeof_expr *typeof_expr;
#line 24
struct AST_typeof_type;
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_typeof_type *typeof_type;
#line 25
struct AST_attribute;
#line 25 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_attribute *attribute;
#line 26
struct AST_gcc_attribute;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_gcc_attribute *gcc_attribute;
#line 27
struct AST_rid;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_rid *rid;
#line 28
struct AST_qualifier;
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_qualifier *qualifier;
#line 29
struct AST_tag_ref;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_tag_ref *tag_ref;
#line 32
struct AST_nested_declarator;
#line 32 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_nested_declarator *nested_declarator;
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_function_declarator *function_declarator;
#line 34
struct AST_pointer_declarator;
#line 34 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_pointer_declarator *pointer_declarator;
#line 35
struct AST_qualified_declarator;
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_qualified_declarator *qualified_declarator;
#line 36
struct AST_array_declarator;
#line 36 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_array_declarator *array_declarator;
#line 37
struct AST_identifier_declarator;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_identifier_declarator *identifier_declarator;
#line 38
struct AST_asm_stmt;
#line 38 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_asm_stmt *asm_stmt;
#line 39
struct AST_compound_stmt;
#line 39 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_compound_stmt *compound_stmt;
#line 40
struct AST_if_stmt;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_if_stmt *if_stmt;
#line 41
struct AST_labeled_stmt;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_labeled_stmt *labeled_stmt;
#line 42
struct AST_expression_stmt;
#line 42 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_expression_stmt *expression_stmt;
#line 43
struct AST_conditional_stmt;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_conditional_stmt *conditional_stmt;
#line 44
struct AST_switch_stmt;
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_switch_stmt *switch_stmt;
#line 45
struct AST_for_stmt;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_for_stmt *for_stmt;
#line 46
struct AST_break_stmt;
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_break_stmt *break_stmt;
#line 47
struct AST_continue_stmt;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_continue_stmt *continue_stmt;
#line 49
struct AST_goto_stmt;
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_goto_stmt *goto_stmt;
#line 50
struct AST_computed_goto_stmt;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_computed_goto_stmt *computed_goto_stmt;
#line 51
struct AST_empty_stmt;
#line 51 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_empty_stmt *empty_stmt;
#line 63
struct AST_function_call;
#line 63 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_function_call *function_call;
#line 70
struct AST_designator;
#line 70 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_designator *designator;
#line 73
struct AST_lexical_cst;
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_lexical_cst *lexical_cst;
#line 74
struct AST_string_cst;
#line 74 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_string_cst *string_cst;
#line 75
struct AST_string;
#line 75 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_string *string;
#line 76
struct AST_id_label;
#line 76 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_id_label *id_label;
#line 77
struct AST_case_label;
#line 77 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_case_label *case_label;
#line 78
struct AST_default_label;
#line 78 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_default_label *default_label;
#line 79
struct AST_word;
#line 79 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_word *word;
#line 80
struct AST_asm_operand;
#line 80 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_asm_operand *asm_operand;
#line 81
struct AST_nesc_decl;
#line 81 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_nesc_decl *nesc_decl;
#line 82
struct AST_interface;
#line 82 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_interface *interface;
#line 83
struct AST_component;
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_component *component;
#line 84
struct AST_implementation;
#line 84 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_implementation *implementation;
#line 85
struct AST_configuration;
#line 85 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_configuration *configuration;
#line 86
struct AST_module;
#line 86 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_module *module;
#line 87
struct AST_binary_component;
#line 87 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary_component *binary_component;
#line 88
struct AST_rp_interface;
#line 88 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_rp_interface *rp_interface;
#line 89
struct AST_interface_ref;
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_interface_ref *interface_ref;
#line 90
struct AST_component_ref;
#line 90 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_component_ref *component_ref;
#line 91
struct AST_connection;
#line 91 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_connection *connection;
#line 92
struct AST_endpoint;
#line 92 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_endpoint *endpoint;
#line 93
struct AST_parameterised_identifier;
#line 93 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_parameterised_identifier *parameterised_identifier;
#line 99
struct AST_component_typeref;
#line 99 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_component_typeref *component_typeref;
#line 100
struct AST_atomic_stmt;
#line 100 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_atomic_stmt *atomic_stmt;
#line 101
struct AST_nesc_attribute;
#line 101 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_nesc_attribute *nesc_attribute;
#line 104 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_declaration *error_decl;
#line 107 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_statement *error_stmt;
#line 108 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_conditional_stmt *while_stmt;
#line 109 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_conditional_stmt *dowhile_stmt;
#line 157 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_connection *rp_connection;
#line 158 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_connection *eq_connection;
#line 161 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_gcc_attribute *target_attribute;
#line 162
enum __anonenum_AST_kind_28 {
    kind_node = 42,
    postkind_node = 199,
    kind_declaration = 43,
    postkind_declaration = 64,
    kind_statement = 65,
    postkind_statement = 83,
    kind_expression = 84,
    postkind_expression = 156,
    kind_type_element = 157,
    postkind_type_element = 174,
    kind_declarator = 175,
    postkind_declarator = 183,
    kind_label = 184,
    postkind_label = 187,
    kind_asm_decl = 44,
    postkind_asm_decl = 44,
    kind_data_decl = 45,
    postkind_data_decl = 45,
    kind_extension_decl = 46,
    postkind_extension_decl = 46,
    kind_ellipsis_decl = 47,
    postkind_ellipsis_decl = 47,
    kind_enumerator = 48,
    postkind_enumerator = 48,
    kind_oldidentifier_decl = 49,
    postkind_oldidentifier_decl = 49,
    kind_function_decl = 50,
    postkind_function_decl = 50,
    kind_implicit_decl = 51,
    postkind_implicit_decl = 51,
    kind_variable_decl = 52,
    postkind_variable_decl = 52,
    kind_field_decl = 53,
    postkind_field_decl = 53,
    kind_asttype = 188,
    postkind_asttype = 188,
    kind_typename = 158,
    postkind_typename = 159,
    kind_typeof_expr = 160,
    postkind_typeof_expr = 160,
    kind_typeof_type = 161,
    postkind_typeof_type = 161,
    kind_attribute = 162,
    postkind_attribute = 165,
    kind_gcc_attribute = 163,
    postkind_gcc_attribute = 164,
    kind_rid = 166,
    postkind_rid = 166,
    kind_qualifier = 167,
    postkind_qualifier = 167,
    kind_tag_ref = 168,
    postkind_tag_ref = 174,
    kind_struct_ref = 169,
    postkind_struct_ref = 170,
    kind_union_ref = 171,
    postkind_union_ref = 172,
    kind_nested_declarator = 176,
    postkind_nested_declarator = 181,
    kind_function_declarator = 177,
    postkind_function_declarator = 177,
    kind_pointer_declarator = 178,
    postkind_pointer_declarator = 178,
    kind_qualified_declarator = 179,
    postkind_qualified_declarator = 179,
    kind_array_declarator = 180,
    postkind_array_declarator = 180,
    kind_identifier_declarator = 182,
    postkind_identifier_declarator = 182,
    kind_asm_stmt = 66,
    postkind_asm_stmt = 66,
    kind_compound_stmt = 67,
    postkind_compound_stmt = 67,
    kind_if_stmt = 68,
    postkind_if_stmt = 68,
    kind_labeled_stmt = 69,
    postkind_labeled_stmt = 69,
    kind_expression_stmt = 70,
    postkind_expression_stmt = 70,
    kind_conditional_stmt = 71,
    postkind_conditional_stmt = 74,
    kind_switch_stmt = 72,
    postkind_switch_stmt = 72,
    kind_for_stmt = 75,
    postkind_for_stmt = 75,
    kind_break_stmt = 76,
    postkind_break_stmt = 76,
    kind_continue_stmt = 77,
    postkind_continue_stmt = 77,
    kind_return_stmt = 78,
    postkind_return_stmt = 78,
    kind_goto_stmt = 79,
    postkind_goto_stmt = 79,
    kind_computed_goto_stmt = 80,
    postkind_computed_goto_stmt = 80,
    kind_empty_stmt = 81,
    postkind_empty_stmt = 81,
    kind_unary = 85,
    postkind_unary = 106,
    kind_binary = 107,
    postkind_binary = 139,
    kind_comma = 140,
    postkind_comma = 140,
    kind_sizeof_type = 141,
    postkind_sizeof_type = 141,
    kind_alignof_type = 142,
    postkind_alignof_type = 142,
    kind_label_address = 143,
    postkind_label_address = 143,
    kind_cast = 86,
    postkind_cast = 86,
    kind_cast_list = 144,
    postkind_cast_list = 144,
    kind_conditional = 145,
    postkind_conditional = 145,
    kind_identifier = 146,
    postkind_identifier = 146,
    kind_compound_expr = 147,
    postkind_compound_expr = 147,
    kind_function_call = 148,
    postkind_function_call = 148,
    kind_field_ref = 87,
    postkind_field_ref = 87,
    kind_increment = 88,
    postkind_increment = 92,
    kind_comparison = 108,
    postkind_comparison = 114,
    kind_assignment = 115,
    postkind_assignment = 126,
    kind_init_list = 149,
    postkind_init_list = 149,
    kind_init_specific = 150,
    postkind_init_specific = 150,
    kind_designator = 189,
    postkind_designator = 191,
    kind_designate_field = 190,
    postkind_designate_field = 190,
    kind_designate_index = 191,
    postkind_designate_index = 191,
    kind_lexical_cst = 151,
    postkind_lexical_cst = 152,
    kind_string_cst = 152,
    postkind_string_cst = 152,
    kind_string = 153,
    postkind_string = 153,
    kind_id_label = 185,
    postkind_id_label = 185,
    kind_case_label = 186,
    postkind_case_label = 186,
    kind_default_label = 187,
    postkind_default_label = 187,
    kind_word = 192,
    postkind_word = 192,
    kind_asm_operand = 193,
    postkind_asm_operand = 193,
    kind_nesc_decl = 54,
    postkind_nesc_decl = 56,
    kind_interface = 55,
    postkind_interface = 55,
    kind_component = 56,
    postkind_component = 56,
    kind_implementation = 194,
    postkind_implementation = 197,
    kind_configuration = 195,
    postkind_configuration = 195,
    kind_module = 196,
    postkind_module = 196,
    kind_binary_component = 197,
    postkind_binary_component = 197,
    kind_rp_interface = 57,
    postkind_rp_interface = 57,
    kind_interface_ref = 58,
    postkind_interface_ref = 58,
    kind_component_ref = 59,
    postkind_component_ref = 59,
    kind_connection = 60,
    postkind_connection = 62,
    kind_endpoint = 198,
    postkind_endpoint = 198,
    kind_parameterised_identifier = 199,
    postkind_parameterised_identifier = 199,
    kind_generic_declarator = 183,
    postkind_generic_declarator = 183,
    kind_generic_call = 154,
    postkind_generic_call = 154,
    kind_interface_ref_declarator = 181,
    postkind_interface_ref_declarator = 181,
    kind_interface_deref = 93,
    postkind_interface_deref = 93,
    kind_component_deref = 94,
    postkind_component_deref = 94,
    kind_component_typeref = 159,
    postkind_component_typeref = 159,
    kind_atomic_stmt = 82,
    postkind_atomic_stmt = 82,
    kind_nesc_attribute = 165,
    postkind_nesc_attribute = 165,
    kind_type_parm_decl = 63,
    postkind_type_parm_decl = 63,
    kind_type_argument = 155,
    postkind_type_argument = 155,
    kind_error_decl = 64,
    postkind_error_decl = 64,
    kind_attribute_ref = 173,
    postkind_attribute_ref = 173,
    kind_enum_ref = 174,
    postkind_enum_ref = 174,
    kind_error_stmt = 83,
    postkind_error_stmt = 83,
    kind_while_stmt = 73,
    postkind_while_stmt = 73,
    kind_dowhile_stmt = 74,
    postkind_dowhile_stmt = 74,
    kind_error_expr = 156,
    postkind_error_expr = 156,
    kind_array_ref = 127,
    postkind_array_ref = 127,
    kind_dereference = 95,
    postkind_dereference = 95,
    kind_extension_expr = 96,
    postkind_extension_expr = 96,
    kind_sizeof_expr = 97,
    postkind_sizeof_expr = 97,
    kind_alignof_expr = 98,
    postkind_alignof_expr = 98,
    kind_realpart = 99,
    postkind_realpart = 99,
    kind_imagpart = 100,
    postkind_imagpart = 100,
    kind_address_of = 101,
    postkind_address_of = 101,
    kind_unary_minus = 102,
    postkind_unary_minus = 102,
    kind_unary_plus = 103,
    postkind_unary_plus = 103,
    kind_conjugate = 104,
    postkind_conjugate = 104,
    kind_bitnot = 105,
    postkind_bitnot = 105,
    kind_not = 106,
    postkind_not = 106,
    kind_preincrement = 89,
    postkind_preincrement = 89,
    kind_predecrement = 90,
    postkind_predecrement = 90,
    kind_postincrement = 91,
    postkind_postincrement = 91,
    kind_postdecrement = 92,
    postkind_postdecrement = 92,
    kind_plus = 128,
    postkind_plus = 128,
    kind_minus = 129,
    postkind_minus = 129,
    kind_times = 130,
    postkind_times = 130,
    kind_divide = 131,
    postkind_divide = 131,
    kind_modulo = 132,
    postkind_modulo = 132,
    kind_lshift = 133,
    postkind_lshift = 133,
    kind_rshift = 134,
    postkind_rshift = 134,
    kind_leq = 109,
    postkind_leq = 109,
    kind_geq = 110,
    postkind_geq = 110,
    kind_lt = 111,
    postkind_lt = 111,
    kind_gt = 112,
    postkind_gt = 112,
    kind_eq = 113,
    postkind_eq = 113,
    kind_ne = 114,
    postkind_ne = 114,
    kind_bitand = 135,
    postkind_bitand = 135,
    kind_bitor = 136,
    postkind_bitor = 136,
    kind_bitxor = 137,
    postkind_bitxor = 137,
    kind_andand = 138,
    postkind_andand = 138,
    kind_oror = 139,
    postkind_oror = 139,
    kind_assign = 116,
    postkind_assign = 116,
    kind_plus_assign = 117,
    postkind_plus_assign = 117,
    kind_minus_assign = 118,
    postkind_minus_assign = 118,
    kind_times_assign = 119,
    postkind_times_assign = 119,
    kind_divide_assign = 120,
    postkind_divide_assign = 120,
    kind_modulo_assign = 121,
    postkind_modulo_assign = 121,
    kind_lshift_assign = 122,
    postkind_lshift_assign = 122,
    kind_rshift_assign = 123,
    postkind_rshift_assign = 123,
    kind_bitand_assign = 124,
    postkind_bitand_assign = 124,
    kind_bitor_assign = 125,
    postkind_bitor_assign = 125,
    kind_bitxor_assign = 126,
    postkind_bitxor_assign = 126,
    kind_rp_connection = 61,
    postkind_rp_connection = 61,
    kind_eq_connection = 62,
    postkind_eq_connection = 62,
    kind_nx_struct_ref = 170,
    postkind_nx_struct_ref = 170,
    kind_nx_union_ref = 172,
    postkind_nx_union_ref = 172,
    kind_target_attribute = 164,
    postkind_target_attribute = 164
} ;
#line 162 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef enum __anonenum_AST_kind_28 AST_kind;
#line 646 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct __anonstruct_AST_generic_29 {
   AST_kind kind ;
};
#line 646 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct __anonstruct_AST_generic_29 *AST_generic;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.h"
struct env;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.h"
typedef struct env *env;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct environment;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef struct environment *environment;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef struct data_declaration *data_declaration;
#line 31
struct label_declaration;
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef struct label_declaration *label_declaration;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-decls.h"
struct cgraph;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-decls.h"
struct nesc_declaration {
   source_language kind ;
   char const   *name ;
   char const   *instance_name ;
   int instance_number ;
   nesc_decl ast ;
   struct environment *env ;
   struct docstring doc ;
   bool abstract ;
   bool dumped ;
   bool printed ;
   declaration parameters ;
   expression arguments ;
   struct environment *parameter_env ;
   struct nesc_declaration *original ;
   dd_list attributes ;
   bool configuration ;
   bool safe ;
   implementation impl ;
   struct cgraph *connections ;
   struct cgraph *user_connections ;
   dd_list local_statics ;
   size_t instance_count ;
   int folded ;
};
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-decls.h"
typedef struct nesc_declaration *nesc_declaration;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-uses.h"
enum __anonenum_context_30 {
    c_atomic = 1,
    c_executable = 2,
    c_read = 4,
    c_write = 8,
    c_fncall = 16,
    c_addressed = 32,
    c_deref = 64,
    c_constant = 128
} ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-uses.h"
typedef enum __anonenum_context_30 context;
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
enum __anonenum_kind_32 {
    cval_variable = 0,
    cval_unk_number = 1,
    cval_unk_address = 2,
    cval_address_unk_offset = 3,
    cval_address = 4,
    cval_float = 5,
    cval_float_complex = 6,
    cval_uint = 7,
    cval_uint_complex = 8,
    cval_sint = 9,
    cval_sint_complex = 10
} ;
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
struct __anonstruct____missing_field_name_34 {
   long double d ;
   long double d_i ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
union __anonunion____missing_field_name_36 {
   largest_int si ;
   largest_uint ui ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
struct __anonstruct____missing_field_name_38 {
   struct data_declaration *ddecl ;
   struct label_declaration *ldecl ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
union __anonunion____missing_field_name_37 {
   largest_int si_i ;
   largest_uint ui_i ;
   struct __anonstruct____missing_field_name_38 __annonCompField3 ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
struct __anonstruct____missing_field_name_35 {
   size_t isize ;
   union __anonunion____missing_field_name_36 __annonCompField2 ;
   union __anonunion____missing_field_name_37 __annonCompField4 ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
union __anonunion____missing_field_name_33 {
   struct __anonstruct____missing_field_name_34 __annonCompField1 ;
   struct __anonstruct____missing_field_name_35 __annonCompField5 ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
struct __anonstruct_cval_31 {
   enum __anonenum_kind_32 kind ;
   union __anonunion____missing_field_name_33 __annonCompField6 ;
};
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
typedef struct __anonstruct_cval_31 cval;
#line 39 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct tag_declaration;
#line 39 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct field_declaration {
   struct tag_declaration *containing_tag ;
   struct field_declaration *next ;
   char const   *name ;
   type type ;
   dd_list attributes ;
   field_decl ast ;
   cval bitwidth ;
   cval offset ;
   bool packed ;
   struct field_declaration *instantiation ;
};
#line 39 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef struct field_declaration *field_declaration;
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct tag_declaration {
   int kind ;
   char const   *name ;
   type reptype ;
   dd_list attributes ;
   env fields ;
   field_declaration fieldlist ;
   tag_ref definition ;
   struct tag_declaration *shadowed ;
   bool defined ;
   bool being_defined ;
   bool fields_const ;
   bool fields_volatile ;
   bool transparent_union ;
   bool collapsed ;
   cval size ;
   cval alignment ;
   cval user_alignment ;
   bool packed ;
   bool dumped ;
   bool Cname ;
   nesc_declaration container ;
   struct data_declaration *container_function ;
   struct tag_declaration *instantiation ;
   struct tag_declaration *instanceof ;
   char const   *macro_name ;
   bool deputy_scope ;
};
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef struct tag_declaration *tag_declaration;
#line 103
enum __anonenum_data_kind_39 {
    decl_variable = 0,
    decl_constant = 1,
    decl_function = 2,
    decl_typedef = 3,
    decl_error = 4,
    decl_magic_string = 5,
    decl_magic_function = 6,
    decl_interface_ref = 7,
    decl_component_ref = 8
} ;
#line 103 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef enum __anonenum_data_kind_39 data_kind;
#line 108
enum __anonenum_call_contexts_40 {
    c_call_atomic = 1,
    c_call_nonatomic = 2
} ;
#line 108 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
typedef enum __anonenum_call_contexts_40 call_contexts;
#line 113
enum __anonenum_ftype_41 {
    function_implicit = 0,
    function_normal = 1,
    function_static = 2,
    function_nested = 3,
    function_event = 4,
    function_command = 5
} ;
#line 113
struct connections;
#line 113
enum __anonenum_vtype_42 {
    variable_register = 0,
    variable_static = 1,
    variable_normal = 2
} ;
#line 113
enum __anonenum_typevar_kind_43 {
    typevar_none = 0,
    typevar_normal = 1,
    typevar_integer = 2,
    typevar_number = 3
} ;
#line 113 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct data_declaration {
   data_kind kind ;
   char const   *name ;
   type type ;
   long id ;
   context use_summary ;
   dd_list attributes ;
   struct data_declaration *shadowed ;
   struct data_declaration *instantiation ;
   struct data_declaration *instanceof ;
   nesc_declaration container ;
   struct data_declaration *container_function ;
   declaration definition ;
   declaration ast ;
   expression initialiser ;
   bool printed ;
   bool dumped ;
   bool islimbo ;
   bool isexternalscope ;
   bool isfilescoperef ;
   bool needsmemory ;
   bool isused ;
   bool in_system_header ;
   bool Cname ;
   bool safe ;
   call_contexts spontaneous ;
   dd_list nuses ;
   enum __anonenum_ftype_41 ftype ;
   bool isinline ;
   bool noinlinep ;
   bool isexterninline ;
   bool defined ;
   bool suppress_definition ;
   bool uncallable ;
   bool async ;
   bool actual_async ;
   call_contexts call_contexts ;
   call_contexts extra_contexts ;
   bool makeinline ;
   gnode ig_node ;
   struct data_declaration *interface ;
   typelist oldstyle_args ;
   dd_list fn_uses ;
   struct connections *connections ;
   known_cst (*magic_fold)(function_call fcall , int pass ) ;
   enum __anonenum_vtype_42 vtype ;
   bool islocal ;
   bool isparameter ;
   bool async_access ;
   bool async_write ;
   bool norace ;
   known_cst value ;
   bool substitute ;
   cstring schars ;
   nesc_declaration itype ;
   environment functions ;
   bool required ;
   typelist gparms ;
   nesc_declaration ctype ;
   struct docstring doc ;
   data_declaration encoder ;
   data_declaration decoder ;
   data_declaration bf_encoder ;
   data_declaration bf_decoder ;
   bool isbe ;
   type basetype ;
   enum __anonenum_typevar_kind_43 typevar_kind ;
};
#line 246 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct label_declaration {
   char const   *name ;
   bool explicitly_declared ;
   bool used ;
   id_label firstuse ;
   id_label definition ;
   function_decl containing_function ;
   atomic_stmt containing_atomic ;
};
#line 256 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
struct environment {
   struct environment *parent ;
   function_decl fdecl ;
   bool parm_level : 1 ;
   bool global_level : 1 ;
   bool deputy_scope : 1 ;
   env id_env ;
   env tag_env ;
};
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
enum __anonenum_type_quals_44 {
    no_qualifiers = 0,
    transparent_qualifier = 1,
    const_qualifier = 2,
    volatile_qualifier = 4,
    restrict_qualifier = 8,
    last_qualifier = 9
} ;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
typedef enum __anonenum_type_quals_44 type_quals;
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
enum __anonenum_nesc_call_kind_46 {
    command_call = 0,
    event_signal = 1,
    post_task = 2,
    normal_call = 3
} ;
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef enum __anonenum_nesc_call_kind_46 nesc_call_kind;
#line 58
enum __anonenum_atomic_t_47 {
    ATOMIC_ANY = 0,
    ATOMIC_SINGLE = 1,
    NOT_ATOMIC = 2
} ;
#line 58 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
typedef enum __anonenum_atomic_t_47 atomic_t;
#line 5 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_node {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 15 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_declaration {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 42 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_statement {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
};
#line 82 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_expression {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
};
#line 106 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_type_element {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 116 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_label {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   label next_label ;
};
#line 139 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_asm_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   asm_stmt asm_stmt ;
};
#line 151 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_data_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   type_element modifiers ;
   declaration decls ;
};
#line 163 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_extension_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declaration decl ;
};
#line 174 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_ellipsis_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 210 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_function_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   type_element modifiers ;
   attribute attributes ;
   declaration old_parms ;
   statement stmt ;
   function_decl parent_function ;
   data_declaration ddecl ;
   function_declarator fdeclarator ;
   type declared_type ;
   env undeclared_variables ;
   env base_labels ;
   env scoped_labels ;
   statement current_loop ;
   int nlocals ;
};
#line 273 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_field_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   attribute attributes ;
   expression arg1 ;
   bool type_checked ;
   field_declaration fdecl ;
};
#line 288 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_asttype {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   type_element qualifiers ;
   type type ;
};
#line 301 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_typename {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   data_declaration ddecl ;
};
#line 312 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_typeof_expr {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   expression arg1 ;
};
#line 323 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_typeof_type {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   asttype asttype ;
};
#line 334 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_attribute {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
};
#line 346 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_gcc_attribute {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   expression args ;
};
#line 358 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_rid {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   enum rid id ;
};
#line 369 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_qualifier {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   enum rid id ;
};
#line 386 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_tag_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   declaration fields ;
   bool defined ;
   tag_declaration tdecl ;
};
#line 432 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_nested_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
};
#line 446 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_function_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   declaration parms ;
   declaration gparms ;
   type_element qualifiers ;
   environment env ;
   asttype return_type ;
};
#line 462 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_pointer_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
};
#line 475 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_qualified_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   type_element modifiers ;
};
#line 487 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_array_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   expression arg1 ;
};
#line 499 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_identifier_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
};
#line 511 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_asm_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression arg1 ;
   asm_operand asm_operands1 ;
   asm_operand asm_operands2 ;
   string asm_clobbers ;
   type_element qualifiers ;
};
#line 531 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_compound_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   id_label id_labels ;
   declaration decls ;
   statement stmts ;
   environment env ;
};
#line 548 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_if_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression condition ;
   statement stmt1 ;
   statement stmt2 ;
};
#line 564 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_labeled_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   label label ;
   statement stmt ;
};
#line 579 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_expression_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression arg1 ;
};
#line 593 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_conditional_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression condition ;
   statement stmt ;
};
#line 609 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_switch_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression condition ;
   statement stmt ;
   label next_label ;
};
#line 625 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_for_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression arg1 ;
   expression arg2 ;
   expression arg3 ;
   statement stmt ;
};
#line 642 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_break_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
};
#line 655 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_continue_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
};
#line 682 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_goto_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   id_label id_label ;
};
#line 696 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_computed_goto_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression arg1 ;
};
#line 710 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_empty_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
};
#line 1010 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_function_call {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   expression args ;
   asttype va_arg_call ;
   nesc_call_kind call_kind ;
};
#line 1202 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_designator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
};
#line 1237 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_lexical_cst {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   cstring cstring ;
};
#line 1264 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_string_cst {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   cstring cstring ;
};
#line 1290 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_string {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   string_cst strings ;
   data_declaration ddecl ;
};
#line 1316 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_id_label {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   label next_label ;
   cstring cstring ;
   label_declaration ldecl ;
};
#line 1329 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_case_label {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   label next_label ;
   expression arg1 ;
   expression arg2 ;
};
#line 1342 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_default_label {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   label next_label ;
};
#line 1353 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_word {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
};
#line 1364 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_asm_operand {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   string string ;
   expression arg1 ;
};
#line 1379 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_nesc_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   nesc_declaration cdecl ;
};
#line 1392 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_interface {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   nesc_declaration cdecl ;
   declaration decls ;
};
#line 1408 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_component {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   nesc_declaration cdecl ;
   bool abstract ;
   declaration parms ;
   declaration decls ;
   implementation implementation ;
};
#line 1427 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_implementation {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   environment ienv ;
   nesc_declaration cdecl ;
};
#line 1440 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_configuration {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   environment ienv ;
   nesc_declaration cdecl ;
   declaration decls ;
};
#line 1453 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_module {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   environment ienv ;
   nesc_declaration cdecl ;
   declaration decls ;
};
#line 1466 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_binary_component {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   environment ienv ;
   nesc_declaration cdecl ;
};
#line 1480 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_rp_interface {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool required ;
   declaration decls ;
};
#line 1495 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_interface_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   expression args ;
   word word2 ;
   declaration gparms ;
   attribute attributes ;
   data_declaration ddecl ;
};
#line 1515 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_component_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   word word2 ;
   bool abstract ;
   expression args ;
   nesc_declaration cdecl ;
};
#line 1530 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_connection {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   endpoint ep1 ;
   endpoint ep2 ;
};
#line 1542 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_endpoint {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   parameterised_identifier ids ;
};
#line 1553 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_parameterised_identifier {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   expression args ;
};
#line 1675 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_component_typeref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   data_declaration ddecl ;
   cstring cstring ;
};
#line 1688 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_atomic_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   statement stmt ;
};
#line 1703 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_nesc_attribute {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   expression arg1 ;
   tag_declaration tdecl ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
struct __anonstruct_itoken_49 {
   location location ;
   int i ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
struct __anonstruct_iexpr_50 {
   expression expr ;
   int i ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
struct __anonstruct_istmt_51 {
   statement stmt ;
   int i ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
union __anonunion_u_48 {
   void *ptr ;
   asm_operand asm_operand ;
   asm_stmt asm_stmt ;
   attribute attribute ;
   gcc_attribute gcc_attribute ;
   nesc_attribute nesc_attribute ;
   lexical_cst constant ;
   declaration decl ;
   declarator declarator ;
   nested_declarator nested ;
   expression expr ;
   id_label id_label ;
   label label ;
   node node ;
   statement stmt ;
   conditional_stmt cstmt ;
   for_stmt for_stmt ;
   string string ;
   type_element telement ;
   asttype type ;
   word word ;
   designator designator ;
   interface_ref iref ;
   component_ref cref ;
   connection conn ;
   endpoint ep ;
   parameterised_identifier pid ;
   implementation impl ;
   environment env ;
   dd_list fields ;
   char *docstring ;
   tag_declaration tdecl ;
   struct __anonstruct_itoken_49 itoken ;
   struct __anonstruct_iexpr_50 iexpr ;
   struct __anonstruct_istmt_51 istmt ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
struct __anonstruct_idtoken_52 {
   location location ;
   cstring id ;
   data_declaration decl ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
struct yystype {
   union __anonunion_u_48 u ;
   struct __anonstruct_idtoken_52 idtoken ;
   bool abstract ;
};
#line 8 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex-state.h"
struct file_stack {
   struct file_stack *next ;
   struct location l ;
};
#line 14
struct cpp_token;
#line 14 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex-state.h"
struct cpp_print {
   FILE *outf ;
   struct cpp_token  const  *prev ;
   struct cpp_token  const  *source ;
   int src_line ;
   unsigned char printed ;
   bool first_time ;
   bool avoid_paste ;
};
#line 25
struct cpp_reader;
#line 25
struct line_maps;
#line 25 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex-state.h"
struct lex_state {
   struct cpp_reader *finput ;
   struct line_maps *line_map ;
   struct file_stack *input ;
   int token_s1 ;
   int token_s2 ;
   struct yystype token_l1 ;
   struct yystype token_l2 ;
   struct cpp_print pp ;
};
#line 186 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
enum __anonenum_spec_section_55 {
    spec_normal = 0,
    spec_provides = 1,
    spec_uses = 2
} ;
#line 186 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
struct semantic_state {
   region fileregion ;
   source_language language ;
   environment env ;
   nesc_declaration file ;
   nesc_declaration container ;
   function_decl function_decl ;
   tag_ref pending_invalid_xref ;
   enum __anonenum_spec_section_55 spec_section ;
   atomic_stmt in_atomic ;
   char *preprocessed_file ;
   struct lex_state lex ;
};
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
enum __anonenum_kind_56 {
    iv_base = 0,
    iv_array = 1,
    iv_structured = 2
} ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
struct __anonstruct_base_58 {
   expression expr ;
   bool require_constant_value ;
   cval value ;
};
#line 29
struct ivalue_array;
#line 29
struct ivalue_field;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
union __anonunion_u_57 {
   struct __anonstruct_base_58 base ;
   struct ivalue_array *array ;
   struct ivalue_field *structured ;
};
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
struct ivalue {
   enum __anonenum_kind_56 kind ;
   type type ;
   ivalue instantiation ;
   union __anonunion_u_57 u ;
};
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
struct ivalue_array {
   struct ivalue_array *next ;
   largest_int from ;
   largest_int to ;
   ivalue value ;
};
#line 53 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
struct ivalue_field {
   struct ivalue_field *next ;
   field_declaration field ;
   ivalue value ;
};
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/machine.h"
struct __anonstruct_machine_type_spec_59 {
   size_t size ;
   size_t align ;
};
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/machine.h"
typedef struct __anonstruct_machine_type_spec_59 machine_type_spec;
#line 10 "/home/wheatley/newnew/temp/nescc-1.3.4/src/machine.h"
struct __anonstruct_machine_spec_60 {
   char const   *machine_name ;
   void (*handle_option)(char const   *opt ) ;
   bool big_endian ;
   bool pcc_bitfield_type_matters ;
   size_t empty_field_boundary ;
   size_t structure_size_boundary ;
   size_t word_size ;
   machine_type_spec tptr ;
   machine_type_spec tfloat ;
   machine_type_spec tdouble ;
   machine_type_spec tlong_double ;
   machine_type_spec tshort ;
   machine_type_spec tint ;
   machine_type_spec tlong ;
   machine_type_spec tlong_long ;
   size_t int1_align ;
   size_t int2_align ;
   size_t int4_align ;
   size_t int8_align ;
   size_t wchar_t_size ;
   size_t size_t_size ;
   bool char_signed ;
   bool wchar_t_signed ;
   char *async_functions_atribute ;
   cval (*adjust_field_align)(field_declaration fdecl , cval alignment ) ;
   bool (*decl_attribute)(gcc_attribute attr , data_declaration ddecl ) ;
   bool (*tag_attribute)(gcc_attribute attr , tag_declaration tdecl ) ;
   bool (*field_attribute)(gcc_attribute attr , field_declaration fdecl ) ;
   bool (*type_attribute)(gcc_attribute attr , type *t ) ;
   void (*preinit)(void) ;
   void (*init)(void) ;
   int (*token)(char const   *word , int length , struct yystype *lvalp ) ;
   declaration (*keilc_definition)(location loc , cstring keyword , cstring name ,
                                   expression address ) ;
   char const   *(*global_cpp_init)(void) ;
   void (*file_cpp_init)(void) ;
};
#line 10 "/home/wheatley/newnew/temp/nescc-1.3.4/src/machine.h"
typedef struct __anonstruct_machine_spec_60 machine_spec;
#line 287 "c-parse.y"
struct spec_stack;
#line 287 "c-parse.y"
typedef struct spec_stack *spec_stack;
#line 288 "c-parse.y"
struct spec_stack {
   type_element declspecs ;
   attribute attributes ;
   spec_stack next ;
};
#line 294 "c-parse.y"
struct parse_state {
   spec_stack declspec_stack ;
   region ds_region ;
   type_element declspecs ;
   attribute attributes ;
   int unevaluated_expression ;
};
#line 452 "c-parse.tab.c"
typedef unsigned char yytype_uint8;
#line 467 "c-parse.tab.c"
typedef unsigned short yytype_uint16;
#line 473 "c-parse.tab.c"
typedef short yytype_int16;
#line 604 "c-parse.tab.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   struct yystype yyvs_alloc ;
};
#line 38 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.h"
struct dhash_table;
#line 38 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.h"
typedef struct dhash_table *dhash_table;
#line 69 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.h"
struct __anonstruct_dhash_scan_21 {
   dhash_table h ;
   int index ;
};
#line 69 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.h"
typedef struct __anonstruct_dhash_scan_21 dhash_scan;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
typedef unsigned int uint32;
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
typedef unsigned long uint64;
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
struct dhash_table {
   region r ;
   void **elements ;
   unsigned long size ;
   unsigned long used ;
   unsigned long log2size ;
   int (*compare)(void *key , void *y ) ;
   unsigned long (*hash)(void *x ) ;
};
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
struct dd_list_pos {
   struct dd_list_pos *next ;
   struct dd_list_pos *previous ;
   void *data ;
};
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
typedef struct dd_list_pos *dd_list_pos;
#line 52 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_unary;
#line 52 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *unary;
#line 53
struct AST_binary;
#line 53 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *binary;
#line 54
struct AST_comma;
#line 54 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comma *comma;
#line 55
struct AST_sizeof_type;
#line 55 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_sizeof_type *sizeof_type;
#line 56
struct AST_alignof_type;
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_alignof_type *alignof_type;
#line 57
struct AST_label_address;
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_label_address *label_address;
#line 58
struct AST_cast;
#line 58 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_cast *cast;
#line 60
struct AST_conditional;
#line 60 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_conditional *conditional;
#line 61
struct AST_identifier;
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_identifier *identifier;
#line 62
struct AST_compound_expr;
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_compound_expr *compound_expr;
#line 64
struct AST_field_ref;
#line 64 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_field_ref *field_ref;
#line 65
struct AST_increment;
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_expression *error_expr;
#line 111 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *array_ref;
#line 112 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *dereference;
#line 113 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *extension_expr;
#line 114 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *sizeof_expr;
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *alignof_expr;
#line 118 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *address_of;
#line 124 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_increment *preincrement;
#line 125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_increment *predecrement;
#line 126 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_increment *postincrement;
#line 127 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_increment *postdecrement;
#line 121 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
struct typelist_element;
#line 121 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
typedef struct typelist_element *typelist_scanner;
#line 723 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_unary {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
};
#line 748 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_binary {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   expression arg2 ;
};
#line 774 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_comma {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
};
#line 799 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_sizeof_type {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   asttype asttype ;
};
#line 824 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_alignof_type {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   asttype asttype ;
};
#line 849 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_label_address {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   id_label id_label ;
};
#line 874 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_cast {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   asttype asttype ;
};
#line 927 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_conditional {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression condition ;
   expression arg1 ;
   expression arg2 ;
};
#line 955 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_identifier {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   cstring cstring ;
   data_declaration ddecl ;
};
#line 981 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_compound_expr {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   statement stmt ;
};
#line 1039 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_field_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   cstring cstring ;
   field_declaration fdecl ;
};
#line 1066 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_increment {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   data_declaration temp1 ;
   data_declaration temp2 ;
};
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
struct known_cst {
   type type ;
   cval cval ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 157 "./../include/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 164 "./../include/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   long temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 28 "./include/symtab.h"
struct ht_identifier;
#line 29 "./include/symtab.h"
struct ht_identifier {
   unsigned char const   *str ;
   unsigned int len ;
   unsigned int hash_value ;
};
#line 39
struct ht;
#line 39 "./include/symtab.h"
typedef struct ht hash_table;
#line 40 "./include/symtab.h"
typedef struct ht_identifier *hashnode;
#line 45 "./include/symtab.h"
struct ht {
   struct obstack stack ;
   hashnode *entries ;
   hashnode (*alloc_node)(hash_table * ) ;
   void *(*alloc_subobject)(size_t  ) ;
   unsigned int nslots ;
   unsigned int nelements ;
   struct cpp_reader *pfile ;
   unsigned int searches ;
   unsigned int collisions ;
   unsigned char entries_owned ;
};
#line 35 "./include/line-map.h"
enum lc_reason {
    LC_ENTER = 0,
    LC_LEAVE = 1,
    LC_RENAME = 2
} ;
#line 40 "./include/line-map.h"
typedef unsigned int source_location;
#line 57 "./include/line-map.h"
struct line_map {
   char const   *to_file ;
   unsigned int to_line ;
   source_location start_location ;
   int included_from ;
   enum lc_reason reason : 8 ;
   unsigned char sysp ;
   unsigned int column_bits : 8 ;
};
#line 71 "./include/line-map.h"
struct line_maps {
   struct line_map *maps ;
   unsigned int allocated ;
   unsigned int used ;
   unsigned int cache ;
   int last_listed ;
   unsigned int depth ;
   unsigned char trace_includes ;
   source_location highest_location ;
   source_location highest_line ;
   unsigned int max_column_hint ;
   void *(*reallocator)(void * , size_t  ) ;
};
#line 35 "./include/cpplib.h"
typedef struct cpp_reader cpp_reader;
#line 36
struct cpp_buffer;
#line 36 "./include/cpplib.h"
typedef struct cpp_buffer cpp_buffer;
#line 37
struct cpp_options;
#line 37 "./include/cpplib.h"
typedef struct cpp_options cpp_options;
#line 38 "./include/cpplib.h"
typedef struct cpp_token cpp_token;
#line 39
struct cpp_string;
#line 39 "./include/cpplib.h"
typedef struct cpp_string cpp_string;
#line 40
struct cpp_hashnode;
#line 40 "./include/cpplib.h"
typedef struct cpp_hashnode cpp_hashnode;
#line 41
struct cpp_macro;
#line 41 "./include/cpplib.h"
typedef struct cpp_macro cpp_macro;
#line 42
struct cpp_callbacks;
#line 43
struct cpp_dir;
#line 43 "./include/cpplib.h"
typedef struct cpp_dir cpp_dir;
#line 45
struct answer;
#line 46
struct _cpp_file;
#line 143
enum cpp_ttype {
    CPP_EQ = 0,
    CPP_NOT = 1,
    CPP_GREATER = 2,
    CPP_LESS = 3,
    CPP_PLUS = 4,
    CPP_MINUS = 5,
    CPP_MULT = 6,
    CPP_DIV = 7,
    CPP_MOD = 8,
    CPP_AND = 9,
    CPP_OR = 10,
    CPP_XOR = 11,
    CPP_RSHIFT = 12,
    CPP_LSHIFT = 13,
    CPP_COMPL = 14,
    CPP_AND_AND = 15,
    CPP_OR_OR = 16,
    CPP_QUERY = 17,
    CPP_COLON = 18,
    CPP_COMMA = 19,
    CPP_OPEN_PAREN = 20,
    CPP_CLOSE_PAREN = 21,
    CPP_EOF = 22,
    CPP_EQ_EQ = 23,
    CPP_NOT_EQ = 24,
    CPP_GREATER_EQ = 25,
    CPP_LESS_EQ = 26,
    CPP_PLUS_EQ = 27,
    CPP_MINUS_EQ = 28,
    CPP_MULT_EQ = 29,
    CPP_DIV_EQ = 30,
    CPP_MOD_EQ = 31,
    CPP_AND_EQ = 32,
    CPP_OR_EQ = 33,
    CPP_XOR_EQ = 34,
    CPP_RSHIFT_EQ = 35,
    CPP_LSHIFT_EQ = 36,
    CPP_HASH = 37,
    CPP_PASTE = 38,
    CPP_OPEN_SQUARE = 39,
    CPP_CLOSE_SQUARE = 40,
    CPP_OPEN_BRACE = 41,
    CPP_CLOSE_BRACE = 42,
    CPP_SEMICOLON = 43,
    CPP_ELLIPSIS = 44,
    CPP_PLUS_PLUS = 45,
    CPP_MINUS_MINUS = 46,
    CPP_DEREF = 47,
    CPP_FERED = 48,
    CPP_DOT = 49,
    CPP_SCOPE = 50,
    CPP_DEREF_STAR = 51,
    CPP_DOT_STAR = 52,
    CPP_ATSIGN = 53,
    CPP_NAME = 54,
    CPP_AT_NAME = 55,
    CPP_NUMBER = 56,
    CPP_CHAR = 57,
    CPP_WCHAR = 58,
    CPP_OTHER = 59,
    CPP_STRING = 60,
    CPP_WSTRING = 61,
    CPP_OBJC_STRING = 62,
    CPP_HEADER_NAME = 63,
    CPP_COMMENT = 64,
    CPP_MACRO_ARG = 65,
    CPP_PRAGMA = 66,
    CPP_PRAGMA_EOL = 67,
    CPP_PADDING = 68,
    N_TTYPES = 69,
    CPP_LAST_EQ = 13,
    CPP_FIRST_DIGRAPH = 37,
    CPP_LAST_PUNCTUATOR = 53,
    CPP_LAST_CPP_OP = 26
} ;
#line 158
enum c_lang {
    CLK_GNUC89 = 0,
    CLK_GNUC99 = 1,
    CLK_STDC89 = 2,
    CLK_STDC94 = 3,
    CLK_STDC99 = 4,
    CLK_GNUCXX = 5,
    CLK_CXX98 = 6,
    CLK_GNUCXX0X = 7,
    CLK_CXX0X = 8,
    CLK_ASM = 9
} ;
#line 162 "./include/cpplib.h"
struct cpp_string {
   unsigned int len ;
   unsigned char const   *text ;
};
#line 192 "./include/cpplib.h"
union cpp_token_u {
   cpp_hashnode *node ;
   cpp_token *source ;
   struct cpp_string str ;
   unsigned int arg_no ;
   unsigned int pragma ;
};
#line 192 "./include/cpplib.h"
struct cpp_token {
   source_location src_loc ;
   enum cpp_ttype type : 8 ;
   unsigned char flags ;
   union cpp_token_u val ;
};
#line 244
enum cpp_deps_style {
    DEPS_NONE = 0,
    DEPS_USER = 1,
    DEPS_SYSTEM = 2
} ;
#line 247
enum cpp_normalize_level {
    normalized_KC = 0,
    normalized_C = 1,
    normalized_identifier_C = 2,
    normalized_none = 3
} ;
#line 261 "./include/cpplib.h"
struct __anonstruct_deps_30 {
   enum cpp_deps_style style ;
   unsigned char missing_files ;
   unsigned char phony_targets ;
   unsigned char ignore_main_file ;
};
#line 261 "./include/cpplib.h"
struct cpp_options {
   unsigned int tabstop ;
   enum c_lang lang ;
   unsigned char cplusplus ;
   unsigned char cplusplus_comments ;
   unsigned char objc ;
   unsigned char discard_comments ;
   unsigned char discard_comments_in_macro_exp ;
   unsigned char trigraphs ;
   unsigned char digraphs ;
   unsigned char extended_numbers ;
   unsigned char print_include_names ;
   unsigned char pedantic_errors ;
   unsigned char inhibit_warnings ;
   unsigned char warn_deprecated ;
   unsigned char warn_system_headers ;
   unsigned char inhibit_errors ;
   unsigned char warn_comments ;
   unsigned char warn_missing_include_dirs ;
   unsigned char warn_trigraphs ;
   unsigned char warn_multichar ;
   unsigned char warn_traditional ;
   unsigned char warn_long_long ;
   unsigned char warn_endif_labels ;
   unsigned char warn_num_sign_change ;
   unsigned char warn_variadic_macros ;
   unsigned char warnings_are_errors ;
   unsigned char remap ;
   unsigned char dollars_in_ident ;
   unsigned char extended_identifiers ;
   unsigned char warn_dollars ;
   unsigned char warn_undef ;
   unsigned char warn_unused_macros ;
   unsigned char c99 ;
   unsigned char std ;
   unsigned char pedantic ;
   unsigned char preprocessed ;
   unsigned char show_column ;
   unsigned char operator_names ;
   unsigned char traditional ;
   char const   *narrow_charset ;
   char const   *wide_charset ;
   char const   *input_charset ;
   enum cpp_normalize_level warn_normalize ;
   unsigned char warn_invalid_pch ;
   unsigned char restore_pch_deps ;
   struct __anonstruct_deps_30 deps ;
   size_t precision ;
   size_t char_precision ;
   size_t int_precision ;
   size_t wchar_precision ;
   unsigned char unsigned_char ;
   unsigned char unsigned_wchar ;
   unsigned char bytes_big_endian ;
   unsigned char stdc_0_in_system_headers ;
   unsigned char client_diagnostic ;
   unsigned char directives_only ;
};
#line 458 "./include/cpplib.h"
struct cpp_callbacks {
   void (*line_change)(cpp_reader * , cpp_token const   * , int  ) ;
   void (*file_change)(cpp_reader * , struct line_map  const  * ) ;
   void (*dir_change)(cpp_reader * , char const   * ) ;
   void (*include)(cpp_reader * , unsigned int  , unsigned char const   * , char const   * ,
                   int  , cpp_token const   ** ) ;
   void (*define)(cpp_reader * , unsigned int  , cpp_hashnode * ) ;
   void (*undef)(cpp_reader * , unsigned int  , cpp_hashnode * ) ;
   void (*ident)(cpp_reader * , unsigned int  , cpp_string const   * ) ;
   void (*def_pragma)(cpp_reader * , unsigned int  ) ;
   int (*valid_pch)(cpp_reader * , char const   * , int  ) ;
   void (*read_pch)(cpp_reader * , char const   * , int  , char const   * ) ;
   char const   *(*missing_header)(cpp_reader * , char const   *header , cpp_dir ** ) ;
   void ( /* format attribute */ __attribute__((__nonnull__(3))) (*error))(cpp_reader * ,
                                                                           int  ,
                                                                           char const   * ,
                                                                           va_list * ) ;
};
#line 487 "./include/cpplib.h"
struct cpp_dir {
   struct cpp_dir *next ;
   char *name ;
   unsigned int len ;
   unsigned char sysp ;
   char const   **name_map ;
   char *(*construct)(char const   *header , cpp_dir *dir ) ;
   ino_t ino ;
   dev_t dev ;
   unsigned char user_supplied_p ;
};
#line 543
enum node_type {
    NT_VOID = 0,
    NT_MACRO = 1,
    NT_ASSERTION = 2
} ;
#line 552
enum builtin_type {
    BT_SPECLINE = 0,
    BT_DATE = 1,
    BT_FILE = 2,
    BT_BASE_FILE = 3,
    BT_INCLUDE_LEVEL = 4,
    BT_TIME = 5,
    BT_STDC = 6,
    BT_PRAGMA = 7,
    BT_TIMESTAMP = 8,
    BT_COUNTER = 9
} ;
#line 592 "./include/cpplib.h"
union _cpp_hashnode_value {
   cpp_macro *macro ;
   struct answer *answers ;
   enum builtin_type builtin ;
   unsigned short arg_index ;
};
#line 604 "./include/cpplib.h"
struct cpp_hashnode {
   struct ht_identifier ident ;
   unsigned int is_directive : 1 ;
   unsigned int directive_index : 7 ;
   unsigned char rid_code ;
   enum node_type type : 8 ;
   unsigned char flags ;
   union _cpp_hashnode_value value ;
};
#line 646
struct deps;
#line 22 "./include/cpp-id-data.h"
typedef unsigned char uchar;
#line 28 "./include/cpp-id-data.h"
struct answer {
   struct answer *next ;
   unsigned int count ;
   cpp_token first[1] ;
};
#line 37 "./include/cpp-id-data.h"
union cpp_macro_u {
   cpp_token *tokens ;
   unsigned char const   *text ;
};
#line 37 "./include/cpp-id-data.h"
struct cpp_macro {
   cpp_hashnode **params ;
   union cpp_macro_u exp ;
   source_location line ;
   unsigned int count ;
   unsigned short paramc ;
   unsigned int fun_like : 1 ;
   unsigned int variadic : 1 ;
   unsigned int syshdr : 1 ;
   unsigned int used : 1 ;
   unsigned int traditional : 1 ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct directive;
#line 42
struct op;
#line 43
struct _cpp_strbuf;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct cset_converter {
   unsigned char (*func)(iconv_t  , unsigned char const   * , size_t  , struct _cpp_strbuf * ) ;
   iconv_t cd ;
};
#line 98
struct _cpp_buff;
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
typedef struct _cpp_buff _cpp_buff;
#line 99 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct _cpp_buff {
   struct _cpp_buff *next ;
   unsigned char *base ;
   unsigned char *cur ;
   unsigned char *limit ;
};
#line 118
enum include_type {
    IT_INCLUDE = 0,
    IT_INCLUDE_NEXT = 1,
    IT_IMPORT = 2,
    IT_CMDLINE = 3
} ;
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
union utoken {
   cpp_token const   *token ;
   cpp_token const   **ptoken ;
};
#line 127
struct tokenrun;
#line 127 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
typedef struct tokenrun tokenrun;
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct tokenrun {
   tokenrun *next ;
   tokenrun *prev ;
   cpp_token *base ;
   cpp_token *limit ;
};
#line 140
struct cpp_context;
#line 140 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
typedef struct cpp_context cpp_context;
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct __anonstruct_iso_34 {
   union utoken first ;
   union utoken last ;
};
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct __anonstruct_trad_35 {
   unsigned char const   *cur ;
   unsigned char const   *rlimit ;
};
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
union __anonunion_u_33 {
   struct __anonstruct_iso_34 iso ;
   struct __anonstruct_trad_35 trad ;
};
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct cpp_context {
   cpp_context *next ;
   cpp_context *prev ;
   union __anonunion_u_33 u ;
   _cpp_buff *buff ;
   cpp_hashnode *macro ;
   unsigned char direct_p ;
};
#line 176 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct lexer_state {
   unsigned char in_directive ;
   unsigned char directive_wants_padding ;
   unsigned char skipping ;
   unsigned char angled_headers ;
   unsigned char in_expression ;
   unsigned char save_comments ;
   unsigned char va_args_ok ;
   unsigned char poisoned_ok ;
   unsigned char prevent_expansion ;
   unsigned char parsing_args ;
   unsigned char discarding_output ;
   unsigned int skip_eval ;
   unsigned char in_deferred_pragma ;
   unsigned char pragma_allow_expansion ;
};
#line 226 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct spec_nodes {
   cpp_hashnode *n_defined ;
   cpp_hashnode *n_true ;
   cpp_hashnode *n_false ;
   cpp_hashnode *n__VA_ARGS__ ;
};
#line 234
struct _cpp_line_note;
#line 234 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
typedef struct _cpp_line_note _cpp_line_note;
#line 235 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct _cpp_line_note {
   unsigned char const   *pos ;
   unsigned int type ;
};
#line 247
struct if_stack;
#line 247 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct cpp_buffer {
   unsigned char const   *cur ;
   unsigned char const   *line_base ;
   unsigned char const   *next_line ;
   unsigned char const   *buf ;
   unsigned char const   *rlimit ;
   _cpp_line_note *notes ;
   unsigned int cur_note ;
   unsigned int notes_used ;
   unsigned int notes_cap ;
   struct cpp_buffer *prev ;
   struct _cpp_file *file ;
   unsigned char const   *timestamp ;
   struct if_stack *if_stack ;
   unsigned char need_line ;
   unsigned int warned_cplusplus_comments : 1 ;
   unsigned int from_stage3 : 1 ;
   unsigned int return_at_eof : 1 ;
   unsigned char sysp ;
   struct cpp_dir dir ;
   struct cset_converter input_cset_desc ;
};
#line 310
struct htab;
#line 310
struct file_hash_entry_pool;
#line 310
struct pragma_entry;
#line 310 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct __anonstruct_out_36 {
   unsigned char *base ;
   unsigned char *limit ;
   unsigned char *cur ;
   source_location first_line ;
};
#line 310
struct cpp_savedstate;
#line 310 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
struct cpp_reader {
   cpp_buffer *buffer ;
   cpp_buffer *overlaid_buffer ;
   struct lexer_state state ;
   struct line_maps *line_table ;
   source_location directive_line ;
   _cpp_buff *a_buff ;
   _cpp_buff *u_buff ;
   _cpp_buff *free_buffs ;
   struct cpp_context base_context ;
   struct cpp_context *context ;
   struct directive  const  *directive ;
   cpp_token directive_result ;
   source_location invocation_location ;
   unsigned char set_invocation_location ;
   struct cpp_dir *quote_include ;
   struct cpp_dir *bracket_include ;
   struct cpp_dir no_search_path ;
   struct _cpp_file *all_files ;
   struct _cpp_file *main_file ;
   struct htab *file_hash ;
   struct htab *dir_hash ;
   struct file_hash_entry_pool *file_hash_entries ;
   struct htab *nonexistent_file_hash ;
   struct obstack nonexistent_file_ob ;
   unsigned char quote_ignores_source_dir ;
   unsigned char seen_once_only ;
   cpp_hashnode const   *mi_cmacro ;
   cpp_hashnode const   *mi_ind_cmacro ;
   unsigned char mi_valid ;
   cpp_token *cur_token ;
   tokenrun base_run ;
   tokenrun *cur_run ;
   unsigned int lookaheads ;
   unsigned int keep_tokens ;
   unsigned int errors ;
   unsigned char *macro_buffer ;
   unsigned int macro_buffer_len ;
   struct cset_converter narrow_cset_desc ;
   struct cset_converter wide_cset_desc ;
   unsigned char const   *date ;
   unsigned char const   *time ;
   cpp_token avoid_paste ;
   cpp_token eof ;
   struct deps *deps ;
   struct obstack hash_ob ;
   struct obstack buffer_ob ;
   struct pragma_entry *pragmas ;
   struct cpp_callbacks cb ;
   struct ht *hash_table ;
   struct op *op_stack ;
   struct op *op_limit ;
   struct cpp_options opts ;
   struct spec_nodes spec_nodes ;
   unsigned char our_hashtable ;
   struct __anonstruct_out_36 out ;
   unsigned char const   *saved_cur ;
   unsigned char const   *saved_rlimit ;
   unsigned char const   *saved_line_base ;
   struct cpp_savedstate *savedstate ;
   unsigned int counter ;
};
#line 536 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
typedef struct _cpp_file _cpp_file;
#line 46 "./../include/hashtab.h"
typedef unsigned int hashval_t;
#line 99 "./../include/hashtab.h"
struct htab {
   hashval_t (*hash_f)(void const   * ) ;
   int (*eq_f)(void const   * , void const   * ) ;
   void (*del_f)(void * ) ;
   void **entries ;
   size_t size ;
   size_t n_elements ;
   size_t n_deleted ;
   unsigned int searches ;
   unsigned int collisions ;
   void *(*alloc_f)(size_t  , size_t  ) ;
   void (*free_f)(void * ) ;
   void *alloc_arg ;
   void *(*alloc_with_arg_f)(void * , size_t  , size_t  ) ;
   void (*free_with_arg_f)(void * , void * ) ;
   unsigned int size_prime_index ;
};
#line 144 "./../include/hashtab.h"
typedef struct htab *htab_t;
#line 147
enum insert_option {
    NO_INSERT = 0,
    INSERT = 1
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct _cpp_file {
   char const   *name ;
   char const   *path ;
   char const   *pchname ;
   char const   *dir_name ;
   struct _cpp_file *next_file ;
   uchar const   *buffer ;
   cpp_hashnode const   *cmacro ;
   cpp_dir *dir ;
   struct stat st ;
   int fd ;
   int err_no ;
   unsigned short stack_count ;
   unsigned char once_only ;
   unsigned char dont_read ;
   unsigned char main_file ;
   unsigned char buffer_valid ;
   unsigned char pch ;
};
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
union __anonunion_u_38 {
   _cpp_file *file ;
   cpp_dir *dir ;
};
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct file_hash_entry {
   struct file_hash_entry *next ;
   cpp_dir *start_dir ;
   source_location location ;
   union __anonunion_u_38 u ;
};
#line 158 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct file_hash_entry_pool {
   unsigned int file_hash_entries_used ;
   struct file_hash_entry_pool *next ;
   struct file_hash_entry pool[127] ;
};
#line 1578 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct pchf_entry {
   off_t size ;
   unsigned char sum[16] ;
   unsigned char once_only ;
};
#line 1588 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct pchf_data {
   size_t count ;
   unsigned char have_once_only ;
   struct pchf_entry entries[1] ;
};
#line 1699 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct pchf_compare_data {
   off_t size ;
   unsigned char sum[16] ;
   unsigned char sum_computed ;
   unsigned char check_included ;
   _cpp_file *f ;
};
#line 19 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_variable_decl;
#line 19 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_variable_decl *variable_decl;
#line 252 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_variable_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   attribute attributes ;
   expression arg1 ;
   asm_stmt asm_stmt ;
   data_declaration ddecl ;
   type declared_type ;
   bool forward ;
};
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.h"
typedef dhash_scan env_scanner;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
struct entry {
   char const   *name ;
   void *value ;
};
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
struct env {
   env parent ;
   region r ;
   dhash_table table ;
};
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.h"
struct array;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/utils.h"
struct char_array_a;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/utils.h"
typedef struct char_array_a *char_array;
#line 28 "./../libcpp/include/symtab.h"
typedef struct ht_identifier ht_identifier;
#line 42 "./../libcpp/include/cpplib.h"
typedef struct cpp_callbacks cpp_callbacks;
#line 240 "./../libcpp/include/cpplib.h"
typedef unsigned int cppchar_t;
#line 734 "./../libcpp/include/cpplib.h"
typedef unsigned long long cpp_num_part;
#line 735
struct cpp_num;
#line 735 "./../libcpp/include/cpplib.h"
typedef struct cpp_num cpp_num;
#line 736 "./../libcpp/include/cpplib.h"
struct cpp_num {
   cpp_num_part high ;
   cpp_num_part low ;
   unsigned char unsignedp ;
   unsigned char overflow ;
};
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
struct string_array_a;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
typedef struct string_array_a *string_array;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
struct resword {
   char *name ;
   short token ;
   enum rid rid ;
};
#line 15 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_enumerator;
#line 15 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_enumerator *enumerator;
#line 30
struct AST_struct_ref;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_struct_ref *struct_ref;
#line 31
struct AST_union_ref;
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_union_ref *union_ref;
#line 48
struct AST_return_stmt;
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_return_stmt *return_stmt;
#line 59
struct AST_cast_list;
#line 59 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_cast_list *cast_list;
#line 65 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_increment *increment;
#line 66
struct AST_comparison;
#line 66 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *comparison;
#line 67
struct AST_assignment;
#line 67 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *assignment;
#line 68
struct AST_init_list;
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_init_list *init_list;
#line 69
struct AST_init_specific;
#line 69 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_init_specific *init_specific;
#line 72
struct AST_designate_index;
#line 72 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_designate_index *designate_index;
#line 94
struct AST_generic_declarator;
#line 94 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_generic_declarator *generic_declarator;
#line 95
struct AST_generic_call;
#line 95 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_generic_call *generic_call;
#line 96
struct AST_interface_ref_declarator;
#line 96 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_interface_ref_declarator *interface_ref_declarator;
#line 97
struct AST_interface_deref;
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_interface_deref *interface_deref;
#line 98
struct AST_component_deref;
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_component_deref *component_deref;
#line 103
struct AST_type_argument;
#line 103 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_type_argument *type_argument;
#line 105 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_tag_ref *attribute_ref;
#line 106 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_tag_ref *enum_ref;
#line 116 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *realpart;
#line 117 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *imagpart;
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *unary_minus;
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *unary_plus;
#line 121 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *conjugate;
#line 122 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *bitnot;
#line 123 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_unary *not;
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *plus;
#line 129 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *minus;
#line 130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *times;
#line 131 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *divide;
#line 132 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *modulo;
#line 133 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *lshift;
#line 134 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *rshift;
#line 135 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *leq;
#line 136 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *geq;
#line 137 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *lt;
#line 138 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *gt;
#line 139 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *eq;
#line 140 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_comparison *ne;
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *bitand;
#line 142 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *bitor;
#line 143 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *bitxor;
#line 144 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *andand;
#line 145 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_binary *oror;
#line 146 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *assign;
#line 147 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *plus_assign;
#line 148 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *minus_assign;
#line 149 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *times_assign;
#line 150 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *divide_assign;
#line 151 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *modulo_assign;
#line 152 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *lshift_assign;
#line 153 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *rshift_assign;
#line 154 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *bitand_assign;
#line 155 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *bitor_assign;
#line 156 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_assignment *bitxor_assign;
#line 159 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_struct_ref *nx_struct_ref;
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_union_ref *nx_union_ref;
#line 184 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_enumerator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
   expression arg1 ;
   data_declaration ddecl ;
};
#line 401 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_struct_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   declaration fields ;
   bool defined ;
   tag_declaration tdecl ;
};
#line 416 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_union_ref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   word word1 ;
   attribute attributes ;
   declaration fields ;
   bool defined ;
   tag_declaration tdecl ;
};
#line 668 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_return_stmt {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   statement parent_loop ;
   atomic_stmt containing_atomic ;
   atomic_t isatomic ;
   expression arg1 ;
};
#line 900 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_cast_list {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   asttype asttype ;
   expression init_expr ;
};
#line 1093 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_comparison {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   expression arg2 ;
};
#line 1119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_assignment {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   expression arg2 ;
   data_declaration temp1 ;
};
#line 1149 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_init_list {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression args ;
};
#line 1176 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_init_specific {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   designator designator ;
   expression init_expr ;
};
#line 1224 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_designate_index {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   expression arg1 ;
   expression arg2 ;
};
#line 1565 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_generic_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   declaration parms ;
};
#line 1577 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_generic_call {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   expression args ;
};
#line 1605 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_interface_ref_declarator {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   declarator declarator ;
   word word1 ;
};
#line 1618 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_interface_deref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   cstring cstring ;
   data_declaration ddecl ;
};
#line 1647 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_component_deref {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   expression arg1 ;
   cstring cstring ;
   data_declaration ddecl ;
};
#line 1728 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_type_argument {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   bool lvalue ;
   bool side_effects ;
   known_cst cst ;
   bool bitfield ;
   bool isregister ;
   type type ;
   known_cst static_address ;
   bool converted_to_pointer ;
   bool cst_checked ;
   char const   *spelling ;
   bool parens ;
   ivalue ivalue ;
   context context ;
   atomic_t isatomic ;
   asttype asttype ;
};
#line 34 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.h"
enum __anonenum_AST_walker_result_48 {
    aw_walk = 0,
    aw_call_parent = 1,
    aw_done = 2
} ;
#line 34 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.h"
typedef enum __anonenum_AST_walker_result_48 AST_walker_result;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.h"
typedef AST_walker_result (*AST_walker_fn)();
#line 41
struct AST_walker;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.h"
typedef struct AST_walker *AST_walker;
#line 22 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
struct AST_walker {
   AST_walker_fn walkers[158] ;
};
#line 16 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_oldidentifier_decl;
#line 16 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_oldidentifier_decl *oldidentifier_decl;
#line 197 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_oldidentifier_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
   data_declaration ddecl ;
};
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
struct dd_list {
   struct dd_list_pos *first ;
   struct dd_list_pos *null ;
   struct dd_list_pos *last ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 87 "./libcompat/regions.h"
typedef void (*nomem_handler)(void);
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
struct __anonstruct_fW_options_87 {
   char c ;
   char *string ;
   int *variable ;
   int on_value ;
};
#line 72 "./../include/demangle.h"
enum demangling_styles {
    no_demangling = -1,
    unknown_demangling = 0,
    auto_demangling = 256,
    gnu_demangling = 512,
    lucid_demangling = 1024,
    arm_demangling = 2048,
    hp_demangling = 4096,
    edg_demangling = 8192,
    gnu_v3_demangling = 16384,
    java_demangling = 4,
    gnat_demangling = 32768
} ;
#line 116 "./../include/demangle.h"
struct demangler_engine {
   char const   * const  demangling_style_name ;
   enum demangling_styles  const  demangling_style ;
   char const   * const  demangling_style_doc ;
};
#line 107 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
struct string {
   char *b ;
   char *p ;
   char *e ;
};
#line 107 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
typedef struct string string___0;
#line 117 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
struct work_stuff {
   int options ;
   char **typevec ;
   char **ktypevec ;
   char **btypevec ;
   int numk ;
   int numb ;
   int ksize ;
   int bsize ;
   int ntypes ;
   int typevec_size ;
   int constructor ;
   int destructor ;
   int static_type ;
   int temp_start ;
   int type_quals ;
   int dllimported ;
   char **tmpl_argvec ;
   int ntmpl_args ;
   int forgetting_types ;
   string___0 *previous_argument ;
   int nrepeats ;
};
#line 147 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
struct optable {
   char const   * const  in ;
   char const   * const  out ;
   int const   flags ;
};
#line 237
enum type_kind_t {
    tk_none = 0,
    tk_pointer = 1,
    tk_reference = 2,
    tk_integral = 3,
    tk_bool = 4,
    tk_char = 5,
    tk_real = 6
} ;
#line 237 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
typedef enum type_kind_t type_kind_t;
#line 102 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_type_parm_decl;
#line 102 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_type_parm_decl *type_parm_decl;
#line 1716 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_type_parm_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
   data_declaration ddecl ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
enum __anonenum_scflags_48 {
    scf_inline = 1,
    scf_default = 2,
    scf_async = 4,
    scf_norace = 8
} ;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
typedef enum __anonenum_scflags_48 scflags;
#line 59 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
struct error_info {
   int const   value ;
   char const   * const  name ;
};
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
struct array {
   region r ;
   void *data ;
   size_t elemsize ;
   type_t elemtype ;
   size_t nelems ;
   size_t nalloc ;
};
#line 136 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
enum __anonenum_cst_kind_33 {
    cst_any = 0,
    cst_numerical = 1,
    cst_address = 2
} ;
#line 136 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
typedef enum __anonenum_cst_kind_33 cst_kind;
#line 18 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
struct AST_implicit_decl;
#line 18 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_implicit_decl *implicit_decl;
#line 71
struct AST_designate_field;
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
typedef struct AST_designate_field *designate_field;
#line 235 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_implicit_decl {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   identifier ident ;
};
#line 1212 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
struct AST_designate_field {
   AST_kind kind ;
   location location ;
   node next ;
   node parent ;
   node *parent_ptr ;
   node instantiation ;
   cstring cstring ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_15 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_15 regmatch_t;
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
struct ND_nd_option;
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_nd_option *nd_option;
#line 5
struct ND_nd_arg;
#line 5 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_nd_arg *nd_arg;
#line 8
struct ND_nd_filter;
#line 8 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_nd_filter *nd_filter;
#line 9
struct ND_ndf_and;
#line 9 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_ndf_and *ndf_and;
#line 10
struct ND_ndf_or;
#line 10 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_ndf_or *ndf_or;
#line 11
struct ND_ndf_not;
#line 11 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_ndf_not *ndf_not;
#line 12
struct ND_ndf_op;
#line 12 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef struct ND_ndf_op *ndf_op;
#line 13
enum __anonenum_ND_kind_50 {
    kind_nd_option = 10000,
    postkind_nd_option = 10000,
    kind_nd_arg = 10001,
    postkind_nd_arg = 10008,
    kind_nd_int = 10002,
    postkind_nd_int = 10002,
    kind_nd_token = 10003,
    postkind_nd_token = 10003,
    kind_nd_filter = 10004,
    postkind_nd_filter = 10008,
    kind_ndf_and = 10005,
    postkind_ndf_and = 10005,
    kind_ndf_or = 10006,
    postkind_ndf_or = 10006,
    kind_ndf_not = 10007,
    postkind_ndf_not = 10007,
    kind_ndf_op = 10008,
    postkind_ndf_op = 10008
} ;
#line 13 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_types.h"
typedef enum __anonenum_ND_kind_50 ND_kind;
#line 7 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_nd_option {
   ND_kind kind ;
   char const   *name ;
   nd_arg args ;
   int count ;
};
#line 15 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_nd_arg {
   ND_kind kind ;
   nd_arg next ;
};
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_nd_filter {
   ND_kind kind ;
   nd_arg next ;
};
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_ndf_and {
   ND_kind kind ;
   nd_arg next ;
   nd_filter filter1 ;
   nd_filter filter2 ;
};
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_ndf_or {
   ND_kind kind ;
   nd_arg next ;
   nd_filter filter1 ;
   nd_filter filter2 ;
};
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_ndf_not {
   ND_kind kind ;
   nd_arg next ;
   nd_filter filter1 ;
};
#line 66 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
struct ND_ndf_op {
   ND_kind kind ;
   nd_arg next ;
   char const   *name ;
   nd_arg args ;
   int count ;
   void *info ;
   int filter_index ;
};
#line 233 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
struct filter_op {
   char const   *name ;
   char const   *args ;
   void (*compile)(ndf_op op ) ;
   bool (*execute_ddecl)(ndf_op op , data_declaration ddecl ) ;
   bool (*execute_ndecl)(ndf_op op , nesc_declaration ndecl ) ;
   bool (*execute_tdecl)(ndf_op op , tag_declaration tdecl ) ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 51 "./libcompat/regions.h"
extern region newsubregion(region parent ) ;
#line 57
extern void *typed_ralloc(region r , size_t size , type_t type ) ;
#line 62
extern void *__rcralloc_small0(region r , size_t size ) ;
#line 83
extern void deleteregion_ptr(region *r ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cstring.h"
extern cstring str2cstring(region r , char const   *s ) ;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
dd_list dd_new_list(region r ) ;
#line 51
void dd_add_last(region r , dd_list l , void *data ) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
location dummy_location ;
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.h"
node AST_node_last(node l ) ;
#line 7
node AST_node_reverse(node l ) ;
#line 641
declaration declaration_chain(declaration l1 , declaration l2 ) ;
#line 643
expression expression_chain(expression l1 , expression l2 ) ;
#line 644
type_element type_element_chain(type_element l1 , type_element l2 ) ;
#line 661
attribute attribute_chain(attribute l1 , attribute l2 ) ;
#line 706
designator designator_chain(designator l1 , designator l2 ) ;
#line 711
string string_chain(string l1 , string l2 ) ;
#line 712
id_label id_label_chain(id_label l1 , id_label l2 ) ;
#line 716
asm_operand asm_operand_chain(asm_operand l1 , asm_operand l2 ) ;
#line 726
component_ref component_ref_chain(component_ref l1 , component_ref l2 ) ;
#line 729
parameterised_identifier parameterised_identifier_chain(parameterised_identifier l1 ,
                                                        parameterised_identifier l2 ) ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type unsigned_char_type ;
#line 58
extern type error_type ;
#line 153
extern char *qualifier_name(type_quals q ) ;
#line 252
extern bool type_command(type t ) ;
#line 253
extern bool type_event(type t ) ;
#line 254
extern bool type_task(type t ) ;
#line 1761 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
asm_decl new_asm_decl(region r , location location___0 , asm_stmt asm_stmt___0 ) ;
#line 1762
data_decl new_data_decl(region r , location location___0 , type_element modifiers ,
                        declaration decls ) ;
#line 1763
extension_decl new_extension_decl(region r , location location___0 , declaration decl ) ;
#line 1764
ellipsis_decl new_ellipsis_decl(region r , location location___0 ) ;
#line 1772
typename new_typename(region r , location location___0 , data_declaration ddecl ) ;
#line 1773
typeof_expr new_typeof_expr(region r , location location___0 , expression arg1 ) ;
#line 1774
typeof_type new_typeof_type(region r , location location___0 , asttype asttype___0 ) ;
#line 1776
gcc_attribute new_gcc_attribute(region r , location location___0 , word word1 , expression args ) ;
#line 1777
rid new_rid(region r , location location___0 , enum rid id ) ;
#line 1778
qualifier new_qualifier(region r , location location___0 , enum rid id ) ;
#line 1783
function_declarator new_function_declarator(region r , location location___0 , declarator declarator___0 ,
                                            declaration parms , declaration gparms ,
                                            type_element qualifiers , environment env___0 ) ;
#line 1784
pointer_declarator new_pointer_declarator(region r , location location___0 , declarator declarator___0 ) ;
#line 1785
qualified_declarator new_qualified_declarator(region r , location location___0 , declarator declarator___0 ,
                                              type_element modifiers ) ;
#line 1786
array_declarator new_array_declarator(region r , location location___0 , declarator declarator___0 ,
                                      expression arg1 ) ;
#line 1787
identifier_declarator new_identifier_declarator(region r , location location___0 ,
                                                cstring cstring___0 ) ;
#line 1788
asm_stmt new_asm_stmt(region r , location location___0 , expression arg1 , asm_operand asm_operands1 ,
                      asm_operand asm_operands2 , string asm_clobbers , type_element qualifiers ) ;
#line 1789
compound_stmt new_compound_stmt(region r , location location___0 , id_label id_labels ,
                                declaration decls , statement stmts , environment env___0 ) ;
#line 1790
if_stmt new_if_stmt(region r , location location___0 , expression condition , statement stmt1 ,
                    statement stmt2 ) ;
#line 1791
labeled_stmt new_labeled_stmt(region r , location location___0 , label label___0 ,
                              statement stmt ) ;
#line 1792
expression_stmt new_expression_stmt(region r , location location___0 , expression arg1 ) ;
#line 1794
switch_stmt new_switch_stmt(region r , location location___0 , expression condition ,
                            statement stmt ) ;
#line 1795
for_stmt new_for_stmt(region r , location location___0 , expression arg1 , expression arg2 ,
                      expression arg3 , statement stmt ) ;
#line 1796
break_stmt new_break_stmt(region r , location location___0 ) ;
#line 1797
continue_stmt new_continue_stmt(region r , location location___0 ) ;
#line 1799
goto_stmt new_goto_stmt(region r , location location___0 , id_label id_label___0 ) ;
#line 1800
computed_goto_stmt new_computed_goto_stmt(region r , location location___0 , expression arg1 ) ;
#line 1801
empty_stmt new_empty_stmt(region r , location location___0 ) ;
#line 1826
id_label new_id_label(region r , location location___0 , cstring cstring___0 ) ;
#line 1827
case_label new_case_label(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1828
default_label new_default_label(region r , location location___0 ) ;
#line 1829
word new_word(region r , location location___0 , cstring cstring___0 ) ;
#line 1830
asm_operand new_asm_operand(region r , location location___0 , word word1 , string string___0 ,
                            expression arg1 ) ;
#line 1832
interface new_interface(region r , location location___0 , word word1 , attribute attributes ,
                        declaration decls ) ;
#line 1833
component new_component(region r , location location___0 , word word1 , attribute attributes ,
                        bool abstract , declaration parms , declaration decls , implementation implementation___0 ) ;
#line 1835
configuration new_configuration(region r , location location___0 , environment ienv ,
                                declaration decls ) ;
#line 1836
module new_module(region r , location location___0 , environment ienv , declaration decls ) ;
#line 1837
binary_component new_binary_component(region r , location location___0 , environment ienv ) ;
#line 1838
rp_interface new_rp_interface(region r , location location___0 , bool required , declaration decls ) ;
#line 1839
interface_ref new_interface_ref(region r , location location___0 , word word1 , expression args ,
                                word word2 , declaration gparms , attribute attributes ,
                                data_declaration ddecl ) ;
#line 1840
component_ref new_component_ref(region r , location location___0 , word word1 , word word2 ,
                                bool abstract , expression args ) ;
#line 1842
endpoint new_endpoint(region r , location location___0 , parameterised_identifier ids ) ;
#line 1843
parameterised_identifier new_parameterised_identifier(region r , location location___0 ,
                                                      word word1 , expression args ) ;
#line 1849
component_typeref new_component_typeref(region r , location location___0 , data_declaration ddecl ,
                                        cstring cstring___0 ) ;
#line 1850
atomic_stmt new_atomic_stmt(region r , location location___0 , statement stmt ) ;
#line 1854
error_decl new_error_decl(region r , location location___0 ) ;
#line 1857
error_stmt new_error_stmt(region r , location location___0 ) ;
#line 1858
while_stmt new_while_stmt(region r , location location___0 , expression condition ,
                          statement stmt ) ;
#line 1859
dowhile_stmt new_dowhile_stmt(region r , location location___0 , expression condition ,
                              statement stmt ) ;
#line 1907
rp_connection new_rp_connection(region r , location location___0 , endpoint ep1 ,
                                endpoint ep2 ) ;
#line 1908
eq_connection new_eq_connection(region r , location location___0 , endpoint ep1 ,
                                endpoint ep2 ) ;
#line 1911
target_attribute new_target_attribute(region r , location location___0 , word word1 ,
                                      expression args ) ;
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int extra_warnings ;
#line 156
int flag_traditional ;
#line 175
bool pedantic ;
#line 250
int flag_use_scheduler ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
int errorcount ;
#line 49
void error(char const   *format  , ...) ;
#line 55
void error_with_location(location l , char const   *format  , ...) ;
#line 72
void warning(char const   *format  , ...) ;
#line 79
void warning_with_location(location l , char const   *format  , ...) ;
#line 93
void pedwarn(char const   *format  , ...) ;
#line 92 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-parse.h"
region parse_region  ;
#line 97
bool unevaluated_expression(void) ;
#line 99
node parse(void) ;
#line 104
declaration make_error_decl(void) ;
#line 105
declarator make_identifier_declarator(location l , cstring id ) ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex-int.h"
int yylex(struct yystype *lvalp ) ;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern void pending_xref_error(void) ;
#line 55
extern void shadow_tag(type_element elements ) ;
#line 58
extern void shadow_tag_warned(type_element elements , int warned ) ;
#line 61
extern declarator finish_array_or_fn_declarator(declarator nested , nested_declarator d ) ;
#line 67
extern bool start_function(type_element elements , declarator d , attribute attribs ,
                           bool nested ) ;
#line 71
extern void store_parm_decls(declaration old_parms ) ;
#line 74
extern declaration finish_function(statement body ) ;
#line 78
extern void pushlevel(bool parm_level ) ;
#line 81
extern environment poplevel(void) ;
#line 92
extern declaration start_decl(declarator d , asm_stmt astmt , type_element elements ,
                              bool initialised , attribute attributes ) ;
#line 97
extern declaration finish_decl(declaration decl , expression init ) ;
#line 103
extern declaration declare_parameter(declarator d , type_element elements , attribute attributes ) ;
#line 108
extern void allow_parameter_redeclaration(declaration parms , bool mark_forward ) ;
#line 110
extern declaration declare_old_parameter(location l , cstring id ) ;
#line 114
extern type_element start_struct(location l , AST_kind skind , word tag ) ;
#line 118
extern type_element finish_struct(type_element t , declaration fields , attribute attribs ) ;
#line 122
extern type_element xref_tag(location l , AST_kind skind , word tag ) ;
#line 125
extern type_element start_enum(location l , word tag ) ;
#line 129
extern type_element finish_enum(type_element t , declaration names , attribute attribs ) ;
#line 137
extern declaration make_field(declarator d , expression bitfield , type_element elements ,
                              attribute attributes ) ;
#line 140
extern declaration make_enumerator(location loc , cstring id , expression value ) ;
#line 144
extern asttype make_type(type_element elements , declarator d ) ;
#line 147
extern char *rid_name(rid r ) ;
#line 151
extern statement chain_with_labels(statement l1 , statement l2 ) ;
#line 163
extern void push_label_level(void) ;
#line 164
extern void pop_label_level(void) ;
#line 212
extern struct semantic_state current ;
#line 240
extern expression make_attr_args(location loc , cstring id , expression args ) ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.h"
expression make_error_expr(void) ;
#line 28
expression make_comma(location loc , expression elist ) ;
#line 29
expression make_dereference(location loc , expression e ) ;
#line 30
expression make_extension_expr(location loc , expression e ) ;
#line 31
expression make_unary(location loc , int unop , expression e ) ;
#line 32
expression make_label_address(location loc , id_label label___0 ) ;
#line 33
expression make_sizeof_expr(location loc , expression e ) ;
#line 34
expression make_sizeof_type(location loc , asttype t ) ;
#line 35
expression make_alignof_expr(location loc , expression e ) ;
#line 36
expression make_alignof_type(location loc , asttype t ) ;
#line 37
expression make_cast(location loc , asttype t , expression e ) ;
#line 38
expression make_binary(location loc , int binop , expression e1 , expression e2 ) ;
#line 39
expression make_conditional(location loc , expression cond , expression true , expression false ) ;
#line 41
expression make_assign(location loc , int binop , expression e1 , expression e2 ) ;
#line 42
expression make_identifier(location loc , cstring id , bool maybe_implicit ) ;
#line 43
expression make_compound_expr(location loc , statement block ) ;
#line 44
expression make_function_call(location loc , expression fn , expression arglist ) ;
#line 45
expression make_va_arg(location loc , expression arg , asttype type___0 ) ;
#line 46
expression make_offsetof(location loc , asttype t , dd_list fields ) ;
#line 47
expression make_array_ref(location loc , expression array , expression index___0 ) ;
#line 48
expression make_field_ref(location loc , expression object , cstring field ) ;
#line 51
expression make_postincrement(location loc , expression e ) ;
#line 53
expression make_postdecrement(location loc , expression e ) ;
#line 69
type default_conversion_for_assignment(expression e ) ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/stmt.h"
extern void check_condition(char const   *context , expression e ) ;
#line 27
extern void check_switch(expression e ) ;
#line 30
extern void check_computed_goto(expression e ) ;
#line 31
extern statement make_return(location loc , expression arg ) ;
#line 32
extern statement make_void_return(location loc ) ;
#line 35
extern void use_label(id_label label ) ;
#line 36
extern void define_label(id_label label ) ;
#line 37
extern void declare_label(id_label label ) ;
#line 41
extern void check_case(label case_label ) ;
#line 43
extern void check_default(label default_label ) ;
#line 44
extern void check_break(statement break_statement ) ;
#line 45
extern void check_continue(statement continue_statement ) ;
#line 46
extern void fail_in_atomic(char const   *context ) ;
#line 48
extern void push_loop(statement loop_statement ) ;
#line 49
extern void pop_loop(void) ;
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/init.h"
extern void start_init(declaration decl , nesc_attribute attr ) ;
#line 62
extern void finish_init(void) ;
#line 63
extern void simple_init(expression expr ) ;
#line 64
extern void really_start_incremental_init(type t ) ;
#line 65
extern void push_init_level(int implicit ) ;
#line 66
extern designator set_init_index(location loc , expression first , expression last ) ;
#line 67
extern designator set_init_label(location loc , cstring fieldname ) ;
#line 68
extern void process_init_element(expression value ) ;
#line 70
extern expression make_init_specific(designator dlist , expression initval ) ;
#line 71
extern expression make_init_list(location loc , expression elist ) ;
#line 72
extern expression make_cast_list(location loc , asttype t , expression init ) ;
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.h"
nesc_declaration start_nesc_entity(source_language sl , word name ) ;
#line 113
declaration declare_template_parameter(declarator d , type_element elements , attribute attributes ) ;
#line 115
declaration declare_type_parameter(location l , cstring id , attribute attribs , dd_list extra_attr ) ;
#line 118
expression make_type_argument(asttype t ) ;
#line 22 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-component.h"
extern void declare_interface_ref(interface_ref iref , declaration gparms , environment genv ,
                                  attribute attribs ) ;
#line 28
extern void check_interface_parameter_types(declaration parms ) ;
#line 30
extern environment start_implementation(void) ;
#line 25 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-configuration.h"
extern component_ref require_component(component_ref comp , word as ) ;
#line 23 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-module.h"
extern declarator make_interface_ref_declarator(location l , cstring w1 , cstring w2 ) ;
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-env.h"
extern void preload(source_language sl , location l , char const   *name ) ;
#line 33
extern void require_c(location l , char const   *name ) ;
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-c.h"
extern void add_cdecls(declaration cdecls ) ;
#line 6 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-attributes.h"
extern nesc_attribute start_attribute_use(word name ) ;
#line 7
extern attribute finish_attribute_use(nesc_attribute attr , expression init ) ;
#line 22 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-task.h"
extern declaration all_tasks ;
#line 27
extern void handle_post(function_call fcall ) ;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-cpp.h"
extern void end_macro_saving(void) ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.h"
void handle_nescdecl_attributes(attribute alist , nesc_declaration ndecl ) ;
#line 54 "/home/wheatley/newnew/temp/nescc-1.3.4/src/machine.h"
extern machine_spec *target ;
#line 59 "c-parse.y"
int yyparse(void) ;
#line 61
void yyerror(char *string___0 ) ;
#line 258 "c-parse.y"
static int stmt_count  ;
#line 259 "c-parse.y"
static int compstmt_count  ;
#line 294 "c-parse.y"
struct parse_state pstate  ;
#line 312 "c-parse.y"
bool unevaluated_expression(void) 
{ 


  {
#line 314
  return ((bool )(pstate.unevaluated_expression != 0));
}
}
#line 319 "c-parse.y"
static void pop_declspec_stack(void) 
{ 


  {
#line 321
  pstate.declspecs = (pstate.declspec_stack)->declspecs;
#line 322
  pstate.attributes = (pstate.declspec_stack)->attributes;
#line 323
  pstate.declspec_stack = (pstate.declspec_stack)->next;
#line 324
  return;
}
}
#line 326 "c-parse.y"
static void push_declspec_stack(void) 
{ 
  spec_stack news ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 330
  if (sizeof(struct spec_stack ) < (unsigned long )(1 << 9)) {
    {
#line 330
    tmp = __rcralloc_small0(pstate.ds_region, sizeof(struct spec_stack ));
#line 330
    news = (spec_stack )tmp;
    }
  } else {
    {
#line 330
    tmp___0 = typed_ralloc(pstate.ds_region, sizeof(struct spec_stack ), 0);
#line 330
    news = (spec_stack )tmp___0;
    }
  }
#line 331
  news->declspecs = pstate.declspecs;
#line 332
  news->attributes = pstate.attributes;
#line 333
  news->next = pstate.declspec_stack;
#line 334
  pstate.declspec_stack = news;
#line 335
  return;
}
}
#line 337 "c-parse.y"
static node parse_tree  ;
#line 339 "c-parse.y"
node parse(void) 
{ 
  int result ;
  int old_errorcount ;
  struct parse_state old_pstate ;

  {
  {
#line 341
  old_errorcount = errorcount;
#line 342
  old_pstate = pstate;
#line 344
  pstate.declspecs = (type_element )((void *)0);
#line 345
  pstate.attributes = (attribute )((void *)0);
#line 346
  pstate.unevaluated_expression = 0;
#line 347
  pstate.declspec_stack = (spec_stack )((void *)0);
#line 348
  pstate.ds_region = newsubregion(parse_region);
#line 349
  parse_tree = (node )((void *)0);
#line 350
  result = yyparse();
  }
#line 351
  if (result) {
#line 352
    parse_tree = (node )((void *)0);
  }
  {
#line 353
  deleteregion_ptr(& pstate.ds_region);
  }
#line 355
  if (result != 0) {
#line 355
    if (errorcount == old_errorcount) {
      {
#line 356
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Errors detected in input file (your bison.simple is out of date)");
      }
    }
  }
#line 358
  pstate = old_pstate;
#line 360
  return (parse_tree);
}
}
#line 363 "c-parse.y"
static void set_nesc_ast(void *tree ) 
{ 
  nesc_declaration cdecl ;
  nesc_decl nd ;
  AST_generic tEmPcast ;

  {
#line 365
  cdecl = current.container;
#line 366
  tEmPcast = (AST_generic )tree;
#line 366
  if (tEmPcast) {
#line 366
    if ((unsigned int )tEmPcast->kind >= 54U) {
#line 366
      if (! ((unsigned int )tEmPcast->kind <= 56U)) {
        {
#line 366
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "c-parse.y", 366U, "set_nesc_ast");
        }
      }
    } else {
      {
#line 366
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "c-parse.y", 366U, "set_nesc_ast");
      }
    }
  }
#line 366
  nd = (nesc_decl )tEmPcast;
#line 368
  nd->cdecl = cdecl;
#line 369
  cdecl->ast = nd;
#line 370
  return;
}
}
#line 372 "c-parse.y"
static void set_nesc_parse_tree(void *tree ) 
{ 
  AST_generic tEmPcast ;

  {
  {
#line 374
  set_nesc_ast(tree);
#line 375
  tEmPcast = (AST_generic )tree;
  }
#line 375
  if (tEmPcast) {
#line 375
    if ((unsigned int )tEmPcast->kind >= 42U) {
#line 375
      if (! ((unsigned int )tEmPcast->kind <= 199U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 375U, "set_nesc_parse_tree");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 375U, "set_nesc_parse_tree");
      }
    }
  }
#line 375
  parse_tree = (node )tEmPcast;
#line 376
  return;
}
}
#line 378 "c-parse.y"
static void set_nesc_impl(implementation impl ) 
{ 
  nesc_declaration cdecl ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 380
  cdecl = current.container;
#line 382
  tEmPcast = (AST_generic )cdecl->ast;
#line 382
  if (tEmPcast) {
#line 382
    if ((unsigned int )tEmPcast->kind >= 56U) {
#line 382
      if (! ((unsigned int )tEmPcast->kind <= 56U)) {
        {
#line 382
        __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                      "c-parse.y", 382U, "set_nesc_impl");
        }
      }
    } else {
      {
#line 382
      __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                    "c-parse.y", 382U, "set_nesc_impl");
      }
    }
  }
#line 382
  ((component )tEmPcast)->implementation = impl;
#line 383
  tEmPcast___0 = (AST_generic )cdecl->ast;
#line 383
  if (tEmPcast___0) {
#line 383
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 383
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 383
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 383U, "set_nesc_impl");
        }
      }
    } else {
      {
#line 383
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 383U, "set_nesc_impl");
      }
    }
  }
#line 383
  parse_tree = (node )tEmPcast___0;
#line 384
  return;
}
}
#line 386 "c-parse.y"
void refuse_asm(asm_stmt s ) 
{ 


  {
#line 388
  if (s) {
    {
#line 389
    error_with_location(s->location, "unexpected asm statement");
    }
  }
#line 390
  return;
}
}
#line 395 "c-parse.y"
attribute prefix_attr(attribute post_attr ) 
{ 
  attribute tmp ;

  {
  {
#line 397
  tmp = attribute_chain(pstate.attributes, post_attr);
  }
#line 397
  return (tmp);
}
}
#line 401 "c-parse.y"
declaration make_data_decl(type_element modifiers , declaration decls ) 
{ 
  location l ;
  location tmp ;
  data_decl dd ;
  data_decl tmp___0 ;
  AST_generic tEmPcast ;

  {
#line 403
  if (modifiers) {
#line 403
    tmp = modifiers->location;
  } else {
#line 403
    tmp = decls->location;
  }
  {
#line 403
  l = tmp;
#line 405
  tmp___0 = new_data_decl(parse_region, l, modifiers, decls);
#line 405
  dd = tmp___0;
#line 407
  pop_declspec_stack();
  }
#line 409
  if ((unsigned long )decls == (unsigned long )((void *)0)) {
#line 409
    if ((unsigned int )current.spec_section != 0U) {
      {
#line 410
      error("provides/uses must be followed by a command, event or interface");
      }
    }
  }
#line 412
  tEmPcast = (AST_generic )dd;
#line 412
  if (tEmPcast) {
#line 412
    if ((unsigned int )tEmPcast->kind >= 43U) {
#line 412
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 412
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 412U, "make_data_decl");
        }
      }
    } else {
      {
#line 412
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 412U, "make_data_decl");
      }
    }
  }
#line 412
  return ((declaration )tEmPcast);
}
}
#line 415 "c-parse.y"
declaration make_error_decl(void) 
{ 
  error_decl tmp ;

  {
  {
#line 417
  tmp = new_error_decl(parse_region, dummy_location);
  }
#line 417
  return (tmp);
}
}
#line 420 "c-parse.y"
declaration make_extension_decl(int old_pedantic , location l , declaration d ) 
{ 
  AST_generic tEmPcast ;
  extension_decl tmp ;

  {
  {
#line 422
  pedantic = (bool )old_pedantic;
#line 423
  tmp = new_extension_decl(parse_region, l, d);
#line 423
  tEmPcast = (AST_generic )tmp;
  }
#line 423
  if (tEmPcast) {
#line 423
    if ((unsigned int )tEmPcast->kind >= 43U) {
#line 423
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 423
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 423U, "make_extension_decl");
        }
      }
    } else {
      {
#line 423
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 423U, "make_extension_decl");
      }
    }
  }
#line 423
  return ((declaration )tEmPcast);
}
}
#line 426 "c-parse.y"
word make_cword(location l , char const   *s ) 
{ 
  cstring tmp ;
  word tmp___0 ;

  {
  {
#line 428
  tmp = str2cstring(parse_region, s);
#line 428
  tmp___0 = new_word(parse_region, l, tmp);
  }
#line 428
  return (tmp___0);
}
}
#line 431 "c-parse.y"
declarator make_qualified_declarator(location l , declarator d , type_element quals ) 
{ 
  AST_generic tEmPcast ;
  qualified_declarator tmp ;

  {
#line 433
  if (quals) {
    {
#line 434
    tmp = new_qualified_declarator(parse_region, l, d, quals);
#line 434
    tEmPcast = (AST_generic )tmp;
    }
#line 434
    if (tEmPcast) {
#line 434
      if ((unsigned int )tEmPcast->kind >= 175U) {
#line 434
        if (! ((unsigned int )tEmPcast->kind <= 183U)) {
          {
#line 434
          __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                        "c-parse.y", 434U, "make_qualified_declarator");
          }
        }
      } else {
        {
#line 434
        __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                      "c-parse.y", 434U, "make_qualified_declarator");
        }
      }
    }
#line 434
    return ((declarator )tEmPcast);
  } else {
#line 436
    return (d);
  }
}
}
#line 439 "c-parse.y"
declarator make_pointer_declarator(location l , declarator d , type_element quals ) 
{ 
  AST_generic tEmPcast ;
  pointer_declarator tmp ;

  {
  {
#line 441
  d = make_qualified_declarator(l, d, quals);
#line 443
  tmp = new_pointer_declarator(parse_region, l, d);
#line 443
  tEmPcast = (AST_generic )tmp;
  }
#line 443
  if (tEmPcast) {
#line 443
    if ((unsigned int )tEmPcast->kind >= 175U) {
#line 443
      if (! ((unsigned int )tEmPcast->kind <= 183U)) {
        {
#line 443
        __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                      "c-parse.y", 443U, "make_pointer_declarator");
        }
      }
    } else {
      {
#line 443
      __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                    "c-parse.y", 443U, "make_pointer_declarator");
      }
    }
  }
#line 443
  return ((declarator )tEmPcast);
}
}
#line 446 "c-parse.y"
declarator make_identifier_declarator(location l , cstring id ) 
{ 
  AST_generic tEmPcast ;
  identifier_declarator tmp ;

  {
  {
#line 448
  tmp = new_identifier_declarator(parse_region, l, id);
#line 448
  tEmPcast = (AST_generic )tmp;
  }
#line 448
  if (tEmPcast) {
#line 448
    if ((unsigned int )tEmPcast->kind >= 175U) {
#line 448
      if (! ((unsigned int )tEmPcast->kind <= 183U)) {
        {
#line 448
        __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                      "c-parse.y", 448U, "make_identifier_declarator");
        }
      }
    } else {
      {
#line 448
      __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                    "c-parse.y", 448U, "make_identifier_declarator");
      }
    }
  }
#line 448
  return ((declarator )tEmPcast);
}
}
#line 451 "c-parse.y"
statement make_error_stmt(void) 
{ 
  error_stmt tmp ;

  {
  {
#line 453
  tmp = new_error_stmt(parse_region, dummy_location);
  }
#line 453
  return (tmp);
}
}
#line 459
void yyprint(FILE *file , int yychar , struct yystype yylval ) ;
#line 677 "c-parse.tab.c"
static yytype_uint8 const   yytranslate[333]  = 
#line 677 "c-parse.tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )67,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )59,      (yytype_uint8 const   )48,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )101,      (yytype_uint8 const   )57,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )56,      (yytype_uint8 const   )62,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )43,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )40,      (yytype_uint8 const   )51,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )100,      (yytype_uint8 const   )47,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )99,      (yytype_uint8 const   )66,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )49,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97};
#line 718 "c-parse.tab.c"
static yytype_uint16 const   yyprhs[634]  = 
#line 718
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )6, 
        (yytype_uint16 const   )9,      (yytype_uint16 const   )12,      (yytype_uint16 const   )14,      (yytype_uint16 const   )17, 
        (yytype_uint16 const   )20,      (yytype_uint16 const   )23,      (yytype_uint16 const   )26,      (yytype_uint16 const   )27, 
        (yytype_uint16 const   )30,      (yytype_uint16 const   )32,      (yytype_uint16 const   )35,      (yytype_uint16 const   )36, 
        (yytype_uint16 const   )40,      (yytype_uint16 const   )42,      (yytype_uint16 const   )46,      (yytype_uint16 const   )47, 
        (yytype_uint16 const   )48,      (yytype_uint16 const   )59,      (yytype_uint16 const   )60,      (yytype_uint16 const   )64, 
        (yytype_uint16 const   )66,      (yytype_uint16 const   )70,      (yytype_uint16 const   )73,      (yytype_uint16 const   )75, 
        (yytype_uint16 const   )78,      (yytype_uint16 const   )80,      (yytype_uint16 const   )81,      (yytype_uint16 const   )85, 
        (yytype_uint16 const   )88,      (yytype_uint16 const   )91,      (yytype_uint16 const   )94,      (yytype_uint16 const   )97, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )101,      (yytype_uint16 const   )102,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )116,      (yytype_uint16 const   )117,      (yytype_uint16 const   )130, 
        (yytype_uint16 const   )131,      (yytype_uint16 const   )132,      (yytype_uint16 const   )141,      (yytype_uint16 const   )143, 
        (yytype_uint16 const   )144,      (yytype_uint16 const   )145,      (yytype_uint16 const   )149,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )154,      (yytype_uint16 const   )158,      (yytype_uint16 const   )163, 
        (yytype_uint16 const   )168,      (yytype_uint16 const   )173,      (yytype_uint16 const   )176,      (yytype_uint16 const   )178, 
        (yytype_uint16 const   )181,      (yytype_uint16 const   )182,      (yytype_uint16 const   )184,      (yytype_uint16 const   )186, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )190,      (yytype_uint16 const   )191,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )200,      (yytype_uint16 const   )202,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )209,      (yytype_uint16 const   )211,      (yytype_uint16 const   )213,      (yytype_uint16 const   )217, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )224,      (yytype_uint16 const   )228,      (yytype_uint16 const   )231, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )239,      (yytype_uint16 const   )241,      (yytype_uint16 const   )245, 
        (yytype_uint16 const   )246,      (yytype_uint16 const   )252,      (yytype_uint16 const   )256,      (yytype_uint16 const   )260, 
        (yytype_uint16 const   )262,      (yytype_uint16 const   )264,      (yytype_uint16 const   )268,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )279,      (yytype_uint16 const   )281, 
        (yytype_uint16 const   )285,      (yytype_uint16 const   )287,      (yytype_uint16 const   )289,      (yytype_uint16 const   )291, 
        (yytype_uint16 const   )294,      (yytype_uint16 const   )295,      (yytype_uint16 const   )297,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )301,      (yytype_uint16 const   )306,      (yytype_uint16 const   )311,      (yytype_uint16 const   )316, 
        (yytype_uint16 const   )320,      (yytype_uint16 const   )322,      (yytype_uint16 const   )324,      (yytype_uint16 const   )329, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )336,      (yytype_uint16 const   )337,      (yytype_uint16 const   )340, 
        (yytype_uint16 const   )341,      (yytype_uint16 const   )345,      (yytype_uint16 const   )347,      (yytype_uint16 const   )349, 
        (yytype_uint16 const   )355,      (yytype_uint16 const   )358,      (yytype_uint16 const   )362,      (yytype_uint16 const   )364, 
        (yytype_uint16 const   )369,      (yytype_uint16 const   )374,      (yytype_uint16 const   )378,      (yytype_uint16 const   )381, 
        (yytype_uint16 const   )384,      (yytype_uint16 const   )386,      (yytype_uint16 const   )388,      (yytype_uint16 const   )394, 
        (yytype_uint16 const   )399,      (yytype_uint16 const   )404,      (yytype_uint16 const   )408,      (yytype_uint16 const   )409, 
        (yytype_uint16 const   )410,      (yytype_uint16 const   )417,      (yytype_uint16 const   )419,      (yytype_uint16 const   )421, 
        (yytype_uint16 const   )423,      (yytype_uint16 const   )425,      (yytype_uint16 const   )427,      (yytype_uint16 const   )429, 
        (yytype_uint16 const   )431,      (yytype_uint16 const   )433,      (yytype_uint16 const   )435,      (yytype_uint16 const   )437, 
        (yytype_uint16 const   )439,      (yytype_uint16 const   )441,      (yytype_uint16 const   )443,      (yytype_uint16 const   )445, 
        (yytype_uint16 const   )446,      (yytype_uint16 const   )448,      (yytype_uint16 const   )450,      (yytype_uint16 const   )452, 
        (yytype_uint16 const   )456,      (yytype_uint16 const   )458,      (yytype_uint16 const   )460,      (yytype_uint16 const   )462, 
        (yytype_uint16 const   )464,      (yytype_uint16 const   )467,      (yytype_uint16 const   )470,      (yytype_uint16 const   )473, 
        (yytype_uint16 const   )476,      (yytype_uint16 const   )479,      (yytype_uint16 const   )482,      (yytype_uint16 const   )487, 
        (yytype_uint16 const   )490,      (yytype_uint16 const   )495,      (yytype_uint16 const   )497,      (yytype_uint16 const   )499, 
        (yytype_uint16 const   )501,      (yytype_uint16 const   )506,      (yytype_uint16 const   )507,      (yytype_uint16 const   )515, 
        (yytype_uint16 const   )517,      (yytype_uint16 const   )521,      (yytype_uint16 const   )525,      (yytype_uint16 const   )529, 
        (yytype_uint16 const   )533,      (yytype_uint16 const   )537,      (yytype_uint16 const   )541,      (yytype_uint16 const   )545, 
        (yytype_uint16 const   )549,      (yytype_uint16 const   )553,      (yytype_uint16 const   )557,      (yytype_uint16 const   )561, 
        (yytype_uint16 const   )565,      (yytype_uint16 const   )569,      (yytype_uint16 const   )573,      (yytype_uint16 const   )577, 
        (yytype_uint16 const   )581,      (yytype_uint16 const   )587,      (yytype_uint16 const   )588,      (yytype_uint16 const   )594, 
        (yytype_uint16 const   )598,      (yytype_uint16 const   )602,      (yytype_uint16 const   )604,      (yytype_uint16 const   )606, 
        (yytype_uint16 const   )608,      (yytype_uint16 const   )612,      (yytype_uint16 const   )616,      (yytype_uint16 const   )617, 
        (yytype_uint16 const   )622,      (yytype_uint16 const   )624,      (yytype_uint16 const   )631,      (yytype_uint16 const   )638, 
        (yytype_uint16 const   )643,      (yytype_uint16 const   )647,      (yytype_uint16 const   )651,      (yytype_uint16 const   )654, 
        (yytype_uint16 const   )657,      (yytype_uint16 const   )659,      (yytype_uint16 const   )663,      (yytype_uint16 const   )668, 
        (yytype_uint16 const   )670,      (yytype_uint16 const   )672,      (yytype_uint16 const   )673,      (yytype_uint16 const   )675, 
        (yytype_uint16 const   )678,      (yytype_uint16 const   )680,      (yytype_uint16 const   )683,      (yytype_uint16 const   )688, 
        (yytype_uint16 const   )693,      (yytype_uint16 const   )697,      (yytype_uint16 const   )700,      (yytype_uint16 const   )702, 
        (yytype_uint16 const   )704,      (yytype_uint16 const   )707,      (yytype_uint16 const   )710,      (yytype_uint16 const   )711, 
        (yytype_uint16 const   )713,      (yytype_uint16 const   )718,      (yytype_uint16 const   )723,      (yytype_uint16 const   )727, 
        (yytype_uint16 const   )731,      (yytype_uint16 const   )735,      (yytype_uint16 const   )738,      (yytype_uint16 const   )740, 
        (yytype_uint16 const   )743,      (yytype_uint16 const   )746,      (yytype_uint16 const   )749,      (yytype_uint16 const   )752, 
        (yytype_uint16 const   )755,      (yytype_uint16 const   )757,      (yytype_uint16 const   )760,      (yytype_uint16 const   )762, 
        (yytype_uint16 const   )765,      (yytype_uint16 const   )768,      (yytype_uint16 const   )771,      (yytype_uint16 const   )774, 
        (yytype_uint16 const   )777,      (yytype_uint16 const   )780,      (yytype_uint16 const   )782,      (yytype_uint16 const   )785, 
        (yytype_uint16 const   )788,      (yytype_uint16 const   )791,      (yytype_uint16 const   )794,      (yytype_uint16 const   )797, 
        (yytype_uint16 const   )800,      (yytype_uint16 const   )803,      (yytype_uint16 const   )806,      (yytype_uint16 const   )809, 
        (yytype_uint16 const   )812,      (yytype_uint16 const   )815,      (yytype_uint16 const   )818,      (yytype_uint16 const   )821, 
        (yytype_uint16 const   )824,      (yytype_uint16 const   )827,      (yytype_uint16 const   )830,      (yytype_uint16 const   )832, 
        (yytype_uint16 const   )835,      (yytype_uint16 const   )838,      (yytype_uint16 const   )841,      (yytype_uint16 const   )844, 
        (yytype_uint16 const   )847,      (yytype_uint16 const   )850,      (yytype_uint16 const   )853,      (yytype_uint16 const   )856, 
        (yytype_uint16 const   )859,      (yytype_uint16 const   )862,      (yytype_uint16 const   )865,      (yytype_uint16 const   )868, 
        (yytype_uint16 const   )871,      (yytype_uint16 const   )874,      (yytype_uint16 const   )877,      (yytype_uint16 const   )880, 
        (yytype_uint16 const   )883,      (yytype_uint16 const   )886,      (yytype_uint16 const   )889,      (yytype_uint16 const   )892, 
        (yytype_uint16 const   )895,      (yytype_uint16 const   )898,      (yytype_uint16 const   )901,      (yytype_uint16 const   )904, 
        (yytype_uint16 const   )907,      (yytype_uint16 const   )910,      (yytype_uint16 const   )913,      (yytype_uint16 const   )916, 
        (yytype_uint16 const   )919,      (yytype_uint16 const   )922,      (yytype_uint16 const   )925,      (yytype_uint16 const   )928, 
        (yytype_uint16 const   )931,      (yytype_uint16 const   )934,      (yytype_uint16 const   )937,      (yytype_uint16 const   )940, 
        (yytype_uint16 const   )943,      (yytype_uint16 const   )946,      (yytype_uint16 const   )949,      (yytype_uint16 const   )952, 
        (yytype_uint16 const   )955,      (yytype_uint16 const   )958,      (yytype_uint16 const   )961,      (yytype_uint16 const   )964, 
        (yytype_uint16 const   )966,      (yytype_uint16 const   )968,      (yytype_uint16 const   )970,      (yytype_uint16 const   )972, 
        (yytype_uint16 const   )974,      (yytype_uint16 const   )976,      (yytype_uint16 const   )978,      (yytype_uint16 const   )980, 
        (yytype_uint16 const   )982,      (yytype_uint16 const   )984,      (yytype_uint16 const   )986,      (yytype_uint16 const   )988, 
        (yytype_uint16 const   )990,      (yytype_uint16 const   )992,      (yytype_uint16 const   )994,      (yytype_uint16 const   )996, 
        (yytype_uint16 const   )998,      (yytype_uint16 const   )1000,      (yytype_uint16 const   )1002,      (yytype_uint16 const   )1004, 
        (yytype_uint16 const   )1006,      (yytype_uint16 const   )1008,      (yytype_uint16 const   )1010,      (yytype_uint16 const   )1012, 
        (yytype_uint16 const   )1014,      (yytype_uint16 const   )1016,      (yytype_uint16 const   )1018,      (yytype_uint16 const   )1020, 
        (yytype_uint16 const   )1022,      (yytype_uint16 const   )1024,      (yytype_uint16 const   )1026,      (yytype_uint16 const   )1028, 
        (yytype_uint16 const   )1030,      (yytype_uint16 const   )1032,      (yytype_uint16 const   )1034,      (yytype_uint16 const   )1036, 
        (yytype_uint16 const   )1037,      (yytype_uint16 const   )1039,      (yytype_uint16 const   )1041,      (yytype_uint16 const   )1043, 
        (yytype_uint16 const   )1045,      (yytype_uint16 const   )1047,      (yytype_uint16 const   )1049,      (yytype_uint16 const   )1051, 
        (yytype_uint16 const   )1053,      (yytype_uint16 const   )1057,      (yytype_uint16 const   )1062,      (yytype_uint16 const   )1067, 
        (yytype_uint16 const   )1069,      (yytype_uint16 const   )1071,      (yytype_uint16 const   )1073,      (yytype_uint16 const   )1078, 
        (yytype_uint16 const   )1080,      (yytype_uint16 const   )1085,      (yytype_uint16 const   )1086,      (yytype_uint16 const   )1091, 
        (yytype_uint16 const   )1092,      (yytype_uint16 const   )1099,      (yytype_uint16 const   )1103,      (yytype_uint16 const   )1104, 
        (yytype_uint16 const   )1111,      (yytype_uint16 const   )1115,      (yytype_uint16 const   )1116,      (yytype_uint16 const   )1118, 
        (yytype_uint16 const   )1120,      (yytype_uint16 const   )1121,      (yytype_uint16 const   )1124,      (yytype_uint16 const   )1126, 
        (yytype_uint16 const   )1129,      (yytype_uint16 const   )1136,      (yytype_uint16 const   )1138,      (yytype_uint16 const   )1140, 
        (yytype_uint16 const   )1142,      (yytype_uint16 const   )1145,      (yytype_uint16 const   )1148,      (yytype_uint16 const   )1150, 
        (yytype_uint16 const   )1152,      (yytype_uint16 const   )1156,      (yytype_uint16 const   )1158,      (yytype_uint16 const   )1162, 
        (yytype_uint16 const   )1163,      (yytype_uint16 const   )1165,      (yytype_uint16 const   )1170,      (yytype_uint16 const   )1177, 
        (yytype_uint16 const   )1182,      (yytype_uint16 const   )1188,      (yytype_uint16 const   )1193,      (yytype_uint16 const   )1195, 
        (yytype_uint16 const   )1197,      (yytype_uint16 const   )1199,      (yytype_uint16 const   )1201,      (yytype_uint16 const   )1203, 
        (yytype_uint16 const   )1205,      (yytype_uint16 const   )1207,      (yytype_uint16 const   )1208,      (yytype_uint16 const   )1213, 
        (yytype_uint16 const   )1215,      (yytype_uint16 const   )1216,      (yytype_uint16 const   )1219,      (yytype_uint16 const   )1221, 
        (yytype_uint16 const   )1225,      (yytype_uint16 const   )1229,      (yytype_uint16 const   )1232,      (yytype_uint16 const   )1233, 
        (yytype_uint16 const   )1238,      (yytype_uint16 const   )1240,      (yytype_uint16 const   )1241,      (yytype_uint16 const   )1246, 
        (yytype_uint16 const   )1248,      (yytype_uint16 const   )1250,      (yytype_uint16 const   )1252,      (yytype_uint16 const   )1255, 
        (yytype_uint16 const   )1258,      (yytype_uint16 const   )1264,      (yytype_uint16 const   )1268,      (yytype_uint16 const   )1269, 
        (yytype_uint16 const   )1270,      (yytype_uint16 const   )1278,      (yytype_uint16 const   )1279,      (yytype_uint16 const   )1280, 
        (yytype_uint16 const   )1288,      (yytype_uint16 const   )1290,      (yytype_uint16 const   )1292,      (yytype_uint16 const   )1295, 
        (yytype_uint16 const   )1299,      (yytype_uint16 const   )1304,      (yytype_uint16 const   )1306,      (yytype_uint16 const   )1310, 
        (yytype_uint16 const   )1313,      (yytype_uint16 const   )1317,      (yytype_uint16 const   )1319,      (yytype_uint16 const   )1322, 
        (yytype_uint16 const   )1326,      (yytype_uint16 const   )1331,      (yytype_uint16 const   )1333,      (yytype_uint16 const   )1337, 
        (yytype_uint16 const   )1339,      (yytype_uint16 const   )1343,      (yytype_uint16 const   )1347,      (yytype_uint16 const   )1348, 
        (yytype_uint16 const   )1357,      (yytype_uint16 const   )1358,      (yytype_uint16 const   )1368,      (yytype_uint16 const   )1374, 
        (yytype_uint16 const   )1375,      (yytype_uint16 const   )1385,      (yytype_uint16 const   )1386,      (yytype_uint16 const   )1394, 
        (yytype_uint16 const   )1396,      (yytype_uint16 const   )1398,      (yytype_uint16 const   )1400,      (yytype_uint16 const   )1402, 
        (yytype_uint16 const   )1403,      (yytype_uint16 const   )1405,      (yytype_uint16 const   )1406,      (yytype_uint16 const   )1408, 
        (yytype_uint16 const   )1410,      (yytype_uint16 const   )1413,      (yytype_uint16 const   )1414,      (yytype_uint16 const   )1418, 
        (yytype_uint16 const   )1421,      (yytype_uint16 const   )1425,      (yytype_uint16 const   )1428,      (yytype_uint16 const   )1432, 
        (yytype_uint16 const   )1435,      (yytype_uint16 const   )1437,      (yytype_uint16 const   )1440,      (yytype_uint16 const   )1442, 
        (yytype_uint16 const   )1447,      (yytype_uint16 const   )1449,      (yytype_uint16 const   )1454,      (yytype_uint16 const   )1457, 
        (yytype_uint16 const   )1462,      (yytype_uint16 const   )1466,      (yytype_uint16 const   )1469,      (yytype_uint16 const   )1474, 
        (yytype_uint16 const   )1478,      (yytype_uint16 const   )1480,      (yytype_uint16 const   )1484,      (yytype_uint16 const   )1486, 
        (yytype_uint16 const   )1488,      (yytype_uint16 const   )1492,      (yytype_uint16 const   )1493,      (yytype_uint16 const   )1497, 
        (yytype_uint16 const   )1498,      (yytype_uint16 const   )1500,      (yytype_uint16 const   )1502,      (yytype_uint16 const   )1504, 
        (yytype_uint16 const   )1506,      (yytype_uint16 const   )1510,      (yytype_uint16 const   )1513,      (yytype_uint16 const   )1517, 
        (yytype_uint16 const   )1522,      (yytype_uint16 const   )1525,      (yytype_uint16 const   )1527,      (yytype_uint16 const   )1529, 
        (yytype_uint16 const   )1531,      (yytype_uint16 const   )1533,      (yytype_uint16 const   )1535,      (yytype_uint16 const   )1540, 
        (yytype_uint16 const   )1544,      (yytype_uint16 const   )1548,      (yytype_uint16 const   )1552,      (yytype_uint16 const   )1555, 
        (yytype_uint16 const   )1557,      (yytype_uint16 const   )1559,      (yytype_uint16 const   )1562,      (yytype_uint16 const   )1565, 
        (yytype_uint16 const   )1566,      (yytype_uint16 const   )1568,      (yytype_uint16 const   )1571,      (yytype_uint16 const   )1572, 
        (yytype_uint16 const   )1573,      (yytype_uint16 const   )1575,      (yytype_uint16 const   )1577,      (yytype_uint16 const   )1580, 
        (yytype_uint16 const   )1584,      (yytype_uint16 const   )1586,      (yytype_uint16 const   )1589,      (yytype_uint16 const   )1591, 
        (yytype_uint16 const   )1595,      (yytype_uint16 const   )1602,      (yytype_uint16 const   )1608,      (yytype_uint16 const   )1614, 
        (yytype_uint16 const   )1617,      (yytype_uint16 const   )1620,      (yytype_uint16 const   )1625,      (yytype_uint16 const   )1626, 
        (yytype_uint16 const   )1631,      (yytype_uint16 const   )1633,      (yytype_uint16 const   )1636,      (yytype_uint16 const   )1638, 
        (yytype_uint16 const   )1640,      (yytype_uint16 const   )1641,      (yytype_uint16 const   )1645,      (yytype_uint16 const   )1647, 
        (yytype_uint16 const   )1649,      (yytype_uint16 const   )1651,      (yytype_uint16 const   )1654,      (yytype_uint16 const   )1655, 
        (yytype_uint16 const   )1660,      (yytype_uint16 const   )1662,      (yytype_uint16 const   )1666,      (yytype_uint16 const   )1667, 
        (yytype_uint16 const   )1668,      (yytype_uint16 const   )1676,      (yytype_uint16 const   )1682,      (yytype_uint16 const   )1685, 
        (yytype_uint16 const   )1686,      (yytype_uint16 const   )1687,      (yytype_uint16 const   )1688,      (yytype_uint16 const   )1701, 
        (yytype_uint16 const   )1702,      (yytype_uint16 const   )1709,      (yytype_uint16 const   )1712,      (yytype_uint16 const   )1715, 
        (yytype_uint16 const   )1718,      (yytype_uint16 const   )1722,      (yytype_uint16 const   )1729,      (yytype_uint16 const   )1738, 
        (yytype_uint16 const   )1749,      (yytype_uint16 const   )1762,      (yytype_uint16 const   )1766,      (yytype_uint16 const   )1771, 
        (yytype_uint16 const   )1773,      (yytype_uint16 const   )1775,      (yytype_uint16 const   )1779,      (yytype_uint16 const   )1785, 
        (yytype_uint16 const   )1788,      (yytype_uint16 const   )1791,      (yytype_uint16 const   )1792,      (yytype_uint16 const   )1794, 
        (yytype_uint16 const   )1795,      (yytype_uint16 const   )1797,      (yytype_uint16 const   )1798,      (yytype_uint16 const   )1800, 
        (yytype_uint16 const   )1802,      (yytype_uint16 const   )1806,      (yytype_uint16 const   )1811,      (yytype_uint16 const   )1819, 
        (yytype_uint16 const   )1821,      (yytype_uint16 const   )1825,      (yytype_uint16 const   )1826,      (yytype_uint16 const   )1829, 
        (yytype_uint16 const   )1832,      (yytype_uint16 const   )1833,      (yytype_uint16 const   )1838,      (yytype_uint16 const   )1841, 
        (yytype_uint16 const   )1842,      (yytype_uint16 const   )1844,      (yytype_uint16 const   )1846,      (yytype_uint16 const   )1850, 
        (yytype_uint16 const   )1852,      (yytype_uint16 const   )1856,      (yytype_uint16 const   )1861,      (yytype_uint16 const   )1866, 
        (yytype_uint16 const   )1870,      (yytype_uint16 const   )1875,      (yytype_uint16 const   )1880,      (yytype_uint16 const   )1884, 
        (yytype_uint16 const   )1889,      (yytype_uint16 const   )1890,      (yytype_uint16 const   )1891,      (yytype_uint16 const   )1894, 
        (yytype_uint16 const   )1896,      (yytype_uint16 const   )1899,      (yytype_uint16 const   )1901,      (yytype_uint16 const   )1905, 
        (yytype_uint16 const   )1907,      (yytype_uint16 const   )1909,      (yytype_uint16 const   )1913,      (yytype_uint16 const   )1914, 
        (yytype_uint16 const   )1916,      (yytype_uint16 const   )1918,      (yytype_uint16 const   )1920,      (yytype_uint16 const   )1922, 
        (yytype_uint16 const   )1924,      (yytype_uint16 const   )1926};
#line 787 "c-parse.tab.c"
static yytype_int16 const   yyrhs[1928]  = 
#line 787
  {      (yytype_int16 const   )104,      (yytype_int16 const   )0,      (yytype_int16 const   )-1,      (yytype_int16 const   )71, 
        (yytype_int16 const   )110,      (yytype_int16 const   )-1,      (yytype_int16 const   )71,      (yytype_int16 const   )121, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )70,      (yytype_int16 const   )169,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-1,      (yytype_int16 const   )72,      (yytype_int16 const   )351, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )72,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )73,      (yytype_int16 const   )298,      (yytype_int16 const   )-1,      (yytype_int16 const   )73, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )106, 
        (yytype_int16 const   )107,      (yytype_int16 const   )-1,      (yytype_int16 const   )169,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )80,      (yytype_int16 const   )109,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )109,      (yytype_int16 const   )98, 
        (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )105,      (yytype_int16 const   )76,      (yytype_int16 const   )182,      (yytype_int16 const   )111, 
        (yytype_int16 const   )113,      (yytype_int16 const   )249,      (yytype_int16 const   )112,      (yytype_int16 const   )68, 
        (yytype_int16 const   )117,      (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )50,      (yytype_int16 const   )114,      (yytype_int16 const   )51,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )115,      (yytype_int16 const   )-1,      (yytype_int16 const   )114,      (yytype_int16 const   )98, 
        (yytype_int16 const   )115,      (yytype_int16 const   )-1,      (yytype_int16 const   )116,      (yytype_int16 const   )249, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )117, 
        (yytype_int16 const   )174,      (yytype_int16 const   )-1,      (yytype_int16 const   )174,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )64,      (yytype_int16 const   )119,      (yytype_int16 const   )120, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )350,      (yytype_int16 const   )100,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )100,      (yytype_int16 const   )-1,      (yytype_int16 const   )105, 
        (yytype_int16 const   )122,      (yytype_int16 const   )-1,      (yytype_int16 const   )105,      (yytype_int16 const   )125, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )105,      (yytype_int16 const   )129,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )132,      (yytype_int16 const   )79, 
        (yytype_int16 const   )182,      (yytype_int16 const   )123,      (yytype_int16 const   )133,      (yytype_int16 const   )249, 
        (yytype_int16 const   )124,      (yytype_int16 const   )68,      (yytype_int16 const   )137,      (yytype_int16 const   )99, 
        (yytype_int16 const   )167,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )132,      (yytype_int16 const   )81,      (yytype_int16 const   )182, 
        (yytype_int16 const   )126,      (yytype_int16 const   )133,      (yytype_int16 const   )249,      (yytype_int16 const   )127, 
        (yytype_int16 const   )68,      (yytype_int16 const   )137,      (yytype_int16 const   )99,      (yytype_int16 const   )128, 
        (yytype_int16 const   )152,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )93,      (yytype_int16 const   )182,      (yytype_int16 const   )130,      (yytype_int16 const   )249, 
        (yytype_int16 const   )131,      (yytype_int16 const   )68,      (yytype_int16 const   )137,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )88,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )134,      (yytype_int16 const   )101, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )135,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-1,      (yytype_int16 const   )135,      (yytype_int16 const   )98, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )352, 
        (yytype_int16 const   )276,      (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )224, 
        (yytype_int16 const   )352,      (yytype_int16 const   )278,      (yytype_int16 const   )247,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )225,      (yytype_int16 const   )352,      (yytype_int16 const   )278,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )352,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )138,      (yytype_int16 const   )-1,      (yytype_int16 const   )138,      (yytype_int16 const   )139, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )141,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )143,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )140, 
        (yytype_int16 const   )174,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )75, 
        (yytype_int16 const   )142,      (yytype_int16 const   )145,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )78,      (yytype_int16 const   )144,      (yytype_int16 const   )145,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )147,      (yytype_int16 const   )-1,      (yytype_int16 const   )68,      (yytype_int16 const   )146, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )146,      (yytype_int16 const   )147, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )147,      (yytype_int16 const   )-1,      (yytype_int16 const   )174, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )148,      (yytype_int16 const   )249,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )148,      (yytype_int16 const   )118,      (yytype_int16 const   )249, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )149,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )149,      (yytype_int16 const   )82,      (yytype_int16 const   )182,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )76,      (yytype_int16 const   )182,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )76,      (yytype_int16 const   )182,      (yytype_int16 const   )150,      (yytype_int16 const   )50, 
        (yytype_int16 const   )151,      (yytype_int16 const   )51,      (yytype_int16 const   )-1,      (yytype_int16 const   )161, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )151,      (yytype_int16 const   )98,      (yytype_int16 const   )161, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )84,      (yytype_int16 const   )153, 
        (yytype_int16 const   )68,      (yytype_int16 const   )162,      (yytype_int16 const   )99,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )77,      (yytype_int16 const   )155,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )155,      (yytype_int16 const   )98,      (yytype_int16 const   )156,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )156,      (yytype_int16 const   )-1,      (yytype_int16 const   )157,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )157,      (yytype_int16 const   )82,      (yytype_int16 const   )182,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )182,      (yytype_int16 const   )-1,      (yytype_int16 const   )89,      (yytype_int16 const   )182, 
        (yytype_int16 const   )63,      (yytype_int16 const   )158,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )159,      (yytype_int16 const   )-1,      (yytype_int16 const   )160, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )159,      (yytype_int16 const   )98,      (yytype_int16 const   )160, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )161, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )298,      (yytype_int16 const   )-1,      (yytype_int16 const   )162, 
        (yytype_int16 const   )163,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )164, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )174,      (yytype_int16 const   )-1,      (yytype_int16 const   )154, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )165,      (yytype_int16 const   )40,      (yytype_int16 const   )165, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )165,      (yytype_int16 const   )65, 
        (yytype_int16 const   )165,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )165, 
        (yytype_int16 const   )83,      (yytype_int16 const   )165,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )165,      (yytype_int16 const   )62,      (yytype_int16 const   )166,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )166,      (yytype_int16 const   )-1,      (yytype_int16 const   )182,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )182,      (yytype_int16 const   )64,      (yytype_int16 const   )186,      (yytype_int16 const   )100, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )84,      (yytype_int16 const   )168, 
        (yytype_int16 const   )68,      (yytype_int16 const   )169,      (yytype_int16 const   )99,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )170,      (yytype_int16 const   )172,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )169,      (yytype_int16 const   )171,      (yytype_int16 const   )172, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )176,      (yytype_int16 const   )-1,      (yytype_int16 const   )173, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )63,      (yytype_int16 const   )184, 
        (yytype_int16 const   )101,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )360, 
        (yytype_int16 const   )172,      (yytype_int16 const   )-1,      (yytype_int16 const   )205,      (yytype_int16 const   )239, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )174,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )225,      (yytype_int16 const   )205,      (yytype_int16 const   )239,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )205,      (yytype_int16 const   )238, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )231,      (yytype_int16 const   )205, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )99,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )175,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )97,      (yytype_int16 const   )180,      (yytype_int16 const   )40,      (yytype_int16 const   )184, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )205, 
        (yytype_int16 const   )275,      (yytype_int16 const   )177,      (yytype_int16 const   )-1,      (yytype_int16 const   )225, 
        (yytype_int16 const   )205,      (yytype_int16 const   )278,      (yytype_int16 const   )177,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )205,      (yytype_int16 const   )278,      (yytype_int16 const   )177,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )242,      (yytype_int16 const   )247, 
        (yytype_int16 const   )178,      (yytype_int16 const   )201,      (yytype_int16 const   )179,      (yytype_int16 const   )318, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )180, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )56, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )-1,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,      (yytype_int16 const   )186, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )186,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )187,      (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )187,      (yytype_int16 const   )98,      (yytype_int16 const   )194,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )-1,      (yytype_int16 const   )86,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )196,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )188,      (yytype_int16 const   )199,      (yytype_int16 const   )-1,      (yytype_int16 const   )57, 
        (yytype_int16 const   )192,      (yytype_int16 const   )-1,      (yytype_int16 const   )360,      (yytype_int16 const   )192, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )183,      (yytype_int16 const   )192,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )181,      (yytype_int16 const   )-1,      (yytype_int16 const   )190, 
        (yytype_int16 const   )189,      (yytype_int16 const   )-1,      (yytype_int16 const   )190,      (yytype_int16 const   )63, 
        (yytype_int16 const   )298,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )191, 
        (yytype_int16 const   )189,      (yytype_int16 const   )-1,      (yytype_int16 const   )191,      (yytype_int16 const   )63, 
        (yytype_int16 const   )298,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )14, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )189, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )298,      (yytype_int16 const   )101, 
        (yytype_int16 const   )192,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )298,      (yytype_int16 const   )101,      (yytype_int16 const   )68,      (yytype_int16 const   )193, 
        (yytype_int16 const   )261,      (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )192, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )55,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )56,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )57,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )58,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )59,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )54,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )53,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )52,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )50,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )51,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )49,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )48,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )46,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )47,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )45,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )44,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )42,      (yytype_int16 const   )184, 
        (yytype_int16 const   )43,      (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )194,      (yytype_int16 const   )42,      (yytype_int16 const   )195,      (yytype_int16 const   )43, 
        (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )40, 
        (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )41, 
        (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )-1,      (yytype_int16 const   )200,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )1,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )197,      (yytype_int16 const   )320, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )199,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )38,      (yytype_int16 const   )63,      (yytype_int16 const   )194,      (yytype_int16 const   )98, 
        (yytype_int16 const   )298,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )39, 
        (yytype_int16 const   )63,      (yytype_int16 const   )298,      (yytype_int16 const   )98,      (yytype_int16 const   )198, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )196,      (yytype_int16 const   )64, 
        (yytype_int16 const   )186,      (yytype_int16 const   )100,      (yytype_int16 const   )-1,      (yytype_int16 const   )196, 
        (yytype_int16 const   )62,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )196, 
        (yytype_int16 const   )65,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )196, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )196,      (yytype_int16 const   )60, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )198, 
        (yytype_int16 const   )62,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )196, 
        (yytype_int16 const   )63,      (yytype_int16 const   )185,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )11,      (yytype_int16 const   )-1,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )202,      (yytype_int16 const   )-1,      (yytype_int16 const   )202, 
        (yytype_int16 const   )13,      (yytype_int16 const   )-1,      (yytype_int16 const   )203,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )202,      (yytype_int16 const   )203,      (yytype_int16 const   )-1,      (yytype_int16 const   )226, 
        (yytype_int16 const   )205,      (yytype_int16 const   )238,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )227,      (yytype_int16 const   )205,      (yytype_int16 const   )239,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )226,      (yytype_int16 const   )205,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )227,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )207,      (yytype_int16 const   )-1,      (yytype_int16 const   )313,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )204,      (yytype_int16 const   )207,      (yytype_int16 const   )-1,      (yytype_int16 const   )207, 
        (yytype_int16 const   )313,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )205,      (yytype_int16 const   )238, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )225,      (yytype_int16 const   )205, 
        (yytype_int16 const   )239,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )224, 
        (yytype_int16 const   )205,      (yytype_int16 const   )269,      (yytype_int16 const   )-1,      (yytype_int16 const   )225, 
        (yytype_int16 const   )205,      (yytype_int16 const   )272,      (yytype_int16 const   )-1,      (yytype_int16 const   )231, 
        (yytype_int16 const   )205,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )360, 
        (yytype_int16 const   )207,      (yytype_int16 const   )-1,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )208,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )209, 
        (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )208,      (yytype_int16 const   )248, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )210,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )211,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )248, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )210,      (yytype_int16 const   )248,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )233,      (yytype_int16 const   )-1,      (yytype_int16 const   )212,      (yytype_int16 const   )362, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )213,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )212,      (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )213, 
        (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )208,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )233,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )234,      (yytype_int16 const   )-1,      (yytype_int16 const   )212,      (yytype_int16 const   )248, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )212,      (yytype_int16 const   )236,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )213,      (yytype_int16 const   )236,      (yytype_int16 const   )-1,      (yytype_int16 const   )208, 
        (yytype_int16 const   )234,      (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )234, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )214,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )215,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )214, 
        (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )215,      (yytype_int16 const   )235, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )210,      (yytype_int16 const   )233,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )211,      (yytype_int16 const   )233,      (yytype_int16 const   )-1,      (yytype_int16 const   )214, 
        (yytype_int16 const   )248,      (yytype_int16 const   )-1,      (yytype_int16 const   )214,      (yytype_int16 const   )236, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )215,      (yytype_int16 const   )236,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )210,      (yytype_int16 const   )234,      (yytype_int16 const   )-1,      (yytype_int16 const   )211, 
        (yytype_int16 const   )234,      (yytype_int16 const   )-1,      (yytype_int16 const   )361,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )216,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )217, 
        (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )208,      (yytype_int16 const   )361, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )361,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )216,      (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )217, 
        (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )216,      (yytype_int16 const   )248, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )218,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )219,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )210, 
        (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )211,      (yytype_int16 const   )361, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )218,      (yytype_int16 const   )361,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )219,      (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )218, 
        (yytype_int16 const   )248,      (yytype_int16 const   )-1,      (yytype_int16 const   )220,      (yytype_int16 const   )362, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )221,      (yytype_int16 const   )362,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )220,      (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )221, 
        (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )216,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )217,      (yytype_int16 const   )233,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )212,      (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )213, 
        (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )220,      (yytype_int16 const   )361, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )221,      (yytype_int16 const   )361,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )220,      (yytype_int16 const   )248,      (yytype_int16 const   )-1,      (yytype_int16 const   )220, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-1,      (yytype_int16 const   )221,      (yytype_int16 const   )236, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )216,      (yytype_int16 const   )234,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )217,      (yytype_int16 const   )234,      (yytype_int16 const   )-1,      (yytype_int16 const   )222, 
        (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )223,      (yytype_int16 const   )362, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )222,      (yytype_int16 const   )235,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )223,      (yytype_int16 const   )235,      (yytype_int16 const   )-1,      (yytype_int16 const   )218, 
        (yytype_int16 const   )233,      (yytype_int16 const   )-1,      (yytype_int16 const   )219,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )214,      (yytype_int16 const   )361,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )215,      (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )222, 
        (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )223,      (yytype_int16 const   )361, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )222,      (yytype_int16 const   )248,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )222,      (yytype_int16 const   )236,      (yytype_int16 const   )-1,      (yytype_int16 const   )223, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-1,      (yytype_int16 const   )218,      (yytype_int16 const   )234, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )219,      (yytype_int16 const   )234,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )212,      (yytype_int16 const   )-1,      (yytype_int16 const   )213,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )214,      (yytype_int16 const   )-1,      (yytype_int16 const   )215,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )220,      (yytype_int16 const   )-1,      (yytype_int16 const   )221,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )222,      (yytype_int16 const   )-1,      (yytype_int16 const   )223,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )208,      (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )210,      (yytype_int16 const   )-1,      (yytype_int16 const   )211,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )216,      (yytype_int16 const   )-1,      (yytype_int16 const   )217,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )218,      (yytype_int16 const   )-1,      (yytype_int16 const   )219,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )212,      (yytype_int16 const   )-1,      (yytype_int16 const   )213,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )220,      (yytype_int16 const   )-1,      (yytype_int16 const   )221,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )208,      (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )216,      (yytype_int16 const   )-1,      (yytype_int16 const   )217,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )212,      (yytype_int16 const   )-1,      (yytype_int16 const   )213,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )214,      (yytype_int16 const   )-1,      (yytype_int16 const   )215,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )208,      (yytype_int16 const   )-1,      (yytype_int16 const   )209,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )210,      (yytype_int16 const   )-1,      (yytype_int16 const   )211,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )228,      (yytype_int16 const   )-1,      (yytype_int16 const   )229,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )224,      (yytype_int16 const   )-1,      (yytype_int16 const   )225,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )229,      (yytype_int16 const   )-1,      (yytype_int16 const   )235, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )237,      (yytype_int16 const   )-1,      (yytype_int16 const   )236, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )364,      (yytype_int16 const   )-1,      (yytype_int16 const   )280, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )281,      (yytype_int16 const   )-1,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )5,      (yytype_int16 const   )62,      (yytype_int16 const   )180, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )63,      (yytype_int16 const   )184, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )63, 
        (yytype_int16 const   )298,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )240, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )241,      (yytype_int16 const   )-1,      (yytype_int16 const   )243, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )240,      (yytype_int16 const   )98,      (yytype_int16 const   )206, 
        (yytype_int16 const   )243,      (yytype_int16 const   )-1,      (yytype_int16 const   )245,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )241,      (yytype_int16 const   )98,      (yytype_int16 const   )206,      (yytype_int16 const   )243, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )63, 
        (yytype_int16 const   )11,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )275,      (yytype_int16 const   )242,      (yytype_int16 const   )247,      (yytype_int16 const   )40, 
        (yytype_int16 const   )244,      (yytype_int16 const   )259,      (yytype_int16 const   )-1,      (yytype_int16 const   )275, 
        (yytype_int16 const   )242,      (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )278,      (yytype_int16 const   )242,      (yytype_int16 const   )247,      (yytype_int16 const   )40, 
        (yytype_int16 const   )246,      (yytype_int16 const   )259,      (yytype_int16 const   )-1,      (yytype_int16 const   )278, 
        (yytype_int16 const   )242,      (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )250,      (yytype_int16 const   )-1,      (yytype_int16 const   )250,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )249,      (yytype_int16 const   )256,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )251,      (yytype_int16 const   )-1,      (yytype_int16 const   )250,      (yytype_int16 const   )251, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )63,      (yytype_int16 const   )63, 
        (yytype_int16 const   )254,      (yytype_int16 const   )101,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )252,      (yytype_int16 const   )-1,      (yytype_int16 const   )256,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )-1,      (yytype_int16 const   )96,      (yytype_int16 const   )253, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )253,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )-1,      (yytype_int16 const   )200,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )255,      (yytype_int16 const   )-1,      (yytype_int16 const   )254,      (yytype_int16 const   )98, 
        (yytype_int16 const   )255,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )258, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )258,      (yytype_int16 const   )63,      (yytype_int16 const   )3, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )258,      (yytype_int16 const   )63, 
        (yytype_int16 const   )3,      (yytype_int16 const   )98,      (yytype_int16 const   )186,      (yytype_int16 const   )101, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )258,      (yytype_int16 const   )63,      (yytype_int16 const   )185, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )257, 
        (yytype_int16 const   )63,      (yytype_int16 const   )261,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )257,      (yytype_int16 const   )1,      (yytype_int16 const   )101, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )182,      (yytype_int16 const   )-1,      (yytype_int16 const   )182, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )361,      (yytype_int16 const   )-1,      (yytype_int16 const   )364, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )86, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )68,      (yytype_int16 const   )260,      (yytype_int16 const   )261,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )262,      (yytype_int16 const   )287,      (yytype_int16 const   )-1,      (yytype_int16 const   )263, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )262,      (yytype_int16 const   )98,      (yytype_int16 const   )263, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )267,      (yytype_int16 const   )40,      (yytype_int16 const   )265, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )268,      (yytype_int16 const   )265,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )180,      (yytype_int16 const   )43,      (yytype_int16 const   )264, 
        (yytype_int16 const   )265,      (yytype_int16 const   )-1,      (yytype_int16 const   )265,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )68,      (yytype_int16 const   )266,      (yytype_int16 const   )261, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )194,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )268,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )267,      (yytype_int16 const   )268,      (yytype_int16 const   )-1,      (yytype_int16 const   )62, 
        (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )64,      (yytype_int16 const   )194, 
        (yytype_int16 const   )13,      (yytype_int16 const   )194,      (yytype_int16 const   )100,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )64,      (yytype_int16 const   )194,      (yytype_int16 const   )100,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )275,      (yytype_int16 const   )242, 
        (yytype_int16 const   )247,      (yytype_int16 const   )270,      (yytype_int16 const   )201,      (yytype_int16 const   )271, 
        (yytype_int16 const   )320,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )278,      (yytype_int16 const   )242,      (yytype_int16 const   )247,      (yytype_int16 const   )273, 
        (yytype_int16 const   )201,      (yytype_int16 const   )274,      (yytype_int16 const   )320,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )276,      (yytype_int16 const   )-1,      (yytype_int16 const   )278,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )276,      (yytype_int16 const   )305,      (yytype_int16 const   )-1,      (yytype_int16 const   )57, 
        (yytype_int16 const   )232,      (yytype_int16 const   )276,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )247,      (yytype_int16 const   )276,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )62, 
        (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )277,      (yytype_int16 const   )305, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )232,      (yytype_int16 const   )277, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )278, 
        (yytype_int16 const   )305,      (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )232, 
        (yytype_int16 const   )278,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )247, 
        (yytype_int16 const   )278,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )62,      (yytype_int16 const   )180, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )180,      (yytype_int16 const   )-1,      (yytype_int16 const   )286, 
        (yytype_int16 const   )279,      (yytype_int16 const   )249,      (yytype_int16 const   )-1,      (yytype_int16 const   )15, 
        (yytype_int16 const   )279,      (yytype_int16 const   )249,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )286,      (yytype_int16 const   )279,      (yytype_int16 const   )249,      (yytype_int16 const   )68, 
        (yytype_int16 const   )282,      (yytype_int16 const   )289,      (yytype_int16 const   )99,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )16,      (yytype_int16 const   )102, 
        (yytype_int16 const   )279,      (yytype_int16 const   )249,      (yytype_int16 const   )68,      (yytype_int16 const   )283, 
        (yytype_int16 const   )289,      (yytype_int16 const   )99,      (yytype_int16 const   )247,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )286,      (yytype_int16 const   )68,      (yytype_int16 const   )289,      (yytype_int16 const   )99, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15, 
        (yytype_int16 const   )279,      (yytype_int16 const   )249,      (yytype_int16 const   )68,      (yytype_int16 const   )284, 
        (yytype_int16 const   )296,      (yytype_int16 const   )288,      (yytype_int16 const   )99,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )68, 
        (yytype_int16 const   )285,      (yytype_int16 const   )296,      (yytype_int16 const   )288,      (yytype_int16 const   )99, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )16,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )98, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )290,      (yytype_int16 const   )-1,      (yytype_int16 const   )290,      (yytype_int16 const   )291, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )290,      (yytype_int16 const   )291, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )290,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )228,      (yytype_int16 const   )205,      (yytype_int16 const   )292, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )228,      (yytype_int16 const   )205,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )229,      (yytype_int16 const   )205,      (yytype_int16 const   )293,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )229,      (yytype_int16 const   )205,      (yytype_int16 const   )-1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )360,      (yytype_int16 const   )291,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )294,      (yytype_int16 const   )-1,      (yytype_int16 const   )292,      (yytype_int16 const   )98, 
        (yytype_int16 const   )206,      (yytype_int16 const   )294,      (yytype_int16 const   )-1,      (yytype_int16 const   )295, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )293,      (yytype_int16 const   )98,      (yytype_int16 const   )206, 
        (yytype_int16 const   )295,      (yytype_int16 const   )-1,      (yytype_int16 const   )275,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )275,      (yytype_int16 const   )43,      (yytype_int16 const   )194, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )194, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )278,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )278,      (yytype_int16 const   )43,      (yytype_int16 const   )194, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )194, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )297,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )296,      (yytype_int16 const   )98,      (yytype_int16 const   )297,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )180,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )180,      (yytype_int16 const   )40,      (yytype_int16 const   )194,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )230,      (yytype_int16 const   )299,      (yytype_int16 const   )300, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )301,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )303,      (yytype_int16 const   )-1,      (yytype_int16 const   )302,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )304,      (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )232, 
        (yytype_int16 const   )302,      (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )232, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )232,      (yytype_int16 const   )303, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )247,      (yytype_int16 const   )301, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )304,      (yytype_int16 const   )306, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )306,      (yytype_int16 const   )-1,      (yytype_int16 const   )307, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )309,      (yytype_int16 const   )-1,      (yytype_int16 const   )308, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )309,      (yytype_int16 const   )-1,      (yytype_int16 const   )118, 
        (yytype_int16 const   )63,      (yytype_int16 const   )355,      (yytype_int16 const   )359,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )353,      (yytype_int16 const   )359,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )345,      (yytype_int16 const   )359,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )64,      (yytype_int16 const   )184,      (yytype_int16 const   )100,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )64,      (yytype_int16 const   )100,      (yytype_int16 const   )-1,      (yytype_int16 const   )311, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )326,      (yytype_int16 const   )-1,      (yytype_int16 const   )311, 
        (yytype_int16 const   )326,      (yytype_int16 const   )-1,      (yytype_int16 const   )311,      (yytype_int16 const   )313, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )310,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )316,      (yytype_int16 const   )-1,      (yytype_int16 const   )317, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )316,      (yytype_int16 const   )317,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )35,      (yytype_int16 const   )358,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )320,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )320, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )68,      (yytype_int16 const   )-1,      (yytype_int16 const   )319, 
        (yytype_int16 const   )314,      (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )319, 
        (yytype_int16 const   )314,      (yytype_int16 const   )315,      (yytype_int16 const   )204,      (yytype_int16 const   )312, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )319,      (yytype_int16 const   )314, 
        (yytype_int16 const   )315,      (yytype_int16 const   )1,      (yytype_int16 const   )99,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )319,      (yytype_int16 const   )314,      (yytype_int16 const   )315,      (yytype_int16 const   )310, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )322,      (yytype_int16 const   )325, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )322,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )18,      (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )101, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )21,      (yytype_int16 const   )324, 
        (yytype_int16 const   )325,      (yytype_int16 const   )20,      (yytype_int16 const   )-1,      (yytype_int16 const   )330, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )338,      (yytype_int16 const   )325,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )330,      (yytype_int16 const   )-1,      (yytype_int16 const   )338,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )74,      (yytype_int16 const   )328,      (yytype_int16 const   )329, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )330,      (yytype_int16 const   )-1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )320,      (yytype_int16 const   )-1,      (yytype_int16 const   )184, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )321, 
        (yytype_int16 const   )19,      (yytype_int16 const   )331,      (yytype_int16 const   )325,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )321,      (yytype_int16 const   )-1,      (yytype_int16 const   )321,      (yytype_int16 const   )19, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )20,      (yytype_int16 const   )332,      (yytype_int16 const   )63,      (yytype_int16 const   )184, 
        (yytype_int16 const   )101,      (yytype_int16 const   )333,      (yytype_int16 const   )325,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )323,      (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )101, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )323,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )22,      (yytype_int16 const   )63,      (yytype_int16 const   )340,      (yytype_int16 const   )69, 
        (yytype_int16 const   )334,      (yytype_int16 const   )340,      (yytype_int16 const   )69,      (yytype_int16 const   )335, 
        (yytype_int16 const   )340,      (yytype_int16 const   )101,      (yytype_int16 const   )336,      (yytype_int16 const   )325, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,      (yytype_int16 const   )63, 
        (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )337,      (yytype_int16 const   )325, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )26,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )27,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )28, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )28,      (yytype_int16 const   )184, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )339, 
        (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )339,      (yytype_int16 const   )63, 
        (yytype_int16 const   )184,      (yytype_int16 const   )43,      (yytype_int16 const   )341,      (yytype_int16 const   )101, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )339, 
        (yytype_int16 const   )63,      (yytype_int16 const   )184,      (yytype_int16 const   )43,      (yytype_int16 const   )341, 
        (yytype_int16 const   )43,      (yytype_int16 const   )341,      (yytype_int16 const   )101,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )339,      (yytype_int16 const   )63, 
        (yytype_int16 const   )184,      (yytype_int16 const   )43,      (yytype_int16 const   )341,      (yytype_int16 const   )43, 
        (yytype_int16 const   )341,      (yytype_int16 const   )43,      (yytype_int16 const   )344,      (yytype_int16 const   )101, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )29,      (yytype_int16 const   )181, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )29,      (yytype_int16 const   )57, 
        (yytype_int16 const   )184,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )327, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )24, 
        (yytype_int16 const   )194,      (yytype_int16 const   )43,      (yytype_int16 const   )-1,      (yytype_int16 const   )24, 
        (yytype_int16 const   )194,      (yytype_int16 const   )13,      (yytype_int16 const   )194,      (yytype_int16 const   )43, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )43,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )181,      (yytype_int16 const   )43,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )362,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )184, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )342,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )343,      (yytype_int16 const   )-1,      (yytype_int16 const   )342,      (yytype_int16 const   )98, 
        (yytype_int16 const   )343,      (yytype_int16 const   )-1,      (yytype_int16 const   )11,      (yytype_int16 const   )63, 
        (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )64, 
        (yytype_int16 const   )182,      (yytype_int16 const   )100,      (yytype_int16 const   )11,      (yytype_int16 const   )63, 
        (yytype_int16 const   )184,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )11, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )344,      (yytype_int16 const   )98,      (yytype_int16 const   )11, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )346,      (yytype_int16 const   )347, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )349,      (yytype_int16 const   )101,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )350,      (yytype_int16 const   )69,      (yytype_int16 const   )348, 
        (yytype_int16 const   )347,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )101, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )13,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )350,      (yytype_int16 const   )-1,      (yytype_int16 const   )350,      (yytype_int16 const   )98, 
        (yytype_int16 const   )13,      (yytype_int16 const   )-1,      (yytype_int16 const   )351,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )350,      (yytype_int16 const   )98,      (yytype_int16 const   )351,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )224,      (yytype_int16 const   )352,      (yytype_int16 const   )277,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )352,      (yytype_int16 const   )278, 
        (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )352, 
        (yytype_int16 const   )300,      (yytype_int16 const   )-1,      (yytype_int16 const   )224,      (yytype_int16 const   )352, 
        (yytype_int16 const   )302,      (yytype_int16 const   )250,      (yytype_int16 const   )-1,      (yytype_int16 const   )225, 
        (yytype_int16 const   )352,      (yytype_int16 const   )278,      (yytype_int16 const   )247,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )225,      (yytype_int16 const   )352,      (yytype_int16 const   )300,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )225,      (yytype_int16 const   )352,      (yytype_int16 const   )302,      (yytype_int16 const   )250, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )354, 
        (yytype_int16 const   )355,      (yytype_int16 const   )-1,      (yytype_int16 const   )347,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )356,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )357, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )356,      (yytype_int16 const   )98,      (yytype_int16 const   )357, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )181, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )358,      (yytype_int16 const   )98,      (yytype_int16 const   )181, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )363,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )6,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )9,      (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )-1};
#line 985 "c-parse.tab.c"
static yytype_uint16 const   yyrline[634]  = 
#line 985
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )465,      (yytype_uint16 const   )465,      (yytype_uint16 const   )466, 
        (yytype_uint16 const   )467,      (yytype_uint16 const   )470,      (yytype_uint16 const   )471,      (yytype_uint16 const   )472, 
        (yytype_uint16 const   )473,      (yytype_uint16 const   )474,      (yytype_uint16 const   )478,      (yytype_uint16 const   )478, 
        (yytype_uint16 const   )479,      (yytype_uint16 const   )487,      (yytype_uint16 const   )488,      (yytype_uint16 const   )492, 
        (yytype_uint16 const   )496,      (yytype_uint16 const   )498,      (yytype_uint16 const   )505,      (yytype_uint16 const   )509, 
        (yytype_uint16 const   )503,      (yytype_uint16 const   )524,      (yytype_uint16 const   )525,      (yytype_uint16 const   )543, 
        (yytype_uint16 const   )544,      (yytype_uint16 const   )549,      (yytype_uint16 const   )554,      (yytype_uint16 const   )558, 
        (yytype_uint16 const   )559,      (yytype_uint16 const   )562,      (yytype_uint16 const   )562,      (yytype_uint16 const   )566, 
        (yytype_uint16 const   )571,      (yytype_uint16 const   )575,      (yytype_uint16 const   )576,      (yytype_uint16 const   )577, 
        (yytype_uint16 const   )582,      (yytype_uint16 const   )587,      (yytype_uint16 const   )581,      (yytype_uint16 const   )601, 
        (yytype_uint16 const   )607,      (yytype_uint16 const   )611,      (yytype_uint16 const   )600,      (yytype_uint16 const   )622, 
        (yytype_uint16 const   )626,      (yytype_uint16 const   )621,      (yytype_uint16 const   )637,      (yytype_uint16 const   )638, 
        (yytype_uint16 const   )643,      (yytype_uint16 const   )651,      (yytype_uint16 const   )670,      (yytype_uint16 const   )671, 
        (yytype_uint16 const   )675,      (yytype_uint16 const   )676,      (yytype_uint16 const   )685,      (yytype_uint16 const   )687, 
        (yytype_uint16 const   )689,      (yytype_uint16 const   )691,      (yytype_uint16 const   )696,      (yytype_uint16 const   )701, 
        (yytype_uint16 const   )703,      (yytype_uint16 const   )707,      (yytype_uint16 const   )708,      (yytype_uint16 const   )709, 
        (yytype_uint16 const   )709,      (yytype_uint16 const   )713,      (yytype_uint16 const   )713,      (yytype_uint16 const   )718, 
        (yytype_uint16 const   )718,      (yytype_uint16 const   )723,      (yytype_uint16 const   )724,      (yytype_uint16 const   )728, 
        (yytype_uint16 const   )730,      (yytype_uint16 const   )734,      (yytype_uint16 const   )735,      (yytype_uint16 const   )740, 
        (yytype_uint16 const   )750,      (yytype_uint16 const   )751,      (yytype_uint16 const   )755,      (yytype_uint16 const   )761, 
        (yytype_uint16 const   )760,      (yytype_uint16 const   )769,      (yytype_uint16 const   )770,      (yytype_uint16 const   )774, 
        (yytype_uint16 const   )774,      (yytype_uint16 const   )782,      (yytype_uint16 const   )786,      (yytype_uint16 const   )787, 
        (yytype_uint16 const   )791,      (yytype_uint16 const   )792,      (yytype_uint16 const   )796,      (yytype_uint16 const   )798, 
        (yytype_uint16 const   )804,      (yytype_uint16 const   )805,      (yytype_uint16 const   )809,      (yytype_uint16 const   )810, 
        (yytype_uint16 const   )814,      (yytype_uint16 const   )816,      (yytype_uint16 const   )820,      (yytype_uint16 const   )824, 
        (yytype_uint16 const   )825,      (yytype_uint16 const   )829,      (yytype_uint16 const   )830,      (yytype_uint16 const   )831, 
        (yytype_uint16 const   )835,      (yytype_uint16 const   )837,      (yytype_uint16 const   )839,      (yytype_uint16 const   )844, 
        (yytype_uint16 const   )848,      (yytype_uint16 const   )853,      (yytype_uint16 const   )855,      (yytype_uint16 const   )859, 
        (yytype_uint16 const   )859,      (yytype_uint16 const   )869,      (yytype_uint16 const   )869,      (yytype_uint16 const   )870, 
        (yytype_uint16 const   )870,      (yytype_uint16 const   )875,      (yytype_uint16 const   )876,      (yytype_uint16 const   )877, 
        (yytype_uint16 const   )882,      (yytype_uint16 const   )887,      (yytype_uint16 const   )894,      (yytype_uint16 const   )898, 
        (yytype_uint16 const   )900,      (yytype_uint16 const   )902,      (yytype_uint16 const   )905,      (yytype_uint16 const   )906, 
        (yytype_uint16 const   )907,      (yytype_uint16 const   )911,      (yytype_uint16 const   )915,      (yytype_uint16 const   )920, 
        (yytype_uint16 const   )921,      (yytype_uint16 const   )922,      (yytype_uint16 const   )926,      (yytype_uint16 const   )937, 
        (yytype_uint16 const   )925,      (yytype_uint16 const   )944,      (yytype_uint16 const   )945,      (yytype_uint16 const   )949, 
        (yytype_uint16 const   )953,      (yytype_uint16 const   )956,      (yytype_uint16 const   )958,      (yytype_uint16 const   )960, 
        (yytype_uint16 const   )962,      (yytype_uint16 const   )964,      (yytype_uint16 const   )966,      (yytype_uint16 const   )968, 
        (yytype_uint16 const   )970,      (yytype_uint16 const   )972,      (yytype_uint16 const   )976,      (yytype_uint16 const   )985, 
        (yytype_uint16 const   )986,      (yytype_uint16 const   )990,      (yytype_uint16 const   )995,      (yytype_uint16 const   )997, 
        (yytype_uint16 const   )1002,      (yytype_uint16 const   )1003,      (yytype_uint16 const   )1004,      (yytype_uint16 const   )1008, 
        (yytype_uint16 const   )1009,      (yytype_uint16 const   )1041,      (yytype_uint16 const   )1044,      (yytype_uint16 const   )1047, 
        (yytype_uint16 const   )1054,      (yytype_uint16 const   )1059,      (yytype_uint16 const   )1069,      (yytype_uint16 const   )1072, 
        (yytype_uint16 const   )1075,      (yytype_uint16 const   )1081,      (yytype_uint16 const   )1085,      (yytype_uint16 const   )1089, 
        (yytype_uint16 const   )1090,      (yytype_uint16 const   )1093,      (yytype_uint16 const   )1092,      (yytype_uint16 const   )1111, 
        (yytype_uint16 const   )1112,      (yytype_uint16 const   )1114,      (yytype_uint16 const   )1116,      (yytype_uint16 const   )1118, 
        (yytype_uint16 const   )1120,      (yytype_uint16 const   )1122,      (yytype_uint16 const   )1124,      (yytype_uint16 const   )1126, 
        (yytype_uint16 const   )1128,      (yytype_uint16 const   )1130,      (yytype_uint16 const   )1132,      (yytype_uint16 const   )1134, 
        (yytype_uint16 const   )1136,      (yytype_uint16 const   )1138,      (yytype_uint16 const   )1140,      (yytype_uint16 const   )1142, 
        (yytype_uint16 const   )1144,      (yytype_uint16 const   )1147,      (yytype_uint16 const   )1146,      (yytype_uint16 const   )1152, 
        (yytype_uint16 const   )1154,      (yytype_uint16 const   )1159,      (yytype_uint16 const   )1165,      (yytype_uint16 const   )1166, 
        (yytype_uint16 const   )1167,      (yytype_uint16 const   )1169,      (yytype_uint16 const   )1172,      (yytype_uint16 const   )1171, 
        (yytype_uint16 const   )1186,      (yytype_uint16 const   )1204,      (yytype_uint16 const   )1206,      (yytype_uint16 const   )1208, 
        (yytype_uint16 const   )1210,      (yytype_uint16 const   )1212,      (yytype_uint16 const   )1215,      (yytype_uint16 const   )1217, 
        (yytype_uint16 const   )1222,      (yytype_uint16 const   )1223,      (yytype_uint16 const   )1227,      (yytype_uint16 const   )1231, 
        (yytype_uint16 const   )1232,      (yytype_uint16 const   )1236,      (yytype_uint16 const   )1237,      (yytype_uint16 const   )1238, 
        (yytype_uint16 const   )1250,      (yytype_uint16 const   )1251,      (yytype_uint16 const   )1259,      (yytype_uint16 const   )1261, 
        (yytype_uint16 const   )1263,      (yytype_uint16 const   )1267,      (yytype_uint16 const   )1277,      (yytype_uint16 const   )1278, 
        (yytype_uint16 const   )1279,      (yytype_uint16 const   )1280,      (yytype_uint16 const   )1288,      (yytype_uint16 const   )1299, 
        (yytype_uint16 const   )1304,      (yytype_uint16 const   )1306,      (yytype_uint16 const   )1308,      (yytype_uint16 const   )1311, 
        (yytype_uint16 const   )1314,      (yytype_uint16 const   )1317,      (yytype_uint16 const   )1373,      (yytype_uint16 const   )1374, 
        (yytype_uint16 const   )1376,      (yytype_uint16 const   )1381,      (yytype_uint16 const   )1386,      (yytype_uint16 const   )1388, 
        (yytype_uint16 const   )1393,      (yytype_uint16 const   )1394,      (yytype_uint16 const   )1398,      (yytype_uint16 const   )1399, 
        (yytype_uint16 const   )1401,      (yytype_uint16 const   )1403,      (yytype_uint16 const   )1405,      (yytype_uint16 const   )1407, 
        (yytype_uint16 const   )1409,      (yytype_uint16 const   )1414,      (yytype_uint16 const   )1415,      (yytype_uint16 const   )1417, 
        (yytype_uint16 const   )1419,      (yytype_uint16 const   )1421,      (yytype_uint16 const   )1423,      (yytype_uint16 const   )1428, 
        (yytype_uint16 const   )1430,      (yytype_uint16 const   )1432,      (yytype_uint16 const   )1434,      (yytype_uint16 const   )1436, 
        (yytype_uint16 const   )1438,      (yytype_uint16 const   )1443,      (yytype_uint16 const   )1445,      (yytype_uint16 const   )1447, 
        (yytype_uint16 const   )1449,      (yytype_uint16 const   )1451,      (yytype_uint16 const   )1456,      (yytype_uint16 const   )1457, 
        (yytype_uint16 const   )1459,      (yytype_uint16 const   )1461,      (yytype_uint16 const   )1463,      (yytype_uint16 const   )1465, 
        (yytype_uint16 const   )1467,      (yytype_uint16 const   )1472,      (yytype_uint16 const   )1477,      (yytype_uint16 const   )1479, 
        (yytype_uint16 const   )1481,      (yytype_uint16 const   )1483,      (yytype_uint16 const   )1485,      (yytype_uint16 const   )1487, 
        (yytype_uint16 const   )1492,      (yytype_uint16 const   )1497,      (yytype_uint16 const   )1499,      (yytype_uint16 const   )1501, 
        (yytype_uint16 const   )1503,      (yytype_uint16 const   )1505,      (yytype_uint16 const   )1507,      (yytype_uint16 const   )1509, 
        (yytype_uint16 const   )1511,      (yytype_uint16 const   )1513,      (yytype_uint16 const   )1515,      (yytype_uint16 const   )1520, 
        (yytype_uint16 const   )1522,      (yytype_uint16 const   )1524,      (yytype_uint16 const   )1526,      (yytype_uint16 const   )1528, 
        (yytype_uint16 const   )1533,      (yytype_uint16 const   )1535,      (yytype_uint16 const   )1537,      (yytype_uint16 const   )1539, 
        (yytype_uint16 const   )1541,      (yytype_uint16 const   )1543,      (yytype_uint16 const   )1545,      (yytype_uint16 const   )1547, 
        (yytype_uint16 const   )1549,      (yytype_uint16 const   )1551,      (yytype_uint16 const   )1556,      (yytype_uint16 const   )1558, 
        (yytype_uint16 const   )1560,      (yytype_uint16 const   )1562,      (yytype_uint16 const   )1564,      (yytype_uint16 const   )1570, 
        (yytype_uint16 const   )1571,      (yytype_uint16 const   )1572,      (yytype_uint16 const   )1573,      (yytype_uint16 const   )1574, 
        (yytype_uint16 const   )1575,      (yytype_uint16 const   )1576,      (yytype_uint16 const   )1577,      (yytype_uint16 const   )1581, 
        (yytype_uint16 const   )1582,      (yytype_uint16 const   )1583,      (yytype_uint16 const   )1584,      (yytype_uint16 const   )1585, 
        (yytype_uint16 const   )1586,      (yytype_uint16 const   )1587,      (yytype_uint16 const   )1588,      (yytype_uint16 const   )1592, 
        (yytype_uint16 const   )1593,      (yytype_uint16 const   )1594,      (yytype_uint16 const   )1595,      (yytype_uint16 const   )1599, 
        (yytype_uint16 const   )1600,      (yytype_uint16 const   )1601,      (yytype_uint16 const   )1602,      (yytype_uint16 const   )1606, 
        (yytype_uint16 const   )1607,      (yytype_uint16 const   )1608,      (yytype_uint16 const   )1609,      (yytype_uint16 const   )1613, 
        (yytype_uint16 const   )1614,      (yytype_uint16 const   )1615,      (yytype_uint16 const   )1616,      (yytype_uint16 const   )1620, 
        (yytype_uint16 const   )1621,      (yytype_uint16 const   )1625,      (yytype_uint16 const   )1626,      (yytype_uint16 const   )1632, 
        (yytype_uint16 const   )1633,      (yytype_uint16 const   )1658,      (yytype_uint16 const   )1659,      (yytype_uint16 const   )1663, 
        (yytype_uint16 const   )1667,      (yytype_uint16 const   )1668,      (yytype_uint16 const   )1672,      (yytype_uint16 const   )1676, 
        (yytype_uint16 const   )1680,      (yytype_uint16 const   )1685,      (yytype_uint16 const   )1687,      (yytype_uint16 const   )1693, 
        (yytype_uint16 const   )1697,      (yytype_uint16 const   )1701,      (yytype_uint16 const   )1702,      (yytype_uint16 const   )1707, 
        (yytype_uint16 const   )1708,      (yytype_uint16 const   )1714,      (yytype_uint16 const   )1715,      (yytype_uint16 const   )1722, 
        (yytype_uint16 const   )1721,      (yytype_uint16 const   )1729,      (yytype_uint16 const   )1737,      (yytype_uint16 const   )1736, 
        (yytype_uint16 const   )1744,      (yytype_uint16 const   )1752,      (yytype_uint16 const   )1753,      (yytype_uint16 const   )1758, 
        (yytype_uint16 const   )1762,      (yytype_uint16 const   )1763,      (yytype_uint16 const   )1768,      (yytype_uint16 const   )1770, 
        (yytype_uint16 const   )1775,      (yytype_uint16 const   )1777,      (yytype_uint16 const   )1778,      (yytype_uint16 const   )1782, 
        (yytype_uint16 const   )1785,      (yytype_uint16 const   )1788,      (yytype_uint16 const   )1794,      (yytype_uint16 const   )1795, 
        (yytype_uint16 const   )1796,      (yytype_uint16 const   )1800,      (yytype_uint16 const   )1802,      (yytype_uint16 const   )1808, 
        (yytype_uint16 const   )1809,      (yytype_uint16 const   )1811,      (yytype_uint16 const   )1814,      (yytype_uint16 const   )1818, 
        (yytype_uint16 const   )1824,      (yytype_uint16 const   )1826,      (yytype_uint16 const   )1831,      (yytype_uint16 const   )1839, 
        (yytype_uint16 const   )1840,      (yytype_uint16 const   )1842,      (yytype_uint16 const   )1844,      (yytype_uint16 const   )1846, 
        (yytype_uint16 const   )1853,      (yytype_uint16 const   )1855,      (yytype_uint16 const   )1854,      (yytype_uint16 const   )1858, 
        (yytype_uint16 const   )1865,      (yytype_uint16 const   )1868,      (yytype_uint16 const   )1872,      (yytype_uint16 const   )1873, 
        (yytype_uint16 const   )1879,      (yytype_uint16 const   )1883,      (yytype_uint16 const   )1888,      (yytype_uint16 const   )1887, 
        (yytype_uint16 const   )1893,      (yytype_uint16 const   )1898,      (yytype_uint16 const   )1897,      (yytype_uint16 const   )1902, 
        (yytype_uint16 const   )1904,      (yytype_uint16 const   )1908,      (yytype_uint16 const   )1909,      (yytype_uint16 const   )1913, 
        (yytype_uint16 const   )1918,      (yytype_uint16 const   )1922,      (yytype_uint16 const   )1928,      (yytype_uint16 const   )1938, 
        (yytype_uint16 const   )1927,      (yytype_uint16 const   )1951,      (yytype_uint16 const   )1961,      (yytype_uint16 const   )1950, 
        (yytype_uint16 const   )1976,      (yytype_uint16 const   )1977,      (yytype_uint16 const   )1983,      (yytype_uint16 const   )1985, 
        (yytype_uint16 const   )1987,      (yytype_uint16 const   )1989,      (yytype_uint16 const   )1990,      (yytype_uint16 const   )2001, 
        (yytype_uint16 const   )2003,      (yytype_uint16 const   )2005,      (yytype_uint16 const   )2014,      (yytype_uint16 const   )2016, 
        (yytype_uint16 const   )2018,      (yytype_uint16 const   )2020,      (yytype_uint16 const   )2022,      (yytype_uint16 const   )2029, 
        (yytype_uint16 const   )2033,      (yytype_uint16 const   )2036,      (yytype_uint16 const   )2043,      (yytype_uint16 const   )2042, 
        (yytype_uint16 const   )2049,      (yytype_uint16 const   )2048,      (yytype_uint16 const   )2054,      (yytype_uint16 const   )2059, 
        (yytype_uint16 const   )2058,      (yytype_uint16 const   )2063,      (yytype_uint16 const   )2062,      (yytype_uint16 const   )2069, 
        (yytype_uint16 const   )2070,      (yytype_uint16 const   )2071,      (yytype_uint16 const   )2072,      (yytype_uint16 const   )2075, 
        (yytype_uint16 const   )2077,      (yytype_uint16 const   )2080,      (yytype_uint16 const   )2082,      (yytype_uint16 const   )2087, 
        (yytype_uint16 const   )2089,      (yytype_uint16 const   )2096,      (yytype_uint16 const   )2097,      (yytype_uint16 const   )2099, 
        (yytype_uint16 const   )2115,      (yytype_uint16 const   )2117,      (yytype_uint16 const   )2122,      (yytype_uint16 const   )2124, 
        (yytype_uint16 const   )2129,      (yytype_uint16 const   )2131,      (yytype_uint16 const   )2136,      (yytype_uint16 const   )2137, 
        (yytype_uint16 const   )2144,      (yytype_uint16 const   )2145,      (yytype_uint16 const   )2150,      (yytype_uint16 const   )2153, 
        (yytype_uint16 const   )2156,      (yytype_uint16 const   )2162,      (yytype_uint16 const   )2165,      (yytype_uint16 const   )2168, 
        (yytype_uint16 const   )2174,      (yytype_uint16 const   )2175,      (yytype_uint16 const   )2177,      (yytype_uint16 const   )2183, 
        (yytype_uint16 const   )2185,      (yytype_uint16 const   )2191,      (yytype_uint16 const   )2190,      (yytype_uint16 const   )2198, 
        (yytype_uint16 const   )2199,      (yytype_uint16 const   )2203,      (yytype_uint16 const   )2204,      (yytype_uint16 const   )2208, 
        (yytype_uint16 const   )2209,      (yytype_uint16 const   )2214,      (yytype_uint16 const   )2216,      (yytype_uint16 const   )2221, 
        (yytype_uint16 const   )2223,      (yytype_uint16 const   )2225,      (yytype_uint16 const   )2230,      (yytype_uint16 const   )2231, 
        (yytype_uint16 const   )2235,      (yytype_uint16 const   )2236,      (yytype_uint16 const   )2240,      (yytype_uint16 const   )2243, 
        (yytype_uint16 const   )2249,      (yytype_uint16 const   )2255,      (yytype_uint16 const   )2257,      (yytype_uint16 const   )2266, 
        (yytype_uint16 const   )2282,      (yytype_uint16 const   )2283,      (yytype_uint16 const   )2285,      (yytype_uint16 const   )2290, 
        (yytype_uint16 const   )2291,      (yytype_uint16 const   )2294,      (yytype_uint16 const   )2299,      (yytype_uint16 const   )2305, 
        (yytype_uint16 const   )2306,      (yytype_uint16 const   )2313,      (yytype_uint16 const   )2314,      (yytype_uint16 const   )2318, 
        (yytype_uint16 const   )2325,      (yytype_uint16 const   )2326,      (yytype_uint16 const   )2330,      (yytype_uint16 const   )2334, 
        (yytype_uint16 const   )2336,      (yytype_uint16 const   )2339,      (yytype_uint16 const   )2342,      (yytype_uint16 const   )2348, 
        (yytype_uint16 const   )2351,      (yytype_uint16 const   )2355,      (yytype_uint16 const   )2366,      (yytype_uint16 const   )2365, 
        (yytype_uint16 const   )2377,      (yytype_uint16 const   )2379,      (yytype_uint16 const   )2384,      (yytype_uint16 const   )2386, 
        (yytype_uint16 const   )2391,      (yytype_uint16 const   )2391,      (yytype_uint16 const   )2411,      (yytype_uint16 const   )2412, 
        (yytype_uint16 const   )2417,      (yytype_uint16 const   )2419,      (yytype_uint16 const   )2423,      (yytype_uint16 const   )2422, 
        (yytype_uint16 const   )2431,      (yytype_uint16 const   )2440,      (yytype_uint16 const   )2443,      (yytype_uint16 const   )2445, 
        (yytype_uint16 const   )2442,      (yytype_uint16 const   )2454,      (yytype_uint16 const   )2461,      (yytype_uint16 const   )2464, 
        (yytype_uint16 const   )2465,      (yytype_uint16 const   )2467,      (yytype_uint16 const   )2464,      (yytype_uint16 const   )2474, 
        (yytype_uint16 const   )2473,      (yytype_uint16 const   )2482,      (yytype_uint16 const   )2487,      (yytype_uint16 const   )2492, 
        (yytype_uint16 const   )2495,      (yytype_uint16 const   )2498,      (yytype_uint16 const   )2503,      (yytype_uint16 const   )2508, 
        (yytype_uint16 const   )2512,      (yytype_uint16 const   )2516,      (yytype_uint16 const   )2521,      (yytype_uint16 const   )2528, 
        (yytype_uint16 const   )2529,      (yytype_uint16 const   )2536,      (yytype_uint16 const   )2539,      (yytype_uint16 const   )2542, 
        (yytype_uint16 const   )2545,      (yytype_uint16 const   )2554,      (yytype_uint16 const   )2555,      (yytype_uint16 const   )2560, 
        (yytype_uint16 const   )2561,      (yytype_uint16 const   )2568,      (yytype_uint16 const   )2569,      (yytype_uint16 const   )2573, 
        (yytype_uint16 const   )2574,      (yytype_uint16 const   )2579,      (yytype_uint16 const   )2581,      (yytype_uint16 const   )2586, 
        (yytype_uint16 const   )2588,      (yytype_uint16 const   )2595,      (yytype_uint16 const   )2595,      (yytype_uint16 const   )2603, 
        (yytype_uint16 const   )2605,      (yytype_uint16 const   )2604,      (yytype_uint16 const   )2611,      (yytype_uint16 const   )2618, 
        (yytype_uint16 const   )2619,      (yytype_uint16 const   )2629,      (yytype_uint16 const   )2631,      (yytype_uint16 const   )2636, 
        (yytype_uint16 const   )2637,      (yytype_uint16 const   )2644,      (yytype_uint16 const   )2646,      (yytype_uint16 const   )2648, 
        (yytype_uint16 const   )2650,      (yytype_uint16 const   )2652,      (yytype_uint16 const   )2654,      (yytype_uint16 const   )2656, 
        (yytype_uint16 const   )2660,      (yytype_uint16 const   )2666,      (yytype_uint16 const   )2666,      (yytype_uint16 const   )2673, 
        (yytype_uint16 const   )2674,      (yytype_uint16 const   )2679,      (yytype_uint16 const   )2681,      (yytype_uint16 const   )2686, 
        (yytype_uint16 const   )2691,      (yytype_uint16 const   )2692,      (yytype_uint16 const   )2699,      (yytype_uint16 const   )2700, 
        (yytype_uint16 const   )2704,      (yytype_uint16 const   )2711,      (yytype_uint16 const   )2713,      (yytype_uint16 const   )2718, 
        (yytype_uint16 const   )2723,      (yytype_uint16 const   )2728};
#line 1057 "c-parse.tab.c"
static char const   * const  yytname[366]  = 
#line 1057
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENTIFIER", 
        (char const   */* const  */)"TYPENAME",      (char const   */* const  */)"COMPONENTREF",      (char const   */* const  */)"SCSPEC",      (char const   */* const  */)"TYPESPEC", 
        (char const   */* const  */)"TYPE_QUAL",      (char const   */* const  */)"FN_QUAL",      (char const   */* const  */)"CONSTANT",      (char const   */* const  */)"STRING", 
        (char const   */* const  */)"MAGIC_STRING",      (char const   */* const  */)"ELLIPSIS",      (char const   */* const  */)"SIZEOF",      (char const   */* const  */)"ENUM", 
        (char const   */* const  */)"STRUCT",      (char const   */* const  */)"UNION",      (char const   */* const  */)"IF",      (char const   */* const  */)"ELSE", 
        (char const   */* const  */)"WHILE",      (char const   */* const  */)"DO",      (char const   */* const  */)"FOR",      (char const   */* const  */)"SWITCH", 
        (char const   */* const  */)"CASE",      (char const   */* const  */)"DEFAULT",      (char const   */* const  */)"BREAK",      (char const   */* const  */)"CONTINUE", 
        (char const   */* const  */)"RETURN",      (char const   */* const  */)"GOTO",      (char const   */* const  */)"ASM_KEYWORD",      (char const   */* const  */)"TYPEOF", 
        (char const   */* const  */)"ALIGNOF",      (char const   */* const  */)"ATTRIBUTE",      (char const   */* const  */)"EXTENSION",      (char const   */* const  */)"LABEL", 
        (char const   */* const  */)"REALPART",      (char const   */* const  */)"IMAGPART",      (char const   */* const  */)"VA_ARG",      (char const   */* const  */)"OFFSETOF", 
        (char const   */* const  */)"\'=\'",      (char const   */* const  */)"ASSIGN",      (char const   */* const  */)"\'?\'",      (char const   */* const  */)"\':\'", 
        (char const   */* const  */)"OROR",      (char const   */* const  */)"ANDAND",      (char const   */* const  */)"\'|\'",      (char const   */* const  */)"\'^\'", 
        (char const   */* const  */)"\'&\'",      (char const   */* const  */)"EQCOMPARE",      (char const   */* const  */)"\'<\'",      (char const   */* const  */)"\'>\'", 
        (char const   */* const  */)"ARITHCOMPARE",      (char const   */* const  */)"RSHIFT",      (char const   */* const  */)"LSHIFT",      (char const   */* const  */)"\'+\'", 
        (char const   */* const  */)"\'-\'",      (char const   */* const  */)"\'*\'",      (char const   */* const  */)"\'/\'",      (char const   */* const  */)"\'%\'", 
        (char const   */* const  */)"MINUSMINUS",      (char const   */* const  */)"PLUSPLUS",      (char const   */* const  */)"\'.\'",      (char const   */* const  */)"\'(\'", 
        (char const   */* const  */)"\'[\'",      (char const   */* const  */)"POINTSAT",      (char const   */* const  */)"\'~\'",      (char const   */* const  */)"\'!\'", 
        (char const   */* const  */)"\'{\'",      (char const   */* const  */)"\';\'",      (char const   */* const  */)"DISPATCH_C",      (char const   */* const  */)"DISPATCH_NESC", 
        (char const   */* const  */)"DISPATCH_PARM",      (char const   */* const  */)"DISPATCH_TYPE",      (char const   */* const  */)"ATOMIC",      (char const   */* const  */)"USES", 
        (char const   */* const  */)"INTERFACE",      (char const   */* const  */)"COMPONENTS",      (char const   */* const  */)"PROVIDES",      (char const   */* const  */)"MODULE", 
        (char const   */* const  */)"INCLUDES",      (char const   */* const  */)"CONFIGURATION",      (char const   */* const  */)"AS",      (char const   */* const  */)"TASTNIOP", 
        (char const   */* const  */)"IMPLEMENTATION",      (char const   */* const  */)"CALL",      (char const   */* const  */)"SIGNAL",      (char const   */* const  */)"POST", 
        (char const   */* const  */)"GENERIC",      (char const   */* const  */)"NEW",      (char const   */* const  */)"NX_STRUCT",      (char const   */* const  */)"NX_UNION", 
        (char const   */* const  */)"ABSTRACT",      (char const   */* const  */)"COMPONENT",      (char const   */* const  */)"EXTENDS",      (char const   */* const  */)"TARGET_ATTRIBUTE0", 
        (char const   */* const  */)"TARGET_ATTRIBUTE1",      (char const   */* const  */)"TARGET_DEF",      (char const   */* const  */)"\',\'",      (char const   */* const  */)"\'}\'", 
        (char const   */* const  */)"\']\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"\'@\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"dispatch",      (char const   */* const  */)"ncheader",      (char const   */* const  */)"$@1",      (char const   */* const  */)"includes_list", 
        (char const   */* const  */)"includes",      (char const   */* const  */)"include_list",      (char const   */* const  */)"interface",      (char const   */* const  */)"$@2", 
        (char const   */* const  */)"$@3",      (char const   */* const  */)"interface_parms",      (char const   */* const  */)"interface_parm_list",      (char const   */* const  */)"interface_parm", 
        (char const   */* const  */)"type_parm",      (char const   */* const  */)"datadef_list",      (char const   */* const  */)"parameters",      (char const   */* const  */)"$@4", 
        (char const   */* const  */)"parameters1",      (char const   */* const  */)"component",      (char const   */* const  */)"module",      (char const   */* const  */)"$@5", 
        (char const   */* const  */)"$@6",      (char const   */* const  */)"configuration",      (char const   */* const  */)"$@7",      (char const   */* const  */)"$@8", 
        (char const   */* const  */)"$@9",      (char const   */* const  */)"binary_component",      (char const   */* const  */)"$@10",      (char const   */* const  */)"$@11", 
        (char const   */* const  */)"generic",      (char const   */* const  */)"component_parms",      (char const   */* const  */)"template_parms",      (char const   */* const  */)"template_parmlist", 
        (char const   */* const  */)"template_parm",      (char const   */* const  */)"requires_or_provides_list",      (char const   */* const  */)"requires_or_provides_list_",      (char const   */* const  */)"requires_or_provides", 
        (char const   */* const  */)"$@12",      (char const   */* const  */)"requires",      (char const   */* const  */)"$@13",      (char const   */* const  */)"provides", 
        (char const   */* const  */)"$@14",      (char const   */* const  */)"parameterised_interface_list",      (char const   */* const  */)"parameterised_interfaces",      (char const   */* const  */)"parameterised_interface", 
        (char const   */* const  */)"interface_ref",      (char const   */* const  */)"interface_type",      (char const   */* const  */)"$@15",      (char const   */* const  */)"typelist", 
        (char const   */* const  */)"iconfiguration",      (char const   */* const  */)"@16",      (char const   */* const  */)"cuses",      (char const   */* const  */)"component_list", 
        (char const   */* const  */)"component_ref",      (char const   */* const  */)"component_ref2",      (char const   */* const  */)"generic_args",      (char const   */* const  */)"generic_arglist", 
        (char const   */* const  */)"generic_arg",      (char const   */* const  */)"generic_type",      (char const   */* const  */)"configuration_decls",      (char const   */* const  */)"configuration_decl", 
        (char const   */* const  */)"connection",      (char const   */* const  */)"endpoint",      (char const   */* const  */)"parameterised_identifier",      (char const   */* const  */)"imodule", 
        (char const   */* const  */)"@17",      (char const   */* const  */)"extdefs",      (char const   */* const  */)"@18",      (char const   */* const  */)"@19", 
        (char const   */* const  */)"extdef",      (char const   */* const  */)"datadef",      (char const   */* const  */)"just_datadef",      (char const   */* const  */)"target_def", 
        (char const   */* const  */)"fndef",      (char const   */* const  */)"fndef2",      (char const   */* const  */)"$@20",      (char const   */* const  */)"$@21", 
        (char const   */* const  */)"identifier",      (char const   */* const  */)"id_label",      (char const   */* const  */)"idword",      (char const   */* const  */)"unop", 
        (char const   */* const  */)"expr",      (char const   */* const  */)"exprlist",      (char const   */* const  */)"nonnull_exprlist",      (char const   */* const  */)"nonnull_exprlist_", 
        (char const   */* const  */)"callkind",      (char const   */* const  */)"unary_expr",      (char const   */* const  */)"sizeof",      (char const   */* const  */)"alignof", 
        (char const   */* const  */)"cast_expr",      (char const   */* const  */)"$@22",      (char const   */* const  */)"expr_no_commas",      (char const   */* const  */)"$@23", 
        (char const   */* const  */)"primary",      (char const   */* const  */)"$@24",      (char const   */* const  */)"fieldlist",      (char const   */* const  */)"function_call", 
        (char const   */* const  */)"string",      (char const   */* const  */)"old_style_parm_decls",      (char const   */* const  */)"datadecls",      (char const   */* const  */)"datadecl", 
        (char const   */* const  */)"decls",      (char const   */* const  */)"setspecs",      (char const   */* const  */)"maybe_resetattrs",      (char const   */* const  */)"decl", 
        (char const   */* const  */)"declspecs_nosc_nots_nosa_noea",      (char const   */* const  */)"declspecs_nosc_nots_nosa_ea",      (char const   */* const  */)"declspecs_nosc_nots_sa_noea",      (char const   */* const  */)"declspecs_nosc_nots_sa_ea", 
        (char const   */* const  */)"declspecs_nosc_ts_nosa_noea",      (char const   */* const  */)"declspecs_nosc_ts_nosa_ea",      (char const   */* const  */)"declspecs_nosc_ts_sa_noea",      (char const   */* const  */)"declspecs_nosc_ts_sa_ea", 
        (char const   */* const  */)"declspecs_sc_nots_nosa_noea",      (char const   */* const  */)"declspecs_sc_nots_nosa_ea",      (char const   */* const  */)"declspecs_sc_nots_sa_noea",      (char const   */* const  */)"declspecs_sc_nots_sa_ea", 
        (char const   */* const  */)"declspecs_sc_ts_nosa_noea",      (char const   */* const  */)"declspecs_sc_ts_nosa_ea",      (char const   */* const  */)"declspecs_sc_ts_sa_noea",      (char const   */* const  */)"declspecs_sc_ts_sa_ea", 
        (char const   */* const  */)"declspecs_ts",      (char const   */* const  */)"declspecs_nots",      (char const   */* const  */)"declspecs_ts_nosa",      (char const   */* const  */)"declspecs_nots_nosa", 
        (char const   */* const  */)"declspecs_nosc_ts",      (char const   */* const  */)"declspecs_nosc_nots",      (char const   */* const  */)"declspecs_nosc",      (char const   */* const  */)"declspecs", 
        (char const   */* const  */)"maybe_type_quals_attrs",      (char const   */* const  */)"type_spec_nonattr",      (char const   */* const  */)"type_spec_attr",      (char const   */* const  */)"type_spec_reserved_nonattr", 
        (char const   */* const  */)"type_spec_reserved_attr",      (char const   */* const  */)"type_spec_nonreserved_nonattr",      (char const   */* const  */)"initdecls",      (char const   */* const  */)"notype_initdecls", 
        (char const   */* const  */)"initdecls_",      (char const   */* const  */)"notype_initdecls_",      (char const   */* const  */)"maybeasm",      (char const   */* const  */)"initdcl", 
        (char const   */* const  */)"@25",      (char const   */* const  */)"notype_initdcl",      (char const   */* const  */)"@26",      (char const   */* const  */)"maybe_attribute", 
        (char const   */* const  */)"eattributes",      (char const   */* const  */)"nesc_attributes",      (char const   */* const  */)"attributes",      (char const   */* const  */)"attribute", 
        (char const   */* const  */)"target_attribute",      (char const   */* const  */)"restricted_expr",      (char const   */* const  */)"attribute_list",      (char const   */* const  */)"attrib", 
        (char const   */* const  */)"nattrib",      (char const   */* const  */)"nastart",      (char const   */* const  */)"any_word",      (char const   */* const  */)"init", 
        (char const   */* const  */)"$@27",      (char const   */* const  */)"initlist_maybe_comma",      (char const   */* const  */)"initlist1",      (char const   */* const  */)"initelt", 
        (char const   */* const  */)"@28",      (char const   */* const  */)"initval",      (char const   */* const  */)"$@29",      (char const   */* const  */)"designator_list", 
        (char const   */* const  */)"designator",      (char const   */* const  */)"nested_function",      (char const   */* const  */)"$@30",      (char const   */* const  */)"$@31", 
        (char const   */* const  */)"notype_nested_function",      (char const   */* const  */)"$@32",      (char const   */* const  */)"$@33",      (char const   */* const  */)"declarator", 
        (char const   */* const  */)"after_type_declarator",      (char const   */* const  */)"parm_declarator",      (char const   */* const  */)"notype_declarator",      (char const   */* const  */)"tag", 
        (char const   */* const  */)"structuse",      (char const   */* const  */)"structdef",      (char const   */* const  */)"@34",      (char const   */* const  */)"@35", 
        (char const   */* const  */)"@36",      (char const   */* const  */)"@37",      (char const   */* const  */)"structkind",      (char const   */* const  */)"maybecomma", 
        (char const   */* const  */)"maybecomma_warn",      (char const   */* const  */)"component_decl_list",      (char const   */* const  */)"component_decl_list2",      (char const   */* const  */)"component_decl", 
        (char const   */* const  */)"components",      (char const   */* const  */)"components_notype",      (char const   */* const  */)"component_declarator",      (char const   */* const  */)"component_notype_declarator", 
        (char const   */* const  */)"enumlist",      (char const   */* const  */)"enumerator",      (char const   */* const  */)"typename",      (char const   */* const  */)"$@38", 
        (char const   */* const  */)"absdcl",      (char const   */* const  */)"absdcl1",      (char const   */* const  */)"absdcl1_noea",      (char const   */* const  */)"absdcl1_ea", 
        (char const   */* const  */)"direct_absdcl1",      (char const   */* const  */)"array_or_fn_declarator",      (char const   */* const  */)"array_or_absfn_declarator",      (char const   */* const  */)"fn_declarator", 
        (char const   */* const  */)"absfn_declarator",      (char const   */* const  */)"array_declarator",      (char const   */* const  */)"stmts",      (char const   */* const  */)"stmt_or_labels", 
        (char const   */* const  */)"xstmts",      (char const   */* const  */)"errstmt",      (char const   */* const  */)"pushlevel",      (char const   */* const  */)"maybe_label_decls", 
        (char const   */* const  */)"label_decls",      (char const   */* const  */)"label_decl",      (char const   */* const  */)"compstmt_or_error",      (char const   */* const  */)"compstmt_start", 
        (char const   */* const  */)"compstmt",      (char const   */* const  */)"simple_if",      (char const   */* const  */)"if_prefix",      (char const   */* const  */)"do_stmt_start", 
        (char const   */* const  */)"@39",      (char const   */* const  */)"labeled_stmt",      (char const   */* const  */)"stmt_or_label",      (char const   */* const  */)"atomic_stmt", 
        (char const   */* const  */)"$@40",      (char const   */* const  */)"stmt_or_error",      (char const   */* const  */)"stmt",      (char const   */* const  */)"$@41", 
        (char const   */* const  */)"$@42",      (char const   */* const  */)"@43",      (char const   */* const  */)"$@44",      (char const   */* const  */)"$@45", 
        (char const   */* const  */)"@46",      (char const   */* const  */)"@47",      (char const   */* const  */)"label",      (char const   */* const  */)"maybe_type_qual", 
        (char const   */* const  */)"xexpr",      (char const   */* const  */)"asm_operands",      (char const   */* const  */)"nonnull_asm_operands",      (char const   */* const  */)"asm_operand", 
        (char const   */* const  */)"asm_clobbers",      (char const   */* const  */)"parmlist",      (char const   */* const  */)"$@48",      (char const   */* const  */)"parmlist_1", 
        (char const   */* const  */)"$@49",      (char const   */* const  */)"parmlist_2",      (char const   */* const  */)"parms",      (char const   */* const  */)"parm", 
        (char const   */* const  */)"xreferror",      (char const   */* const  */)"parmlist_or_identifiers",      (char const   */* const  */)"$@50",      (char const   */* const  */)"parmlist_or_identifiers_1", 
        (char const   */* const  */)"identifiers",      (char const   */* const  */)"old_parameter",      (char const   */* const  */)"identifiers_or_typenames",      (char const   */* const  */)"fn_quals", 
        (char const   */* const  */)"extension",      (char const   */* const  */)"scspec",      (char const   */* const  */)"type_qual",      (char const   */* const  */)"fn_qual", 
        (char const   */* const  */)"type_spec",      (char const   */* const  */)0};
#line 1143 "c-parse.tab.c"
static yytype_uint16 const   yytoknum[103]  = 
#line 1143
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )265,      (yytype_uint16 const   )266, 
        (yytype_uint16 const   )267,      (yytype_uint16 const   )268,      (yytype_uint16 const   )269,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )272,      (yytype_uint16 const   )273,      (yytype_uint16 const   )274, 
        (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )279,      (yytype_uint16 const   )280,      (yytype_uint16 const   )281,      (yytype_uint16 const   )282, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )284,      (yytype_uint16 const   )285,      (yytype_uint16 const   )286, 
        (yytype_uint16 const   )287,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )291,      (yytype_uint16 const   )292,      (yytype_uint16 const   )293,      (yytype_uint16 const   )294, 
        (yytype_uint16 const   )61,      (yytype_uint16 const   )295,      (yytype_uint16 const   )63,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )296,      (yytype_uint16 const   )297,      (yytype_uint16 const   )124,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )38,      (yytype_uint16 const   )298,      (yytype_uint16 const   )60,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )299,      (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )43, 
        (yytype_uint16 const   )45,      (yytype_uint16 const   )42,      (yytype_uint16 const   )47,      (yytype_uint16 const   )37, 
        (yytype_uint16 const   )302,      (yytype_uint16 const   )303,      (yytype_uint16 const   )46,      (yytype_uint16 const   )40, 
        (yytype_uint16 const   )91,      (yytype_uint16 const   )304,      (yytype_uint16 const   )126,      (yytype_uint16 const   )33, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )59,      (yytype_uint16 const   )305,      (yytype_uint16 const   )306, 
        (yytype_uint16 const   )307,      (yytype_uint16 const   )308,      (yytype_uint16 const   )309,      (yytype_uint16 const   )310, 
        (yytype_uint16 const   )311,      (yytype_uint16 const   )312,      (yytype_uint16 const   )313,      (yytype_uint16 const   )314, 
        (yytype_uint16 const   )315,      (yytype_uint16 const   )316,      (yytype_uint16 const   )317,      (yytype_uint16 const   )318, 
        (yytype_uint16 const   )319,      (yytype_uint16 const   )320,      (yytype_uint16 const   )321,      (yytype_uint16 const   )322, 
        (yytype_uint16 const   )323,      (yytype_uint16 const   )324,      (yytype_uint16 const   )325,      (yytype_uint16 const   )326, 
        (yytype_uint16 const   )327,      (yytype_uint16 const   )328,      (yytype_uint16 const   )329,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )331,      (yytype_uint16 const   )332,      (yytype_uint16 const   )44,      (yytype_uint16 const   )125, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )41,      (yytype_uint16 const   )64};
#line 1160 "c-parse.tab.c"
static yytype_uint16 const   yyr1[634]  = 
#line 1160
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )103,      (yytype_uint16 const   )104,      (yytype_uint16 const   )104, 
        (yytype_uint16 const   )104,      (yytype_uint16 const   )104,      (yytype_uint16 const   )104,      (yytype_uint16 const   )104, 
        (yytype_uint16 const   )104,      (yytype_uint16 const   )104,      (yytype_uint16 const   )106,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )107,      (yytype_uint16 const   )107,      (yytype_uint16 const   )108, 
        (yytype_uint16 const   )109,      (yytype_uint16 const   )109,      (yytype_uint16 const   )111,      (yytype_uint16 const   )112, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )113,      (yytype_uint16 const   )113,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )114,      (yytype_uint16 const   )115,      (yytype_uint16 const   )116,      (yytype_uint16 const   )117, 
        (yytype_uint16 const   )117,      (yytype_uint16 const   )119,      (yytype_uint16 const   )118,      (yytype_uint16 const   )120, 
        (yytype_uint16 const   )120,      (yytype_uint16 const   )121,      (yytype_uint16 const   )121,      (yytype_uint16 const   )121, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )124,      (yytype_uint16 const   )122,      (yytype_uint16 const   )126, 
        (yytype_uint16 const   )127,      (yytype_uint16 const   )128,      (yytype_uint16 const   )125,      (yytype_uint16 const   )130, 
        (yytype_uint16 const   )131,      (yytype_uint16 const   )129,      (yytype_uint16 const   )132,      (yytype_uint16 const   )132, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )133,      (yytype_uint16 const   )134,      (yytype_uint16 const   )134, 
        (yytype_uint16 const   )135,      (yytype_uint16 const   )135,      (yytype_uint16 const   )136,      (yytype_uint16 const   )136, 
        (yytype_uint16 const   )136,      (yytype_uint16 const   )136,      (yytype_uint16 const   )137,      (yytype_uint16 const   )138, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )139,      (yytype_uint16 const   )139,      (yytype_uint16 const   )140, 
        (yytype_uint16 const   )139,      (yytype_uint16 const   )142,      (yytype_uint16 const   )141,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )145,      (yytype_uint16 const   )145,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )146,      (yytype_uint16 const   )147,      (yytype_uint16 const   )147,      (yytype_uint16 const   )147, 
        (yytype_uint16 const   )148,      (yytype_uint16 const   )148,      (yytype_uint16 const   )149,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )149,      (yytype_uint16 const   )151,      (yytype_uint16 const   )151,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )154,      (yytype_uint16 const   )155,      (yytype_uint16 const   )155, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )156,      (yytype_uint16 const   )157,      (yytype_uint16 const   )157, 
        (yytype_uint16 const   )158,      (yytype_uint16 const   )158,      (yytype_uint16 const   )159,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )160,      (yytype_uint16 const   )160,      (yytype_uint16 const   )161,      (yytype_uint16 const   )162, 
        (yytype_uint16 const   )162,      (yytype_uint16 const   )163,      (yytype_uint16 const   )163,      (yytype_uint16 const   )163, 
        (yytype_uint16 const   )164,      (yytype_uint16 const   )164,      (yytype_uint16 const   )164,      (yytype_uint16 const   )165, 
        (yytype_uint16 const   )165,      (yytype_uint16 const   )166,      (yytype_uint16 const   )166,      (yytype_uint16 const   )168, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )170,      (yytype_uint16 const   )169,      (yytype_uint16 const   )171, 
        (yytype_uint16 const   )169,      (yytype_uint16 const   )172,      (yytype_uint16 const   )172,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )173,      (yytype_uint16 const   )173,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )174,      (yytype_uint16 const   )174,      (yytype_uint16 const   )174,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )174,      (yytype_uint16 const   )174,      (yytype_uint16 const   )175,      (yytype_uint16 const   )176, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )176,      (yytype_uint16 const   )178,      (yytype_uint16 const   )179, 
        (yytype_uint16 const   )177,      (yytype_uint16 const   )180,      (yytype_uint16 const   )180,      (yytype_uint16 const   )181, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )183,      (yytype_uint16 const   )183,      (yytype_uint16 const   )183, 
        (yytype_uint16 const   )183,      (yytype_uint16 const   )183,      (yytype_uint16 const   )183,      (yytype_uint16 const   )183, 
        (yytype_uint16 const   )183,      (yytype_uint16 const   )183,      (yytype_uint16 const   )184,      (yytype_uint16 const   )185, 
        (yytype_uint16 const   )185,      (yytype_uint16 const   )186,      (yytype_uint16 const   )187,      (yytype_uint16 const   )187, 
        (yytype_uint16 const   )188,      (yytype_uint16 const   )188,      (yytype_uint16 const   )188,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )189,      (yytype_uint16 const   )189,      (yytype_uint16 const   )189,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )189,      (yytype_uint16 const   )189,      (yytype_uint16 const   )189,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )189,      (yytype_uint16 const   )190,      (yytype_uint16 const   )191,      (yytype_uint16 const   )192, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )192,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )195,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )197,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )198,      (yytype_uint16 const   )198,      (yytype_uint16 const   )199,      (yytype_uint16 const   )200, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )201,      (yytype_uint16 const   )201,      (yytype_uint16 const   )201, 
        (yytype_uint16 const   )202,      (yytype_uint16 const   )202,      (yytype_uint16 const   )203,      (yytype_uint16 const   )203, 
        (yytype_uint16 const   )203,      (yytype_uint16 const   )203,      (yytype_uint16 const   )204,      (yytype_uint16 const   )204, 
        (yytype_uint16 const   )204,      (yytype_uint16 const   )204,      (yytype_uint16 const   )205,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )207,      (yytype_uint16 const   )207,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )207,      (yytype_uint16 const   )208,      (yytype_uint16 const   )208, 
        (yytype_uint16 const   )208,      (yytype_uint16 const   )209,      (yytype_uint16 const   )210,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )211,      (yytype_uint16 const   )211,      (yytype_uint16 const   )212,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )212,      (yytype_uint16 const   )212,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )213,      (yytype_uint16 const   )213,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )213,      (yytype_uint16 const   )213,      (yytype_uint16 const   )213,      (yytype_uint16 const   )214, 
        (yytype_uint16 const   )214,      (yytype_uint16 const   )214,      (yytype_uint16 const   )214,      (yytype_uint16 const   )214, 
        (yytype_uint16 const   )214,      (yytype_uint16 const   )215,      (yytype_uint16 const   )215,      (yytype_uint16 const   )215, 
        (yytype_uint16 const   )215,      (yytype_uint16 const   )215,      (yytype_uint16 const   )216,      (yytype_uint16 const   )216, 
        (yytype_uint16 const   )216,      (yytype_uint16 const   )216,      (yytype_uint16 const   )216,      (yytype_uint16 const   )216, 
        (yytype_uint16 const   )216,      (yytype_uint16 const   )217,      (yytype_uint16 const   )218,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )218,      (yytype_uint16 const   )218,      (yytype_uint16 const   )218,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )219,      (yytype_uint16 const   )220,      (yytype_uint16 const   )220,      (yytype_uint16 const   )220, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )220,      (yytype_uint16 const   )220,      (yytype_uint16 const   )220, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )220,      (yytype_uint16 const   )220,      (yytype_uint16 const   )221, 
        (yytype_uint16 const   )221,      (yytype_uint16 const   )221,      (yytype_uint16 const   )221,      (yytype_uint16 const   )221, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )222,      (yytype_uint16 const   )222,      (yytype_uint16 const   )222, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )222,      (yytype_uint16 const   )222,      (yytype_uint16 const   )222, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )222,      (yytype_uint16 const   )223,      (yytype_uint16 const   )223, 
        (yytype_uint16 const   )223,      (yytype_uint16 const   )223,      (yytype_uint16 const   )223,      (yytype_uint16 const   )224, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )224,      (yytype_uint16 const   )224,      (yytype_uint16 const   )224, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )224,      (yytype_uint16 const   )224,      (yytype_uint16 const   )225, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )225,      (yytype_uint16 const   )225,      (yytype_uint16 const   )225, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )225,      (yytype_uint16 const   )225,      (yytype_uint16 const   )226, 
        (yytype_uint16 const   )226,      (yytype_uint16 const   )226,      (yytype_uint16 const   )226,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )227,      (yytype_uint16 const   )227,      (yytype_uint16 const   )227,      (yytype_uint16 const   )228, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )228,      (yytype_uint16 const   )228,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )229,      (yytype_uint16 const   )229,      (yytype_uint16 const   )229,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )231,      (yytype_uint16 const   )231,      (yytype_uint16 const   )232, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )233,      (yytype_uint16 const   )233,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )237, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )237,      (yytype_uint16 const   )237,      (yytype_uint16 const   )238, 
        (yytype_uint16 const   )239,      (yytype_uint16 const   )240,      (yytype_uint16 const   )240,      (yytype_uint16 const   )241, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )242,      (yytype_uint16 const   )242,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )243,      (yytype_uint16 const   )246,      (yytype_uint16 const   )245, 
        (yytype_uint16 const   )245,      (yytype_uint16 const   )247,      (yytype_uint16 const   )247,      (yytype_uint16 const   )248, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )249,      (yytype_uint16 const   )250,      (yytype_uint16 const   )250, 
        (yytype_uint16 const   )251,      (yytype_uint16 const   )251,      (yytype_uint16 const   )251,      (yytype_uint16 const   )252, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )252,      (yytype_uint16 const   )253,      (yytype_uint16 const   )253, 
        (yytype_uint16 const   )253,      (yytype_uint16 const   )254,      (yytype_uint16 const   )254,      (yytype_uint16 const   )255, 
        (yytype_uint16 const   )255,      (yytype_uint16 const   )255,      (yytype_uint16 const   )255,      (yytype_uint16 const   )255, 
        (yytype_uint16 const   )256,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )258,      (yytype_uint16 const   )258,      (yytype_uint16 const   )258,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )259,      (yytype_uint16 const   )259, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )263, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )266,      (yytype_uint16 const   )265,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )265,      (yytype_uint16 const   )267,      (yytype_uint16 const   )267,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )268,      (yytype_uint16 const   )270,      (yytype_uint16 const   )271, 
        (yytype_uint16 const   )269,      (yytype_uint16 const   )273,      (yytype_uint16 const   )274,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )275,      (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )276, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )276,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )277,      (yytype_uint16 const   )277,      (yytype_uint16 const   )278,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )278,      (yytype_uint16 const   )278,      (yytype_uint16 const   )279, 
        (yytype_uint16 const   )280,      (yytype_uint16 const   )280,      (yytype_uint16 const   )282,      (yytype_uint16 const   )281, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )281,      (yytype_uint16 const   )281,      (yytype_uint16 const   )284, 
        (yytype_uint16 const   )281,      (yytype_uint16 const   )285,      (yytype_uint16 const   )281,      (yytype_uint16 const   )286, 
        (yytype_uint16 const   )286,      (yytype_uint16 const   )286,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287, 
        (yytype_uint16 const   )287,      (yytype_uint16 const   )288,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289, 
        (yytype_uint16 const   )289,      (yytype_uint16 const   )290,      (yytype_uint16 const   )290,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )291,      (yytype_uint16 const   )291,      (yytype_uint16 const   )291,      (yytype_uint16 const   )291, 
        (yytype_uint16 const   )291,      (yytype_uint16 const   )291,      (yytype_uint16 const   )292,      (yytype_uint16 const   )292, 
        (yytype_uint16 const   )293,      (yytype_uint16 const   )293,      (yytype_uint16 const   )294,      (yytype_uint16 const   )294, 
        (yytype_uint16 const   )294,      (yytype_uint16 const   )295,      (yytype_uint16 const   )295,      (yytype_uint16 const   )295, 
        (yytype_uint16 const   )296,      (yytype_uint16 const   )296,      (yytype_uint16 const   )296,      (yytype_uint16 const   )297, 
        (yytype_uint16 const   )297,      (yytype_uint16 const   )299,      (yytype_uint16 const   )298,      (yytype_uint16 const   )300, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )302,      (yytype_uint16 const   )303,      (yytype_uint16 const   )303,      (yytype_uint16 const   )304, 
        (yytype_uint16 const   )304,      (yytype_uint16 const   )304,      (yytype_uint16 const   )305,      (yytype_uint16 const   )305, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )306,      (yytype_uint16 const   )307,      (yytype_uint16 const   )307, 
        (yytype_uint16 const   )308,      (yytype_uint16 const   )309,      (yytype_uint16 const   )309,      (yytype_uint16 const   )310, 
        (yytype_uint16 const   )311,      (yytype_uint16 const   )311,      (yytype_uint16 const   )311,      (yytype_uint16 const   )312, 
        (yytype_uint16 const   )312,      (yytype_uint16 const   )313,      (yytype_uint16 const   )314,      (yytype_uint16 const   )315, 
        (yytype_uint16 const   )315,      (yytype_uint16 const   )316,      (yytype_uint16 const   )316,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )318,      (yytype_uint16 const   )318,      (yytype_uint16 const   )319,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )320,      (yytype_uint16 const   )320,      (yytype_uint16 const   )320,      (yytype_uint16 const   )321, 
        (yytype_uint16 const   )321,      (yytype_uint16 const   )322,      (yytype_uint16 const   )324,      (yytype_uint16 const   )323, 
        (yytype_uint16 const   )325,      (yytype_uint16 const   )325,      (yytype_uint16 const   )326,      (yytype_uint16 const   )326, 
        (yytype_uint16 const   )328,      (yytype_uint16 const   )327,      (yytype_uint16 const   )329,      (yytype_uint16 const   )329, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )331,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )332,      (yytype_uint16 const   )333, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )334, 
        (yytype_uint16 const   )335,      (yytype_uint16 const   )336,      (yytype_uint16 const   )330,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )330,      (yytype_uint16 const   )338,      (yytype_uint16 const   )338,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )338,      (yytype_uint16 const   )339,      (yytype_uint16 const   )339,      (yytype_uint16 const   )340, 
        (yytype_uint16 const   )340,      (yytype_uint16 const   )341,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342, 
        (yytype_uint16 const   )342,      (yytype_uint16 const   )343,      (yytype_uint16 const   )343,      (yytype_uint16 const   )344, 
        (yytype_uint16 const   )344,      (yytype_uint16 const   )346,      (yytype_uint16 const   )345,      (yytype_uint16 const   )347, 
        (yytype_uint16 const   )348,      (yytype_uint16 const   )347,      (yytype_uint16 const   )347,      (yytype_uint16 const   )349, 
        (yytype_uint16 const   )349,      (yytype_uint16 const   )349,      (yytype_uint16 const   )349,      (yytype_uint16 const   )350, 
        (yytype_uint16 const   )350,      (yytype_uint16 const   )351,      (yytype_uint16 const   )351,      (yytype_uint16 const   )351, 
        (yytype_uint16 const   )351,      (yytype_uint16 const   )351,      (yytype_uint16 const   )351,      (yytype_uint16 const   )351, 
        (yytype_uint16 const   )352,      (yytype_uint16 const   )354,      (yytype_uint16 const   )353,      (yytype_uint16 const   )355, 
        (yytype_uint16 const   )355,      (yytype_uint16 const   )356,      (yytype_uint16 const   )356,      (yytype_uint16 const   )357, 
        (yytype_uint16 const   )358,      (yytype_uint16 const   )358,      (yytype_uint16 const   )359,      (yytype_uint16 const   )359, 
        (yytype_uint16 const   )360,      (yytype_uint16 const   )361,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )363,      (yytype_uint16 const   )364};
#line 1229 "c-parse.tab.c"
static yytype_uint8 const   yyr2[634]  = 
#line 1229
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )6,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )5,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1};
#line 1300 "c-parse.tab.c"
static yytype_uint16 const   yydefact[1038]  = 
#line 1300
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )113,      (yytype_uint16 const   )113,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )115,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )47,      (yytype_uint16 const   )14,      (yytype_uint16 const   )2,      (yytype_uint16 const   )3, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )7,      (yytype_uint16 const   )359,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )629,      (yytype_uint16 const   )633,      (yytype_uint16 const   )631,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )463,      (yytype_uint16 const   )464,      (yytype_uint16 const   )630,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )465,      (yytype_uint16 const   )466,      (yytype_uint16 const   )387, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )323,      (yytype_uint16 const   )324, 
        (yytype_uint16 const   )325,      (yytype_uint16 const   )326,      (yytype_uint16 const   )315,      (yytype_uint16 const   )316, 
        (yytype_uint16 const   )317,      (yytype_uint16 const   )318,      (yytype_uint16 const   )327,      (yytype_uint16 const   )328, 
        (yytype_uint16 const   )329,      (yytype_uint16 const   )330,      (yytype_uint16 const   )319,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )321,      (yytype_uint16 const   )322,      (yytype_uint16 const   )616,      (yytype_uint16 const   )616, 
        (yytype_uint16 const   )246,      (yytype_uint16 const   )253,      (yytype_uint16 const   )353,      (yytype_uint16 const   )355, 
        (yytype_uint16 const   )354,      (yytype_uint16 const   )244,      (yytype_uint16 const   )379,      (yytype_uint16 const   )382, 
        (yytype_uint16 const   )385,      (yytype_uint16 const   )386,      (yytype_uint16 const   )357,      (yytype_uint16 const   )358, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )6,      (yytype_uint16 const   )270,      (yytype_uint16 const   )238, 
        (yytype_uint16 const   )356,      (yytype_uint16 const   )9,      (yytype_uint16 const   )343,      (yytype_uint16 const   )344, 
        (yytype_uint16 const   )345,      (yytype_uint16 const   )346,      (yytype_uint16 const   )339,      (yytype_uint16 const   )340, 
        (yytype_uint16 const   )341,      (yytype_uint16 const   )342,      (yytype_uint16 const   )347,      (yytype_uint16 const   )348, 
        (yytype_uint16 const   )497,      (yytype_uint16 const   )8,      (yytype_uint16 const   )1,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )628,      (yytype_uint16 const   )128, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )114,      (yytype_uint16 const   )118,      (yytype_uint16 const   )122, 
        (yytype_uint16 const   )129,      (yytype_uint16 const   )117,      (yytype_uint16 const   )0,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )230,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )46,      (yytype_uint16 const   )0,      (yytype_uint16 const   )33,      (yytype_uint16 const   )34, 
        (yytype_uint16 const   )35,      (yytype_uint16 const   )0,      (yytype_uint16 const   )11,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )137,      (yytype_uint16 const   )138,      (yytype_uint16 const   )461,      (yytype_uint16 const   )451, 
        (yytype_uint16 const   )380,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )390,      (yytype_uint16 const   )215,      (yytype_uint16 const   )216,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )391,      (yytype_uint16 const   )388,      (yytype_uint16 const   )140,      (yytype_uint16 const   )402, 
        (yytype_uint16 const   )389,      (yytype_uint16 const   )0,      (yytype_uint16 const   )251,      (yytype_uint16 const   )257, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )273,      (yytype_uint16 const   )239,      (yytype_uint16 const   )252, 
        (yytype_uint16 const   )258,      (yytype_uint16 const   )274,      (yytype_uint16 const   )240,      (yytype_uint16 const   )263, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )245,      (yytype_uint16 const   )280,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )264,      (yytype_uint16 const   )269,      (yytype_uint16 const   )281,      (yytype_uint16 const   )243, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )255,      (yytype_uint16 const   )254,      (yytype_uint16 const   )291, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )250,      (yytype_uint16 const   )256,      (yytype_uint16 const   )292, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )261,      (yytype_uint16 const   )266,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )259,      (yytype_uint16 const   )262,      (yytype_uint16 const   )267, 
        (yytype_uint16 const   )307,      (yytype_uint16 const   )260,      (yytype_uint16 const   )289,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )277,      (yytype_uint16 const   )275,      (yytype_uint16 const   )271,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )299,      (yytype_uint16 const   )276,      (yytype_uint16 const   )272,      (yytype_uint16 const   )304, 
        (yytype_uint16 const   )313,      (yytype_uint16 const   )284,      (yytype_uint16 const   )282,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )305,      (yytype_uint16 const   )314,      (yytype_uint16 const   )283,      (yytype_uint16 const   )279, 
        (yytype_uint16 const   )287,      (yytype_uint16 const   )296,      (yytype_uint16 const   )295,      (yytype_uint16 const   )293, 
        (yytype_uint16 const   )285,      (yytype_uint16 const   )288,      (yytype_uint16 const   )297,      (yytype_uint16 const   )294, 
        (yytype_uint16 const   )286,      (yytype_uint16 const   )302,      (yytype_uint16 const   )311,      (yytype_uint16 const   )310, 
        (yytype_uint16 const   )308,      (yytype_uint16 const   )300,      (yytype_uint16 const   )303,      (yytype_uint16 const   )312, 
        (yytype_uint16 const   )309,      (yytype_uint16 const   )301,      (yytype_uint16 const   )499,      (yytype_uint16 const   )499, 
        (yytype_uint16 const   )383,      (yytype_uint16 const   )473,      (yytype_uint16 const   )380,      (yytype_uint16 const   )499, 
        (yytype_uint16 const   )116,      (yytype_uint16 const   )126,      (yytype_uint16 const   )127,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )449,      (yytype_uint16 const   )351,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )364,      (yytype_uint16 const   )367,      (yytype_uint16 const   )369, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )120, 
        (yytype_uint16 const   )18,      (yytype_uint16 const   )43,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )13,      (yytype_uint16 const   )360,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )453,      (yytype_uint16 const   )380,      (yytype_uint16 const   )197,      (yytype_uint16 const   )198, 
        (yytype_uint16 const   )169,      (yytype_uint16 const   )170,      (yytype_uint16 const   )148,      (yytype_uint16 const   )149, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )141, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )142,      (yytype_uint16 const   )0,      (yytype_uint16 const   )145, 
        (yytype_uint16 const   )144,      (yytype_uint16 const   )0,      (yytype_uint16 const   )146,      (yytype_uint16 const   )147, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )157,      (yytype_uint16 const   )158,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )150,      (yytype_uint16 const   )153,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )171,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )175, 
        (yytype_uint16 const   )154,      (yytype_uint16 const   )159,      (yytype_uint16 const   )204,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )395,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )445,      (yytype_uint16 const   )351, 
        (yytype_uint16 const   )597,      (yytype_uint16 const   )0,      (yytype_uint16 const   )377,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )611,      (yytype_uint16 const   )500,      (yytype_uint16 const   )502,      (yytype_uint16 const   )501, 
        (yytype_uint16 const   )503,      (yytype_uint16 const   )509,      (yytype_uint16 const   )512,      (yytype_uint16 const   )513, 
        (yytype_uint16 const   )351,      (yytype_uint16 const   )377,      (yytype_uint16 const   )614,      (yytype_uint16 const   )502, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )452,      (yytype_uint16 const   )351, 
        (yytype_uint16 const   )597,      (yytype_uint16 const   )498,      (yytype_uint16 const   )502,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )343,      (yytype_uint16 const   )344, 
        (yytype_uint16 const   )345,      (yytype_uint16 const   )346,      (yytype_uint16 const   )352,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )378,      (yytype_uint16 const   )121,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )617,      (yytype_uint16 const   )29,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )377,      (yytype_uint16 const   )446,      (yytype_uint16 const   )510, 
        (yytype_uint16 const   )511,      (yytype_uint16 const   )441,      (yytype_uint16 const   )351,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )363,      (yytype_uint16 const   )365,      (yytype_uint16 const   )369, 
        (yytype_uint16 const   )436,      (yytype_uint16 const   )437,      (yytype_uint16 const   )0,      (yytype_uint16 const   )369, 
        (yytype_uint16 const   )125,      (yytype_uint16 const   )21,      (yytype_uint16 const   )380,      (yytype_uint16 const   )36, 
        (yytype_uint16 const   )39,      (yytype_uint16 const   )0,      (yytype_uint16 const   )16,      (yytype_uint16 const   )494, 
        (yytype_uint16 const   )495,      (yytype_uint16 const   )469,      (yytype_uint16 const   )492,      (yytype_uint16 const   )459, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )381,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )139,      (yytype_uint16 const   )164,      (yytype_uint16 const   )161, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )163,      (yytype_uint16 const   )361,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )160,      (yytype_uint16 const   )0,      (yytype_uint16 const   )165, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )167,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )193,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )211,      (yytype_uint16 const   )210,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )151,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )162,      (yytype_uint16 const   )407,      (yytype_uint16 const   )403,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )393,      (yytype_uint16 const   )396,      (yytype_uint16 const   )404,      (yytype_uint16 const   )406, 
        (yytype_uint16 const   )405,      (yytype_uint16 const   )392,      (yytype_uint16 const   )401,      (yytype_uint16 const   )424, 
        (yytype_uint16 const   )197,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )421, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )423,      (yytype_uint16 const   )0,      (yytype_uint16 const   )467, 
        (yytype_uint16 const   )414,      (yytype_uint16 const   )420,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )505,      (yytype_uint16 const   )0,      (yytype_uint16 const   )626,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )518,      (yytype_uint16 const   )0,      (yytype_uint16 const   )609,      (yytype_uint16 const   )443, 
        (yytype_uint16 const   )610,      (yytype_uint16 const   )612,      (yytype_uint16 const   )597,      (yytype_uint16 const   )508, 
        (yytype_uint16 const   )505,      (yytype_uint16 const   )613,      (yytype_uint16 const   )615,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )480,      (yytype_uint16 const   )475,      (yytype_uint16 const   )230,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )472,      (yytype_uint16 const   )0,      (yytype_uint16 const   )454,      (yytype_uint16 const   )505, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )450, 
        (yytype_uint16 const   )447,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )231, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )626,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )134,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )124,      (yytype_uint16 const   )377,      (yytype_uint16 const   )131, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )438,      (yytype_uint16 const   )123,      (yytype_uint16 const   )132, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )380,      (yytype_uint16 const   )44,      (yytype_uint16 const   )48, 
        (yytype_uint16 const   )48,      (yytype_uint16 const   )15,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )470,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )456, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )201,      (yytype_uint16 const   )200, 
        (yytype_uint16 const   )534,      (yytype_uint16 const   )526,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )155,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )190,      (yytype_uint16 const   )188,      (yytype_uint16 const   )189,      (yytype_uint16 const   )187, 
        (yytype_uint16 const   )186,      (yytype_uint16 const   )184,      (yytype_uint16 const   )185,      (yytype_uint16 const   )183, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )181,      (yytype_uint16 const   )176,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )178,      (yytype_uint16 const   )179,      (yytype_uint16 const   )180,      (yytype_uint16 const   )208, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )152,      (yytype_uint16 const   )0,      (yytype_uint16 const   )209, 
        (yytype_uint16 const   )395,      (yytype_uint16 const   )0,      (yytype_uint16 const   )151,      (yytype_uint16 const   )427, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )418,      (yytype_uint16 const   )400, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )413,      (yytype_uint16 const   )0,      (yytype_uint16 const   )426, 
        (yytype_uint16 const   )417,      (yytype_uint16 const   )444,      (yytype_uint16 const   )504,      (yytype_uint16 const   )506, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )632,      (yytype_uint16 const   )516,      (yytype_uint16 const   )627, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )604,      (yytype_uint16 const   )598,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )605,      (yytype_uint16 const   )607,      (yytype_uint16 const   )517,      (yytype_uint16 const   )458, 
        (yytype_uint16 const   )477,      (yytype_uint16 const   )479,      (yytype_uint16 const   )474,      (yytype_uint16 const   )481, 
        (yytype_uint16 const   )473,      (yytype_uint16 const   )119,      (yytype_uint16 const   )130,      (yytype_uint16 const   )448, 
        (yytype_uint16 const   )368,      (yytype_uint16 const   )369,      (yytype_uint16 const   )0,      (yytype_uint16 const   )515, 
        (yytype_uint16 const   )623,      (yytype_uint16 const   )619,      (yytype_uint16 const   )618,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )621,      (yytype_uint16 const   )0,      (yytype_uint16 const   )30,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )626,      (yytype_uint16 const   )374,      (yytype_uint16 const   )217,      (yytype_uint16 const   )442, 
        (yytype_uint16 const   )439,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )134, 
        (yytype_uint16 const   )26,      (yytype_uint16 const   )0,      (yytype_uint16 const   )23,      (yytype_uint16 const   )380, 
        (yytype_uint16 const   )19,      (yytype_uint16 const   )0,      (yytype_uint16 const   )50,      (yytype_uint16 const   )380, 
        (yytype_uint16 const   )380,      (yytype_uint16 const   )17,      (yytype_uint16 const   )496,      (yytype_uint16 const   )493, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )469,      (yytype_uint16 const   )473,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )527,      (yytype_uint16 const   )203,      (yytype_uint16 const   )173, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )166,      (yytype_uint16 const   )168,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )214,      (yytype_uint16 const   )207,      (yytype_uint16 const   )394, 
        (yytype_uint16 const   )384,      (yytype_uint16 const   )197,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )429,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )415, 
        (yytype_uint16 const   )416,      (yytype_uint16 const   )507,      (yytype_uint16 const   )602,      (yytype_uint16 const   )599, 
        (yytype_uint16 const   )600,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )476,      (yytype_uint16 const   )482,      (yytype_uint16 const   )0,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )478,      (yytype_uint16 const   )484,      (yytype_uint16 const   )0,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )370,      (yytype_uint16 const   )0,      (yytype_uint16 const   )620,      (yytype_uint16 const   )32, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )31,      (yytype_uint16 const   )514,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )135,      (yytype_uint16 const   )218,      (yytype_uint16 const   )220,      (yytype_uint16 const   )335, 
        (yytype_uint16 const   )336,      (yytype_uint16 const   )331,      (yytype_uint16 const   )332,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )338,      (yytype_uint16 const   )333,      (yytype_uint16 const   )334,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )440,      (yytype_uint16 const   )366,      (yytype_uint16 const   )371, 
        (yytype_uint16 const   )22,      (yytype_uint16 const   )0,      (yytype_uint16 const   )25,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )60,      (yytype_uint16 const   )0,      (yytype_uint16 const   )51,      (yytype_uint16 const   )52, 
        (yytype_uint16 const   )616,      (yytype_uint16 const   )616,      (yytype_uint16 const   )37,      (yytype_uint16 const   )40, 
        (yytype_uint16 const   )462,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )535, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )528,      (yytype_uint16 const   )529,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )194,      (yytype_uint16 const   )0,      (yytype_uint16 const   )397, 
        (yytype_uint16 const   )399,      (yytype_uint16 const   )0,      (yytype_uint16 const   )422,      (yytype_uint16 const   )419, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )606,      (yytype_uint16 const   )608,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )486,      (yytype_uint16 const   )377,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )489,      (yytype_uint16 const   )377,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )373,      (yytype_uint16 const   )622,      (yytype_uint16 const   )411,      (yytype_uint16 const   )409, 
        (yytype_uint16 const   )408,      (yytype_uint16 const   )375,      (yytype_uint16 const   )0,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )221,      (yytype_uint16 const   )0,      (yytype_uint16 const   )225,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )24,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )49,      (yytype_uint16 const   )0,      (yytype_uint16 const   )57, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )205,      (yytype_uint16 const   )0,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )624,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )359, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )558,      (yytype_uint16 const   )542,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )630,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )585, 
        (yytype_uint16 const   )580,      (yytype_uint16 const   )548,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )523,      (yytype_uint16 const   )0,      (yytype_uint16 const   )230,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )552,      (yytype_uint16 const   )556,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )520,      (yytype_uint16 const   )579,      (yytype_uint16 const   )546,      (yytype_uint16 const   )547, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )530,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )428,      (yytype_uint16 const   )601,      (yytype_uint16 const   )488,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )491,      (yytype_uint16 const   )377,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )455,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )136, 
        (yytype_uint16 const   )532,      (yytype_uint16 const   )224,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )369,      (yytype_uint16 const   )372,      (yytype_uint16 const   )0,      (yytype_uint16 const   )28, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )230,      (yytype_uint16 const   )45,      (yytype_uint16 const   )65, 
        (yytype_uint16 const   )67,      (yytype_uint16 const   )59,      (yytype_uint16 const   )0,      (yytype_uint16 const   )61, 
        (yytype_uint16 const   )62,      (yytype_uint16 const   )53,      (yytype_uint16 const   )377,      (yytype_uint16 const   )377, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )60,      (yytype_uint16 const   )60,      (yytype_uint16 const   )460, 
        (yytype_uint16 const   )457,      (yytype_uint16 const   )213,      (yytype_uint16 const   )531,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )525,      (yytype_uint16 const   )537,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )587,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )583,      (yytype_uint16 const   )569,      (yytype_uint16 const   )570,      (yytype_uint16 const   )571, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )586,      (yytype_uint16 const   )0,      (yytype_uint16 const   )584,      (yytype_uint16 const   )553, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )524,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )229,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )538,      (yytype_uint16 const   )0,      (yytype_uint16 const   )522,      (yytype_uint16 const   )521, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )540,      (yytype_uint16 const   )539,      (yytype_uint16 const   )544, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )562,      (yytype_uint16 const   )0,      (yytype_uint16 const   )237, 
        (yytype_uint16 const   )174,      (yytype_uint16 const   )398,      (yytype_uint16 const   )487,      (yytype_uint16 const   )483, 
        (yytype_uint16 const   )490,      (yytype_uint16 const   )485,      (yytype_uint16 const   )0,      (yytype_uint16 const   )533, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )223,      (yytype_uint16 const   )377,      (yytype_uint16 const   )20, 
        (yytype_uint16 const   )27,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )64,      (yytype_uint16 const   )54,      (yytype_uint16 const   )55, 
        (yytype_uint16 const   )56,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )625, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )588, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )581, 
        (yytype_uint16 const   )572,      (yytype_uint16 const   )0,      (yytype_uint16 const   )577,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )551,      (yytype_uint16 const   )549,      (yytype_uint16 const   )550,      (yytype_uint16 const   )536, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )234,      (yytype_uint16 const   )369,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )369,      (yytype_uint16 const   )236,      (yytype_uint16 const   )557, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )545,      (yytype_uint16 const   )0,      (yytype_uint16 const   )410, 
        (yytype_uint16 const   )376,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )380,      (yytype_uint16 const   )76,      (yytype_uint16 const   )73, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )0,      (yytype_uint16 const   )41,      (yytype_uint16 const   )541, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )543,      (yytype_uint16 const   )563,      (yytype_uint16 const   )567, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )578,      (yytype_uint16 const   )0,      (yytype_uint16 const   )232, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )233,      (yytype_uint16 const   )377,      (yytype_uint16 const   )555, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )72,      (yytype_uint16 const   )78, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )380,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )111,      (yytype_uint16 const   )38,      (yytype_uint16 const   )0,      (yytype_uint16 const   )559, 
        (yytype_uint16 const   )587,      (yytype_uint16 const   )0,      (yytype_uint16 const   )582,      (yytype_uint16 const   )589, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )430,      (yytype_uint16 const   )433,      (yytype_uint16 const   )561, 
        (yytype_uint16 const   )70,      (yytype_uint16 const   )71,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )74,      (yytype_uint16 const   )77,      (yytype_uint16 const   )0,      (yytype_uint16 const   )83, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )568, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )590, 
        (yytype_uint16 const   )591,      (yytype_uint16 const   )573,      (yytype_uint16 const   )217,      (yytype_uint16 const   )217, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )75,      (yytype_uint16 const   )113,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )560,      (yytype_uint16 const   )564,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )589,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )431, 
        (yytype_uint16 const   )434,      (yytype_uint16 const   )0,      (yytype_uint16 const   )81,      (yytype_uint16 const   )98, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )100,      (yytype_uint16 const   )587,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )574,      (yytype_uint16 const   )592, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )80,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )112,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )593, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )432, 
        (yytype_uint16 const   )435,      (yytype_uint16 const   )82,      (yytype_uint16 const   )0,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )103,      (yytype_uint16 const   )99,      (yytype_uint16 const   )101,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )108,      (yytype_uint16 const   )102,      (yytype_uint16 const   )109,      (yytype_uint16 const   )565, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )595,      (yytype_uint16 const   )0,      (yytype_uint16 const   )575, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )87,      (yytype_uint16 const   )88, 
        (yytype_uint16 const   )90,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )85, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )107, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )566, 
        (yytype_uint16 const   )594,      (yytype_uint16 const   )596,      (yytype_uint16 const   )576,      (yytype_uint16 const   )92, 
        (yytype_uint16 const   )86,      (yytype_uint16 const   )89,      (yytype_uint16 const   )104,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )106,      (yytype_uint16 const   )110,      (yytype_uint16 const   )0,      (yytype_uint16 const   )93, 
        (yytype_uint16 const   )94,      (yytype_uint16 const   )97,      (yytype_uint16 const   )96,      (yytype_uint16 const   )91, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )95};
#line 1409 "c-parse.tab.c"
static yytype_int16 const   yydefgoto[262]  = 
#line 1409
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )5,      (yytype_int16 const   )8,      (yytype_int16 const   )9, 
        (yytype_int16 const   )102,      (yytype_int16 const   )221,      (yytype_int16 const   )329,      (yytype_int16 const   )10, 
        (yytype_int16 const   )325,      (yytype_int16 const   )639,      (yytype_int16 const   )457,      (yytype_int16 const   )561, 
        (yytype_int16 const   )562,      (yytype_int16 const   )563,      (yytype_int16 const   )766,      (yytype_int16 const   )307, 
        (yytype_int16 const   )443,      (yytype_int16 const   )550,      (yytype_int16 const   )11,      (yytype_int16 const   )98, 
        (yytype_int16 const   )459,      (yytype_int16 const   )701,      (yytype_int16 const   )99,      (yytype_int16 const   )460, 
        (yytype_int16 const   )702,      (yytype_int16 const   )914,      (yytype_int16 const   )100,      (yytype_int16 const   )326, 
        (yytype_int16 const   )565,      (yytype_int16 const   )101,      (yytype_int16 const   )567,      (yytype_int16 const   )641, 
        (yytype_int16 const   )642,      (yytype_int16 const   )643,      (yytype_int16 const   )695,      (yytype_int16 const   )696, 
        (yytype_int16 const   )773,      (yytype_int16 const   )774,      (yytype_int16 const   )775,      (yytype_int16 const   )843, 
        (yytype_int16 const   )776,      (yytype_int16 const   )844,      (yytype_int16 const   )883,      (yytype_int16 const   )905, 
        (yytype_int16 const   )884,      (yytype_int16 const   )885,      (yytype_int16 const   )886,      (yytype_int16 const   )926, 
        (yytype_int16 const   )957,      (yytype_int16 const   )932,      (yytype_int16 const   )947,      (yytype_int16 const   )984, 
        (yytype_int16 const   )997,      (yytype_int16 const   )998,      (yytype_int16 const   )999,      (yytype_int16 const   )1030, 
        (yytype_int16 const   )1031,      (yytype_int16 const   )1032,      (yytype_int16 const   )1033,      (yytype_int16 const   )973, 
        (yytype_int16 const   )985,      (yytype_int16 const   )986,      (yytype_int16 const   )987,      (yytype_int16 const   )988, 
        (yytype_int16 const   )913,      (yytype_int16 const   )930,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )79,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )887, 
        (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )308,      (yytype_int16 const   )554, 
        (yytype_int16 const   )686,      (yytype_int16 const   )118,      (yytype_int16 const   )726,      (yytype_int16 const   )990, 
        (yytype_int16 const   )247,      (yytype_int16 const   )727,      (yytype_int16 const   )500,      (yytype_int16 const   )249, 
        (yytype_int16 const   )250,      (yytype_int16 const   )251,      (yytype_int16 const   )252,      (yytype_int16 const   )253, 
        (yytype_int16 const   )254,      (yytype_int16 const   )255,      (yytype_int16 const   )659,      (yytype_int16 const   )256, 
        (yytype_int16 const   )482,      (yytype_int16 const   )257,      (yytype_int16 const   )346,      (yytype_int16 const   )653, 
        (yytype_int16 const   )258,      (yytype_int16 const   )259,      (yytype_int16 const   )620,      (yytype_int16 const   )621, 
        (yytype_int16 const   )622,      (yytype_int16 const   )728,      (yytype_int16 const   )90,      (yytype_int16 const   )438, 
        (yytype_int16 const   )729,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )631, 
        (yytype_int16 const   )632,      (yytype_int16 const   )74,      (yytype_int16 const   )75,      (yytype_int16 const   )76, 
        (yytype_int16 const   )93,      (yytype_int16 const   )299,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )316, 
        (yytype_int16 const   )322,      (yytype_int16 const   )317,      (yytype_int16 const   )209,      (yytype_int16 const   )309, 
        (yytype_int16 const   )318,      (yytype_int16 const   )692,      (yytype_int16 const   )210,      (yytype_int16 const   )619, 
        (yytype_int16 const   )439,      (yytype_int16 const   )53,      (yytype_int16 const   )224,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )117,      (yytype_int16 const   )387, 
        (yytype_int16 const   )388,      (yytype_int16 const   )57,      (yytype_int16 const   )121,      (yytype_int16 const   )389, 
        (yytype_int16 const   )685,      (yytype_int16 const   )757,      (yytype_int16 const   )402,      (yytype_int16 const   )403, 
        (yytype_int16 const   )404,      (yytype_int16 const   )594,      (yytype_int16 const   )405,      (yytype_int16 const   )509, 
        (yytype_int16 const   )406,      (yytype_int16 const   )407,      (yytype_int16 const   )869,      (yytype_int16 const   )942, 
        (yytype_int16 const   )968,      (yytype_int16 const   )872,      (yytype_int16 const   )943,      (yytype_int16 const   )969, 
        (yytype_int16 const   )541,      (yytype_int16 const   )320,      (yytype_int16 const   )270,      (yytype_int16 const   )321, 
        (yytype_int16 const   )108,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )536, 
        (yytype_int16 const   )574,      (yytype_int16 const   )466,      (yytype_int16 const   )223,      (yytype_int16 const   )60, 
        (yytype_int16 const   )513,      (yytype_int16 const   )465,      (yytype_int16 const   )284,      (yytype_int16 const   )285, 
        (yytype_int16 const   )428,      (yytype_int16 const   )604,      (yytype_int16 const   )608,      (yytype_int16 const   )605, 
        (yytype_int16 const   )609,      (yytype_int16 const   )333,      (yytype_int16 const   )334,      (yytype_int16 const   )959, 
        (yytype_int16 const   )199,      (yytype_int16 const   )272,      (yytype_int16 const   )273,      (yytype_int16 const   )290, 
        (yytype_int16 const   )275,      (yytype_int16 const   )276,      (yytype_int16 const   )310,      (yytype_int16 const   )277, 
        (yytype_int16 const   )311,      (yytype_int16 const   )278,      (yytype_int16 const   )312,      (yytype_int16 const   )733, 
        (yytype_int16 const   )734,      (yytype_int16 const   )810,      (yytype_int16 const   )735,      (yytype_int16 const   )577, 
        (yytype_int16 const   )656,      (yytype_int16 const   )657,      (yytype_int16 const   )658,      (yytype_int16 const   )759, 
        (yytype_int16 const   )473,      (yytype_int16 const   )736,      (yytype_int16 const   )737,      (yytype_int16 const   )738, 
        (yytype_int16 const   )739,      (yytype_int16 const   )792,      (yytype_int16 const   )822,      (yytype_int16 const   )740, 
        (yytype_int16 const   )741,      (yytype_int16 const   )805,      (yytype_int16 const   )865,      (yytype_int16 const   )823, 
        (yytype_int16 const   )876,      (yytype_int16 const   )791,      (yytype_int16 const   )933,      (yytype_int16 const   )916, 
        (yytype_int16 const   )962,      (yytype_int16 const   )1006,      (yytype_int16 const   )917,      (yytype_int16 const   )824, 
        (yytype_int16 const   )803,      (yytype_int16 const   )856,      (yytype_int16 const   )938,      (yytype_int16 const   )939, 
        (yytype_int16 const   )940,      (yytype_int16 const   )994,      (yytype_int16 const   )410,      (yytype_int16 const   )411, 
        (yytype_int16 const   )545,      (yytype_int16 const   )668,      (yytype_int16 const   )527,      (yytype_int16 const   )528, 
        (yytype_int16 const   )529,      (yytype_int16 const   )194,      (yytype_int16 const   )441,      (yytype_int16 const   )442, 
        (yytype_int16 const   )546,      (yytype_int16 const   )547,      (yytype_int16 const   )548,      (yytype_int16 const   )709, 
        (yytype_int16 const   )522,      (yytype_int16 const   )261,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )523,      (yytype_int16 const   )64};
#line 1443 "c-parse.tab.c"
static yytype_int16 const   yypact[1038]  = 
#line 1443
  {      (yytype_int16 const   )560,      (yytype_int16 const   )204,      (yytype_int16 const   )583,      (yytype_int16 const   )2204, 
        (yytype_int16 const   )2276,      (yytype_int16 const   )251,      (yytype_int16 const   )311,      (yytype_int16 const   )1317, 
        (yytype_int16 const   )536,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )534,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )273, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )76, 
        (yytype_int16 const   )215,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )52, 
        (yytype_int16 const   )367,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )322,      (yytype_int16 const   )544,      (yytype_int16 const   )2947,      (yytype_int16 const   )630, 
        (yytype_int16 const   )2947,      (yytype_int16 const   )630,      (yytype_int16 const   )1209,      (yytype_int16 const   )760, 
        (yytype_int16 const   )1209,      (yytype_int16 const   )760,      (yytype_int16 const   )2947,      (yytype_int16 const   )630, 
        (yytype_int16 const   )2947,      (yytype_int16 const   )630,      (yytype_int16 const   )1209,      (yytype_int16 const   )760, 
        (yytype_int16 const   )1209,      (yytype_int16 const   )760,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )168,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )2966,      (yytype_int16 const   )731, 
        (yytype_int16 const   )2966,      (yytype_int16 const   )731,      (yytype_int16 const   )1093,      (yytype_int16 const   )386, 
        (yytype_int16 const   )1093,      (yytype_int16 const   )386,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )1317, 
        (yytype_int16 const   )323,      (yytype_int16 const   )407,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )605,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )343,      (yytype_int16 const   )352, 
        (yytype_int16 const   )389,      (yytype_int16 const   )-729,      (yytype_int16 const   )1317,      (yytype_int16 const   )605, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )441,      (yytype_int16 const   )421,      (yytype_int16 const   )605, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )2695,      (yytype_int16 const   )468, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )69,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )317,      (yytype_int16 const   )402, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )446, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )499,      (yytype_int16 const   )514,      (yytype_int16 const   )83,      (yytype_int16 const   )115, 
        (yytype_int16 const   )480,      (yytype_int16 const   )491,      (yytype_int16 const   )-729,      (yytype_int16 const   )160, 
        (yytype_int16 const   )334,      (yytype_int16 const   )343,      (yytype_int16 const   )529,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )605, 
        (yytype_int16 const   )605,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )565, 
        (yytype_int16 const   )123,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )538,      (yytype_int16 const   )586,      (yytype_int16 const   )605,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )1439,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )552,      (yytype_int16 const   )-729,      (yytype_int16 const   )569,      (yytype_int16 const   )469, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )3866,      (yytype_int16 const   )3925,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )1498,      (yytype_int16 const   )848,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )573,      (yytype_int16 const   )3807,      (yytype_int16 const   )589,      (yytype_int16 const   )576, 
        (yytype_int16 const   )579,      (yytype_int16 const   )2440,      (yytype_int16 const   )-729,      (yytype_int16 const   )83, 
        (yytype_int16 const   )410,      (yytype_int16 const   )3041,      (yytype_int16 const   )741,      (yytype_int16 const   )741, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )9,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )83,      (yytype_int16 const   )741,      (yytype_int16 const   )-729,      (yytype_int16 const   )115, 
        (yytype_int16 const   )607,      (yytype_int16 const   )482,      (yytype_int16 const   )129,      (yytype_int16 const   )83, 
        (yytype_int16 const   )615,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )608, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )605,      (yytype_int16 const   )83,      (yytype_int16 const   )705, 
        (yytype_int16 const   )83,      (yytype_int16 const   )705,      (yytype_int16 const   )-729,      (yytype_int16 const   )343, 
        (yytype_int16 const   )343,      (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )115, 
        (yytype_int16 const   )655,      (yytype_int16 const   )-729,      (yytype_int16 const   )3041,      (yytype_int16 const   )659, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )664,      (yytype_int16 const   )83,      (yytype_int16 const   )115, 
        (yytype_int16 const   )658,      (yytype_int16 const   )632,      (yytype_int16 const   )-729,      (yytype_int16 const   )698, 
        (yytype_int16 const   )578,      (yytype_int16 const   )578,      (yytype_int16 const   )674,      (yytype_int16 const   )160, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )694,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )117,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )693,      (yytype_int16 const   )651,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )605,      (yytype_int16 const   )-729,      (yytype_int16 const   )145,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )2966,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )656,      (yytype_int16 const   )662,      (yytype_int16 const   )684,      (yytype_int16 const   )663, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )3434, 
        (yytype_int16 const   )848,      (yytype_int16 const   )939,      (yytype_int16 const   )1439,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )1439,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )605, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )605,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )395, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )696,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )713,      (yytype_int16 const   )605,      (yytype_int16 const   )3807,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )717,      (yytype_int16 const   )1498,      (yytype_int16 const   )669,      (yytype_int16 const   )675, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )350,      (yytype_int16 const   )3366, 
        (yytype_int16 const   )317,      (yytype_int16 const   )402,      (yytype_int16 const   )763,      (yytype_int16 const   )1569, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )678,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )402,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )115, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )720,      (yytype_int16 const   )2256,      (yytype_int16 const   )-729,      (yytype_int16 const   )446, 
        (yytype_int16 const   )446,      (yytype_int16 const   )721,      (yytype_int16 const   )723,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )578,      (yytype_int16 const   )278,      (yytype_int16 const   )334,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )771,      (yytype_int16 const   )763,      (yytype_int16 const   )1999,      (yytype_int16 const   )2237, 
        (yytype_int16 const   )1999,      (yytype_int16 const   )2,      (yytype_int16 const   )605,      (yytype_int16 const   )334, 
        (yytype_int16 const   )334,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )783,      (yytype_int16 const   )-729,      (yytype_int16 const   )691,      (yytype_int16 const   )733, 
        (yytype_int16 const   )733,      (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )605,      (yytype_int16 const   )695,      (yytype_int16 const   )565,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )4091,      (yytype_int16 const   )699,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )702,      (yytype_int16 const   )3687, 
        (yytype_int16 const   )1498,      (yytype_int16 const   )706,      (yytype_int16 const   )707,      (yytype_int16 const   )1498, 
        (yytype_int16 const   )1498,      (yytype_int16 const   )772,      (yytype_int16 const   )775,      (yytype_int16 const   )2026, 
        (yytype_int16 const   )2264,      (yytype_int16 const   )1149,      (yytype_int16 const   )1460,      (yytype_int16 const   )1863, 
        (yytype_int16 const   )1380,      (yytype_int16 const   )878,      (yytype_int16 const   )878,      (yytype_int16 const   )878, 
        (yytype_int16 const   )797,      (yytype_int16 const   )797,      (yytype_int16 const   )599,      (yytype_int16 const   )599, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )722,      (yytype_int16 const   )-729,      (yytype_int16 const   )724,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )589,      (yytype_int16 const   )726,      (yytype_int16 const   )3984,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3098,      (yytype_int16 const   )2860,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )2372,      (yytype_int16 const   )-729,      (yytype_int16 const   )3495,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )578,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )730,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )743, 
        (yytype_int16 const   )349,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )844,      (yytype_int16 const   )98,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )698,      (yytype_int16 const   )744,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )445, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )725,      (yytype_int16 const   )-729,      (yytype_int16 const   )523, 
        (yytype_int16 const   )763,      (yytype_int16 const   )-729,      (yytype_int16 const   )630,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )578,      (yytype_int16 const   )399,      (yytype_int16 const   )334,      (yytype_int16 const   )384, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )1,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )691,      (yytype_int16 const   )774,      (yytype_int16 const   )2947,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )1498,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )115,      (yytype_int16 const   )651,      (yytype_int16 const   )-729,      (yytype_int16 const   )2966, 
        (yytype_int16 const   )605,      (yytype_int16 const   )85,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )459,      (yytype_int16 const   )748,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )761,      (yytype_int16 const   )3495,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )2925,      (yytype_int16 const   )3807,      (yytype_int16 const   )137, 
        (yytype_int16 const   )765,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )738, 
        (yytype_int16 const   )766,      (yytype_int16 const   )-729,      (yytype_int16 const   )767,      (yytype_int16 const   )115, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )868,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )2947,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3556, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )118,      (yytype_int16 const   )-729,      (yytype_int16 const   )2947, 
        (yytype_int16 const   )630,      (yytype_int16 const   )1209,      (yytype_int16 const   )760,      (yytype_int16 const   )2947, 
        (yytype_int16 const   )630,      (yytype_int16 const   )1209,      (yytype_int16 const   )760,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )790,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )783,      (yytype_int16 const   )691,      (yytype_int16 const   )804, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )773,      (yytype_int16 const   )777,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )691,      (yytype_int16 const   )691, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )780,      (yytype_int16 const   )781,      (yytype_int16 const   )782, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )244,      (yytype_int16 const   )605,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )1734,      (yytype_int16 const   )841,      (yytype_int16 const   )-729,      (yytype_int16 const   )2860, 
        (yytype_int16 const   )1201,      (yytype_int16 const   )1201,      (yytype_int16 const   )3807,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )4052,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )1569,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )4032, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )4032, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )115, 
        (yytype_int16 const   )845,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )1498,      (yytype_int16 const   )-729,      (yytype_int16 const   )34,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )240,      (yytype_int16 const   )-729,      (yytype_int16 const   )343, 
        (yytype_int16 const   )3556,      (yytype_int16 const   )-729,      (yytype_int16 const   )2137,      (yytype_int16 const   )794, 
        (yytype_int16 const   )393,      (yytype_int16 const   )-729,      (yytype_int16 const   )2947,      (yytype_int16 const   )334, 
        (yytype_int16 const   )343,      (yytype_int16 const   )813,      (yytype_int16 const   )821,      (yytype_int16 const   )115, 
        (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )358,      (yytype_int16 const   )346,      (yytype_int16 const   )755, 
        (yytype_int16 const   )834,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )836, 
        (yytype_int16 const   )840,      (yytype_int16 const   )3807,      (yytype_int16 const   )861,      (yytype_int16 const   )846, 
        (yytype_int16 const   )847,      (yytype_int16 const   )3746,      (yytype_int16 const   )325,      (yytype_int16 const   )705, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )862,      (yytype_int16 const   )849, 
        (yytype_int16 const   )2528,      (yytype_int16 const   )1606,      (yytype_int16 const   )352,      (yytype_int16 const   )389, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )822,      (yytype_int16 const   )2791,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )901,      (yytype_int16 const   )3157,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )2628,      (yytype_int16 const   )-729,      (yytype_int16 const   )824,      (yytype_int16 const   )826, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )4032, 
        (yytype_int16 const   )844,      (yytype_int16 const   )-729,      (yytype_int16 const   )4032,      (yytype_int16 const   )98, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )2860,      (yytype_int16 const   )684,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )860,      (yytype_int16 const   )876, 
        (yytype_int16 const   )160,      (yytype_int16 const   )-729,      (yytype_int16 const   )2035,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )352,      (yytype_int16 const   )389,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )2137,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )741,      (yytype_int16 const   )741, 
        (yytype_int16 const   )741,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )605, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )897, 
        (yytype_int16 const   )3626,      (yytype_int16 const   )3807,      (yytype_int16 const   )3807,      (yytype_int16 const   )4113, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )892,      (yytype_int16 const   )3807,      (yytype_int16 const   )899,      (yytype_int16 const   )903, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )3305,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )870,      (yytype_int16 const   )904, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )334,      (yytype_int16 const   )343,      (yytype_int16 const   )905, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )861,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3235,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3626,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )873,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )334,      (yytype_int16 const   )343,      (yytype_int16 const   )1869, 
        (yytype_int16 const   )1869,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )881,      (yytype_int16 const   )884,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )883,      (yytype_int16 const   )3807,      (yytype_int16 const   )957,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )916,      (yytype_int16 const   )887,      (yytype_int16 const   )3807,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )922,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )925,      (yytype_int16 const   )-729,      (yytype_int16 const   )698,      (yytype_int16 const   )927, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )160,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3626,      (yytype_int16 const   )-729,      (yytype_int16 const   )896,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )885,      (yytype_int16 const   )2102,      (yytype_int16 const   )605,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )941,      (yytype_int16 const   )924,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )923,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )908,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )4150,      (yytype_int16 const   )-729,      (yytype_int16 const   )149,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )115,      (yytype_int16 const   )-729,      (yytype_int16 const   )115,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )943,      (yytype_int16 const   )1968,      (yytype_int16 const   )-729,      (yytype_int16 const   )963, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )114,      (yytype_int16 const   )605, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )930,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )3626,      (yytype_int16 const   )-729,      (yytype_int16 const   )49, 
        (yytype_int16 const   )946,      (yytype_int16 const   )384,      (yytype_int16 const   )2,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )967,      (yytype_int16 const   )255, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )950,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )3626,      (yytype_int16 const   )951,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )958,      (yytype_int16 const   )605,      (yytype_int16 const   )157,      (yytype_int16 const   )926, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )630,      (yytype_int16 const   )630, 
        (yytype_int16 const   )2966,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )960, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )929, 
        (yytype_int16 const   )49,      (yytype_int16 const   )964,      (yytype_int16 const   )49,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )124,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )938,      (yytype_int16 const   )-729,      (yytype_int16 const   )3807,      (yytype_int16 const   )937, 
        (yytype_int16 const   )1030,      (yytype_int16 const   )169,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )684,      (yytype_int16 const   )684,      (yytype_int16 const   )-729,      (yytype_int16 const   )2966, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )1834,      (yytype_int16 const   )944,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )983,      (yytype_int16 const   )1037,      (yytype_int16 const   )980,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )58,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )369, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )987,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )3807,      (yytype_int16 const   )-729,      (yytype_int16 const   )487,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )605,      (yytype_int16 const   )366,      (yytype_int16 const   )-729,      (yytype_int16 const   )970, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )605,      (yytype_int16 const   )605,      (yytype_int16 const   )605, 
        (yytype_int16 const   )605,      (yytype_int16 const   )3807,      (yytype_int16 const   )3626,      (yytype_int16 const   )952, 
        (yytype_int16 const   )1043,      (yytype_int16 const   )988,      (yytype_int16 const   )993,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )58,      (yytype_int16 const   )605,      (yytype_int16 const   )246,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )416,      (yytype_int16 const   )426,      (yytype_int16 const   )977,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )2695, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )959,      (yytype_int16 const   )982, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )1498,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )2695,      (yytype_int16 const   )-729};
#line 1552 "c-parse.tab.c"
static yytype_int16 const   yypgoto[262]  = 
#line 1552
  {      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )444,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )193, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )622,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )385,      (yytype_int16 const   )-116,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )241,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-646,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )75,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )54,      (yytype_int16 const   )-644,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-385,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )12,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )344,      (yytype_int16 const   )-729,      (yytype_int16 const   )13, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )53,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )78,      (yytype_int16 const   )-228,      (yytype_int16 const   )-20, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )163,      (yytype_int16 const   )588,      (yytype_int16 const   )-355, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )447,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-211,      (yytype_int16 const   )-729,      (yytype_int16 const   )700, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )851,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )853,      (yytype_int16 const   )670,      (yytype_int16 const   )-227,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )474,      (yytype_int16 const   )-729,      (yytype_int16 const   )-28,      (yytype_int16 const   )-413, 
        (yytype_int16 const   )-641,      (yytype_int16 const   )-4,      (yytype_int16 const   )-1,      (yytype_int16 const   )0, 
        (yytype_int16 const   )8,      (yytype_int16 const   )4,      (yytype_int16 const   )7,      (yytype_int16 const   )11, 
        (yytype_int16 const   )19,      (yytype_int16 const   )-547,      (yytype_int16 const   )-535,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-532,      (yytype_int16 const   )-523,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )14,      (yytype_int16 const   )25,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-275,      (yytype_int16 const   )-111,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-616,      (yytype_int16 const   )224,      (yytype_int16 const   )16,      (yytype_int16 const   )127, 
        (yytype_int16 const   )184,      (yytype_int16 const   )492,      (yytype_int16 const   )-729,      (yytype_int16 const   )-636, 
        (yytype_int16 const   )-89,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-303, 
        (yytype_int16 const   )-405,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )818,      (yytype_int16 const   )856,      (yytype_int16 const   )-180,      (yytype_int16 const   )558, 
        (yytype_int16 const   )22,      (yytype_int16 const   )-729,      (yytype_int16 const   )1067,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )593,      (yytype_int16 const   )-196,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )413,      (yytype_int16 const   )-729,      (yytype_int16 const   )-458,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )600,      (yytype_int16 const   )-729,      (yytype_int16 const   )-341,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )710,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-207,      (yytype_int16 const   )-409,      (yytype_int16 const   )703,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )18,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )546,      (yytype_int16 const   )-493,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )728,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )368, 
        (yytype_int16 const   )373,      (yytype_int16 const   )657,      (yytype_int16 const   )660,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )326,      (yytype_int16 const   )-83,      (yytype_int16 const   )-126, 
        (yytype_int16 const   )110,      (yytype_int16 const   )-729,      (yytype_int16 const   )-226,      (yytype_int16 const   )855, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )683,      (yytype_int16 const   )401, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-280,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )475,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-317,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-687,      (yytype_int16 const   )417, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-598, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-589, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-728,      (yytype_int16 const   )201,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )200,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-394,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729,      (yytype_int16 const   )715, 
        (yytype_int16 const   )10,      (yytype_int16 const   )-45,      (yytype_int16 const   )-729,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )716,      (yytype_int16 const   )-729,      (yytype_int16 const   )549,      (yytype_int16 const   )-729, 
        (yytype_int16 const   )-400,      (yytype_int16 const   )17,      (yytype_int16 const   )652,      (yytype_int16 const   )1104, 
        (yytype_int16 const   )-729,      (yytype_int16 const   )-232};
#line 1588 "c-parse.tab.c"
static yytype_int16 const   yytable[4210]  = 
#line 1588
  {      (yytype_int16 const   )66,      (yytype_int16 const   )208,      (yytype_int16 const   )195,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )319,      (yytype_int16 const   )342,      (yytype_int16 const   )627, 
        (yytype_int16 const   )70,      (yytype_int16 const   )119,      (yytype_int16 const   )426,      (yytype_int16 const   )71, 
        (yytype_int16 const   )69,      (yytype_int16 const   )61,      (yytype_int16 const   )12,      (yytype_int16 const   )72, 
        (yytype_int16 const   )452,      (yytype_int16 const   )526,      (yytype_int16 const   )286,      (yytype_int16 const   )628, 
        (yytype_int16 const   )87,      (yytype_int16 const   )91,      (yytype_int16 const   )629,      (yytype_int16 const   )73, 
        (yytype_int16 const   )94,      (yytype_int16 const   )501,      (yytype_int16 const   )502,      (yytype_int16 const   )343, 
        (yytype_int16 const   )337,      (yytype_int16 const   )474,      (yytype_int16 const   )392,      (yytype_int16 const   )630, 
        (yytype_int16 const   )92,      (yytype_int16 const   )540,      (yytype_int16 const   )77,      (yytype_int16 const   )758, 
        (yytype_int16 const   )348,      (yytype_int16 const   )558,      (yytype_int16 const   )556,      (yytype_int16 const   )557, 
        (yytype_int16 const   )732,      (yytype_int16 const   )543,      (yytype_int16 const   )553,      (yytype_int16 const   )610, 
        (yytype_int16 const   )415,      (yytype_int16 const   )338,      (yytype_int16 const   )122,      (yytype_int16 const   )127, 
        (yytype_int16 const   )131,      (yytype_int16 const   )136,      (yytype_int16 const   )384,      (yytype_int16 const   )593, 
        (yytype_int16 const   )636,      (yytype_int16 const   )762,      (yytype_int16 const   )158,      (yytype_int16 const   )163, 
        (yytype_int16 const   )167,      (yytype_int16 const   )172,      (yytype_int16 const   )742,      (yytype_int16 const   )211, 
        (yytype_int16 const   )936,      (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )212, 
        (yytype_int16 const   )213,      (yytype_int16 const   )214,      (yytype_int16 const   )516,      (yytype_int16 const   )743, 
        (yytype_int16 const   )274,      (yytype_int16 const   )283,      (yytype_int16 const   )264,      (yytype_int16 const   )-376, 
        (yytype_int16 const   )418,      (yytype_int16 const   )269,      (yytype_int16 const   )627,      (yytype_int16 const   )216, 
        (yytype_int16 const   )196,      (yytype_int16 const   )217,      (yytype_int16 const   )198,      (yytype_int16 const   )104, 
        (yytype_int16 const   )105,      (yytype_int16 const   )650,      (yytype_int16 const   )122,      (yytype_int16 const   )127, 
        (yytype_int16 const   )131,      (yytype_int16 const   )136,      (yytype_int16 const   )628,      (yytype_int16 const   )808, 
        (yytype_int16 const   )825,      (yytype_int16 const   )629,      (yytype_int16 const   )337,      (yytype_int16 const   )18, 
        (yytype_int16 const   )87,      (yytype_int16 const   )91,      (yytype_int16 const   )453,      (yytype_int16 const   )298, 
        (yytype_int16 const   )94,      (yytype_int16 const   )107,      (yytype_int16 const   )630,      (yytype_int16 const   )637, 
        (yytype_int16 const   )-376,      (yytype_int16 const   )205,      (yytype_int16 const   )472,      (yytype_int16 const   )827, 
        (yytype_int16 const   )92,      (yytype_int16 const   )854,      (yytype_int16 const   )66,      (yytype_int16 const   )87, 
        (yytype_int16 const   )91,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )94, 
        (yytype_int16 const   )732,      (yytype_int16 const   )937,      (yytype_int16 const   )70,      (yytype_int16 const   )110, 
        (yytype_int16 const   )24,      (yytype_int16 const   )71,      (yytype_int16 const   )69,      (yytype_int16 const   )92, 
        (yytype_int16 const   )654,      (yytype_int16 const   )72,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )225, 
        (yytype_int16 const   )732,      (yytype_int16 const   )73,      (yytype_int16 const   )742,      (yytype_int16 const   )687, 
        (yytype_int16 const   )265,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )742,      (yytype_int16 const   )877,      (yytype_int16 const   )107,      (yytype_int16 const   )743, 
        (yytype_int16 const   )260,      (yytype_int16 const   )606,      (yytype_int16 const   )337,      (yytype_int16 const   )22, 
        (yytype_int16 const   )106,      (yytype_int16 const   )743,      (yytype_int16 const   )458,      (yytype_int16 const   )996, 
        (yytype_int16 const   )24,      (yytype_int16 const   )23,      (yytype_int16 const   )826,      (yytype_int16 const   )501, 
        (yytype_int16 const   )618,      (yytype_int16 const   )634,      (yytype_int16 const   )426,      (yytype_int16 const   )206, 
        (yytype_int16 const   )298,      (yytype_int16 const   )123,      (yytype_int16 const   )128,      (yytype_int16 const   )132, 
        (yytype_int16 const   )137,      (yytype_int16 const   )207,      (yytype_int16 const   )204,      (yytype_int16 const   )271, 
        (yytype_int16 const   )281,      (yytype_int16 const   )159,      (yytype_int16 const   )164,      (yytype_int16 const   )168, 
        (yytype_int16 const   )173,      (yytype_int16 const   )298,      (yytype_int16 const   )24,      (yytype_int16 const   )104, 
        (yytype_int16 const   )105,      (yytype_int16 const   )596,      (yytype_int16 const   )427,      (yytype_int16 const   )970, 
        (yytype_int16 const   )298,      (yytype_int16 const   )868,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )672,      (yytype_int16 const   )222,      (yytype_int16 const   )323,      (yytype_int16 const   )928, 
        (yytype_int16 const   )655,      (yytype_int16 const   )29,      (yytype_int16 const   )461,      (yytype_int16 const   )107, 
        (yytype_int16 const   )934,      (yytype_int16 const   )903,      (yytype_int16 const   )304,      (yytype_int16 const   )335, 
        (yytype_int16 const   )919,      (yytype_int16 const   )123,      (yytype_int16 const   )128,      (yytype_int16 const   )132, 
        (yytype_int16 const   )137,      (yytype_int16 const   )430,      (yytype_int16 const   )327,      (yytype_int16 const   )328, 
        (yytype_int16 const   )952,      (yytype_int16 const   )746,      (yytype_int16 const   )294,      (yytype_int16 const   )298, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )295,      (yytype_int16 const   )296,      (yytype_int16 const   )866, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )977,      (yytype_int16 const   )467,      (yytype_int16 const   )297,      (yytype_int16 const   )462, 
        (yytype_int16 const   )336,      (yytype_int16 const   )29,      (yytype_int16 const   )140,      (yytype_int16 const   )145, 
        (yytype_int16 const   )149,      (yytype_int16 const   )154,      (yytype_int16 const   )971,      (yytype_int16 const   )305, 
        (yytype_int16 const   )306,      (yytype_int16 const   )336,      (yytype_int16 const   )176,      (yytype_int16 const   )181, 
        (yytype_int16 const   )185,      (yytype_int16 const   )190,      (yytype_int16 const   )935,      (yytype_int16 const   )336, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )974,      (yytype_int16 const   )906, 
        (yytype_int16 const   )197,      (yytype_int16 const   )66,      (yytype_int16 const   )611,      (yytype_int16 const   )29, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )386,      (yytype_int16 const   )205, 
        (yytype_int16 const   )313,      (yytype_int16 const   )70,      (yytype_int16 const   )948,      (yytype_int16 const   )336, 
        (yytype_int16 const   )71,      (yytype_int16 const   )69,      (yytype_int16 const   )920,      (yytype_int16 const   )78, 
        (yytype_int16 const   )72,      (yytype_int16 const   )667,      (yytype_int16 const   )140,      (yytype_int16 const   )145, 
        (yytype_int16 const   )149,      (yytype_int16 const   )154,      (yytype_int16 const   )953,      (yytype_int16 const   )925, 
        (yytype_int16 const   )73,      (yytype_int16 const   )752,      (yytype_int16 const   )337,      (yytype_int16 const   )294, 
        (yytype_int16 const   )580,      (yytype_int16 const   )755,      (yytype_int16 const   )295,      (yytype_int16 const   )296, 
        (yytype_int16 const   )436,      (yytype_int16 const   )437,      (yytype_int16 const   )978,      (yytype_int16 const   )347, 
        (yytype_int16 const   )392,      (yytype_int16 const   )248,      (yytype_int16 const   )749,      (yytype_int16 const   )297, 
        (yytype_int16 const   )294,      (yytype_int16 const   )564,      (yytype_int16 const   )263,      (yytype_int16 const   )295, 
        (yytype_int16 const   )296,      (yytype_int16 const   )66,      (yytype_int16 const   )518,      (yytype_int16 const   )294, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )295,      (yytype_int16 const   )296, 
        (yytype_int16 const   )297,      (yytype_int16 const   )70,      (yytype_int16 const   )778,      (yytype_int16 const   )415, 
        (yytype_int16 const   )71,      (yytype_int16 const   )69,      (yytype_int16 const   )518,      (yytype_int16 const   )297, 
        (yytype_int16 const   )72,      (yytype_int16 const   )314,      (yytype_int16 const   )330,      (yytype_int16 const   )834, 
        (yytype_int16 const   )958,      (yytype_int16 const   )332,      (yytype_int16 const   )429,      (yytype_int16 const   )315, 
        (yytype_int16 const   )73,      (yytype_int16 const   )518,      (yytype_int16 const   )706,      (yytype_int16 const   )747, 
        (yytype_int16 const   )1002,      (yytype_int16 const   )761,      (yytype_int16 const   )294,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )341,      (yytype_int16 const   )295,      (yytype_int16 const   )296,      (yytype_int16 const   )1026, 
        (yytype_int16 const   )119,      (yytype_int16 const   )109,      (yytype_int16 const   )427,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )205,      (yytype_int16 const   )266,      (yytype_int16 const   )297,      (yytype_int16 const   )196, 
        (yytype_int16 const   )945,      (yytype_int16 const   )603,      (yytype_int16 const   )520,      (yytype_int16 const   )981, 
        (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )453,      (yytype_int16 const   )453, 
        (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )103, 
        (yytype_int16 const   )66,      (yytype_int16 const   )205,      (yytype_int16 const   )313,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )305,      (yytype_int16 const   )306,      (yytype_int16 const   )400, 
        (yytype_int16 const   )70,      (yytype_int16 const   )707,      (yytype_int16 const   )205,      (yytype_int16 const   )71, 
        (yytype_int16 const   )69,      (yytype_int16 const   )520,      (yytype_int16 const   )66,      (yytype_int16 const   )72, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )336,      (yytype_int16 const   )70,      (yytype_int16 const   )73, 
        (yytype_int16 const   )70,      (yytype_int16 const   )71,      (yytype_int16 const   )69,      (yytype_int16 const   )71, 
        (yytype_int16 const   )69,      (yytype_int16 const   )72,      (yytype_int16 const   )291,      (yytype_int16 const   )72, 
        (yytype_int16 const   )337,      (yytype_int16 const   )760,      (yytype_int16 const   )469,      (yytype_int16 const   )435, 
        (yytype_int16 const   )451,      (yytype_int16 const   )73,      (yytype_int16 const   )267,      (yytype_int16 const   )73, 
        (yytype_int16 const   )455,      (yytype_int16 const   )436,      (yytype_int16 const   )437,      (yytype_int16 const   )539, 
        (yytype_int16 const   )268,      (yytype_int16 const   )269,      (yytype_int16 const   )801,      (yytype_int16 const   )638, 
        (yytype_int16 const   )477,      (yytype_int16 const   )115,      (yytype_int16 const   )478,      (yytype_int16 const   )646, 
        (yytype_int16 const   )647,      (yytype_int16 const   )436,      (yytype_int16 const   )514,      (yytype_int16 const   )314, 
        (yytype_int16 const   )201,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )627, 
        (yytype_int16 const   )627,      (yytype_int16 const   )315,      (yytype_int16 const   )532,      (yytype_int16 const   )533, 
        (yytype_int16 const   )206,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )345,      (yytype_int16 const   )205,      (yytype_int16 const   )207,      (yytype_int16 const   )628, 
        (yytype_int16 const   )628,      (yytype_int16 const   )1001,      (yytype_int16 const   )629,      (yytype_int16 const   )629, 
        (yytype_int16 const   )397,      (yytype_int16 const   )-377,      (yytype_int16 const   )398,      (yytype_int16 const   )788, 
        (yytype_int16 const   )436,      (yytype_int16 const   )437,      (yytype_int16 const   )600,      (yytype_int16 const   )630, 
        (yytype_int16 const   )630,      (yytype_int16 const   )-349,      (yytype_int16 const   )202,      (yytype_int16 const   )200, 
        (yytype_int16 const   )635,      (yytype_int16 const   )66,      (yytype_int16 const   )708,      (yytype_int16 const   )786, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )111,      (yytype_int16 const   )1002, 
        (yytype_int16 const   )413,      (yytype_int16 const   )70,      (yytype_int16 const   )1003,      (yytype_int16 const   )1011, 
        (yytype_int16 const   )71,      (yytype_int16 const   )69,      (yytype_int16 const   )215,      (yytype_int16 const   )196, 
        (yytype_int16 const   )72,      (yytype_int16 const   )835,      (yytype_int16 const   )337,      (yytype_int16 const   )24, 
        (yytype_int16 const   )196,      (yytype_int16 const   )789,      (yytype_int16 const   )429,      (yytype_int16 const   )601, 
        (yytype_int16 const   )73,      (yytype_int16 const   )812,      (yytype_int16 const   )337,      (yytype_int16 const   )337, 
        (yytype_int16 const   )1004,      (yytype_int16 const   )-373,      (yytype_int16 const   )818,      (yytype_int16 const   )434, 
        (yytype_int16 const   )787,      (yytype_int16 const   )499,      (yytype_int16 const   )-350,      (yytype_int16 const   )280, 
        (yytype_int16 const   )503,      (yytype_int16 const   )838,      (yytype_int16 const   )305,      (yytype_int16 const   )306, 
        (yytype_int16 const   )1012,      (yytype_int16 const   )268,      (yytype_int16 const   )269,      (yytype_int16 const   )-377, 
        (yytype_int16 const   )771,      (yytype_int16 const   )413,      (yytype_int16 const   )203,      (yytype_int16 const   )772, 
        (yytype_int16 const   )226,      (yytype_int16 const   )-377,      (yytype_int16 const   )-377,      (yytype_int16 const   )507, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )1002,      (yytype_int16 const   )227, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )-373,      (yytype_int16 const   )424, 
        (yytype_int16 const   )386,      (yytype_int16 const   )1027,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )1002,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )408, 
        (yytype_int16 const   )-58,      (yytype_int16 const   )504,      (yytype_int16 const   )802,      (yytype_int16 const   )1028, 
        (yytype_int16 const   )505,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )633,      (yytype_int16 const   )220,      (yytype_int16 const   )607,      (yytype_int16 const   )287, 
        (yytype_int16 const   )420,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )232, 
        (yytype_int16 const   )233,      (yytype_int16 const   )288,      (yytype_int16 const   )269,      (yytype_int16 const   )431, 
        (yytype_int16 const   )29,      (yytype_int16 const   )23,      (yytype_int16 const   )345,      (yytype_int16 const   )24, 
        (yytype_int16 const   )82,      (yytype_int16 const   )345,      (yytype_int16 const   )519,      (yytype_int16 const   )345, 
        (yytype_int16 const   )218,      (yytype_int16 const   )282,      (yytype_int16 const   )219,      (yytype_int16 const   )481, 
        (yytype_int16 const   )555,      (yytype_int16 const   )289,      (yytype_int16 const   )141,      (yytype_int16 const   )146, 
        (yytype_int16 const   )150,      (yytype_int16 const   )155,      (yytype_int16 const   )519,      (yytype_int16 const   )262, 
        (yytype_int16 const   )351,      (yytype_int16 const   )384,      (yytype_int16 const   )177,      (yytype_int16 const   )182, 
        (yytype_int16 const   )186,      (yytype_int16 const   )191,      (yytype_int16 const   )447,      (yytype_int16 const   )292, 
        (yytype_int16 const   )569,      (yytype_int16 const   )519,      (yytype_int16 const   )332,      (yytype_int16 const   )613, 
        (yytype_int16 const   )332,      (yytype_int16 const   )603,      (yytype_int16 const   )614,      (yytype_int16 const   )104, 
        (yytype_int16 const   )105,      (yytype_int16 const   )302,      (yytype_int16 const   )623,      (yytype_int16 const   )425, 
        (yytype_int16 const   )453,      (yytype_int16 const   )624,      (yytype_int16 const   )112,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )662,      (yytype_int16 const   )625,      (yytype_int16 const   )851, 
        (yytype_int16 const   )663,      (yytype_int16 const   )626,      (yytype_int16 const   )141,      (yytype_int16 const   )146, 
        (yytype_int16 const   )150,      (yytype_int16 const   )155,      (yytype_int16 const   )331,      (yytype_int16 const   )900, 
        (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )902,      (yytype_int16 const   )66, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )293,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )70, 
        (yytype_int16 const   )644,      (yytype_int16 const   )-471,      (yytype_int16 const   )71,      (yytype_int16 const   )69, 
        (yytype_int16 const   )29,      (yytype_int16 const   )1008,      (yytype_int16 const   )72,      (yytype_int16 const   )400, 
        (yytype_int16 const   )1009,      (yytype_int16 const   )303,      (yytype_int16 const   )400,      (yytype_int16 const   )645, 
        (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )73,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )324,      (yytype_int16 const   )699, 
        (yytype_int16 const   )700,      (yytype_int16 const   )339,      (yytype_int16 const   )763,      (yytype_int16 const   )689, 
        (yytype_int16 const   )691,      (yytype_int16 const   )651,      (yytype_int16 const   )870,      (yytype_int16 const   )115, 
        (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )-12,      (yytype_int16 const   )670, 
        (yytype_int16 const   )95,      (yytype_int16 const   )-12,      (yytype_int16 const   )22,      (yytype_int16 const   )-12, 
        (yytype_int16 const   )1014,      (yytype_int16 const   )623,      (yytype_int16 const   )1016,      (yytype_int16 const   )1017, 
        (yytype_int16 const   )624,      (yytype_int16 const   )616,      (yytype_int16 const   )-12,      (yytype_int16 const   )617, 
        (yytype_int16 const   )96,      (yytype_int16 const   )625,      (yytype_int16 const   )670,      (yytype_int16 const   )-12, 
        (yytype_int16 const   )626,      (yytype_int16 const   )97,      (yytype_int16 const   )1,      (yytype_int16 const   )2, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )122, 
        (yytype_int16 const   )127,      (yytype_int16 const   )305,      (yytype_int16 const   )306,      (yytype_int16 const   )158, 
        (yytype_int16 const   )163,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )24,      (yytype_int16 const   )340,      (yytype_int16 const   )1018,      (yytype_int16 const   )979, 
        (yytype_int16 const   )980,      (yytype_int16 const   )349,      (yytype_int16 const   )652,      (yytype_int16 const   )22, 
        (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )-10, 
        (yytype_int16 const   )764,      (yytype_int16 const   )23,      (yytype_int16 const   )-10,      (yytype_int16 const   )-10, 
        (yytype_int16 const   )-10,      (yytype_int16 const   )849,      (yytype_int16 const   )850,      (yytype_int16 const   )350, 
        (yytype_int16 const   )779,      (yytype_int16 const   )780,      (yytype_int16 const   )730,      (yytype_int16 const   )-10, 
        (yytype_int16 const   )-377,      (yytype_int16 const   )744,      (yytype_int16 const   )383,      (yytype_int16 const   )385, 
        (yytype_int16 const   )-10,      (yytype_int16 const   )393,      (yytype_int16 const   )-377,      (yytype_int16 const   )-377, 
        (yytype_int16 const   )394,      (yytype_int16 const   )731,      (yytype_int16 const   )125,      (yytype_int16 const   )129, 
        (yytype_int16 const   )134,      (yytype_int16 const   )138,      (yytype_int16 const   )143,      (yytype_int16 const   )147, 
        (yytype_int16 const   )152,      (yytype_int16 const   )156,      (yytype_int16 const   )161,      (yytype_int16 const   )165, 
        (yytype_int16 const   )170,      (yytype_int16 const   )174,      (yytype_int16 const   )179,      (yytype_int16 const   )183, 
        (yytype_int16 const   )188,      (yytype_int16 const   )192,      (yytype_int16 const   )116,      (yytype_int16 const   )116, 
        (yytype_int16 const   )355,      (yytype_int16 const   )357,      (yytype_int16 const   )813,      (yytype_int16 const   )814, 
        (yytype_int16 const   )815,      (yytype_int16 const   )910,      (yytype_int16 const   )423,      (yytype_int16 const   )767, 
        (yytype_int16 const   )768,      (yytype_int16 const   )433,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )644,      (yytype_int16 const   )18,      (yytype_int16 const   )337,      (yytype_int16 const   )955, 
        (yytype_int16 const   )956,      (yytype_int16 const   )29,      (yytype_int16 const   )440,      (yytype_int16 const   )769, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )444,      (yytype_int16 const   )645, 
        (yytype_int16 const   )607,      (yytype_int16 const   )871,      (yytype_int16 const   )446,      (yytype_int16 const   )449, 
        (yytype_int16 const   )304,      (yytype_int16 const   )927,      (yytype_int16 const   )450,      (yytype_int16 const   )337, 
        (yytype_int16 const   )341,      (yytype_int16 const   )463,      (yytype_int16 const   )341,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )400,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )841,      (yytype_int16 const   )842,      (yytype_int16 const   )730,      (yytype_int16 const   )454, 
        (yytype_int16 const   )456,      (yytype_int16 const   )744,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )464,      (yytype_int16 const   )123,      (yytype_int16 const   )128, 
        (yytype_int16 const   )472,      (yytype_int16 const   )731,      (yytype_int16 const   )159,      (yytype_int16 const   )164, 
        (yytype_int16 const   )-137,      (yytype_int16 const   )470,      (yytype_int16 const   )730,      (yytype_int16 const   )506, 
        (yytype_int16 const   )510,      (yytype_int16 const   )744,      (yytype_int16 const   )23,      (yytype_int16 const   )471, 
        (yytype_int16 const   )475,      (yytype_int16 const   )301,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )731,      (yytype_int16 const   )511,      (yytype_int16 const   )24, 
        (yytype_int16 const   )521,      (yytype_int16 const   )512,      (yytype_int16 const   )24,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )530,      (yytype_int16 const   )840, 
        (yytype_int16 const   )768,      (yytype_int16 const   )676,      (yytype_int16 const   )542,      (yytype_int16 const   )873, 
        (yytype_int16 const   )785,      (yytype_int16 const   )22,      (yytype_int16 const   )560,      (yytype_int16 const   )845, 
        (yytype_int16 const   )768,      (yytype_int16 const   )534,      (yytype_int16 const   )537,      (yytype_int16 const   )769, 
        (yytype_int16 const   )538,      (yytype_int16 const   )336,      (yytype_int16 const   )572,      (yytype_int16 const   )-138, 
        (yytype_int16 const   )566,      (yytype_int16 const   )576,      (yytype_int16 const   )-138,      (yytype_int16 const   )769, 
        (yytype_int16 const   )341,      (yytype_int16 const   )305,      (yytype_int16 const   )306,      (yytype_int16 const   )578, 
        (yytype_int16 const   )305,      (yytype_int16 const   )306,      (yytype_int16 const   )341,      (yytype_int16 const   )581, 
        (yytype_int16 const   )582,      (yytype_int16 const   )140,      (yytype_int16 const   )145,      (yytype_int16 const   )764, 
        (yytype_int16 const   )341,      (yytype_int16 const   )176,      (yytype_int16 const   )181,      (yytype_int16 const   )583, 
        (yytype_int16 const   )341,      (yytype_int16 const   )-138,      (yytype_int16 const   )584,      (yytype_int16 const   )-138, 
        (yytype_int16 const   )-138,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )585, 
        (yytype_int16 const   )586,      (yytype_int16 const   )615,      (yytype_int16 const   )301,      (yytype_int16 const   )588, 
        (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )597,      (yytype_int16 const   )598, 
        (yytype_int16 const   )417,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )400, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )-138,      (yytype_int16 const   )301, 
        (yytype_int16 const   )29,      (yytype_int16 const   )422,      (yytype_int16 const   )640,      (yytype_int16 const   )29, 
        (yytype_int16 const   )599,      (yytype_int16 const   )612,      (yytype_int16 const   )301,      (yytype_int16 const   )205, 
        (yytype_int16 const   )313,      (yytype_int16 const   )664,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375, 
        (yytype_int16 const   )376,      (yytype_int16 const   )768,      (yytype_int16 const   )768,      (yytype_int16 const   )690, 
        (yytype_int16 const   )666,      (yytype_int16 const   )301,      (yytype_int16 const   )907,      (yytype_int16 const   )674, 
        (yytype_int16 const   )678,      (yytype_int16 const   )341,      (yytype_int16 const   )679,      (yytype_int16 const   )301, 
        (yytype_int16 const   )769,      (yytype_int16 const   )769,      (yytype_int16 const   )341,      (yytype_int16 const   )544, 
        (yytype_int16 const   )694,      (yytype_int16 const   )301,      (yytype_int16 const   )697,      (yytype_int16 const   )698, 
        (yytype_int16 const   )654,      (yytype_int16 const   )279,      (yytype_int16 const   )279,      (yytype_int16 const   )703, 
        (yytype_int16 const   )704,      (yytype_int16 const   )781,      (yytype_int16 const   )279,      (yytype_int16 const   )705, 
        (yytype_int16 const   )800,      (yytype_int16 const   )635,      (yytype_int16 const   )124,      (yytype_int16 const   )602, 
        (yytype_int16 const   )133,      (yytype_int16 const   )782,      (yytype_int16 const   )142,      (yytype_int16 const   )929, 
        (yytype_int16 const   )151,      (yytype_int16 const   )770,      (yytype_int16 const   )160,      (yytype_int16 const   )768, 
        (yytype_int16 const   )169,      (yytype_int16 const   )790,      (yytype_int16 const   )178,      (yytype_int16 const   )793, 
        (yytype_int16 const   )187,      (yytype_int16 const   )314,      (yytype_int16 const   )341,      (yytype_int16 const   )794, 
        (yytype_int16 const   )796,      (yytype_int16 const   )806,      (yytype_int16 const   )769,      (yytype_int16 const   )315, 
        (yytype_int16 const   )377,      (yytype_int16 const   )378,      (yytype_int16 const   )379,      (yytype_int16 const   )380, 
        (yytype_int16 const   )381,      (yytype_int16 const   )382,      (yytype_int16 const   )390,      (yytype_int16 const   )797, 
        (yytype_int16 const   )798,      (yytype_int16 const   )951,      (yytype_int16 const   )807,      (yytype_int16 const   )768, 
        (yytype_int16 const   )820,      (yytype_int16 const   )816,      (yytype_int16 const   )124,      (yytype_int16 const   )828, 
        (yytype_int16 const   )133,      (yytype_int16 const   )553,      (yytype_int16 const   )142,      (yytype_int16 const   )829, 
        (yytype_int16 const   )151,      (yytype_int16 const   )836,      (yytype_int16 const   )769,      (yytype_int16 const   )370, 
        (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374, 
        (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )623,      (yytype_int16 const   )623, 
        (yytype_int16 const   )66,      (yytype_int16 const   )624,      (yytype_int16 const   )624,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )837,      (yytype_int16 const   )625,      (yytype_int16 const   )625, 
        (yytype_int16 const   )70,      (yytype_int16 const   )626,      (yytype_int16 const   )626,      (yytype_int16 const   )71, 
        (yytype_int16 const   )69,      (yytype_int16 const   )852,      (yytype_int16 const   )341,      (yytype_int16 const   )72, 
        (yytype_int16 const   )855,      (yytype_int16 const   )857,      (yytype_int16 const   )960,      (yytype_int16 const   )279, 
        (yytype_int16 const   )853,      (yytype_int16 const   )860,      (yytype_int16 const   )1000,      (yytype_int16 const   )73, 
        (yytype_int16 const   )861,      (yytype_int16 const   )401,      (yytype_int16 const   )863,      (yytype_int16 const   )66, 
        (yytype_int16 const   )862,      (yytype_int16 const   )867,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )879,      (yytype_int16 const   )788,      (yytype_int16 const   )874,      (yytype_int16 const   )70, 
        (yytype_int16 const   )1010,      (yytype_int16 const   )893,      (yytype_int16 const   )71,      (yytype_int16 const   )69, 
        (yytype_int16 const   )889,      (yytype_int16 const   )301,      (yytype_int16 const   )72,      (yytype_int16 const   )890, 
        (yytype_int16 const   )891,      (yytype_int16 const   )894,      (yytype_int16 const   )989,      (yytype_int16 const   )768, 
        (yytype_int16 const   )895,      (yytype_int16 const   )878,      (yytype_int16 const   )73,      (yytype_int16 const   )897, 
        (yytype_int16 const   )1000,      (yytype_int16 const   )1025,      (yytype_int16 const   )899,      (yytype_int16 const   )341, 
        (yytype_int16 const   )901,      (yytype_int16 const   )904,      (yytype_int16 const   )769,      (yytype_int16 const   )-204, 
        (yytype_int16 const   )-204,      (yytype_int16 const   )-204,      (yytype_int16 const   )-204,      (yytype_int16 const   )-204, 
        (yytype_int16 const   )-204,      (yytype_int16 const   )908,      (yytype_int16 const   )911,      (yytype_int16 const   )912, 
        (yytype_int16 const   )301,      (yytype_int16 const   )915,      (yytype_int16 const   )301,      (yytype_int16 const   )341, 
        (yytype_int16 const   )923,      (yytype_int16 const   )-79,      (yytype_int16 const   )931,      (yytype_int16 const   )941, 
        (yytype_int16 const   )892,      (yytype_int16 const   )944,      (yytype_int16 const   )946,      (yytype_int16 const   )66, 
        (yytype_int16 const   )949,      (yytype_int16 const   )950,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )954,      (yytype_int16 const   )300,      (yytype_int16 const   )898,      (yytype_int16 const   )70, 
        (yytype_int16 const   )961,      (yytype_int16 const   )964,      (yytype_int16 const   )71,      (yytype_int16 const   )69, 
        (yytype_int16 const   )66,      (yytype_int16 const   )966,      (yytype_int16 const   )72,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )972,      (yytype_int16 const   )975,      (yytype_int16 const   )468, 
        (yytype_int16 const   )70,      (yytype_int16 const   )976,      (yytype_int16 const   )73,      (yytype_int16 const   )71, 
        (yytype_int16 const   )69,      (yytype_int16 const   )991,      (yytype_int16 const   )992,      (yytype_int16 const   )72, 
        (yytype_int16 const   )993,      (yytype_int16 const   )995,      (yytype_int16 const   )476,      (yytype_int16 const   )1005, 
        (yytype_int16 const   )1013,      (yytype_int16 const   )1020,      (yytype_int16 const   )1021,      (yytype_int16 const   )73, 
        (yytype_int16 const   )1023,      (yytype_int16 const   )1022,      (yytype_int16 const   )479,      (yytype_int16 const   )480, 
        (yytype_int16 const   )1035,      (yytype_int16 const   )483,      (yytype_int16 const   )484,      (yytype_int16 const   )485, 
        (yytype_int16 const   )486,      (yytype_int16 const   )487,      (yytype_int16 const   )488,      (yytype_int16 const   )489, 
        (yytype_int16 const   )490,      (yytype_int16 const   )491,      (yytype_int16 const   )492,      (yytype_int16 const   )493, 
        (yytype_int16 const   )494,      (yytype_int16 const   )495,      (yytype_int16 const   )496,      (yytype_int16 const   )497, 
        (yytype_int16 const   )498,      (yytype_int16 const   )1029,      (yytype_int16 const   )909,      (yytype_int16 const   )855, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )693,      (yytype_int16 const   )568,      (yytype_int16 const   )777, 
        (yytype_int16 const   )341,      (yytype_int16 const   )888,      (yytype_int16 const   )409,      (yytype_int16 const   )1024, 
        (yytype_int16 const   )414,      (yytype_int16 const   )416,      (yytype_int16 const   )1037,      (yytype_int16 const   )279, 
        (yytype_int16 const   )279,      (yytype_int16 const   )1015,      (yytype_int16 const   )590,      (yytype_int16 const   )688, 
        (yytype_int16 const   )120,      (yytype_int16 const   )587,      (yytype_int16 const   )508,      (yytype_int16 const   )421, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )352,      (yytype_int16 const   )279, 
        (yytype_int16 const   )353,      (yytype_int16 const   )765,      (yytype_int16 const   )432,      (yytype_int16 const   )401, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )517, 
        (yytype_int16 const   )595,      (yytype_int16 const   )963,      (yytype_int16 const   )279,      (yytype_int16 const   )279, 
        (yytype_int16 const   )515,      (yytype_int16 const   )141,      (yytype_int16 const   )146,      (yytype_int16 const   )649, 
        (yytype_int16 const   )831,      (yytype_int16 const   )177,      (yytype_int16 const   )182,      (yytype_int16 const   )573, 
        (yytype_int16 const   )571,      (yytype_int16 const   )855,      (yytype_int16 const   )24,      (yytype_int16 const   )445, 
        (yytype_int16 const   )833,      (yytype_int16 const   )809,      (yytype_int16 const   )301,      (yytype_int16 const   )419, 
        (yytype_int16 const   )745,      (yytype_int16 const   )448,      (yytype_int16 const   )126,      (yytype_int16 const   )130, 
        (yytype_int16 const   )135,      (yytype_int16 const   )139,      (yytype_int16 const   )144,      (yytype_int16 const   )148, 
        (yytype_int16 const   )153,      (yytype_int16 const   )157,      (yytype_int16 const   )162,      (yytype_int16 const   )166, 
        (yytype_int16 const   )171,      (yytype_int16 const   )175,      (yytype_int16 const   )180,      (yytype_int16 const   )184, 
        (yytype_int16 const   )189,      (yytype_int16 const   )193,      (yytype_int16 const   )124,      (yytype_int16 const   )819, 
        (yytype_int16 const   )133,      (yytype_int16 const   )965,      (yytype_int16 const   )967,      (yytype_int16 const   )1007, 
        (yytype_int16 const   )390,      (yytype_int16 const   )535,      (yytype_int16 const   )551,      (yytype_int16 const   )0, 
        (yytype_int16 const   )552,      (yytype_int16 const   )301,      (yytype_int16 const   )681,      (yytype_int16 const   )570, 
        (yytype_int16 const   )0,      (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )301,      (yytype_int16 const   )126,      (yytype_int16 const   )130, 
        (yytype_int16 const   )135,      (yytype_int16 const   )139,      (yytype_int16 const   )144,      (yytype_int16 const   )148, 
        (yytype_int16 const   )153,      (yytype_int16 const   )157,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367, 
        (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371, 
        (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375, 
        (yytype_int16 const   )376,      (yytype_int16 const   )401,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )401,      (yytype_int16 const   )0,      (yytype_int16 const   )401,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )531,      (yytype_int16 const   )24,      (yytype_int16 const   )360, 
        (yytype_int16 const   )0,      (yytype_int16 const   )361,      (yytype_int16 const   )362,      (yytype_int16 const   )363, 
        (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367, 
        (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371, 
        (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375, 
        (yytype_int16 const   )376,      (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )559,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )125, 
        (yytype_int16 const   )129,      (yytype_int16 const   )143,      (yytype_int16 const   )147,      (yytype_int16 const   )161, 
        (yytype_int16 const   )165,      (yytype_int16 const   )179,      (yytype_int16 const   )183,      (yytype_int16 const   )660, 
        (yytype_int16 const   )661,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )665, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )401,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )671,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )675,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )80,      (yytype_int16 const   )684, 
        (yytype_int16 const   )-230,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )301,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )81, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )82, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )401, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )391,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )751,      (yytype_int16 const   )0,      (yytype_int16 const   )-230,      (yytype_int16 const   )0, 
        (yytype_int16 const   )754,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-230,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )83,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )648,      (yytype_int16 const   )0, 
        (yytype_int16 const   )684,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )126,      (yytype_int16 const   )130, 
        (yytype_int16 const   )135,      (yytype_int16 const   )139,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )84,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )795,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )0,      (yytype_int16 const   )673,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )677,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )680,      (yytype_int16 const   )367,      (yytype_int16 const   )368, 
        (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )344,      (yytype_int16 const   )0,      (yytype_int16 const   )226,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )0,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )401,      (yytype_int16 const   )301,      (yytype_int16 const   )0, 
        (yytype_int16 const   )301,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )229, 
        (yytype_int16 const   )24,      (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )124, 
        (yytype_int16 const   )0,      (yytype_int16 const   )142,      (yytype_int16 const   )0,      (yytype_int16 const   )160, 
        (yytype_int16 const   )234,      (yytype_int16 const   )178,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )750,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )753,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )756,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )-202, 
        (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368, 
        (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )0,      (yytype_int16 const   )783,      (yytype_int16 const   )784,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )358,      (yytype_int16 const   )359, 
        (yytype_int16 const   )360,      (yytype_int16 const   )29,      (yytype_int16 const   )361,      (yytype_int16 const   )362, 
        (yytype_int16 const   )363,      (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366, 
        (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370, 
        (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374, 
        (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )896,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )830,      (yytype_int16 const   )524,      (yytype_int16 const   )0, 
        (yytype_int16 const   )832,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )525,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )846,      (yytype_int16 const   )847,      (yytype_int16 const   )848,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )811, 
        (yytype_int16 const   )391,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )880,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )-603,      (yytype_int16 const   )29, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-226, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )-226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-226,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )921,      (yytype_int16 const   )0, 
        (yytype_int16 const   )922,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )1034, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )126, 
        (yytype_int16 const   )130,      (yytype_int16 const   )144,      (yytype_int16 const   )148,      (yytype_int16 const   )162, 
        (yytype_int16 const   )166,      (yytype_int16 const   )180,      (yytype_int16 const   )184,      (yytype_int16 const   )710, 
        (yytype_int16 const   )1034,      (yytype_int16 const   )396,      (yytype_int16 const   )711,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0, 
        (yytype_int16 const   )228,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )712,      (yytype_int16 const   )0,      (yytype_int16 const   )713,      (yytype_int16 const   )714, 
        (yytype_int16 const   )715,      (yytype_int16 const   )716,      (yytype_int16 const   )717,      (yytype_int16 const   )718, 
        (yytype_int16 const   )719,      (yytype_int16 const   )720,      (yytype_int16 const   )721,      (yytype_int16 const   )722, 
        (yytype_int16 const   )723,      (yytype_int16 const   )23,      (yytype_int16 const   )229,      (yytype_int16 const   )24, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )472,      (yytype_int16 const   )724, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )725,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )804, 
        (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )80, 
        (yytype_int16 const   )29,      (yytype_int16 const   )104,      (yytype_int16 const   )711,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )80,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )83, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )982, 
        (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369, 
        (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373, 
        (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )84, 
        (yytype_int16 const   )0,      (yytype_int16 const   )983,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )29,      (yytype_int16 const   )881,      (yytype_int16 const   )83,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )882,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )84,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )80,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )524,      (yytype_int16 const   )24,      (yytype_int16 const   )544,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )525,      (yytype_int16 const   )0,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0, 
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )80,      (yytype_int16 const   )83,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )882,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )84,      (yytype_int16 const   )23,      (yytype_int16 const   )924, 
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )362, 
        (yytype_int16 const   )363,      (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366, 
        (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370, 
        (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374, 
        (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-603,      (yytype_int16 const   )29,      (yytype_int16 const   )0,      (yytype_int16 const   )80, 
        (yytype_int16 const   )83,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )84,      (yytype_int16 const   )23,      (yytype_int16 const   )839,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )80,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )83, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )882,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )84, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )29,      (yytype_int16 const   )13,      (yytype_int16 const   )83,      (yytype_int16 const   )0, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )84,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )549,      (yytype_int16 const   )29, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )424,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )22,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )65,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )0,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )82,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )363,      (yytype_int16 const   )364, 
        (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368, 
        (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )395,      (yytype_int16 const   )0,      (yytype_int16 const   )396, 
        (yytype_int16 const   )105,      (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )397,      (yytype_int16 const   )241, 
        (yytype_int16 const   )398,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )399,      (yytype_int16 const   )395,      (yytype_int16 const   )0,      (yytype_int16 const   )396, 
        (yytype_int16 const   )105,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-468, 
        (yytype_int16 const   )229,      (yytype_int16 const   )-468,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )397,      (yytype_int16 const   )241, 
        (yytype_int16 const   )398,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )399,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )396, 
        (yytype_int16 const   )711,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )-412,      (yytype_int16 const   )228,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )712,      (yytype_int16 const   )0, 
        (yytype_int16 const   )713,      (yytype_int16 const   )714,      (yytype_int16 const   )715,      (yytype_int16 const   )716, 
        (yytype_int16 const   )717,      (yytype_int16 const   )718,      (yytype_int16 const   )719,      (yytype_int16 const   )720, 
        (yytype_int16 const   )721,      (yytype_int16 const   )722,      (yytype_int16 const   )723,      (yytype_int16 const   )23, 
        (yytype_int16 const   )229,      (yytype_int16 const   )24,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )472,      (yytype_int16 const   )724,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )725,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )226, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )229,      (yytype_int16 const   )24,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )226,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )0,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )229, 
        (yytype_int16 const   )24,      (yytype_int16 const   )82,      (yytype_int16 const   )29,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )811,      (yytype_int16 const   )0,      (yytype_int16 const   )396,      (yytype_int16 const   )105, 
        (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )712,      (yytype_int16 const   )0,      (yytype_int16 const   )713, 
        (yytype_int16 const   )714,      (yytype_int16 const   )715,      (yytype_int16 const   )716,      (yytype_int16 const   )717, 
        (yytype_int16 const   )817,      (yytype_int16 const   )719,      (yytype_int16 const   )720,      (yytype_int16 const   )721, 
        (yytype_int16 const   )722,      (yytype_int16 const   )723,      (yytype_int16 const   )0,      (yytype_int16 const   )229, 
        (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )472, 
        (yytype_int16 const   )724,      (yytype_int16 const   )395,      (yytype_int16 const   )0,      (yytype_int16 const   )396, 
        (yytype_int16 const   )105,      (yytype_int16 const   )725,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-519,      (yytype_int16 const   )0, 
        (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )397,      (yytype_int16 const   )241, 
        (yytype_int16 const   )398,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )399,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )669,      (yytype_int16 const   )0, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )-412, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )22,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0, 
        (yytype_int16 const   )24,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )29, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )226,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )29,      (yytype_int16 const   )0,      (yytype_int16 const   )227, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )29,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82, 
        (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232, 
        (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0, 
        (yytype_int16 const   )241,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242, 
        (yytype_int16 const   )243,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )591, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245, 
        (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )358,      (yytype_int16 const   )359, 
        (yytype_int16 const   )360,      (yytype_int16 const   )412,      (yytype_int16 const   )361,      (yytype_int16 const   )362, 
        (yytype_int16 const   )363,      (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366, 
        (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370, 
        (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374, 
        (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )821,      (yytype_int16 const   )0, 
        (yytype_int16 const   )396,      (yytype_int16 const   )105,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )712, 
        (yytype_int16 const   )0,      (yytype_int16 const   )713,      (yytype_int16 const   )714,      (yytype_int16 const   )715, 
        (yytype_int16 const   )716,      (yytype_int16 const   )717,      (yytype_int16 const   )817,      (yytype_int16 const   )719, 
        (yytype_int16 const   )720,      (yytype_int16 const   )721,      (yytype_int16 const   )722,      (yytype_int16 const   )723, 
        (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82, 
        (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232, 
        (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )592,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0, 
        (yytype_int16 const   )241,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242, 
        (yytype_int16 const   )243,      (yytype_int16 const   )472,      (yytype_int16 const   )724,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )725, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )875,      (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245, 
        (yytype_int16 const   )246,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )864,      (yytype_int16 const   )0, 
        (yytype_int16 const   )226,      (yytype_int16 const   )-554,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228, 
        (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )-554,      (yytype_int16 const   )712, 
        (yytype_int16 const   )0,      (yytype_int16 const   )713,      (yytype_int16 const   )714,      (yytype_int16 const   )715, 
        (yytype_int16 const   )716,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )719, 
        (yytype_int16 const   )720,      (yytype_int16 const   )721,      (yytype_int16 const   )722,      (yytype_int16 const   )723, 
        (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82, 
        (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232, 
        (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )395, 
        (yytype_int16 const   )241,      (yytype_int16 const   )226,      (yytype_int16 const   )0,      (yytype_int16 const   )242, 
        (yytype_int16 const   )243,      (yytype_int16 const   )472,      (yytype_int16 const   )724,      (yytype_int16 const   )0, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )725, 
        (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245, 
        (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )-425,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )-425,      (yytype_int16 const   )241,      (yytype_int16 const   )-425,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )399,      (yytype_int16 const   )344, 
        (yytype_int16 const   )0,      (yytype_int16 const   )226,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0, 
        (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )395,      (yytype_int16 const   )241,      (yytype_int16 const   )226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )-202,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229, 
        (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )682,      (yytype_int16 const   )241,      (yytype_int16 const   )226, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )399, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )683,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )396,      (yytype_int16 const   )105,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0, 
        (yytype_int16 const   )228,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )712,      (yytype_int16 const   )0,      (yytype_int16 const   )713,      (yytype_int16 const   )714, 
        (yytype_int16 const   )715,      (yytype_int16 const   )716,      (yytype_int16 const   )717,      (yytype_int16 const   )817, 
        (yytype_int16 const   )719,      (yytype_int16 const   )720,      (yytype_int16 const   )721,      (yytype_int16 const   )722, 
        (yytype_int16 const   )723,      (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )472,      (yytype_int16 const   )724, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )725,      (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229, 
        (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )226,      (yytype_int16 const   )241,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )579, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0, 
        (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )226,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )0,      (yytype_int16 const   )799, 
        (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229, 
        (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237, 
        (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239, 
        (yytype_int16 const   )240,      (yytype_int16 const   )226,      (yytype_int16 const   )241,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )0, 
        (yytype_int16 const   )227,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0, 
        (yytype_int16 const   )228,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240, 
        (yytype_int16 const   )226,      (yytype_int16 const   )354,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )242,      (yytype_int16 const   )243,      (yytype_int16 const   )0,      (yytype_int16 const   )227, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244, 
        (yytype_int16 const   )245,      (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82, 
        (yytype_int16 const   )0,      (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232, 
        (yytype_int16 const   )233,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )236,      (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )589, 
        (yytype_int16 const   )356,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242, 
        (yytype_int16 const   )243,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )113, 
        (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )228,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245, 
        (yytype_int16 const   )246,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )229,      (yytype_int16 const   )0,      (yytype_int16 const   )82,      (yytype_int16 const   )0, 
        (yytype_int16 const   )230,      (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )234,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )0,      (yytype_int16 const   )241, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )246, 
        (yytype_int16 const   )358,      (yytype_int16 const   )359,      (yytype_int16 const   )360,      (yytype_int16 const   )0, 
        (yytype_int16 const   )361,      (yytype_int16 const   )362,      (yytype_int16 const   )363,      (yytype_int16 const   )364, 
        (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368, 
        (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )358,      (yytype_int16 const   )359,      (yytype_int16 const   )360,      (yytype_int16 const   )0, 
        (yytype_int16 const   )361,      (yytype_int16 const   )362,      (yytype_int16 const   )363,      (yytype_int16 const   )364, 
        (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368, 
        (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )858,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )358, 
        (yytype_int16 const   )359,      (yytype_int16 const   )360,      (yytype_int16 const   )29,      (yytype_int16 const   )361, 
        (yytype_int16 const   )362,      (yytype_int16 const   )363,      (yytype_int16 const   )364,      (yytype_int16 const   )365, 
        (yytype_int16 const   )366,      (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369, 
        (yytype_int16 const   )370,      (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373, 
        (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376,      (yytype_int16 const   )0, 
        (yytype_int16 const   )748,      (yytype_int16 const   )358,      (yytype_int16 const   )359,      (yytype_int16 const   )360, 
        (yytype_int16 const   )859,      (yytype_int16 const   )361,      (yytype_int16 const   )362,      (yytype_int16 const   )363, 
        (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367, 
        (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371, 
        (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375, 
        (yytype_int16 const   )376,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )575,      (yytype_int16 const   )358,      (yytype_int16 const   )359, 
        (yytype_int16 const   )360,      (yytype_int16 const   )918,      (yytype_int16 const   )361,      (yytype_int16 const   )362, 
        (yytype_int16 const   )363,      (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366, 
        (yytype_int16 const   )367,      (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370, 
        (yytype_int16 const   )371,      (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374, 
        (yytype_int16 const   )375,      (yytype_int16 const   )376};
#line 2013 "c-parse.tab.c"
static yytype_int16 const   yycheck[4210]  = 
#line 2013
  {      (yytype_int16 const   )4,      (yytype_int16 const   )90,      (yytype_int16 const   )47,      (yytype_int16 const   )4, 
        (yytype_int16 const   )4,      (yytype_int16 const   )212,      (yytype_int16 const   )234,      (yytype_int16 const   )554, 
        (yytype_int16 const   )4,      (yytype_int16 const   )29,      (yytype_int16 const   )285,      (yytype_int16 const   )4, 
        (yytype_int16 const   )4,      (yytype_int16 const   )3,      (yytype_int16 const   )2,      (yytype_int16 const   )4, 
        (yytype_int16 const   )319,      (yytype_int16 const   )411,      (yytype_int16 const   )198,      (yytype_int16 const   )554, 
        (yytype_int16 const   )7,      (yytype_int16 const   )7,      (yytype_int16 const   )554,      (yytype_int16 const   )4, 
        (yytype_int16 const   )7,      (yytype_int16 const   )380,      (yytype_int16 const   )381,      (yytype_int16 const   )238, 
        (yytype_int16 const   )224,      (yytype_int16 const   )346,      (yytype_int16 const   )262,      (yytype_int16 const   )554, 
        (yytype_int16 const   )7,      (yytype_int16 const   )438,      (yytype_int16 const   )4,      (yytype_int16 const   )1, 
        (yytype_int16 const   )247,      (yytype_int16 const   )450,      (yytype_int16 const   )447,      (yytype_int16 const   )448, 
        (yytype_int16 const   )656,      (yytype_int16 const   )441,      (yytype_int16 const   )40,      (yytype_int16 const   )536, 
        (yytype_int16 const   )270,      (yytype_int16 const   )225,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )261,      (yytype_int16 const   )509, 
        (yytype_int16 const   )51,      (yytype_int16 const   )689,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )656,      (yytype_int16 const   )90, 
        (yytype_int16 const   )11,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )91, 
        (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )407,      (yytype_int16 const   )656, 
        (yytype_int16 const   )194,      (yytype_int16 const   )195,      (yytype_int16 const   )1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )621,      (yytype_int16 const   )95, 
        (yytype_int16 const   )54,      (yytype_int16 const   )97,      (yytype_int16 const   )60,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )574,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )621,      (yytype_int16 const   )728, 
        (yytype_int16 const   )1,      (yytype_int16 const   )621,      (yytype_int16 const   )286,      (yytype_int16 const   )8, 
        (yytype_int16 const   )79,      (yytype_int16 const   )79,      (yytype_int16 const   )320,      (yytype_int16 const   )206, 
        (yytype_int16 const   )79,      (yytype_int16 const   )19,      (yytype_int16 const   )621,      (yytype_int16 const   )98, 
        (yytype_int16 const   )98,      (yytype_int16 const   )3,      (yytype_int16 const   )68,      (yytype_int16 const   )744, 
        (yytype_int16 const   )79,      (yytype_int16 const   )792,      (yytype_int16 const   )110,      (yytype_int16 const   )94, 
        (yytype_int16 const   )94,      (yytype_int16 const   )110,      (yytype_int16 const   )110,      (yytype_int16 const   )94, 
        (yytype_int16 const   )728,      (yytype_int16 const   )64,      (yytype_int16 const   )110,      (yytype_int16 const   )63, 
        (yytype_int16 const   )33,      (yytype_int16 const   )110,      (yytype_int16 const   )110,      (yytype_int16 const   )94, 
        (yytype_int16 const   )35,      (yytype_int16 const   )110,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )109, 
        (yytype_int16 const   )744,      (yytype_int16 const   )110,      (yytype_int16 const   )728,      (yytype_int16 const   )13, 
        (yytype_int16 const   )63,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )734,      (yytype_int16 const   )824,      (yytype_int16 const   )60,      (yytype_int16 const   )728, 
        (yytype_int16 const   )110,      (yytype_int16 const   )43,      (yytype_int16 const   )338,      (yytype_int16 const   )25, 
        (yytype_int16 const   )68,      (yytype_int16 const   )734,      (yytype_int16 const   )326,      (yytype_int16 const   )89, 
        (yytype_int16 const   )33,      (yytype_int16 const   )31,      (yytype_int16 const   )63,      (yytype_int16 const   )506, 
        (yytype_int16 const   )552,      (yytype_int16 const   )558,      (yytype_int16 const   )429,      (yytype_int16 const   )57, 
        (yytype_int16 const   )267,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )63,      (yytype_int16 const   )84,      (yytype_int16 const   )194, 
        (yytype_int16 const   )195,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )280,      (yytype_int16 const   )33,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )514,      (yytype_int16 const   )285,      (yytype_int16 const   )51, 
        (yytype_int16 const   )287,      (yytype_int16 const   )813,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )43,      (yytype_int16 const   )103,      (yytype_int16 const   )213,      (yytype_int16 const   )69, 
        (yytype_int16 const   )99,      (yytype_int16 const   )102,      (yytype_int16 const   )69,      (yytype_int16 const   )109, 
        (yytype_int16 const   )916,      (yytype_int16 const   )876,      (yytype_int16 const   )30,      (yytype_int16 const   )68, 
        (yytype_int16 const   )43,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )69,      (yytype_int16 const   )68,      (yytype_int16 const   )218,      (yytype_int16 const   )219, 
        (yytype_int16 const   )43,      (yytype_int16 const   )659,      (yytype_int16 const   )206,      (yytype_int16 const   )314, 
        (yytype_int16 const   )0,      (yytype_int16 const   )206,      (yytype_int16 const   )206,      (yytype_int16 const   )805, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )43,      (yytype_int16 const   )68,      (yytype_int16 const   )206,      (yytype_int16 const   )98, 
        (yytype_int16 const   )102,      (yytype_int16 const   )102,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )98,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )102,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )917,      (yytype_int16 const   )102, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )962,      (yytype_int16 const   )881, 
        (yytype_int16 const   )68,      (yytype_int16 const   )241,      (yytype_int16 const   )541,      (yytype_int16 const   )102, 
        (yytype_int16 const   )241,      (yytype_int16 const   )241,      (yytype_int16 const   )262,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )241,      (yytype_int16 const   )933,      (yytype_int16 const   )102, 
        (yytype_int16 const   )241,      (yytype_int16 const   )241,      (yytype_int16 const   )101,      (yytype_int16 const   )0, 
        (yytype_int16 const   )241,      (yytype_int16 const   )594,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )101,      (yytype_int16 const   )905, 
        (yytype_int16 const   )241,      (yytype_int16 const   )674,      (yytype_int16 const   )458,      (yytype_int16 const   )267, 
        (yytype_int16 const   )475,      (yytype_int16 const   )678,      (yytype_int16 const   )267,      (yytype_int16 const   )267, 
        (yytype_int16 const   )299,      (yytype_int16 const   )300,      (yytype_int16 const   )101,      (yytype_int16 const   )241, 
        (yytype_int16 const   )504,      (yytype_int16 const   )110,      (yytype_int16 const   )668,      (yytype_int16 const   )267, 
        (yytype_int16 const   )280,      (yytype_int16 const   )457,      (yytype_int16 const   )115,      (yytype_int16 const   )280, 
        (yytype_int16 const   )280,      (yytype_int16 const   )285,      (yytype_int16 const   )408,      (yytype_int16 const   )287, 
        (yytype_int16 const   )285,      (yytype_int16 const   )285,      (yytype_int16 const   )287,      (yytype_int16 const   )287, 
        (yytype_int16 const   )280,      (yytype_int16 const   )285,      (yytype_int16 const   )699,      (yytype_int16 const   )517, 
        (yytype_int16 const   )285,      (yytype_int16 const   )285,      (yytype_int16 const   )420,      (yytype_int16 const   )287, 
        (yytype_int16 const   )285,      (yytype_int16 const   )57,      (yytype_int16 const   )220,      (yytype_int16 const   )757, 
        (yytype_int16 const   )944,      (yytype_int16 const   )223,      (yytype_int16 const   )285,      (yytype_int16 const   )63, 
        (yytype_int16 const   )285,      (yytype_int16 const   )431,      (yytype_int16 const   )62,      (yytype_int16 const   )662, 
        (yytype_int16 const   )62,      (yytype_int16 const   )69,      (yytype_int16 const   )314,      (yytype_int16 const   )0, 
        (yytype_int16 const   )234,      (yytype_int16 const   )314,      (yytype_int16 const   )314,      (yytype_int16 const   )69, 
        (yytype_int16 const   )336,      (yytype_int16 const   )102,      (yytype_int16 const   )429,      (yytype_int16 const   )1006, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )314,      (yytype_int16 const   )301, 
        (yytype_int16 const   )69,      (yytype_int16 const   )532,      (yytype_int16 const   )409,      (yytype_int16 const   )971, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )556,      (yytype_int16 const   )557, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )62, 
        (yytype_int16 const   )340,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )340, 
        (yytype_int16 const   )340,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )265, 
        (yytype_int16 const   )340,      (yytype_int16 const   )101,      (yytype_int16 const   )3,      (yytype_int16 const   )340, 
        (yytype_int16 const   )340,      (yytype_int16 const   )432,      (yytype_int16 const   )354,      (yytype_int16 const   )340, 
        (yytype_int16 const   )356,      (yytype_int16 const   )354,      (yytype_int16 const   )354,      (yytype_int16 const   )356, 
        (yytype_int16 const   )356,      (yytype_int16 const   )102,      (yytype_int16 const   )354,      (yytype_int16 const   )340, 
        (yytype_int16 const   )356,      (yytype_int16 const   )354,      (yytype_int16 const   )354,      (yytype_int16 const   )356, 
        (yytype_int16 const   )356,      (yytype_int16 const   )354,      (yytype_int16 const   )203,      (yytype_int16 const   )356, 
        (yytype_int16 const   )564,      (yytype_int16 const   )686,      (yytype_int16 const   )340,      (yytype_int16 const   )293, 
        (yytype_int16 const   )319,      (yytype_int16 const   )354,      (yytype_int16 const   )57,      (yytype_int16 const   )356, 
        (yytype_int16 const   )323,      (yytype_int16 const   )408,      (yytype_int16 const   )409,      (yytype_int16 const   )101, 
        (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )57,      (yytype_int16 const   )563, 
        (yytype_int16 const   )354,      (yytype_int16 const   )63,      (yytype_int16 const   )356,      (yytype_int16 const   )567, 
        (yytype_int16 const   )568,      (yytype_int16 const   )420,      (yytype_int16 const   )40,      (yytype_int16 const   )57, 
        (yytype_int16 const   )69,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )942, 
        (yytype_int16 const   )943,      (yytype_int16 const   )63,      (yytype_int16 const   )426,      (yytype_int16 const   )427, 
        (yytype_int16 const   )57,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )241,      (yytype_int16 const   )3,      (yytype_int16 const   )63,      (yytype_int16 const   )942, 
        (yytype_int16 const   )943,      (yytype_int16 const   )40,      (yytype_int16 const   )942,      (yytype_int16 const   )943, 
        (yytype_int16 const   )62,      (yytype_int16 const   )3,      (yytype_int16 const   )64,      (yytype_int16 const   )69, 
        (yytype_int16 const   )447,      (yytype_int16 const   )448,      (yytype_int16 const   )69,      (yytype_int16 const   )942, 
        (yytype_int16 const   )943,      (yytype_int16 const   )69,      (yytype_int16 const   )99,      (yytype_int16 const   )79, 
        (yytype_int16 const   )40,      (yytype_int16 const   )429,      (yytype_int16 const   )654,      (yytype_int16 const   )69, 
        (yytype_int16 const   )429,      (yytype_int16 const   )429,      (yytype_int16 const   )63,      (yytype_int16 const   )62, 
        (yytype_int16 const   )269,      (yytype_int16 const   )429,      (yytype_int16 const   )65,      (yytype_int16 const   )69, 
        (yytype_int16 const   )429,      (yytype_int16 const   )429,      (yytype_int16 const   )94,      (yytype_int16 const   )417, 
        (yytype_int16 const   )429,      (yytype_int16 const   )758,      (yytype_int16 const   )638,      (yytype_int16 const   )33, 
        (yytype_int16 const   )422,      (yytype_int16 const   )99,      (yytype_int16 const   )429,      (yytype_int16 const   )98, 
        (yytype_int16 const   )429,      (yytype_int16 const   )729,      (yytype_int16 const   )646,      (yytype_int16 const   )647, 
        (yytype_int16 const   )83,      (yytype_int16 const   )69,      (yytype_int16 const   )734,      (yytype_int16 const   )292, 
        (yytype_int16 const   )98,      (yytype_int16 const   )379,      (yytype_int16 const   )69,      (yytype_int16 const   )57, 
        (yytype_int16 const   )382,      (yytype_int16 const   )764,      (yytype_int16 const   )63,      (yytype_int16 const   )64, 
        (yytype_int16 const   )98,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )57, 
        (yytype_int16 const   )75,      (yytype_int16 const   )306,      (yytype_int16 const   )63,      (yytype_int16 const   )78, 
        (yytype_int16 const   )3,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )397, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )62,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )98,      (yytype_int16 const   )1, 
        (yytype_int16 const   )504,      (yytype_int16 const   )69,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )62,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )267, 
        (yytype_int16 const   )99,      (yytype_int16 const   )98,      (yytype_int16 const   )722,      (yytype_int16 const   )69, 
        (yytype_int16 const   )101,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )101,      (yytype_int16 const   )80,      (yytype_int16 const   )533,      (yytype_int16 const   )57, 
        (yytype_int16 const   )280,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )287, 
        (yytype_int16 const   )102,      (yytype_int16 const   )31,      (yytype_int16 const   )351,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )354,      (yytype_int16 const   )408,      (yytype_int16 const   )356, 
        (yytype_int16 const   )79,      (yytype_int16 const   )195,      (yytype_int16 const   )81,      (yytype_int16 const   )360, 
        (yytype_int16 const   )446,      (yytype_int16 const   )199,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )420,      (yytype_int16 const   )63, 
        (yytype_int16 const   )63,      (yytype_int16 const   )744,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )314,      (yytype_int16 const   )40, 
        (yytype_int16 const   )462,      (yytype_int16 const   )431,      (yytype_int16 const   )464,      (yytype_int16 const   )98, 
        (yytype_int16 const   )466,      (yytype_int16 const   )752,      (yytype_int16 const   )101,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )69,      (yytype_int16 const   )554,      (yytype_int16 const   )69, 
        (yytype_int16 const   )778,      (yytype_int16 const   )554,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )98,      (yytype_int16 const   )554,      (yytype_int16 const   )787, 
        (yytype_int16 const   )101,      (yytype_int16 const   )554,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )1,      (yytype_int16 const   )870, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )873,      (yytype_int16 const   )575, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )575,      (yytype_int16 const   )575, 
        (yytype_int16 const   )62,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )575, 
        (yytype_int16 const   )566,      (yytype_int16 const   )99,      (yytype_int16 const   )575,      (yytype_int16 const   )575, 
        (yytype_int16 const   )102,      (yytype_int16 const   )98,      (yytype_int16 const   )575,      (yytype_int16 const   )509, 
        (yytype_int16 const   )101,      (yytype_int16 const   )98,      (yytype_int16 const   )512,      (yytype_int16 const   )566, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )575,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )69,      (yytype_int16 const   )644, 
        (yytype_int16 const   )645,      (yytype_int16 const   )63,      (yytype_int16 const   )691,      (yytype_int16 const   )631, 
        (yytype_int16 const   )632,      (yytype_int16 const   )575,      (yytype_int16 const   )813,      (yytype_int16 const   )63, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )76,      (yytype_int16 const   )601, 
        (yytype_int16 const   )76,      (yytype_int16 const   )79,      (yytype_int16 const   )25,      (yytype_int16 const   )81, 
        (yytype_int16 const   )1001,      (yytype_int16 const   )621,      (yytype_int16 const   )1003,      (yytype_int16 const   )1004, 
        (yytype_int16 const   )621,      (yytype_int16 const   )98,      (yytype_int16 const   )88,      (yytype_int16 const   )100, 
        (yytype_int16 const   )88,      (yytype_int16 const   )621,      (yytype_int16 const   )616,      (yytype_int16 const   )93, 
        (yytype_int16 const   )621,      (yytype_int16 const   )93,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )623, 
        (yytype_int16 const   )624,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )627, 
        (yytype_int16 const   )628,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )33,      (yytype_int16 const   )63,      (yytype_int16 const   )1005,      (yytype_int16 const   )968, 
        (yytype_int16 const   )969,      (yytype_int16 const   )101,      (yytype_int16 const   )576,      (yytype_int16 const   )25, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )76, 
        (yytype_int16 const   )691,      (yytype_int16 const   )31,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )81,      (yytype_int16 const   )781,      (yytype_int16 const   )782,      (yytype_int16 const   )98, 
        (yytype_int16 const   )699,      (yytype_int16 const   )700,      (yytype_int16 const   )656,      (yytype_int16 const   )88, 
        (yytype_int16 const   )57,      (yytype_int16 const   )656,      (yytype_int16 const   )101,      (yytype_int16 const   )86, 
        (yytype_int16 const   )93,      (yytype_int16 const   )101,      (yytype_int16 const   )63,      (yytype_int16 const   )64, 
        (yytype_int16 const   )101,      (yytype_int16 const   )656,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )253,      (yytype_int16 const   )254,      (yytype_int16 const   )730,      (yytype_int16 const   )731, 
        (yytype_int16 const   )732,      (yytype_int16 const   )885,      (yytype_int16 const   )99,      (yytype_int16 const   )694, 
        (yytype_int16 const   )694,      (yytype_int16 const   )101,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )698,      (yytype_int16 const   )8,      (yytype_int16 const   )910,      (yytype_int16 const   )942, 
        (yytype_int16 const   )943,      (yytype_int16 const   )102,      (yytype_int16 const   )63,      (yytype_int16 const   )694, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )63,      (yytype_int16 const   )698, 
        (yytype_int16 const   )755,      (yytype_int16 const   )814,      (yytype_int16 const   )62,      (yytype_int16 const   )69, 
        (yytype_int16 const   )30,      (yytype_int16 const   )909,      (yytype_int16 const   )98,      (yytype_int16 const   )927, 
        (yytype_int16 const   )654,      (yytype_int16 const   )40,      (yytype_int16 const   )656,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )659,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )768,      (yytype_int16 const   )769,      (yytype_int16 const   )728,      (yytype_int16 const   )69, 
        (yytype_int16 const   )50,      (yytype_int16 const   )728,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )98,      (yytype_int16 const   )623,      (yytype_int16 const   )624, 
        (yytype_int16 const   )68,      (yytype_int16 const   )728,      (yytype_int16 const   )627,      (yytype_int16 const   )628, 
        (yytype_int16 const   )43,      (yytype_int16 const   )101,      (yytype_int16 const   )744,      (yytype_int16 const   )63, 
        (yytype_int16 const   )43,      (yytype_int16 const   )744,      (yytype_int16 const   )31,      (yytype_int16 const   )101, 
        (yytype_int16 const   )101,      (yytype_int16 const   )207,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )744,      (yytype_int16 const   )101,      (yytype_int16 const   )33, 
        (yytype_int16 const   )9,      (yytype_int16 const   )98,      (yytype_int16 const   )33,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )100,      (yytype_int16 const   )766, 
        (yytype_int16 const   )766,      (yytype_int16 const   )43,      (yytype_int16 const   )11,      (yytype_int16 const   )814, 
        (yytype_int16 const   )706,      (yytype_int16 const   )25,      (yytype_int16 const   )3,      (yytype_int16 const   )774, 
        (yytype_int16 const   )774,      (yytype_int16 const   )69,      (yytype_int16 const   )69,      (yytype_int16 const   )766, 
        (yytype_int16 const   )69,      (yytype_int16 const   )102,      (yytype_int16 const   )99,      (yytype_int16 const   )40, 
        (yytype_int16 const   )63,      (yytype_int16 const   )98,      (yytype_int16 const   )43,      (yytype_int16 const   )774, 
        (yytype_int16 const   )722,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )101, 
        (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )728,      (yytype_int16 const   )101, 
        (yytype_int16 const   )101,      (yytype_int16 const   )625,      (yytype_int16 const   )626,      (yytype_int16 const   )842, 
        (yytype_int16 const   )734,      (yytype_int16 const   )629,      (yytype_int16 const   )630,      (yytype_int16 const   )43, 
        (yytype_int16 const   )738,      (yytype_int16 const   )62,      (yytype_int16 const   )43,      (yytype_int16 const   )64, 
        (yytype_int16 const   )65,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )101, 
        (yytype_int16 const   )100,      (yytype_int16 const   )100,      (yytype_int16 const   )268,      (yytype_int16 const   )101, 
        (yytype_int16 const   )270,      (yytype_int16 const   )271,      (yytype_int16 const   )101,      (yytype_int16 const   )101, 
        (yytype_int16 const   )274,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )757, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )83,      (yytype_int16 const   )281, 
        (yytype_int16 const   )102,      (yytype_int16 const   )283,      (yytype_int16 const   )68,      (yytype_int16 const   )102, 
        (yytype_int16 const   )101,      (yytype_int16 const   )101,      (yytype_int16 const   )288,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )101,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )843,      (yytype_int16 const   )844,      (yytype_int16 const   )69, 
        (yytype_int16 const   )99,      (yytype_int16 const   )303,      (yytype_int16 const   )882,      (yytype_int16 const   )98, 
        (yytype_int16 const   )98,      (yytype_int16 const   )787,      (yytype_int16 const   )99,      (yytype_int16 const   )309, 
        (yytype_int16 const   )843,      (yytype_int16 const   )844,      (yytype_int16 const   )792,      (yytype_int16 const   )3, 
        (yytype_int16 const   )68,      (yytype_int16 const   )315,      (yytype_int16 const   )101,      (yytype_int16 const   )98, 
        (yytype_int16 const   )35,      (yytype_int16 const   )194,      (yytype_int16 const   )195,      (yytype_int16 const   )99, 
        (yytype_int16 const   )99,      (yytype_int16 const   )68,      (yytype_int16 const   )199,      (yytype_int16 const   )101, 
        (yytype_int16 const   )721,      (yytype_int16 const   )40,      (yytype_int16 const   )30,      (yytype_int16 const   )43, 
        (yytype_int16 const   )32,      (yytype_int16 const   )68,      (yytype_int16 const   )34,      (yytype_int16 const   )911, 
        (yytype_int16 const   )36,      (yytype_int16 const   )99,      (yytype_int16 const   )38,      (yytype_int16 const   )881, 
        (yytype_int16 const   )40,      (yytype_int16 const   )63,      (yytype_int16 const   )42,      (yytype_int16 const   )63, 
        (yytype_int16 const   )44,      (yytype_int16 const   )57,      (yytype_int16 const   )824,      (yytype_int16 const   )63, 
        (yytype_int16 const   )43,      (yytype_int16 const   )43,      (yytype_int16 const   )881,      (yytype_int16 const   )63, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )65,      (yytype_int16 const   )262,      (yytype_int16 const   )69, 
        (yytype_int16 const   )69,      (yytype_int16 const   )937,      (yytype_int16 const   )69,      (yytype_int16 const   )905, 
        (yytype_int16 const   )19,      (yytype_int16 const   )99,      (yytype_int16 const   )66,      (yytype_int16 const   )99, 
        (yytype_int16 const   )68,      (yytype_int16 const   )40,      (yytype_int16 const   )70,      (yytype_int16 const   )101, 
        (yytype_int16 const   )72,      (yytype_int16 const   )69,      (yytype_int16 const   )905,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )942,      (yytype_int16 const   )943, 
        (yytype_int16 const   )944,      (yytype_int16 const   )942,      (yytype_int16 const   )943,      (yytype_int16 const   )944, 
        (yytype_int16 const   )944,      (yytype_int16 const   )69,      (yytype_int16 const   )942,      (yytype_int16 const   )943, 
        (yytype_int16 const   )944,      (yytype_int16 const   )942,      (yytype_int16 const   )943,      (yytype_int16 const   )944, 
        (yytype_int16 const   )944,      (yytype_int16 const   )790,      (yytype_int16 const   )876,      (yytype_int16 const   )944, 
        (yytype_int16 const   )793,      (yytype_int16 const   )794,      (yytype_int16 const   )946,      (yytype_int16 const   )276, 
        (yytype_int16 const   )63,      (yytype_int16 const   )69,      (yytype_int16 const   )982,      (yytype_int16 const   )944, 
        (yytype_int16 const   )801,      (yytype_int16 const   )265,      (yytype_int16 const   )63,      (yytype_int16 const   )971, 
        (yytype_int16 const   )69,      (yytype_int16 const   )99,      (yytype_int16 const   )971,      (yytype_int16 const   )971, 
        (yytype_int16 const   )99,      (yytype_int16 const   )69,      (yytype_int16 const   )69,      (yytype_int16 const   )971, 
        (yytype_int16 const   )996,      (yytype_int16 const   )20,      (yytype_int16 const   )971,      (yytype_int16 const   )971, 
        (yytype_int16 const   )99,      (yytype_int16 const   )423,      (yytype_int16 const   )971,      (yytype_int16 const   )99, 
        (yytype_int16 const   )101,      (yytype_int16 const   )69,      (yytype_int16 const   )973,      (yytype_int16 const   )973, 
        (yytype_int16 const   )101,      (yytype_int16 const   )826,      (yytype_int16 const   )971,      (yytype_int16 const   )69, 
        (yytype_int16 const   )1012,      (yytype_int16 const   )1013,      (yytype_int16 const   )69,      (yytype_int16 const   )917, 
        (yytype_int16 const   )69,      (yytype_int16 const   )101,      (yytype_int16 const   )973,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )64, 
        (yytype_int16 const   )65,      (yytype_int16 const   )64,      (yytype_int16 const   )82,      (yytype_int16 const   )84, 
        (yytype_int16 const   )450,      (yytype_int16 const   )101,      (yytype_int16 const   )452,      (yytype_int16 const   )933, 
        (yytype_int16 const   )69,      (yytype_int16 const   )50,      (yytype_int16 const   )84,      (yytype_int16 const   )69, 
        (yytype_int16 const   )853,      (yytype_int16 const   )50,      (yytype_int16 const   )68,      (yytype_int16 const   )1023, 
        (yytype_int16 const   )69,      (yytype_int16 const   )63,      (yytype_int16 const   )1023,      (yytype_int16 const   )1023, 
        (yytype_int16 const   )98,      (yytype_int16 const   )207,      (yytype_int16 const   )863,      (yytype_int16 const   )1023, 
        (yytype_int16 const   )68,      (yytype_int16 const   )100,      (yytype_int16 const   )1023,      (yytype_int16 const   )1023, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )69,      (yytype_int16 const   )1023,      (yytype_int16 const   )1036, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )99,      (yytype_int16 const   )101,      (yytype_int16 const   )339, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )11,      (yytype_int16 const   )1023,      (yytype_int16 const   )1036, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )101,      (yytype_int16 const   )63,      (yytype_int16 const   )1036, 
        (yytype_int16 const   )11,      (yytype_int16 const   )69,      (yytype_int16 const   )350,      (yytype_int16 const   )64, 
        (yytype_int16 const   )82,      (yytype_int16 const   )101,      (yytype_int16 const   )11,      (yytype_int16 const   )1036, 
        (yytype_int16 const   )63,      (yytype_int16 const   )69,      (yytype_int16 const   )358,      (yytype_int16 const   )359, 
        (yytype_int16 const   )101,      (yytype_int16 const   )361,      (yytype_int16 const   )362,      (yytype_int16 const   )363, 
        (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )366,      (yytype_int16 const   )367, 
        (yytype_int16 const   )368,      (yytype_int16 const   )369,      (yytype_int16 const   )370,      (yytype_int16 const   )371, 
        (yytype_int16 const   )372,      (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375, 
        (yytype_int16 const   )376,      (yytype_int16 const   )100,      (yytype_int16 const   )885,      (yytype_int16 const   )916, 
        (yytype_int16 const   )98,      (yytype_int16 const   )637,      (yytype_int16 const   )460,      (yytype_int16 const   )698, 
        (yytype_int16 const   )1006,      (yytype_int16 const   )844,      (yytype_int16 const   )268,      (yytype_int16 const   )1012, 
        (yytype_int16 const   )270,      (yytype_int16 const   )271,      (yytype_int16 const   )1036,      (yytype_int16 const   )408, 
        (yytype_int16 const   )409,      (yytype_int16 const   )1002,      (yytype_int16 const   )506,      (yytype_int16 const   )621, 
        (yytype_int16 const   )29,      (yytype_int16 const   )504,      (yytype_int16 const   )398,      (yytype_int16 const   )281, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )251,      (yytype_int16 const   )420, 
        (yytype_int16 const   )251,      (yytype_int16 const   )692,      (yytype_int16 const   )288,      (yytype_int16 const   )407, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )408, 
        (yytype_int16 const   )512,      (yytype_int16 const   )950,      (yytype_int16 const   )431,      (yytype_int16 const   )432, 
        (yytype_int16 const   )406,      (yytype_int16 const   )625,      (yytype_int16 const   )626,      (yytype_int16 const   )573, 
        (yytype_int16 const   )752,      (yytype_int16 const   )629,      (yytype_int16 const   )630,      (yytype_int16 const   )466, 
        (yytype_int16 const   )464,      (yytype_int16 const   )962,      (yytype_int16 const   )33,      (yytype_int16 const   )309, 
        (yytype_int16 const   )755,      (yytype_int16 const   )728,      (yytype_int16 const   )572,      (yytype_int16 const   )276, 
        (yytype_int16 const   )657,      (yytype_int16 const   )315,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )294,      (yytype_int16 const   )734, 
        (yytype_int16 const   )296,      (yytype_int16 const   )952,      (yytype_int16 const   )954,      (yytype_int16 const   )992, 
        (yytype_int16 const   )504,      (yytype_int16 const   )429,      (yytype_int16 const   )443,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )444,      (yytype_int16 const   )603,      (yytype_int16 const   )613,      (yytype_int16 const   )463, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )607,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )611,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )509,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )512,      (yytype_int16 const   )-1,      (yytype_int16 const   )514,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )671,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )674,      (yytype_int16 const   )675,      (yytype_int16 const   )25,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )678,      (yytype_int16 const   )679,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )423,      (yytype_int16 const   )33,      (yytype_int16 const   )42, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )703,      (yytype_int16 const   )704,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )452,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )623, 
        (yytype_int16 const   )624,      (yytype_int16 const   )625,      (yytype_int16 const   )626,      (yytype_int16 const   )627, 
        (yytype_int16 const   )628,      (yytype_int16 const   )629,      (yytype_int16 const   )630,      (yytype_int16 const   )583, 
        (yytype_int16 const   )584,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )591, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )594,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )602,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )606,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )751,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )754,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )619, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )778,      (yytype_int16 const   )779,      (yytype_int16 const   )780,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )659, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )262,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )672,      (yytype_int16 const   )-1,      (yytype_int16 const   )57,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )676,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )572,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )692,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )838,      (yytype_int16 const   )-1,      (yytype_int16 const   )294,      (yytype_int16 const   )295, 
        (yytype_int16 const   )296,      (yytype_int16 const   )297,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )717,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )603,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )607,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )611,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )757,      (yytype_int16 const   )900,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )902,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )623, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )625,      (yytype_int16 const   )-1,      (yytype_int16 const   )627, 
        (yytype_int16 const   )45,      (yytype_int16 const   )629,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )671,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )675,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )679,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )703,      (yytype_int16 const   )704,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )102,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )858,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )751,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )754,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )13,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )778,      (yytype_int16 const   )779,      (yytype_int16 const   )780,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )504,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )838,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )101,      (yytype_int16 const   )102, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )900,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )902,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1023, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )623, 
        (yytype_int16 const   )624,      (yytype_int16 const   )625,      (yytype_int16 const   )626,      (yytype_int16 const   )627, 
        (yytype_int16 const   )628,      (yytype_int16 const   )629,      (yytype_int16 const   )630,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1036,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )723, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )77, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )99,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )76,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31, 
        (yytype_int16 const   )1,      (yytype_int16 const   )33,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )13,      (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )33,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )76,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )31,      (yytype_int16 const   )99, 
        (yytype_int16 const   )33,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )-1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )25, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )97,      (yytype_int16 const   )31,      (yytype_int16 const   )99,      (yytype_int16 const   )33, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )76,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )31, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )25,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )-1,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )31, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )99, 
        (yytype_int16 const   )32,      (yytype_int16 const   )101,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )101,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )74,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )102,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )-1,      (yytype_int16 const   )32, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )69,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )99,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )13,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )25,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )33,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )-1,      (yytype_int16 const   )33, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )102, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96, 
        (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )102,      (yytype_int16 const   )-1,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )13, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86, 
        (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )100,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )18, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )100,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )74, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86, 
        (yytype_int16 const   )87,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )-1,      (yytype_int16 const   )32, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )3,      (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )18, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )74, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86, 
        (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )1,      (yytype_int16 const   )63,      (yytype_int16 const   )3,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )1,      (yytype_int16 const   )63,      (yytype_int16 const   )3, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )3,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )74,      (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )3,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )3,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )3,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )3,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )3, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86, 
        (yytype_int16 const   )87,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )32,      (yytype_int16 const   )-1,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )45,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )33,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )13,      (yytype_int16 const   )95, 
        (yytype_int16 const   )96,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )102,      (yytype_int16 const   )44, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )100,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59};
#line 2440 "c-parse.tab.c"
static yytype_uint16 const   yystos[1038]  = 
#line 2440
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )70,      (yytype_uint16 const   )71,      (yytype_uint16 const   )72, 
        (yytype_uint16 const   )73,      (yytype_uint16 const   )104,      (yytype_uint16 const   )169,      (yytype_uint16 const   )170, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )106,      (yytype_uint16 const   )110,      (yytype_uint16 const   )121, 
        (yytype_uint16 const   )169,      (yytype_uint16 const   )1,      (yytype_uint16 const   )4,      (yytype_uint16 const   )5, 
        (yytype_uint16 const   )6,      (yytype_uint16 const   )7,      (yytype_uint16 const   )8,      (yytype_uint16 const   )15, 
        (yytype_uint16 const   )16,      (yytype_uint16 const   )17,      (yytype_uint16 const   )25,      (yytype_uint16 const   )31, 
        (yytype_uint16 const   )33,      (yytype_uint16 const   )90,      (yytype_uint16 const   )91,      (yytype_uint16 const   )95, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )102,      (yytype_uint16 const   )208,      (yytype_uint16 const   )209, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )211,      (yytype_uint16 const   )212,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )214,      (yytype_uint16 const   )215,      (yytype_uint16 const   )216,      (yytype_uint16 const   )217, 
        (yytype_uint16 const   )218,      (yytype_uint16 const   )219,      (yytype_uint16 const   )220,      (yytype_uint16 const   )221, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )223,      (yytype_uint16 const   )224,      (yytype_uint16 const   )225, 
        (yytype_uint16 const   )233,      (yytype_uint16 const   )234,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )248,      (yytype_uint16 const   )250,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )256,      (yytype_uint16 const   )280,      (yytype_uint16 const   )281, 
        (yytype_uint16 const   )286,      (yytype_uint16 const   )351,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )364,      (yytype_uint16 const   )1,      (yytype_uint16 const   )208,      (yytype_uint16 const   )209, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )211,      (yytype_uint16 const   )212,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )214,      (yytype_uint16 const   )215,      (yytype_uint16 const   )228,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )298,      (yytype_uint16 const   )0,      (yytype_uint16 const   )171, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )30,      (yytype_uint16 const   )34,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )97,      (yytype_uint16 const   )172,      (yytype_uint16 const   )173,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )175,      (yytype_uint16 const   )176,      (yytype_uint16 const   )205,      (yytype_uint16 const   )224, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )231,      (yytype_uint16 const   )360,      (yytype_uint16 const   )76, 
        (yytype_uint16 const   )88,      (yytype_uint16 const   )93,      (yytype_uint16 const   )122,      (yytype_uint16 const   )125, 
        (yytype_uint16 const   )129,      (yytype_uint16 const   )132,      (yytype_uint16 const   )107,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )3,      (yytype_uint16 const   )4,      (yytype_uint16 const   )68,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )279,      (yytype_uint16 const   )102,      (yytype_uint16 const   )63,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )10,      (yytype_uint16 const   )11,      (yytype_uint16 const   )12,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )253,      (yytype_uint16 const   )180,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )253,      (yytype_uint16 const   )257,      (yytype_uint16 const   )233,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )248,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )233,      (yytype_uint16 const   )234,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )248,      (yytype_uint16 const   )361, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )361, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )248, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )233,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )248,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )233,      (yytype_uint16 const   )234,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )248,      (yytype_uint16 const   )361, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )361, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236,      (yytype_uint16 const   )248, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )235,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )362,      (yytype_uint16 const   )352,      (yytype_uint16 const   )352, 
        (yytype_uint16 const   )251,      (yytype_uint16 const   )68,      (yytype_uint16 const   )279,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )69,      (yytype_uint16 const   )99,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )3,      (yytype_uint16 const   )57,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )239,      (yytype_uint16 const   )241,      (yytype_uint16 const   )245,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )205,      (yytype_uint16 const   )205,      (yytype_uint16 const   )205,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )182,      (yytype_uint16 const   )79,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )80,      (yytype_uint16 const   )108,      (yytype_uint16 const   )180,      (yytype_uint16 const   )285, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )279,      (yytype_uint16 const   )3,      (yytype_uint16 const   )10, 
        (yytype_uint16 const   )14,      (yytype_uint16 const   )32,      (yytype_uint16 const   )36,      (yytype_uint16 const   )37, 
        (yytype_uint16 const   )38,      (yytype_uint16 const   )39,      (yytype_uint16 const   )45,      (yytype_uint16 const   )48, 
        (yytype_uint16 const   )55,      (yytype_uint16 const   )56,      (yytype_uint16 const   )57,      (yytype_uint16 const   )60, 
        (yytype_uint16 const   )61,      (yytype_uint16 const   )63,      (yytype_uint16 const   )66,      (yytype_uint16 const   )67, 
        (yytype_uint16 const   )85,      (yytype_uint16 const   )86,      (yytype_uint16 const   )87,      (yytype_uint16 const   )183, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )186,      (yytype_uint16 const   )187,      (yytype_uint16 const   )188, 
        (yytype_uint16 const   )189,      (yytype_uint16 const   )190,      (yytype_uint16 const   )191,      (yytype_uint16 const   )192, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )196,      (yytype_uint16 const   )199,      (yytype_uint16 const   )200, 
        (yytype_uint16 const   )298,      (yytype_uint16 const   )360,      (yytype_uint16 const   )63,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )63,      (yytype_uint16 const   )4,      (yytype_uint16 const   )57, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )64,      (yytype_uint16 const   )277,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302,      (yytype_uint16 const   )303, 
        (yytype_uint16 const   )304,      (yytype_uint16 const   )306,      (yytype_uint16 const   )308,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )57,      (yytype_uint16 const   )278,      (yytype_uint16 const   )300,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )289,      (yytype_uint16 const   )290,      (yytype_uint16 const   )249,      (yytype_uint16 const   )57, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )300,      (yytype_uint16 const   )302,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )40,      (yytype_uint16 const   )62,      (yytype_uint16 const   )208,      (yytype_uint16 const   )209, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )211,      (yytype_uint16 const   )229,      (yytype_uint16 const   )232, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )250,      (yytype_uint16 const   )69,      (yytype_uint16 const   )98, 
        (yytype_uint16 const   )30,      (yytype_uint16 const   )63,      (yytype_uint16 const   )64,      (yytype_uint16 const   )118, 
        (yytype_uint16 const   )177,      (yytype_uint16 const   )242,      (yytype_uint16 const   )305,      (yytype_uint16 const   )307, 
        (yytype_uint16 const   )309,      (yytype_uint16 const   )4,      (yytype_uint16 const   )57,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )238,      (yytype_uint16 const   )240,      (yytype_uint16 const   )243,      (yytype_uint16 const   )275, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )278,      (yytype_uint16 const   )239,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )111,      (yytype_uint16 const   )130,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )109,      (yytype_uint16 const   )180,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )296,      (yytype_uint16 const   )297,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )102,      (yytype_uint16 const   )256,      (yytype_uint16 const   )249,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )180,      (yytype_uint16 const   )181,      (yytype_uint16 const   )192, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )184,      (yytype_uint16 const   )197,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )101,      (yytype_uint16 const   )98,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )199,      (yytype_uint16 const   )63,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )189,      (yytype_uint16 const   )40,      (yytype_uint16 const   )41, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )44,      (yytype_uint16 const   )45,      (yytype_uint16 const   )46, 
        (yytype_uint16 const   )47,      (yytype_uint16 const   )48,      (yytype_uint16 const   )49,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )51,      (yytype_uint16 const   )52,      (yytype_uint16 const   )53,      (yytype_uint16 const   )54, 
        (yytype_uint16 const   )55,      (yytype_uint16 const   )56,      (yytype_uint16 const   )57,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )59,      (yytype_uint16 const   )60,      (yytype_uint16 const   )61,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )64,      (yytype_uint16 const   )65,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )86,      (yytype_uint16 const   )182,      (yytype_uint16 const   )254, 
        (yytype_uint16 const   )255,      (yytype_uint16 const   )258,      (yytype_uint16 const   )361,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )364,      (yytype_uint16 const   )101,      (yytype_uint16 const   )101,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )3,      (yytype_uint16 const   )62,      (yytype_uint16 const   )64,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )194,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )265,      (yytype_uint16 const   )267,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )247,      (yytype_uint16 const   )345,      (yytype_uint16 const   )346, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )184,      (yytype_uint16 const   )247,      (yytype_uint16 const   )305, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )250,      (yytype_uint16 const   )63,      (yytype_uint16 const   )306, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )247,      (yytype_uint16 const   )250,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )69,      (yytype_uint16 const   )228,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )291,      (yytype_uint16 const   )360,      (yytype_uint16 const   )68,      (yytype_uint16 const   )232, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )101,      (yytype_uint16 const   )184,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )278,      (yytype_uint16 const   )206,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )353,      (yytype_uint16 const   )354,      (yytype_uint16 const   )119, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )247,      (yytype_uint16 const   )62,      (yytype_uint16 const   )232, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )69,      (yytype_uint16 const   )98,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )242,      (yytype_uint16 const   )305,      (yytype_uint16 const   )69,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )50,      (yytype_uint16 const   )113,      (yytype_uint16 const   )249,      (yytype_uint16 const   )123, 
        (yytype_uint16 const   )126,      (yytype_uint16 const   )69,      (yytype_uint16 const   )98,      (yytype_uint16 const   )40, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )288,      (yytype_uint16 const   )284,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )298,      (yytype_uint16 const   )101,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )319,      (yytype_uint16 const   )320,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )298,      (yytype_uint16 const   )298,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )184,      (yytype_uint16 const   )195,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )185,      (yytype_uint16 const   )186,      (yytype_uint16 const   )186,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )101,      (yytype_uint16 const   )63,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )266,      (yytype_uint16 const   )43,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )287,      (yytype_uint16 const   )40,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )265,      (yytype_uint16 const   )277,      (yytype_uint16 const   )302,      (yytype_uint16 const   )303, 
        (yytype_uint16 const   )301,      (yytype_uint16 const   )9,      (yytype_uint16 const   )359,      (yytype_uint16 const   )363, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )13,      (yytype_uint16 const   )347,      (yytype_uint16 const   )349, 
        (yytype_uint16 const   )350,      (yytype_uint16 const   )351,      (yytype_uint16 const   )100,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )205,      (yytype_uint16 const   )205,      (yytype_uint16 const   )69,      (yytype_uint16 const   )291, 
        (yytype_uint16 const   )282,      (yytype_uint16 const   )69,      (yytype_uint16 const   )69,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )275,      (yytype_uint16 const   )11,      (yytype_uint16 const   )359, 
        (yytype_uint16 const   )3,      (yytype_uint16 const   )347,      (yytype_uint16 const   )355,      (yytype_uint16 const   )356, 
        (yytype_uint16 const   )357,      (yytype_uint16 const   )1,      (yytype_uint16 const   )120,      (yytype_uint16 const   )350, 
        (yytype_uint16 const   )355,      (yytype_uint16 const   )40,      (yytype_uint16 const   )178,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )276,      (yytype_uint16 const   )206,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )3,      (yytype_uint16 const   )114,      (yytype_uint16 const   )115,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )131,      (yytype_uint16 const   )63,      (yytype_uint16 const   )133, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )180,      (yytype_uint16 const   )194,      (yytype_uint16 const   )297, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )296,      (yytype_uint16 const   )283,      (yytype_uint16 const   )98, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )314,      (yytype_uint16 const   )101,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )101,      (yytype_uint16 const   )101,      (yytype_uint16 const   )43, 
        (yytype_uint16 const   )43,      (yytype_uint16 const   )101,      (yytype_uint16 const   )100,      (yytype_uint16 const   )255, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )3,      (yytype_uint16 const   )185,      (yytype_uint16 const   )13, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )261,      (yytype_uint16 const   )264,      (yytype_uint16 const   )263, 
        (yytype_uint16 const   )265,      (yytype_uint16 const   )101,      (yytype_uint16 const   )101,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )98,      (yytype_uint16 const   )43,      (yytype_uint16 const   )275, 
        (yytype_uint16 const   )292,      (yytype_uint16 const   )294,      (yytype_uint16 const   )43,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )293,      (yytype_uint16 const   )295,      (yytype_uint16 const   )289,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )98,      (yytype_uint16 const   )101,      (yytype_uint16 const   )100, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )100,      (yytype_uint16 const   )359,      (yytype_uint16 const   )246, 
        (yytype_uint16 const   )201,      (yytype_uint16 const   )202,      (yytype_uint16 const   )203,      (yytype_uint16 const   )208, 
        (yytype_uint16 const   )209,      (yytype_uint16 const   )212,      (yytype_uint16 const   )213,      (yytype_uint16 const   )216, 
        (yytype_uint16 const   )217,      (yytype_uint16 const   )220,      (yytype_uint16 const   )221,      (yytype_uint16 const   )226, 
        (yytype_uint16 const   )227,      (yytype_uint16 const   )101,      (yytype_uint16 const   )243,      (yytype_uint16 const   )40, 
        (yytype_uint16 const   )51,      (yytype_uint16 const   )98,      (yytype_uint16 const   )249,      (yytype_uint16 const   )112, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )134,      (yytype_uint16 const   )135,      (yytype_uint16 const   )136, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )225,      (yytype_uint16 const   )249,      (yytype_uint16 const   )249, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )198,      (yytype_uint16 const   )35,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )315,      (yytype_uint16 const   )316,      (yytype_uint16 const   )317,      (yytype_uint16 const   )193, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )194,      (yytype_uint16 const   )98,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )194,      (yytype_uint16 const   )99,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )348,      (yytype_uint16 const   )13,      (yytype_uint16 const   )351,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )43,      (yytype_uint16 const   )247,      (yytype_uint16 const   )98,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )43,      (yytype_uint16 const   )247,      (yytype_uint16 const   )98,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )357,      (yytype_uint16 const   )1,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )259,      (yytype_uint16 const   )179,      (yytype_uint16 const   )13, 
        (yytype_uint16 const   )203,      (yytype_uint16 const   )205,      (yytype_uint16 const   )69,      (yytype_uint16 const   )205, 
        (yytype_uint16 const   )244,      (yytype_uint16 const   )115,      (yytype_uint16 const   )68,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )101,      (yytype_uint16 const   )98,      (yytype_uint16 const   )352, 
        (yytype_uint16 const   )352,      (yytype_uint16 const   )124,      (yytype_uint16 const   )127,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )101,      (yytype_uint16 const   )62,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )181,      (yytype_uint16 const   )358,      (yytype_uint16 const   )1,      (yytype_uint16 const   )4, 
        (yytype_uint16 const   )18,      (yytype_uint16 const   )20,      (yytype_uint16 const   )21,      (yytype_uint16 const   )22, 
        (yytype_uint16 const   )23,      (yytype_uint16 const   )24,      (yytype_uint16 const   )25,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )27,      (yytype_uint16 const   )28,      (yytype_uint16 const   )29,      (yytype_uint16 const   )30, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )74,      (yytype_uint16 const   )181,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )204,      (yytype_uint16 const   )207,      (yytype_uint16 const   )224,      (yytype_uint16 const   )225, 
        (yytype_uint16 const   )231,      (yytype_uint16 const   )310,      (yytype_uint16 const   )311,      (yytype_uint16 const   )313, 
        (yytype_uint16 const   )320,      (yytype_uint16 const   )321,      (yytype_uint16 const   )322,      (yytype_uint16 const   )323, 
        (yytype_uint16 const   )326,      (yytype_uint16 const   )327,      (yytype_uint16 const   )330,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )360,      (yytype_uint16 const   )317,      (yytype_uint16 const   )261,      (yytype_uint16 const   )186, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )347,      (yytype_uint16 const   )247,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )206,      (yytype_uint16 const   )247,      (yytype_uint16 const   )194,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )260,      (yytype_uint16 const   )1,      (yytype_uint16 const   )318, 
        (yytype_uint16 const   )320,      (yytype_uint16 const   )69,      (yytype_uint16 const   )238,      (yytype_uint16 const   )239, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )259,      (yytype_uint16 const   )117,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )225,      (yytype_uint16 const   )99,      (yytype_uint16 const   )75, 
        (yytype_uint16 const   )78,      (yytype_uint16 const   )139,      (yytype_uint16 const   )140,      (yytype_uint16 const   )141, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )136,      (yytype_uint16 const   )276,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )68,      (yytype_uint16 const   )68,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )180,      (yytype_uint16 const   )69,      (yytype_uint16 const   )98, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )99,      (yytype_uint16 const   )63,      (yytype_uint16 const   )332, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )63,      (yytype_uint16 const   )63,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )43,      (yytype_uint16 const   )69,      (yytype_uint16 const   )69,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )57,      (yytype_uint16 const   )181,      (yytype_uint16 const   )339, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )328,      (yytype_uint16 const   )43,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )310,      (yytype_uint16 const   )312,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )313,      (yytype_uint16 const   )205,      (yytype_uint16 const   )205,      (yytype_uint16 const   )205, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )25,      (yytype_uint16 const   )313,      (yytype_uint16 const   )326, 
        (yytype_uint16 const   )19,      (yytype_uint16 const   )1,      (yytype_uint16 const   )325,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )338,      (yytype_uint16 const   )1,      (yytype_uint16 const   )63,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )101,      (yytype_uint16 const   )247,      (yytype_uint16 const   )294, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )295,      (yytype_uint16 const   )261,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )69,      (yytype_uint16 const   )242,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )174,      (yytype_uint16 const   )205,      (yytype_uint16 const   )205,      (yytype_uint16 const   )142, 
        (yytype_uint16 const   )144,      (yytype_uint16 const   )174,      (yytype_uint16 const   )247,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )137,      (yytype_uint16 const   )137,      (yytype_uint16 const   )181, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )63,      (yytype_uint16 const   )325,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )340,      (yytype_uint16 const   )184,      (yytype_uint16 const   )13,      (yytype_uint16 const   )43, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )184,      (yytype_uint16 const   )69,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )1,      (yytype_uint16 const   )329,      (yytype_uint16 const   )330,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )238,      (yytype_uint16 const   )269,      (yytype_uint16 const   )275,      (yytype_uint16 const   )239, 
        (yytype_uint16 const   )272,      (yytype_uint16 const   )278,      (yytype_uint16 const   )69,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )331,      (yytype_uint16 const   )325,      (yytype_uint16 const   )184,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )247,      (yytype_uint16 const   )68,      (yytype_uint16 const   )76,      (yytype_uint16 const   )145, 
        (yytype_uint16 const   )147,      (yytype_uint16 const   )148,      (yytype_uint16 const   )149,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )145,      (yytype_uint16 const   )99,      (yytype_uint16 const   )99,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )20,      (yytype_uint16 const   )69,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )69,      (yytype_uint16 const   )184,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )242,      (yytype_uint16 const   )69,      (yytype_uint16 const   )242,      (yytype_uint16 const   )325, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )146,      (yytype_uint16 const   )147,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )64,      (yytype_uint16 const   )118,      (yytype_uint16 const   )249,      (yytype_uint16 const   )82, 
        (yytype_uint16 const   )84,      (yytype_uint16 const   )167,      (yytype_uint16 const   )128,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )334,      (yytype_uint16 const   )337,      (yytype_uint16 const   )43,      (yytype_uint16 const   )43, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )247,      (yytype_uint16 const   )247,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )147,      (yytype_uint16 const   )150,      (yytype_uint16 const   )249, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )182,      (yytype_uint16 const   )168,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )333,      (yytype_uint16 const   )340,      (yytype_uint16 const   )325, 
        (yytype_uint16 const   )11,      (yytype_uint16 const   )64,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342, 
        (yytype_uint16 const   )343,      (yytype_uint16 const   )69,      (yytype_uint16 const   )270,      (yytype_uint16 const   )273, 
        (yytype_uint16 const   )50,      (yytype_uint16 const   )69,      (yytype_uint16 const   )68,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )325,      (yytype_uint16 const   )69,      (yytype_uint16 const   )63,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )43,      (yytype_uint16 const   )101,      (yytype_uint16 const   )98,      (yytype_uint16 const   )201, 
        (yytype_uint16 const   )201,      (yytype_uint16 const   )151,      (yytype_uint16 const   )161,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )169,      (yytype_uint16 const   )68,      (yytype_uint16 const   )335,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )341,      (yytype_uint16 const   )69,      (yytype_uint16 const   )343, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )274,      (yytype_uint16 const   )51,      (yytype_uint16 const   )98, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )162,      (yytype_uint16 const   )340,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )11,      (yytype_uint16 const   )43,      (yytype_uint16 const   )101,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )320,      (yytype_uint16 const   )161,      (yytype_uint16 const   )77,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )154,      (yytype_uint16 const   )163,      (yytype_uint16 const   )164,      (yytype_uint16 const   )165, 
        (yytype_uint16 const   )166,      (yytype_uint16 const   )174,      (yytype_uint16 const   )182,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )11,      (yytype_uint16 const   )344,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )89,      (yytype_uint16 const   )155,      (yytype_uint16 const   )156,      (yytype_uint16 const   )157, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )40,      (yytype_uint16 const   )62,      (yytype_uint16 const   )65, 
        (yytype_uint16 const   )83,      (yytype_uint16 const   )64,      (yytype_uint16 const   )336,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )101,      (yytype_uint16 const   )182,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )82,      (yytype_uint16 const   )165,      (yytype_uint16 const   )166, 
        (yytype_uint16 const   )165,      (yytype_uint16 const   )165,      (yytype_uint16 const   )186,      (yytype_uint16 const   )325, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )11,      (yytype_uint16 const   )69,      (yytype_uint16 const   )63, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )182,      (yytype_uint16 const   )69,      (yytype_uint16 const   )69, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )100,      (yytype_uint16 const   )158,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )160,      (yytype_uint16 const   )161,      (yytype_uint16 const   )194,      (yytype_uint16 const   )101, 
        (yytype_uint16 const   )98,      (yytype_uint16 const   )160};
#line 2671 "c-parse.tab.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , struct yystype  const  * const  yyvaluep ) 
{ 


  {
#line 2681
  if (! yyvaluep) {
#line 2682
    return;
  }
#line 2684
  if (yytype < 103) {
    {
#line 2685
    yyprint(yyoutput, (int const   )yytoknum[yytype], *yyvaluep);
    }
  }
  {
#line 2691
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 2692
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2694
  return;
}
}
#line 2703 "c-parse.tab.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , struct yystype  const  * const  yyvaluep ) 
{ 


  {
#line 2713
  if (yytype < 103) {
    {
#line 2714
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 2716
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 2718
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 2719
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 2720
  return;
}
}
#line 2729 "c-parse.tab.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;

  {
  {
#line 2738
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 2739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2739
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 2739
      goto while_break;
    }
    {
#line 2741
    yybot = (int )*yybottom;
#line 2742
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            yybot);
#line 2739
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2744
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2745
  return;
}
}
#line 2760 "c-parse.tab.c"
static void yy_reduce_print(struct yystype *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 2769
  yynrhs = (int )yyr2[yyrule];
#line 2771
  yylno = (unsigned long )yyrline[yyrule];
#line 2772
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 2775
  yyi = 0;
  }
  {
#line 2775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2775
    if (! (yyi < yynrhs)) {
#line 2775
      goto while_break;
    }
    {
#line 2777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 2778
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (struct yystype  const  */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 2781
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2775
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2783
  return;
}
}
#line 2793 "c-parse.tab.c"
int yydebug  ;
#line 3038 "c-parse.tab.c"
static void yydestruct(char const   *yymsg , int yytype , struct yystype *yyvaluep ) 
{ 


  {
#line 3050
  if (! yymsg) {
#line 3051
    yymsg = "Deleting";
  }
  {
#line 3052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3052
    if (yydebug) {
      {
#line 3052
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 3052
      yy_symbol_print(stderr, yytype, (struct yystype  const  */* const  */)yyvaluep);
#line 3052
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 3052
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3057
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 3058
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3060
  return;
}
}
#line 3098 "c-parse.tab.c"
int yyparse(void) 
{ 
  int yychar ;
  struct yystype yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  struct yystype yyvsa[200] ;
  struct yystype *yyvs ;
  struct yystype *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  struct yystype yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  declaration cdecls ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  node tmp___0 ;
  AST_generic tEmPcast___1 ;
  AST_generic tEmPcast___2 ;
  AST_generic tEmPcast___3 ;
  declaration tmp___1 ;
  AST_generic tEmPcast___4 ;
  AST_generic tEmPcast___5 ;
  AST_generic tEmPcast___6 ;
  node tmp___2 ;
  interface intf ;
  AST_generic tEmPcast___7 ;
  AST_generic tEmPcast___8 ;
  node tmp___3 ;
  interface tmp___4 ;
  nesc_declaration intf___0 ;
  AST_generic tEmPcast___9 ;
  AST_generic tEmPcast___10 ;
  node tmp___5 ;
  declaration intfs ;
  AST_generic tEmPcast___11 ;
  AST_generic tEmPcast___12 ;
  node tmp___6 ;
  declaration tmp___7 ;
  component tmp___8 ;
  AST_generic tEmPcast___13 ;
  AST_generic tEmPcast___14 ;
  node tmp___9 ;
  component tmp___10 ;
  binary_component dummy___0 ;
  environment tmp___11 ;
  binary_component tmp___12 ;
  component c ;
  AST_generic tEmPcast___15 ;
  AST_generic tEmPcast___16 ;
  AST_generic tEmPcast___17 ;
  node tmp___13 ;
  component tmp___14 ;
  nesc_declaration comp ;
  AST_generic tEmPcast___18 ;
  AST_generic tEmPcast___19 ;
  AST_generic tEmPcast___20 ;
  node tmp___15 ;
  rp_interface tmp___16 ;
  AST_generic tEmPcast___21 ;
  AST_generic tEmPcast___22 ;
  AST_generic tEmPcast___23 ;
  node tmp___17 ;
  rp_interface tmp___18 ;
  AST_generic tEmPcast___24 ;
  AST_generic tEmPcast___25 ;
  AST_generic tEmPcast___26 ;
  AST_generic tEmPcast___27 ;
  AST_generic tEmPcast___28 ;
  node tmp___19 ;
  configuration tmp___20 ;
  AST_generic tEmPcast___29 ;
  AST_generic tEmPcast___30 ;
  AST_generic tEmPcast___31 ;
  eq_connection tmp___21 ;
  AST_generic tEmPcast___32 ;
  rp_connection tmp___22 ;
  AST_generic tEmPcast___33 ;
  rp_connection tmp___23 ;
  AST_generic tEmPcast___34 ;
  AST_generic tEmPcast___35 ;
  AST_generic tEmPcast___36 ;
  node tmp___24 ;
  module tmp___25 ;
  AST_generic tEmPcast___37 ;
  asm_stmt tmp___26 ;
  asm_decl tmp___27 ;
  bool tmp___28 ;
  AST_generic tEmPcast___38 ;
  AST_generic tEmPcast___39 ;
  node tmp___29 ;
  AST_generic tEmPcast___40 ;
  AST_generic tEmPcast___41 ;
  node tmp___30 ;
  function_call fc ;
  AST_generic tEmPcast___42 ;
  type calltype ;
  bool noerror ;
  bool tmp___31 ;
  bool tmp___32 ;
  bool tmp___33 ;
  AST_generic tEmPcast___43 ;
  expression tmp___34 ;
  expression constructor ;
  expression tmp___35 ;
  AST_generic tEmPcast___44 ;
  function_call fc___0 ;
  AST_generic tEmPcast___45 ;
  type calltype___0 ;
  bool tmp___36 ;
  bool tmp___37 ;
  bool tmp___38 ;
  expression tmp___39 ;
  AST_generic tEmPcast___46 ;
  AST_generic tEmPcast___47 ;
  ellipsis_decl tmp___40 ;
  AST_generic tEmPcast___48 ;
  typename tmp___41 ;
  AST_generic tEmPcast___49 ;
  component_typeref tmp___42 ;
  AST_generic tEmPcast___50 ;
  typeof_expr tmp___43 ;
  AST_generic tEmPcast___51 ;
  typeof_type tmp___44 ;
  AST_generic tEmPcast___52 ;
  AST_generic tEmPcast___53 ;
  node tmp___45 ;
  AST_generic tEmPcast___54 ;
  AST_generic tEmPcast___55 ;
  node tmp___46 ;
  AST_generic tEmPcast___56 ;
  attribute tmp___47 ;
  declaration d ;
  attribute tmp___48 ;
  declaration tmp___49 ;
  attribute tmp___50 ;
  declaration d___0 ;
  attribute tmp___51 ;
  declaration tmp___52 ;
  AST_generic tEmPcast___57 ;
  AST_generic tEmPcast___58 ;
  node tmp___53 ;
  AST_generic tEmPcast___59 ;
  AST_generic tEmPcast___60 ;
  word w ;
  word tmp___54 ;
  word w___0 ;
  word tmp___55 ;
  word w___1 ;
  cstring tmp___56 ;
  word tmp___57 ;
  AST_generic tEmPcast___61 ;
  AST_generic tEmPcast___62 ;
  AST_generic tEmPcast___63 ;
  expression tmp___58 ;
  expression tmp___59 ;
  expression tmp___60 ;
  AST_generic tEmPcast___64 ;
  char *tmp___61 ;
  AST_generic tEmPcast___65 ;
  char *tmp___62 ;
  AST_generic tEmPcast___66 ;
  char *tmp___63 ;
  AST_generic tEmPcast___67 ;
  AST_generic tEmPcast___68 ;
  node tmp___64 ;
  bool tmp___65 ;
  AST_generic tEmPcast___69 ;
  AST_generic tEmPcast___70 ;
  node tmp___66 ;
  bool tmp___67 ;
  AST_generic tEmPcast___71 ;
  AST_generic tEmPcast___72 ;
  node tmp___68 ;
  AST_generic tEmPcast___73 ;
  AST_generic tEmPcast___74 ;
  attribute tmp___69 ;
  attribute tmp___70 ;
  type_element tmp___71 ;
  attribute tmp___72 ;
  AST_generic tEmPcast___75 ;
  AST_generic tEmPcast___76 ;
  node tmp___73 ;
  AST_generic tEmPcast___77 ;
  AST_generic tEmPcast___78 ;
  node tmp___74 ;
  AST_generic tEmPcast___79 ;
  AST_generic tEmPcast___80 ;
  node tmp___75 ;
  AST_generic tEmPcast___81 ;
  AST_generic tEmPcast___82 ;
  declaration tmp___76 ;
  node tmp___77 ;
  AST_generic tEmPcast___83 ;
  AST_generic tEmPcast___84 ;
  node tmp___78 ;
  AST_generic tEmPcast___85 ;
  AST_generic tEmPcast___86 ;
  node tmp___79 ;
  attribute tmp___80 ;
  attribute tmp___81 ;
  attribute tmp___82 ;
  attribute tmp___83 ;
  attribute tmp___84 ;
  attribute tmp___85 ;
  AST_generic tEmPcast___87 ;
  AST_generic tEmPcast___88 ;
  function_declarator tmp___86 ;
  AST_generic tEmPcast___89 ;
  function_declarator tmp___87 ;
  AST_generic tEmPcast___90 ;
  function_declarator tmp___88 ;
  AST_generic tEmPcast___91 ;
  array_declarator tmp___89 ;
  AST_generic tEmPcast___92 ;
  array_declarator tmp___90 ;
  statement last_label ;
  AST_generic tEmPcast___93 ;
  AST_generic tEmPcast___94 ;
  node tmp___91 ;
  AST_generic tEmPcast___95 ;
  empty_stmt tmp___92 ;
  AST_generic tEmPcast___96 ;
  AST_generic tEmPcast___97 ;
  node tmp___93 ;
  AST_generic tEmPcast___98 ;
  environment tmp___94 ;
  compound_stmt tmp___95 ;
  AST_generic tEmPcast___99 ;
  environment tmp___96 ;
  AST_generic tEmPcast___100 ;
  AST_generic tEmPcast___101 ;
  node tmp___97 ;
  compound_stmt tmp___98 ;
  AST_generic tEmPcast___102 ;
  environment tmp___99 ;
  compound_stmt tmp___100 ;
  AST_generic tEmPcast___103 ;
  if_stmt tmp___101 ;
  AST_generic tEmPcast___104 ;
  dowhile_stmt tmp___102 ;
  AST_generic tEmPcast___105 ;
  AST_generic tEmPcast___106 ;
  labeled_stmt tmp___103 ;
  AST_generic tEmPcast___107 ;
  labeled_stmt tmp___104 ;
  atomic_stmt last_atomic ;
  atomic_stmt this_atomic ;
  AST_generic tEmPcast___108 ;
  AST_generic tEmPcast___109 ;
  expression_stmt tmp___105 ;
  AST_generic tEmPcast___110 ;
  int tmp___106 ;
  AST_generic tEmPcast___111 ;
  while_stmt tmp___107 ;
  AST_generic tEmPcast___112 ;
  AST_generic tEmPcast___113 ;
  AST_generic tEmPcast___114 ;
  AST_generic tEmPcast___115 ;
  AST_generic tEmPcast___116 ;
  AST_generic tEmPcast___117 ;
  switch_stmt tmp___108 ;
  AST_generic tEmPcast___118 ;
  AST_generic tEmPcast___119 ;
  AST_generic tEmPcast___120 ;
  break_stmt tmp___109 ;
  AST_generic tEmPcast___121 ;
  continue_stmt tmp___110 ;
  AST_generic tEmPcast___122 ;
  asm_stmt tmp___111 ;
  AST_generic tEmPcast___123 ;
  asm_stmt tmp___112 ;
  AST_generic tEmPcast___124 ;
  asm_stmt tmp___113 ;
  AST_generic tEmPcast___125 ;
  asm_stmt tmp___114 ;
  AST_generic tEmPcast___126 ;
  goto_stmt tmp___115 ;
  AST_generic tEmPcast___127 ;
  computed_goto_stmt tmp___116 ;
  AST_generic tEmPcast___128 ;
  empty_stmt tmp___117 ;
  AST_generic tEmPcast___129 ;
  case_label tmp___118 ;
  AST_generic tEmPcast___130 ;
  case_label tmp___119 ;
  AST_generic tEmPcast___131 ;
  default_label tmp___120 ;
  AST_generic tEmPcast___132 ;
  AST_generic tEmPcast___133 ;
  ellipsis_decl tmp___121 ;
  AST_generic tEmPcast___134 ;
  rid tmp___122 ;
  AST_generic tEmPcast___135 ;
  rid tmp___123 ;
  AST_generic tEmPcast___136 ;
  qualifier tmp___124 ;
  AST_generic tEmPcast___137 ;
  qualifier tmp___125 ;
  AST_generic tEmPcast___138 ;
  rid tmp___126 ;

  {
#line 3158
  yylen = 0;
#line 3160
  yytoken = 0;
#line 3161
  yyss = yyssa;
#line 3162
  yyvs = yyvsa;
#line 3163
  yystacksize = 200UL;
  {
#line 3165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3165
    if (yydebug) {
      {
#line 3165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 3165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3167
  yystate = 0;
#line 3168
  yyerrstatus = 0;
#line 3169
  yynerrs = 0;
#line 3170
  yychar = -2;
#line 3176
  yyssp = yyss;
#line 3177
  yyvsp = yyvs;
#line 3179
  goto yysetstate;
  yynewstate: 
#line 3187
  yyssp ++;
  yysetstate: 
#line 3190
  *yyssp = (yytype_int16 )yystate;
#line 3192
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 3195
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 3222
    if (10000UL <= yystacksize) {
#line 3223
      goto yyexhaustedlab;
    }
#line 3224
    yystacksize *= 2UL;
#line 3225
    if (10000UL < yystacksize) {
#line 3226
      yystacksize = 10000UL;
    }
    {
#line 3229
    yyss1 = yyss;
#line 3230
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(struct yystype )) + (sizeof(union yyalloc ) - 1UL));
#line 3230
    yyptr = (union yyalloc *)tmp;
    }
#line 3232
    if (! yyptr) {
#line 3233
      goto yyexhaustedlab;
    }
    {
#line 3234
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3234
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 3234
      yyss = & yyptr->yyss_alloc;
#line 3234
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 3234
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 3234
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3235
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 3235
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 3235
      yyvs = & yyptr->yyvs_alloc;
#line 3235
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 3235
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 3235
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3237
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 3238
      free((void *)yyss1);
      }
    }
#line 3243
    yyssp = (yyss + yysize) - 1;
#line 3244
    yyvsp = (yyvs + yysize) - 1;
    {
#line 3246
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3246
      if (yydebug) {
        {
#line 3246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 3246
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3249
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 3250
      goto yyabortlab;
    }
  }
  {
#line 3253
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3253
    if (yydebug) {
      {
#line 3253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 3253
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3255
  if (yystate == 78) {
#line 3256
    goto yyacceptlab;
  }
#line 3258
  goto yybackup;
  yybackup: 
#line 3269
  yyn = (int )yypact[yystate];
#line 3270
  if (yyn == -729) {
#line 3271
    goto yydefault;
  }
#line 3276
  if (yychar == -2) {
    {
#line 3278
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3278
      if (yydebug) {
        {
#line 3278
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 3278
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3279
    yychar = yylex(& yylval);
    }
  }
#line 3282
  if (yychar <= 0) {
#line 3284
    yytoken = 0;
#line 3284
    yychar = yytoken;
    {
#line 3285
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3285
      if (yydebug) {
        {
#line 3285
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 3285
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 3289
    if ((unsigned int )yychar <= 332U) {
#line 3289
      yytoken = (int )yytranslate[yychar];
    } else {
#line 3289
      yytoken = 2;
    }
    {
#line 3290
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3290
      if (yydebug) {
        {
#line 3290
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 3290
        yy_symbol_print(stderr, yytoken, (struct yystype  const  */* const  */)(& yylval));
#line 3290
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 3290
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 3295
  yyn += yytoken;
#line 3296
  if (yyn < 0) {
#line 3297
    goto yydefault;
  } else
#line 3296
  if (4209 < yyn) {
#line 3297
    goto yydefault;
  } else
#line 3296
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 3297
    goto yydefault;
  }
#line 3298
  yyn = (int )yytable[yyn];
#line 3299
  if (yyn <= 0) {
#line 3301
    if (yyn == 0) {
#line 3302
      goto yyerrlab;
    } else
#line 3301
    if (yyn == -604) {
#line 3302
      goto yyerrlab;
    }
#line 3303
    yyn = - yyn;
#line 3304
    goto yyreduce;
  }
#line 3309
  if (yyerrstatus) {
#line 3310
    yyerrstatus --;
  }
  {
#line 3313
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3313
    if (yydebug) {
      {
#line 3313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 3313
      yy_symbol_print(stderr, yytoken, (struct yystype  const  */* const  */)(& yylval));
#line 3313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 3313
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3316
  yychar = -2;
#line 3318
  yystate = yyn;
#line 3319
  yyvsp ++;
#line 3319
  *yyvsp = yylval;
#line 3321
  goto yynewstate;
  yydefault: 
#line 3328
  yyn = (int )yydefact[yystate];
#line 3329
  if (yyn == 0) {
#line 3330
    goto yyerrlab;
  }
#line 3331
  goto yyreduce;
  yyreduce: 
#line 3339
  yylen = (int )yyr2[yyn];
#line 3349
  yyval = *(yyvsp + (1 - yylen));
  {
#line 3352
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3352
    if (yydebug) {
      {
#line 3352
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 3352
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 3355
  if (yyn == 2) {
#line 3355
    goto case_2;
  }
#line 468
  if (yyn == 3) {
#line 468 "c-parse.y"
    goto case_3;
  }
#line 469
  if (yyn == 4) {
#line 469
    goto case_4;
  }
#line 472
  if (yyn == 5) {
#line 472
    goto case_5;
  }
#line 473
  if (yyn == 6) {
#line 473
    goto case_6;
  }
#line 474
  if (yyn == 7) {
#line 474
    goto case_7;
  }
#line 475
  if (yyn == 8) {
#line 475
    goto case_8;
  }
#line 476
  if (yyn == 9) {
#line 476
    goto case_9;
  }
#line 477
  if (yyn == 10) {
#line 477
    goto case_10;
  }
#line 481
  if (yyn == 12) {
#line 481
    goto case_12;
  }
#line 486
  if (yyn == 15) {
#line 486
    goto case_15;
  }
#line 495
  if (yyn == 16) {
#line 495
    goto case_16;
  }
#line 500
  if (yyn == 17) {
#line 500
    goto case_17;
  }
#line 502
  if (yyn == 18) {
#line 502
    goto case_18;
  }
#line 510
  if (yyn == 19) {
#line 510
    goto case_19;
  }
#line 514
  if (yyn == 20) {
#line 514
    goto case_20;
  }
#line 523
  if (yyn == 21) {
#line 523
    goto case_21;
  }
#line 527
  if (yyn == 22) {
#line 527
    goto case_22;
  }
#line 542
  if (yyn == 24) {
#line 542
    goto case_24;
  }
#line 548
  if (yyn == 25) {
#line 548
    goto case_25;
  }
#line 553
  if (yyn == 26) {
#line 553
    goto case_26;
  }
#line 557
  if (yyn == 27) {
#line 557
    goto case_27;
  }
#line 561
  if (yyn == 29) {
#line 561
    goto case_29;
  }
#line 565
  if (yyn == 30) {
#line 565
    goto case_30;
  }
#line 566
  if (yyn == 31) {
#line 566
    goto case_31;
  }
#line 573
  if (yyn == 32) {
#line 573
    goto case_32;
  }
#line 574
  if (yyn == 36) {
#line 574
    goto case_36;
  }
#line 588
  if (yyn == 37) {
#line 588
    goto case_37;
  }
#line 592
  if (yyn == 38) {
#line 592
    goto case_38;
  }
#line 599
  if (yyn == 39) {
#line 599
    goto case_39;
  }
#line 608
  if (yyn == 40) {
#line 608
    goto case_40;
  }
#line 612
  if (yyn == 41) {
#line 612
    goto case_41;
  }
#line 616
  if (yyn == 42) {
#line 616
    goto case_42;
  }
#line 620
  if (yyn == 43) {
#line 620
    goto case_43;
  }
#line 627
  if (yyn == 44) {
#line 627
    goto case_44;
  }
#line 631
  if (yyn == 45) {
#line 631
    goto case_45;
  }
#line 637
  if (yyn == 46) {
#line 637
    goto case_46;
  }
#line 640
  if (yyn == 47) {
#line 640
    goto case_47;
  }
#line 641
  if (yyn == 48) {
#line 641
    goto case_48;
  }
#line 653
  if (yyn == 49) {
#line 653
    goto case_49;
  }
#line 669
  if (yyn == 50) {
#line 669
    goto case_50;
  }
#line 673
  if (yyn == 53) {
#line 673
    goto case_53;
  }
#line 680
  if (yyn == 54) {
#line 680
    goto case_54;
  }
#line 689
  if (yyn == 55) {
#line 689
    goto case_55;
  }
#line 691
  if (yyn == 56) {
#line 691
    goto case_56;
  }
#line 693
  if (yyn == 57) {
#line 693
    goto case_57;
  }
#line 695
  if (yyn == 58) {
#line 695
    goto case_58;
  }
#line 700
  if (yyn == 59) {
#line 700
    goto case_59;
  }
#line 705
  if (yyn == 60) {
#line 705
    goto case_60;
  }
#line 706
  if (yyn == 63) {
#line 706
    goto case_63;
  }
#line 712
  if (yyn == 64) {
#line 712
    goto case_64;
  }
#line 712
  if (yyn == 65) {
#line 712
    goto case_65;
  }
#line 716
  if (yyn == 66) {
#line 716
    goto case_66;
  }
#line 718
  if (yyn == 67) {
#line 718
    goto case_67;
  }
#line 721
  if (yyn == 68) {
#line 721
    goto case_68;
  }
#line 723
  if (yyn == 70) {
#line 723
    goto case_70;
  }
#line 727
  if (yyn == 71) {
#line 727
    goto case_71;
  }
#line 732
  if (yyn == 74) {
#line 732
    goto case_74;
  }
#line 742
  if (yyn == 75) {
#line 742
    goto case_75;
  }
#line 749
  if (yyn == 77) {
#line 749
    goto case_77;
  }
#line 754
  if (yyn == 78) {
#line 754
    goto case_78;
  }
#line 762
  if (yyn == 79) {
#line 762
    goto case_79;
  }
#line 766
  if (yyn == 80) {
#line 766
    goto case_80;
  }
#line 768
  if (yyn == 82) {
#line 768
    goto case_82;
  }
#line 773
  if (yyn == 83) {
#line 773
    goto case_83;
  }
#line 777
  if (yyn == 84) {
#line 777
    goto case_84;
  }
#line 782
  if (yyn == 85) {
#line 782
    goto case_85;
  }
#line 785
  if (yyn == 86) {
#line 785
    goto case_86;
  }
#line 789
  if (yyn == 88) {
#line 789
    goto case_88;
  }
#line 794
  if (yyn == 89) {
#line 794
    goto case_89;
  }
#line 795
  if (yyn == 90) {
#line 795
    goto case_90;
  }
#line 800
  if (yyn == 91) {
#line 800
    goto case_91;
  }
#line 803
  if (yyn == 92) {
#line 803
    goto case_92;
  }
#line 807
  if (yyn == 95) {
#line 807
    goto case_95;
  }
#line 813
  if (yyn == 96) {
#line 813
    goto case_96;
  }
#line 818
  if (yyn == 98) {
#line 818
    goto case_98;
  }
#line 823
  if (yyn == 99) {
#line 823
    goto case_99;
  }
#line 827
  if (yyn == 100) {
#line 827
    goto case_100;
  }
#line 828
  if (yyn == 101) {
#line 828
    goto case_101;
  }
#line 832
  if (yyn == 103) {
#line 832
    goto case_103;
  }
#line 834
  if (yyn == 104) {
#line 834
    goto case_104;
  }
#line 839
  if (yyn == 105) {
#line 839
    goto case_105;
  }
#line 841
  if (yyn == 106) {
#line 841
    goto case_106;
  }
#line 843
  if (yyn == 107) {
#line 843
    goto case_107;
  }
#line 850
  if (yyn == 108) {
#line 850
    goto case_108;
  }
#line 852
  if (yyn == 109) {
#line 852
    goto case_109;
  }
#line 857
  if (yyn == 110) {
#line 857
    goto case_110;
  }
#line 859
  if (yyn == 111) {
#line 859
    goto case_111;
  }
#line 862
  if (yyn == 112) {
#line 862
    goto case_112;
  }
#line 865
  if (yyn == 113) {
#line 865
    goto case_113;
  }
#line 872
  if (yyn == 114) {
#line 872
    goto case_114;
  }
#line 872
  if (yyn == 115) {
#line 872
    goto case_115;
  }
#line 873
  if (yyn == 116) {
#line 873
    goto case_116;
  }
#line 874
  if (yyn == 119) {
#line 874
    goto case_119;
  }
#line 884
  if (yyn == 120) {
#line 884
    goto case_120;
  }
#line 886
  if (yyn == 121) {
#line 886
    goto case_121;
  }
#line 896
  if (yyn == 123) {
#line 896
    goto case_123;
  }
#line 902
  if (yyn == 124) {
#line 902
    goto case_124;
  }
#line 904
  if (yyn == 125) {
#line 904
    goto case_125;
  }
#line 907
  if (yyn == 126) {
#line 907
    goto case_126;
  }
#line 908
  if (yyn == 127) {
#line 908
    goto case_127;
  }
#line 909
  if (yyn == 128) {
#line 909
    goto case_128;
  }
#line 913
  if (yyn == 130) {
#line 913
    goto case_130;
  }
#line 919
  if (yyn == 131) {
#line 919
    goto case_131;
  }
#line 923
  if (yyn == 132) {
#line 923
    goto case_132;
  }
#line 924
  if (yyn == 133) {
#line 924
    goto case_133;
  }
#line 925
  if (yyn == 134) {
#line 925
    goto case_134;
  }
#line 938
  if (yyn == 135) {
#line 938
    goto case_135;
  }
#line 940
  if (yyn == 136) {
#line 940
    goto case_136;
  }
#line 943
  if (yyn == 139) {
#line 943
    goto case_139;
  }
#line 952
  if (yyn == 140) {
#line 952
    goto case_140;
  }
#line 956
  if (yyn == 141) {
#line 956
    goto case_141;
  }
#line 960
  if (yyn == 142) {
#line 960
    goto case_142;
  }
#line 962
  if (yyn == 143) {
#line 962
    goto case_143;
  }
#line 964
  if (yyn == 144) {
#line 964
    goto case_144;
  }
#line 966
  if (yyn == 145) {
#line 966
    goto case_145;
  }
#line 968
  if (yyn == 146) {
#line 968
    goto case_146;
  }
#line 970
  if (yyn == 147) {
#line 970
    goto case_147;
  }
#line 972
  if (yyn == 148) {
#line 972
    goto case_148;
  }
#line 974
  if (yyn == 149) {
#line 974
    goto case_149;
  }
#line 976
  if (yyn == 150) {
#line 976
    goto case_150;
  }
#line 983
  if (yyn == 151) {
#line 983
    goto case_151;
  }
#line 988
  if (yyn == 153) {
#line 988
    goto case_153;
  }
#line 994
  if (yyn == 154) {
#line 994
    goto case_154;
  }
#line 999
  if (yyn == 155) {
#line 999
    goto case_155;
  }
#line 1001
  if (yyn == 156) {
#line 1001
    goto case_156;
  }
#line 1005
  if (yyn == 157) {
#line 1005
    goto case_157;
  }
#line 1006
  if (yyn == 158) {
#line 1006
    goto case_158;
  }
#line 1007
  if (yyn == 160) {
#line 1007
    goto case_160;
  }
#line 1043
  if (yyn == 161) {
#line 1043
    goto case_161;
  }
#line 1045
  if (yyn == 162) {
#line 1045
    goto case_162;
  }
#line 1049
  if (yyn == 163) {
#line 1049
    goto case_163;
  }
#line 1055
  if (yyn == 164) {
#line 1055
    goto case_164;
  }
#line 1061
  if (yyn == 165) {
#line 1061
    goto case_165;
  }
#line 1071
  if (yyn == 166) {
#line 1071
    goto case_166;
  }
#line 1074
  if (yyn == 167) {
#line 1074
    goto case_167;
  }
#line 1077
  if (yyn == 168) {
#line 1077
    goto case_168;
  }
#line 1080
  if (yyn == 169) {
#line 1080
    goto case_169;
  }
#line 1084
  if (yyn == 170) {
#line 1084
    goto case_170;
  }
#line 1088
  if (yyn == 172) {
#line 1088
    goto case_172;
  }
#line 1094
  if (yyn == 173) {
#line 1094
    goto case_173;
  }
#line 1099
  if (yyn == 174) {
#line 1099
    goto case_174;
  }
#line 1110
  if (yyn == 176) {
#line 1110
    goto case_176;
  }
#line 1116
  if (yyn == 177) {
#line 1116
    goto case_177;
  }
#line 1118
  if (yyn == 178) {
#line 1118
    goto case_178;
  }
#line 1120
  if (yyn == 179) {
#line 1120
    goto case_179;
  }
#line 1122
  if (yyn == 180) {
#line 1122
    goto case_180;
  }
#line 1124
  if (yyn == 181) {
#line 1124
    goto case_181;
  }
#line 1126
  if (yyn == 182) {
#line 1126
    goto case_182;
  }
#line 1128
  if (yyn == 183) {
#line 1128
    goto case_183;
  }
#line 1130
  if (yyn == 184) {
#line 1130
    goto case_184;
  }
#line 1132
  if (yyn == 185) {
#line 1132
    goto case_185;
  }
#line 1134
  if (yyn == 186) {
#line 1134
    goto case_186;
  }
#line 1136
  if (yyn == 187) {
#line 1136
    goto case_187;
  }
#line 1138
  if (yyn == 188) {
#line 1138
    goto case_188;
  }
#line 1140
  if (yyn == 189) {
#line 1140
    goto case_189;
  }
#line 1142
  if (yyn == 190) {
#line 1142
    goto case_190;
  }
#line 1144
  if (yyn == 191) {
#line 1144
    goto case_191;
  }
#line 1146
  if (yyn == 192) {
#line 1146
    goto case_192;
  }
#line 1148
  if (yyn == 193) {
#line 1148
    goto case_193;
  }
#line 1152
  if (yyn == 194) {
#line 1152
    goto case_194;
  }
#line 1154
  if (yyn == 195) {
#line 1154
    goto case_195;
  }
#line 1156
  if (yyn == 196) {
#line 1156
    goto case_196;
  }
#line 1158
  if (yyn == 197) {
#line 1158
    goto case_197;
  }
#line 1167
  if (yyn == 198) {
#line 1167
    goto case_198;
  }
#line 1168
  if (yyn == 199) {
#line 1168
    goto case_199;
  }
#line 1169
  if (yyn == 200) {
#line 1169
    goto case_200;
  }
#line 1171
  if (yyn == 201) {
#line 1171
    goto case_201;
  }
#line 1173
  if (yyn == 202) {
#line 1173
    goto case_202;
  }
#line 1181
  if (yyn == 203) {
#line 1181
    goto case_203;
  }
#line 1188
  if (yyn == 204) {
#line 1188
    goto case_204;
  }
#line 1206
  if (yyn == 205) {
#line 1206
    goto case_205;
  }
#line 1208
  if (yyn == 206) {
#line 1208
    goto case_206;
  }
#line 1210
  if (yyn == 207) {
#line 1210
    goto case_207;
  }
#line 1212
  if (yyn == 208) {
#line 1212
    goto case_208;
  }
#line 1214
  if (yyn == 209) {
#line 1214
    goto case_209;
  }
#line 1217
  if (yyn == 210) {
#line 1217
    goto case_210;
  }
#line 1219
  if (yyn == 211) {
#line 1219
    goto case_211;
  }
#line 1221
  if (yyn == 212) {
#line 1221
    goto case_212;
  }
#line 1225
  if (yyn == 213) {
#line 1225
    goto case_213;
  }
#line 1226
  if (yyn == 214) {
#line 1226
    goto case_214;
  }
#line 1231
  if (yyn == 215) {
#line 1231
    goto case_215;
  }
#line 1234
  if (yyn == 216) {
#line 1234
    goto case_216;
  }
#line 1235
  if (yyn == 217) {
#line 1235
    goto case_217;
  }
#line 1239
  if (yyn == 219) {
#line 1239
    goto case_219;
  }
#line 1246
  if (yyn == 221) {
#line 1246
    goto case_221;
  }
#line 1254
  if (yyn == 222) {
#line 1254
    goto case_222;
  }
#line 1263
  if (yyn == 223) {
#line 1263
    goto case_223;
  }
#line 1265
  if (yyn == 224) {
#line 1265
    goto case_224;
  }
#line 1269
  if (yyn == 225) {
#line 1269
    goto case_225;
  }
#line 1272
  if (yyn == 227) {
#line 1272
    goto case_227;
  }
#line 1281
  if (yyn == 228) {
#line 1281
    goto case_228;
  }
#line 1282
  if (yyn == 229) {
#line 1282
    goto case_229;
  }
#line 1283
  if (yyn == 230) {
#line 1283
    goto case_230;
  }
#line 1296
  if (yyn == 231) {
#line 1296
    goto case_231;
  }
#line 1303
  if (yyn == 232) {
#line 1303
    goto case_232;
  }
#line 1308
  if (yyn == 233) {
#line 1308
    goto case_233;
  }
#line 1310
  if (yyn == 234) {
#line 1310
    goto case_234;
  }
#line 1313
  if (yyn == 235) {
#line 1313
    goto case_235;
  }
#line 1316
  if (yyn == 236) {
#line 1316
    goto case_236;
  }
#line 1319
  if (yyn == 237) {
#line 1319
    goto case_237;
  }
#line 1321
  if (yyn == 239) {
#line 1321
    goto case_239;
  }
#line 1378
  if (yyn == 240) {
#line 1378
    goto case_240;
  }
#line 1380
  if (yyn == 241) {
#line 1380
    goto case_241;
  }
#line 1385
  if (yyn == 242) {
#line 1385
    goto case_242;
  }
#line 1390
  if (yyn == 243) {
#line 1390
    goto case_243;
  }
#line 1392
  if (yyn == 247) {
#line 1392
    goto case_247;
  }
#line 1403
  if (yyn == 248) {
#line 1403
    goto case_248;
  }
#line 1405
  if (yyn == 249) {
#line 1405
    goto case_249;
  }
#line 1407
  if (yyn == 250) {
#line 1407
    goto case_250;
  }
#line 1409
  if (yyn == 251) {
#line 1409
    goto case_251;
  }
#line 1411
  if (yyn == 252) {
#line 1411
    goto case_252;
  }
#line 1413
  if (yyn == 254) {
#line 1413
    goto case_254;
  }
#line 1419
  if (yyn == 255) {
#line 1419
    goto case_255;
  }
#line 1421
  if (yyn == 256) {
#line 1421
    goto case_256;
  }
#line 1423
  if (yyn == 257) {
#line 1423
    goto case_257;
  }
#line 1425
  if (yyn == 258) {
#line 1425
    goto case_258;
  }
#line 1427
  if (yyn == 259) {
#line 1427
    goto case_259;
  }
#line 1432
  if (yyn == 260) {
#line 1432
    goto case_260;
  }
#line 1434
  if (yyn == 261) {
#line 1434
    goto case_261;
  }
#line 1436
  if (yyn == 262) {
#line 1436
    goto case_262;
  }
#line 1438
  if (yyn == 263) {
#line 1438
    goto case_263;
  }
#line 1440
  if (yyn == 264) {
#line 1440
    goto case_264;
  }
#line 1442
  if (yyn == 265) {
#line 1442
    goto case_265;
  }
#line 1447
  if (yyn == 266) {
#line 1447
    goto case_266;
  }
#line 1449
  if (yyn == 267) {
#line 1449
    goto case_267;
  }
#line 1451
  if (yyn == 268) {
#line 1451
    goto case_268;
  }
#line 1453
  if (yyn == 269) {
#line 1453
    goto case_269;
  }
#line 1455
  if (yyn == 271) {
#line 1455
    goto case_271;
  }
#line 1461
  if (yyn == 272) {
#line 1461
    goto case_272;
  }
#line 1463
  if (yyn == 273) {
#line 1463
    goto case_273;
  }
#line 1465
  if (yyn == 274) {
#line 1465
    goto case_274;
  }
#line 1467
  if (yyn == 275) {
#line 1467
    goto case_275;
  }
#line 1469
  if (yyn == 276) {
#line 1469
    goto case_276;
  }
#line 1471
  if (yyn == 277) {
#line 1471
    goto case_277;
  }
#line 1476
  if (yyn == 278) {
#line 1476
    goto case_278;
  }
#line 1481
  if (yyn == 279) {
#line 1481
    goto case_279;
  }
#line 1483
  if (yyn == 280) {
#line 1483
    goto case_280;
  }
#line 1485
  if (yyn == 281) {
#line 1485
    goto case_281;
  }
#line 1487
  if (yyn == 282) {
#line 1487
    goto case_282;
  }
#line 1489
  if (yyn == 283) {
#line 1489
    goto case_283;
  }
#line 1491
  if (yyn == 284) {
#line 1491
    goto case_284;
  }
#line 1496
  if (yyn == 285) {
#line 1496
    goto case_285;
  }
#line 1501
  if (yyn == 286) {
#line 1501
    goto case_286;
  }
#line 1503
  if (yyn == 287) {
#line 1503
    goto case_287;
  }
#line 1505
  if (yyn == 288) {
#line 1505
    goto case_288;
  }
#line 1507
  if (yyn == 289) {
#line 1507
    goto case_289;
  }
#line 1509
  if (yyn == 290) {
#line 1509
    goto case_290;
  }
#line 1511
  if (yyn == 291) {
#line 1511
    goto case_291;
  }
#line 1513
  if (yyn == 292) {
#line 1513
    goto case_292;
  }
#line 1515
  if (yyn == 293) {
#line 1515
    goto case_293;
  }
#line 1517
  if (yyn == 294) {
#line 1517
    goto case_294;
  }
#line 1519
  if (yyn == 295) {
#line 1519
    goto case_295;
  }
#line 1524
  if (yyn == 296) {
#line 1524
    goto case_296;
  }
#line 1526
  if (yyn == 297) {
#line 1526
    goto case_297;
  }
#line 1528
  if (yyn == 298) {
#line 1528
    goto case_298;
  }
#line 1530
  if (yyn == 299) {
#line 1530
    goto case_299;
  }
#line 1532
  if (yyn == 300) {
#line 1532
    goto case_300;
  }
#line 1537
  if (yyn == 301) {
#line 1537
    goto case_301;
  }
#line 1539
  if (yyn == 302) {
#line 1539
    goto case_302;
  }
#line 1541
  if (yyn == 303) {
#line 1541
    goto case_303;
  }
#line 1543
  if (yyn == 304) {
#line 1543
    goto case_304;
  }
#line 1545
  if (yyn == 305) {
#line 1545
    goto case_305;
  }
#line 1547
  if (yyn == 306) {
#line 1547
    goto case_306;
  }
#line 1549
  if (yyn == 307) {
#line 1549
    goto case_307;
  }
#line 1551
  if (yyn == 308) {
#line 1551
    goto case_308;
  }
#line 1553
  if (yyn == 309) {
#line 1553
    goto case_309;
  }
#line 1555
  if (yyn == 310) {
#line 1555
    goto case_310;
  }
#line 1560
  if (yyn == 311) {
#line 1560
    goto case_311;
  }
#line 1562
  if (yyn == 312) {
#line 1562
    goto case_312;
  }
#line 1564
  if (yyn == 313) {
#line 1564
    goto case_313;
  }
#line 1566
  if (yyn == 314) {
#line 1566
    goto case_314;
  }
#line 1568
  if (yyn == 351) {
#line 1568
    goto case_351;
  }
#line 1635
  if (yyn == 359) {
#line 1635
    goto case_359;
  }
#line 1682
  if (yyn == 360) {
#line 1682
    goto case_360;
  }
#line 1687
  if (yyn == 361) {
#line 1687
    goto case_361;
  }
#line 1689
  if (yyn == 362) {
#line 1689
    goto case_362;
  }
#line 1691
  if (yyn == 363) {
#line 1691
    goto case_363;
  }
#line 1696
  if (yyn == 364) {
#line 1696
    goto case_364;
  }
#line 1700
  if (yyn == 366) {
#line 1700
    goto case_366;
  }
#line 1706
  if (yyn == 367) {
#line 1706
    goto case_367;
  }
#line 1710
  if (yyn == 368) {
#line 1710
    goto case_368;
  }
#line 1712
  if (yyn == 369) {
#line 1712
    goto case_369;
  }
#line 1717
  if (yyn == 370) {
#line 1717
    goto case_370;
  }
#line 1720
  if (yyn == 371) {
#line 1720
    goto case_371;
  }
#line 1727
  if (yyn == 372) {
#line 1727
    goto case_372;
  }
#line 1731
  if (yyn == 373) {
#line 1731
    goto case_373;
  }
#line 1735
  if (yyn == 374) {
#line 1735
    goto case_374;
  }
#line 1742
  if (yyn == 375) {
#line 1742
    goto case_375;
  }
#line 1746
  if (yyn == 376) {
#line 1746
    goto case_376;
  }
#line 1750
  if (yyn == 377) {
#line 1750
    goto case_377;
  }
#line 1755
  if (yyn == 378) {
#line 1755
    goto case_378;
  }
#line 1757
  if (yyn == 379) {
#line 1757
    goto case_379;
  }
#line 1761
  if (yyn == 380) {
#line 1761
    goto case_380;
  }
#line 1765
  if (yyn == 381) {
#line 1765
    goto case_381;
  }
#line 1767
  if (yyn == 382) {
#line 1767
    goto case_382;
  }
#line 1772
  if (yyn == 383) {
#line 1772
    goto case_383;
  }
#line 1774
  if (yyn == 384) {
#line 1774
    goto case_384;
  }
#line 1779
  if (yyn == 385) {
#line 1779
    goto case_385;
  }
#line 1780
  if (yyn == 387) {
#line 1780
    goto case_387;
  }
#line 1787
  if (yyn == 388) {
#line 1787
    goto case_388;
  }
#line 1790
  if (yyn == 389) {
#line 1790
    goto case_389;
  }
#line 1793
  if (yyn == 390) {
#line 1793
    goto case_390;
  }
#line 1797
  if (yyn == 391) {
#line 1797
    goto case_391;
  }
#line 1798
  if (yyn == 392) {
#line 1798
    goto case_392;
  }
#line 1799
  if (yyn == 393) {
#line 1799
    goto case_393;
  }
#line 1804
  if (yyn == 394) {
#line 1804
    goto case_394;
  }
#line 1806
  if (yyn == 395) {
#line 1806
    goto case_395;
  }
#line 1811
  if (yyn == 396) {
#line 1811
    goto case_396;
  }
#line 1813
  if (yyn == 397) {
#line 1813
    goto case_397;
  }
#line 1816
  if (yyn == 398) {
#line 1816
    goto case_398;
  }
#line 1820
  if (yyn == 399) {
#line 1820
    goto case_399;
  }
#line 1823
  if (yyn == 400) {
#line 1823
    goto case_400;
  }
#line 1828
  if (yyn == 401) {
#line 1828
    goto case_401;
  }
#line 1830
  if (yyn == 402) {
#line 1830
    goto case_402;
  }
#line 1835
  if (yyn == 404) {
#line 1835
    goto case_404;
  }
#line 1844
  if (yyn == 405) {
#line 1844
    goto case_405;
  }
#line 1846
  if (yyn == 406) {
#line 1846
    goto case_406;
  }
#line 1848
  if (yyn == 407) {
#line 1848
    goto case_407;
  }
#line 1850
  if (yyn == 408) {
#line 1850
    goto case_408;
  }
#line 1856
  if (yyn == 409) {
#line 1856
    goto case_409;
  }
#line 1858
  if (yyn == 410) {
#line 1858
    goto case_410;
  }
#line 1860
  if (yyn == 411) {
#line 1860
    goto case_411;
  }
#line 1862
  if (yyn == 412) {
#line 1862
    goto case_412;
  }
#line 1870
  if (yyn == 413) {
#line 1870
    goto case_413;
  }
#line 1871
  if (yyn == 415) {
#line 1871
    goto case_415;
  }
#line 1876
  if (yyn == 416) {
#line 1876
    goto case_416;
  }
#line 1885
  if (yyn == 417) {
#line 1885
    goto case_417;
  }
#line 1889
  if (yyn == 418) {
#line 1889
    goto case_418;
  }
#line 1893
  if (yyn == 419) {
#line 1893
    goto case_419;
  }
#line 1895
  if (yyn == 421) {
#line 1895
    goto case_421;
  }
#line 1901
  if (yyn == 422) {
#line 1901
    goto case_422;
  }
#line 1904
  if (yyn == 423) {
#line 1904
    goto case_423;
  }
#line 1906
  if (yyn == 424) {
#line 1906
    goto case_424;
  }
#line 1907
  if (yyn == 426) {
#line 1907
    goto case_426;
  }
#line 1912
  if (yyn == 427) {
#line 1912
    goto case_427;
  }
#line 1917
  if (yyn == 428) {
#line 1917
    goto case_428;
  }
#line 1924
  if (yyn == 429) {
#line 1924
    goto case_429;
  }
#line 1926
  if (yyn == 430) {
#line 1926
    goto case_430;
  }
#line 1939
  if (yyn == 431) {
#line 1939
    goto case_431;
  }
#line 1941
  if (yyn == 432) {
#line 1941
    goto case_432;
  }
#line 1949
  if (yyn == 433) {
#line 1949
    goto case_433;
  }
#line 1962
  if (yyn == 434) {
#line 1962
    goto case_434;
  }
#line 1964
  if (yyn == 435) {
#line 1964
    goto case_435;
  }
#line 1972
  if (yyn == 438) {
#line 1972
    goto case_438;
  }
#line 1987
  if (yyn == 439) {
#line 1987
    goto case_439;
  }
#line 1989
  if (yyn == 440) {
#line 1989
    goto case_440;
  }
#line 1991
  if (yyn == 441) {
#line 1991
    goto case_441;
  }
#line 1992
  if (yyn == 442) {
#line 1992
    goto case_442;
  }
#line 1996
  if (yyn == 443) {
#line 1996
    goto case_443;
  }
#line 2005
  if (yyn == 444) {
#line 2005
    goto case_444;
  }
#line 2007
  if (yyn == 445) {
#line 2007
    goto case_445;
  }
#line 2009
  if (yyn == 446) {
#line 2009
    goto case_446;
  }
#line 2018
  if (yyn == 447) {
#line 2018
    goto case_447;
  }
#line 2020
  if (yyn == 448) {
#line 2020
    goto case_448;
  }
#line 2022
  if (yyn == 449) {
#line 2022
    goto case_449;
  }
#line 2024
  if (yyn == 450) {
#line 2024
    goto case_450;
  }
#line 2028
  if (yyn == 451) {
#line 2028
    goto case_451;
  }
#line 2032
  if (yyn == 452) {
#line 2032
    goto case_452;
  }
#line 2038
  if (yyn == 453) {
#line 2038
    goto case_453;
  }
#line 2041
  if (yyn == 454) {
#line 2041
    goto case_454;
  }
#line 2048
  if (yyn == 455) {
#line 2048
    goto case_455;
  }
#line 2050
  if (yyn == 456) {
#line 2050
    goto case_456;
  }
#line 2054
  if (yyn == 457) {
#line 2054
    goto case_457;
  }
#line 2056
  if (yyn == 458) {
#line 2056
    goto case_458;
  }
#line 2060
  if (yyn == 459) {
#line 2060
    goto case_459;
  }
#line 2062
  if (yyn == 460) {
#line 2062
    goto case_460;
  }
#line 2064
  if (yyn == 461) {
#line 2064
    goto case_461;
  }
#line 2066
  if (yyn == 462) {
#line 2066
    goto case_462;
  }
#line 2068
  if (yyn == 463) {
#line 2068
    goto case_463;
  }
#line 2072
  if (yyn == 464) {
#line 2072
    goto case_464;
  }
#line 2073
  if (yyn == 465) {
#line 2073
    goto case_465;
  }
#line 2074
  if (yyn == 466) {
#line 2074
    goto case_466;
  }
#line 2075
  if (yyn == 470) {
#line 2075
    goto case_470;
  }
#line 2086
  if (yyn == 471) {
#line 2086
    goto case_471;
  }
#line 2091
  if (yyn == 472) {
#line 2091
    goto case_472;
  }
#line 2094
  if (yyn == 473) {
#line 2094
    goto case_473;
  }
#line 2099
  if (yyn == 474) {
#line 2099
    goto case_474;
  }
#line 2101
  if (yyn == 475) {
#line 2101
    goto case_475;
  }
#line 2105
  if (yyn == 476) {
#line 2105
    goto case_476;
  }
#line 2119
  if (yyn == 477) {
#line 2119
    goto case_477;
  }
#line 2124
  if (yyn == 478) {
#line 2124
    goto case_478;
  }
#line 2126
  if (yyn == 479) {
#line 2126
    goto case_479;
  }
#line 2131
  if (yyn == 480) {
#line 2131
    goto case_480;
  }
#line 2133
  if (yyn == 481) {
#line 2133
    goto case_481;
  }
#line 2135
  if (yyn == 483) {
#line 2135
    goto case_483;
  }
#line 2141
  if (yyn == 485) {
#line 2141
    goto case_485;
  }
#line 2149
  if (yyn == 486) {
#line 2149
    goto case_486;
  }
#line 2155
  if (yyn == 487) {
#line 2155
    goto case_487;
  }
#line 2158
  if (yyn == 488) {
#line 2158
    goto case_488;
  }
#line 2161
  if (yyn == 489) {
#line 2161
    goto case_489;
  }
#line 2167
  if (yyn == 490) {
#line 2167
    goto case_490;
  }
#line 2170
  if (yyn == 491) {
#line 2170
    goto case_491;
  }
#line 2173
  if (yyn == 493) {
#line 2173
    goto case_493;
  }
#line 2179
  if (yyn == 494) {
#line 2179
    goto case_494;
  }
#line 2181
  if (yyn == 495) {
#line 2181
    goto case_495;
  }
#line 2187
  if (yyn == 496) {
#line 2187
    goto case_496;
  }
#line 2189
  if (yyn == 497) {
#line 2189
    goto case_497;
  }
#line 2194
  if (yyn == 498) {
#line 2194
    goto case_498;
  }
#line 2196
  if (yyn == 499) {
#line 2196
    goto case_499;
  }
#line 2201
  if (yyn == 504) {
#line 2201
    goto case_504;
  }
#line 2213
  if (yyn == 505) {
#line 2213
    goto case_505;
  }
#line 2218
  if (yyn == 506) {
#line 2218
    goto case_506;
  }
#line 2220
  if (yyn == 507) {
#line 2220
    goto case_507;
  }
#line 2225
  if (yyn == 508) {
#line 2225
    goto case_508;
  }
#line 2227
  if (yyn == 509) {
#line 2227
    goto case_509;
  }
#line 2229
  if (yyn == 514) {
#line 2229
    goto case_514;
  }
#line 2245
  if (yyn == 515) {
#line 2245
    goto case_515;
  }
#line 2248
  if (yyn == 516) {
#line 2248
    goto case_516;
  }
#line 2254
  if (yyn == 517) {
#line 2254
    goto case_517;
  }
#line 2259
  if (yyn == 518) {
#line 2259
    goto case_518;
  }
#line 2261
  if (yyn == 519) {
#line 2261
    goto case_519;
  }
#line 2281
  if (yyn == 521) {
#line 2281
    goto case_521;
  }
#line 2287
  if (yyn == 522) {
#line 2287
    goto case_522;
  }
#line 2289
  if (yyn == 523) {
#line 2289
    goto case_523;
  }
#line 2293
  if (yyn == 526) {
#line 2293
    goto case_526;
  }
#line 2302
  if (yyn == 527) {
#line 2302
    goto case_527;
  }
#line 2308
  if (yyn == 528) {
#line 2308
    goto case_528;
  }
#line 2312
  if (yyn == 530) {
#line 2312
    goto case_530;
  }
#line 2317
  if (yyn == 531) {
#line 2317
    goto case_531;
  }
#line 2322
  if (yyn == 533) {
#line 2322
    goto case_533;
  }
#line 2329
  if (yyn == 534) {
#line 2329
    goto case_534;
  }
#line 2333
  if (yyn == 535) {
#line 2333
    goto case_535;
  }
#line 2338
  if (yyn == 536) {
#line 2338
    goto case_536;
  }
#line 2341
  if (yyn == 537) {
#line 2341
    goto case_537;
  }
#line 2344
  if (yyn == 538) {
#line 2344
    goto case_538;
  }
#line 2346
  if (yyn == 539) {
#line 2346
    goto case_539;
  }
#line 2353
  if (yyn == 540) {
#line 2353
    goto case_540;
  }
#line 2354
  if (yyn == 541) {
#line 2354
    goto case_541;
  }
#line 2361
  if (yyn == 542) {
#line 2361
    goto case_542;
  }
#line 2373
  if (yyn == 543) {
#line 2373
    goto case_543;
  }
#line 2376
  if (yyn == 544) {
#line 2376
    goto case_544;
  }
#line 2381
  if (yyn == 545) {
#line 2381
    goto case_545;
  }
#line 2383
  if (yyn == 546) {
#line 2383
    goto case_546;
  }
#line 2388
  if (yyn == 547) {
#line 2388
    goto case_547;
  }
#line 2390
  if (yyn == 548) {
#line 2390
    goto case_548;
  }
#line 2399
  if (yyn == 549) {
#line 2399
    goto case_549;
  }
#line 2410
  if (yyn == 551) {
#line 2410
    goto case_551;
  }
#line 2415
  if (yyn == 552) {
#line 2415
    goto case_552;
  }
#line 2421
  if (yyn == 553) {
#line 2421
    goto case_553;
  }
#line 2424
  if (yyn == 554) {
#line 2424
    goto case_554;
  }
#line 2426
  if (yyn == 555) {
#line 2426
    goto case_555;
  }
#line 2433
  if (yyn == 556) {
#line 2433
    goto case_556;
  }
#line 2442
  if (yyn == 557) {
#line 2442
    goto case_557;
  }
#line 2444
  if (yyn == 558) {
#line 2444
    goto case_558;
  }
#line 2446
  if (yyn == 559) {
#line 2446
    goto case_559;
  }
#line 2452
  if (yyn == 560) {
#line 2452
    goto case_560;
  }
#line 2456
  if (yyn == 561) {
#line 2456
    goto case_561;
  }
#line 2463
  if (yyn == 562) {
#line 2463
    goto case_562;
  }
#line 2466
  if (yyn == 563) {
#line 2466
    goto case_563;
  }
#line 2467
  if (yyn == 564) {
#line 2467
    goto case_564;
  }
#line 2468
  if (yyn == 565) {
#line 2468
    goto case_565;
  }
#line 2471
  if (yyn == 566) {
#line 2471
    goto case_566;
  }
#line 2475
  if (yyn == 567) {
#line 2475
    goto case_567;
  }
#line 2480
  if (yyn == 568) {
#line 2480
    goto case_568;
  }
#line 2484
  if (yyn == 569) {
#line 2484
    goto case_569;
  }
#line 2489
  if (yyn == 570) {
#line 2489
    goto case_570;
  }
#line 2494
  if (yyn == 571) {
#line 2494
    goto case_571;
  }
#line 2497
  if (yyn == 572) {
#line 2497
    goto case_572;
  }
#line 2500
  if (yyn == 573) {
#line 2500
    goto case_573;
  }
#line 2504
  if (yyn == 574) {
#line 2504
    goto case_574;
  }
#line 2509
  if (yyn == 575) {
#line 2509
    goto case_575;
  }
#line 2513
  if (yyn == 576) {
#line 2513
    goto case_576;
  }
#line 2518
  if (yyn == 577) {
#line 2518
    goto case_577;
  }
#line 2523
  if (yyn == 578) {
#line 2523
    goto case_578;
  }
#line 2530
  if (yyn == 580) {
#line 2530
    goto case_580;
  }
#line 2532
  if (yyn == 581) {
#line 2532
    goto case_581;
  }
#line 2541
  if (yyn == 582) {
#line 2541
    goto case_582;
  }
#line 2544
  if (yyn == 583) {
#line 2544
    goto case_583;
  }
#line 2547
  if (yyn == 584) {
#line 2547
    goto case_584;
  }
#line 2550
  if (yyn == 585) {
#line 2550
    goto case_585;
  }
#line 2557
  if (yyn == 587) {
#line 2557
    goto case_587;
  }
#line 2563
  if (yyn == 589) {
#line 2563
    goto case_589;
  }
#line 2571
  if (yyn == 592) {
#line 2571
    goto case_592;
  }
#line 2578
  if (yyn == 593) {
#line 2578
    goto case_593;
  }
#line 2583
  if (yyn == 594) {
#line 2583
    goto case_594;
  }
#line 2585
  if (yyn == 595) {
#line 2585
    goto case_595;
  }
#line 2590
  if (yyn == 596) {
#line 2590
    goto case_596;
  }
#line 2592
  if (yyn == 597) {
#line 2592
    goto case_597;
  }
#line 2598
  if (yyn == 598) {
#line 2598
    goto case_598;
  }
#line 2602
  if (yyn == 599) {
#line 2602
    goto case_599;
  }
#line 2606
  if (yyn == 600) {
#line 2606
    goto case_600;
  }
#line 2611
  if (yyn == 601) {
#line 2611
    goto case_601;
  }
#line 2613
  if (yyn == 602) {
#line 2613
    goto case_602;
  }
#line 2615
  if (yyn == 603) {
#line 2615
    goto case_603;
  }
#line 2621
  if (yyn == 604) {
#line 2621
    goto case_604;
  }
#line 2631
  if (yyn == 605) {
#line 2631
    goto case_605;
  }
#line 2633
  if (yyn == 606) {
#line 2633
    goto case_606;
  }
#line 2635
  if (yyn == 608) {
#line 2635
    goto case_608;
  }
#line 2641
  if (yyn == 609) {
#line 2641
    goto case_609;
  }
#line 2648
  if (yyn == 610) {
#line 2648
    goto case_610;
  }
#line 2650
  if (yyn == 611) {
#line 2650
    goto case_611;
  }
#line 2652
  if (yyn == 612) {
#line 2652
    goto case_612;
  }
#line 2654
  if (yyn == 613) {
#line 2654
    goto case_613;
  }
#line 2656
  if (yyn == 614) {
#line 2656
    goto case_614;
  }
#line 2658
  if (yyn == 615) {
#line 2658
    goto case_615;
  }
#line 2660
  if (yyn == 616) {
#line 2660
    goto case_616;
  }
#line 2663
  if (yyn == 617) {
#line 2663
    goto case_617;
  }
#line 2669
  if (yyn == 618) {
#line 2669
    goto case_618;
  }
#line 2672
  if (yyn == 620) {
#line 2672
    goto case_620;
  }
#line 2677
  if (yyn == 621) {
#line 2677
    goto case_621;
  }
#line 2683
  if (yyn == 622) {
#line 2683
    goto case_622;
  }
#line 2685
  if (yyn == 623) {
#line 2685
    goto case_623;
  }
#line 2689
  if (yyn == 624) {
#line 2689
    goto case_624;
  }
#line 2694
  if (yyn == 625) {
#line 2694
    goto case_625;
  }
#line 2697
  if (yyn == 626) {
#line 2697
    goto case_626;
  }
#line 2702
  if (yyn == 627) {
#line 2702
    goto case_627;
  }
#line 2703
  if (yyn == 628) {
#line 2703
    goto case_628;
  }
#line 2710
  if (yyn == 629) {
#line 2710
    goto case_629;
  }
#line 2715
  if (yyn == 630) {
#line 2715
    goto case_630;
  }
#line 2717
  if (yyn == 631) {
#line 2717
    goto case_631;
  }
#line 2722
  if (yyn == 632) {
#line 2722
    goto case_632;
  }
#line 2727
  if (yyn == 633) {
#line 2727
    goto case_633;
  }
#line 7376 "c-parse.tab.c"
  goto switch_default;
  case_2: /* CIL Label */ ;
#line 466 "c-parse.y"
  goto switch_break;
  case_3: /* CIL Label */ ;
#line 467
  goto switch_break;
  case_4: /* CIL Label */ 
#line 468
  tEmPcast___0 = (AST_generic )(yyvsp + 0)->u.decl;
#line 468
  if (tEmPcast___0) {
#line 468
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 468
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 468U, "yyparse");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 468U, "yyparse");
      }
    }
  }
  {
#line 468
  tmp___0 = AST_node_reverse((node )tEmPcast___0);
#line 468
  tEmPcast = (AST_generic )tmp___0;
  }
#line 468
  if (tEmPcast) {
#line 468
    if ((unsigned int )tEmPcast->kind >= 43U) {
#line 468
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 468U, "yyparse");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 468U, "yyparse");
      }
    }
  }
#line 468
  cdecls = (declaration )tEmPcast;
#line 469
  tEmPcast___1 = (AST_generic )cdecls;
#line 469
  if (tEmPcast___1) {
#line 469
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 469
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 469
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 469U, "yyparse");
        }
      }
    } else {
      {
#line 469
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 469U, "yyparse");
      }
    }
  }
#line 469
  parse_tree = (node )tEmPcast___1;
#line 470
  goto switch_break;
  case_5: /* CIL Label */ 
#line 470
  parse_tree = (node )((void *)0);
#line 471
  goto switch_break;
  case_6: /* CIL Label */ 
#line 471
  tEmPcast___2 = (AST_generic )(yyvsp + 0)->u.decl;
#line 471
  if (tEmPcast___2) {
#line 471
    if ((unsigned int )tEmPcast___2->kind >= 42U) {
#line 471
      if (! ((unsigned int )tEmPcast___2->kind <= 199U)) {
        {
#line 471
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 471U, "yyparse");
        }
      }
    } else {
      {
#line 471
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 471U, "yyparse");
      }
    }
  }
#line 471
  parse_tree = (node )tEmPcast___2;
#line 472
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 472
  tmp___1 = make_error_decl();
#line 472
  tEmPcast___3 = (AST_generic )tmp___1;
  }
#line 472
  if (tEmPcast___3) {
#line 472
    if ((unsigned int )tEmPcast___3->kind >= 42U) {
#line 472
      if (! ((unsigned int )tEmPcast___3->kind <= 199U)) {
        {
#line 472
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 472U, "yyparse");
        }
      }
    } else {
      {
#line 472
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 472U, "yyparse");
      }
    }
  }
#line 472
  parse_tree = (node )tEmPcast___3;
#line 473
  goto switch_break;
  case_8: /* CIL Label */ 
#line 473
  tEmPcast___4 = (AST_generic )(yyvsp + 0)->u.type;
#line 473
  if (tEmPcast___4) {
#line 473
    if ((unsigned int )tEmPcast___4->kind >= 42U) {
#line 473
      if (! ((unsigned int )tEmPcast___4->kind <= 199U)) {
        {
#line 473
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 473U, "yyparse");
        }
      }
    } else {
      {
#line 473
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 473U, "yyparse");
      }
    }
  }
#line 473
  parse_tree = (node )tEmPcast___4;
#line 474
  goto switch_break;
  case_9: /* CIL Label */ 
#line 474
  parse_tree = (node )((void *)0);
#line 475
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 478
  end_macro_saving();
  }
#line 479
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 481
  end_macro_saving();
#line 482
  tEmPcast___6 = (AST_generic )(yyvsp + 0)->u.decl;
  }
#line 482
  if (tEmPcast___6) {
#line 482
    if ((unsigned int )tEmPcast___6->kind >= 42U) {
#line 482
      if (! ((unsigned int )tEmPcast___6->kind <= 199U)) {
        {
#line 482
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 482U, "yyparse");
        }
      }
    } else {
      {
#line 482
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 482U, "yyparse");
      }
    }
  }
  {
#line 482
  tmp___2 = AST_node_reverse((node )tEmPcast___6);
#line 482
  tEmPcast___5 = (AST_generic )tmp___2;
  }
#line 482
  if (tEmPcast___5) {
#line 482
    if ((unsigned int )tEmPcast___5->kind >= 43U) {
#line 482
      if (! ((unsigned int )tEmPcast___5->kind <= 64U)) {
        {
#line 482
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 482U, "yyparse");
        }
      }
    } else {
      {
#line 482
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 482U, "yyparse");
      }
    }
  }
  {
#line 482
  add_cdecls((declaration )tEmPcast___5);
  }
#line 484
  goto switch_break;
  case_15: /* CIL Label */ ;
#line 493
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 497
  require_c((yyvsp + 0)->idtoken.location, (char const   *)(yyvsp + 0)->idtoken.id.data);
  }
#line 498
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 499
  require_c((yyvsp + 0)->idtoken.location, (char const   *)(yyvsp + 0)->idtoken.id.data);
  }
#line 500
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 506
  start_nesc_entity((source_language )1, (yyvsp + 0)->u.word);
  }
#line 508
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 510
  handle_nescdecl_attributes((yyvsp + 0)->u.attribute, current.container);
  }
#line 512
  goto switch_break;
  case_20: /* CIL Label */ 
#line 514
  tEmPcast___8 = (AST_generic )(yyvsp + -1)->u.decl;
#line 514
  if (tEmPcast___8) {
#line 514
    if ((unsigned int )tEmPcast___8->kind >= 42U) {
#line 514
      if (! ((unsigned int )tEmPcast___8->kind <= 199U)) {
        {
#line 514
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 514U, "yyparse");
        }
      }
    } else {
      {
#line 514
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 514U, "yyparse");
      }
    }
  }
  {
#line 514
  tmp___3 = AST_node_reverse((node )tEmPcast___8);
#line 514
  tEmPcast___7 = (AST_generic )tmp___3;
  }
#line 514
  if (tEmPcast___7) {
#line 514
    if ((unsigned int )tEmPcast___7->kind >= 43U) {
#line 514
      if (! ((unsigned int )tEmPcast___7->kind <= 64U)) {
        {
#line 514
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 514U, "yyparse");
        }
      }
    } else {
      {
#line 514
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 514U, "yyparse");
      }
    }
  }
  {
#line 514
  tmp___4 = new_interface(parse_region, (yyvsp + -8)->u.itoken.location, (yyvsp + -7)->u.word,
                          (yyvsp + -4)->u.attribute, (declaration )tEmPcast___7);
#line 514
  intf = tmp___4;
#line 516
  set_nesc_parse_tree((void *)intf);
  }
#line 518
  if ((intf->cdecl)->abstract) {
    {
#line 519
    poplevel();
    }
  }
#line 521
  goto switch_break;
  case_21: /* CIL Label */ 
#line 524
  yyval.u.decl = (declaration )((void *)0);
#line 525
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 527
  intf___0 = current.container;
#line 529
  intf___0->parameters = (yyvsp + -1)->u.decl;
#line 530
  intf___0->parameter_env = current.env;
#line 531
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 534
  pushlevel((bool )0);
#line 536
  (current.env)->global_level = (bool )1;
#line 537
  intf___0->env = current.env;
#line 538
  intf___0->abstract = (bool )1;
  }
#line 540
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 545
  yyval.u.decl = declaration_chain((yyvsp + -2)->u.decl, (yyvsp + 0)->u.decl);
  }
#line 546
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 550
  yyval.u.decl = declare_type_parameter((yyvsp + -1)->idtoken.location, (yyvsp + -1)->idtoken.id,
                                        (yyvsp + 0)->u.attribute, (dd_list )((void *)0));
  }
#line 551
  goto switch_break;
  case_26: /* CIL Label */ 
#line 554
  yyval.idtoken = (yyvsp + 0)->idtoken;
#line 555
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 558
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 559
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 562
  pushlevel((bool )1);
  }
#line 563
  goto switch_break;
  case_30: /* CIL Label */ 
#line 563
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 564
  goto switch_break;
  case_31: /* CIL Label */ 
#line 568
  tEmPcast___10 = (AST_generic )(yyvsp + -1)->u.decl;
#line 568
  if (tEmPcast___10) {
#line 568
    if ((unsigned int )tEmPcast___10->kind >= 42U) {
#line 568
      if (! ((unsigned int )tEmPcast___10->kind <= 199U)) {
        {
#line 568
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 568U, "yyparse");
        }
      }
    } else {
      {
#line 568
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 568U, "yyparse");
      }
    }
  }
  {
#line 568
  tmp___5 = AST_node_reverse((node )tEmPcast___10);
#line 568
  tEmPcast___9 = (AST_generic )tmp___5;
  }
#line 568
  if (tEmPcast___9) {
#line 568
    if ((unsigned int )tEmPcast___9->kind >= 43U) {
#line 568
      if (! ((unsigned int )tEmPcast___9->kind <= 64U)) {
        {
#line 568
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 568U, "yyparse");
        }
      }
    } else {
      {
#line 568
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 568U, "yyparse");
      }
    }
  }
  {
#line 568
  yyval.u.decl = (declaration )tEmPcast___9;
#line 569
  check_interface_parameter_types(yyval.u.decl);
  }
#line 571
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 571
  yyval.u.decl = make_error_decl();
  }
#line 572
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 583
  start_nesc_entity((source_language )2, (yyvsp + 0)->u.word);
#line 584
  (current.container)->abstract = (yyvsp + -2)->abstract;
  }
#line 586
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 588
  handle_nescdecl_attributes((yyvsp + 0)->u.attribute, current.container);
  }
#line 590
  goto switch_break;
  case_38: /* CIL Label */ 
#line 594
  tEmPcast___12 = (AST_generic )(yyvsp + -2)->u.decl;
#line 594
  if (tEmPcast___12) {
#line 594
    if ((unsigned int )tEmPcast___12->kind >= 42U) {
#line 594
      if (! ((unsigned int )tEmPcast___12->kind <= 199U)) {
        {
#line 594
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 594U, "yyparse");
        }
      }
    } else {
      {
#line 594
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 594U, "yyparse");
      }
    }
  }
  {
#line 594
  tmp___6 = AST_node_reverse((node )tEmPcast___12);
#line 594
  tEmPcast___11 = (AST_generic )tmp___6;
  }
#line 594
  if (tEmPcast___11) {
#line 594
    if ((unsigned int )tEmPcast___11->kind >= 43U) {
#line 594
      if (! ((unsigned int )tEmPcast___11->kind <= 64U)) {
        {
#line 594
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 594U, "yyparse");
        }
      }
    } else {
      {
#line 594
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 594U, "yyparse");
      }
    }
  }
  {
#line 594
  tmp___7 = declaration_chain((declaration )tEmPcast___11, all_tasks);
#line 594
  intfs = tmp___7;
#line 595
  tmp___8 = new_component(parse_region, (yyvsp + -9)->u.itoken.location, (yyvsp + -8)->u.word,
                          (yyvsp + -5)->u.attribute, (yyvsp + -10)->abstract, (yyvsp + -6)->u.decl,
                          intfs, (yyvsp + 0)->u.impl);
#line 595
  set_nesc_parse_tree((void *)tmp___8);
  }
#line 597
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 602
  start_nesc_entity((source_language )2, (yyvsp + 0)->u.word);
#line 603
  (current.container)->abstract = (yyvsp + -2)->abstract;
#line 604
  (current.container)->configuration = (bool )1;
  }
#line 606
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 608
  handle_nescdecl_attributes((yyvsp + 0)->u.attribute, current.container);
  }
#line 610
  goto switch_break;
  case_41: /* CIL Label */ 
#line 612
  tEmPcast___14 = (AST_generic )(yyvsp + -1)->u.decl;
#line 612
  if (tEmPcast___14) {
#line 612
    if ((unsigned int )tEmPcast___14->kind >= 42U) {
#line 612
      if (! ((unsigned int )tEmPcast___14->kind <= 199U)) {
        {
#line 612
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 612U, "yyparse");
        }
      }
    } else {
      {
#line 612
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 612U, "yyparse");
      }
    }
  }
  {
#line 612
  tmp___9 = AST_node_reverse((node )tEmPcast___14);
#line 612
  tEmPcast___13 = (AST_generic )tmp___9;
  }
#line 612
  if (tEmPcast___13) {
#line 612
    if ((unsigned int )tEmPcast___13->kind >= 43U) {
#line 612
      if (! ((unsigned int )tEmPcast___13->kind <= 64U)) {
        {
#line 612
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 612U, "yyparse");
        }
      }
    } else {
      {
#line 612
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 612U, "yyparse");
      }
    }
  }
  {
#line 612
  tmp___10 = new_component(parse_region, (yyvsp + -8)->u.itoken.location, (yyvsp + -7)->u.word,
                           (yyvsp + -4)->u.attribute, (yyvsp + -9)->abstract, (yyvsp + -5)->u.decl,
                           (declaration )tEmPcast___13, (implementation )((void *)0));
#line 612
  set_nesc_ast((void *)tmp___10);
  }
#line 614
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 616
  set_nesc_impl((yyvsp + 0)->u.impl);
  }
#line 618
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 623
  start_nesc_entity((source_language )2, (yyvsp + 0)->u.word);
  }
#line 625
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 627
  handle_nescdecl_attributes((yyvsp + 0)->u.attribute, current.container);
  }
#line 629
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 631
  tmp___11 = start_implementation();
#line 631
  tmp___12 = new_binary_component(parse_region, (yyvsp + -7)->u.itoken.location, tmp___11);
#line 631
  dummy___0 = tmp___12;
#line 632
  tEmPcast___15 = (AST_generic )dummy___0;
  }
#line 632
  if (tEmPcast___15) {
#line 632
    if ((unsigned int )tEmPcast___15->kind >= 194U) {
#line 632
      if (! ((unsigned int )tEmPcast___15->kind <= 197U)) {
        {
#line 632
        __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                      "c-parse.y", 632U, "yyparse");
        }
      }
    } else {
      {
#line 632
      __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                    "c-parse.y", 632U, "yyparse");
      }
    }
  }
#line 632
  tEmPcast___17 = (AST_generic )(yyvsp + -1)->u.decl;
#line 632
  if (tEmPcast___17) {
#line 632
    if ((unsigned int )tEmPcast___17->kind >= 42U) {
#line 632
      if (! ((unsigned int )tEmPcast___17->kind <= 199U)) {
        {
#line 632
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 632U, "yyparse");
        }
      }
    } else {
      {
#line 632
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 632U, "yyparse");
      }
    }
  }
  {
#line 632
  tmp___13 = AST_node_reverse((node )tEmPcast___17);
#line 632
  tEmPcast___16 = (AST_generic )tmp___13;
  }
#line 632
  if (tEmPcast___16) {
#line 632
    if ((unsigned int )tEmPcast___16->kind >= 43U) {
#line 632
      if (! ((unsigned int )tEmPcast___16->kind <= 64U)) {
        {
#line 632
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 632U, "yyparse");
        }
      }
    } else {
      {
#line 632
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 632U, "yyparse");
      }
    }
  }
  {
#line 632
  tmp___14 = new_component(parse_region, (yyvsp + -7)->u.itoken.location, (yyvsp + -6)->u.word,
                           (yyvsp + -4)->u.attribute, (bool )0, (declaration )((void *)0),
                           (declaration )tEmPcast___16, (implementation )tEmPcast___15);
#line 632
  c = tmp___14;
#line 633
  set_nesc_parse_tree((void *)c);
  }
#line 635
  goto switch_break;
  case_46: /* CIL Label */ 
#line 637
  yyval.abstract = (bool )1;
#line 638
  goto switch_break;
  case_47: /* CIL Label */ 
#line 638
  yyval.abstract = (bool )0;
#line 639
  goto switch_break;
  case_48: /* CIL Label */ 
#line 644
  if ((current.container)->abstract) {
    {
#line 645
    error("generic components require a parameter list");
    }
  }
#line 649
  yyval.u.decl = (declaration )((void *)0);
#line 651
  goto switch_break;
  case_49: /* CIL Label */ 
#line 653
  comp = current.container;
#line 655
  if (! comp->abstract) {
    {
#line 656
    error("only generic components can have a parameter list");
    }
  }
  {
#line 657
  comp->parameters = (yyvsp + -1)->u.decl;
#line 658
  comp->parameter_env = current.env;
#line 659
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 663
  pushlevel((bool )0);
#line 664
  (current.env)->global_level = (bool )1;
#line 665
  comp->env = current.env;
  }
#line 667
  goto switch_break;
  case_50: /* CIL Label */ 
#line 670
  yyval.u.decl = (declaration )((void *)0);
#line 671
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 677
  yyval.u.decl = declaration_chain((yyvsp + -2)->u.decl, (yyvsp + 0)->u.decl);
  }
#line 678
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 686
  yyval.u.decl = declare_template_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                            (yyvsp + 0)->u.attribute);
  }
#line 687
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 688
  yyval.u.decl = declare_template_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                            (yyvsp + 0)->u.attribute);
  }
#line 689
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 690
  yyval.u.decl = declare_template_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                            (yyvsp + 0)->u.attribute);
  }
#line 691
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 692
  yyval.u.decl = declare_template_parameter((declarator )((void *)0), (yyvsp + -1)->u.telement,
                                            (attribute )((void *)0));
  }
#line 693
  goto switch_break;
  case_58: /* CIL Label */ 
#line 697
  current.spec_section = (enum __anonenum_spec_section_55 )0;
#line 698
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 702
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 703
  goto switch_break;
  case_60: /* CIL Label */ 
#line 703
  yyval.u.decl = (declaration )((void *)0);
#line 704
  goto switch_break;
  case_63: /* CIL Label */ 
#line 709
  current.spec_section = (enum __anonenum_spec_section_55 )0;
#line 710
  goto switch_break;
  case_64: /* CIL Label */ 
#line 709
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 710
  goto switch_break;
  case_65: /* CIL Label */ 
#line 713
  current.spec_section = (enum __anonenum_spec_section_55 )2;
#line 714
  goto switch_break;
  case_66: /* CIL Label */ 
#line 715
  tEmPcast___20 = (AST_generic )(yyvsp + 0)->u.decl;
#line 715
  if (tEmPcast___20) {
#line 715
    if ((unsigned int )tEmPcast___20->kind >= 42U) {
#line 715
      if (! ((unsigned int )tEmPcast___20->kind <= 199U)) {
        {
#line 715
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 715U, "yyparse");
        }
      }
    } else {
      {
#line 715
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 715U, "yyparse");
      }
    }
  }
  {
#line 715
  tmp___15 = AST_node_reverse((node )tEmPcast___20);
#line 715
  tEmPcast___19 = (AST_generic )tmp___15;
  }
#line 715
  if (tEmPcast___19) {
#line 715
    if ((unsigned int )tEmPcast___19->kind >= 43U) {
#line 715
      if (! ((unsigned int )tEmPcast___19->kind <= 64U)) {
        {
#line 715
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 715U, "yyparse");
        }
      }
    } else {
      {
#line 715
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 715U, "yyparse");
      }
    }
  }
  {
#line 715
  tmp___16 = new_rp_interface(parse_region, (yyvsp + -2)->u.itoken.location, (bool )1,
                              (declaration )tEmPcast___19);
#line 715
  tEmPcast___18 = (AST_generic )tmp___16;
  }
#line 715
  if (tEmPcast___18) {
#line 715
    if ((unsigned int )tEmPcast___18->kind >= 43U) {
#line 715
      if (! ((unsigned int )tEmPcast___18->kind <= 64U)) {
        {
#line 715
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 715U, "yyparse");
        }
      }
    } else {
      {
#line 715
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 715U, "yyparse");
      }
    }
  }
#line 715
  yyval.u.decl = (declaration )tEmPcast___18;
#line 716
  goto switch_break;
  case_67: /* CIL Label */ 
#line 718
  current.spec_section = (enum __anonenum_spec_section_55 )1;
#line 719
  goto switch_break;
  case_68: /* CIL Label */ 
#line 720
  tEmPcast___23 = (AST_generic )(yyvsp + 0)->u.decl;
#line 720
  if (tEmPcast___23) {
#line 720
    if ((unsigned int )tEmPcast___23->kind >= 42U) {
#line 720
      if (! ((unsigned int )tEmPcast___23->kind <= 199U)) {
        {
#line 720
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 720U, "yyparse");
        }
      }
    } else {
      {
#line 720
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 720U, "yyparse");
      }
    }
  }
  {
#line 720
  tmp___17 = AST_node_reverse((node )tEmPcast___23);
#line 720
  tEmPcast___22 = (AST_generic )tmp___17;
  }
#line 720
  if (tEmPcast___22) {
#line 720
    if ((unsigned int )tEmPcast___22->kind >= 43U) {
#line 720
      if (! ((unsigned int )tEmPcast___22->kind <= 64U)) {
        {
#line 720
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 720U, "yyparse");
        }
      }
    } else {
      {
#line 720
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 720U, "yyparse");
      }
    }
  }
  {
#line 720
  tmp___18 = new_rp_interface(parse_region, (yyvsp + -2)->u.itoken.location, (bool )0,
                              (declaration )tEmPcast___22);
#line 720
  tEmPcast___21 = (AST_generic )tmp___18;
  }
#line 720
  if (tEmPcast___21) {
#line 720
    if ((unsigned int )tEmPcast___21->kind >= 43U) {
#line 720
      if (! ((unsigned int )tEmPcast___21->kind <= 64U)) {
        {
#line 720
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 720U, "yyparse");
        }
      }
    } else {
      {
#line 720
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 720U, "yyparse");
      }
    }
  }
#line 720
  yyval.u.decl = (declaration )tEmPcast___21;
#line 721
  goto switch_break;
  case_70: /* CIL Label */ 
#line 724
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 725
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 729
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 730
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 737
  declare_interface_ref((yyvsp + -2)->u.iref, (declaration )((void *)0), current.env,
                        (yyvsp + -1)->u.attribute);
#line 738
  tEmPcast___24 = (AST_generic )(yyvsp + -2)->u.iref;
  }
#line 738
  if (tEmPcast___24) {
#line 738
    if ((unsigned int )tEmPcast___24->kind >= 43U) {
#line 738
      if (! ((unsigned int )tEmPcast___24->kind <= 64U)) {
        {
#line 738
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 738U, "yyparse");
        }
      }
    } else {
      {
#line 738
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 738U, "yyparse");
      }
    }
  }
#line 738
  yyval.u.decl = (declaration )tEmPcast___24;
#line 740
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 742
  ((yyvsp + -3)->u.iref)->gparms = (yyvsp + -2)->u.decl;
#line 743
  poplevel();
#line 744
  declare_interface_ref((yyvsp + -3)->u.iref, (yyvsp + -2)->u.decl, current.env, (yyvsp + -1)->u.attribute);
#line 745
  tEmPcast___25 = (AST_generic )(yyvsp + -3)->u.iref;
  }
#line 745
  if (tEmPcast___25) {
#line 745
    if ((unsigned int )tEmPcast___25->kind >= 43U) {
#line 745
      if (! ((unsigned int )tEmPcast___25->kind <= 64U)) {
        {
#line 745
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 745U, "yyparse");
        }
      }
    } else {
      {
#line 745
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 745U, "yyparse");
      }
    }
  }
#line 745
  yyval.u.decl = (declaration )tEmPcast___25;
#line 747
  goto switch_break;
  case_77: /* CIL Label */ 
#line 751
  yyval.u.iref = (yyvsp + -2)->u.iref;
#line 751
  (yyval.u.iref)->word2 = (yyvsp + 0)->u.word;
#line 752
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 757
  preload((source_language )1, (yyvsp + -1)->u.itoken.location, (char const   *)((yyvsp + 0)->u.word)->cstring.data);
#line 758
  yyval.u.iref = new_interface_ref(parse_region, (yyvsp + -1)->u.itoken.location,
                                   (yyvsp + 0)->u.word, (expression )((void *)0),
                                   (word )((void *)0), (declaration )((void *)0),
                                   (attribute )((void *)0), (data_declaration )((void *)0));
  }
#line 760
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 762
  preload((source_language )1, (yyvsp + -1)->u.itoken.location, (char const   *)((yyvsp + 0)->u.word)->cstring.data);
  }
#line 764
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 765
  yyval.u.iref = new_interface_ref(parse_region, (yyvsp + -5)->u.itoken.location,
                                   (yyvsp + -4)->u.word, (yyvsp + -1)->u.expr, (word )((void *)0),
                                   (declaration )((void *)0), (attribute )((void *)0),
                                   (data_declaration )((void *)0));
  }
#line 766
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 770
  yyval.u.expr = expression_chain((yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 771
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 774
  yyval.u.env = start_implementation();
  }
#line 775
  goto switch_break;
  case_84: /* CIL Label */ 
#line 778
  tEmPcast___28 = (AST_generic )(yyvsp + -1)->u.decl;
#line 778
  if (tEmPcast___28) {
#line 778
    if ((unsigned int )tEmPcast___28->kind >= 42U) {
#line 778
      if (! ((unsigned int )tEmPcast___28->kind <= 199U)) {
        {
#line 778
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 778U, "yyparse");
        }
      }
    } else {
      {
#line 778
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 778U, "yyparse");
      }
    }
  }
  {
#line 778
  tmp___19 = AST_node_reverse((node )tEmPcast___28);
#line 778
  tEmPcast___27 = (AST_generic )tmp___19;
  }
#line 778
  if (tEmPcast___27) {
#line 778
    if ((unsigned int )tEmPcast___27->kind >= 43U) {
#line 778
      if (! ((unsigned int )tEmPcast___27->kind <= 64U)) {
        {
#line 778
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 778U, "yyparse");
        }
      }
    } else {
      {
#line 778
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 778U, "yyparse");
      }
    }
  }
  {
#line 778
  tmp___20 = new_configuration(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -3)->u.env,
                               (declaration )tEmPcast___27);
#line 778
  tEmPcast___26 = (AST_generic )tmp___20;
  }
#line 778
  if (tEmPcast___26) {
#line 778
    if ((unsigned int )tEmPcast___26->kind >= 194U) {
#line 778
      if (! ((unsigned int )tEmPcast___26->kind <= 197U)) {
        {
#line 778
        __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                      "c-parse.y", 778U, "yyparse");
        }
      }
    } else {
      {
#line 778
      __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                    "c-parse.y", 778U, "yyparse");
      }
    }
  }
#line 778
  yyval.u.impl = (implementation )tEmPcast___26;
#line 780
  goto switch_break;
  case_85: /* CIL Label */ 
#line 782
  yyval.u.cref = (yyvsp + -1)->u.cref;
#line 783
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 786
  yyval.u.cref = component_ref_chain((yyvsp + 0)->u.cref, (yyvsp + -2)->u.cref);
  }
#line 787
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 791
  yyval.u.cref = require_component((yyvsp + 0)->u.cref, (word )((void *)0));
  }
#line 792
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 792
  yyval.u.cref = require_component((yyvsp + -2)->u.cref, (yyvsp + 0)->u.word);
  }
#line 793
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 796
  yyval.u.cref = new_component_ref(parse_region, ((yyvsp + 0)->u.word)->location,
                                   (yyvsp + 0)->u.word, (word )((void *)0), (bool )0,
                                   (expression )((void *)0));
  }
#line 798
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 799
  yyval.u.cref = new_component_ref(parse_region, (yyvsp + -4)->u.itoken.location,
                                   (yyvsp + -3)->u.word, (word )((void *)0), (bool )1,
                                   (yyvsp + -1)->u.expr);
  }
#line 801
  goto switch_break;
  case_92: /* CIL Label */ 
#line 804
  yyval.u.expr = (expression )((void *)0);
#line 805
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 810
  yyval.u.expr = expression_chain((yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 811
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 815
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 815
  (yyval.u.expr)->type = default_conversion_for_assignment(yyval.u.expr);
  }
#line 816
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 820
  yyval.u.expr = make_type_argument((yyvsp + 0)->u.type);
  }
#line 821
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 824
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 825
  goto switch_break;
  case_100: /* CIL Label */ 
#line 825
  yyval.u.decl = (declaration )((void *)0);
#line 826
  goto switch_break;
  case_101: /* CIL Label */ 
#line 829
  tEmPcast___29 = (AST_generic )(yyvsp + 0)->u.conn;
#line 829
  if (tEmPcast___29) {
#line 829
    if ((unsigned int )tEmPcast___29->kind >= 43U) {
#line 829
      if (! ((unsigned int )tEmPcast___29->kind <= 64U)) {
        {
#line 829
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 829U, "yyparse");
        }
      }
    } else {
      {
#line 829
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 829U, "yyparse");
      }
    }
  }
#line 829
  yyval.u.decl = (declaration )tEmPcast___29;
#line 830
  goto switch_break;
  case_103: /* CIL Label */ 
#line 831
  tEmPcast___30 = (AST_generic )(yyvsp + 0)->u.cref;
#line 831
  if (tEmPcast___30) {
#line 831
    if ((unsigned int )tEmPcast___30->kind >= 43U) {
#line 831
      if (! ((unsigned int )tEmPcast___30->kind <= 64U)) {
        {
#line 831
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 831U, "yyparse");
        }
      }
    } else {
      {
#line 831
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 831U, "yyparse");
      }
    }
  }
#line 831
  yyval.u.decl = (declaration )tEmPcast___30;
#line 832
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 836
  tmp___21 = new_eq_connection(parse_region, (yyvsp + -2)->u.itoken.location, (yyvsp + -3)->u.ep,
                               (yyvsp + -1)->u.ep);
#line 836
  tEmPcast___31 = (AST_generic )tmp___21;
  }
#line 836
  if (tEmPcast___31) {
#line 836
    if ((unsigned int )tEmPcast___31->kind >= 60U) {
#line 836
      if (! ((unsigned int )tEmPcast___31->kind <= 62U)) {
        {
#line 836
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "c-parse.y", 836U, "yyparse");
        }
      }
    } else {
      {
#line 836
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "c-parse.y", 836U, "yyparse");
      }
    }
  }
#line 836
  yyval.u.conn = (connection )tEmPcast___31;
#line 837
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 838
  tmp___22 = new_rp_connection(parse_region, (yyvsp + -2)->u.itoken.location, (yyvsp + -1)->u.ep,
                               (yyvsp + -3)->u.ep);
#line 838
  tEmPcast___32 = (AST_generic )tmp___22;
  }
#line 838
  if (tEmPcast___32) {
#line 838
    if ((unsigned int )tEmPcast___32->kind >= 60U) {
#line 838
      if (! ((unsigned int )tEmPcast___32->kind <= 62U)) {
        {
#line 838
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "c-parse.y", 838U, "yyparse");
        }
      }
    } else {
      {
#line 838
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "c-parse.y", 838U, "yyparse");
      }
    }
  }
#line 838
  yyval.u.conn = (connection )tEmPcast___32;
#line 839
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 840
  tmp___23 = new_rp_connection(parse_region, (yyvsp + -2)->u.itoken.location, (yyvsp + -3)->u.ep,
                               (yyvsp + -1)->u.ep);
#line 840
  tEmPcast___33 = (AST_generic )tmp___23;
  }
#line 840
  if (tEmPcast___33) {
#line 840
    if ((unsigned int )tEmPcast___33->kind >= 60U) {
#line 840
      if (! ((unsigned int )tEmPcast___33->kind <= 62U)) {
        {
#line 840
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "c-parse.y", 840U, "yyparse");
        }
      }
    } else {
      {
#line 840
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "c-parse.y", 840U, "yyparse");
      }
    }
  }
#line 840
  yyval.u.conn = (connection )tEmPcast___33;
#line 841
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 845
  yyval.u.ep = (yyvsp + -2)->u.ep;
#line 846
  (yyval.u.ep)->ids = parameterised_identifier_chain((yyval.u.ep)->ids, (yyvsp + 0)->u.pid);
  }
#line 848
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 849
  yyval.u.ep = new_endpoint(parse_region, ((yyvsp + 0)->u.pid)->location, (yyvsp + 0)->u.pid);
  }
#line 850
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 854
  yyval.u.pid = new_parameterised_identifier(parse_region, ((yyvsp + 0)->u.word)->location,
                                             (yyvsp + 0)->u.word, (expression )((void *)0));
  }
#line 855
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 856
  yyval.u.pid = new_parameterised_identifier(parse_region, ((yyvsp + -3)->u.word)->location,
                                             (yyvsp + -3)->u.word, (yyvsp + -1)->u.expr);
  }
#line 857
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 859
  yyval.u.env = start_implementation();
#line 859
  all_tasks = (declaration )((void *)0);
  }
#line 860
  goto switch_break;
  case_112: /* CIL Label */ 
#line 861
  tEmPcast___36 = (AST_generic )(yyvsp + -1)->u.decl;
#line 861
  if (tEmPcast___36) {
#line 861
    if ((unsigned int )tEmPcast___36->kind >= 42U) {
#line 861
      if (! ((unsigned int )tEmPcast___36->kind <= 199U)) {
        {
#line 861
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 861U, "yyparse");
        }
      }
    } else {
      {
#line 861
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 861U, "yyparse");
      }
    }
  }
  {
#line 861
  tmp___24 = AST_node_reverse((node )tEmPcast___36);
#line 861
  tEmPcast___35 = (AST_generic )tmp___24;
  }
#line 861
  if (tEmPcast___35) {
#line 861
    if ((unsigned int )tEmPcast___35->kind >= 43U) {
#line 861
      if (! ((unsigned int )tEmPcast___35->kind <= 64U)) {
        {
#line 861
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 861U, "yyparse");
        }
      }
    } else {
      {
#line 861
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 861U, "yyparse");
      }
    }
  }
  {
#line 861
  tmp___25 = new_module(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -3)->u.env,
                        (declaration )tEmPcast___35);
#line 861
  tEmPcast___34 = (AST_generic )tmp___25;
  }
#line 861
  if (tEmPcast___34) {
#line 861
    if ((unsigned int )tEmPcast___34->kind >= 194U) {
#line 861
      if (! ((unsigned int )tEmPcast___34->kind <= 197U)) {
        {
#line 861
        __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                      "c-parse.y", 861U, "yyparse");
        }
      }
    } else {
      {
#line 861
      __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                    "c-parse.y", 861U, "yyparse");
      }
    }
  }
#line 861
  yyval.u.impl = (implementation )tEmPcast___34;
#line 863
  goto switch_break;
  case_113: /* CIL Label */ 
#line 869
  yyval.u.telement = (type_element )((void *)0);
#line 870
  goto switch_break;
  case_114: /* CIL Label */ 
#line 869
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 870
  goto switch_break;
  case_115: /* CIL Label */ 
#line 870
  yyval.u.telement = (type_element )((void *)0);
#line 871
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 871
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -2)->u.decl);
  }
#line 872
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 879
  tmp___26 = new_asm_stmt(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -2)->u.expr,
                          (asm_operand )((void *)0), (asm_operand )((void *)0), (string )((void *)0),
                          (type_element )((void *)0));
#line 879
  tmp___27 = new_asm_decl(parse_region, (yyvsp + -4)->u.itoken.location, tmp___26);
#line 879
  tEmPcast___37 = (AST_generic )tmp___27;
  }
#line 879
  if (tEmPcast___37) {
#line 879
    if ((unsigned int )tEmPcast___37->kind >= 43U) {
#line 879
      if (! ((unsigned int )tEmPcast___37->kind <= 64U)) {
        {
#line 879
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 881U, "yyparse");
        }
      }
    } else {
      {
#line 879
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 881U, "yyparse");
      }
    }
  }
#line 879
  yyval.u.decl = (declaration )tEmPcast___37;
#line 882
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 883
  yyval.u.decl = make_extension_decl((yyvsp + -1)->u.itoken.i, (yyvsp + -1)->u.itoken.location,
                                     (yyvsp + 0)->u.decl);
  }
#line 884
  goto switch_break;
  case_121: /* CIL Label */ 
#line 888
  if (pedantic) {
    {
#line 889
    error("ANSI C forbids data definition with no type or storage class");
    }
  } else
#line 890
  if (! flag_traditional) {
    {
#line 891
    warning("data definition has no type or storage class");
    }
  }
  {
#line 893
  yyval.u.decl = make_data_decl((type_element )((void *)0), (yyvsp + -1)->u.decl);
  }
#line 894
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 899
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 900
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 901
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 902
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 903
  shadow_tag((yyvsp + -2)->u.telement);
#line 904
  yyval.u.decl = make_data_decl((yyvsp + -2)->u.telement, (declaration )((void *)0));
  }
#line 905
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 905
  yyval.u.decl = make_error_decl();
  }
#line 906
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 906
  yyval.u.decl = make_error_decl();
  }
#line 907
  goto switch_break;
  case_128: /* CIL Label */ 
#line 908
  if (pedantic) {
    {
#line 909
    pedwarn("ANSI C does not allow extra `;\' outside of a function");
    }
  }
#line 910
  yyval.u.decl = (declaration )((void *)0);
#line 911
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 916
  yyval.u.decl = (*(target->keilc_definition))((yyvsp + -4)->idtoken.location, (yyvsp + -4)->idtoken.id,
                                               (yyvsp + -3)->idtoken.id, (yyvsp + -1)->u.expr);
  }
#line 917
  goto switch_break;
  case_131: /* CIL Label */ 
#line 920
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 921
  goto switch_break;
  case_132: /* CIL Label */ 
#line 921
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 922
  goto switch_break;
  case_133: /* CIL Label */ 
#line 922
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 923
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 928
  refuse_asm((yyvsp + -1)->u.asm_stmt);
#line 933
  tmp___28 = start_function(pstate.declspecs, (yyvsp + -2)->u.declarator, (yyvsp + 0)->u.attribute,
                            (bool )0);
  }
#line 933
  if (! tmp___28) {
    {
#line 934
    yyerror("syntax error");
    }
#line 934
    goto yyerrorlab;
  }
#line 936
  goto switch_break;
  case_135: /* CIL Label */ 
#line 937
  tEmPcast___39 = (AST_generic )(yyvsp + 0)->u.decl;
#line 937
  if (tEmPcast___39) {
#line 937
    if ((unsigned int )tEmPcast___39->kind >= 42U) {
#line 937
      if (! ((unsigned int )tEmPcast___39->kind <= 199U)) {
        {
#line 937
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 937U, "yyparse");
        }
      }
    } else {
      {
#line 937
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 937U, "yyparse");
      }
    }
  }
  {
#line 937
  tmp___29 = AST_node_reverse((node )tEmPcast___39);
#line 937
  tEmPcast___38 = (AST_generic )tmp___29;
  }
#line 937
  if (tEmPcast___38) {
#line 937
    if ((unsigned int )tEmPcast___38->kind >= 43U) {
#line 937
      if (! ((unsigned int )tEmPcast___38->kind <= 64U)) {
        {
#line 937
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 937U, "yyparse");
        }
      }
    } else {
      {
#line 937
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 937U, "yyparse");
      }
    }
  }
  {
#line 937
  store_parm_decls((declaration )tEmPcast___38);
  }
#line 938
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 939
  yyval.u.decl = finish_function((yyvsp + 0)->u.stmt);
#line 940
  pop_declspec_stack();
  }
#line 941
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 949
  yyval.u.id_label = new_id_label(parse_region, (yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 950
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 953
  yyval.u.word = new_word(parse_region, (yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 954
  goto switch_break;
  case_141: /* CIL Label */ 
#line 957
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 957
  yyval.u.itoken.i = 101;
#line 958
  goto switch_break;
  case_142: /* CIL Label */ 
#line 959
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 959
  yyval.u.itoken.i = 102;
#line 960
  goto switch_break;
  case_143: /* CIL Label */ 
#line 961
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 961
  yyval.u.itoken.i = 103;
#line 962
  goto switch_break;
  case_144: /* CIL Label */ 
#line 963
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 963
  yyval.u.itoken.i = 89;
#line 964
  goto switch_break;
  case_145: /* CIL Label */ 
#line 965
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 965
  yyval.u.itoken.i = 90;
#line 966
  goto switch_break;
  case_146: /* CIL Label */ 
#line 967
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 967
  yyval.u.itoken.i = 105;
#line 968
  goto switch_break;
  case_147: /* CIL Label */ 
#line 969
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 969
  yyval.u.itoken.i = 106;
#line 970
  goto switch_break;
  case_148: /* CIL Label */ 
#line 971
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 971
  yyval.u.itoken.i = 99;
#line 972
  goto switch_break;
  case_149: /* CIL Label */ 
#line 973
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 973
  yyval.u.itoken.i = 100;
#line 974
  goto switch_break;
  case_150: /* CIL Label */ 
#line 977
  if (((yyvsp + 0)->u.expr)->next) {
    {
#line 978
    yyval.u.expr = make_comma(((yyvsp + 0)->u.expr)->location, (yyvsp + 0)->u.expr);
    }
  } else {
#line 980
    yyval.u.expr = (yyvsp + 0)->u.expr;
  }
#line 981
  goto switch_break;
  case_151: /* CIL Label */ 
#line 985
  yyval.u.expr = (expression )((void *)0);
#line 986
  goto switch_break;
  case_153: /* CIL Label */ 
#line 991
  tEmPcast___41 = (AST_generic )(yyvsp + 0)->u.expr;
#line 991
  if (tEmPcast___41) {
#line 991
    if ((unsigned int )tEmPcast___41->kind >= 42U) {
#line 991
      if (! ((unsigned int )tEmPcast___41->kind <= 199U)) {
        {
#line 991
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 991U, "yyparse");
        }
      }
    } else {
      {
#line 991
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 991U, "yyparse");
      }
    }
  }
  {
#line 991
  tmp___30 = AST_node_reverse((node )tEmPcast___41);
#line 991
  tEmPcast___40 = (AST_generic )tmp___30;
  }
#line 991
  if (tEmPcast___40) {
#line 991
    if ((unsigned int )tEmPcast___40->kind >= 84U) {
#line 991
      if (! ((unsigned int )tEmPcast___40->kind <= 156U)) {
        {
#line 991
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 991U, "yyparse");
        }
      }
    } else {
      {
#line 991
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 991U, "yyparse");
      }
    }
  }
#line 991
  yyval.u.expr = (expression )tEmPcast___40;
#line 992
  goto switch_break;
  case_154: /* CIL Label */ 
#line 996
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 997
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 998
  yyval.u.expr = expression_chain((yyvsp + 0)->u.expr, (yyvsp + -2)->u.expr);
  }
#line 999
  goto switch_break;
  case_156: /* CIL Label */ 
#line 1002
  yyval.u.itoken.i = 0;
#line 1003
  goto switch_break;
  case_157: /* CIL Label */ 
#line 1003
  yyval.u.itoken.i = 1;
#line 1004
  goto switch_break;
  case_158: /* CIL Label */ 
#line 1004
  yyval.u.itoken.i = 2;
#line 1005
  goto switch_break;
  case_160: /* CIL Label */ 
#line 1011
  tEmPcast___42 = (AST_generic )(yyvsp + 0)->u.expr;
#line 1011
  if (tEmPcast___42) {
#line 1011
    if ((unsigned int )tEmPcast___42->kind >= 148U) {
#line 1011
      if (! ((unsigned int )tEmPcast___42->kind <= 148U)) {
        {
#line 1011
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "c-parse.y", 1011U, "yyparse");
        }
      }
    } else {
      {
#line 1011
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "c-parse.y", 1011U, "yyparse");
      }
    }
  }
#line 1011
  fc = (function_call )tEmPcast___42;
#line 1012
  calltype = (fc->arg1)->type;
#line 1013
  noerror = (bool )((unsigned long )fc->type != (unsigned long )error_type);
#line 1015
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 1016
  fc->call_kind = (nesc_call_kind )(yyvsp + -1)->u.itoken.i;
  {
#line 1019
  if ((yyvsp + -1)->u.itoken.i == 0) {
#line 1019
    goto case_0;
  }
#line 1023
  if ((yyvsp + -1)->u.itoken.i == 1) {
#line 1023
    goto case_1;
  }
#line 1027
  if ((yyvsp + -1)->u.itoken.i == 2) {
#line 1027
    goto case_2___0;
  }
#line 1017
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 1020
  if (noerror) {
    {
#line 1020
    tmp___31 = type_command(calltype);
    }
#line 1020
    if (! tmp___31) {
      {
#line 1021
      error("only commands can be called");
      }
    }
  }
#line 1022
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1024
  if (noerror) {
    {
#line 1024
    tmp___32 = type_event(calltype);
    }
#line 1024
    if (! tmp___32) {
      {
#line 1025
      error("only events can be signaled");
      }
    }
  }
#line 1026
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 1028
  fc->type = unsigned_char_type;
#line 1029
  if (noerror) {
    {
#line 1031
    tmp___33 = type_task(calltype);
    }
#line 1031
    if (tmp___33) {
#line 1033
      if (flag_use_scheduler) {
        {
#line 1036
        handle_post(fc);
        }
      }
    } else {
      {
#line 1032
      error("only tasks can be posted");
      }
    }
  }
#line 1038
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1041
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 1042
  yyval.u.expr = make_dereference((yyvsp + -1)->u.itoken.location, (yyvsp + 0)->u.expr);
  }
#line 1043
  goto switch_break;
  case_162: /* CIL Label */ 
  {
#line 1045
  yyval.u.expr = make_extension_expr((yyvsp + -1)->u.itoken.location, (yyvsp + 0)->u.expr);
#line 1046
  pedantic = (bool )(yyvsp + -1)->u.itoken.i;
  }
#line 1047
  goto switch_break;
  case_163: /* CIL Label */ 
  {
#line 1048
  yyval.u.expr = make_unary((yyvsp + -1)->u.itoken.location, (yyvsp + -1)->u.itoken.i,
                            (yyvsp + 0)->u.expr);
  }
#line 1053
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1056
  tmp___34 = make_label_address((yyvsp + -1)->u.itoken.location, (yyvsp + 0)->u.id_label);
#line 1056
  tEmPcast___43 = (AST_generic )tmp___34;
  }
#line 1056
  if (tEmPcast___43) {
#line 1056
    if ((unsigned int )tEmPcast___43->kind >= 84U) {
#line 1056
      if (! ((unsigned int )tEmPcast___43->kind <= 156U)) {
        {
#line 1056
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1056U, "yyparse");
        }
      }
    } else {
      {
#line 1056
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1056U, "yyparse");
      }
    }
  }
  {
#line 1056
  yyval.u.expr = (expression )tEmPcast___43;
#line 1057
  use_label((yyvsp + 0)->u.id_label);
  }
#line 1059
  goto switch_break;
  case_165: /* CIL Label */ 
  {
#line 1067
  yyval.u.expr = make_sizeof_expr((yyvsp + -1)->u.itoken.location, (yyvsp + 0)->u.expr);
#line 1068
  (pstate.unevaluated_expression) --;
  }
#line 1069
  goto switch_break;
  case_166: /* CIL Label */ 
  {
#line 1070
  yyval.u.expr = make_sizeof_type((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.type);
#line 1071
  (pstate.unevaluated_expression) --;
  }
#line 1072
  goto switch_break;
  case_167: /* CIL Label */ 
  {
#line 1073
  yyval.u.expr = make_alignof_expr((yyvsp + -1)->u.itoken.location, (yyvsp + 0)->u.expr);
#line 1074
  (pstate.unevaluated_expression) --;
  }
#line 1075
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 1076
  yyval.u.expr = make_alignof_type((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.type);
#line 1077
  (pstate.unevaluated_expression) --;
  }
#line 1078
  goto switch_break;
  case_169: /* CIL Label */ 
#line 1081
  (pstate.unevaluated_expression) ++;
#line 1081
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 1082
  goto switch_break;
  case_170: /* CIL Label */ 
#line 1085
  (pstate.unevaluated_expression) ++;
#line 1085
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 1086
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 1091
  yyval.u.expr = make_cast((yyvsp + -3)->u.itoken.location, (yyvsp + -2)->u.type,
                           (yyvsp + 0)->u.expr);
  }
#line 1092
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 1094
  start_init((declaration )((void *)0), (nesc_attribute )((void *)0));
#line 1095
  really_start_incremental_init(((yyvsp + -2)->u.type)->type);
  }
#line 1097
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 1099
  tmp___35 = make_init_list((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.expr);
#line 1099
  constructor = tmp___35;
#line 1101
  finish_init();
  }
#line 1103
  if (pedantic) {
    {
#line 1104
    pedwarn("ANSI C forbids constructor expressions");
    }
  }
  {
#line 1106
  yyval.u.expr = make_cast_list((yyvsp + -6)->u.itoken.location, (yyvsp + -5)->u.type,
                                constructor);
  }
#line 1108
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 1113
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 128, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1114
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 1115
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 129, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1116
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 1117
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 130, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1118
  goto switch_break;
  case_179: /* CIL Label */ 
  {
#line 1119
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 131, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1120
  goto switch_break;
  case_180: /* CIL Label */ 
  {
#line 1121
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 132, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1122
  goto switch_break;
  case_181: /* CIL Label */ 
  {
#line 1123
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 133, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1124
  goto switch_break;
  case_182: /* CIL Label */ 
  {
#line 1125
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 134, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1126
  goto switch_break;
  case_183: /* CIL Label */ 
  {
#line 1127
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, (yyvsp + -1)->u.itoken.i,
                             (yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 1128
  goto switch_break;
  case_184: /* CIL Label */ 
  {
#line 1129
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 111, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1130
  goto switch_break;
  case_185: /* CIL Label */ 
  {
#line 1131
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 112, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1132
  goto switch_break;
  case_186: /* CIL Label */ 
  {
#line 1133
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, (yyvsp + -1)->u.itoken.i,
                             (yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 1134
  goto switch_break;
  case_187: /* CIL Label */ 
  {
#line 1135
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 135, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1136
  goto switch_break;
  case_188: /* CIL Label */ 
  {
#line 1137
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 136, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1138
  goto switch_break;
  case_189: /* CIL Label */ 
  {
#line 1139
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 137, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1140
  goto switch_break;
  case_190: /* CIL Label */ 
  {
#line 1141
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 138, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1142
  goto switch_break;
  case_191: /* CIL Label */ 
  {
#line 1143
  yyval.u.expr = make_binary((yyvsp + -1)->u.itoken.location, 139, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1144
  goto switch_break;
  case_192: /* CIL Label */ 
  {
#line 1145
  yyval.u.expr = make_conditional((yyvsp + -3)->u.itoken.location, (yyvsp + -4)->u.expr,
                                  (yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 1146
  goto switch_break;
  case_193: /* CIL Label */ 
#line 1147
  if (pedantic) {
    {
#line 1148
    pedwarn("ANSI C forbids omitting the middle term of a ?: expression");
    }
  }
#line 1150
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 1151
  yyval.u.expr = make_conditional((yyvsp + -3)->u.itoken.location, (yyvsp + -4)->u.expr,
                                  (expression )((void *)0), (yyvsp + 0)->u.expr);
  }
#line 1152
  goto switch_break;
  case_195: /* CIL Label */ 
  {
#line 1153
  yyval.u.expr = make_assign((yyvsp + -1)->u.itoken.location, 116, (yyvsp + -2)->u.expr,
                             (yyvsp + 0)->u.expr);
  }
#line 1154
  goto switch_break;
  case_196: /* CIL Label */ 
  {
#line 1155
  yyval.u.expr = make_assign((yyvsp + -1)->u.itoken.location, (yyvsp + -1)->u.itoken.i,
                             (yyvsp + -2)->u.expr, (yyvsp + 0)->u.expr);
  }
#line 1156
  goto switch_break;
  case_197: /* CIL Label */ 
#line 1161
  if (yychar == -2) {
    {
#line 1162
    yychar = yylex(& yylval);
    }
  }
  {
#line 1163
  yyval.u.expr = make_identifier((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id,
                                 (bool )(yychar == 40));
  }
#line 1165
  goto switch_break;
  case_198: /* CIL Label */ 
#line 1165
  tEmPcast___44 = (AST_generic )(yyvsp + 0)->u.constant;
#line 1165
  if (tEmPcast___44) {
#line 1165
    if ((unsigned int )tEmPcast___44->kind >= 84U) {
#line 1165
      if (! ((unsigned int )tEmPcast___44->kind <= 156U)) {
        {
#line 1165
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1165U, "yyparse");
        }
      }
    } else {
      {
#line 1165
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1165U, "yyparse");
      }
    }
  }
#line 1165
  yyval.u.expr = (expression )tEmPcast___44;
#line 1166
  goto switch_break;
  case_199: /* CIL Label */ 
#line 1166
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 1167
  goto switch_break;
  case_200: /* CIL Label */ 
#line 1168
  yyval.u.expr = (yyvsp + -1)->u.expr;
#line 1168
  (yyval.u.expr)->parens = (bool )1;
#line 1169
  goto switch_break;
  case_201: /* CIL Label */ 
  {
#line 1170
  yyval.u.expr = make_error_expr();
  }
#line 1171
  goto switch_break;
  case_202: /* CIL Label */ 
#line 1172
  if ((unsigned long )current.function_decl == (unsigned long )((function_decl )0)) {
    {
#line 1174
    error("braced-group within expression allowed only inside a function");
    }
#line 1175
    goto yyerrorlab;
  }
  {
#line 1177
  push_label_level();
  }
#line 1179
  goto switch_break;
  case_203: /* CIL Label */ 
  {
#line 1181
  pop_label_level();
  }
#line 1182
  if (pedantic) {
    {
#line 1183
    pedwarn("ANSI C forbids braced-groups within expressions");
    }
  }
  {
#line 1184
  yyval.u.expr = make_compound_expr((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.stmt);
  }
#line 1186
  goto switch_break;
  case_204: /* CIL Label */ 
#line 1189
  if ((unsigned int )((yyvsp + 0)->u.expr)->kind >= 148U) {
#line 1189
    if ((unsigned int )((yyvsp + 0)->u.expr)->kind <= 148U) {
#line 1191
      tEmPcast___45 = (AST_generic )(yyvsp + 0)->u.expr;
#line 1191
      if (tEmPcast___45) {
#line 1191
        if ((unsigned int )tEmPcast___45->kind >= 148U) {
#line 1191
          if (! ((unsigned int )tEmPcast___45->kind <= 148U)) {
            {
#line 1191
            __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                          "c-parse.y", 1191U, "yyparse");
            }
          }
        } else {
          {
#line 1191
          __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                        "c-parse.y", 1191U, "yyparse");
          }
        }
      }
      {
#line 1191
      fc___0 = (function_call )tEmPcast___45;
#line 1192
      calltype___0 = (fc___0->arg1)->type;
#line 1194
      tmp___38 = type_command(calltype___0);
      }
#line 1194
      if (tmp___38) {
        {
#line 1195
        error("commands must be called with call");
        }
      } else {
        {
#line 1196
        tmp___37 = type_event(calltype___0);
        }
#line 1196
        if (tmp___37) {
          {
#line 1197
          error("events must be signaled with signal");
          }
        } else {
          {
#line 1198
          tmp___36 = type_task(calltype___0);
          }
#line 1198
          if (tmp___36) {
            {
#line 1199
            error("tasks must be posted with post");
            }
          }
        }
      }
    }
  }
#line 1202
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 1204
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 1205
  yyval.u.expr = make_va_arg((yyvsp + -5)->u.itoken.location, (yyvsp + -3)->u.expr,
                             (yyvsp + -1)->u.type);
  }
#line 1206
  goto switch_break;
  case_206: /* CIL Label */ 
  {
#line 1207
  yyval.u.expr = make_offsetof((yyvsp + -5)->u.itoken.location, (yyvsp + -3)->u.type,
                               (yyvsp + -1)->u.fields);
  }
#line 1208
  goto switch_break;
  case_207: /* CIL Label */ 
  {
#line 1209
  yyval.u.expr = make_array_ref((yyvsp + -2)->u.itoken.location, (yyvsp + -3)->u.expr,
                                (yyvsp + -1)->u.expr);
  }
#line 1210
  goto switch_break;
  case_208: /* CIL Label */ 
  {
#line 1211
  yyval.u.expr = make_field_ref((yyvsp + -1)->u.itoken.location, (yyvsp + -2)->u.expr,
                                (yyvsp + 0)->idtoken.id);
  }
#line 1212
  goto switch_break;
  case_209: /* CIL Label */ 
  {
#line 1213
  tmp___39 = make_dereference((yyvsp + -1)->u.itoken.location, (yyvsp + -2)->u.expr);
#line 1213
  yyval.u.expr = make_field_ref((yyvsp + -1)->u.itoken.location, tmp___39, (yyvsp + 0)->idtoken.id);
  }
#line 1215
  goto switch_break;
  case_210: /* CIL Label */ 
  {
#line 1216
  yyval.u.expr = make_postincrement((yyvsp + 0)->u.itoken.location, (yyvsp + -1)->u.expr);
  }
#line 1217
  goto switch_break;
  case_211: /* CIL Label */ 
  {
#line 1218
  yyval.u.expr = make_postdecrement((yyvsp + 0)->u.itoken.location, (yyvsp + -1)->u.expr);
  }
#line 1219
  goto switch_break;
  case_212: /* CIL Label */ 
  {
#line 1222
  yyval.u.fields = dd_new_list(parse_region);
#line 1222
  dd_add_last(parse_region, yyval.u.fields, (void *)(yyvsp + 0)->idtoken.id.data);
  }
#line 1223
  goto switch_break;
  case_213: /* CIL Label */ 
  {
#line 1223
  yyval.u.fields = (yyvsp + -2)->u.fields;
#line 1223
  dd_add_last(parse_region, yyval.u.fields, (void *)(yyvsp + 0)->idtoken.id.data);
  }
#line 1224
  goto switch_break;
  case_214: /* CIL Label */ 
  {
#line 1228
  yyval.u.expr = make_function_call((yyvsp + -2)->u.itoken.location, (yyvsp + -3)->u.expr,
                                    (yyvsp + -1)->u.expr);
  }
#line 1229
  goto switch_break;
  case_215: /* CIL Label */ 
#line 1231
  tEmPcast___46 = (AST_generic )(yyvsp + 0)->u.string;
#line 1231
  if (tEmPcast___46) {
#line 1231
    if ((unsigned int )tEmPcast___46->kind >= 84U) {
#line 1231
      if (! ((unsigned int )tEmPcast___46->kind <= 156U)) {
        {
#line 1231
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1231U, "yyparse");
        }
      }
    } else {
      {
#line 1231
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1231U, "yyparse");
      }
    }
  }
#line 1231
  yyval.u.expr = (expression )tEmPcast___46;
#line 1232
  goto switch_break;
  case_216: /* CIL Label */ 
  {
#line 1232
  yyval.u.expr = make_identifier((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id,
                                 (bool )0);
  }
#line 1233
  goto switch_break;
  case_217: /* CIL Label */ 
#line 1236
  yyval.u.decl = (declaration )((void *)0);
#line 1237
  goto switch_break;
  case_219: /* CIL Label */ 
#line 1240
  if (pedantic) {
    {
#line 1241
    pedwarn("ANSI C does not permit use of `varargs.h\'");
    }
  }
  {
#line 1242
  tmp___40 = new_ellipsis_decl(parse_region, (yyvsp + 0)->u.itoken.location);
#line 1242
  tEmPcast___47 = (AST_generic )tmp___40;
  }
#line 1242
  if (tEmPcast___47) {
#line 1242
    if ((unsigned int )tEmPcast___47->kind >= 43U) {
#line 1242
      if (! ((unsigned int )tEmPcast___47->kind <= 64U)) {
        {
#line 1242
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 1242U, "yyparse");
        }
      }
    } else {
      {
#line 1242
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 1242U, "yyparse");
      }
    }
  }
  {
#line 1242
  yyval.u.decl = declaration_chain((declaration )tEmPcast___47, (yyvsp + -1)->u.decl);
  }
#line 1244
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 1251
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 1252
  goto switch_break;
  case_222: /* CIL Label */ 
  {
#line 1260
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 1261
  goto switch_break;
  case_223: /* CIL Label */ 
  {
#line 1262
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 1263
  goto switch_break;
  case_224: /* CIL Label */ 
  {
#line 1264
  shadow_tag_warned((yyvsp + -2)->u.telement, 1);
#line 1265
  yyval.u.decl = make_data_decl((yyvsp + -2)->u.telement, (declaration )((void *)0));
#line 1266
  pedwarn("empty declaration");
  }
#line 1267
  goto switch_break;
  case_225: /* CIL Label */ 
  {
#line 1268
  pedwarn("empty declaration");
#line 1269
  yyval.u.decl = (declaration )((void *)0);
  }
#line 1270
  goto switch_break;
  case_227: /* CIL Label */ 
  {
#line 1278
  yyval.u.decl = make_error_decl();
  }
#line 1279
  goto switch_break;
  case_228: /* CIL Label */ 
  {
#line 1279
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
  }
#line 1280
  goto switch_break;
  case_229: /* CIL Label */ 
  {
#line 1280
  yyval.u.decl = make_error_decl();
  }
#line 1281
  goto switch_break;
  case_230: /* CIL Label */ 
  {
#line 1289
  push_declspec_stack();
#line 1290
  pending_xref_error();
#line 1291
  pstate.declspecs = (yyvsp + 0)->u.telement;
#line 1292
  pstate.attributes = (attribute )((void *)0);
  }
#line 1294
  goto switch_break;
  case_231: /* CIL Label */ 
#line 1300
  pstate.attributes = (yyvsp + 0)->u.attribute;
#line 1301
  goto switch_break;
  case_232: /* CIL Label */ 
  {
#line 1305
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 1306
  goto switch_break;
  case_233: /* CIL Label */ 
  {
#line 1307
  yyval.u.decl = make_data_decl((yyvsp + -3)->u.telement, (yyvsp + -1)->u.decl);
  }
#line 1308
  goto switch_break;
  case_234: /* CIL Label */ 
  {
#line 1309
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 1310
  pop_declspec_stack();
  }
#line 1311
  goto switch_break;
  case_235: /* CIL Label */ 
  {
#line 1312
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 1313
  pop_declspec_stack();
  }
#line 1314
  goto switch_break;
  case_236: /* CIL Label */ 
  {
#line 1315
  shadow_tag((yyvsp + -2)->u.telement);
#line 1316
  yyval.u.decl = make_data_decl((yyvsp + -2)->u.telement, (declaration )((void *)0));
  }
#line 1317
  goto switch_break;
  case_237: /* CIL Label */ 
  {
#line 1318
  yyval.u.decl = make_extension_decl((yyvsp + -1)->u.itoken.i, (yyvsp + -1)->u.itoken.location,
                                     (yyvsp + 0)->u.decl);
  }
#line 1319
  goto switch_break;
  case_239: /* CIL Label */ 
  {
#line 1375
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1376
  goto switch_break;
  case_240: /* CIL Label */ 
  {
#line 1377
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1378
  goto switch_break;
  case_241: /* CIL Label */ 
  {
#line 1382
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1383
  goto switch_break;
  case_242: /* CIL Label */ 
  {
#line 1387
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1388
  goto switch_break;
  case_243: /* CIL Label */ 
  {
#line 1389
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1390
  goto switch_break;
  case_247: /* CIL Label */ 
  {
#line 1400
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1401
  goto switch_break;
  case_248: /* CIL Label */ 
  {
#line 1402
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1403
  goto switch_break;
  case_249: /* CIL Label */ 
  {
#line 1404
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1405
  goto switch_break;
  case_250: /* CIL Label */ 
  {
#line 1406
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1407
  goto switch_break;
  case_251: /* CIL Label */ 
  {
#line 1408
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1409
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 1410
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1411
  goto switch_break;
  case_254: /* CIL Label */ 
  {
#line 1416
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1417
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 1418
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1419
  goto switch_break;
  case_256: /* CIL Label */ 
  {
#line 1420
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1421
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 1422
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1423
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 1424
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1425
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 1429
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1430
  goto switch_break;
  case_260: /* CIL Label */ 
  {
#line 1431
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1432
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 1433
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1434
  goto switch_break;
  case_262: /* CIL Label */ 
  {
#line 1435
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1436
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 1437
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1438
  goto switch_break;
  case_264: /* CIL Label */ 
  {
#line 1439
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1440
  goto switch_break;
  case_265: /* CIL Label */ 
  {
#line 1444
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1445
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 1446
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1447
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 1448
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1449
  goto switch_break;
  case_268: /* CIL Label */ 
  {
#line 1450
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1451
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 1452
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1453
  goto switch_break;
  case_271: /* CIL Label */ 
  {
#line 1458
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1459
  goto switch_break;
  case_272: /* CIL Label */ 
  {
#line 1460
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1461
  goto switch_break;
  case_273: /* CIL Label */ 
  {
#line 1462
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1463
  goto switch_break;
  case_274: /* CIL Label */ 
  {
#line 1464
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1465
  goto switch_break;
  case_275: /* CIL Label */ 
  {
#line 1466
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1467
  goto switch_break;
  case_276: /* CIL Label */ 
  {
#line 1468
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1469
  goto switch_break;
  case_277: /* CIL Label */ 
  {
#line 1473
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1474
  goto switch_break;
  case_278: /* CIL Label */ 
  {
#line 1478
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1479
  goto switch_break;
  case_279: /* CIL Label */ 
  {
#line 1480
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1481
  goto switch_break;
  case_280: /* CIL Label */ 
  {
#line 1482
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1483
  goto switch_break;
  case_281: /* CIL Label */ 
  {
#line 1484
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1485
  goto switch_break;
  case_282: /* CIL Label */ 
  {
#line 1486
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1487
  goto switch_break;
  case_283: /* CIL Label */ 
  {
#line 1488
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1489
  goto switch_break;
  case_284: /* CIL Label */ 
  {
#line 1493
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1494
  goto switch_break;
  case_285: /* CIL Label */ 
  {
#line 1498
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1499
  goto switch_break;
  case_286: /* CIL Label */ 
  {
#line 1500
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1501
  goto switch_break;
  case_287: /* CIL Label */ 
  {
#line 1502
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1503
  goto switch_break;
  case_288: /* CIL Label */ 
  {
#line 1504
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1505
  goto switch_break;
  case_289: /* CIL Label */ 
  {
#line 1506
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1507
  goto switch_break;
  case_290: /* CIL Label */ 
  {
#line 1508
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1509
  goto switch_break;
  case_291: /* CIL Label */ 
  {
#line 1510
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1511
  goto switch_break;
  case_292: /* CIL Label */ 
  {
#line 1512
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1513
  goto switch_break;
  case_293: /* CIL Label */ 
  {
#line 1514
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1515
  goto switch_break;
  case_294: /* CIL Label */ 
  {
#line 1516
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1517
  goto switch_break;
  case_295: /* CIL Label */ 
  {
#line 1521
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1522
  goto switch_break;
  case_296: /* CIL Label */ 
  {
#line 1523
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1524
  goto switch_break;
  case_297: /* CIL Label */ 
  {
#line 1525
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1526
  goto switch_break;
  case_298: /* CIL Label */ 
  {
#line 1527
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1528
  goto switch_break;
  case_299: /* CIL Label */ 
  {
#line 1529
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1530
  goto switch_break;
  case_300: /* CIL Label */ 
  {
#line 1534
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1535
  goto switch_break;
  case_301: /* CIL Label */ 
  {
#line 1536
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1537
  goto switch_break;
  case_302: /* CIL Label */ 
  {
#line 1538
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1539
  goto switch_break;
  case_303: /* CIL Label */ 
  {
#line 1540
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1541
  goto switch_break;
  case_304: /* CIL Label */ 
  {
#line 1542
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1543
  goto switch_break;
  case_305: /* CIL Label */ 
  {
#line 1544
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1545
  goto switch_break;
  case_306: /* CIL Label */ 
  {
#line 1546
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1547
  goto switch_break;
  case_307: /* CIL Label */ 
  {
#line 1548
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1549
  goto switch_break;
  case_308: /* CIL Label */ 
  {
#line 1550
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1551
  goto switch_break;
  case_309: /* CIL Label */ 
  {
#line 1552
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1553
  goto switch_break;
  case_310: /* CIL Label */ 
  {
#line 1557
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1558
  goto switch_break;
  case_311: /* CIL Label */ 
  {
#line 1559
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1560
  goto switch_break;
  case_312: /* CIL Label */ 
  {
#line 1561
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1562
  goto switch_break;
  case_313: /* CIL Label */ 
  {
#line 1563
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1564
  goto switch_break;
  case_314: /* CIL Label */ 
  {
#line 1565
  yyval.u.telement = type_element_chain((yyvsp + -1)->u.telement, (yyvsp + 0)->u.telement);
  }
#line 1566
  goto switch_break;
  case_351: /* CIL Label */ 
#line 1632
  yyval.u.telement = (type_element )((void *)0);
#line 1633
  goto switch_break;
  case_359: /* CIL Label */ 
  {
#line 1679
  tmp___41 = new_typename(parse_region, (yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.decl);
#line 1679
  tEmPcast___48 = (AST_generic )tmp___41;
  }
#line 1679
  if (tEmPcast___48) {
#line 1679
    if ((unsigned int )tEmPcast___48->kind >= 157U) {
#line 1679
      if (! ((unsigned int )tEmPcast___48->kind <= 174U)) {
        {
#line 1679
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1679U, "yyparse");
        }
      }
    } else {
      {
#line 1679
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1679U, "yyparse");
      }
    }
  }
#line 1679
  yyval.u.telement = (type_element )tEmPcast___48;
#line 1680
  goto switch_break;
  case_360: /* CIL Label */ 
  {
#line 1683
  tmp___42 = new_component_typeref(parse_region, (yyvsp + -2)->idtoken.location, (yyvsp + 0)->idtoken.decl,
                                   (yyvsp + -2)->idtoken.id);
#line 1683
  tEmPcast___49 = (AST_generic )tmp___42;
  }
#line 1683
  if (tEmPcast___49) {
#line 1683
    if ((unsigned int )tEmPcast___49->kind >= 157U) {
#line 1683
      if (! ((unsigned int )tEmPcast___49->kind <= 174U)) {
        {
#line 1683
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1683U, "yyparse");
        }
      }
    } else {
      {
#line 1683
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1683U, "yyparse");
      }
    }
  }
#line 1683
  yyval.u.telement = (type_element )tEmPcast___49;
#line 1685
  goto switch_break;
  case_361: /* CIL Label */ 
  {
#line 1686
  tmp___43 = new_typeof_expr(parse_region, (yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.expr);
#line 1686
  tEmPcast___50 = (AST_generic )tmp___43;
  }
#line 1686
  if (tEmPcast___50) {
#line 1686
    if ((unsigned int )tEmPcast___50->kind >= 157U) {
#line 1686
      if (! ((unsigned int )tEmPcast___50->kind <= 174U)) {
        {
#line 1686
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1686U, "yyparse");
        }
      }
    } else {
      {
#line 1686
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1686U, "yyparse");
      }
    }
  }
#line 1686
  yyval.u.telement = (type_element )tEmPcast___50;
#line 1687
  goto switch_break;
  case_362: /* CIL Label */ 
  {
#line 1688
  tmp___44 = new_typeof_type(parse_region, (yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.type);
#line 1688
  tEmPcast___51 = (AST_generic )tmp___44;
  }
#line 1688
  if (tEmPcast___51) {
#line 1688
    if ((unsigned int )tEmPcast___51->kind >= 157U) {
#line 1688
      if (! ((unsigned int )tEmPcast___51->kind <= 174U)) {
        {
#line 1688
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1688U, "yyparse");
        }
      }
    } else {
      {
#line 1688
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1688U, "yyparse");
      }
    }
  }
#line 1688
  yyval.u.telement = (type_element )tEmPcast___51;
#line 1689
  goto switch_break;
  case_363: /* CIL Label */ 
#line 1693
  tEmPcast___53 = (AST_generic )(yyvsp + 0)->u.decl;
#line 1693
  if (tEmPcast___53) {
#line 1693
    if ((unsigned int )tEmPcast___53->kind >= 42U) {
#line 1693
      if (! ((unsigned int )tEmPcast___53->kind <= 199U)) {
        {
#line 1693
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1693U, "yyparse");
        }
      }
    } else {
      {
#line 1693
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1693U, "yyparse");
      }
    }
  }
  {
#line 1693
  tmp___45 = AST_node_reverse((node )tEmPcast___53);
#line 1693
  tEmPcast___52 = (AST_generic )tmp___45;
  }
#line 1693
  if (tEmPcast___52) {
#line 1693
    if ((unsigned int )tEmPcast___52->kind >= 43U) {
#line 1693
      if (! ((unsigned int )tEmPcast___52->kind <= 64U)) {
        {
#line 1693
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 1693U, "yyparse");
        }
      }
    } else {
      {
#line 1693
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 1693U, "yyparse");
      }
    }
  }
#line 1693
  yyval.u.decl = (declaration )tEmPcast___52;
#line 1694
  goto switch_break;
  case_364: /* CIL Label */ 
#line 1697
  tEmPcast___55 = (AST_generic )(yyvsp + 0)->u.decl;
#line 1697
  if (tEmPcast___55) {
#line 1697
    if ((unsigned int )tEmPcast___55->kind >= 42U) {
#line 1697
      if (! ((unsigned int )tEmPcast___55->kind <= 199U)) {
        {
#line 1697
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1697U, "yyparse");
        }
      }
    } else {
      {
#line 1697
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1697U, "yyparse");
      }
    }
  }
  {
#line 1697
  tmp___46 = AST_node_reverse((node )tEmPcast___55);
#line 1697
  tEmPcast___54 = (AST_generic )tmp___46;
  }
#line 1697
  if (tEmPcast___54) {
#line 1697
    if ((unsigned int )tEmPcast___54->kind >= 43U) {
#line 1697
      if (! ((unsigned int )tEmPcast___54->kind <= 64U)) {
        {
#line 1697
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 1697U, "yyparse");
        }
      }
    } else {
      {
#line 1697
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 1697U, "yyparse");
      }
    }
  }
#line 1697
  yyval.u.decl = (declaration )tEmPcast___54;
#line 1698
  goto switch_break;
  case_366: /* CIL Label */ 
  {
#line 1703
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -3)->u.decl);
  }
#line 1704
  goto switch_break;
  case_367: /* CIL Label */ 
#line 1707
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 1708
  goto switch_break;
  case_368: /* CIL Label */ 
  {
#line 1709
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -3)->u.decl);
  }
#line 1710
  goto switch_break;
  case_369: /* CIL Label */ 
#line 1714
  yyval.u.asm_stmt = (asm_stmt )((void *)0);
#line 1715
  goto switch_break;
  case_370: /* CIL Label */ 
#line 1716
  tEmPcast___56 = (AST_generic )(yyvsp + -1)->u.string;
#line 1716
  if (tEmPcast___56) {
#line 1716
    if ((unsigned int )tEmPcast___56->kind >= 84U) {
#line 1716
      if (! ((unsigned int )tEmPcast___56->kind <= 156U)) {
        {
#line 1716
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1716U, "yyparse");
        }
      }
    } else {
      {
#line 1716
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1716U, "yyparse");
      }
    }
  }
  {
#line 1716
  yyval.u.asm_stmt = new_asm_stmt(parse_region, (yyvsp + -3)->u.itoken.location, (expression )tEmPcast___56,
                                  (asm_operand )((void *)0), (asm_operand )((void *)0),
                                  (string )((void *)0), (type_element )((void *)0));
  }
#line 1718
  goto switch_break;
  case_371: /* CIL Label */ 
  {
#line 1722
  tmp___47 = prefix_attr((yyvsp + -1)->u.attribute);
#line 1722
  yyval.u.decl = start_decl((yyvsp + -3)->u.declarator, (yyvsp + -2)->u.asm_stmt,
                            pstate.declspecs, (bool )1, tmp___47);
#line 1724
  start_init(yyval.u.decl, (nesc_attribute )((void *)0));
  }
#line 1725
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 1727
  finish_init();
#line 1728
  yyval.u.decl = finish_decl((yyvsp + -1)->u.decl, (yyvsp + 0)->u.expr);
  }
#line 1729
  goto switch_break;
  case_373: /* CIL Label */ 
  {
#line 1730
  tmp___48 = prefix_attr((yyvsp + 0)->u.attribute);
#line 1730
  tmp___49 = start_decl((yyvsp + -2)->u.declarator, (yyvsp + -1)->u.asm_stmt, pstate.declspecs,
                        (bool )0, tmp___48);
#line 1730
  d = tmp___49;
#line 1732
  yyval.u.decl = finish_decl(d, (expression )((void *)0));
  }
#line 1733
  goto switch_break;
  case_374: /* CIL Label */ 
  {
#line 1737
  tmp___50 = prefix_attr((yyvsp + -1)->u.attribute);
#line 1737
  yyval.u.decl = start_decl((yyvsp + -3)->u.declarator, (yyvsp + -2)->u.asm_stmt,
                            pstate.declspecs, (bool )1, tmp___50);
#line 1739
  start_init(yyval.u.decl, (nesc_attribute )((void *)0));
  }
#line 1740
  goto switch_break;
  case_375: /* CIL Label */ 
  {
#line 1742
  finish_init();
#line 1743
  yyval.u.decl = finish_decl((yyvsp + -1)->u.decl, (yyvsp + 0)->u.expr);
  }
#line 1744
  goto switch_break;
  case_376: /* CIL Label */ 
  {
#line 1745
  tmp___51 = prefix_attr((yyvsp + 0)->u.attribute);
#line 1745
  tmp___52 = start_decl((yyvsp + -2)->u.declarator, (yyvsp + -1)->u.asm_stmt, pstate.declspecs,
                        (bool )0, tmp___51);
#line 1745
  d___0 = tmp___52;
#line 1747
  yyval.u.decl = finish_decl(d___0, (expression )((void *)0));
  }
#line 1748
  goto switch_break;
  case_377: /* CIL Label */ 
#line 1752
  yyval.u.attribute = (attribute )((void *)0);
#line 1753
  goto switch_break;
  case_378: /* CIL Label */ 
#line 1754
  tEmPcast___58 = (AST_generic )(yyvsp + 0)->u.attribute;
#line 1754
  if (tEmPcast___58) {
#line 1754
    if ((unsigned int )tEmPcast___58->kind >= 42U) {
#line 1754
      if (! ((unsigned int )tEmPcast___58->kind <= 199U)) {
        {
#line 1754
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1754U, "yyparse");
        }
      }
    } else {
      {
#line 1754
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1754U, "yyparse");
      }
    }
  }
  {
#line 1754
  tmp___53 = AST_node_reverse((node )tEmPcast___58);
#line 1754
  tEmPcast___57 = (AST_generic )tmp___53;
  }
#line 1754
  if (tEmPcast___57) {
#line 1754
    if ((unsigned int )tEmPcast___57->kind >= 162U) {
#line 1754
      if (! ((unsigned int )tEmPcast___57->kind <= 165U)) {
        {
#line 1754
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "c-parse.y", 1754U, "yyparse");
        }
      }
    } else {
      {
#line 1754
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "c-parse.y", 1754U, "yyparse");
      }
    }
  }
#line 1754
  yyval.u.attribute = (attribute )tEmPcast___57;
#line 1755
  goto switch_break;
  case_379: /* CIL Label */ 
#line 1758
  tEmPcast___59 = (AST_generic )(yyvsp + 0)->u.attribute;
#line 1758
  if (tEmPcast___59) {
#line 1758
    if ((unsigned int )tEmPcast___59->kind >= 157U) {
#line 1758
      if (! ((unsigned int )tEmPcast___59->kind <= 174U)) {
        {
#line 1758
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1758U, "yyparse");
        }
      }
    } else {
      {
#line 1758
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1758U, "yyparse");
      }
    }
  }
#line 1758
  yyval.u.telement = (type_element )tEmPcast___59;
#line 1759
  goto switch_break;
  case_380: /* CIL Label */ 
#line 1762
  yyval.u.attribute = (attribute )((void *)0);
#line 1763
  goto switch_break;
  case_381: /* CIL Label */ 
  {
#line 1764
  yyval.u.attribute = attribute_chain((yyvsp + 0)->u.attribute, (yyvsp + -1)->u.attribute);
  }
#line 1765
  goto switch_break;
  case_382: /* CIL Label */ 
#line 1769
  yyval.u.attribute = (yyvsp + 0)->u.attribute;
#line 1770
  goto switch_break;
  case_383: /* CIL Label */ 
  {
#line 1771
  yyval.u.attribute = attribute_chain((yyvsp + 0)->u.attribute, (yyvsp + -1)->u.attribute);
  }
#line 1772
  goto switch_break;
  case_384: /* CIL Label */ 
#line 1776
  yyval.u.attribute = (yyvsp + -2)->u.attribute;
#line 1777
  goto switch_break;
  case_385: /* CIL Label */ 
#line 1777
  tEmPcast___60 = (AST_generic )(yyvsp + 0)->u.gcc_attribute;
#line 1777
  if (tEmPcast___60) {
#line 1777
    if ((unsigned int )tEmPcast___60->kind >= 162U) {
#line 1777
      if (! ((unsigned int )tEmPcast___60->kind <= 165U)) {
        {
#line 1777
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "c-parse.y", 1777U, "yyparse");
        }
      }
    } else {
      {
#line 1777
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "c-parse.y", 1777U, "yyparse");
      }
    }
  }
#line 1777
  yyval.u.attribute = (attribute )tEmPcast___60;
#line 1778
  goto switch_break;
  case_387: /* CIL Label */ 
  {
#line 1783
  tmp___54 = new_word(parse_region, (yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
#line 1783
  w = tmp___54;
#line 1784
  yyval.u.gcc_attribute = new_target_attribute(parse_region, (yyvsp + 0)->idtoken.location,
                                               w, (expression )((void *)0));
  }
#line 1785
  goto switch_break;
  case_388: /* CIL Label */ 
  {
#line 1786
  tmp___55 = new_word(parse_region, (yyvsp + -1)->idtoken.location, (yyvsp + -1)->idtoken.id);
#line 1786
  w___0 = tmp___55;
#line 1787
  yyval.u.gcc_attribute = new_target_attribute(parse_region, (yyvsp + -1)->idtoken.location,
                                               w___0, (yyvsp + 0)->u.expr);
  }
#line 1788
  goto switch_break;
  case_389: /* CIL Label */ 
  {
#line 1789
  tmp___56 = str2cstring(parse_region, "iar_at");
#line 1789
  tmp___57 = new_word(parse_region, ((yyvsp + 0)->u.expr)->location, tmp___56);
#line 1789
  w___1 = tmp___57;
#line 1790
  yyval.u.gcc_attribute = new_target_attribute(parse_region, ((yyvsp + 0)->u.expr)->location,
                                               w___1, (yyvsp + 0)->u.expr);
  }
#line 1791
  goto switch_break;
  case_390: /* CIL Label */ 
#line 1794
  tEmPcast___61 = (AST_generic )(yyvsp + 0)->u.constant;
#line 1794
  if (tEmPcast___61) {
#line 1794
    if ((unsigned int )tEmPcast___61->kind >= 84U) {
#line 1794
      if (! ((unsigned int )tEmPcast___61->kind <= 156U)) {
        {
#line 1794
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1794U, "yyparse");
        }
      }
    } else {
      {
#line 1794
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1794U, "yyparse");
      }
    }
  }
#line 1794
  yyval.u.expr = (expression )tEmPcast___61;
#line 1795
  goto switch_break;
  case_391: /* CIL Label */ 
#line 1795
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 1796
  goto switch_break;
  case_392: /* CIL Label */ 
#line 1796
  yyval.u.expr = (yyvsp + -1)->u.expr;
#line 1797
  goto switch_break;
  case_393: /* CIL Label */ 
#line 1801
  tEmPcast___62 = (AST_generic )(yyvsp + 0)->u.gcc_attribute;
#line 1801
  if (tEmPcast___62) {
#line 1801
    if ((unsigned int )tEmPcast___62->kind >= 162U) {
#line 1801
      if (! ((unsigned int )tEmPcast___62->kind <= 165U)) {
        {
#line 1801
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "c-parse.y", 1801U, "yyparse");
        }
      }
    } else {
      {
#line 1801
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "c-parse.y", 1801U, "yyparse");
      }
    }
  }
#line 1801
  yyval.u.attribute = (attribute )tEmPcast___62;
#line 1802
  goto switch_break;
  case_394: /* CIL Label */ 
#line 1803
  tEmPcast___63 = (AST_generic )(yyvsp + 0)->u.gcc_attribute;
#line 1803
  if (tEmPcast___63) {
#line 1803
    if ((unsigned int )tEmPcast___63->kind >= 162U) {
#line 1803
      if (! ((unsigned int )tEmPcast___63->kind <= 165U)) {
        {
#line 1803
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "c-parse.y", 1803U, "yyparse");
        }
      }
    } else {
      {
#line 1803
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "c-parse.y", 1803U, "yyparse");
      }
    }
  }
  {
#line 1803
  yyval.u.attribute = attribute_chain((yyvsp + -2)->u.attribute, (attribute )tEmPcast___63);
  }
#line 1804
  goto switch_break;
  case_395: /* CIL Label */ 
#line 1808
  yyval.u.gcc_attribute = (gcc_attribute )((void *)0);
#line 1809
  goto switch_break;
  case_396: /* CIL Label */ 
  {
#line 1810
  yyval.u.gcc_attribute = new_gcc_attribute(parse_region, ((yyvsp + 0)->u.word)->location,
                                            (yyvsp + 0)->u.word, (expression )((void *)0));
  }
#line 1811
  goto switch_break;
  case_397: /* CIL Label */ 
  {
#line 1812
  tmp___58 = make_attr_args((yyvsp + -1)->idtoken.location, (yyvsp + -1)->idtoken.id,
                            (expression )((void *)0));
#line 1812
  yyval.u.gcc_attribute = new_gcc_attribute(parse_region, ((yyvsp + -3)->u.word)->location,
                                            (yyvsp + -3)->u.word, tmp___58);
  }
#line 1814
  goto switch_break;
  case_398: /* CIL Label */ 
  {
#line 1815
  tmp___59 = make_attr_args((yyvsp + -3)->idtoken.location, (yyvsp + -3)->idtoken.id,
                            (yyvsp + -1)->u.expr);
#line 1815
  yyval.u.gcc_attribute = new_gcc_attribute(parse_region, (yyvsp + -4)->u.itoken.location,
                                            (yyvsp + -5)->u.word, tmp___59);
  }
#line 1818
  goto switch_break;
  case_399: /* CIL Label */ 
  {
#line 1819
  yyval.u.gcc_attribute = new_gcc_attribute(parse_region, (yyvsp + -2)->u.itoken.location,
                                            (yyvsp + -3)->u.word, (yyvsp + -1)->u.expr);
  }
#line 1821
  goto switch_break;
  case_400: /* CIL Label */ 
  {
#line 1825
  yyval.u.attribute = finish_attribute_use((yyvsp + -3)->u.nesc_attribute, (yyvsp + -1)->u.expr);
  }
#line 1826
  goto switch_break;
  case_401: /* CIL Label */ 
  {
#line 1827
  tmp___60 = make_error_expr();
#line 1827
  yyval.u.attribute = finish_attribute_use((yyvsp + -2)->u.nesc_attribute, tmp___60);
  }
#line 1828
  goto switch_break;
  case_402: /* CIL Label */ 
  {
#line 1832
  yyval.u.nesc_attribute = start_attribute_use((yyvsp + 0)->u.word);
  }
#line 1833
  goto switch_break;
  case_404: /* CIL Label */ 
#line 1841
  tEmPcast___64 = (AST_generic )(yyvsp + 0)->u.telement;
#line 1841
  if (tEmPcast___64) {
#line 1841
    if ((unsigned int )tEmPcast___64->kind >= 166U) {
#line 1841
      if (! ((unsigned int )tEmPcast___64->kind <= 166U)) {
        {
#line 1841
        __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                      "c-parse.y", 1841U, "yyparse");
        }
      }
    } else {
      {
#line 1841
      __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                    "c-parse.y", 1841U, "yyparse");
      }
    }
  }
  {
#line 1841
  tmp___61 = rid_name((rid )tEmPcast___64);
#line 1841
  yyval.u.word = make_cword(((yyvsp + 0)->u.telement)->location, (char const   *)tmp___61);
  }
#line 1842
  goto switch_break;
  case_405: /* CIL Label */ 
#line 1843
  tEmPcast___65 = (AST_generic )(yyvsp + 0)->u.telement;
#line 1843
  if (tEmPcast___65) {
#line 1843
    if ((unsigned int )tEmPcast___65->kind >= 166U) {
#line 1843
      if (! ((unsigned int )tEmPcast___65->kind <= 166U)) {
        {
#line 1843
        __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                      "c-parse.y", 1843U, "yyparse");
        }
      }
    } else {
      {
#line 1843
      __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                    "c-parse.y", 1843U, "yyparse");
      }
    }
  }
  {
#line 1843
  tmp___62 = rid_name((rid )tEmPcast___65);
#line 1843
  yyval.u.word = make_cword(((yyvsp + 0)->u.telement)->location, (char const   *)tmp___62);
  }
#line 1844
  goto switch_break;
  case_406: /* CIL Label */ 
#line 1845
  tEmPcast___66 = (AST_generic )(yyvsp + 0)->u.telement;
#line 1845
  if (tEmPcast___66) {
#line 1845
    if ((unsigned int )tEmPcast___66->kind >= 167U) {
#line 1845
      if (! ((unsigned int )tEmPcast___66->kind <= 167U)) {
        {
#line 1845
        __assert_fail("((tEmPcast)->kind >= kind_qualifier && (tEmPcast)->kind <= postkind_qualifier)",
                      "c-parse.y", 1845U, "yyparse");
        }
      }
    } else {
      {
#line 1845
      __assert_fail("((tEmPcast)->kind >= kind_qualifier && (tEmPcast)->kind <= postkind_qualifier)",
                    "c-parse.y", 1845U, "yyparse");
      }
    }
  }
  {
#line 1845
  tmp___63 = qualifier_name((type_quals )((qualifier )tEmPcast___66)->id);
#line 1845
  yyval.u.word = make_cword(((yyvsp + 0)->u.telement)->location, (char const   *)tmp___63);
  }
#line 1846
  goto switch_break;
  case_407: /* CIL Label */ 
  {
#line 1847
  yyval.u.word = make_cword((yyvsp + 0)->u.itoken.location, "signal");
  }
#line 1848
  goto switch_break;
  case_408: /* CIL Label */ 
  {
#line 1853
  yyval.u.expr = (yyvsp + 0)->u.expr;
#line 1853
  simple_init(yyval.u.expr);
  }
#line 1854
  goto switch_break;
  case_409: /* CIL Label */ 
  {
#line 1855
  really_start_incremental_init((type )((void *)0));
  }
#line 1856
  goto switch_break;
  case_410: /* CIL Label */ 
  {
#line 1857
  yyval.u.expr = make_init_list((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.expr);
  }
#line 1858
  goto switch_break;
  case_411: /* CIL Label */ 
  {
#line 1859
  yyval.u.expr = make_error_expr();
  }
#line 1860
  goto switch_break;
  case_412: /* CIL Label */ 
#line 1865
  if (pedantic) {
    {
#line 1866
    pedwarn("ANSI C forbids empty initializer braces");
    }
  }
#line 1867
  yyval.u.expr = (expression )((void *)0);
#line 1868
  goto switch_break;
  case_413: /* CIL Label */ 
#line 1868
  tEmPcast___68 = (AST_generic )(yyvsp + -1)->u.expr;
#line 1868
  if (tEmPcast___68) {
#line 1868
    if ((unsigned int )tEmPcast___68->kind >= 42U) {
#line 1868
      if (! ((unsigned int )tEmPcast___68->kind <= 199U)) {
        {
#line 1868
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1868U, "yyparse");
        }
      }
    } else {
      {
#line 1868
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1868U, "yyparse");
      }
    }
  }
  {
#line 1868
  tmp___64 = AST_node_reverse((node )tEmPcast___68);
#line 1868
  tEmPcast___67 = (AST_generic )tmp___64;
  }
#line 1868
  if (tEmPcast___67) {
#line 1868
    if ((unsigned int )tEmPcast___67->kind >= 84U) {
#line 1868
      if (! ((unsigned int )tEmPcast___67->kind <= 156U)) {
        {
#line 1868
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "c-parse.y", 1868U, "yyparse");
        }
      }
    } else {
      {
#line 1868
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "c-parse.y", 1868U, "yyparse");
      }
    }
  }
#line 1868
  yyval.u.expr = (expression )tEmPcast___67;
#line 1869
  goto switch_break;
  case_415: /* CIL Label */ 
  {
#line 1873
  yyval.u.expr = expression_chain((yyvsp + 0)->u.expr, (yyvsp + -2)->u.expr);
  }
#line 1874
  goto switch_break;
  case_416: /* CIL Label */ 
#line 1880
  if (pedantic) {
    {
#line 1881
    pedwarn("ANSI C forbids specifying subobject to initialize");
    }
  }
  {
#line 1882
  yyval.u.expr = make_init_specific((yyvsp + -2)->u.designator, (yyvsp + 0)->u.expr);
  }
#line 1883
  goto switch_break;
  case_417: /* CIL Label */ 
#line 1884
  if (pedantic) {
    {
#line 1885
    pedwarn("obsolete use of designated initializer without `=\'");
    }
  }
  {
#line 1886
  yyval.u.expr = make_init_specific((yyvsp + -1)->u.designator, (yyvsp + 0)->u.expr);
  }
#line 1887
  goto switch_break;
  case_418: /* CIL Label */ 
  {
#line 1888
  yyval.u.designator = set_init_label((yyvsp + -1)->idtoken.location, (yyvsp + -1)->idtoken.id);
  }
#line 1889
  if (pedantic) {
    {
#line 1890
    pedwarn("obsolete use of designated initializer with `:\'");
    }
  }
#line 1891
  goto switch_break;
  case_419: /* CIL Label */ 
  {
#line 1892
  yyval.u.expr = make_init_specific((yyvsp + -1)->u.designator, (yyvsp + 0)->u.expr);
  }
#line 1893
  goto switch_break;
  case_421: /* CIL Label */ 
  {
#line 1898
  push_init_level(0);
  }
#line 1899
  goto switch_break;
  case_422: /* CIL Label */ 
  {
#line 1900
  yyval.u.expr = make_init_list((yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.expr);
#line 1901
  process_init_element((expression )((void *)0));
  }
#line 1902
  goto switch_break;
  case_423: /* CIL Label */ 
  {
#line 1903
  process_init_element((yyvsp + 0)->u.expr);
#line 1903
  yyval.u.expr = (yyvsp + 0)->u.expr;
  }
#line 1904
  goto switch_break;
  case_424: /* CIL Label */ 
  {
#line 1904
  yyval.u.expr = make_error_expr();
  }
#line 1905
  goto switch_break;
  case_426: /* CIL Label */ 
  {
#line 1909
  yyval.u.designator = designator_chain((yyvsp + -1)->u.designator, (yyvsp + 0)->u.designator);
  }
#line 1910
  goto switch_break;
  case_427: /* CIL Label */ 
  {
#line 1914
  yyval.u.designator = set_init_label((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 1915
  goto switch_break;
  case_428: /* CIL Label */ 
  {
#line 1919
  yyval.u.designator = set_init_index((yyvsp + -4)->u.itoken.location, (yyvsp + -3)->u.expr,
                                      (yyvsp + -1)->u.expr);
  }
#line 1920
  if (pedantic) {
    {
#line 1921
    pedwarn("ISO C forbids specifying range of elements to initialize");
    }
  }
#line 1922
  goto switch_break;
  case_429: /* CIL Label */ 
  {
#line 1923
  yyval.u.designator = set_init_index((yyvsp + -2)->u.itoken.location, (yyvsp + -1)->u.expr,
                                      (expression )((void *)0));
  }
#line 1924
  goto switch_break;
  case_430: /* CIL Label */ 
  {
#line 1930
  refuse_asm((yyvsp + -1)->u.asm_stmt);
#line 1932
  tmp___65 = start_function(pstate.declspecs, (yyvsp + -2)->u.declarator, (yyvsp + 0)->u.attribute,
                            (bool )1);
  }
#line 1932
  if (! tmp___65) {
    {
#line 1934
    yyerror("syntax error");
    }
#line 1934
    goto yyerrorlab;
  }
#line 1937
  goto switch_break;
  case_431: /* CIL Label */ 
#line 1938
  tEmPcast___70 = (AST_generic )(yyvsp + -2)->u.attribute;
#line 1938
  if (tEmPcast___70) {
#line 1938
    if ((unsigned int )tEmPcast___70->kind >= 42U) {
#line 1938
      if (! ((unsigned int )tEmPcast___70->kind <= 199U)) {
        {
#line 1938
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1938U, "yyparse");
        }
      }
    } else {
      {
#line 1938
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1938U, "yyparse");
      }
    }
  }
  {
#line 1938
  tmp___66 = AST_node_reverse((node )tEmPcast___70);
#line 1938
  tEmPcast___69 = (AST_generic )tmp___66;
  }
#line 1938
  if (tEmPcast___69) {
#line 1938
    if ((unsigned int )tEmPcast___69->kind >= 43U) {
#line 1938
      if (! ((unsigned int )tEmPcast___69->kind <= 64U)) {
        {
#line 1938
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 1938U, "yyparse");
        }
      }
    } else {
      {
#line 1938
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 1938U, "yyparse");
      }
    }
  }
  {
#line 1938
  store_parm_decls((declaration )tEmPcast___69);
  }
#line 1939
  goto switch_break;
  case_432: /* CIL Label */ 
  {
#line 1946
  yyval.u.decl = finish_function((yyvsp + 0)->u.stmt);
  }
#line 1947
  goto switch_break;
  case_433: /* CIL Label */ 
  {
#line 1953
  refuse_asm((yyvsp + -1)->u.asm_stmt);
#line 1955
  tmp___67 = start_function(pstate.declspecs, (yyvsp + -2)->u.declarator, (yyvsp + 0)->u.attribute,
                            (bool )1);
  }
#line 1955
  if (! tmp___67) {
    {
#line 1957
    yyerror("syntax error");
    }
#line 1957
    goto yyerrorlab;
  }
#line 1960
  goto switch_break;
  case_434: /* CIL Label */ 
#line 1961
  tEmPcast___72 = (AST_generic )(yyvsp + -2)->u.attribute;
#line 1961
  if (tEmPcast___72) {
#line 1961
    if ((unsigned int )tEmPcast___72->kind >= 42U) {
#line 1961
      if (! ((unsigned int )tEmPcast___72->kind <= 199U)) {
        {
#line 1961
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 1961U, "yyparse");
        }
      }
    } else {
      {
#line 1961
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 1961U, "yyparse");
      }
    }
  }
  {
#line 1961
  tmp___68 = AST_node_reverse((node )tEmPcast___72);
#line 1961
  tEmPcast___71 = (AST_generic )tmp___68;
  }
#line 1961
  if (tEmPcast___71) {
#line 1961
    if ((unsigned int )tEmPcast___71->kind >= 43U) {
#line 1961
      if (! ((unsigned int )tEmPcast___71->kind <= 64U)) {
        {
#line 1961
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 1961U, "yyparse");
        }
      }
    } else {
      {
#line 1961
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 1961U, "yyparse");
      }
    }
  }
  {
#line 1961
  store_parm_decls((declaration )tEmPcast___71);
  }
#line 1962
  goto switch_break;
  case_435: /* CIL Label */ 
  {
#line 1969
  yyval.u.decl = finish_function((yyvsp + 0)->u.stmt);
  }
#line 1970
  goto switch_break;
  case_438: /* CIL Label */ 
  {
#line 1984
  yyval.u.declarator = finish_array_or_fn_declarator((yyvsp + -1)->u.declarator, (yyvsp + 0)->u.nested);
  }
#line 1985
  goto switch_break;
  case_439: /* CIL Label */ 
  {
#line 1986
  yyval.u.declarator = make_pointer_declarator((yyvsp + -2)->u.itoken.location, (yyvsp + 0)->u.declarator,
                                               (yyvsp + -1)->u.telement);
  }
#line 1987
  goto switch_break;
  case_440: /* CIL Label */ 
#line 1988
  tEmPcast___73 = (AST_generic )(yyvsp + -2)->u.attribute;
#line 1988
  if (tEmPcast___73) {
#line 1988
    if ((unsigned int )tEmPcast___73->kind >= 157U) {
#line 1988
      if (! ((unsigned int )tEmPcast___73->kind <= 174U)) {
        {
#line 1988
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 1988U, "yyparse");
        }
      }
    } else {
      {
#line 1988
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 1988U, "yyparse");
      }
    }
  }
  {
#line 1988
  yyval.u.declarator = make_qualified_declarator((yyvsp + -3)->u.itoken.location,
                                                 (yyvsp + -1)->u.declarator, (type_element )tEmPcast___73);
  }
#line 1989
  goto switch_break;
  case_441: /* CIL Label */ 
  {
#line 1989
  yyval.u.declarator = make_identifier_declarator((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 1990
  goto switch_break;
  case_442: /* CIL Label */ 
  {
#line 1992
  yyval.u.declarator = make_interface_ref_declarator((yyvsp + -2)->idtoken.location,
                                                     (yyvsp + -2)->idtoken.id, (yyvsp + 0)->idtoken.id);
  }
#line 1994
  goto switch_break;
  case_443: /* CIL Label */ 
  {
#line 2002
  yyval.u.declarator = finish_array_or_fn_declarator((yyvsp + -1)->u.declarator, (yyvsp + 0)->u.nested);
  }
#line 2003
  goto switch_break;
  case_444: /* CIL Label */ 
  {
#line 2004
  yyval.u.declarator = make_pointer_declarator((yyvsp + -2)->u.itoken.location, (yyvsp + 0)->u.declarator,
                                               (yyvsp + -1)->u.telement);
  }
#line 2005
  goto switch_break;
  case_445: /* CIL Label */ 
  {
#line 2006
  yyval.u.declarator = make_identifier_declarator((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 2007
  goto switch_break;
  case_446: /* CIL Label */ 
  {
#line 2015
  yyval.u.declarator = finish_array_or_fn_declarator((yyvsp + -1)->u.declarator, (yyvsp + 0)->u.nested);
  }
#line 2016
  goto switch_break;
  case_447: /* CIL Label */ 
  {
#line 2017
  yyval.u.declarator = make_pointer_declarator((yyvsp + -2)->u.itoken.location, (yyvsp + 0)->u.declarator,
                                               (yyvsp + -1)->u.telement);
  }
#line 2018
  goto switch_break;
  case_448: /* CIL Label */ 
#line 2019
  tEmPcast___74 = (AST_generic )(yyvsp + -2)->u.attribute;
#line 2019
  if (tEmPcast___74) {
#line 2019
    if ((unsigned int )tEmPcast___74->kind >= 157U) {
#line 2019
      if (! ((unsigned int )tEmPcast___74->kind <= 174U)) {
        {
#line 2019
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2019U, "yyparse");
        }
      }
    } else {
      {
#line 2019
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2019U, "yyparse");
      }
    }
  }
  {
#line 2019
  yyval.u.declarator = make_qualified_declarator((yyvsp + -3)->u.itoken.location,
                                                 (yyvsp + -1)->u.declarator, (type_element )tEmPcast___74);
  }
#line 2020
  goto switch_break;
  case_449: /* CIL Label */ 
  {
#line 2021
  yyval.u.declarator = make_identifier_declarator((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 2022
  goto switch_break;
  case_450: /* CIL Label */ 
  {
#line 2024
  yyval.u.declarator = make_interface_ref_declarator((yyvsp + -2)->idtoken.location,
                                                     (yyvsp + -2)->idtoken.id, (yyvsp + 0)->idtoken.id);
  }
#line 2026
  goto switch_break;
  case_451: /* CIL Label */ 
  {
#line 2029
  yyval.u.word = new_word(parse_region, (yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 2030
  goto switch_break;
  case_452: /* CIL Label */ 
  {
#line 2034
  yyval.u.telement = xref_tag((yyvsp + -2)->u.itoken.location, (AST_kind )(yyvsp + -2)->u.itoken.i,
                              (yyvsp + -1)->u.word);
  }
#line 2035
  if ((yyvsp + 0)->u.attribute) {
    {
#line 2035
    warning("attributes ignored");
    }
  }
#line 2036
  goto switch_break;
  case_453: /* CIL Label */ 
  {
#line 2037
  yyval.u.telement = xref_tag((yyvsp + -2)->u.itoken.location, (AST_kind )174, (yyvsp + -1)->u.word);
  }
#line 2038
  if ((yyvsp + 0)->u.attribute) {
    {
#line 2038
    warning("attributes ignored");
    }
  }
#line 2039
  goto switch_break;
  case_454: /* CIL Label */ 
  {
#line 2043
  yyval.u.telement = start_struct((yyvsp + -3)->u.itoken.location, (AST_kind )(yyvsp + -3)->u.itoken.i,
                                  (yyvsp + -2)->u.word);
  }
#line 2046
  goto switch_break;
  case_455: /* CIL Label */ 
  {
#line 2047
  tmp___69 = attribute_chain((yyvsp + -5)->u.attribute, (yyvsp + 0)->u.attribute);
#line 2047
  yyval.u.telement = finish_struct((yyvsp + -3)->u.telement, (yyvsp + -2)->u.decl,
                                   tmp___69);
  }
#line 2048
  goto switch_break;
  case_456: /* CIL Label */ 
  {
#line 2049
  yyval.u.telement = start_struct((yyvsp + -4)->u.itoken.location, (AST_kind )173,
                                  (yyvsp + -2)->u.word);
  }
#line 2052
  goto switch_break;
  case_457: /* CIL Label */ 
  {
#line 2053
  tmp___70 = attribute_chain((yyvsp + -5)->u.attribute, (yyvsp + 0)->u.attribute);
#line 2053
  yyval.u.telement = finish_struct((yyvsp + -3)->u.telement, (yyvsp + -2)->u.decl,
                                   tmp___70);
  }
#line 2054
  goto switch_break;
  case_458: /* CIL Label */ 
  {
#line 2055
  tmp___71 = start_struct((yyvsp + -4)->u.itoken.location, (AST_kind )(yyvsp + -4)->u.itoken.i,
                          (word )((void *)0));
#line 2055
  yyval.u.telement = finish_struct(tmp___71, (yyvsp + -2)->u.decl, (yyvsp + 0)->u.attribute);
  }
#line 2058
  goto switch_break;
  case_459: /* CIL Label */ 
  {
#line 2059
  yyval.u.telement = start_enum((yyvsp + -3)->u.itoken.location, (yyvsp + -2)->u.word);
  }
#line 2060
  goto switch_break;
  case_460: /* CIL Label */ 
  {
#line 2061
  tmp___72 = attribute_chain((yyvsp + -6)->u.attribute, (yyvsp + 0)->u.attribute);
#line 2061
  tEmPcast___76 = (AST_generic )(yyvsp + -3)->u.decl;
  }
#line 2061
  if (tEmPcast___76) {
#line 2061
    if ((unsigned int )tEmPcast___76->kind >= 42U) {
#line 2061
      if (! ((unsigned int )tEmPcast___76->kind <= 199U)) {
        {
#line 2061
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2061U, "yyparse");
        }
      }
    } else {
      {
#line 2061
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2061U, "yyparse");
      }
    }
  }
  {
#line 2061
  tmp___73 = AST_node_reverse((node )tEmPcast___76);
#line 2061
  tEmPcast___75 = (AST_generic )tmp___73;
  }
#line 2061
  if (tEmPcast___75) {
#line 2061
    if ((unsigned int )tEmPcast___75->kind >= 43U) {
#line 2061
      if (! ((unsigned int )tEmPcast___75->kind <= 64U)) {
        {
#line 2061
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2061U, "yyparse");
        }
      }
    } else {
      {
#line 2061
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2061U, "yyparse");
      }
    }
  }
  {
#line 2061
  yyval.u.telement = finish_enum((yyvsp + -4)->u.telement, (declaration )tEmPcast___75,
                                 tmp___72);
  }
#line 2062
  goto switch_break;
  case_461: /* CIL Label */ 
  {
#line 2063
  yyval.u.telement = start_enum((yyvsp + -1)->u.itoken.location, (word )((void *)0));
  }
#line 2064
  goto switch_break;
  case_462: /* CIL Label */ 
#line 2065
  tEmPcast___78 = (AST_generic )(yyvsp + -3)->u.decl;
#line 2065
  if (tEmPcast___78) {
#line 2065
    if ((unsigned int )tEmPcast___78->kind >= 42U) {
#line 2065
      if (! ((unsigned int )tEmPcast___78->kind <= 199U)) {
        {
#line 2065
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2065U, "yyparse");
        }
      }
    } else {
      {
#line 2065
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2065U, "yyparse");
      }
    }
  }
  {
#line 2065
  tmp___74 = AST_node_reverse((node )tEmPcast___78);
#line 2065
  tEmPcast___77 = (AST_generic )tmp___74;
  }
#line 2065
  if (tEmPcast___77) {
#line 2065
    if ((unsigned int )tEmPcast___77->kind >= 43U) {
#line 2065
      if (! ((unsigned int )tEmPcast___77->kind <= 64U)) {
        {
#line 2065
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2065U, "yyparse");
        }
      }
    } else {
      {
#line 2065
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2065U, "yyparse");
      }
    }
  }
  {
#line 2065
  yyval.u.telement = finish_enum((yyvsp + -4)->u.telement, (declaration )tEmPcast___77,
                                 (yyvsp + 0)->u.attribute);
  }
#line 2066
  goto switch_break;
  case_463: /* CIL Label */ 
#line 2069
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 2069
  yyval.u.itoken.i = 169;
#line 2070
  goto switch_break;
  case_464: /* CIL Label */ 
#line 2070
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 2070
  yyval.u.itoken.i = 171;
#line 2071
  goto switch_break;
  case_465: /* CIL Label */ 
#line 2071
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 2071
  yyval.u.itoken.i = 170;
#line 2072
  goto switch_break;
  case_466: /* CIL Label */ 
#line 2072
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 2072
  yyval.u.itoken.i = 172;
#line 2073
  goto switch_break;
  case_470: /* CIL Label */ 
#line 2083
  if (pedantic) {
    {
#line 2083
    pedwarn("comma at end of enumerator list");
    }
  }
#line 2084
  goto switch_break;
  case_471: /* CIL Label */ 
#line 2088
  tEmPcast___80 = (AST_generic )(yyvsp + 0)->u.decl;
#line 2088
  if (tEmPcast___80) {
#line 2088
    if ((unsigned int )tEmPcast___80->kind >= 42U) {
#line 2088
      if (! ((unsigned int )tEmPcast___80->kind <= 199U)) {
        {
#line 2088
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2088U, "yyparse");
        }
      }
    } else {
      {
#line 2088
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2088U, "yyparse");
      }
    }
  }
  {
#line 2088
  tmp___75 = AST_node_reverse((node )tEmPcast___80);
#line 2088
  tEmPcast___79 = (AST_generic )tmp___75;
  }
#line 2088
  if (tEmPcast___79) {
#line 2088
    if ((unsigned int )tEmPcast___79->kind >= 43U) {
#line 2088
      if (! ((unsigned int )tEmPcast___79->kind <= 64U)) {
        {
#line 2088
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2088U, "yyparse");
        }
      }
    } else {
      {
#line 2088
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2088U, "yyparse");
      }
    }
  }
#line 2088
  yyval.u.decl = (declaration )tEmPcast___79;
#line 2089
  goto switch_break;
  case_472: /* CIL Label */ 
  {
#line 2090
  tmp___76 = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -1)->u.decl);
#line 2090
  tEmPcast___82 = (AST_generic )tmp___76;
  }
#line 2090
  if (tEmPcast___82) {
#line 2090
    if ((unsigned int )tEmPcast___82->kind >= 42U) {
#line 2090
      if (! ((unsigned int )tEmPcast___82->kind <= 199U)) {
        {
#line 2090
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2090U, "yyparse");
        }
      }
    } else {
      {
#line 2090
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2090U, "yyparse");
      }
    }
  }
  {
#line 2090
  tmp___77 = AST_node_reverse((node )tEmPcast___82);
#line 2090
  tEmPcast___81 = (AST_generic )tmp___77;
  }
#line 2090
  if (tEmPcast___81) {
#line 2090
    if ((unsigned int )tEmPcast___81->kind >= 43U) {
#line 2090
      if (! ((unsigned int )tEmPcast___81->kind <= 64U)) {
        {
#line 2090
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2090U, "yyparse");
        }
      }
    } else {
      {
#line 2090
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2090U, "yyparse");
      }
    }
  }
  {
#line 2090
  yyval.u.decl = (declaration )tEmPcast___81;
#line 2091
  pedwarn("no semicolon at end of struct or union");
  }
#line 2092
  goto switch_break;
  case_473: /* CIL Label */ 
#line 2096
  yyval.u.decl = (declaration )((void *)0);
#line 2097
  goto switch_break;
  case_474: /* CIL Label */ 
  {
#line 2098
  yyval.u.decl = declaration_chain((yyvsp + -1)->u.decl, (yyvsp + -2)->u.decl);
  }
#line 2099
  goto switch_break;
  case_475: /* CIL Label */ 
#line 2100
  if (pedantic) {
    {
#line 2101
    pedwarn("extra semicolon in struct or union specified");
    }
  }
#line 2102
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 2103
  goto switch_break;
  case_476: /* CIL Label */ 
#line 2116
  tEmPcast___84 = (AST_generic )(yyvsp + 0)->u.decl;
#line 2116
  if (tEmPcast___84) {
#line 2116
    if ((unsigned int )tEmPcast___84->kind >= 42U) {
#line 2116
      if (! ((unsigned int )tEmPcast___84->kind <= 199U)) {
        {
#line 2116
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2116U, "yyparse");
        }
      }
    } else {
      {
#line 2116
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2116U, "yyparse");
      }
    }
  }
  {
#line 2116
  tmp___78 = AST_node_reverse((node )tEmPcast___84);
#line 2116
  tEmPcast___83 = (AST_generic )tmp___78;
  }
#line 2116
  if (tEmPcast___83) {
#line 2116
    if ((unsigned int )tEmPcast___83->kind >= 43U) {
#line 2116
      if (! ((unsigned int )tEmPcast___83->kind <= 64U)) {
        {
#line 2116
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2116U, "yyparse");
        }
      }
    } else {
      {
#line 2116
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2116U, "yyparse");
      }
    }
  }
  {
#line 2116
  yyval.u.decl = make_data_decl((yyvsp + -2)->u.telement, (declaration )tEmPcast___83);
  }
#line 2117
  goto switch_break;
  case_477: /* CIL Label */ 
#line 2118
  if (pedantic) {
    {
#line 2119
    pedwarn("ISO C doesn\'t support unnamed structs/unions");
    }
  }
  {
#line 2121
  yyval.u.decl = make_data_decl((yyvsp + -1)->u.telement, (declaration )((void *)0));
  }
#line 2122
  goto switch_break;
  case_478: /* CIL Label */ 
#line 2123
  tEmPcast___86 = (AST_generic )(yyvsp + 0)->u.decl;
#line 2123
  if (tEmPcast___86) {
#line 2123
    if ((unsigned int )tEmPcast___86->kind >= 42U) {
#line 2123
      if (! ((unsigned int )tEmPcast___86->kind <= 199U)) {
        {
#line 2123
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2123U, "yyparse");
        }
      }
    } else {
      {
#line 2123
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2123U, "yyparse");
      }
    }
  }
  {
#line 2123
  tmp___79 = AST_node_reverse((node )tEmPcast___86);
#line 2123
  tEmPcast___85 = (AST_generic )tmp___79;
  }
#line 2123
  if (tEmPcast___85) {
#line 2123
    if ((unsigned int )tEmPcast___85->kind >= 43U) {
#line 2123
      if (! ((unsigned int )tEmPcast___85->kind <= 64U)) {
        {
#line 2123
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2123U, "yyparse");
        }
      }
    } else {
      {
#line 2123
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2123U, "yyparse");
      }
    }
  }
  {
#line 2123
  yyval.u.decl = make_data_decl((yyvsp + -2)->u.telement, (declaration )tEmPcast___85);
  }
#line 2124
  goto switch_break;
  case_479: /* CIL Label */ 
#line 2125
  if (pedantic) {
    {
#line 2126
    pedwarn("ANSI C forbids member declarations with no members");
    }
  }
  {
#line 2127
  shadow_tag((yyvsp + -1)->u.telement);
#line 2128
  yyval.u.decl = make_data_decl((yyvsp + -1)->u.telement, (declaration )((void *)0));
  }
#line 2129
  goto switch_break;
  case_480: /* CIL Label */ 
  {
#line 2130
  yyval.u.decl = make_error_decl();
  }
#line 2131
  goto switch_break;
  case_481: /* CIL Label */ 
  {
#line 2132
  yyval.u.decl = make_extension_decl((yyvsp + -1)->u.itoken.i, (yyvsp + -1)->u.itoken.location,
                                     (yyvsp + 0)->u.decl);
  }
#line 2133
  goto switch_break;
  case_483: /* CIL Label */ 
  {
#line 2138
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -3)->u.decl);
  }
#line 2139
  goto switch_break;
  case_485: /* CIL Label */ 
  {
#line 2146
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -3)->u.decl);
  }
#line 2147
  goto switch_break;
  case_486: /* CIL Label */ 
  {
#line 2151
  tmp___80 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2151
  yyval.u.decl = make_field((yyvsp + -1)->u.declarator, (expression )((void *)0),
                            pstate.declspecs, tmp___80);
  }
#line 2153
  goto switch_break;
  case_487: /* CIL Label */ 
  {
#line 2154
  tmp___81 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2154
  yyval.u.decl = make_field((yyvsp + -3)->u.declarator, (yyvsp + -1)->u.expr, pstate.declspecs,
                            tmp___81);
  }
#line 2156
  goto switch_break;
  case_488: /* CIL Label */ 
  {
#line 2157
  tmp___82 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2157
  yyval.u.decl = make_field((declarator )((void *)0), (yyvsp + -1)->u.expr, pstate.declspecs,
                            tmp___82);
  }
#line 2159
  goto switch_break;
  case_489: /* CIL Label */ 
  {
#line 2163
  tmp___83 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2163
  yyval.u.decl = make_field((yyvsp + -1)->u.declarator, (expression )((void *)0),
                            pstate.declspecs, tmp___83);
  }
#line 2165
  goto switch_break;
  case_490: /* CIL Label */ 
  {
#line 2166
  tmp___84 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2166
  yyval.u.decl = make_field((yyvsp + -3)->u.declarator, (yyvsp + -1)->u.expr, pstate.declspecs,
                            tmp___84);
  }
#line 2168
  goto switch_break;
  case_491: /* CIL Label */ 
  {
#line 2169
  tmp___85 = prefix_attr((yyvsp + 0)->u.attribute);
#line 2169
  yyval.u.decl = make_field((declarator )((void *)0), (yyvsp + -1)->u.expr, pstate.declspecs,
                            tmp___85);
  }
#line 2171
  goto switch_break;
  case_493: /* CIL Label */ 
  {
#line 2176
  yyval.u.decl = declaration_chain((yyvsp + 0)->u.decl, (yyvsp + -2)->u.decl);
  }
#line 2177
  goto switch_break;
  case_494: /* CIL Label */ 
#line 2178
  yyval.u.decl = (declaration )((void *)0);
#line 2179
  goto switch_break;
  case_495: /* CIL Label */ 
  {
#line 2184
  yyval.u.decl = make_enumerator((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id,
                                 (expression )((void *)0));
  }
#line 2185
  goto switch_break;
  case_496: /* CIL Label */ 
  {
#line 2186
  yyval.u.decl = make_enumerator((yyvsp + -2)->idtoken.location, (yyvsp + -2)->idtoken.id,
                                 (yyvsp + 0)->u.expr);
  }
#line 2187
  goto switch_break;
  case_497: /* CIL Label */ 
  {
#line 2191
  pending_xref_error();
  }
#line 2192
  goto switch_break;
  case_498: /* CIL Label */ 
  {
#line 2193
  yyval.u.type = make_type((yyvsp + -2)->u.telement, (yyvsp + 0)->u.declarator);
  }
#line 2194
  goto switch_break;
  case_499: /* CIL Label */ 
#line 2198
  yyval.u.declarator = (declarator )((void *)0);
#line 2199
  goto switch_break;
  case_504: /* CIL Label */ 
  {
#line 2210
  yyval.u.declarator = make_pointer_declarator((yyvsp + -2)->u.itoken.location, (yyvsp + 0)->u.declarator,
                                               (yyvsp + -1)->u.telement);
  }
#line 2211
  goto switch_break;
  case_505: /* CIL Label */ 
  {
#line 2215
  yyval.u.declarator = make_pointer_declarator((yyvsp + -1)->u.itoken.location, (declarator )((void *)0),
                                               (yyvsp + 0)->u.telement);
  }
#line 2216
  goto switch_break;
  case_506: /* CIL Label */ 
  {
#line 2217
  yyval.u.declarator = make_pointer_declarator((yyvsp + -2)->u.itoken.location, (yyvsp + 0)->u.declarator,
                                               (yyvsp + -1)->u.telement);
  }
#line 2218
  goto switch_break;
  case_507: /* CIL Label */ 
#line 2222
  tEmPcast___87 = (AST_generic )(yyvsp + -2)->u.attribute;
#line 2222
  if (tEmPcast___87) {
#line 2222
    if ((unsigned int )tEmPcast___87->kind >= 157U) {
#line 2222
      if (! ((unsigned int )tEmPcast___87->kind <= 174U)) {
        {
#line 2222
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2222U, "yyparse");
        }
      }
    } else {
      {
#line 2222
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2222U, "yyparse");
      }
    }
  }
  {
#line 2222
  yyval.u.declarator = make_qualified_declarator((yyvsp + -3)->u.itoken.location,
                                                 (yyvsp + -1)->u.declarator, (type_element )tEmPcast___87);
  }
#line 2223
  goto switch_break;
  case_508: /* CIL Label */ 
  {
#line 2224
  yyval.u.declarator = finish_array_or_fn_declarator((yyvsp + -1)->u.declarator, (yyvsp + 0)->u.nested);
  }
#line 2225
  goto switch_break;
  case_509: /* CIL Label */ 
  {
#line 2226
  yyval.u.declarator = finish_array_or_fn_declarator((declarator )((void *)0), (yyvsp + 0)->u.nested);
  }
#line 2227
  goto switch_break;
  case_514: /* CIL Label */ 
  {
#line 2241
  tmp___86 = new_function_declarator(parse_region, (yyvsp + -2)->u.itoken.location,
                                     (declarator )((void *)0), (yyvsp + -1)->u.decl,
                                     (yyvsp + -3)->u.decl, (yyvsp + 0)->u.telement,
                                     (environment )((void *)0));
#line 2241
  tEmPcast___88 = (AST_generic )tmp___86;
  }
#line 2241
  if (tEmPcast___88) {
#line 2241
    if ((unsigned int )tEmPcast___88->kind >= 176U) {
#line 2241
      if (! ((unsigned int )tEmPcast___88->kind <= 181U)) {
        {
#line 2241
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "c-parse.y", 2242U, "yyparse");
        }
      }
    } else {
      {
#line 2241
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "c-parse.y", 2242U, "yyparse");
      }
    }
  }
#line 2241
  yyval.u.nested = (nested_declarator )tEmPcast___88;
#line 2243
  goto switch_break;
  case_515: /* CIL Label */ 
  {
#line 2244
  tmp___87 = new_function_declarator(parse_region, (yyvsp + -2)->u.itoken.location,
                                     (declarator )((void *)0), (yyvsp + -1)->u.decl,
                                     (declaration )((void *)0), (yyvsp + 0)->u.telement,
                                     (environment )((void *)0));
#line 2244
  tEmPcast___89 = (AST_generic )tmp___87;
  }
#line 2244
  if (tEmPcast___89) {
#line 2244
    if ((unsigned int )tEmPcast___89->kind >= 176U) {
#line 2244
      if (! ((unsigned int )tEmPcast___89->kind <= 181U)) {
        {
#line 2244
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "c-parse.y", 2245U, "yyparse");
        }
      }
    } else {
      {
#line 2244
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "c-parse.y", 2245U, "yyparse");
      }
    }
  }
#line 2244
  yyval.u.nested = (nested_declarator )tEmPcast___89;
#line 2246
  goto switch_break;
  case_516: /* CIL Label */ 
  {
#line 2250
  tmp___88 = new_function_declarator(parse_region, (yyvsp + -2)->u.itoken.location,
                                     (declarator )((void *)0), (yyvsp + -1)->u.decl,
                                     (declaration )((void *)0), (yyvsp + 0)->u.telement,
                                     (environment )((void *)0));
#line 2250
  tEmPcast___90 = (AST_generic )tmp___88;
  }
#line 2250
  if (tEmPcast___90) {
#line 2250
    if ((unsigned int )tEmPcast___90->kind >= 176U) {
#line 2250
      if (! ((unsigned int )tEmPcast___90->kind <= 181U)) {
        {
#line 2250
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "c-parse.y", 2251U, "yyparse");
        }
      }
    } else {
      {
#line 2250
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "c-parse.y", 2251U, "yyparse");
      }
    }
  }
#line 2250
  yyval.u.nested = (nested_declarator )tEmPcast___90;
#line 2252
  goto switch_break;
  case_517: /* CIL Label */ 
  {
#line 2256
  tmp___89 = new_array_declarator(parse_region, (yyvsp + -2)->u.itoken.location, (declarator )((void *)0),
                                  (yyvsp + -1)->u.expr);
#line 2256
  tEmPcast___91 = (AST_generic )tmp___89;
  }
#line 2256
  if (tEmPcast___91) {
#line 2256
    if ((unsigned int )tEmPcast___91->kind >= 176U) {
#line 2256
      if (! ((unsigned int )tEmPcast___91->kind <= 181U)) {
        {
#line 2256
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "c-parse.y", 2256U, "yyparse");
        }
      }
    } else {
      {
#line 2256
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "c-parse.y", 2256U, "yyparse");
      }
    }
  }
#line 2256
  yyval.u.nested = (nested_declarator )tEmPcast___91;
#line 2257
  goto switch_break;
  case_518: /* CIL Label */ 
  {
#line 2258
  tmp___90 = new_array_declarator(parse_region, (yyvsp + -1)->u.itoken.location, (declarator )((void *)0),
                                  (expression )((void *)0));
#line 2258
  tEmPcast___92 = (AST_generic )tmp___90;
  }
#line 2258
  if (tEmPcast___92) {
#line 2258
    if ((unsigned int )tEmPcast___92->kind >= 176U) {
#line 2258
      if (! ((unsigned int )tEmPcast___92->kind <= 181U)) {
        {
#line 2258
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "c-parse.y", 2258U, "yyparse");
        }
      }
    } else {
      {
#line 2258
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "c-parse.y", 2258U, "yyparse");
      }
    }
  }
#line 2258
  yyval.u.nested = (nested_declarator )tEmPcast___92;
#line 2259
  goto switch_break;
  case_519: /* CIL Label */ 
#line 2268
  if (pedantic) {
#line 2268
    if ((yyvsp + 0)->u.istmt.i) {
      {
#line 2269
      pedwarn("ANSI C forbids label at end of compound statement");
      }
    }
  }
#line 2271
  if ((yyvsp + 0)->u.istmt.i) {
#line 2273
    tEmPcast___94 = (AST_generic )(yyvsp + 0)->u.istmt.stmt;
#line 2273
    if (tEmPcast___94) {
#line 2273
      if ((unsigned int )tEmPcast___94->kind >= 42U) {
#line 2273
        if (! ((unsigned int )tEmPcast___94->kind <= 199U)) {
          {
#line 2273
          __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                        "c-parse.y", 2273U, "yyparse");
          }
        }
      } else {
        {
#line 2273
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2273U, "yyparse");
        }
      }
    }
    {
#line 2273
    tmp___91 = AST_node_last((node )tEmPcast___94);
#line 2273
    tEmPcast___93 = (AST_generic )tmp___91;
    }
#line 2273
    if (tEmPcast___93) {
#line 2273
      if ((unsigned int )tEmPcast___93->kind >= 65U) {
#line 2273
        if (! ((unsigned int )tEmPcast___93->kind <= 83U)) {
          {
#line 2273
          __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                        "c-parse.y", 2273U, "yyparse");
          }
        }
      } else {
        {
#line 2273
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2273U, "yyparse");
        }
      }
    }
    {
#line 2273
    last_label = (statement )tEmPcast___93;
#line 2275
    tmp___92 = new_empty_stmt(parse_region, last_label->location);
#line 2275
    tEmPcast___95 = (AST_generic )tmp___92;
    }
#line 2275
    if (tEmPcast___95) {
#line 2275
      if ((unsigned int )tEmPcast___95->kind >= 65U) {
#line 2275
        if (! ((unsigned int )tEmPcast___95->kind <= 83U)) {
          {
#line 2275
          __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                        "c-parse.y", 2275U, "yyparse");
          }
        }
      } else {
        {
#line 2275
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2275U, "yyparse");
        }
      }
    }
    {
#line 2275
    chain_with_labels(last_label, (statement )tEmPcast___95);
    }
  }
#line 2277
  yyval.u.stmt = (yyvsp + 0)->u.istmt.stmt;
#line 2279
  goto switch_break;
  case_521: /* CIL Label */ 
  {
#line 2284
  yyval.u.istmt.i = (yyvsp + 0)->u.istmt.i;
#line 2284
  yyval.u.istmt.stmt = chain_with_labels((yyvsp + -1)->u.istmt.stmt, (yyvsp + 0)->u.istmt.stmt);
  }
#line 2285
  goto switch_break;
  case_522: /* CIL Label */ 
  {
#line 2286
  yyval.u.istmt.i = 0;
#line 2286
  yyval.u.istmt.stmt = make_error_stmt();
  }
#line 2287
  goto switch_break;
  case_523: /* CIL Label */ 
#line 2290
  yyval.u.stmt = (statement )((void *)0);
#line 2291
  goto switch_break;
  case_526: /* CIL Label */ 
  {
#line 2299
  pushlevel((bool )0);
  }
#line 2300
  goto switch_break;
  case_527: /* CIL Label */ 
#line 2305
  yyval.u.id_label = (id_label )((void *)0);
#line 2306
  goto switch_break;
  case_528: /* CIL Label */ 
#line 2307
  if (pedantic) {
    {
#line 2308
    pedwarn("ANSI C forbids label declarations");
    }
  }
#line 2309
  tEmPcast___97 = (AST_generic )(yyvsp + 0)->u.id_label;
#line 2309
  if (tEmPcast___97) {
#line 2309
    if ((unsigned int )tEmPcast___97->kind >= 42U) {
#line 2309
      if (! ((unsigned int )tEmPcast___97->kind <= 199U)) {
        {
#line 2309
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2309U, "yyparse");
        }
      }
    } else {
      {
#line 2309
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2309U, "yyparse");
      }
    }
  }
  {
#line 2309
  tmp___93 = AST_node_reverse((node )tEmPcast___97);
#line 2309
  tEmPcast___96 = (AST_generic )tmp___93;
  }
#line 2309
  if (tEmPcast___96) {
#line 2309
    if ((unsigned int )tEmPcast___96->kind >= 185U) {
#line 2309
      if (! ((unsigned int )tEmPcast___96->kind <= 185U)) {
        {
#line 2309
        __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                      "c-parse.y", 2309U, "yyparse");
        }
      }
    } else {
      {
#line 2309
      __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                    "c-parse.y", 2309U, "yyparse");
      }
    }
  }
#line 2309
  yyval.u.id_label = (id_label )tEmPcast___96;
#line 2310
  goto switch_break;
  case_530: /* CIL Label */ 
  {
#line 2314
  yyval.u.id_label = id_label_chain((yyvsp + 0)->u.id_label, (yyvsp + -1)->u.id_label);
  }
#line 2315
  goto switch_break;
  case_531: /* CIL Label */ 
#line 2319
  yyval.u.id_label = (yyvsp + -1)->u.id_label;
#line 2320
  goto switch_break;
  case_533: /* CIL Label */ 
#line 2326
  yyval.u.stmt = (yyvsp + 0)->u.stmt;
#line 2327
  goto switch_break;
  case_534: /* CIL Label */ 
#line 2330
  yyval.u.itoken = (yyvsp + 0)->u.itoken;
#line 2330
  compstmt_count ++;
#line 2331
  goto switch_break;
  case_535: /* CIL Label */ 
  {
#line 2335
  tmp___94 = poplevel();
#line 2335
  tmp___95 = new_compound_stmt(parse_region, (yyvsp + -2)->u.itoken.location, (id_label )((void *)0),
                               (declaration )((void *)0), (statement )((void *)0),
                               tmp___94);
#line 2335
  tEmPcast___98 = (AST_generic )tmp___95;
  }
#line 2335
  if (tEmPcast___98) {
#line 2335
    if ((unsigned int )tEmPcast___98->kind >= 65U) {
#line 2335
      if (! ((unsigned int )tEmPcast___98->kind <= 83U)) {
        {
#line 2335
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2335U, "yyparse");
        }
      }
    } else {
      {
#line 2335
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2335U, "yyparse");
      }
    }
  }
#line 2335
  yyval.u.stmt = (statement )tEmPcast___98;
#line 2336
  goto switch_break;
  case_536: /* CIL Label */ 
  {
#line 2337
  tmp___96 = poplevel();
#line 2337
  tEmPcast___101 = (AST_generic )(yyvsp + -2)->u.decl;
  }
#line 2337
  if (tEmPcast___101) {
#line 2337
    if ((unsigned int )tEmPcast___101->kind >= 42U) {
#line 2337
      if (! ((unsigned int )tEmPcast___101->kind <= 199U)) {
        {
#line 2337
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "c-parse.y", 2338U, "yyparse");
        }
      }
    } else {
      {
#line 2337
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "c-parse.y", 2338U, "yyparse");
      }
    }
  }
  {
#line 2337
  tmp___97 = AST_node_reverse((node )tEmPcast___101);
#line 2337
  tEmPcast___100 = (AST_generic )tmp___97;
  }
#line 2337
  if (tEmPcast___100) {
#line 2337
    if ((unsigned int )tEmPcast___100->kind >= 43U) {
#line 2337
      if (! ((unsigned int )tEmPcast___100->kind <= 64U)) {
        {
#line 2337
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2338U, "yyparse");
        }
      }
    } else {
      {
#line 2337
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2338U, "yyparse");
      }
    }
  }
  {
#line 2337
  tmp___98 = new_compound_stmt(parse_region, (yyvsp + -5)->u.itoken.location, (yyvsp + -3)->u.id_label,
                               (declaration )tEmPcast___100, (yyvsp + -1)->u.stmt,
                               tmp___96);
#line 2337
  tEmPcast___99 = (AST_generic )tmp___98;
  }
#line 2337
  if (tEmPcast___99) {
#line 2337
    if ((unsigned int )tEmPcast___99->kind >= 65U) {
#line 2337
      if (! ((unsigned int )tEmPcast___99->kind <= 83U)) {
        {
#line 2337
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2338U, "yyparse");
        }
      }
    } else {
      {
#line 2337
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2338U, "yyparse");
      }
    }
  }
#line 2337
  yyval.u.stmt = (statement )tEmPcast___99;
#line 2339
  goto switch_break;
  case_537: /* CIL Label */ 
  {
#line 2340
  poplevel();
#line 2341
  yyval.u.stmt = make_error_stmt();
  }
#line 2342
  goto switch_break;
  case_538: /* CIL Label */ 
  {
#line 2343
  tmp___99 = poplevel();
#line 2343
  tmp___100 = new_compound_stmt(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -2)->u.id_label,
                                (declaration )((void *)0), (yyvsp + -1)->u.stmt, tmp___99);
#line 2343
  tEmPcast___102 = (AST_generic )tmp___100;
  }
#line 2343
  if (tEmPcast___102) {
#line 2343
    if ((unsigned int )tEmPcast___102->kind >= 65U) {
#line 2343
      if (! ((unsigned int )tEmPcast___102->kind <= 83U)) {
        {
#line 2343
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2343U, "yyparse");
        }
      }
    } else {
      {
#line 2343
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2343U, "yyparse");
      }
    }
  }
#line 2343
  yyval.u.stmt = (statement )tEmPcast___102;
#line 2344
  goto switch_break;
  case_539: /* CIL Label */ 
  {
#line 2349
  tmp___101 = new_if_stmt(parse_region, ((yyvsp + -1)->u.iexpr.expr)->location, (yyvsp + -1)->u.iexpr.expr,
                          (yyvsp + 0)->u.stmt, (statement )((void *)0));
#line 2349
  tEmPcast___103 = (AST_generic )tmp___101;
  }
#line 2349
  if (tEmPcast___103) {
#line 2349
    if ((unsigned int )tEmPcast___103->kind >= 65U) {
#line 2349
      if (! ((unsigned int )tEmPcast___103->kind <= 83U)) {
        {
#line 2349
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2349U, "yyparse");
        }
      }
    } else {
      {
#line 2349
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2349U, "yyparse");
      }
    }
  }
#line 2349
  yyval.u.istmt.stmt = (statement )tEmPcast___103;
#line 2350
  yyval.u.istmt.i = (yyvsp + -1)->u.iexpr.i;
#line 2351
  goto switch_break;
  case_540: /* CIL Label */ 
  {
#line 2351
  yyval.u.istmt.i = (yyvsp + -1)->u.iexpr.i;
#line 2351
  yyval.u.istmt.stmt = make_error_stmt();
  }
#line 2352
  goto switch_break;
  case_541: /* CIL Label */ 
  {
#line 2356
  yyval.u.iexpr.i = stmt_count;
#line 2357
  yyval.u.iexpr.expr = (yyvsp + -1)->u.expr;
#line 2358
  check_condition("if", (yyvsp + -1)->u.expr);
  }
#line 2359
  goto switch_break;
  case_542: /* CIL Label */ 
  {
#line 2366
  stmt_count ++;
#line 2367
  compstmt_count ++;
#line 2368
  tmp___102 = new_dowhile_stmt(parse_region, (yyvsp + 0)->u.itoken.location, (expression )((void *)0),
                               (statement )((void *)0));
#line 2368
  tEmPcast___104 = (AST_generic )tmp___102;
  }
#line 2368
  if (tEmPcast___104) {
#line 2368
    if ((unsigned int )tEmPcast___104->kind >= 71U) {
#line 2368
      if (! ((unsigned int )tEmPcast___104->kind <= 74U)) {
        {
#line 2368
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "c-parse.y", 2369U, "yyparse");
        }
      }
    } else {
      {
#line 2368
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "c-parse.y", 2369U, "yyparse");
      }
    }
  }
#line 2368
  yyval.u.cstmt = (conditional_stmt )tEmPcast___104;
#line 2370
  tEmPcast___105 = (AST_generic )yyval.u.cstmt;
#line 2370
  if (tEmPcast___105) {
#line 2370
    if ((unsigned int )tEmPcast___105->kind >= 65U) {
#line 2370
      if (! ((unsigned int )tEmPcast___105->kind <= 83U)) {
        {
#line 2370
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2370U, "yyparse");
        }
      }
    } else {
      {
#line 2370
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2370U, "yyparse");
      }
    }
  }
  {
#line 2370
  push_loop((statement )tEmPcast___105);
  }
#line 2371
  goto switch_break;
  case_543: /* CIL Label */ 
#line 2372
  yyval.u.cstmt = (yyvsp + -2)->u.cstmt;
#line 2373
  (yyval.u.cstmt)->stmt = (yyvsp + -1)->u.stmt;
#line 2374
  goto switch_break;
  case_544: /* CIL Label */ 
#line 2378
  yyval.u.stmt = (yyvsp + 0)->u.stmt;
#line 2379
  goto switch_break;
  case_545: /* CIL Label */ 
  {
#line 2380
  tmp___103 = new_labeled_stmt(parse_region, ((yyvsp + -1)->u.label)->location, (yyvsp + -1)->u.label,
                               (yyvsp + 0)->u.stmt);
#line 2380
  tEmPcast___106 = (AST_generic )tmp___103;
  }
#line 2380
  if (tEmPcast___106) {
#line 2380
    if ((unsigned int )tEmPcast___106->kind >= 65U) {
#line 2380
      if (! ((unsigned int )tEmPcast___106->kind <= 83U)) {
        {
#line 2380
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2380U, "yyparse");
        }
      }
    } else {
      {
#line 2380
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2380U, "yyparse");
      }
    }
  }
#line 2380
  yyval.u.stmt = (statement )tEmPcast___106;
#line 2381
  goto switch_break;
  case_546: /* CIL Label */ 
#line 2385
  yyval.u.istmt.i = 0;
#line 2385
  yyval.u.istmt.stmt = (yyvsp + 0)->u.stmt;
#line 2386
  goto switch_break;
  case_547: /* CIL Label */ 
  {
#line 2387
  yyval.u.istmt.i = 1;
#line 2387
  tmp___104 = new_labeled_stmt(parse_region, ((yyvsp + 0)->u.label)->location, (yyvsp + 0)->u.label,
                               (statement )((void *)0));
#line 2387
  tEmPcast___107 = (AST_generic )tmp___104;
  }
#line 2387
  if (tEmPcast___107) {
#line 2387
    if ((unsigned int )tEmPcast___107->kind >= 65U) {
#line 2387
      if (! ((unsigned int )tEmPcast___107->kind <= 83U)) {
        {
#line 2387
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2387U, "yyparse");
        }
      }
    } else {
      {
#line 2387
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2387U, "yyparse");
      }
    }
  }
#line 2387
  yyval.u.istmt.stmt = (statement )tEmPcast___107;
#line 2388
  goto switch_break;
  case_548: /* CIL Label */ 
  {
#line 2392
  last_atomic = current.in_atomic;
#line 2394
  current.in_atomic = new_atomic_stmt(parse_region, (yyvsp + 0)->u.itoken.location,
                                      (statement )((void *)0));
#line 2395
  (current.in_atomic)->containing_atomic = last_atomic;
  }
#line 2397
  goto switch_break;
  case_549: /* CIL Label */ 
#line 2399
  this_atomic = current.in_atomic;
#line 2401
  this_atomic->stmt = (yyvsp + 0)->u.stmt;
#line 2402
  current.in_atomic = this_atomic->containing_atomic;
#line 2403
  if (current.in_atomic) {
#line 2404
    yyval.u.stmt = (yyvsp + 0)->u.stmt;
  } else {
#line 2406
    tEmPcast___108 = (AST_generic )this_atomic;
#line 2406
    if (tEmPcast___108) {
#line 2406
      if ((unsigned int )tEmPcast___108->kind >= 65U) {
#line 2406
        if (! ((unsigned int )tEmPcast___108->kind <= 83U)) {
          {
#line 2406
          __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                        "c-parse.y", 2406U, "yyparse");
          }
        }
      } else {
        {
#line 2406
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2406U, "yyparse");
        }
      }
    }
#line 2406
    yyval.u.stmt = (statement )tEmPcast___108;
  }
#line 2408
  goto switch_break;
  case_551: /* CIL Label */ 
  {
#line 2412
  yyval.u.stmt = make_error_stmt();
  }
#line 2413
  goto switch_break;
  case_552: /* CIL Label */ 
#line 2418
  stmt_count ++;
#line 2418
  yyval.u.stmt = (yyvsp + 0)->u.stmt;
#line 2419
  goto switch_break;
  case_553: /* CIL Label */ 
  {
#line 2420
  stmt_count ++;
#line 2421
  tmp___105 = new_expression_stmt(parse_region, ((yyvsp + -1)->u.expr)->location,
                                  (yyvsp + -1)->u.expr);
#line 2421
  tEmPcast___109 = (AST_generic )tmp___105;
  }
#line 2421
  if (tEmPcast___109) {
#line 2421
    if ((unsigned int )tEmPcast___109->kind >= 65U) {
#line 2421
      if (! ((unsigned int )tEmPcast___109->kind <= 83U)) {
        {
#line 2421
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2421U, "yyparse");
        }
      }
    } else {
      {
#line 2421
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2421U, "yyparse");
      }
    }
  }
#line 2421
  yyval.u.stmt = (statement )tEmPcast___109;
#line 2422
  goto switch_break;
  case_554: /* CIL Label */ 
#line 2423
  (yyvsp + -1)->u.istmt.i = stmt_count;
#line 2424
  goto switch_break;
  case_555: /* CIL Label */ 
#line 2425
  if (extra_warnings) {
#line 2425
    if (stmt_count == (yyvsp + -3)->u.istmt.i) {
      {
#line 2426
      warning("empty body in an else-statement");
      }
    }
  }
#line 2427
  yyval.u.stmt = (yyvsp + -3)->u.istmt.stmt;
#line 2428
  if ((unsigned int )(yyval.u.stmt)->kind >= 68U) {
#line 2428
    if ((unsigned int )(yyval.u.stmt)->kind <= 68U) {
#line 2429
      tEmPcast___110 = (AST_generic )yyval.u.stmt;
#line 2429
      if (tEmPcast___110) {
#line 2429
        if ((unsigned int )tEmPcast___110->kind >= 68U) {
#line 2429
          if (! ((unsigned int )tEmPcast___110->kind <= 68U)) {
            {
#line 2429
            __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                          "c-parse.y", 2429U, "yyparse");
            }
          }
        } else {
          {
#line 2429
          __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                        "c-parse.y", 2429U, "yyparse");
          }
        }
      }
#line 2429
      ((if_stmt )tEmPcast___110)->stmt2 = (yyvsp + 0)->u.stmt;
    }
  }
#line 2431
  goto switch_break;
  case_556: /* CIL Label */ 
#line 2436
  if (extra_warnings) {
#line 2436
    tmp___106 = stmt_count;
#line 2436
    stmt_count ++;
#line 2436
    if (tmp___106 == (yyvsp + 0)->u.istmt.i) {
      {
#line 2437
      warning_with_location(((yyvsp + 0)->u.istmt.stmt)->location, "empty body in an if-statement");
      }
    }
  }
#line 2439
  yyval.u.stmt = (yyvsp + 0)->u.istmt.stmt;
#line 2440
  goto switch_break;
  case_557: /* CIL Label */ 
  {
#line 2441
  yyval.u.stmt = make_error_stmt();
  }
#line 2442
  goto switch_break;
  case_558: /* CIL Label */ 
#line 2443
  stmt_count ++;
#line 2444
  goto switch_break;
  case_559: /* CIL Label */ 
  {
#line 2445
  check_condition("while", (yyvsp + -1)->u.expr);
#line 2446
  tmp___107 = new_while_stmt(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -1)->u.expr,
                             (statement )((void *)0));
#line 2446
  tEmPcast___111 = (AST_generic )tmp___107;
  }
#line 2446
  if (tEmPcast___111) {
#line 2446
    if ((unsigned int )tEmPcast___111->kind >= 71U) {
#line 2446
      if (! ((unsigned int )tEmPcast___111->kind <= 74U)) {
        {
#line 2446
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "c-parse.y", 2447U, "yyparse");
        }
      }
    } else {
      {
#line 2446
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "c-parse.y", 2447U, "yyparse");
      }
    }
  }
#line 2446
  yyval.u.cstmt = (conditional_stmt )tEmPcast___111;
#line 2449
  tEmPcast___112 = (AST_generic )yyval.u.cstmt;
#line 2449
  if (tEmPcast___112) {
#line 2449
    if ((unsigned int )tEmPcast___112->kind >= 65U) {
#line 2449
      if (! ((unsigned int )tEmPcast___112->kind <= 83U)) {
        {
#line 2449
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2449U, "yyparse");
        }
      }
    } else {
      {
#line 2449
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2449U, "yyparse");
      }
    }
  }
  {
#line 2449
  push_loop((statement )tEmPcast___112);
  }
#line 2450
  goto switch_break;
  case_560: /* CIL Label */ 
#line 2451
  tEmPcast___113 = (AST_generic )(yyvsp + -1)->u.cstmt;
#line 2451
  if (tEmPcast___113) {
#line 2451
    if ((unsigned int )tEmPcast___113->kind >= 65U) {
#line 2451
      if (! ((unsigned int )tEmPcast___113->kind <= 83U)) {
        {
#line 2451
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2451U, "yyparse");
        }
      }
    } else {
      {
#line 2451
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2451U, "yyparse");
      }
    }
  }
  {
#line 2451
  yyval.u.stmt = (statement )tEmPcast___113;
#line 2452
  ((yyvsp + -1)->u.cstmt)->stmt = (yyvsp + 0)->u.stmt;
#line 2453
  pop_loop();
  }
#line 2454
  goto switch_break;
  case_561: /* CIL Label */ 
#line 2455
  tEmPcast___114 = (AST_generic )(yyvsp + -4)->u.cstmt;
#line 2455
  if (tEmPcast___114) {
#line 2455
    if ((unsigned int )tEmPcast___114->kind >= 65U) {
#line 2455
      if (! ((unsigned int )tEmPcast___114->kind <= 83U)) {
        {
#line 2455
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2455U, "yyparse");
        }
      }
    } else {
      {
#line 2455
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2455U, "yyparse");
      }
    }
  }
  {
#line 2455
  yyval.u.stmt = (statement )tEmPcast___114;
#line 2456
  ((yyvsp + -4)->u.cstmt)->condition = (yyvsp + -2)->u.expr;
#line 2457
  check_condition("do-while", (yyvsp + -2)->u.expr);
#line 2460
  pop_loop();
  }
#line 2461
  goto switch_break;
  case_562: /* CIL Label */ 
  {
#line 2462
  yyval.u.stmt = make_error_stmt();
#line 2463
  pop_loop();
  }
#line 2464
  goto switch_break;
  case_563: /* CIL Label */ 
#line 2464
  stmt_count ++;
#line 2465
  goto switch_break;
  case_564: /* CIL Label */ 
#line 2465
  if ((yyvsp + -1)->u.expr) {
    {
#line 2465
    check_condition("for", (yyvsp + -1)->u.expr);
    }
  }
#line 2466
  goto switch_break;
  case_565: /* CIL Label */ 
  {
#line 2467
  yyval.u.for_stmt = new_for_stmt(parse_region, (yyvsp + -9)->u.itoken.location, (yyvsp + -7)->u.expr,
                                  (yyvsp + -4)->u.expr, (yyvsp + -1)->u.expr, (statement )((void *)0));
#line 2468
  tEmPcast___115 = (AST_generic )yyval.u.for_stmt;
  }
#line 2468
  if (tEmPcast___115) {
#line 2468
    if ((unsigned int )tEmPcast___115->kind >= 65U) {
#line 2468
      if (! ((unsigned int )tEmPcast___115->kind <= 83U)) {
        {
#line 2468
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2468U, "yyparse");
        }
      }
    } else {
      {
#line 2468
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2468U, "yyparse");
      }
    }
  }
  {
#line 2468
  push_loop((statement )tEmPcast___115);
  }
#line 2469
  goto switch_break;
  case_566: /* CIL Label */ 
#line 2470
  tEmPcast___116 = (AST_generic )(yyvsp + -1)->u.for_stmt;
#line 2470
  if (tEmPcast___116) {
#line 2470
    if ((unsigned int )tEmPcast___116->kind >= 65U) {
#line 2470
      if (! ((unsigned int )tEmPcast___116->kind <= 83U)) {
        {
#line 2470
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2470U, "yyparse");
        }
      }
    } else {
      {
#line 2470
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2470U, "yyparse");
      }
    }
  }
  {
#line 2470
  yyval.u.stmt = (statement )tEmPcast___116;
#line 2471
  ((yyvsp + -1)->u.for_stmt)->stmt = (yyvsp + 0)->u.stmt;
#line 2472
  pop_loop();
  }
#line 2473
  goto switch_break;
  case_567: /* CIL Label */ 
  {
#line 2474
  stmt_count ++;
#line 2474
  check_switch((yyvsp + -1)->u.expr);
#line 2475
  tmp___108 = new_switch_stmt(parse_region, (yyvsp + -3)->u.itoken.location, (yyvsp + -1)->u.expr,
                              (statement )((void *)0));
#line 2475
  tEmPcast___117 = (AST_generic )tmp___108;
  }
#line 2475
  if (tEmPcast___117) {
#line 2475
    if ((unsigned int )tEmPcast___117->kind >= 71U) {
#line 2475
      if (! ((unsigned int )tEmPcast___117->kind <= 74U)) {
        {
#line 2475
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "c-parse.y", 2476U, "yyparse");
        }
      }
    } else {
      {
#line 2475
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "c-parse.y", 2476U, "yyparse");
      }
    }
  }
#line 2475
  yyval.u.cstmt = (conditional_stmt )tEmPcast___117;
#line 2477
  tEmPcast___118 = (AST_generic )yyval.u.cstmt;
#line 2477
  if (tEmPcast___118) {
#line 2477
    if ((unsigned int )tEmPcast___118->kind >= 65U) {
#line 2477
      if (! ((unsigned int )tEmPcast___118->kind <= 83U)) {
        {
#line 2477
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2477U, "yyparse");
        }
      }
    } else {
      {
#line 2477
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2477U, "yyparse");
      }
    }
  }
  {
#line 2477
  push_loop((statement )tEmPcast___118);
  }
#line 2478
  goto switch_break;
  case_568: /* CIL Label */ 
#line 2479
  tEmPcast___119 = (AST_generic )(yyvsp + -1)->u.cstmt;
#line 2479
  if (tEmPcast___119) {
#line 2479
    if ((unsigned int )tEmPcast___119->kind >= 65U) {
#line 2479
      if (! ((unsigned int )tEmPcast___119->kind <= 83U)) {
        {
#line 2479
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2479U, "yyparse");
        }
      }
    } else {
      {
#line 2479
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2479U, "yyparse");
      }
    }
  }
  {
#line 2479
  yyval.u.stmt = (statement )tEmPcast___119;
#line 2480
  ((yyvsp + -1)->u.cstmt)->stmt = (yyvsp + 0)->u.stmt;
#line 2481
  pop_loop();
  }
#line 2482
  goto switch_break;
  case_569: /* CIL Label */ 
  {
#line 2483
  stmt_count ++;
#line 2484
  tmp___109 = new_break_stmt(parse_region, (yyvsp + -1)->u.itoken.location);
#line 2484
  tEmPcast___120 = (AST_generic )tmp___109;
  }
#line 2484
  if (tEmPcast___120) {
#line 2484
    if ((unsigned int )tEmPcast___120->kind >= 65U) {
#line 2484
      if (! ((unsigned int )tEmPcast___120->kind <= 83U)) {
        {
#line 2484
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2484U, "yyparse");
        }
      }
    } else {
      {
#line 2484
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2484U, "yyparse");
      }
    }
  }
  {
#line 2484
  yyval.u.stmt = (statement )tEmPcast___120;
#line 2485
  check_break(yyval.u.stmt);
  }
#line 2487
  goto switch_break;
  case_570: /* CIL Label */ 
  {
#line 2488
  stmt_count ++;
#line 2489
  tmp___110 = new_continue_stmt(parse_region, (yyvsp + -1)->u.itoken.location);
#line 2489
  tEmPcast___121 = (AST_generic )tmp___110;
  }
#line 2489
  if (tEmPcast___121) {
#line 2489
    if ((unsigned int )tEmPcast___121->kind >= 65U) {
#line 2489
      if (! ((unsigned int )tEmPcast___121->kind <= 83U)) {
        {
#line 2489
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2489U, "yyparse");
        }
      }
    } else {
      {
#line 2489
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2489U, "yyparse");
      }
    }
  }
  {
#line 2489
  yyval.u.stmt = (statement )tEmPcast___121;
#line 2490
  check_continue(yyval.u.stmt);
  }
#line 2492
  goto switch_break;
  case_571: /* CIL Label */ 
  {
#line 2493
  stmt_count ++;
#line 2494
  yyval.u.stmt = make_void_return((yyvsp + -1)->u.itoken.location);
  }
#line 2495
  goto switch_break;
  case_572: /* CIL Label */ 
  {
#line 2496
  stmt_count ++;
#line 2497
  yyval.u.stmt = make_return((yyvsp + -2)->u.itoken.location, (yyvsp + -1)->u.expr);
  }
#line 2498
  goto switch_break;
  case_573: /* CIL Label */ 
  {
#line 2499
  stmt_count ++;
#line 2500
  tmp___111 = new_asm_stmt(parse_region, (yyvsp + -5)->u.itoken.location, (yyvsp + -2)->u.expr,
                           (asm_operand )((void *)0), (asm_operand )((void *)0), (string )((void *)0),
                           (yyvsp + -4)->u.telement);
#line 2500
  tEmPcast___122 = (AST_generic )tmp___111;
  }
#line 2500
  if (tEmPcast___122) {
#line 2500
    if ((unsigned int )tEmPcast___122->kind >= 65U) {
#line 2500
      if (! ((unsigned int )tEmPcast___122->kind <= 83U)) {
        {
#line 2500
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2501U, "yyparse");
        }
      }
    } else {
      {
#line 2500
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2501U, "yyparse");
      }
    }
  }
#line 2500
  yyval.u.stmt = (statement )tEmPcast___122;
#line 2502
  goto switch_break;
  case_574: /* CIL Label */ 
  {
#line 2504
  stmt_count ++;
#line 2505
  tmp___112 = new_asm_stmt(parse_region, (yyvsp + -7)->u.itoken.location, (yyvsp + -4)->u.expr,
                           (yyvsp + -2)->u.asm_operand, (asm_operand )((void *)0),
                           (string )((void *)0), (yyvsp + -6)->u.telement);
#line 2505
  tEmPcast___123 = (AST_generic )tmp___112;
  }
#line 2505
  if (tEmPcast___123) {
#line 2505
    if ((unsigned int )tEmPcast___123->kind >= 65U) {
#line 2505
      if (! ((unsigned int )tEmPcast___123->kind <= 83U)) {
        {
#line 2505
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2506U, "yyparse");
        }
      }
    } else {
      {
#line 2505
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2506U, "yyparse");
      }
    }
  }
#line 2505
  yyval.u.stmt = (statement )tEmPcast___123;
#line 2507
  goto switch_break;
  case_575: /* CIL Label */ 
  {
#line 2509
  stmt_count ++;
#line 2510
  tmp___113 = new_asm_stmt(parse_region, (yyvsp + -9)->u.itoken.location, (yyvsp + -6)->u.expr,
                           (yyvsp + -4)->u.asm_operand, (yyvsp + -2)->u.asm_operand,
                           (string )((void *)0), (yyvsp + -8)->u.telement);
#line 2510
  tEmPcast___124 = (AST_generic )tmp___113;
  }
#line 2510
  if (tEmPcast___124) {
#line 2510
    if ((unsigned int )tEmPcast___124->kind >= 65U) {
#line 2510
      if (! ((unsigned int )tEmPcast___124->kind <= 83U)) {
        {
#line 2510
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2510U, "yyparse");
        }
      }
    } else {
      {
#line 2510
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2510U, "yyparse");
      }
    }
  }
#line 2510
  yyval.u.stmt = (statement )tEmPcast___124;
#line 2511
  goto switch_break;
  case_576: /* CIL Label */ 
  {
#line 2514
  stmt_count ++;
#line 2515
  tmp___114 = new_asm_stmt(parse_region, (yyvsp + -11)->u.itoken.location, (yyvsp + -8)->u.expr,
                           (yyvsp + -6)->u.asm_operand, (yyvsp + -4)->u.asm_operand,
                           (yyvsp + -2)->u.string, (yyvsp + -10)->u.telement);
#line 2515
  tEmPcast___125 = (AST_generic )tmp___114;
  }
#line 2515
  if (tEmPcast___125) {
#line 2515
    if ((unsigned int )tEmPcast___125->kind >= 65U) {
#line 2515
      if (! ((unsigned int )tEmPcast___125->kind <= 83U)) {
        {
#line 2515
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2515U, "yyparse");
        }
      }
    } else {
      {
#line 2515
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2515U, "yyparse");
      }
    }
  }
#line 2515
  yyval.u.stmt = (statement )tEmPcast___125;
#line 2516
  goto switch_break;
  case_577: /* CIL Label */ 
  {
#line 2517
  stmt_count ++;
#line 2518
  tmp___115 = new_goto_stmt(parse_region, (yyvsp + -2)->u.itoken.location, (yyvsp + -1)->u.id_label);
#line 2518
  tEmPcast___126 = (AST_generic )tmp___115;
  }
#line 2518
  if (tEmPcast___126) {
#line 2518
    if ((unsigned int )tEmPcast___126->kind >= 65U) {
#line 2518
      if (! ((unsigned int )tEmPcast___126->kind <= 83U)) {
        {
#line 2518
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2518U, "yyparse");
        }
      }
    } else {
      {
#line 2518
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2518U, "yyparse");
      }
    }
  }
  {
#line 2518
  yyval.u.stmt = (statement )tEmPcast___126;
#line 2519
  use_label((yyvsp + -1)->u.id_label);
  }
#line 2521
  goto switch_break;
  case_578: /* CIL Label */ 
#line 2522
  if (pedantic) {
    {
#line 2523
    pedwarn("ANSI C forbids `goto *expr;\'");
    }
  }
  {
#line 2524
  fail_in_atomic("goto *");
#line 2525
  stmt_count ++;
#line 2526
  tmp___116 = new_computed_goto_stmt(parse_region, (yyvsp + -3)->u.itoken.location,
                                     (yyvsp + -1)->u.expr);
#line 2526
  tEmPcast___127 = (AST_generic )tmp___116;
  }
#line 2526
  if (tEmPcast___127) {
#line 2526
    if ((unsigned int )tEmPcast___127->kind >= 65U) {
#line 2526
      if (! ((unsigned int )tEmPcast___127->kind <= 83U)) {
        {
#line 2526
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2526U, "yyparse");
        }
      }
    } else {
      {
#line 2526
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2526U, "yyparse");
      }
    }
  }
  {
#line 2526
  yyval.u.stmt = (statement )tEmPcast___127;
#line 2527
  check_computed_goto((yyvsp + -1)->u.expr);
  }
#line 2528
  goto switch_break;
  case_580: /* CIL Label */ 
  {
#line 2529
  tmp___117 = new_empty_stmt(parse_region, (yyvsp + 0)->u.itoken.location);
#line 2529
  tEmPcast___128 = (AST_generic )tmp___117;
  }
#line 2529
  if (tEmPcast___128) {
#line 2529
    if ((unsigned int )tEmPcast___128->kind >= 65U) {
#line 2529
      if (! ((unsigned int )tEmPcast___128->kind <= 83U)) {
        {
#line 2529
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "c-parse.y", 2529U, "yyparse");
        }
      }
    } else {
      {
#line 2529
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "c-parse.y", 2529U, "yyparse");
      }
    }
  }
#line 2529
  yyval.u.stmt = (statement )tEmPcast___128;
#line 2530
  goto switch_break;
  case_581: /* CIL Label */ 
  {
#line 2537
  tmp___118 = new_case_label(parse_region, (yyvsp + -2)->u.itoken.location, (yyvsp + -1)->u.expr,
                             (expression )((void *)0));
#line 2537
  tEmPcast___129 = (AST_generic )tmp___118;
  }
#line 2537
  if (tEmPcast___129) {
#line 2537
    if ((unsigned int )tEmPcast___129->kind >= 184U) {
#line 2537
      if (! ((unsigned int )tEmPcast___129->kind <= 187U)) {
        {
#line 2537
        __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                      "c-parse.y", 2537U, "yyparse");
        }
      }
    } else {
      {
#line 2537
      __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                    "c-parse.y", 2537U, "yyparse");
      }
    }
  }
  {
#line 2537
  yyval.u.label = (label )tEmPcast___129;
#line 2538
  check_case(yyval.u.label);
  }
#line 2539
  goto switch_break;
  case_582: /* CIL Label */ 
  {
#line 2540
  tmp___119 = new_case_label(parse_region, (yyvsp + -4)->u.itoken.location, (yyvsp + -3)->u.expr,
                             (yyvsp + -1)->u.expr);
#line 2540
  tEmPcast___130 = (AST_generic )tmp___119;
  }
#line 2540
  if (tEmPcast___130) {
#line 2540
    if ((unsigned int )tEmPcast___130->kind >= 184U) {
#line 2540
      if (! ((unsigned int )tEmPcast___130->kind <= 187U)) {
        {
#line 2540
        __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                      "c-parse.y", 2540U, "yyparse");
        }
      }
    } else {
      {
#line 2540
      __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                    "c-parse.y", 2540U, "yyparse");
      }
    }
  }
  {
#line 2540
  yyval.u.label = (label )tEmPcast___130;
#line 2541
  check_case(yyval.u.label);
  }
#line 2542
  goto switch_break;
  case_583: /* CIL Label */ 
  {
#line 2543
  tmp___120 = new_default_label(parse_region, (yyvsp + -1)->u.itoken.location);
#line 2543
  tEmPcast___131 = (AST_generic )tmp___120;
  }
#line 2543
  if (tEmPcast___131) {
#line 2543
    if ((unsigned int )tEmPcast___131->kind >= 184U) {
#line 2543
      if (! ((unsigned int )tEmPcast___131->kind <= 187U)) {
        {
#line 2543
        __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                      "c-parse.y", 2543U, "yyparse");
        }
      }
    } else {
      {
#line 2543
      __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                    "c-parse.y", 2543U, "yyparse");
      }
    }
  }
  {
#line 2543
  yyval.u.label = (label )tEmPcast___131;
#line 2544
  check_default(yyval.u.label);
  }
#line 2545
  goto switch_break;
  case_584: /* CIL Label */ 
#line 2546
  tEmPcast___132 = (AST_generic )(yyvsp + -1)->u.id_label;
#line 2546
  if (tEmPcast___132) {
#line 2546
    if ((unsigned int )tEmPcast___132->kind >= 184U) {
#line 2546
      if (! ((unsigned int )tEmPcast___132->kind <= 187U)) {
        {
#line 2546
        __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                      "c-parse.y", 2546U, "yyparse");
        }
      }
    } else {
      {
#line 2546
      __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                    "c-parse.y", 2546U, "yyparse");
      }
    }
  }
  {
#line 2546
  yyval.u.label = (label )tEmPcast___132;
#line 2547
  define_label((yyvsp + -1)->u.id_label);
  }
#line 2548
  goto switch_break;
  case_585: /* CIL Label */ 
#line 2554
  yyval.u.telement = (type_element )((void *)0);
#line 2555
  goto switch_break;
  case_587: /* CIL Label */ 
#line 2560
  yyval.u.expr = (expression )((void *)0);
#line 2561
  goto switch_break;
  case_589: /* CIL Label */ 
#line 2568
  yyval.u.asm_operand = (asm_operand )((void *)0);
#line 2569
  goto switch_break;
  case_592: /* CIL Label */ 
  {
#line 2575
  yyval.u.asm_operand = asm_operand_chain((yyvsp + -2)->u.asm_operand, (yyvsp + 0)->u.asm_operand);
  }
#line 2576
  goto switch_break;
  case_593: /* CIL Label */ 
  {
#line 2580
  yyval.u.asm_operand = new_asm_operand(parse_region, ((yyvsp + -3)->u.string)->location,
                                        (word )((void *)0), (yyvsp + -3)->u.string,
                                        (yyvsp + -1)->u.expr);
  }
#line 2581
  goto switch_break;
  case_594: /* CIL Label */ 
  {
#line 2582
  yyval.u.asm_operand = new_asm_operand(parse_region, (yyvsp + -6)->u.itoken.location,
                                        (yyvsp + -5)->u.word, (yyvsp + -3)->u.string,
                                        (yyvsp + -1)->u.expr);
  }
#line 2583
  goto switch_break;
  case_595: /* CIL Label */ 
#line 2587
  yyval.u.string = (yyvsp + 0)->u.string;
#line 2588
  goto switch_break;
  case_596: /* CIL Label */ 
  {
#line 2589
  yyval.u.string = string_chain((yyvsp + -2)->u.string, (yyvsp + 0)->u.string);
  }
#line 2590
  goto switch_break;
  case_597: /* CIL Label */ 
  {
#line 2595
  pushlevel((bool )1);
  }
#line 2596
  goto switch_break;
  case_598: /* CIL Label */ 
#line 2597
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 2600
  goto switch_break;
  case_599: /* CIL Label */ 
#line 2603
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 2604
  goto switch_break;
  case_600: /* CIL Label */ 
#line 2605
  if (pedantic) {
    {
#line 2606
    pedwarn("ANSI C forbids forward parameter declarations");
    }
  }
  {
#line 2607
  allow_parameter_redeclaration((yyvsp + -1)->u.decl, (bool )1);
  }
#line 2609
  goto switch_break;
  case_601: /* CIL Label */ 
  {
#line 2610
  yyval.u.decl = declaration_chain((yyvsp + -3)->u.decl, (yyvsp + 0)->u.decl);
  }
#line 2611
  goto switch_break;
  case_602: /* CIL Label */ 
  {
#line 2612
  yyval.u.decl = make_error_decl();
  }
#line 2613
  goto switch_break;
  case_603: /* CIL Label */ 
#line 2618
  yyval.u.decl = (declaration )((void *)0);
#line 2619
  goto switch_break;
  case_604: /* CIL Label */ 
  {
#line 2620
  yyval.u.decl = make_error_decl();
#line 2627
  error("ANSI C requires a named argument before `...\'");
  }
#line 2629
  goto switch_break;
  case_605: /* CIL Label */ 
#line 2630
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 2631
  goto switch_break;
  case_606: /* CIL Label */ 
  {
#line 2632
  tmp___121 = new_ellipsis_decl(parse_region, (yyvsp + 0)->u.itoken.location);
#line 2632
  tEmPcast___133 = (AST_generic )tmp___121;
  }
#line 2632
  if (tEmPcast___133) {
#line 2632
    if ((unsigned int )tEmPcast___133->kind >= 43U) {
#line 2632
      if (! ((unsigned int )tEmPcast___133->kind <= 64U)) {
        {
#line 2632
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "c-parse.y", 2632U, "yyparse");
        }
      }
    } else {
      {
#line 2632
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "c-parse.y", 2632U, "yyparse");
      }
    }
  }
  {
#line 2632
  yyval.u.decl = declaration_chain((yyvsp + -2)->u.decl, (declaration )tEmPcast___133);
  }
#line 2633
  goto switch_break;
  case_608: /* CIL Label */ 
  {
#line 2638
  yyval.u.decl = declaration_chain((yyvsp + -2)->u.decl, (yyvsp + 0)->u.decl);
  }
#line 2639
  goto switch_break;
  case_609: /* CIL Label */ 
  {
#line 2645
  yyval.u.decl = declare_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                   (yyvsp + 0)->u.attribute);
  }
#line 2646
  goto switch_break;
  case_610: /* CIL Label */ 
  {
#line 2647
  yyval.u.decl = declare_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                   (yyvsp + 0)->u.attribute);
  }
#line 2648
  goto switch_break;
  case_611: /* CIL Label */ 
  {
#line 2649
  yyval.u.decl = declare_parameter((yyvsp + 0)->u.declarator, (yyvsp + -2)->u.telement,
                                   (attribute )((void *)0));
  }
#line 2650
  goto switch_break;
  case_612: /* CIL Label */ 
  {
#line 2651
  yyval.u.decl = declare_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                   (yyvsp + 0)->u.attribute);
  }
#line 2652
  goto switch_break;
  case_613: /* CIL Label */ 
  {
#line 2653
  yyval.u.decl = declare_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                   (yyvsp + 0)->u.attribute);
  }
#line 2654
  goto switch_break;
  case_614: /* CIL Label */ 
  {
#line 2655
  yyval.u.decl = declare_parameter((yyvsp + 0)->u.declarator, (yyvsp + -2)->u.telement,
                                   (attribute )((void *)0));
  }
#line 2656
  goto switch_break;
  case_615: /* CIL Label */ 
  {
#line 2657
  yyval.u.decl = declare_parameter((yyvsp + -1)->u.declarator, (yyvsp + -3)->u.telement,
                                   (yyvsp + 0)->u.attribute);
  }
#line 2658
  goto switch_break;
  case_616: /* CIL Label */ 
  {
#line 2660
  pending_xref_error();
  }
#line 2661
  goto switch_break;
  case_617: /* CIL Label */ 
  {
#line 2666
  pushlevel((bool )1);
  }
#line 2667
  goto switch_break;
  case_618: /* CIL Label */ 
#line 2668
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 2670
  goto switch_break;
  case_620: /* CIL Label */ 
#line 2674
  yyval.u.decl = (yyvsp + -1)->u.decl;
#line 2675
  goto switch_break;
  case_621: /* CIL Label */ 
#line 2680
  yyval.u.decl = (yyvsp + 0)->u.decl;
#line 2681
  goto switch_break;
  case_622: /* CIL Label */ 
  {
#line 2682
  yyval.u.decl = declaration_chain((yyvsp + -2)->u.decl, (yyvsp + 0)->u.decl);
  }
#line 2683
  goto switch_break;
  case_623: /* CIL Label */ 
  {
#line 2686
  yyval.u.decl = declare_old_parameter((yyvsp + 0)->idtoken.location, (yyvsp + 0)->idtoken.id);
  }
#line 2687
  goto switch_break;
  case_624: /* CIL Label */ 
  {
#line 2691
  yyval.u.id_label = (yyvsp + 0)->u.id_label;
#line 2691
  declare_label((yyvsp + 0)->u.id_label);
  }
#line 2692
  goto switch_break;
  case_625: /* CIL Label */ 
  {
#line 2693
  yyval.u.id_label = id_label_chain((yyvsp + 0)->u.id_label, (yyvsp + -2)->u.id_label);
#line 2694
  declare_label((yyvsp + 0)->u.id_label);
  }
#line 2695
  goto switch_break;
  case_626: /* CIL Label */ 
#line 2699
  yyval.u.telement = (type_element )((void *)0);
#line 2700
  goto switch_break;
  case_627: /* CIL Label */ 
#line 2700
  yyval.u.telement = (yyvsp + 0)->u.telement;
#line 2701
  goto switch_break;
  case_628: /* CIL Label */ 
#line 2705
  yyval.u.itoken.location = (yyvsp + 0)->u.itoken.location;
#line 2706
  yyval.u.itoken.i = (int )pedantic;
#line 2707
  pedantic = (bool )0;
#line 2708
  goto switch_break;
  case_629: /* CIL Label */ 
  {
#line 2712
  tmp___122 = new_rid(parse_region, (yyvsp + 0)->u.itoken.location, (enum rid )(yyvsp + 0)->u.itoken.i);
#line 2712
  tEmPcast___134 = (AST_generic )tmp___122;
  }
#line 2712
  if (tEmPcast___134) {
#line 2712
    if ((unsigned int )tEmPcast___134->kind >= 157U) {
#line 2712
      if (! ((unsigned int )tEmPcast___134->kind <= 174U)) {
        {
#line 2712
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2712U, "yyparse");
        }
      }
    } else {
      {
#line 2712
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2712U, "yyparse");
      }
    }
  }
#line 2712
  yyval.u.telement = (type_element )tEmPcast___134;
#line 2713
  goto switch_break;
  case_630: /* CIL Label */ 
  {
#line 2714
  tmp___123 = new_rid(parse_region, (yyvsp + 0)->u.itoken.location, (enum rid )12);
#line 2714
  tEmPcast___135 = (AST_generic )tmp___123;
  }
#line 2714
  if (tEmPcast___135) {
#line 2714
    if ((unsigned int )tEmPcast___135->kind >= 157U) {
#line 2714
      if (! ((unsigned int )tEmPcast___135->kind <= 174U)) {
        {
#line 2714
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2714U, "yyparse");
        }
      }
    } else {
      {
#line 2714
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2714U, "yyparse");
      }
    }
  }
#line 2714
  yyval.u.telement = (type_element )tEmPcast___135;
#line 2715
  goto switch_break;
  case_631: /* CIL Label */ 
  {
#line 2719
  tmp___124 = new_qualifier(parse_region, (yyvsp + 0)->u.itoken.location, (enum rid )(yyvsp + 0)->u.itoken.i);
#line 2719
  tEmPcast___136 = (AST_generic )tmp___124;
  }
#line 2719
  if (tEmPcast___136) {
#line 2719
    if ((unsigned int )tEmPcast___136->kind >= 157U) {
#line 2719
      if (! ((unsigned int )tEmPcast___136->kind <= 174U)) {
        {
#line 2719
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2719U, "yyparse");
        }
      }
    } else {
      {
#line 2719
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2719U, "yyparse");
      }
    }
  }
#line 2719
  yyval.u.telement = (type_element )tEmPcast___136;
#line 2720
  goto switch_break;
  case_632: /* CIL Label */ 
  {
#line 2724
  tmp___125 = new_qualifier(parse_region, (yyvsp + 0)->u.itoken.location, (enum rid )(yyvsp + 0)->u.itoken.i);
#line 2724
  tEmPcast___137 = (AST_generic )tmp___125;
  }
#line 2724
  if (tEmPcast___137) {
#line 2724
    if ((unsigned int )tEmPcast___137->kind >= 157U) {
#line 2724
      if (! ((unsigned int )tEmPcast___137->kind <= 174U)) {
        {
#line 2724
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2724U, "yyparse");
        }
      }
    } else {
      {
#line 2724
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2724U, "yyparse");
      }
    }
  }
#line 2724
  yyval.u.telement = (type_element )tEmPcast___137;
#line 2725
  goto switch_break;
  case_633: /* CIL Label */ 
  {
#line 2729
  tmp___126 = new_rid(parse_region, (yyvsp + 0)->u.itoken.location, (enum rid )(yyvsp + 0)->u.itoken.i);
#line 2729
  tEmPcast___138 = (AST_generic )tmp___126;
  }
#line 2729
  if (tEmPcast___138) {
#line 2729
    if ((unsigned int )tEmPcast___138->kind >= 157U) {
#line 2729
      if (! ((unsigned int )tEmPcast___138->kind <= 174U)) {
        {
#line 2729
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "c-parse.y", 2729U, "yyparse");
        }
      }
    } else {
      {
#line 2729
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "c-parse.y", 2729U, "yyparse");
      }
    }
  }
#line 2729
  yyval.u.telement = (type_element )tEmPcast___138;
#line 2730
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 7376 "c-parse.tab.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 7378
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 7378
    if (yydebug) {
      {
#line 7378
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 7378
      yy_symbol_print(stderr, (int )yyr1[yyn], (struct yystype  const  */* const  */)(& yyval));
#line 7378
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 7378
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 7380
  yyvsp -= yylen;
#line 7380
  yyssp -= yylen;
#line 7381
  yylen = 0;
  {
#line 7382
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 7382
    if (yydebug) {
      {
#line 7382
      yy_stack_print(yyss, yyssp);
      }
    }
#line 7382
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 7384
  yyvsp ++;
#line 7384
  *yyvsp = yyval;
#line 7390
  yyn = (int )yyr1[yyn];
#line 7392
  yystate = (int )((int const   )yypgoto[yyn - 103] + (int const   )*yyssp);
#line 7393
  if (0 <= yystate) {
#line 7393
    if (yystate <= 4209) {
#line 7393
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 7394
        yystate = (int )yytable[yystate];
      } else {
#line 7396
        yystate = (int )yydefgoto[yyn - 103];
      }
    } else {
#line 7396
      yystate = (int )yydefgoto[yyn - 103];
    }
  } else {
#line 7396
    yystate = (int )yydefgoto[yyn - 103];
  }
#line 7398
  goto yynewstate;
  yyerrlab: 
#line 7406
  if (! yyerrstatus) {
    {
#line 7408
    yynerrs ++;
#line 7410
    yyerror("syntax error");
    }
  }
#line 7448
  if (yyerrstatus == 3) {
#line 7453
    if (yychar <= 0) {
#line 7456
      if (yychar == 0) {
#line 7457
        goto yyabortlab;
      }
    } else {
      {
#line 7461
      yydestruct("Error: discarding", yytoken, & yylval);
#line 7463
      yychar = -2;
      }
    }
  }
#line 7469
  goto yyerrlab1;
  yyerrorlab: 
#line 7485
  yyvsp -= yylen;
#line 7485
  yyssp -= yylen;
#line 7486
  yylen = 0;
  {
#line 7487
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 7487
    if (yydebug) {
      {
#line 7487
      yy_stack_print(yyss, yyssp);
      }
    }
#line 7487
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 7488
  yystate = (int )*yyssp;
#line 7489
  goto yyerrlab1;
  yyerrlab1: 
#line 7496
  yyerrstatus = 3;
  {
#line 7498
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 7500
    yyn = (int )yypact[yystate];
#line 7501
    if (yyn != -729) {
#line 7503
      yyn ++;
#line 7504
      if (0 <= yyn) {
#line 7504
        if (yyn <= 4209) {
#line 7504
          if ((int const   )yycheck[yyn] == 1) {
#line 7506
            yyn = (int )yytable[yyn];
#line 7507
            if (0 < yyn) {
#line 7508
              goto while_break___12;
            }
          }
        }
      }
    }
#line 7513
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 7514
      goto yyabortlab;
    }
    {
#line 7517
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 7519
    yyvsp --;
#line 7519
    yyssp --;
#line 7520
    yystate = (int )*yyssp;
    }
    {
#line 7521
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 7521
      if (yydebug) {
        {
#line 7521
        yy_stack_print(yyss, yyssp);
        }
      }
#line 7521
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 7524
  yyvsp ++;
#line 7524
  *yyvsp = yylval;
  {
#line 7528
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 7528
    if (yydebug) {
      {
#line 7528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 7528
      yy_symbol_print(stderr, (int )yystos[yyn], (struct yystype  const  */* const  */)yyvsp);
#line 7528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 7528
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 7530
  yystate = yyn;
#line 7531
  goto yynewstate;
  yyacceptlab: 
#line 7538
  yyresult = 0;
#line 7539
  goto yyreturn;
  yyabortlab: 
#line 7545
  yyresult = 1;
#line 7546
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 7553
  yyerror("memory exhausted");
#line 7554
  yyresult = 2;
  }
  yyreturn: 
#line 7559
  if (yychar != -2) {
    {
#line 7560
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
    }
  }
#line 7564
  yyvsp -= yylen;
#line 7564
  yyssp -= yylen;
  {
#line 7565
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 7565
    if (yydebug) {
      {
#line 7565
      yy_stack_print(yyss, yyssp);
      }
    }
#line 7565
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 7566
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 7566
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 7566
      goto while_break___16;
    }
    {
#line 7568
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 7570
    yyvsp --;
#line 7570
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 7573
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 7574
    free((void *)yyss);
    }
  }
#line 7581
  return (yyresult);
}
}
#line 58 "./libcompat/regions.h"
extern void *typed_rarrayalloc(region r , size_t n , size_t size , type_t type ) ;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.h"
dhash_table new_dhash_table(region r , unsigned long initial_size , int (*compare)(void *key ,
                                                                                   void *y ) ,
                            unsigned long (*hash___0)(void *x ) ) ;
#line 47
void *dhlookup(dhash_table h , void *x ) ;
#line 52
void dhadd(dhash_table h , void *x ) ;
#line 58
void *dhaddif(dhash_table h , void *entry ) ;
#line 65
unsigned long dhash_used(dhash_table h ) ;
#line 75
dhash_scan dhscan(dhash_table h ) ;
#line 78
void *dhnext(dhash_scan *iterator ) ;
#line 88
dhash_table new_dhash_ptr_table(region r , unsigned long initial_size ) ;
#line 58 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
dhash_table new_dhash_table(region r , unsigned long initial_size , int (*compare)(void *key ,
                                                                                   void *y ) ,
                            unsigned long (*hash___0)(void *x ) ) 
{ 
  dhash_table h ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 62
  if (sizeof(struct dhash_table ) < (unsigned long )(1 << 9)) {
    {
#line 62
    tmp = __rcralloc_small0(r, sizeof(struct dhash_table ));
#line 62
    tmp___1 = tmp;
    }
  } else {
    {
#line 62
    tmp___0 = typed_ralloc(r, sizeof(struct dhash_table ), 0);
#line 62
    tmp___1 = tmp___0;
    }
  }
  {
#line 62
  h = (dhash_table )tmp___1;
#line 64
  h->r = r;
#line 65
  tmp___2 = typed_rarrayalloc(r, initial_size, sizeof(void *), 0);
#line 65
  h->elements = (void **)tmp___2;
#line 66
  h->size = initial_size;
#line 67
  h->log2size = 0UL;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (initial_size > 1UL)) {
#line 68
      goto while_break;
    }
#line 70
    (h->log2size) ++;
#line 71
    initial_size >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  h->used = 0UL;
#line 74
  h->compare = compare;
#line 75
  h->hash = hash___0;
#line 77
  return (h);
}
}
#line 80 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
unsigned long dhash_used(dhash_table h ) 
{ 


  {
#line 82
  return (h->used);
}
}
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
static unsigned long dhash(dhash_table h , void *x ) 
{ 
  uint32 hval ;
  unsigned long tmp ;
  uint32 hash___0 ;

  {
  {
#line 91
  tmp = (*(h->hash))(x);
#line 91
  hval = (uint32 )tmp;
#line 92
  hash___0 = (uint32 )((uint64 )hval * (uint64 )(0.6180339987 * (double )(1UL << 8UL * sizeof(uint32 ))));
  }
#line 94
  return ((unsigned long )(hash___0 >> (8UL * sizeof(uint32 ) - h->log2size)));
}
}
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
void *dhlookup(dhash_table h , void *x ) 
{ 
  unsigned long i ;
  unsigned long tmp ;
  void *bucket ;
  int tmp___0 ;

  {
  {
#line 99
  tmp = dhash(h, x);
#line 99
  i = tmp;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    bucket = *(h->elements + i);
#line 105
    if (! bucket) {
#line 106
      return ((void *)0);
    }
    {
#line 107
    tmp___0 = (*(h->compare))(x, bucket);
    }
#line 107
    if (tmp___0) {
#line 108
      return (bucket);
    }
#line 110
    i ++;
#line 110
    if (i >= h->size) {
#line 111
      i = 0UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
void dhadd(dhash_table h , void *x ) 
{ 
  unsigned long i ;
  void **oldelements ;
  unsigned long j ;
  unsigned long oldsize ;
  void *tmp ;
  unsigned long newi ;
  unsigned long tmp___0 ;

  {
#line 119
  (h->used) ++;
#line 120
  if (h->used > (3UL * h->size) / 4UL) {
    {
#line 122
    oldelements = h->elements;
#line 123
    oldsize = h->size;
#line 126
    h->size *= 2UL;
#line 127
    (h->log2size) ++;
#line 128
    tmp = typed_rarrayalloc(h->r, h->size, sizeof(void *), 0);
#line 128
    h->elements = (void **)tmp;
#line 131
    j = 0UL;
    }
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (! (j < oldsize)) {
#line 131
        goto while_break;
      }
#line 132
      if (*(oldelements + j)) {
        {
#line 134
        tmp___0 = dhash(h, *(oldelements + j));
#line 134
        newi = tmp___0;
        }
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! *(h->elements + newi)) {
#line 136
            goto while_break___0;
          }
#line 138
          newi ++;
#line 139
          if (newi >= h->size) {
#line 140
            newi = 0UL;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        *(h->elements + newi) = *(oldelements + j);
#line 143
        if (j == i) {
#line 144
          i = newi;
        }
      }
#line 131
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 148
  i = dhash(h, x);
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 152
    if (! *(h->elements + i)) {
#line 154
      *(h->elements + i) = x;
#line 155
      return;
    }
#line 158
    i ++;
#line 158
    if (i >= h->size) {
#line 159
      i = 0UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 163 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
void *dhaddif(dhash_table h , void *entry ) 
{ 
  void *existing ;
  void *tmp ;

  {
  {
#line 165
  tmp = dhlookup(h, entry);
#line 165
  existing = tmp;
  }
#line 167
  if (existing) {
#line 168
    return (existing);
  }
  {
#line 170
  dhadd(h, entry);
  }
#line 171
  return ((void *)0);
}
}
#line 175 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
dhash_scan dhscan(dhash_table h ) 
{ 
  dhash_scan iterator ;

  {
#line 179
  iterator.h = h;
#line 180
  iterator.index = 0;
#line 182
  return (iterator);
}
}
#line 185 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
void *dhnext(dhash_scan *iterator ) 
{ 
  dhash_table h ;
  void *x ;
  int tmp ;

  {
#line 187
  h = iterator->h;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if ((unsigned long )iterator->index >= h->size) {
#line 194
      return ((void *)0);
    }
#line 195
    tmp = iterator->index;
#line 195
    (iterator->index) ++;
#line 195
    x = *(h->elements + tmp);
#line 196
    if (x) {
#line 197
      return (x);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 201 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
static int ptr_compare(void *key , void *y ) 
{ 


  {
#line 203
  return ((unsigned long )key == (unsigned long )y);
}
}
#line 206 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
static unsigned long ptr_hash(void *x ) 
{ 


  {
#line 208
  return ((unsigned long )x >> 3);
}
}
#line 211 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dhash.c"
dhash_table new_dhash_ptr_table(region r , unsigned long initial_size ) 
{ 
  dhash_table tmp ;

  {
  {
#line 213
  tmp = new_dhash_table(r, initial_size, & ptr_compare, & ptr_hash);
  }
#line 213
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 69 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
dd_list_pos dd_first(dd_list l ) ;
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.h"
void *env_lookup(env e , char const   *s , bool this_level_only ) ;
#line 54
void env_add(env e , char const   *s , void *value ) ;
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-uses.h"
extern data_declaration enable_interrupt ;
#line 267 "/home/wheatley/newnew/temp/nescc-1.3.4/src/decls.h"
extern data_declaration bad_decl ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type double_type ;
#line 50
extern type int_type ;
#line 50
extern type unsigned_int_type ;
#line 50
extern type void_type ;
#line 50
extern type ptr_void_type ;
#line 50
extern type size_t_type ;
#line 50
extern type ptrdiff_t_type ;
#line 50
extern type unknown_int_type ;
#line 50
extern type unknown_number_type ;
#line 85
extern type make_base_type(type t ) ;
#line 89
extern type make_qualified_type(type t , type_quals qualifiers ) ;
#line 91
extern type qualify_type2(type t , type t1 , type t2 ) ;
#line 100
extern type make_pointer_type(type t ) ;
#line 122
extern void typelist_scan(typelist tl , typelist_scanner *scanner ) ;
#line 123
extern type typelist_next(typelist_scanner *scanner ) ;
#line 140
extern type common_type(type t1 , type t2 ) ;
#line 142
extern bool type_equal(type t1 , type t2 ) ;
#line 143
extern bool type_equal_unqualified(type t1 , type t2 ) ;
#line 144
extern bool type_compatible(type t1 , type t2 ) ;
#line 145
extern bool type_compatible_unqualified(type t1 , type t2 ) ;
#line 148
extern bool type_self_promoting(type t ) ;
#line 150
extern bool type_incomplete(type t ) ;
#line 155
extern type_quals type_qualifiers(type t ) ;
#line 1 "/home/wheatley/newnew/temp/nescc-1.3.4/src/qualifiers.h"
extern bool type_const(type t ) ;
#line 2
extern bool type_volatile(type t ) ;
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern bool type_readonly(type t ) ;
#line 162
extern bool type_plain_char(type t ) ;
#line 178
extern bool type_tagged(type t ) ;
#line 179
extern bool type_integral(type t ) ;
#line 180
extern bool type_floating(type t ) ;
#line 181
extern bool type_complex(type t ) ;
#line 182
extern bool type_float(type t ) ;
#line 184
extern bool type_void(type t ) ;
#line 186
extern bool type_function(type t ) ;
#line 187
extern bool type_array(type t ) ;
#line 188
extern bool type_pointer(type t ) ;
#line 189
extern bool type_enum(type t ) ;
#line 190
extern bool type_struct(type t ) ;
#line 192
extern bool type_union(type t ) ;
#line 193
extern bool type_integer(type t ) ;
#line 194
extern bool type_unsigned(type t ) ;
#line 195
extern bool type_smallerthanint(type t ) ;
#line 196
extern bool type_real(type t ) ;
#line 197
extern bool type_arithmetic(type t ) ;
#line 198
extern bool type_scalar(type t ) ;
#line 199
extern bool type_aggregate(type t ) ;
#line 201
extern type make_unsigned_type(type t ) ;
#line 203
extern type type_function_return_type(type t ) ;
#line 204
extern typelist type_function_arguments(type t ) ;
#line 205
extern bool type_function_varargs(type t ) ;
#line 206
extern bool type_function_oldstyle(type t ) ;
#line 212
extern type type_points_to(type t ) ;
#line 213
extern type type_array_of(type t ) ;
#line 215
extern expression type_array_size(type t ) ;
#line 218
extern tag_declaration type_tag(type t ) ;
#line 223
extern void type2ast(region r , location loc , type t , declarator inside , declarator *d ,
                     type_element *modifiers ) ;
#line 244
extern bool type_interface(type t ) ;
#line 248
extern bool type_component(type t ) ;
#line 255
extern bool type_functional(type t ) ;
#line 257
extern bool type_generic(type t ) ;
#line 280
extern bool type_variable(type t ) ;
#line 281
extern data_declaration type_variable_decl(type t ) ;
#line 1804 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
comma new_comma(region r , location location___0 , expression arg1 ) ;
#line 1805
sizeof_type new_sizeof_type(region r , location location___0 , asttype asttype___0 ) ;
#line 1806
alignof_type new_alignof_type(region r , location location___0 , asttype asttype___0 ) ;
#line 1807
label_address new_label_address(region r , location location___0 , id_label id_label___0 ) ;
#line 1808
cast new_cast(region r , location location___0 , expression arg1 , asttype asttype___0 ) ;
#line 1810
conditional new_conditional(region r , location location___0 , expression condition ,
                            expression arg1 , expression arg2 ) ;
#line 1811
identifier new_identifier(region r , location location___0 , cstring cstring___0 ,
                          data_declaration ddecl ) ;
#line 1812
compound_expr new_compound_expr(region r , location location___0 , statement stmt ) ;
#line 1813
function_call new_function_call(region r , location location___0 , expression arg1 ,
                                expression args , asttype va_arg_call , nesc_call_kind call_kind ) ;
#line 1814
field_ref new_field_ref(region r , location location___0 , expression arg1 , cstring cstring___0 ) ;
#line 1860
error_expr new_error_expr(region r , location location___0 ) ;
#line 1861
array_ref new_array_ref(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1862
dereference new_dereference(region r , location location___0 , expression arg1 ) ;
#line 1863
extension_expr new_extension_expr(region r , location location___0 , expression arg1 ) ;
#line 1864
sizeof_expr new_sizeof_expr(region r , location location___0 , expression arg1 ) ;
#line 1865
alignof_expr new_alignof_expr(region r , location location___0 , expression arg1 ) ;
#line 1868
address_of new_address_of(region r , location location___0 , expression arg1 ) ;
#line 1874
preincrement new_preincrement(region r , location location___0 , expression arg1 ) ;
#line 1875
predecrement new_predecrement(region r , location location___0 , expression arg1 ) ;
#line 1876
postincrement new_postincrement(region r , location location___0 , expression arg1 ) ;
#line 1877
postdecrement new_postdecrement(region r , location location___0 , expression arg1 ) ;
#line 70 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
unary newkind_unary(region r , AST_kind kind , location location___0 , expression arg1 ) ;
#line 71
binary newkind_binary(region r , AST_kind kind , location location___0 , expression arg1 ,
                      expression arg2 ) ;
#line 94 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_cond_mismatch ;
#line 112
int warn_pointer_arith ;
#line 130
int warn_cast_qual ;
#line 135
int warn_bad_function_cast ;
#line 144
int warn_char_subscripts ;
#line 147
int warn_conversion ;
#line 160
int flag_allow_single_precision ;
#line 163
int warn_parentheses ;
#line 52 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.h"
expression make_preincrement(location loc , expression e ) ;
#line 54
expression make_predecrement(location loc , expression e ) ;
#line 57
bool check_assignment(type lhstype , type rhstype , expression rhs , char const   *context___0 ,
                      data_declaration fundecl , int parmnum ) ;
#line 61
bool check_conversion(type to , type from ) ;
#line 62
bool check_arguments(type fntype , expression arglist , data_declaration fundecl ,
                     bool generic_call___0 ) ;
#line 65
type default_conversion(expression e ) ;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
lexical_cst fold_lexical_int(type itype , location loc , cstring tok , bool iscomplex ,
                             largest_uint intvalue , bool overflow ) ;
#line 54
known_cst fold_label_address(expression e ) ;
#line 55
known_cst fold_sizeof(expression e , type stype ) ;
#line 57
known_cst fold_cast(expression e ) ;
#line 58
known_cst fold_unary(expression e ) ;
#line 59
known_cst fold_binary(type t , expression e ) ;
#line 60
known_cst fold_conditional(expression e ) ;
#line 61
known_cst fold_function_call(expression e , int pass ) ;
#line 62
known_cst fold_identifier(expression e , data_declaration decl , int pass ) ;
#line 66
known_cst foldaddress_identifier(expression e , data_declaration decl ) ;
#line 68
known_cst foldaddress_field_ref(expression e ) ;
#line 70
bool definite_null(expression e ) ;
#line 71
bool definite_zero(expression e ) ;
#line 79
void constant_overflow_warning(known_cst c ) ;
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/unparse.h"
extern char const   *binary_op_name(AST_kind kind ) ;
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern type builtin_va_list_type ;
#line 36
extern data_declaration builtin_va_arg_decl ;
#line 51
extern data_declaration lookup_id(char const   *s , bool this_level_only ) ;
#line 161
extern data_declaration implicitly_declare(identifier fnid ) ;
#line 237
char const   *tagkind_name(int tagkind ) ;
#line 51 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.h"
expression build_identifier(region r , location loc , data_declaration id ) ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-module.h"
extern expression make_generic_call(location loc , expression iref , expression args ) ;
#line 24
extern expression make_interface_deref(location loc , expression object , cstring field ) ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-configuration.h"
extern expression make_component_deref(location loc , expression object , cstring field ) ;
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.h"
char const   *decl_printname(data_declaration ddecl ) ;
#line 90
data_declaration get_function_ddecl(expression e ) ;
#line 39 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool compatible_pointer_targets(type ttl , type ttr , bool pedantic___0 ) 
{ 
  int val ;
  bool tmp ;

  {
  {
#line 43
  tmp = type_compatible_unqualified(ttl, ttr);
#line 43
  val = (int )tmp;
  }
#line 45
  if (val == 2) {
#line 45
    if (pedantic___0) {
      {
#line 46
      pedwarn("types are not quite compatible");
      }
    }
  }
#line 47
  return ((bool )(val != 0));
}
}
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool compatible_pointer_types(type tl , type tr ) 
{ 
  type tmp ;
  type tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 52
  tmp = type_points_to(tr);
#line 52
  tmp___0 = type_points_to(tl);
#line 52
  tmp___1 = compatible_pointer_targets(tmp___0, tmp, pedantic);
  }
#line 52
  return (tmp___1);
}
}
#line 60 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static char const   *argtype(int *parmnum ) 
{ 


  {
#line 62
  if (*parmnum >= 0) {
#line 63
    return ("argument");
  }
#line 64
  *parmnum = - *parmnum;
#line 65
  return ("parameter");
}
}
#line 71
static void warn_for_assignment(char const   *msg , char const   *opname , data_declaration fdecl ,
                                int argnum ) ;
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static char argstring[22]  = 
#line 71
  {      (char )'p',      (char )'a',      (char )'s',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'%',      (char )'s',      (char )' ',      (char )'%', 
        (char )'d',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'`',      (char )'%',      (char )'s', 
        (char )'\'',      (char )'\000'};
#line 72 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static char argnofun[14]  = 
#line 72
  {      (char )'p',      (char )'a',      (char )'s',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'%',      (char )'s',      (char )' ',      (char )'%', 
        (char )'d',      (char )'\000'};
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void warn_for_assignment(char const   *msg , char const   *opname , data_declaration fdecl ,
                                int argnum ) 
{ 
  char *tmpname ;
  char const   *argname ;
  char const   *tmp ;
  char const   *function ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 74
  if ((unsigned long )opname == (unsigned long )((char const   *)0)) {
    {
#line 77
    tmp = argtype(& argnum);
#line 77
    argname = tmp;
    }
#line 79
    if (fdecl) {
      {
#line 81
      tmp___0 = decl_printname(fdecl);
#line 81
      function = tmp___0;
#line 84
      tmp___1 = strlen(function);
#line 84
      tmp___2 = __builtin_alloca(((tmp___1 + sizeof(argstring)) + 25UL) + 1UL);
#line 84
      tmpname = (char *)tmp___2;
#line 85
      sprintf((char */* __restrict  */)tmpname, (char const   */* __restrict  */)(argstring),
              argname, argnum, function);
      }
    } else {
      {
#line 90
      tmp___3 = __builtin_alloca((sizeof(argnofun) + 25UL) + 1UL);
#line 90
      tmpname = (char *)tmp___3;
#line 91
      sprintf((char */* __restrict  */)tmpname, (char const   */* __restrict  */)(argnofun),
              argname, argnum);
      }
    }
#line 93
    opname = (char const   *)tmpname;
  }
  {
#line 95
  pedwarn(msg, opname);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void incomplete_type_error(expression e , type t ) 
{ 
  AST_generic tEmPcast ;
  bool tmp ;
  expression tmp___0 ;
  tag_declaration tag ;
  tag_declaration tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 101
  if ((unsigned long )t == (unsigned long )error_type) {
#line 102
    return;
  }
#line 104
  if (e) {
#line 104
    if ((unsigned int )e->kind >= 146U) {
#line 104
      if ((unsigned int )e->kind <= 146U) {
#line 105
        tEmPcast = (AST_generic )e;
#line 105
        if (tEmPcast) {
#line 105
          if ((unsigned int )tEmPcast->kind >= 146U) {
#line 105
            if (! ((unsigned int )tEmPcast->kind <= 146U)) {
              {
#line 105
              __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 105U,
                            "incomplete_type_error");
              }
            }
          } else {
            {
#line 105
            __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 105U,
                          "incomplete_type_error");
            }
          }
        }
        {
#line 105
        error("`%s\' has an incomplete type", ((identifier )tEmPcast)->cstring.data);
        }
      } else {
#line 104
        goto _L;
      }
    } else {
#line 104
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 108
      tmp = type_array(t);
      }
#line 108
      if (tmp) {
        {
#line 108
        tmp___0 = type_array_size(t);
        }
#line 108
        if (! tmp___0) {
#line 108
          goto while_break;
        }
      } else {
#line 108
        goto while_break;
      }
      {
#line 109
      t = type_array_of(t);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 111
    tmp___5 = type_tagged(t);
    }
#line 111
    if (tmp___5) {
      {
#line 113
      tmp___1 = type_tag(t);
#line 113
      tag = tmp___1;
#line 115
      tmp___2 = tagkind_name(tag->kind);
#line 115
      error("invalid use of undefined type `%s %s\'", tmp___2, tag->name);
      }
    } else {
      {
#line 118
      tmp___4 = type_void(t);
      }
#line 118
      if (tmp___4) {
        {
#line 119
        error("invalid use of void expression");
        }
      } else {
        {
#line 120
        tmp___3 = type_array(t);
        }
#line 120
        if (tmp___3) {
          {
#line 121
          error("invalid use of array with unspecified bounds");
          }
        } else {
          {
#line 123
          __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c",
                        123U, "incomplete_type_error");
          }
        }
      }
    }
  }
#line 126
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static type require_complete_type(expression e , type etype ) 
{ 
  bool tmp ;

  {
  {
#line 130
  tmp = type_incomplete(etype);
  }
#line 130
  if (! tmp) {
#line 131
    return (e->type);
  }
  {
#line 133
  incomplete_type_error(e, etype);
  }
#line 135
  return (error_type);
}
}
#line 138 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
type default_conversion(expression e ) 
{ 
  type from ;
  tag_declaration tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  type tmp___5 ;
  bool tmp___6 ;
  type tmp___7 ;
  type tmp___8 ;
  bool tmp___9 ;
  data_declaration vdecl ;
  data_declaration tmp___10 ;
  bool tmp___11 ;

  {
  {
#line 140
  from = e->type;
#line 142
  tmp___0 = type_enum(from);
  }
#line 142
  if (tmp___0) {
    {
#line 143
    tmp = type_tag(from);
#line 143
    from = tmp->reptype;
    }
  }
  {
#line 145
  tmp___2 = type_smallerthanint(from);
  }
#line 145
  if (tmp___2) {
#line 148
    if (flag_traditional) {
      {
#line 148
      tmp___1 = type_unsigned(from);
      }
#line 148
      if (tmp___1) {
#line 149
        return (unsigned_int_type);
      } else {
#line 151
        return (int_type);
      }
    } else {
#line 151
      return (int_type);
    }
  }
#line 154
  if (flag_traditional) {
#line 154
    if (! flag_allow_single_precision) {
      {
#line 154
      tmp___3 = type_float(from);
      }
#line 154
      if (tmp___3) {
#line 155
        return (double_type);
      }
    }
  }
  {
#line 157
  tmp___4 = type_void(from);
  }
#line 157
  if (tmp___4) {
    {
#line 159
    error("void value not ignored as it ought to be");
    }
#line 160
    return (error_type);
  }
  {
#line 167
  tmp___6 = type_function(from);
  }
#line 167
  if (tmp___6) {
#line 169
    if (! (! e->cst)) {
      {
#line 169
      __assert_fail("!e->cst", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c",
                    169U, "default_conversion");
      }
    }
    {
#line 170
    e->cst = e->static_address;
#line 171
    e->converted_to_pointer = (bool )1;
#line 172
    tmp___5 = make_pointer_type(from);
    }
#line 172
    return (tmp___5);
  }
  {
#line 175
  tmp___9 = type_array(from);
  }
#line 175
  if (tmp___9) {
#line 177
    if (! e->lvalue) {
      {
#line 179
      error("invalid use of non-lvalue array");
      }
#line 180
      return (error_type);
    }
#line 182
    if (! (! e->cst)) {
      {
#line 182
      __assert_fail("!e->cst", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c",
                    182U, "default_conversion");
      }
    }
    {
#line 183
    e->cst = e->static_address;
#line 184
    e->converted_to_pointer = (bool )1;
#line 186
    e->lvalue = (bool )0;
#line 187
    tmp___7 = type_array_of(from);
#line 187
    tmp___8 = make_pointer_type(tmp___7);
    }
#line 187
    return (tmp___8);
  }
  {
#line 190
  tmp___11 = type_variable(from);
  }
#line 190
  if (tmp___11) {
    {
#line 192
    tmp___10 = type_variable_decl(from);
#line 192
    vdecl = tmp___10;
    }
    {
#line 196
    if ((unsigned int )vdecl->typevar_kind == 2U) {
#line 196
      goto case_2;
    }
#line 197
    if ((unsigned int )vdecl->typevar_kind == 3U) {
#line 197
      goto case_3;
    }
#line 198
    goto switch_default;
    case_2: /* CIL Label */ 
#line 196
    return (unknown_int_type);
    case_3: /* CIL Label */ 
#line 197
    return (unknown_number_type);
    switch_default: /* CIL Label */ 
#line 198
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 202
  return (from);
}
}
#line 206 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
type default_conversion_for_assignment(expression e ) 
{ 
  type tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 208
  tmp___0 = type_array(e->type);
  }
#line 208
  if (tmp___0) {
    {
#line 209
    tmp = default_conversion(e);
    }
#line 209
    return (tmp);
  } else {
    {
#line 208
    tmp___1 = type_function(e->type);
    }
#line 208
    if (tmp___1) {
      {
#line 209
      tmp = default_conversion(e);
      }
#line 209
      return (tmp);
    } else {
#line 211
      return (e->type);
    }
  }
}
}
#line 214 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void readonly_warning(expression e , char *context___0 ) 
{ 
  char buf___0[80] ;
  field_ref field ;
  AST_generic tEmPcast ;
  bool tmp ;
  AST_generic tEmPcast___0 ;

  {
  {
#line 218
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)context___0);
  }
#line 220
  if ((unsigned int )e->kind >= 87U) {
#line 220
    if ((unsigned int )e->kind <= 87U) {
#line 222
      tEmPcast = (AST_generic )e;
#line 222
      if (tEmPcast) {
#line 222
        if ((unsigned int )tEmPcast->kind >= 87U) {
#line 222
          if (! ((unsigned int )tEmPcast->kind <= 87U)) {
            {
#line 222
            __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 222U,
                          "readonly_warning");
            }
          }
        } else {
          {
#line 222
          __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 222U,
                        "readonly_warning");
          }
        }
      }
      {
#line 222
      field = (field_ref )tEmPcast;
#line 224
      tmp = type_readonly((field->arg1)->type);
      }
#line 224
      if (tmp) {
        {
#line 225
        readonly_warning(field->arg1, context___0);
        }
      } else {
        {
#line 228
        strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" of read-only member `%s\'");
#line 229
        pedwarn((char const   *)(buf___0), field->cstring.data);
        }
      }
    } else {
#line 220
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 232
  if ((unsigned int )e->kind >= 146U) {
#line 232
    if ((unsigned int )e->kind <= 146U) {
      {
#line 234
      strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" of read-only variable `%s\'");
#line 235
      tEmPcast___0 = (AST_generic )e;
      }
#line 235
      if (tEmPcast___0) {
#line 235
        if ((unsigned int )tEmPcast___0->kind >= 146U) {
#line 235
          if (! ((unsigned int )tEmPcast___0->kind <= 146U)) {
            {
#line 235
            __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 235U,
                          "readonly_warning");
            }
          }
        } else {
          {
#line 235
          __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 235U,
                        "readonly_warning");
          }
        }
      }
      {
#line 235
      pedwarn((char const   *)(buf___0), ((identifier )tEmPcast___0)->cstring.data);
      }
    } else {
      {
#line 238
      pedwarn("%s of read-only location", buf___0);
      }
    }
  } else {
    {
#line 238
    pedwarn("%s of read-only location", buf___0);
    }
  }
#line 239
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool check_writable_lvalue(expression e , char *context___0 ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 243
  if (! e->lvalue) {
    {
#line 245
    error("invalid lvalue in %s", context___0);
    }
#line 246
    return ((bool )0);
  } else {
    {
#line 243
    tmp = type_array(e->type);
    }
#line 243
    if (tmp) {
      {
#line 245
      error("invalid lvalue in %s", context___0);
      }
#line 246
      return ((bool )0);
    }
  }
  {
#line 248
  tmp___0 = type_readonly(e->type);
  }
#line 248
  if (tmp___0) {
    {
#line 249
    readonly_warning(e, context___0);
    }
  }
#line 250
  return ((bool )1);
}
}
#line 253 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
bool check_conversion(type to , type from ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;

  {
  {
#line 255
  tmp = type_equal_unqualified(to, from);
  }
#line 255
  if (tmp) {
#line 256
    return ((bool )1);
  }
#line 258
  if ((unsigned long )to == (unsigned long )error_type) {
#line 259
    return ((bool )0);
  } else
#line 258
  if ((unsigned long )from == (unsigned long )error_type) {
#line 259
    return ((bool )0);
  }
  {
#line 261
  tmp___0 = type_void(from);
  }
#line 261
  if (tmp___0) {
    {
#line 263
    error("void value not ignored as it ought to be");
    }
#line 264
    return ((bool )0);
  }
  {
#line 267
  tmp___1 = type_void(to);
  }
#line 267
  if (tmp___1) {
#line 268
    return ((bool )1);
  }
  {
#line 270
  tmp___12 = type_integer(to);
  }
#line 270
  if (tmp___12) {
    {
#line 272
    tmp___2 = type_scalar(from);
    }
#line 272
    if (! tmp___2) {
      {
#line 274
      error("aggregate value used where an integer was expected");
      }
#line 275
      return ((bool )0);
    }
  } else {
    {
#line 278
    tmp___11 = type_pointer(to);
    }
#line 278
    if (tmp___11) {
      {
#line 280
      tmp___3 = type_integer(from);
      }
#line 280
      if (! tmp___3) {
        {
#line 280
        tmp___4 = type_pointer(from);
        }
#line 280
        if (! tmp___4) {
          {
#line 282
          error("cannot convert to a pointer type");
          }
#line 283
          return ((bool )0);
        }
      }
    } else {
      {
#line 286
      tmp___10 = type_floating(to);
      }
#line 286
      if (tmp___10) {
        {
#line 288
        tmp___6 = type_pointer(from);
        }
#line 288
        if (tmp___6) {
          {
#line 290
          error("pointer value used where a floating point value was expected");
          }
#line 291
          return ((bool )0);
        } else {
          {
#line 293
          tmp___5 = type_arithmetic(from);
          }
#line 293
          if (! tmp___5) {
            {
#line 295
            error("aggregate value used where a float was expected");
            }
#line 296
            return ((bool )0);
          }
        }
      } else {
        {
#line 299
        tmp___9 = type_complex(to);
        }
#line 299
        if (tmp___9) {
          {
#line 301
          tmp___8 = type_pointer(from);
          }
#line 301
          if (tmp___8) {
            {
#line 303
            error("pointer value used where a complex was expected");
            }
#line 304
            return ((bool )0);
          } else {
            {
#line 306
            tmp___7 = type_arithmetic(from);
            }
#line 306
            if (! tmp___7) {
              {
#line 308
              error("aggregate value used where a complex was expected");
              }
#line 309
              return ((bool )0);
            }
          }
        } else {
          {
#line 314
          error("conversion to non-scalar type requested");
          }
#line 315
          return ((bool )0);
        }
      }
    }
  }
#line 317
  return ((bool )1);
}
}
#line 320 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool assignable_pointer_targets(type tt1 , type tt2 , bool pedantic___0 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 322
  tmp = type_void(tt1);
  }
#line 322
  if (tmp) {
#line 322
    tmp___2 = 1;
  } else {
    {
#line 322
    tmp___0 = type_void(tt2);
    }
#line 322
    if (tmp___0) {
#line 322
      tmp___2 = 1;
    } else {
      {
#line 322
      tmp___1 = compatible_pointer_targets(tt1, tt2, pedantic___0);
      }
#line 322
      if (tmp___1) {
#line 322
        tmp___2 = 1;
      } else {
#line 322
        tmp___2 = 0;
      }
    }
  }
#line 322
  return ((bool )tmp___2);
}
}
#line 326 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void ptrconversion_warnings(type ttl , type ttr , expression rhs , char const   *context___0 ,
                                   data_declaration fdecl , int parmnum , bool pedantic___0 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;

  {
#line 331
  if (pedantic___0) {
    {
#line 331
    tmp___12 = type_void(ttl);
    }
#line 331
    if (tmp___12) {
      {
#line 331
      tmp___13 = type_function(ttr);
      }
#line 331
      if (tmp___13) {
        {
#line 335
        warn_for_assignment("ANSI forbids %s between function pointer and `void *\'",
                            context___0, fdecl, parmnum);
        }
      } else {
#line 331
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 331
      tmp___14 = type_function(ttl);
      }
#line 331
      if (tmp___14) {
        {
#line 331
        tmp___15 = type_void(ttr);
        }
#line 331
        if (tmp___15) {
#line 331
          if (rhs) {
            {
#line 331
            tmp___16 = definite_null(rhs);
            }
#line 331
            if (tmp___16) {
#line 331
              goto _L___0;
            } else {
              {
#line 335
              warn_for_assignment("ANSI forbids %s between function pointer and `void *\'",
                                  context___0, fdecl, parmnum);
              }
            }
          } else {
            {
#line 335
            warn_for_assignment("ANSI forbids %s between function pointer and `void *\'",
                                context___0, fdecl, parmnum);
            }
          }
        } else {
#line 331
          goto _L___0;
        }
      } else {
#line 331
        goto _L___0;
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 340
    tmp___10 = type_function(ttl);
    }
#line 340
    if (tmp___10) {
      {
#line 340
      tmp___11 = type_function(ttr);
      }
#line 340
      if (tmp___11) {
        {
#line 347
        tmp = type_const(ttl);
        }
#line 347
        if (tmp) {
          {
#line 347
          tmp___0 = type_const(ttr);
          }
#line 347
          if (! tmp___0) {
            {
#line 348
            warn_for_assignment("%s makes `const *\' function pointer from non-const",
                                context___0, fdecl, parmnum);
            }
          }
        }
        {
#line 350
        tmp___1 = type_volatile(ttl);
        }
#line 350
        if (tmp___1) {
          {
#line 350
          tmp___2 = type_volatile(ttr);
          }
#line 350
          if (! tmp___2) {
            {
#line 351
            warn_for_assignment("%s makes `volatile *\' function pointer from non-volatile",
                                context___0, fdecl, parmnum);
            }
          }
        }
      } else {
#line 340
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 354
      tmp___8 = type_function(ttl);
      }
#line 354
      if (! tmp___8) {
        {
#line 354
        tmp___9 = type_function(ttr);
        }
#line 354
        if (! tmp___9) {
          {
#line 356
          tmp___3 = type_const(ttl);
          }
#line 356
          if (! tmp___3) {
            {
#line 356
            tmp___4 = type_const(ttr);
            }
#line 356
            if (tmp___4) {
              {
#line 357
              warn_for_assignment("%s discards `const\' from pointer target type",
                                  context___0, fdecl, parmnum);
              }
            }
          }
          {
#line 359
          tmp___5 = type_volatile(ttl);
          }
#line 359
          if (! tmp___5) {
            {
#line 359
            tmp___6 = type_volatile(ttr);
            }
#line 359
            if (tmp___6) {
              {
#line 360
              warn_for_assignment("%s discards `volatile\' from pointer target type",
                                  context___0, fdecl, parmnum);
              }
            }
          }
          {
#line 365
          tmp___7 = assignable_pointer_targets(ttl, ttr, (bool )0);
          }
#line 365
          if (! tmp___7) {
#line 365
            if (pedantic___0) {
              {
#line 366
              warn_for_assignment("pointer targets in %s differ in signedness", context___0,
                                  fdecl, parmnum);
              }
            }
          }
        }
      }
    }
  }
#line 369
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
bool check_assignment(type lhstype , type rhstype , expression rhs , char const   *context___0 ,
                      data_declaration fundecl , int parmnum ) 
{ 
  bool zerorhs ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  tag_declaration tag ;
  tag_declaration tmp___6 ;
  field_declaration fields ;
  field_declaration marginal_field ;
  type ft ;
  bool tmp___7 ;
  bool tmp___8 ;
  type ttl ;
  type tmp___9 ;
  type ttr ;
  type tmp___10 ;
  bool goodmatch ;
  bool tmp___11 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  bool tmp___23 ;
  bool tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  bool tmp___27 ;
  bool tmp___28 ;
  bool tmp___29 ;
  type ttl___0 ;
  type tmp___30 ;
  type ttr___0 ;
  type tmp___31 ;
  type_quals tmp___32 ;
  type ttl___1 ;
  type tmp___33 ;
  type ttr___1 ;
  type tmp___34 ;
  bool goodmatch___0 ;
  bool tmp___35 ;
  type tmp___36 ;
  type tmp___37 ;
  bool tmp___38 ;
  bool tmp___39 ;
  bool tmp___40 ;
  bool tmp___41 ;
  bool tmp___42 ;
  bool tmp___43 ;
  bool tmp___44 ;
  bool tmp___45 ;
  bool tmp___46 ;
  bool tmp___47 ;
  char const   *argname ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;

  {
#line 376
  if (rhs) {
    {
#line 376
    tmp = definite_zero(rhs);
    }
#line 376
    if (tmp) {
#line 376
      tmp___0 = 1;
    } else {
#line 376
      tmp___0 = 0;
    }
  } else {
#line 376
    tmp___0 = 0;
  }
#line 376
  zerorhs = (bool )tmp___0;
#line 378
  if ((unsigned long )lhstype == (unsigned long )error_type) {
#line 379
    return ((bool )0);
  } else
#line 378
  if ((unsigned long )rhstype == (unsigned long )error_type) {
#line 379
    return ((bool )0);
  }
  {
#line 381
  tmp___1 = type_void(rhstype);
  }
#line 381
  if (tmp___1) {
    {
#line 383
    error("void value not ignored as it ought to be");
    }
#line 384
    return ((bool )0);
  }
  {
#line 387
  tmp___2 = type_equal_unqualified(lhstype, rhstype);
  }
#line 387
  if (tmp___2) {
#line 388
    return ((bool )1);
  }
  {
#line 390
  tmp___4 = type_arithmetic(lhstype);
  }
#line 390
  if (tmp___4) {
    {
#line 390
    tmp___5 = type_arithmetic(rhstype);
    }
#line 390
    if (tmp___5) {
#line 392
      if (rhs) {
        {
#line 393
        constant_overflow_warning(rhs->cst);
        }
      }
      {
#line 394
      tmp___3 = check_conversion(lhstype, rhstype);
      }
#line 394
      return (tmp___3);
    }
  }
#line 396
  if (parmnum) {
    {
#line 396
    tmp___32 = type_qualifiers(lhstype);
    }
#line 396
    if ((unsigned int )tmp___32 & 1U) {
      {
#line 399
      tmp___6 = type_tag(lhstype);
#line 399
      tag = tmp___6;
#line 400
      marginal_field = (field_declaration )((void *)0);
#line 406
      fields = tag->fieldlist;
      }
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (! fields) {
#line 406
          goto while_break;
        }
        {
#line 408
        ft = fields->type;
#line 410
        tmp___7 = type_compatible(ft, rhstype);
        }
#line 410
        if (tmp___7) {
#line 411
          goto while_break;
        }
        {
#line 413
        tmp___8 = type_pointer(ft);
        }
#line 413
        if (! tmp___8) {
#line 414
          goto __Cont;
        }
        {
#line 416
        tmp___29 = type_pointer(rhstype);
        }
#line 416
        if (tmp___29) {
          {
#line 418
          tmp___9 = type_points_to(ft);
#line 418
          ttl = tmp___9;
#line 418
          tmp___10 = type_points_to(rhstype);
#line 418
          ttr = tmp___10;
#line 419
          tmp___11 = assignable_pointer_targets(ttl, ttr, (bool )0);
#line 419
          goodmatch = tmp___11;
          }
#line 425
          if (goodmatch) {
            {
#line 428
            tmp___27 = type_function(ttr);
            }
#line 428
            if (tmp___27) {
              {
#line 428
              tmp___28 = type_function(ttl);
              }
#line 428
              if (tmp___28) {
                {
#line 428
                tmp___14 = type_const(ttl);
                }
#line 428
                if (tmp___14) {
#line 428
                  tmp___15 = 0;
                } else {
#line 428
                  tmp___15 = 1;
                }
                {
#line 428
                tmp___16 = type_const(ttr);
#line 428
                tmp___17 = type_volatile(ttl);
                }
#line 428
                if (tmp___17) {
#line 428
                  tmp___18 = 0;
                } else {
#line 428
                  tmp___18 = 1;
                }
                {
#line 428
                tmp___19 = type_volatile(ttr);
#line 428
                tmp___26 = (tmp___15 | (int )tmp___16) & (tmp___18 | (int )tmp___19);
                }
              } else {
#line 428
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 428
              tmp___20 = type_const(ttl);
#line 428
              tmp___21 = type_const(ttr);
              }
#line 428
              if (tmp___21) {
#line 428
                tmp___22 = 0;
              } else {
#line 428
                tmp___22 = 1;
              }
              {
#line 428
              tmp___23 = type_volatile(ttl);
#line 428
              tmp___24 = type_volatile(ttr);
              }
#line 428
              if (tmp___24) {
#line 428
                tmp___25 = 0;
              } else {
#line 428
                tmp___25 = 1;
              }
#line 428
              tmp___26 = ((int )tmp___20 | tmp___22) & ((int )tmp___23 | tmp___25);
            }
#line 428
            if (tmp___26) {
#line 433
              goto while_break;
            }
#line 436
            if (! marginal_field) {
#line 437
              marginal_field = fields;
            }
          }
        }
#line 443
        if (zerorhs) {
#line 444
          goto while_break;
        }
        __Cont: /* CIL Label */ 
#line 406
        fields = fields->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 447
      if (fields) {
#line 447
        goto _L___0;
      } else
#line 447
      if (marginal_field) {
        _L___0: /* CIL Label */ 
#line 449
        if (! fields) {
          {
#line 453
          tmp___30 = type_points_to(marginal_field->type);
#line 453
          ttl___0 = tmp___30;
#line 453
          tmp___31 = type_points_to(rhstype);
#line 453
          ttr___0 = tmp___31;
#line 456
          ptrconversion_warnings(ttl___0, ttr___0, rhs, context___0, fundecl, parmnum,
                                 (bool )0);
          }
        }
#line 460
        if (pedantic) {
#line 460
          if (fundecl) {
#line 460
            if (! fundecl->in_system_header) {
              {
#line 461
              pedwarn("ANSI C prohibits argument conversion to union type");
              }
            }
          } else {
            {
#line 461
            pedwarn("ANSI C prohibits argument conversion to union type");
            }
          }
        }
#line 463
        return ((bool )1);
      }
    }
  }
  {
#line 467
  tmp___46 = type_pointer(lhstype);
  }
#line 467
  if (tmp___46) {
    {
#line 467
    tmp___47 = type_pointer(rhstype);
    }
#line 467
    if (tmp___47) {
      {
#line 469
      tmp___33 = type_points_to(lhstype);
#line 469
      ttl___1 = tmp___33;
#line 469
      tmp___34 = type_points_to(rhstype);
#line 469
      ttr___1 = tmp___34;
#line 470
      tmp___35 = assignable_pointer_targets(ttl___1, ttr___1, pedantic);
#line 470
      goodmatch___0 = tmp___35;
      }
#line 475
      if (goodmatch___0) {
        {
#line 477
        ptrconversion_warnings(ttl___1, ttr___1, rhs, context___0, fundecl, parmnum,
                               pedantic);
        }
      } else {
        {
#line 475
        tmp___36 = make_unsigned_type(ttr___1);
#line 475
        tmp___37 = make_unsigned_type(ttl___1);
#line 475
        tmp___38 = type_equal_unqualified(tmp___37, tmp___36);
        }
#line 475
        if (tmp___38) {
          {
#line 477
          ptrconversion_warnings(ttl___1, ttr___1, rhs, context___0, fundecl, parmnum,
                                 pedantic);
          }
        } else {
          {
#line 480
          warn_for_assignment("%s from incompatible pointer type", context___0, fundecl,
                              parmnum);
          }
        }
      }
      {
#line 483
      tmp___39 = check_conversion(lhstype, rhstype);
      }
#line 483
      return (tmp___39);
    } else {
#line 467
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 486
    tmp___44 = type_pointer(lhstype);
    }
#line 486
    if (tmp___44) {
      {
#line 486
      tmp___45 = type_integral(rhstype);
      }
#line 486
      if (tmp___45) {
#line 488
        if (! zerorhs) {
          {
#line 489
          warn_for_assignment("%s makes pointer from integer without a cast", context___0,
                              fundecl, parmnum);
          }
        }
        {
#line 491
        tmp___40 = check_conversion(lhstype, rhstype);
        }
#line 491
        return (tmp___40);
      } else {
#line 486
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 493
      tmp___42 = type_integral(lhstype);
      }
#line 493
      if (tmp___42) {
        {
#line 493
        tmp___43 = type_pointer(rhstype);
        }
#line 493
        if (tmp___43) {
          {
#line 495
          warn_for_assignment("%s makes integer from pointer without a cast", context___0,
                              fundecl, parmnum);
#line 497
          tmp___41 = check_conversion(lhstype, rhstype);
          }
#line 497
          return (tmp___41);
        }
      }
    }
  }
#line 500
  if (! context___0) {
    {
#line 502
    tmp___48 = argtype(& parmnum);
#line 502
    argname = tmp___48;
    }
#line 504
    if (fundecl) {
      {
#line 505
      tmp___49 = decl_printname(fundecl);
#line 505
      error("incompatible type for %s %d of `%s\'", argname, parmnum, tmp___49);
      }
    } else {
      {
#line 508
      error("incompatible type for %s %d of indirect function call", argname, parmnum);
      }
    }
  } else {
    {
#line 512
    error("incompatible types in %s", context___0);
    }
  }
#line 514
  return ((bool )0);
}
}
#line 517 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_error_expr(void) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  error_expr tmp ;

  {
  {
#line 519
  tmp = new_error_expr(parse_region, dummy_location);
#line 519
  tEmPcast = (AST_generic )tmp;
  }
#line 519
  if (tEmPcast) {
#line 519
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 519
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 519
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 519U, "make_error_expr");
        }
      }
    } else {
      {
#line 519
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 519U, "make_error_expr");
      }
    }
  }
#line 519
  result = (expression )tEmPcast;
#line 521
  result->type = error_type;
#line 523
  return (result);
}
}
#line 526 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_comma(location loc , expression elist ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  comma tmp ;
  expression e ;
  bool all_cst ;
  AST_generic tEmPcast___0 ;
  bool tmp___0 ;

  {
  {
#line 528
  tmp = new_comma(parse_region, loc, elist);
#line 528
  tEmPcast = (AST_generic )tmp;
  }
#line 528
  if (tEmPcast) {
#line 528
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 528
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 528
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 528U, "make_comma");
        }
      }
    } else {
      {
#line 528
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 528U, "make_comma");
      }
    }
  }
#line 528
  result = (expression )tEmPcast;
#line 530
  all_cst = (bool )1;
#line 532
  e = elist;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! e) {
#line 532
      goto while_break;
    }
#line 533
    if (e->next) {
#line 535
      if (! e->cst) {
#line 536
        all_cst = (bool )0;
      }
    } else {
      {
#line 554
      tmp___0 = type_array(e->type);
      }
#line 554
      if (tmp___0) {
        {
#line 555
        result->type = default_conversion(e);
        }
      } else {
#line 557
        result->type = e->type;
      }
#line 559
      if (! pedantic) {
#line 563
        if (all_cst) {
#line 564
          result->cst = e->cst;
        }
#line 565
        result->lvalue = e->lvalue;
#line 566
        result->isregister = e->isregister;
#line 567
        result->bitfield = e->bitfield;
      }
    }
#line 532
    tEmPcast___0 = (AST_generic )e->next;
#line 532
    if (tEmPcast___0) {
#line 532
      if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 532
        if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
          {
#line 532
          __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 532U,
                        "make_comma");
          }
        }
      } else {
        {
#line 532
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 532U, "make_comma");
        }
      }
    }
#line 532
    e = (expression )tEmPcast___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (result);
}
}
#line 574 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void check_dereference(expression result , type dereferenced , char const   *errorstring ) 
{ 
  type t ;
  type tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 577
  tmp___3 = type_pointer(dereferenced);
  }
#line 577
  if (tmp___3) {
    {
#line 579
    tmp = type_points_to(dereferenced);
#line 579
    t = tmp;
#line 581
    result->type = t;
#line 589
    tmp___0 = type_void(t);
    }
#line 589
    if (tmp___0) {
      {
#line 589
      tmp___1 = unevaluated_expression();
      }
#line 589
      if (! tmp___1) {
        {
#line 590
        warning("dereferencing `void *\' pointer");
        }
      }
    }
    {
#line 591
    tmp___2 = type_volatile(t);
#line 591
    result->side_effects = (bool )((int )result->side_effects | (int )tmp___2);
    }
  } else {
#line 595
    result->type = error_type;
#line 596
    if ((unsigned long )dereferenced != (unsigned long )error_type) {
      {
#line 597
      error("invalid type argument of `%s\'", errorstring);
      }
    }
  }
#line 599
  result->lvalue = (bool )1;
#line 600
  return;
}
}
#line 602 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_dereference(location loc , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  dereference tmp ;
  type tmp___0 ;

  {
  {
#line 604
  tmp = new_dereference(parse_region, loc, e);
#line 604
  tEmPcast = (AST_generic )tmp;
  }
#line 604
  if (tEmPcast) {
#line 604
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 604
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 604
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 604U, "make_dereference");
        }
      }
    } else {
      {
#line 604
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 604U, "make_dereference");
      }
    }
  }
  {
#line 604
  result = (expression )tEmPcast;
#line 606
  result->side_effects = e->side_effects;
#line 607
  tmp___0 = default_conversion(e);
#line 607
  check_dereference(result, tmp___0, "unary *");
#line 608
  result->static_address = e->cst;
  }
#line 610
  return (result);
}
}
#line 613 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_extension_expr(location loc , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  extension_expr tmp ;

  {
  {
#line 615
  tmp = new_extension_expr(parse_region, loc, e);
#line 615
  tEmPcast = (AST_generic )tmp;
  }
#line 615
  if (tEmPcast) {
#line 615
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 615
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 615
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 615U, "make_extension_expr");
        }
      }
    } else {
      {
#line 615
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 615U, "make_extension_expr");
      }
    }
  }
#line 615
  result = (expression )tEmPcast;
#line 617
  result->type = e->type;
#line 618
  result->lvalue = e->lvalue;
#line 619
  result->side_effects = e->side_effects;
#line 620
  result->cst = e->cst;
#line 621
  result->bitfield = e->bitfield;
#line 622
  result->isregister = e->isregister;
#line 623
  result->static_address = e->static_address;
#line 625
  return (result);
}
}
#line 628 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_address_of(location loc , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  address_of tmp ;
  bool tmp___0 ;

  {
  {
#line 630
  tmp = new_address_of(parse_region, loc, e);
#line 630
  tEmPcast = (AST_generic )tmp;
  }
#line 630
  if (tEmPcast) {
#line 630
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 630
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 630
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 630U, "make_address_of");
        }
      }
    } else {
      {
#line 630
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 630U, "make_address_of");
      }
    }
  }
#line 630
  result = (expression )tEmPcast;
#line 632
  result->type = error_type;
#line 634
  if (! ((unsigned long )e->type == (unsigned long )error_type)) {
#line 636
    if (e->bitfield) {
      {
#line 637
      error("attempt to take address of a bit-field structure member");
      }
    } else {
#line 640
      if (e->isregister) {
        {
#line 641
        pedwarn("address of a register variable requested");
        }
      }
      {
#line 643
      tmp___0 = type_function(e->type);
      }
#line 643
      if (! tmp___0) {
#line 643
        if (! e->lvalue) {
          {
#line 644
          error("invalid lvalue in unary `&\'");
          }
        }
      }
      {
#line 646
      result->type = make_pointer_type(e->type);
#line 647
      result->cst = e->static_address;
      }
    }
  }
#line 649
  return (result);
}
}
#line 652 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_unary(location loc , int unop , expression e ) 
{ 
  expression tmp ;
  expression tmp___0 ;
  expression tmp___1 ;
  expression result ;
  AST_generic tEmPcast ;
  unary tmp___2 ;
  type etype ;
  type tmp___3 ;
  char const   *errstring ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  type tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;

  {
  {
#line 656
  if (unop == 101) {
#line 656
    goto case_101;
  }
#line 658
  if (unop == 89) {
#line 658
    goto case_89;
  }
#line 660
  if (unop == 90) {
#line 660
    goto case_90;
  }
#line 662
  goto switch_default;
  case_101: /* CIL Label */ 
  {
#line 657
  tmp = make_address_of(loc, e);
  }
#line 657
  return (tmp);
  case_89: /* CIL Label */ 
  {
#line 659
  tmp___0 = make_preincrement(loc, e);
  }
#line 659
  return (tmp___0);
  case_90: /* CIL Label */ 
  {
#line 661
  tmp___1 = make_predecrement(loc, e);
  }
#line 661
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 664
  tmp___2 = newkind_unary(parse_region, (AST_kind )unop, loc, e);
#line 664
  tEmPcast = (AST_generic )tmp___2;
  }
#line 664
  if (tEmPcast) {
#line 664
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 664
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 664
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 664U, "make_unary");
        }
      }
    } else {
      {
#line 664
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 664U, "make_unary");
      }
    }
  }
  {
#line 664
  result = (expression )tEmPcast;
#line 665
  tmp___3 = default_conversion(e);
#line 665
  etype = tmp___3;
#line 666
  errstring = (char const   *)((void *)0);
  }
#line 668
  if ((unsigned long )etype == (unsigned long )error_type) {
#line 669
    result->type = error_type;
  } else {
    {
#line 674
    if (unop == 103) {
#line 674
      goto case_103;
    }
#line 678
    if (unop == 102) {
#line 678
      goto case_102;
    }
#line 682
    if (unop == 105) {
#line 682
      goto case_105;
    }
#line 688
    if (unop == 106) {
#line 688
      goto case_106;
    }
#line 694
    if (unop == 100) {
#line 694
      goto case_100;
    }
#line 694
    if (unop == 99) {
#line 694
      goto case_100;
    }
#line 703
    goto switch_default___0;
    case_103: /* CIL Label */ 
    {
#line 675
    tmp___4 = type_arithmetic(etype);
    }
#line 675
    if (! tmp___4) {
#line 676
      errstring = "wrong type argument to unary plus";
    }
#line 677
    goto switch_break___0;
    case_102: /* CIL Label */ 
    {
#line 679
    tmp___5 = type_arithmetic(etype);
    }
#line 679
    if (! tmp___5) {
#line 680
      errstring = "wrong type argument to unary minus";
    }
#line 681
    goto switch_break___0;
    case_105: /* CIL Label */ 
    {
#line 683
    tmp___7 = type_complex(etype);
    }
#line 683
    if (tmp___7) {
#line 684
      result->kind = (AST_kind )104;
    } else {
      {
#line 685
      tmp___6 = type_integer(etype);
      }
#line 685
      if (! tmp___6) {
#line 686
        errstring = "wrong type argument to bit-complement";
      }
    }
#line 687
    goto switch_break___0;
    case_106: /* CIL Label */ 
    {
#line 689
    tmp___8 = type_scalar(etype);
    }
#line 689
    if (tmp___8) {
#line 692
      etype = int_type;
    } else {
#line 690
      errstring = "wrong type argument to unary exclamation mark";
    }
#line 693
    goto switch_break___0;
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    {
#line 695
    tmp___12 = type_arithmetic(etype);
    }
#line 695
    if (tmp___12) {
      {
#line 701
      tmp___11 = type_complex(etype);
      }
#line 701
      if (tmp___11) {
        {
#line 701
        tmp___10 = make_base_type(etype);
#line 701
        etype = tmp___10;
        }
      } else {
#line 701
        etype = etype;
      }
    } else
#line 696
    if (unop == 99) {
#line 697
      errstring = "wrong type argument to __real__";
    } else {
#line 699
      errstring = "wrong type argument to __imag__";
    }
#line 702
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 704
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 704U,
                  "make_unary");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 706
    if (errstring) {
      {
#line 708
      error(errstring);
#line 709
      result->type = error_type;
      }
    } else {
      {
#line 713
      result->type = etype;
#line 714
      result->cst = fold_unary(result);
      }
    }
  }
#line 717
  return (result);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 722 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_label_address(location loc , id_label label___0 ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  label_address tmp ;

  {
  {
#line 724
  tmp = new_label_address(parse_region, loc, label___0);
#line 724
  tEmPcast = (AST_generic )tmp;
  }
#line 724
  if (tEmPcast) {
#line 724
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 724
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 724
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 724U, "make_label_address");
        }
      }
    } else {
      {
#line 724
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 724U, "make_label_address");
      }
    }
  }
  {
#line 724
  result = (expression )tEmPcast;
#line 726
  use_label(label___0);
#line 728
  result->type = ptr_void_type;
#line 729
  result->cst = fold_label_address(result);
  }
#line 731
  if (pedantic) {
    {
#line 732
    pedwarn("ANSI C forbids `&&\'");
    }
  }
#line 734
  return (result);
}
}
#line 737 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static void check_sizealign(char const   *kind , type stype ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 739
  tmp___0 = type_command(stype);
  }
#line 739
  if (tmp___0) {
    {
#line 741
    error("%s applied to a command, event, interface or component", kind);
    }
  } else {
    {
#line 739
    tmp___1 = type_event(stype);
    }
#line 739
    if (tmp___1) {
      {
#line 741
      error("%s applied to a command, event, interface or component", kind);
      }
    } else {
      {
#line 739
      tmp___2 = type_interface(stype);
      }
#line 739
      if (tmp___2) {
        {
#line 741
        error("%s applied to a command, event, interface or component", kind);
        }
      } else {
        {
#line 739
        tmp___3 = type_component(stype);
        }
#line 739
        if (tmp___3) {
          {
#line 741
          error("%s applied to a command, event, interface or component", kind);
          }
        } else {
          {
#line 742
          tmp = type_incomplete(stype);
          }
#line 742
          if (tmp) {
            {
#line 743
            error("%s applied to an incomplete type", kind);
            }
          }
        }
      }
    }
  }
#line 744
  return;
}
}
#line 746 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
void check_sizeof(expression result , type stype ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 748
  tmp___0 = type_function(stype);
  }
#line 748
  if (tmp___0) {
#line 750
    if (pedantic) {
      {
#line 751
      pedwarn("sizeof applied to a function type");
      }
    } else
#line 750
    if (warn_pointer_arith) {
      {
#line 751
      pedwarn("sizeof applied to a function type");
      }
    }
  } else {
    {
#line 753
    tmp = type_void(stype);
    }
#line 753
    if (tmp) {
#line 755
      if (pedantic) {
        {
#line 756
        pedwarn("sizeof applied to a void type");
        }
      } else
#line 755
      if (warn_pointer_arith) {
        {
#line 756
        pedwarn("sizeof applied to a void type");
        }
      }
    } else {
      {
#line 759
      check_sizealign("sizeof", stype);
      }
    }
  }
  {
#line 761
  result->type = size_t_type;
#line 762
  result->cst = fold_sizeof(result, stype);
  }
#line 763
  return;
}
}
#line 765 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_sizeof_expr(location loc , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  sizeof_expr tmp ;

  {
  {
#line 767
  tmp = new_sizeof_expr(parse_region, loc, e);
#line 767
  tEmPcast = (AST_generic )tmp;
  }
#line 767
  if (tEmPcast) {
#line 767
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 767
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 767
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 767U, "make_sizeof_expr");
        }
      }
    } else {
      {
#line 767
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 767U, "make_sizeof_expr");
      }
    }
  }
  {
#line 767
  result = (expression )tEmPcast;
#line 768
  check_sizeof(result, e->type);
  }
#line 769
  return (result);
}
}
#line 772 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_sizeof_type(location loc , asttype t ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  sizeof_type tmp ;

  {
  {
#line 774
  tmp = new_sizeof_type(parse_region, loc, t);
#line 774
  tEmPcast = (AST_generic )tmp;
  }
#line 774
  if (tEmPcast) {
#line 774
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 774
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 774
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 774U, "make_sizeof_type");
        }
      }
    } else {
      {
#line 774
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 774U, "make_sizeof_type");
      }
    }
  }
  {
#line 774
  result = (expression )tEmPcast;
#line 775
  check_sizeof(result, t->type);
  }
#line 776
  return (result);
}
}
#line 779 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
void check_alignof(expression result , type stype ) 
{ 


  {
  {
#line 781
  check_sizealign("__alignof__", stype);
#line 783
  result->type = size_t_type;
#line 784
  result->cst = fold_sizeof(result, stype);
  }
#line 785
  return;
}
}
#line 787 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_alignof_expr(location loc , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  alignof_expr tmp ;

  {
  {
#line 789
  tmp = new_alignof_expr(parse_region, loc, e);
#line 789
  tEmPcast = (AST_generic )tmp;
  }
#line 789
  if (tEmPcast) {
#line 789
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 789
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 789
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 789U, "make_alignof_expr");
        }
      }
    } else {
      {
#line 789
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 789U, "make_alignof_expr");
      }
    }
  }
  {
#line 789
  result = (expression )tEmPcast;
#line 790
  check_alignof(result, e->type);
  }
#line 791
  return (result);
}
}
#line 794 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_alignof_type(location loc , asttype t ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  alignof_type tmp ;

  {
  {
#line 796
  tmp = new_alignof_type(parse_region, loc, t);
#line 796
  tEmPcast = (AST_generic )tmp;
  }
#line 796
  if (tEmPcast) {
#line 796
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 796
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 796
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 796U, "make_alignof_type");
        }
      }
    } else {
      {
#line 796
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 796U, "make_alignof_type");
      }
    }
  }
  {
#line 796
  result = (expression )tEmPcast;
#line 797
  check_alignof(result, t->type);
  }
#line 798
  return (result);
}
}
#line 801 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_cast(location loc , asttype t , expression e ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  cast tmp ;
  type castto ;
  bool tmp___0 ;
  type etype ;
  bool tmp___1 ;
  bool tmp___2 ;
  tag_declaration utag ;
  tag_declaration tmp___3 ;
  field_declaration ufield ;
  bool tmp___4 ;
  type ep ;
  type tmp___5 ;
  type cp ;
  type tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;

  {
  {
#line 803
  tmp = new_cast(parse_region, loc, e, t);
#line 803
  tEmPcast = (AST_generic )tmp;
  }
#line 803
  if (tEmPcast) {
#line 803
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 803
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 803
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 803U, "make_cast");
        }
      }
    } else {
      {
#line 803
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 803U, "make_cast");
      }
    }
  }
#line 803
  result = (expression )tEmPcast;
#line 804
  castto = t->type;
#line 806
  if (! ((unsigned long )castto == (unsigned long )error_type)) {
    {
#line 806
    tmp___19 = type_void(castto);
    }
#line 806
    if (! tmp___19) {
      {
#line 808
      tmp___18 = type_array(castto);
      }
#line 808
      if (tmp___18) {
        {
#line 810
        error("cast specifies array type");
#line 811
        castto = error_type;
        }
      } else {
        {
#line 813
        tmp___17 = type_function(castto);
        }
#line 813
        if (tmp___17) {
          {
#line 815
          error("cast specifies function type");
#line 816
          castto = error_type;
          }
        } else {
          {
#line 818
          tmp___16 = type_equal_unqualified(castto, e->type);
          }
#line 818
          if (tmp___16) {
#line 820
            if (pedantic) {
              {
#line 820
              tmp___0 = type_aggregate(castto);
              }
#line 820
              if (tmp___0) {
                {
#line 821
                pedwarn("ANSI C forbids casting nonscalar to the same type");
                }
              }
            }
          } else {
            {
#line 825
            etype = e->type;
#line 829
            tmp___1 = type_function(etype);
            }
#line 829
            if (tmp___1) {
              {
#line 830
              etype = default_conversion(e);
              }
            } else {
              {
#line 829
              tmp___2 = type_array(etype);
              }
#line 829
              if (tmp___2) {
                {
#line 830
                etype = default_conversion(e);
                }
              }
            }
            {
#line 832
            tmp___15 = type_union(castto);
            }
#line 832
            if (tmp___15) {
              {
#line 834
              tmp___3 = type_tag(castto);
#line 834
              utag = tmp___3;
#line 838
              ufield = utag->fieldlist;
              }
              {
#line 838
              while (1) {
                while_continue: /* CIL Label */ ;
#line 838
                if (! ufield) {
#line 838
                  goto while_break;
                }
#line 839
                if (ufield->name) {
                  {
#line 839
                  tmp___4 = type_equal_unqualified(ufield->type, etype);
                  }
#line 839
                  if (tmp___4) {
#line 841
                    if (pedantic) {
                      {
#line 842
                      pedwarn("ANSI C forbids casts to union type");
                      }
                    }
#line 843
                    goto while_break;
                  }
                }
#line 838
                ufield = ufield->next;
              }
              while_break: /* CIL Label */ ;
              }
#line 845
              if (! ufield) {
                {
#line 846
                error("cast to union type from type not present in union");
                }
              }
            } else {
#line 852
              if (warn_cast_qual) {
                {
#line 852
                tmp___11 = type_pointer(etype);
                }
#line 852
                if (tmp___11) {
                  {
#line 852
                  tmp___12 = type_pointer(castto);
                  }
#line 852
                  if (tmp___12) {
                    {
#line 854
                    tmp___5 = type_points_to(etype);
#line 854
                    ep = tmp___5;
#line 854
                    tmp___6 = type_points_to(castto);
#line 854
                    cp = tmp___6;
#line 856
                    tmp___7 = type_volatile(ep);
                    }
#line 856
                    if (tmp___7) {
                      {
#line 856
                      tmp___8 = type_volatile(cp);
                      }
#line 856
                      if (! tmp___8) {
                        {
#line 857
                        pedwarn("cast discards `volatile\' from pointer target type");
                        }
                      }
                    }
                    {
#line 858
                    tmp___9 = type_const(ep);
                    }
#line 858
                    if (tmp___9) {
                      {
#line 858
                      tmp___10 = type_const(cp);
                      }
#line 858
                      if (! tmp___10) {
                        {
#line 859
                        pedwarn("cast discards `const\' from pointer target type");
                        }
                      }
                    }
                  }
                }
              }
#line 863
              if (warn_bad_function_cast) {
#line 863
                if ((unsigned int )e->kind >= 148U) {
#line 863
                  if ((unsigned int )e->kind <= 148U) {
                    {
#line 863
                    tmp___13 = type_equal_unqualified(castto, etype);
                    }
#line 863
                    if (! tmp___13) {
                      {
#line 865
                      warning("cast does not match function type");
                      }
                    }
                  }
                }
              }
              {
#line 901
              tmp___14 = check_conversion(castto, etype);
              }
#line 901
              if (! tmp___14) {
#line 902
                castto = error_type;
              }
            }
          }
        }
      }
    }
  }
#line 906
  if (! pedantic) {
#line 906
    if (e->lvalue) {
#line 906
      tmp___20 = 1;
    } else {
#line 906
      tmp___20 = 0;
    }
  } else {
#line 906
    tmp___20 = 0;
  }
#line 906
  result->lvalue = (bool )tmp___20;
#line 907
  result->isregister = e->isregister;
#line 908
  result->bitfield = e->bitfield;
#line 909
  result->static_address = e->static_address;
#line 910
  result->type = castto;
#line 911
  if ((unsigned long )castto != (unsigned long )error_type) {
    {
#line 912
    result->cst = fold_cast(result);
    }
  }
#line 914
  return (result);
}
}
#line 917 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
type pointer_int_sum(type ptype , type itype ) 
{ 
  type pointed ;
  type tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 919
  tmp = type_points_to(ptype);
#line 919
  pointed = tmp;
#line 921
  tmp___2 = type_void(pointed);
  }
#line 921
  if (tmp___2) {
#line 923
    if (pedantic) {
      {
#line 924
      pedwarn("pointer of type `void *\' used in arithmetic");
      }
    } else
#line 923
    if (warn_pointer_arith) {
      {
#line 924
      pedwarn("pointer of type `void *\' used in arithmetic");
      }
    }
  } else {
    {
#line 926
    tmp___1 = type_function(pointed);
    }
#line 926
    if (tmp___1) {
#line 928
      if (pedantic) {
        {
#line 929
        pedwarn("pointer to a function used in arithmetic");
        }
      } else
#line 928
      if (warn_pointer_arith) {
        {
#line 929
        pedwarn("pointer to a function used in arithmetic");
        }
      }
    } else {
      {
#line 931
      tmp___0 = type_incomplete(pointed);
      }
#line 931
      if (tmp___0) {
        {
#line 932
        error("arithmetic on pointer to an incomplete type");
        }
      }
    }
  }
#line 934
  return (ptype);
}
}
#line 937 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
bool valid_compare(type t1 , type t2 , expression e1 ) 
{ 
  type tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  type tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 939
  tmp___2 = type_points_to(t1);
#line 939
  tmp___3 = type_void(tmp___2);
  }
#line 939
  if (tmp___3) {
#line 941
    if (pedantic) {
      {
#line 941
      tmp = type_points_to(t2);
#line 941
      tmp___0 = type_function(tmp);
      }
#line 941
      if (tmp___0) {
        {
#line 941
        tmp___1 = definite_null(e1);
        }
#line 941
        if (! tmp___1) {
          {
#line 942
          pedwarn("ANSI C forbids comparison of `void *\' with function pointer");
          }
        }
      }
    }
#line 943
    return ((bool )1);
  }
#line 945
  return ((bool )0);
}
}
#line 948 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
type check_binary(int binop , expression e1 , expression e2 ) 
{ 
  type t1 ;
  type tmp ;
  type t2 ;
  type tmp___0 ;
  type rtype ;
  bool common ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  type tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  bool tmp___23 ;
  bool tmp___24 ;
  bool tmp___25 ;
  bool tmp___26 ;
  bool tmp___27 ;
  bool tmp___28 ;
  bool tmp___29 ;
  bool tmp___30 ;
  bool tmp___31 ;
  bool tmp___32 ;
  bool tmp___33 ;
  bool tmp___34 ;
  bool tmp___35 ;
  bool tmp___36 ;
  bool tmp___37 ;
  bool tmp___38 ;
  bool tmp___39 ;
  bool tmp___40 ;
  bool tmp___41 ;
  bool tmp___42 ;
  bool tmp___43 ;
  bool tmp___44 ;
  bool tmp___45 ;
  bool tmp___46 ;
  bool tmp___47 ;
  bool tmp___48 ;
  bool tmp___49 ;
  char const   *tmp___50 ;

  {
  {
#line 950
  tmp = default_conversion(e1);
#line 950
  t1 = tmp;
#line 950
  tmp___0 = default_conversion(e2);
#line 950
  t2 = tmp___0;
#line 951
  rtype = (type )((void *)0);
#line 952
  common = (bool )0;
  }
#line 955
  if ((unsigned long )t1 == (unsigned long )error_type) {
#line 956
    rtype = error_type;
  } else
#line 955
  if ((unsigned long )t2 == (unsigned long )error_type) {
#line 956
    rtype = error_type;
  } else {
    {
#line 959
    if (binop == 128) {
#line 959
      goto case_128;
    }
#line 968
    if (binop == 129) {
#line 968
      goto case_129;
    }
#line 978
    if (binop == 118) {
#line 978
      goto case_118;
    }
#line 978
    if (binop == 117) {
#line 978
      goto case_118;
    }
#line 986
    if (binop == 120) {
#line 986
      goto case_120;
    }
#line 986
    if (binop == 119) {
#line 986
      goto case_120;
    }
#line 986
    if (binop == 131) {
#line 986
      goto case_120;
    }
#line 986
    if (binop == 130) {
#line 986
      goto case_120;
    }
#line 993
    if (binop == 123) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 122) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 126) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 125) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 124) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 121) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 134) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 133) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 137) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 136) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 135) {
#line 993
      goto case_123;
    }
#line 993
    if (binop == 132) {
#line 993
      goto case_123;
    }
#line 998
    if (binop == 112) {
#line 998
      goto case_112;
    }
#line 998
    if (binop == 111) {
#line 998
      goto case_112;
    }
#line 998
    if (binop == 110) {
#line 998
      goto case_112;
    }
#line 998
    if (binop == 109) {
#line 998
      goto case_112;
    }
#line 1032
    if (binop == 114) {
#line 1032
      goto case_114;
    }
#line 1032
    if (binop == 113) {
#line 1032
      goto case_114;
    }
#line 1056
    if (binop == 139) {
#line 1056
      goto case_139;
    }
#line 1056
    if (binop == 138) {
#line 1056
      goto case_139;
    }
#line 1061
    goto switch_default;
    case_128: /* CIL Label */ 
    {
#line 960
    tmp___3 = type_pointer(t1);
    }
#line 960
    if (tmp___3) {
      {
#line 960
      tmp___4 = type_integer(t2);
      }
#line 960
      if (tmp___4) {
        {
#line 961
        rtype = pointer_int_sum(t1, t2);
        }
      } else {
#line 960
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 962
      tmp___1 = type_pointer(t2);
      }
#line 962
      if (tmp___1) {
        {
#line 962
        tmp___2 = type_integer(t1);
        }
#line 962
        if (tmp___2) {
          {
#line 963
          rtype = pointer_int_sum(t2, t1);
          }
        } else {
#line 965
          common = (bool )1;
        }
      } else {
#line 965
        common = (bool )1;
      }
    }
#line 966
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 969
    tmp___8 = type_pointer(t1);
    }
#line 969
    if (tmp___8) {
      {
#line 969
      tmp___9 = type_integer(t2);
      }
#line 969
      if (tmp___9) {
        {
#line 970
        rtype = pointer_int_sum(t1, t2);
        }
      } else {
#line 969
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 971
      tmp___5 = type_pointer(t1);
      }
#line 971
      if (tmp___5) {
        {
#line 971
        tmp___6 = type_pointer(t2);
        }
#line 971
        if (tmp___6) {
          {
#line 971
          tmp___7 = compatible_pointer_types(t1, t2);
          }
#line 971
          if (tmp___7) {
#line 973
            rtype = ptrdiff_t_type;
          } else {
#line 975
            common = (bool )1;
          }
        } else {
#line 975
          common = (bool )1;
        }
      } else {
#line 975
        common = (bool )1;
      }
    }
#line 976
    goto switch_break;
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    {
#line 979
    tmp___10 = type_pointer(t1);
    }
#line 979
    if (tmp___10) {
      {
#line 979
      tmp___11 = type_integer(t2);
      }
#line 979
      if (tmp___11) {
        {
#line 980
        rtype = pointer_int_sum(t1, t2);
        }
      } else {
#line 982
        common = (bool )1;
      }
    } else {
#line 982
      common = (bool )1;
    }
#line 983
    goto switch_break;
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
#line 987
    common = (bool )1;
#line 988
    goto switch_break;
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    case_137: /* CIL Label */ 
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_132: /* CIL Label */ 
    {
#line 994
    tmp___12 = type_integer(t1);
    }
#line 994
    if (tmp___12) {
      {
#line 994
      tmp___13 = type_integer(t2);
      }
#line 994
      if (tmp___13) {
        {
#line 995
        rtype = common_type(t1, t2);
        }
      }
    }
#line 996
    goto switch_break;
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    {
#line 999
    rtype = int_type;
#line 1000
    tmp___29 = type_real(t1);
    }
#line 1000
    if (tmp___29) {
      {
#line 1000
      tmp___30 = type_real(t2);
      }
#line 1000
      if (! tmp___30) {
#line 1000
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      {
#line 1002
      tmp___27 = type_pointer(t1);
      }
#line 1002
      if (tmp___27) {
        {
#line 1002
        tmp___28 = type_pointer(t2);
        }
#line 1002
        if (tmp___28) {
          {
#line 1004
          tmp___18 = compatible_pointer_types(t1, t2);
          }
#line 1004
          if (tmp___18) {
            {
#line 1007
            tmp___16 = type_incomplete(t1);
#line 1007
            tmp___17 = type_incomplete(t2);
            }
#line 1007
            if ((int )tmp___16 != (int )tmp___17) {
              {
#line 1008
              pedwarn("comparison of complete and incomplete pointers");
              }
            } else
#line 1009
            if (pedantic) {
              {
#line 1009
              tmp___14 = type_points_to(t1);
#line 1009
              tmp___15 = type_function(tmp___14);
              }
#line 1009
              if (tmp___15) {
                {
#line 1010
                pedwarn("ANSI C forbids ordered comparisons of pointers to functions");
                }
              }
            }
          } else {
            {
#line 1013
            pedwarn("comparison of distinct pointer types lacks a cast");
            }
          }
        } else {
#line 1002
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        {
#line 1016
        tmp___23 = type_pointer(t1);
        }
#line 1016
        if (tmp___23) {
          {
#line 1016
          tmp___24 = definite_zero(e2);
          }
#line 1016
          if (tmp___24) {
#line 1016
            goto _L___3;
          } else {
#line 1016
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          {
#line 1016
          tmp___25 = type_pointer(t2);
          }
#line 1016
          if (tmp___25) {
            {
#line 1016
            tmp___26 = definite_zero(e1);
            }
#line 1016
            if (tmp___26) {
              _L___3: /* CIL Label */ 
#line 1019
              if (pedantic) {
                {
#line 1020
                pedwarn("ordered comparison of pointer with integer zero");
                }
              } else
#line 1019
              if (extra_warnings) {
                {
#line 1020
                pedwarn("ordered comparison of pointer with integer zero");
                }
              }
            } else {
#line 1016
              goto _L___4;
            }
          } else {
            _L___4: /* CIL Label */ 
            {
#line 1022
            tmp___19 = type_pointer(t1);
            }
#line 1022
            if (tmp___19) {
              {
#line 1022
              tmp___20 = type_integer(t2);
              }
#line 1022
              if (tmp___20) {
#line 1022
                goto _L___1;
              } else {
#line 1022
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ 
              {
#line 1022
              tmp___21 = type_pointer(t2);
              }
#line 1022
              if (tmp___21) {
                {
#line 1022
                tmp___22 = type_integer(t1);
                }
#line 1022
                if (tmp___22) {
                  _L___1: /* CIL Label */ 
#line 1025
                  if (! flag_traditional) {
                    {
#line 1026
                    pedwarn("comparison between pointer and integer");
                    }
                  }
                } else {
#line 1029
                  rtype = (type )((void *)0);
                }
              } else {
#line 1029
                rtype = (type )((void *)0);
              }
            }
          }
        }
      }
    }
#line 1030
    goto switch_break;
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    {
#line 1033
    rtype = int_type;
#line 1034
    tmp___44 = type_arithmetic(t1);
    }
#line 1034
    if (tmp___44) {
      {
#line 1034
      tmp___45 = type_arithmetic(t2);
      }
#line 1034
      if (! tmp___45) {
#line 1034
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */ 
      {
#line 1036
      tmp___42 = type_pointer(t1);
      }
#line 1036
      if (tmp___42) {
        {
#line 1036
        tmp___43 = type_pointer(t2);
        }
#line 1036
        if (tmp___43) {
          {
#line 1038
          tmp___31 = compatible_pointer_types(t1, t2);
          }
#line 1038
          if (! tmp___31) {
            {
#line 1038
            tmp___32 = valid_compare(t1, t2, e1);
            }
#line 1038
            if (! tmp___32) {
              {
#line 1038
              tmp___33 = valid_compare(t2, t1, e2);
              }
#line 1038
              if (! tmp___33) {
                {
#line 1041
                pedwarn("comparison of distinct pointer types lacks a cast");
                }
              }
            }
          }
        } else {
#line 1036
          goto _L___12;
        }
      } else {
        _L___12: /* CIL Label */ 
        {
#line 1043
        tmp___38 = type_pointer(t1);
        }
#line 1043
        if (tmp___38) {
          {
#line 1043
          tmp___39 = definite_null(e2);
          }
#line 1043
          if (! tmp___39) {
#line 1043
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ 
          {
#line 1043
          tmp___40 = type_pointer(t2);
          }
#line 1043
          if (tmp___40) {
            {
#line 1043
            tmp___41 = definite_null(e1);
            }
#line 1043
            if (! tmp___41) {
#line 1043
              goto _L___10;
            }
          } else {
            _L___10: /* CIL Label */ 
            {
#line 1046
            tmp___34 = type_pointer(t1);
            }
#line 1046
            if (tmp___34) {
              {
#line 1046
              tmp___35 = type_integer(t2);
              }
#line 1046
              if (tmp___35) {
#line 1046
                goto _L___8;
              } else {
#line 1046
                goto _L___9;
              }
            } else {
              _L___9: /* CIL Label */ 
              {
#line 1046
              tmp___36 = type_pointer(t2);
              }
#line 1046
              if (tmp___36) {
                {
#line 1046
                tmp___37 = type_integer(t1);
                }
#line 1046
                if (tmp___37) {
                  _L___8: /* CIL Label */ 
#line 1049
                  if (! flag_traditional) {
                    {
#line 1050
                    pedwarn("comparison between pointer and integer");
                    }
                  }
                } else {
#line 1053
                  rtype = (type )((void *)0);
                }
              } else {
#line 1053
                rtype = (type )((void *)0);
              }
            }
          }
        }
      }
    }
#line 1054
    goto switch_break;
    case_139: /* CIL Label */ 
    case_138: /* CIL Label */ 
    {
#line 1057
    tmp___46 = type_scalar(t1);
    }
#line 1057
    if (tmp___46) {
      {
#line 1057
      tmp___47 = type_scalar(t2);
      }
#line 1057
      if (tmp___47) {
#line 1058
        rtype = int_type;
      }
    }
#line 1059
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1061
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1061U,
                  "check_binary");
    }
#line 1061
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1064
  if (common) {
    {
#line 1064
    tmp___48 = type_arithmetic(t1);
    }
#line 1064
    if (tmp___48) {
      {
#line 1064
      tmp___49 = type_arithmetic(t2);
      }
#line 1064
      if (tmp___49) {
        {
#line 1065
        rtype = common_type(t1, t2);
        }
      }
    }
  }
#line 1067
  if (! rtype) {
    {
#line 1069
    tmp___50 = binary_op_name((AST_kind )binop);
#line 1069
    error("invalid operands to binary %s", tmp___50);
#line 1070
    rtype = error_type;
    }
  }
#line 1073
  return (rtype);
}
}
#line 1076 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool unsafe_comparison(expression e ) 
{ 
  int tmp ;

  {
#line 1078
  if (! e->parens) {
#line 1078
    if ((unsigned int )e->kind >= 108U) {
#line 1078
      if ((unsigned int )e->kind <= 114U) {
#line 1078
        tmp = 1;
      } else {
#line 1078
        tmp = 0;
      }
    } else {
#line 1078
      tmp = 0;
    }
  } else {
#line 1078
    tmp = 0;
  }
#line 1078
  return ((bool )tmp);
}
}
#line 1081 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_binary(location loc , int binop , expression e1 , expression e2 ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  binary tmp ;
  int code1 ;
  unsigned int tmp___0 ;
  int code2 ;
  unsigned int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;

  {
  {
#line 1083
  tmp = newkind_binary(parse_region, (AST_kind )binop, loc, e1, e2);
#line 1083
  tEmPcast = (AST_generic )tmp;
  }
#line 1083
  if (tEmPcast) {
#line 1083
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1083
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1083
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1083U,
                      "make_binary");
        }
      }
    } else {
      {
#line 1083
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1083U, "make_binary");
      }
    }
  }
  {
#line 1083
  result = (expression )tEmPcast;
#line 1085
  result->type = check_binary(binop, e1, e2);
  }
#line 1086
  if ((unsigned long )result->type != (unsigned long )error_type) {
    {
#line 1088
    result->cst = fold_binary(result->type, result);
    }
  }
#line 1094
  if (warn_parentheses) {
#line 1096
    if (e1->parens) {
#line 1096
      tmp___0 = 0U;
    } else {
#line 1096
      tmp___0 = (unsigned int )e1->kind;
    }
#line 1096
    code1 = (int )tmp___0;
#line 1096
    if (e2->parens) {
#line 1096
      tmp___1 = 0U;
    } else {
#line 1096
      tmp___1 = (unsigned int )e2->kind;
    }
#line 1096
    code2 = (int )tmp___1;
#line 1098
    if (binop == 133) {
#line 1098
      goto _L;
    } else
#line 1098
    if (binop == 134) {
      _L: /* CIL Label */ 
#line 1100
      if (code1 == 128) {
        {
#line 1102
        warning("suggest parentheses around + or - inside shift");
        }
      } else
#line 1100
      if (code1 == 129) {
        {
#line 1102
        warning("suggest parentheses around + or - inside shift");
        }
      } else
#line 1100
      if (code2 == 128) {
        {
#line 1102
        warning("suggest parentheses around + or - inside shift");
        }
      } else
#line 1100
      if (code2 == 129) {
        {
#line 1102
        warning("suggest parentheses around + or - inside shift");
        }
      }
    }
#line 1105
    if (binop == 139) {
#line 1107
      if (code1 == 138) {
        {
#line 1108
        warning("suggest parentheses around && within ||");
        }
      } else
#line 1107
      if (code2 == 138) {
        {
#line 1108
        warning("suggest parentheses around && within ||");
        }
      }
    }
#line 1111
    if (binop == 136) {
#line 1113
      if (code1 == 135) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code1 == 137) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code1 == 128) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code1 == 129) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code2 == 135) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code2 == 137) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code2 == 128) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      } else
#line 1113
      if (code2 == 129) {
        {
#line 1117
        warning("suggest parentheses around arithmetic in operand of |");
        }
      }
      {
#line 1119
      tmp___2 = unsafe_comparison(e1);
      }
#line 1119
      if (tmp___2) {
        {
#line 1120
        warning("suggest parentheses around comparison in operand of |");
        }
      } else {
        {
#line 1119
        tmp___3 = unsafe_comparison(e2);
        }
#line 1119
        if (tmp___3) {
          {
#line 1120
          warning("suggest parentheses around comparison in operand of |");
          }
        }
      }
    }
#line 1123
    if (binop == 137) {
#line 1125
      if (code1 == 135) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      } else
#line 1125
      if (code1 == 128) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      } else
#line 1125
      if (code1 == 129) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      } else
#line 1125
      if (code2 == 135) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      } else
#line 1125
      if (code2 == 128) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      } else
#line 1125
      if (code2 == 129) {
        {
#line 1129
        warning("suggest parentheses around arithmetic in operand of ^");
        }
      }
      {
#line 1131
      tmp___4 = unsafe_comparison(e1);
      }
#line 1131
      if (tmp___4) {
        {
#line 1132
        warning("suggest parentheses around comparison in operand of ^");
        }
      } else {
        {
#line 1131
        tmp___5 = unsafe_comparison(e2);
        }
#line 1131
        if (tmp___5) {
          {
#line 1132
          warning("suggest parentheses around comparison in operand of ^");
          }
        }
      }
    }
#line 1135
    if (binop == 135) {
#line 1137
      if (code1 == 128) {
        {
#line 1139
        warning("suggest parentheses around + or - in operand of &");
        }
      } else
#line 1137
      if (code1 == 129) {
        {
#line 1139
        warning("suggest parentheses around + or - in operand of &");
        }
      } else
#line 1137
      if (code2 == 128) {
        {
#line 1139
        warning("suggest parentheses around + or - in operand of &");
        }
      } else
#line 1137
      if (code2 == 129) {
        {
#line 1139
        warning("suggest parentheses around + or - in operand of &");
        }
      }
      {
#line 1141
      tmp___6 = unsafe_comparison(e1);
      }
#line 1141
      if (tmp___6) {
        {
#line 1142
        warning("suggest parentheses around comparison in operand of &");
        }
      } else {
        {
#line 1141
        tmp___7 = unsafe_comparison(e2);
        }
#line 1141
        if (tmp___7) {
          {
#line 1142
          warning("suggest parentheses around comparison in operand of &");
          }
        }
      }
    }
    {
#line 1147
    tmp___8 = unsafe_comparison(result);
    }
#line 1147
    if (tmp___8) {
      {
#line 1147
      tmp___9 = unsafe_comparison(e1);
      }
#line 1147
      if (tmp___9) {
        {
#line 1149
        warning("comparisons like X<=Y<=Z do not have their mathematical meaning");
        }
      } else {
        {
#line 1147
        tmp___10 = unsafe_comparison(e2);
        }
#line 1147
        if (tmp___10) {
          {
#line 1149
          warning("comparisons like X<=Y<=Z do not have their mathematical meaning");
          }
        }
      }
    }
  }
#line 1158
  return (result);
}
}
#line 1161 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool voidstar_conditional(type t1 , type t2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 1163
  tmp___0 = type_void(t1);
  }
#line 1163
  if (tmp___0) {
#line 1165
    if (pedantic) {
      {
#line 1165
      tmp = type_function(t2);
      }
#line 1165
      if (tmp) {
        {
#line 1166
        pedwarn("ANSI C forbids conditional expr between `void *\' and function pointer");
        }
      }
    }
#line 1167
    return ((bool )1);
  }
#line 1169
  return ((bool )0);
}
}
#line 1172 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool pointerint_conditional(type t1 , type t2 , expression e2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 1174
  tmp___0 = type_pointer(t1);
  }
#line 1174
  if (tmp___0) {
    {
#line 1174
    tmp___1 = type_integer(t2);
    }
#line 1174
    if (tmp___1) {
      {
#line 1176
      tmp = definite_zero(e2);
      }
#line 1176
      if (! tmp) {
        {
#line 1177
        pedwarn("pointer/integer type mismatch in conditional expression");
        }
      }
#line 1178
      return ((bool )1);
    }
  }
#line 1180
  return ((bool )0);
}
}
#line 1183 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_conditional(location loc , expression cond , expression true , expression false ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  conditional tmp ;
  type ctype ;
  type ttype ;
  type ftype ;
  type rtype ;
  bool truelvalue ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  type tpointsto ;
  type tmp___5 ;
  type fpointsto ;
  type tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  type tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  bool tmp___23 ;
  bool tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  {
#line 1187
  tmp = new_conditional(parse_region, loc, cond, true, false);
#line 1187
  tEmPcast = (AST_generic )tmp;
  }
#line 1187
  if (tEmPcast) {
#line 1187
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1187
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1187
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1187U,
                      "make_conditional");
        }
      }
    } else {
      {
#line 1187
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1187U, "make_conditional");
      }
    }
  }
#line 1187
  result = (expression )tEmPcast;
#line 1188
  rtype = (type )((void *)0);
#line 1189
  if (true) {
#line 1189
    tmp___0 = (int )true->lvalue;
  } else {
#line 1189
    tmp___0 = 0;
  }
  {
#line 1189
  truelvalue = (bool )tmp___0;
#line 1191
  ctype = default_conversion(cond);
  }
#line 1193
  if (! true) {
#line 1195
    true = cond;
#line 1196
    truelvalue = (bool )0;
  }
  {
#line 1199
  tmp___1 = type_void(true->type);
  }
#line 1199
  if (tmp___1) {
#line 1200
    ttype = true->type;
  } else {
    {
#line 1202
    ttype = default_conversion(true);
    }
  }
  {
#line 1204
  tmp___2 = type_void(false->type);
  }
#line 1204
  if (tmp___2) {
#line 1205
    ftype = false->type;
  } else {
    {
#line 1207
    ftype = default_conversion(false);
    }
  }
#line 1209
  if ((unsigned long )ctype == (unsigned long )error_type) {
#line 1210
    rtype = error_type;
  } else
#line 1209
  if ((unsigned long )ttype == (unsigned long )error_type) {
#line 1210
    rtype = error_type;
  } else
#line 1209
  if ((unsigned long )ftype == (unsigned long )error_type) {
#line 1210
    rtype = error_type;
  } else {
    {
#line 1211
    tmp___24 = type_equal(ttype, ftype);
    }
#line 1211
    if (tmp___24) {
#line 1212
      rtype = ttype;
    } else {
      {
#line 1213
      tmp___23 = type_equal_unqualified(ttype, ftype);
      }
#line 1213
      if (tmp___23) {
        {
#line 1214
        rtype = make_qualified_type(ttype, (type_quals )0);
        }
      } else {
        {
#line 1215
        tmp___21 = type_real(ttype);
        }
#line 1215
        if (tmp___21) {
          {
#line 1215
          tmp___22 = type_real(ftype);
          }
#line 1215
          if (tmp___22) {
            {
#line 1217
            rtype = common_type(ttype, ftype);
            }
          } else {
#line 1215
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          {
#line 1218
          tmp___19 = type_void(ttype);
          }
#line 1218
          if (tmp___19) {
#line 1218
            goto _L___2;
          } else {
            {
#line 1218
            tmp___20 = type_void(ftype);
            }
#line 1218
            if (tmp___20) {
              _L___2: /* CIL Label */ 
#line 1220
              if (pedantic) {
                {
#line 1220
                tmp___3 = type_void(ttype);
                }
#line 1220
                if (tmp___3) {
                  {
#line 1220
                  tmp___4 = type_void(ftype);
                  }
#line 1220
                  if (! tmp___4) {
                    {
#line 1221
                    pedwarn("ANSI C forbids conditional expr with only one void side");
                    }
                  }
                } else {
                  {
#line 1221
                  pedwarn("ANSI C forbids conditional expr with only one void side");
                  }
                }
              }
#line 1222
              rtype = void_type;
            } else {
              {
#line 1224
              tmp___17 = type_pointer(ttype);
              }
#line 1224
              if (tmp___17) {
                {
#line 1224
                tmp___18 = type_pointer(ftype);
                }
#line 1224
                if (tmp___18) {
                  {
#line 1226
                  tmp___5 = type_points_to(ttype);
#line 1226
                  tpointsto = tmp___5;
#line 1226
                  tmp___6 = type_points_to(ftype);
#line 1226
                  fpointsto = tmp___6;
#line 1228
                  tmp___13 = compatible_pointer_types(ttype, ftype);
                  }
#line 1228
                  if (tmp___13) {
                    {
#line 1229
                    rtype = common_type(tpointsto, fpointsto);
                    }
                  } else {
                    {
#line 1230
                    tmp___11 = definite_null(true);
                    }
#line 1230
                    if (tmp___11) {
                      {
#line 1230
                      tmp___12 = type_void(tpointsto);
                      }
#line 1230
                      if (tmp___12) {
#line 1231
                        rtype = fpointsto;
                      } else {
#line 1230
                        goto _L___0;
                      }
                    } else {
                      _L___0: /* CIL Label */ 
                      {
#line 1232
                      tmp___9 = definite_null(false);
                      }
#line 1232
                      if (tmp___9) {
                        {
#line 1232
                        tmp___10 = type_void(fpointsto);
                        }
#line 1232
                        if (tmp___10) {
#line 1233
                          rtype = tpointsto;
                        } else {
#line 1232
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
                        {
#line 1234
                        tmp___8 = voidstar_conditional(tpointsto, fpointsto);
                        }
#line 1234
                        if (tmp___8) {
#line 1235
                          rtype = tpointsto;
                        } else {
                          {
#line 1236
                          tmp___7 = voidstar_conditional(fpointsto, tpointsto);
                          }
#line 1236
                          if (tmp___7) {
#line 1237
                            rtype = fpointsto;
                          } else {
                            {
#line 1240
                            pedwarn("pointer type mismatch in conditional expression");
#line 1243
                            rtype = void_type;
                            }
                          }
                        }
                      }
                    }
                  }
                  {
#line 1247
                  tmp___14 = qualify_type2(rtype, tpointsto, fpointsto);
#line 1247
                  rtype = make_pointer_type(tmp___14);
                  }
                } else {
#line 1224
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                {
#line 1249
                tmp___16 = pointerint_conditional(ttype, ftype, false);
                }
#line 1249
                if (tmp___16) {
#line 1250
                  rtype = ttype;
                } else {
                  {
#line 1251
                  tmp___15 = pointerint_conditional(ftype, ttype, true);
                  }
#line 1251
                  if (tmp___15) {
#line 1252
                    rtype = ftype;
                  } else
#line 1253
                  if (flag_cond_mismatch) {
#line 1254
                    rtype = void_type;
                  } else {
                    {
#line 1257
                    error("type mismatch in conditional expression");
#line 1258
                    rtype = error_type;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1262
  if ((unsigned long )rtype != (unsigned long )error_type) {
    {
#line 1263
    rtype = qualify_type2(rtype, ttype, ftype);
    }
  }
#line 1265
  result->type = rtype;
#line 1266
  if (! pedantic) {
#line 1266
    if (truelvalue) {
#line 1266
      if (false->lvalue) {
#line 1266
        tmp___25 = 1;
      } else {
#line 1266
        tmp___25 = 0;
      }
    } else {
#line 1266
      tmp___25 = 0;
    }
  } else {
#line 1266
    tmp___25 = 0;
  }
#line 1266
  result->lvalue = (bool )tmp___25;
#line 1267
  if (true->isregister) {
#line 1267
    tmp___26 = 1;
  } else
#line 1267
  if (false->isregister) {
#line 1267
    tmp___26 = 1;
  } else {
#line 1267
    tmp___26 = 0;
  }
#line 1267
  result->isregister = (bool )tmp___26;
#line 1268
  if (true->bitfield) {
#line 1268
    tmp___27 = 1;
  } else
#line 1268
  if (false->bitfield) {
#line 1268
    tmp___27 = 1;
  } else {
#line 1268
    tmp___27 = 0;
  }
  {
#line 1268
  result->bitfield = (bool )tmp___27;
#line 1269
  result->cst = fold_conditional(result);
  }
#line 1271
  return (result);
}
}
#line 1274 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_assign(location loc , int binop , expression e1 , expression e2 ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  binary tmp ;
  type t1 ;
  type tmp___0 ;
  type t2 ;
  expression rhs ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 1276
  tmp = newkind_binary(parse_region, (AST_kind )binop, loc, e1, e2);
#line 1276
  tEmPcast = (AST_generic )tmp;
  }
#line 1276
  if (tEmPcast) {
#line 1276
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1276
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1276
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1277U,
                      "make_assign");
        }
      }
    } else {
      {
#line 1276
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1277U, "make_assign");
      }
    }
  }
  {
#line 1276
  result = (expression )tEmPcast;
#line 1278
  tmp___0 = require_complete_type(e1, e1->type);
#line 1278
  t1 = tmp___0;
#line 1280
  result->type = error_type;
  }
#line 1281
  if ((unsigned long )t1 != (unsigned long )error_type) {
#line 1281
    if ((unsigned long )e2->type != (unsigned long )error_type) {
#line 1285
      if (binop == 116) {
        {
#line 1287
        t2 = default_conversion_for_assignment(e2);
#line 1288
        rhs = e2;
        }
      } else {
        {
#line 1292
        t2 = check_binary(binop, e1, e2);
#line 1293
        rhs = (expression )((void *)0);
        }
      }
      {
#line 1296
      tmp___1 = check_writable_lvalue(e1, (char *)"assignment");
      }
#line 1296
      if (tmp___1) {
        {
#line 1296
        tmp___2 = check_assignment(e1->type, t2, rhs, "assignment", (data_declaration )((void *)0),
                                   0);
        }
#line 1296
        if (tmp___2) {
          {
#line 1298
          result->type = make_qualified_type(e1->type, (type_quals )0);
          }
        }
      }
    }
  }
#line 1301
  return (result);
}
}
#line 1327 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool undeclared_variable_notice  ;
#line 1304 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_identifier(location loc , cstring id , bool maybe_implicit ) 
{ 
  data_declaration decl ;
  data_declaration tmp ;
  identifier result ;
  identifier tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  AST_generic tEmPcast ;
  int tmp___3 ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;

  {
  {
#line 1307
  tmp = lookup_id((char const   *)id.data, (bool )0);
#line 1307
  decl = tmp;
#line 1308
  tmp___0 = new_identifier(parse_region, loc, id, (data_declaration )((void *)0));
#line 1308
  result = tmp___0;
  }
#line 1310
  if (decl) {
#line 1310
    if (decl->islimbo) {
#line 1311
      decl = (data_declaration )((void *)0);
    }
  }
#line 1313
  if (! decl) {
#line 1313
    if (maybe_implicit) {
      {
#line 1314
      decl = implicitly_declare(result);
      }
    }
  }
#line 1316
  if (! decl) {
#line 1321
    if (! (current.env)->deputy_scope) {
#line 1323
      if (! current.function_decl) {
        {
#line 1324
        error("`%s\' undeclared here (not in a function)", id.data);
        }
      } else {
        {
#line 1325
        tmp___1 = env_lookup((current.function_decl)->undeclared_variables, (char const   *)id.data,
                             (bool )0);
        }
#line 1325
        if (! tmp___1) {
          {
#line 1329
          error("`%s\' undeclared (first use in this function)", id.data);
#line 1330
          env_add((current.function_decl)->undeclared_variables, (char const   *)id.data,
                  (void *)1);
          }
#line 1331
          if (! undeclared_variable_notice) {
            {
#line 1333
            error("(Each undeclared identifier is reported only once");
#line 1334
            error("for each function it appears in.)");
#line 1335
            undeclared_variable_notice = (bool )1;
            }
          }
        }
      }
    }
#line 1339
    decl = bad_decl;
  }
#line 1343
  result->type = decl->type;
#line 1344
  if ((unsigned int )decl->kind == 0U) {
#line 1344
    tmp___2 = 1;
  } else
#line 1344
  if ((unsigned int )decl->kind == 5U) {
#line 1344
    tmp___2 = 1;
  } else {
#line 1344
    tmp___2 = 0;
  }
#line 1344
  result->lvalue = (bool )tmp___2;
#line 1346
  tEmPcast = (AST_generic )result;
#line 1346
  if (tEmPcast) {
#line 1346
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1346
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1346
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1346U,
                      "make_identifier");
        }
      }
    } else {
      {
#line 1346
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1346U, "make_identifier");
      }
    }
  }
  {
#line 1346
  result->cst = fold_identifier((expression )tEmPcast, decl, 0);
  }
#line 1347
  if ((unsigned int )decl->kind == 0U) {
#line 1347
    if ((unsigned int )decl->vtype == 0U) {
#line 1347
      tmp___3 = 1;
    } else {
#line 1347
      tmp___3 = 0;
    }
  } else {
#line 1347
    tmp___3 = 0;
  }
#line 1347
  result->isregister = (bool )tmp___3;
#line 1349
  tEmPcast___0 = (AST_generic )result;
#line 1349
  if (tEmPcast___0) {
#line 1349
    if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 1349
      if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
        {
#line 1349
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1349U,
                      "make_identifier");
        }
      }
    } else {
      {
#line 1349
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1349U, "make_identifier");
      }
    }
  }
  {
#line 1349
  result->static_address = foldaddress_identifier((expression )tEmPcast___0, decl);
#line 1350
  result->ddecl = decl;
#line 1352
  tEmPcast___1 = (AST_generic )result;
  }
#line 1352
  if (tEmPcast___1) {
#line 1352
    if ((unsigned int )tEmPcast___1->kind >= 84U) {
#line 1352
      if (! ((unsigned int )tEmPcast___1->kind <= 156U)) {
        {
#line 1352
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1352U,
                      "make_identifier");
        }
      }
    } else {
      {
#line 1352
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1352U, "make_identifier");
      }
    }
  }
#line 1352
  return ((expression )tEmPcast___1);
}
}
#line 1355 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_compound_expr(location loc , statement block ) 
{ 
  expression tmp ;
  expression result ;
  AST_generic tEmPcast ;
  compound_expr tmp___0 ;
  compound_stmt bs ;
  AST_generic tEmPcast___0 ;
  statement last_stmt ;
  AST_generic tEmPcast___1 ;
  AST_generic tEmPcast___2 ;
  node tmp___1 ;
  AST_generic tEmPcast___3 ;

  {
#line 1357
  if ((unsigned int )block->kind >= 83U) {
#line 1357
    if ((unsigned int )block->kind <= 83U) {
      {
#line 1358
      tmp = make_error_expr();
      }
#line 1358
      return (tmp);
    } else {
#line 1357
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1361
    tmp___0 = new_compound_expr(parse_region, loc, block);
#line 1361
    tEmPcast = (AST_generic )tmp___0;
    }
#line 1361
    if (tEmPcast) {
#line 1361
      if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1361
        if (! ((unsigned int )tEmPcast->kind <= 156U)) {
          {
#line 1361
          __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1361U,
                        "make_compound_expr");
          }
        }
      } else {
        {
#line 1361
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1361U,
                      "make_compound_expr");
        }
      }
    }
#line 1361
    result = (expression )tEmPcast;
#line 1362
    tEmPcast___0 = (AST_generic )block;
#line 1362
    if (tEmPcast___0) {
#line 1362
      if ((unsigned int )tEmPcast___0->kind >= 67U) {
#line 1362
        if (! ((unsigned int )tEmPcast___0->kind <= 67U)) {
          {
#line 1362
          __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1362U,
                        "make_compound_expr");
          }
        }
      } else {
        {
#line 1362
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1362U,
                      "make_compound_expr");
        }
      }
    }
#line 1362
    bs = (compound_stmt )tEmPcast___0;
#line 1363
    tEmPcast___2 = (AST_generic )bs->stmts;
#line 1363
    if (tEmPcast___2) {
#line 1363
      if ((unsigned int )tEmPcast___2->kind >= 42U) {
#line 1363
        if (! ((unsigned int )tEmPcast___2->kind <= 199U)) {
          {
#line 1363
          __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1363U,
                        "make_compound_expr");
          }
        }
      } else {
        {
#line 1363
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1363U,
                      "make_compound_expr");
        }
      }
    }
    {
#line 1363
    tmp___1 = AST_node_last((node )tEmPcast___2);
#line 1363
    tEmPcast___1 = (AST_generic )tmp___1;
    }
#line 1363
    if (tEmPcast___1) {
#line 1363
      if ((unsigned int )tEmPcast___1->kind >= 65U) {
#line 1363
        if (! ((unsigned int )tEmPcast___1->kind <= 83U)) {
          {
#line 1363
          __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1363U,
                        "make_compound_expr");
          }
        }
      } else {
        {
#line 1363
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1363U,
                      "make_compound_expr");
        }
      }
    }
#line 1363
    last_stmt = (statement )tEmPcast___1;
#line 1365
    if (last_stmt) {
#line 1365
      if ((unsigned int )last_stmt->kind >= 70U) {
#line 1365
        if ((unsigned int )last_stmt->kind <= 70U) {
#line 1366
          tEmPcast___3 = (AST_generic )last_stmt;
#line 1366
          if (tEmPcast___3) {
#line 1366
            if ((unsigned int )tEmPcast___3->kind >= 70U) {
#line 1366
              if (! ((unsigned int )tEmPcast___3->kind <= 70U)) {
                {
#line 1366
                __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c",
                              1366U, "make_compound_expr");
                }
              }
            } else {
              {
#line 1366
              __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1366U,
                            "make_compound_expr");
              }
            }
          }
#line 1366
          result->type = (((expression_stmt )tEmPcast___3)->arg1)->type;
        } else {
#line 1368
          result->type = void_type;
        }
      } else {
#line 1368
        result->type = void_type;
      }
    } else {
#line 1368
      result->type = void_type;
    }
#line 1370
    return (result);
  }
}
}
#line 1374 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
bool check_arguments(type fntype , expression arglist , data_declaration fundecl ,
                     bool generic_call___0 ) 
{ 
  typelist_scanner parmtypes ;
  int parmstep ;
  int tmp ;
  int parmnum ;
  type parmtype ;
  char const   *argname ;
  int old_errorcount ;
  typelist tmp___0 ;
  type argtype___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  type tmp___11 ;
  bool tmp___12 ;
  AST_generic tEmPcast ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  type tmp___17 ;
  AST_generic tEmPcast___0 ;

  {
#line 1378
  if (generic_call___0) {
#line 1378
    tmp = -1;
  } else {
#line 1378
    tmp = 1;
  }
  {
#line 1378
  parmstep = tmp;
#line 1378
  parmnum = parmstep;
#line 1381
  old_errorcount = errorcount;
#line 1383
  tmp___16 = type_function_oldstyle(fntype);
  }
#line 1383
  if (! tmp___16) {
    {
#line 1385
    tmp___0 = type_function_arguments(fntype);
#line 1385
    typelist_scan(tmp___0, & parmtypes);
    }
    {
#line 1387
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1387
      parmtype = typelist_next(& parmtypes);
      }
#line 1387
      if (parmtype) {
#line 1387
        if (! arglist) {
#line 1387
          goto while_break;
        }
      } else {
#line 1387
        goto while_break;
      }
      {
#line 1389
      argtype___0 = arglist->type;
#line 1391
      tmp___12 = type_incomplete(parmtype);
      }
#line 1391
      if (tmp___12) {
        {
#line 1392
        error("type of formal parameter %d is incomplete", parmnum);
        }
      } else {
#line 1395
        if (warn_conversion) {
          {
#line 1397
          tmp___9 = type_integer(parmtype);
          }
#line 1397
          if (tmp___9) {
            {
#line 1397
            tmp___10 = type_floating(argtype___0);
            }
#line 1397
            if (tmp___10) {
              {
#line 1398
              warn_for_assignment("%s as integer rather than floating due to prototype",
                                  (char const   *)((void *)0), fundecl, parmnum);
              }
            } else {
#line 1397
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            {
#line 1400
            tmp___7 = type_floating(parmtype);
            }
#line 1400
            if (tmp___7) {
              {
#line 1400
              tmp___8 = type_integer(argtype___0);
              }
#line 1400
              if (tmp___8) {
                {
#line 1401
                warn_for_assignment("%s as floating rather than integer due to prototype",
                                    (char const   *)((void *)0), fundecl, parmnum);
                }
              } else {
#line 1400
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 1403
              tmp___5 = type_complex(parmtype);
              }
#line 1403
              if (tmp___5) {
                {
#line 1403
                tmp___6 = type_floating(argtype___0);
                }
#line 1403
                if (tmp___6) {
                  {
#line 1404
                  warn_for_assignment("%s as complex rather than floating due to prototype",
                                      (char const   *)((void *)0), fundecl, parmnum);
                  }
                } else {
#line 1403
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 1406
                tmp___3 = type_floating(parmtype);
                }
#line 1406
                if (tmp___3) {
                  {
#line 1406
                  tmp___4 = type_complex(argtype___0);
                  }
#line 1406
                  if (tmp___4) {
                    {
#line 1407
                    warn_for_assignment("%s as floating rather than complex due to prototype",
                                        (char const   *)((void *)0), fundecl, parmnum);
                    }
                  } else {
#line 1406
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 1411
                  tmp___1 = type_float(parmtype);
                  }
#line 1411
                  if (tmp___1) {
                    {
#line 1411
                    tmp___2 = type_floating(argtype___0);
                    }
#line 1411
                    if (tmp___2) {
                      {
#line 1412
                      warn_for_assignment("%s as `float\' rather than `double\' due to prototype",
                                          (char const   *)((void *)0), fundecl, parmnum);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 1429
        tmp___11 = default_conversion_for_assignment(arglist);
#line 1429
        check_assignment(parmtype, tmp___11, arglist, (char const   *)((void *)0),
                         fundecl, parmnum);
        }
      }
#line 1432
      parmnum += parmstep;
#line 1433
      tEmPcast = (AST_generic )arglist->next;
#line 1433
      if (tEmPcast) {
#line 1433
        if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1433
          if (! ((unsigned int )tEmPcast->kind <= 156U)) {
            {
#line 1433
            __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1433U,
                          "check_arguments");
            }
          }
        } else {
          {
#line 1433
          __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1433U,
                        "check_arguments");
          }
        }
      }
#line 1433
      arglist = (expression )tEmPcast;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1435
    argname = argtype(& parmstep);
    }
#line 1436
    if (parmtype) {
#line 1438
      if (fundecl) {
        {
#line 1439
        tmp___13 = decl_printname(fundecl);
#line 1439
        error("too few %ss to function `%s\'", argname, tmp___13);
        }
      } else {
        {
#line 1442
        error("too few %ss to function", argname);
        }
      }
    } else
#line 1444
    if (arglist) {
      {
#line 1444
      tmp___15 = type_function_varargs(fntype);
      }
#line 1444
      if (! tmp___15) {
#line 1446
        if (fundecl) {
          {
#line 1447
          tmp___14 = decl_printname(fundecl);
#line 1447
          error("too many %ss to function `%s\'", argname, tmp___14);
          }
        } else {
          {
#line 1450
          error("too many %ss to function", argname);
          }
        }
      }
    }
  }
  {
#line 1455
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1455
    if (! arglist) {
#line 1455
      goto while_break___0;
    }
    {
#line 1457
    tmp___17 = default_conversion(arglist);
#line 1457
    require_complete_type(arglist, tmp___17);
#line 1458
    tEmPcast___0 = (AST_generic )arglist->next;
    }
#line 1458
    if (tEmPcast___0) {
#line 1458
      if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 1458
        if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
          {
#line 1458
          __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1458U,
                        "check_arguments");
          }
        }
      } else {
        {
#line 1458
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1458U,
                      "check_arguments");
        }
      }
    }
#line 1458
    arglist = (expression )tEmPcast___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1461
  return ((bool )(errorcount == old_errorcount));
}
}
#line 1464 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_function_call(location loc , expression fn , expression arglist ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  function_call tmp ;
  type fntype ;
  type tmp___0 ;
  type rettype ;
  bool argumentsok ;
  AST_generic tEmPcast___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  data_declaration tmp___4 ;
  bool tmp___5 ;

  {
  {
#line 1466
  tmp = new_function_call(parse_region, loc, fn, arglist, (asttype )((void *)0), (nesc_call_kind )3);
#line 1466
  tEmPcast = (AST_generic )tmp;
  }
#line 1466
  if (tEmPcast) {
#line 1466
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1466
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1466
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1466U,
                      "make_function_call");
        }
      }
    } else {
      {
#line 1466
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1466U, "make_function_call");
      }
    }
  }
  {
#line 1466
  result = (expression )tEmPcast;
#line 1467
  tmp___0 = default_conversion(fn);
#line 1467
  fntype = tmp___0;
#line 1470
  result->type = error_type;
  }
#line 1471
  if ((unsigned long )fntype == (unsigned long )error_type) {
#line 1472
    return (result);
  }
#line 1475
  if ((unsigned int )fn->kind >= 146U) {
#line 1475
    if ((unsigned int )fn->kind <= 146U) {
#line 1475
      tEmPcast___0 = (AST_generic )fn;
#line 1475
      if (tEmPcast___0) {
#line 1475
        if ((unsigned int )tEmPcast___0->kind >= 146U) {
#line 1475
          if (! ((unsigned int )tEmPcast___0->kind <= 146U)) {
            {
#line 1475
            __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1475U,
                          "make_function_call");
            }
          }
        } else {
          {
#line 1475
          __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1475U,
                        "make_function_call");
          }
        }
      }
#line 1475
      if ((unsigned long )((identifier )tEmPcast___0)->ddecl == (unsigned long )enable_interrupt) {
#line 1477
        ((current.function_decl)->ddecl)->extra_contexts = (call_contexts )((unsigned int )((current.function_decl)->ddecl)->extra_contexts | 2U);
#line 1478
        if (current.in_atomic) {
          {
#line 1479
          warning("call to __nesc_enable_interrupt within an atomic statement");
          }
        }
      }
    }
  }
  {
#line 1482
  tmp___1 = type_pointer(fntype);
  }
#line 1482
  if (tmp___1) {
    {
#line 1485
    fntype = type_points_to(fntype);
    }
  }
  {
#line 1487
  tmp___3 = type_functional(fntype);
  }
#line 1487
  if (! tmp___3) {
    {
#line 1489
    tmp___2 = type_generic(fntype);
    }
#line 1489
    if (tmp___2) {
      {
#line 1490
      error("parameters missing in call to parameterised command or event");
      }
    } else {
      {
#line 1492
      error("called object is not a function, command, event or task");
      }
    }
#line 1493
    return (result);
  }
  {
#line 1496
  tmp___4 = get_function_ddecl(fn);
#line 1496
  argumentsok = check_arguments(fntype, arglist, tmp___4, (bool )0);
#line 1498
  rettype = type_function_return_type(fntype);
#line 1499
  result->type = rettype;
#line 1500
  tmp___5 = type_void(rettype);
  }
#line 1500
  if (! tmp___5) {
    {
#line 1501
    result->type = require_complete_type(result, rettype);
    }
  }
#line 1503
  if (argumentsok) {
    {
#line 1504
    result->cst = fold_function_call(result, 0);
    }
  }
#line 1506
  return (result);
}
}
#line 1519 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static bool gave_help  ;
#line 1509 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_va_arg(location loc , expression arg , asttype type___0 ) 
{ 
  expression va_arg_id ;
  expression tmp ;
  expression result ;
  AST_generic tEmPcast ;
  function_call tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 1511
  tmp = build_identifier(parse_region, loc, builtin_va_arg_decl);
#line 1511
  va_arg_id = tmp;
#line 1512
  tmp___0 = new_function_call(parse_region, loc, va_arg_id, arg, type___0, (nesc_call_kind )3);
#line 1512
  tEmPcast = (AST_generic )tmp___0;
  }
#line 1512
  if (tEmPcast) {
#line 1512
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1512
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1512
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1512U,
                      "make_va_arg");
        }
      }
    } else {
      {
#line 1512
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1512U, "make_va_arg");
      }
    }
  }
  {
#line 1512
  result = (expression )tEmPcast;
#line 1514
  tmp___1 = type_equal_unqualified(arg->type, builtin_va_list_type);
  }
#line 1514
  if (! tmp___1) {
    {
#line 1515
    error("first argument to `va_arg\' not of type `va_list\'");
    }
  }
  {
#line 1517
  tmp___2 = type_self_promoting(type___0->type);
  }
#line 1517
  if (! tmp___2) {
    {
#line 1521
    error("char, short and float are automatically promoted when passed through `...\'");
    }
#line 1522
    if (! gave_help) {
      {
#line 1524
      gave_help = (bool )1;
#line 1525
      error("(so you should pass `int\', `unsigned\' or `double\' to `va_arg\')");
      }
    }
  }
#line 1528
  result->type = type___0->type;
#line 1530
  return (result);
}
}
#line 1533 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_offsetof(location loc , asttype t , dd_list fields ) 
{ 
  expression zero ;
  AST_generic tEmPcast ;
  cstring tmp ;
  lexical_cst tmp___0 ;
  declarator ptr_to_t_d ;
  expression cast___0 ;
  expression fieldref ;
  expression addrof ;
  declarator size_t_d ;
  type_element size_t_m ;
  asttype size_t_ast ;
  dd_list_pos field ;
  AST_generic tEmPcast___0 ;
  pointer_declarator tmp___1 ;
  cstring f ;
  size_t tmp___2 ;
  expression tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
  {
#line 1537
  tmp = str2cstring(parse_region, "0");
#line 1537
  tmp___0 = fold_lexical_int(size_t_type, loc, tmp, (bool )0, (largest_uint )0, (bool )0);
#line 1537
  tEmPcast = (AST_generic )tmp___0;
  }
#line 1537
  if (tEmPcast) {
#line 1537
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1537
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1537
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1538U,
                      "make_offsetof");
        }
      }
    } else {
      {
#line 1537
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1538U, "make_offsetof");
      }
    }
  }
#line 1537
  zero = (expression )tEmPcast;
#line 1540
  if ((unsigned long )t->type == (unsigned long )error_type) {
#line 1540
    goto _L;
  } else {
    {
#line 1540
    tmp___4 = type_struct(t->type);
    }
#line 1540
    if (tmp___4) {
#line 1540
      goto _L;
    } else {
      {
#line 1540
      tmp___5 = type_union(t->type);
      }
#line 1540
      if (tmp___5) {
        _L: /* CIL Label */ 
        {
#line 1555
        tmp___1 = new_pointer_declarator(parse_region, loc, t->declarator);
#line 1555
        tEmPcast___0 = (AST_generic )tmp___1;
        }
#line 1555
        if (tEmPcast___0) {
#line 1555
          if ((unsigned int )tEmPcast___0->kind >= 175U) {
#line 1555
            if (! ((unsigned int )tEmPcast___0->kind <= 183U)) {
              {
#line 1555
              __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1556U,
                            "make_offsetof");
              }
            }
          } else {
            {
#line 1555
            __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1556U,
                          "make_offsetof");
            }
          }
        }
        {
#line 1555
        ptr_to_t_d = (declarator )tEmPcast___0;
#line 1557
        t = make_type(t->qualifiers, ptr_to_t_d);
#line 1558
        cast___0 = make_cast(loc, t, zero);
#line 1559
        fieldref = make_dereference(loc, cast___0);
#line 1560
        field = dd_first(fields);
        }
        {
#line 1560
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1560
          if (! (! (! field->next))) {
#line 1560
            goto while_break;
          }
          {
#line 1564
          f.data = (char *)field->data;
#line 1565
          tmp___2 = strlen((char const   *)f.data);
#line 1565
          f.length = (int )tmp___2;
#line 1566
          fieldref = make_field_ref(loc, fieldref, f);
#line 1560
          field = field->next;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1568
        addrof = make_unary(loc, 101, fieldref);
#line 1570
        type2ast(parse_region, loc, size_t_type, (declarator )((void *)0), & size_t_d,
                 & size_t_m);
#line 1571
        size_t_ast = make_type(size_t_m, size_t_d);
#line 1573
        tmp___3 = make_cast(loc, size_t_ast, addrof);
        }
#line 1573
        return (tmp___3);
      } else {
        {
#line 1542
        error("offsetof is only valid for structs or unions");
        }
#line 1543
        return (zero);
      }
    }
  }
}
}
#line 1577 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_array_ref(location loc , expression array , expression index___0 ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  array_ref tmp ;
  type atype ;
  type itype ;
  expression tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  type tmp___3 ;
  bool tmp___4 ;
  type temp ;
  bool tmp___5 ;
  bool tmp___6 ;
  type tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 1579
  tmp = new_array_ref(parse_region, loc, array, index___0);
#line 1579
  tEmPcast = (AST_generic )tmp;
  }
#line 1579
  if (tEmPcast) {
#line 1579
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1579
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1579
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1579U,
                      "make_array_ref");
        }
      }
    } else {
      {
#line 1579
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1579U, "make_array_ref");
      }
    }
  }
  {
#line 1579
  result = (expression )tEmPcast;
#line 1582
  tmp___1 = type_generic(array->type);
  }
#line 1582
  if (tmp___1) {
    {
#line 1583
    tmp___0 = make_generic_call(loc, array, index___0);
    }
#line 1583
    return (tmp___0);
  }
  {
#line 1585
  itype = default_conversion(index___0);
  }
#line 1586
  if (index___0->next) {
    {
#line 1587
    index___0 = make_comma(index___0->location, index___0);
    }
  }
#line 1589
  if (warn_char_subscripts) {
    {
#line 1589
    tmp___2 = type_plain_char(index___0->type);
    }
#line 1589
    if (tmp___2) {
      {
#line 1590
      warning("subscript has type `char\'");
      }
    }
  }
  {
#line 1592
  tmp___4 = type_array(array->type);
  }
#line 1592
  if (tmp___4) {
#line 1592
    if (! array->lvalue) {
#line 1597
      if (pedantic) {
        {
#line 1598
        pedwarn("ANSI C forbids subscripting non-lvalue array");
        }
      }
      {
#line 1599
      tmp___3 = type_array_of(array->type);
#line 1599
      atype = make_pointer_type(tmp___3);
      }
#line 1603
      if (! (! array->static_address)) {
        {
#line 1603
        __assert_fail("!array->static_address", "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c",
                      1603U, "make_array_ref");
        }
      }
    } else {
      {
#line 1606
      atype = default_conversion(array);
      }
    }
  } else {
    {
#line 1606
    atype = default_conversion(array);
    }
  }
  {
#line 1609
  tmp___5 = type_integer(atype);
  }
#line 1609
  if (tmp___5) {
#line 1611
    temp = atype;
#line 1612
    atype = itype;
#line 1613
    itype = temp;
  }
  {
#line 1616
  tmp___6 = type_pointer(atype);
  }
#line 1616
  if (tmp___6) {
    {
#line 1616
    tmp___7 = type_points_to(atype);
#line 1616
    tmp___8 = type_function(tmp___7);
    }
#line 1616
    if (tmp___8) {
      {
#line 1618
      error("subscripted value is neither array nor pointer");
#line 1619
      result->type = error_type;
#line 1620
      result->lvalue = (bool )1;
      }
    } else {
      {
#line 1624
      check_dereference(result, atype, "array indexing");
#line 1625
      result->static_address = fold_binary(atype, result);
      }
    }
  } else {
    {
#line 1618
    error("subscripted value is neither array nor pointer");
#line 1619
    result->type = error_type;
#line 1620
    result->lvalue = (bool )1;
    }
  }
  {
#line 1628
  tmp___9 = type_integer(itype);
  }
#line 1628
  if (! tmp___9) {
#line 1628
    if ((unsigned long )itype != (unsigned long )error_type) {
      {
#line 1629
      error("array subscript is not an integer");
      }
    }
  }
#line 1631
  return (result);
}
}
#line 1634 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_field_ref(location loc , expression object , cstring field ) 
{ 
  type otype ;
  field_ref result ;
  expression tmp ;
  bool tmp___0 ;
  expression tmp___1 ;
  bool tmp___2 ;
  tag_declaration tag ;
  tag_declaration tmp___3 ;
  field_declaration fdecl ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  AST_generic tEmPcast ;
  bool tmp___6 ;
  AST_generic tEmPcast___0 ;

  {
  {
#line 1636
  otype = object->type;
#line 1639
  tmp___0 = type_interface(otype);
  }
#line 1639
  if (tmp___0) {
    {
#line 1640
    tmp = make_interface_deref(loc, object, field);
    }
#line 1640
    return (tmp);
  }
  {
#line 1641
  tmp___2 = type_component(otype);
  }
#line 1641
  if (tmp___2) {
    {
#line 1642
    tmp___1 = make_component_deref(loc, object, field);
    }
#line 1642
    return (tmp___1);
  }
  {
#line 1644
  result = new_field_ref(parse_region, loc, object, field);
#line 1645
  result->type = error_type;
#line 1647
  tmp___6 = type_aggregate(otype);
  }
#line 1647
  if (tmp___6) {
    {
#line 1649
    tmp___3 = type_tag(otype);
#line 1649
    tag = tmp___3;
    }
#line 1651
    if (! tag->defined) {
      {
#line 1652
      incomplete_type_error((expression )((void *)0), otype);
      }
    } else {
      {
#line 1655
      tmp___4 = env_lookup(tag->fields, (char const   *)field.data, (bool )0);
#line 1655
      fdecl = (field_declaration )tmp___4;
      }
#line 1657
      if (! fdecl) {
        {
#line 1658
        tmp___5 = tagkind_name(tag->kind);
#line 1658
        error("%s has no member named `%s\'", tmp___5, field.data);
        }
      } else {
        {
#line 1662
        result->fdecl = fdecl;
#line 1663
        result->type = qualify_type2(fdecl->type, fdecl->type, object->type);
#line 1664
        result->bitfield = (bool )(! ((unsigned int )fdecl->bitwidth.kind == 0U));
#line 1665
        tEmPcast = (AST_generic )result;
        }
#line 1665
        if (tEmPcast) {
#line 1665
          if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1665
            if (! ((unsigned int )tEmPcast->kind <= 156U)) {
              {
#line 1665
              __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1665U,
                            "make_field_ref");
              }
            }
          } else {
            {
#line 1665
            __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1665U,
                          "make_field_ref");
            }
          }
        }
        {
#line 1665
        result->static_address = foldaddress_field_ref((expression )tEmPcast);
        }
      }
    }
  } else
#line 1669
  if ((unsigned long )otype != (unsigned long )error_type) {
    {
#line 1670
    error("request for member `%s\' in something not a structure or union", field.data);
    }
  }
#line 1673
  result->lvalue = object->lvalue;
#line 1675
  tEmPcast___0 = (AST_generic )result;
#line 1675
  if (tEmPcast___0) {
#line 1675
    if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 1675
      if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
        {
#line 1675
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1675U,
                      "make_field_ref");
        }
      }
    } else {
      {
#line 1675
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1675U, "make_field_ref");
      }
    }
  }
#line 1675
  return ((expression )tEmPcast___0);
}
}
#line 1678 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
static expression finish_increment(unary result , char *name ) 
{ 
  expression e ;
  type etype ;
  bool tmp ;
  type tmp___0 ;
  bool tmp___1 ;
  type tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  AST_generic tEmPcast ;

  {
  {
#line 1680
  e = result->arg1;
#line 1681
  etype = e->type;
#line 1683
  result->type = error_type;
#line 1685
  tmp___6 = type_scalar(etype);
  }
#line 1685
  if (tmp___6) {
    {
#line 1689
    tmp___4 = type_incomplete(etype);
    }
#line 1689
    if (tmp___4) {
      {
#line 1690
      error("%s of pointer to unknown structure or union", name);
      }
    } else {
      {
#line 1691
      tmp = type_pointer(etype);
      }
#line 1691
      if (tmp) {
#line 1691
        if (pedantic) {
#line 1691
          goto _L;
        } else
#line 1691
        if (warn_pointer_arith) {
          _L: /* CIL Label */ 
          {
#line 1691
          tmp___0 = type_points_to(etype);
#line 1691
          tmp___1 = type_void(tmp___0);
          }
#line 1691
          if (tmp___1) {
            {
#line 1694
            pedwarn("wrong type argument to %s", name);
            }
          } else {
            {
#line 1691
            tmp___2 = type_points_to(etype);
#line 1691
            tmp___3 = type_function(tmp___2);
            }
#line 1691
            if (tmp___3) {
              {
#line 1694
              pedwarn("wrong type argument to %s", name);
              }
            }
          }
        }
      }
    }
    {
#line 1696
    tmp___5 = check_writable_lvalue(e, name);
    }
#line 1696
    if (tmp___5) {
#line 1697
      result->type = etype;
    }
  } else {
    {
#line 1686
    error("wrong type argument to %s", name);
    }
  }
#line 1699
  tEmPcast = (AST_generic )result;
#line 1699
  if (tEmPcast) {
#line 1699
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 1699
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 1699
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1699U,
                      "finish_increment");
        }
      }
    } else {
      {
#line 1699
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1699U, "finish_increment");
      }
    }
  }
#line 1699
  return ((expression )tEmPcast);
}
}
#line 1702 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_postincrement(location loc , expression e ) 
{ 
  AST_generic tEmPcast ;
  postincrement tmp ;
  expression tmp___0 ;

  {
  {
#line 1704
  tmp = new_postincrement(parse_region, loc, e);
#line 1704
  tEmPcast = (AST_generic )tmp;
  }
#line 1704
  if (tEmPcast) {
#line 1704
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 1704
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 1704
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1704U,
                      "make_postincrement");
        }
      }
    } else {
      {
#line 1704
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1704U, "make_postincrement");
      }
    }
  }
  {
#line 1704
  tmp___0 = finish_increment((unary )tEmPcast, (char *)"increment");
  }
#line 1704
  return (tmp___0);
}
}
#line 1708 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_preincrement(location loc , expression e ) 
{ 
  AST_generic tEmPcast ;
  preincrement tmp ;
  expression tmp___0 ;

  {
  {
#line 1710
  tmp = new_preincrement(parse_region, loc, e);
#line 1710
  tEmPcast = (AST_generic )tmp;
  }
#line 1710
  if (tEmPcast) {
#line 1710
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 1710
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 1710
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1710U,
                      "make_preincrement");
        }
      }
    } else {
      {
#line 1710
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1710U, "make_preincrement");
      }
    }
  }
  {
#line 1710
  tmp___0 = finish_increment((unary )tEmPcast, (char *)"increment");
  }
#line 1710
  return (tmp___0);
}
}
#line 1714 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_postdecrement(location loc , expression e ) 
{ 
  AST_generic tEmPcast ;
  postdecrement tmp ;
  expression tmp___0 ;

  {
  {
#line 1716
  tmp = new_postdecrement(parse_region, loc, e);
#line 1716
  tEmPcast = (AST_generic )tmp;
  }
#line 1716
  if (tEmPcast) {
#line 1716
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 1716
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 1716
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1716U,
                      "make_postdecrement");
        }
      }
    } else {
      {
#line 1716
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1716U, "make_postdecrement");
      }
    }
  }
  {
#line 1716
  tmp___0 = finish_increment((unary )tEmPcast, (char *)"decrement");
  }
#line 1716
  return (tmp___0);
}
}
#line 1720 "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c"
expression make_predecrement(location loc , expression e ) 
{ 
  AST_generic tEmPcast ;
  predecrement tmp ;
  expression tmp___0 ;

  {
  {
#line 1722
  tmp = new_predecrement(parse_region, loc, e);
#line 1722
  tEmPcast = (AST_generic )tmp;
  }
#line 1722
  if (tEmPcast) {
#line 1722
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 1722
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 1722
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1722U,
                      "make_predecrement");
        }
      }
    } else {
      {
#line 1722
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/expr.c", 1722U, "make_predecrement");
      }
    }
  }
  {
#line 1722
  tmp___0 = finish_increment((unary )tEmPcast, (char *)"decrement");
  }
#line 1722
  return (tmp___0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 550
extern int getc_unlocked(FILE *__stream ) ;
#line 602
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 737
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 739
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/system.h"
extern int fputs_unlocked(char const   * , FILE * ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 67 "./../include/libiberty.h"
extern FILE *fopen_unlocked(char const   * , char const   * ) ;
#line 68
extern FILE *fdopen_unlocked(int  , char const   * ) ;
#line 116
extern char const   *lbasename(char const   * ) ;
#line 285
extern void *xmalloc(size_t  )  __attribute__((__malloc__)) ;
#line 291
extern void *xrealloc(void * , size_t  ) ;
#line 296
extern void *xcalloc(size_t  , size_t  )  __attribute__((__malloc__)) ;
#line 300
extern char *xstrdup(char const   * )  __attribute__((__malloc__)) ;
#line 89 "./../include/safe-ctype.h"
extern unsigned short const   _sch_istable[256] ;
#line 191 "./../include/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 193
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 210
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 636 "./include/cpplib.h"
void cpp_set_include_chains(cpp_reader *pfile , cpp_dir *quote , cpp_dir *bracket ,
                            int quote_ignores_source_dir ) ;
#line 643
extern cpp_options *cpp_get_options(cpp_reader * ) ;
#line 728
extern cpp_buffer *cpp_push_buffer(cpp_reader * , unsigned char const   * , size_t  ,
                                   int  ) ;
#line 813
extern void ( /* format attribute */ __attribute__((__nonnull__(3))) cpp_error)(cpp_reader * ,
                                                                                int  ,
                                                                                char const   *msgid 
                                                                                , ...) ;
#line 818
extern void cpp_errno(cpp_reader * , int  , char const   *msgid ) ;
#line 856
unsigned char cpp_included(cpp_reader *pfile , char const   *fname ) ;
#line 857
unsigned char cpp_included_before(cpp_reader *pfile , char const   *fname , source_location location ) ;
#line 858
void cpp_make_system_header(cpp_reader *pfile , int syshdr , int externc ) ;
#line 859
unsigned char cpp_push_include(cpp_reader *pfile , char const   *fname ) ;
#line 860
void cpp_change_file(cpp_reader *pfile , enum lc_reason reason , char const   *new_name ) ;
#line 861
char const   *cpp_get_path(struct _cpp_file *f ) ;
#line 862
cpp_dir *cpp_get_dir(struct _cpp_file *f ) ;
#line 863
cpp_buffer *cpp_get_buffer(cpp_reader *pfile ) ;
#line 864
struct _cpp_file *cpp_get_file(cpp_buffer *b ) ;
#line 865
cpp_buffer *cpp_get_prev(cpp_buffer *b ) ;
#line 866
void cpp_clear_file_cache(cpp_reader *pfile ) ;
#line 537 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/internal.h"
_cpp_file *_cpp_find_file(cpp_reader *pfile , char const   *fname , cpp_dir *start_dir ,
                          unsigned char fake , int angle_brackets ) ;
#line 539
unsigned char _cpp_find_failed(_cpp_file *file ) ;
#line 540
void _cpp_mark_file_once_only(cpp_reader *pfile , struct _cpp_file *file ) ;
#line 541
void _cpp_fake_include(cpp_reader *pfile , char const   *fname ) ;
#line 542
unsigned char _cpp_stack_file(cpp_reader *pfile , _cpp_file *file , unsigned char import ) ;
#line 543
unsigned char _cpp_stack_include(cpp_reader *pfile , char const   *fname , int angle_brackets ,
                                 enum include_type type ) ;
#line 545
int _cpp_compare_file_date(cpp_reader *pfile , char const   *fname , int angle_brackets ) ;
#line 546
void _cpp_report_missing_guards(cpp_reader *pfile ) ;
#line 547
void _cpp_init_files(cpp_reader *pfile ) ;
#line 548
void _cpp_cleanup_files(cpp_reader *pfile ) ;
#line 549
void _cpp_pop_file_buffer(cpp_reader *pfile , struct _cpp_file *file ) ;
#line 550
unsigned char _cpp_save_file_entries(cpp_reader *pfile , FILE *fp ) ;
#line 551
unsigned char _cpp_read_file_entries(cpp_reader *pfile  __attribute__((__unused__)) ,
                                     FILE *f ) ;
#line 552
struct stat *_cpp_get_file_stat(_cpp_file *file ) ;
#line 581
extern void _cpp_do_file_change(cpp_reader * , enum lc_reason  , char const   * ,
                                unsigned int  , unsigned int  ) ;
#line 636
extern unsigned char *_cpp_convert_input(cpp_reader * , char const   * , unsigned char * ,
                                         size_t  , size_t  , off_t * ) ;
#line 56 "./include/mkdeps.h"
extern void deps_add_dep(struct deps * , char const   * ) ;
#line 151 "./../include/hashtab.h"
extern htab_t htab_create_alloc(size_t  , hashval_t (*)(void const   * ) , int (*)(void const   * ,
                                                                                   void const   * ) ,
                                void (*)(void * ) , void *(*)(size_t  , size_t  ) ,
                                void (*)(void * ) ) ;
#line 169
extern void htab_delete(htab_t  ) ;
#line 174
extern void *htab_find_with_hash(htab_t  , void const   * , hashval_t  ) ;
#line 175
extern void **htab_find_slot_with_hash(htab_t  , void const   * , hashval_t  , enum insert_option  ) ;
#line 181
extern void htab_traverse(htab_t  , int (*)(void ** , void * ) , void * ) ;
#line 195
extern hashval_t htab_hash_string(void const   * ) ;
#line 133 "./../include/md5.h"
extern int md5_stream(FILE *stream , void *resblock ) ;
#line 139
extern void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 168 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char open_file(_cpp_file *file ) ;
#line 169
static unsigned char pch_open_file(cpp_reader *pfile , _cpp_file *file , unsigned char *invalid_pch ) ;
#line 171
static unsigned char find_file_in_dir(cpp_reader *pfile , _cpp_file *file , unsigned char *invalid_pch ) ;
#line 173
static unsigned char read_file_guts(cpp_reader *pfile , _cpp_file *file ) ;
#line 174
static unsigned char read_file(cpp_reader *pfile , _cpp_file *file ) ;
#line 175
static unsigned char should_stack_file(cpp_reader *pfile , _cpp_file *file , unsigned char import ) ;
#line 176
static struct cpp_dir *search_path_head(cpp_reader *pfile , char const   *fname ,
                                        int angle_brackets , enum include_type type ) ;
#line 178
static char const   *dir_name_of_file(_cpp_file *file ) ;
#line 179
static void open_file_failed(cpp_reader *pfile , _cpp_file *file , int angle_brackets ) ;
#line 180
static struct file_hash_entry *search_cache(struct file_hash_entry *head , cpp_dir const   *start_dir ) ;
#line 182
static _cpp_file *make_cpp_file(cpp_reader *pfile , cpp_dir *dir , char const   *fname ) ;
#line 183
static void destroy_cpp_file(_cpp_file *file ) ;
#line 184
static cpp_dir *make_cpp_dir(cpp_reader *pfile , char const   *dir_name , int sysp ) ;
#line 185
static void allocate_file_hash_entries(cpp_reader *pfile ) ;
#line 186
static struct file_hash_entry *new_file_hash_entry(cpp_reader *pfile ) ;
#line 187
static int report_missing_guard(void **slot , void *b ) ;
#line 188
static hashval_t file_hash_hash(void const   *p ) ;
#line 189
static int file_hash_eq(void const   *p , void const   *q ) ;
#line 190
static char *read_filename_string(int ch , FILE *f ) ;
#line 191
static void read_name_map(cpp_dir *dir ) ;
#line 192
static char *remap_filename(cpp_reader *pfile , _cpp_file *file ) ;
#line 193
static char *append_file_to_dir(char const   *fname , cpp_dir *dir ) ;
#line 194
static unsigned char validate_pch(cpp_reader *pfile , _cpp_file *file , char const   *pchname ) ;
#line 195
static int pchf_save_compare(void const   *e1 , void const   *e2 ) ;
#line 196
static int pchf_compare(void const   *d_p , void const   *e_p ) ;
#line 197
static unsigned char check_file_against_entries(cpp_reader *pfile  __attribute__((__unused__)) ,
                                                _cpp_file *f , unsigned char check_included ) ;
#line 218 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char open_file(_cpp_file *file ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 221
  if ((int const   )*(file->path + 0) == 0) {
#line 223
    file->fd = 0;
  } else {
    {
#line 227
    file->fd = open(file->path, 256, 438);
    }
  }
#line 229
  if (file->fd != -1) {
    {
#line 231
    tmp___0 = fstat(file->fd, & file->st);
    }
#line 231
    if (tmp___0 == 0) {
#line 233
      if (! ((file->st.st_mode & 61440U) == 16384U)) {
#line 235
        file->err_no = 0;
#line 236
        return ((unsigned char)1);
      }
      {
#line 241
      tmp = __errno_location();
#line 241
      *tmp = 2;
      }
    }
    {
#line 244
    close(file->fd);
#line 245
    file->fd = -1;
    }
  } else {
    {
#line 263
    tmp___2 = __errno_location();
    }
#line 263
    if (*tmp___2 == 20) {
      {
#line 264
      tmp___1 = __errno_location();
#line 264
      *tmp___1 = 2;
      }
    }
  }
  {
#line 266
  tmp___3 = __errno_location();
#line 266
  file->err_no = *tmp___3;
  }
#line 268
  return ((unsigned char)0);
}
}
#line 279 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char const   extension[5]  = {      (char const   )'.',      (char const   )'g',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000'};
#line 276 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char pch_open_file(cpp_reader *pfile , _cpp_file *file , unsigned char *invalid_pch ) 
{ 
  char const   *path ;
  size_t len ;
  size_t flen ;
  char *pchname ;
  struct stat st ;
  unsigned char valid ;
  void *tmp ;
  DIR *pchdir ;
  struct dirent *d ;
  size_t dlen ;
  size_t plen ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 280
  path = file->path;
#line 284
  valid = (unsigned char)0;
#line 287
  if ((int const   )*(file->name + 0) == 0) {
#line 288
    return ((unsigned char)0);
  } else
#line 287
  if (! pfile->cb.valid_pch) {
#line 288
    return ((unsigned char)0);
  }
  {
#line 290
  flen = strlen(path);
#line 291
  len = flen + sizeof(extension);
#line 292
  tmp = xmalloc(sizeof(char ) * len);
#line 292
  pchname = (char *)tmp;
#line 293
  memcpy((void */* __restrict  */)pchname, (void const   */* __restrict  */)path,
         flen);
#line 294
  memcpy((void */* __restrict  */)(pchname + flen), (void const   */* __restrict  */)(extension),
         sizeof(extension));
#line 296
  tmp___4 = stat((char const   */* __restrict  */)pchname, (struct stat */* __restrict  */)(& st));
  }
#line 296
  if (tmp___4 == 0) {
#line 300
    plen = len;
#line 302
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 303
      valid = validate_pch(pfile, file, (char const   *)pchname);
      }
    } else {
      {
#line 304
      pchdir = opendir((char const   *)pchname);
      }
#line 304
      if ((unsigned long )pchdir != (unsigned long )((void *)0)) {
#line 306
        *(pchname + (plen - 1UL)) = (char )'/';
        {
#line 307
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 307
          d = readdir(pchdir);
          }
#line 307
          if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 307
            goto while_break;
          }
          {
#line 309
          tmp___0 = strlen((char const   *)(d->d_name));
#line 309
          dlen = tmp___0 + 1UL;
#line 310
          tmp___1 = strcmp((char const   *)(d->d_name), ".");
          }
#line 310
          if (tmp___1 == 0) {
#line 312
            goto while_continue;
          } else {
            {
#line 310
            tmp___2 = strcmp((char const   *)(d->d_name), "..");
            }
#line 310
            if (tmp___2 == 0) {
#line 312
              goto while_continue;
            }
          }
#line 313
          if (dlen + plen > len) {
            {
#line 315
            len += dlen + 64UL;
#line 316
            tmp___3 = xrealloc((void *)pchname, sizeof(char ) * len);
#line 316
            pchname = (char *)tmp___3;
            }
          }
          {
#line 318
          memcpy((void */* __restrict  */)(pchname + plen), (void const   */* __restrict  */)(d->d_name),
                 dlen);
#line 319
          valid = validate_pch(pfile, file, (char const   *)pchname);
          }
#line 320
          if (valid) {
#line 321
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 323
        closedir(pchdir);
        }
      }
    }
#line 325
    if (valid) {
#line 326
      file->pch = (unsigned char)1;
    } else {
#line 328
      *invalid_pch = (unsigned char)1;
    }
  }
#line 331
  if (valid) {
#line 332
    file->pchname = (char const   *)pchname;
  } else {
    {
#line 334
    free((void *)pchname);
    }
  }
#line 336
  return (valid);
}
}
#line 344 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char find_file_in_dir(cpp_reader *pfile , _cpp_file *file , unsigned char *invalid_pch ) 
{ 
  char *path ;
  hashval_t hv ;
  hashval_t tmp ;
  char *copy ;
  void **pp ;
  void *tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *value ;

  {
#line 349
  if (pfile->opts.remap) {
    {
#line 349
    path = remap_filename(pfile, file);
    }
#line 349
    if (! path) {
#line 349
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 352
  if ((file->dir)->construct) {
    {
#line 353
    path = (*((file->dir)->construct))(file->name, file->dir);
    }
  } else {
    {
#line 355
    path = append_file_to_dir(file->name, file->dir);
    }
  }
#line 357
  if (path) {
    {
#line 359
    tmp = htab_hash_string((void const   *)path);
#line 359
    hv = tmp;
#line 363
    tmp___0 = htab_find_with_hash(pfile->nonexistent_file_hash, (void const   *)path,
                                  hv);
    }
#line 363
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 365
      file->err_no = 2;
#line 366
      return ((unsigned char)0);
    }
    {
#line 369
    file->path = (char const   *)path;
#line 370
    tmp___1 = pch_open_file(pfile, file, invalid_pch);
    }
#line 370
    if (tmp___1) {
#line 371
      return ((unsigned char)1);
    }
    {
#line 373
    tmp___2 = open_file(file);
    }
#line 373
    if (tmp___2) {
#line 374
      return ((unsigned char)1);
    }
#line 376
    if (file->err_no != 2) {
      {
#line 378
      open_file_failed(pfile, file, 0);
      }
#line 379
      return ((unsigned char)1);
    }
    {
#line 385
    __h = & pfile->nonexistent_file_ob;
#line 385
    __o = __h;
#line 385
    tmp___3 = strlen((char const   *)path);
#line 385
    __len = (int )tmp___3;
    }
#line 385
    if ((unsigned long )((__o->next_free + __len) + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 385
      _obstack_newchunk(__o, __len + 1);
      }
    }
    {
#line 385
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)path,
           (size_t )__len);
#line 385
    __o->next_free += __len;
#line 385
    tmp___4 = __o->next_free;
#line 385
    (__o->next_free) ++;
#line 385
    *tmp___4 = (char)0;
#line 385
    __o1 = __h;
#line 385
    value = (void *)__o1->object_base;
    }
#line 385
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 385
      __o1->maybe_empty_object = 1U;
    }
#line 385
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 385
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 385
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 385
    __o1->object_base = __o1->next_free;
#line 385
    copy = (char *)value;
#line 387
    free((void *)path);
#line 388
    pp = htab_find_slot_with_hash(pfile->nonexistent_file_hash, (void const   *)copy,
                                  hv, (enum insert_option )1);
#line 390
    *pp = (void *)copy;
#line 392
    file->path = file->name;
    }
  } else {
#line 396
    file->err_no = 2;
#line 397
    file->path = (char const   *)((void *)0);
  }
#line 400
  return ((unsigned char)0);
}
}
#line 404 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char search_path_exhausted(cpp_reader *pfile , char const   *header ,
                                           _cpp_file *file ) 
{ 
  char const   *(*func)(cpp_reader * , char const   *header , cpp_dir ** ) ;
  unsigned char tmp ;
  char const   *tmp___0 ;

  {
#line 407
  func = pfile->cb.missing_header;
#line 411
  if (func) {
#line 411
    if ((unsigned long )file->dir == (unsigned long )((void *)0)) {
      {
#line 414
      tmp___0 = (*func)(pfile, header, & file->dir);
#line 414
      file->path = tmp___0;
      }
#line 414
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 416
        tmp = open_file(file);
        }
#line 416
        if (tmp) {
#line 417
          return ((unsigned char)1);
        }
        {
#line 418
        free((void *)file->path);
        }
      }
#line 420
      file->path = file->name;
    }
  }
#line 423
  return ((unsigned char)0);
}
}
#line 426 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char _cpp_find_failed(_cpp_file *file ) 
{ 


  {
#line 429
  return ((unsigned char )(file->err_no != 0));
}
}
#line 446 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
_cpp_file *_cpp_find_file(cpp_reader *pfile , char const   *fname , cpp_dir *start_dir ,
                          unsigned char fake , int angle_brackets ) 
{ 
  struct file_hash_entry *entry ;
  struct file_hash_entry **hash_slot ;
  _cpp_file *file ;
  unsigned char invalid_pch ;
  unsigned char saw_bracket_include ;
  unsigned char saw_quote_include ;
  struct cpp_dir *found_in_cache ;
  hashval_t tmp ;
  void **tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  cpp_options *tmp___3 ;

  {
#line 451
  invalid_pch = (unsigned char)0;
#line 452
  saw_bracket_include = (unsigned char)0;
#line 453
  saw_quote_include = (unsigned char)0;
#line 454
  found_in_cache = (struct cpp_dir *)((void *)0);
#line 457
  if ((unsigned long )start_dir == (unsigned long )((void *)0)) {
    {
#line 458
    cpp_error(pfile, 4, "NULL directory in find_file");
    }
  }
  {
#line 460
  tmp = htab_hash_string((void const   *)fname);
#line 460
  tmp___0 = htab_find_slot_with_hash(pfile->file_hash, (void const   *)fname, tmp,
                                     (enum insert_option )1);
#line 460
  hash_slot = (struct file_hash_entry **)tmp___0;
#line 466
  entry = search_cache(*hash_slot, (cpp_dir const   *)start_dir);
  }
#line 467
  if (entry) {
#line 468
    return (entry->u.file);
  }
  {
#line 470
  file = make_cpp_file(pfile, start_dir, fname);
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (! fake)) {
#line 473
      goto while_break;
    }
    {
#line 475
    tmp___1 = find_file_in_dir(pfile, file, & invalid_pch);
    }
#line 475
    if (tmp___1) {
#line 476
      goto while_break;
    }
#line 478
    file->dir = (file->dir)->next;
#line 479
    if ((unsigned long )file->dir == (unsigned long )((void *)0)) {
      {
#line 481
      tmp___2 = search_path_exhausted(pfile, fname, file);
      }
#line 481
      if (tmp___2) {
#line 487
        file->next_file = pfile->all_files;
#line 488
        pfile->all_files = file;
#line 489
        return (file);
      }
      {
#line 492
      open_file_failed(pfile, file, angle_brackets);
      }
#line 493
      if (invalid_pch) {
        {
#line 495
        cpp_error(pfile, 3, "one or more PCH files were found, but they were invalid");
#line 497
        tmp___3 = cpp_get_options(pfile);
        }
#line 497
        if (! tmp___3->warn_invalid_pch) {
          {
#line 498
          cpp_error(pfile, 3, "use -Winvalid-pch for more information");
          }
        }
      }
#line 501
      goto while_break;
    }
#line 507
    if ((unsigned long )file->dir == (unsigned long )pfile->bracket_include) {
#line 508
      saw_bracket_include = (unsigned char)1;
    } else
#line 509
    if ((unsigned long )file->dir == (unsigned long )pfile->quote_include) {
#line 510
      saw_quote_include = (unsigned char)1;
    } else {
#line 512
      goto __Cont;
    }
    {
#line 514
    entry = search_cache(*hash_slot, (cpp_dir const   *)file->dir);
    }
#line 515
    if (entry) {
#line 517
      found_in_cache = file->dir;
#line 518
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if (entry) {
    {
#line 525
    free((void *)((char *)file->name));
#line 526
    free((void *)file);
#line 527
    file = entry->u.file;
    }
  } else {
#line 532
    file->next_file = pfile->all_files;
#line 533
    pfile->all_files = file;
  }
  {
#line 537
  entry = new_file_hash_entry(pfile);
#line 538
  entry->next = *hash_slot;
#line 539
  entry->start_dir = start_dir;
#line 540
  entry->location = (pfile->line_table)->highest_location;
#line 541
  entry->u.file = file;
#line 542
  *hash_slot = entry;
  }
#line 546
  if (saw_bracket_include) {
#line 546
    if ((unsigned long )pfile->bracket_include != (unsigned long )start_dir) {
#line 546
      if ((unsigned long )found_in_cache != (unsigned long )pfile->bracket_include) {
        {
#line 550
        entry = new_file_hash_entry(pfile);
#line 551
        entry->next = *hash_slot;
#line 552
        entry->start_dir = pfile->bracket_include;
#line 553
        entry->location = (pfile->line_table)->highest_location;
#line 554
        entry->u.file = file;
#line 555
        *hash_slot = entry;
        }
      }
    }
  }
#line 557
  if (saw_quote_include) {
#line 557
    if ((unsigned long )pfile->quote_include != (unsigned long )start_dir) {
#line 557
      if ((unsigned long )found_in_cache != (unsigned long )pfile->quote_include) {
        {
#line 561
        entry = new_file_hash_entry(pfile);
#line 562
        entry->next = *hash_slot;
#line 563
        entry->start_dir = pfile->quote_include;
#line 564
        entry->location = (pfile->line_table)->highest_location;
#line 565
        entry->u.file = file;
#line 566
        *hash_slot = entry;
        }
      }
    }
  }
#line 569
  return (file);
}
}
#line 580 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char read_file_guts(cpp_reader *pfile , _cpp_file *file ) 
{ 
  ssize_t size ;
  ssize_t total ;
  ssize_t count ;
  uchar *buf___0 ;
  unsigned char regular ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 587
  if ((file->st.st_mode & 61440U) == 24576U) {
    {
#line 589
    cpp_error(pfile, 3, "%s is a block device", file->path);
    }
#line 590
    return ((unsigned char)0);
  }
#line 593
  regular = (unsigned char )((file->st.st_mode & 61440U) == 32768U);
#line 594
  if (regular) {
#line 604
    if (file->st.st_size > -1L - (-1L << (sizeof(ssize_t ) * 8UL - 1UL))) {
      {
#line 606
      cpp_error(pfile, 3, "%s is too large", file->path);
      }
#line 607
      return ((unsigned char)0);
    }
#line 610
    size = file->st.st_size;
  } else {
#line 616
    size = (ssize_t )8192;
  }
  {
#line 618
  tmp = xmalloc(sizeof(uchar ) * (unsigned long )(size + 1L));
#line 618
  buf___0 = (uchar *)tmp;
#line 619
  total = (ssize_t )0;
  }
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 620
    count = read(file->fd, (void *)(buf___0 + total), (size_t )(size - total));
    }
#line 620
    if (! (count > 0L)) {
#line 620
      goto while_break;
    }
#line 622
    total += count;
#line 624
    if (total == size) {
#line 626
      if (regular) {
#line 627
        goto while_break;
      }
      {
#line 628
      size *= 2L;
#line 629
      tmp___0 = xrealloc((void *)buf___0, sizeof(uchar ) * (unsigned long )(size + 1L));
#line 629
      buf___0 = (uchar *)tmp___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  if (count < 0L) {
    {
#line 635
    cpp_errno(pfile, 3, file->path);
    }
#line 636
    return ((unsigned char)0);
  }
#line 639
  if (regular) {
#line 639
    if (total != size) {
      {
#line 640
      cpp_error(pfile, 0, "%s is shorter than expected", file->path);
      }
    }
  }
  {
#line 643
  tmp___1 = _cpp_convert_input(pfile, pfile->opts.input_charset, buf___0, (size_t )size,
                               (size_t )total, & file->st.st_size);
#line 643
  file->buffer = (uchar const   *)tmp___1;
#line 645
  file->buffer_valid = (unsigned char)1;
  }
#line 647
  return ((unsigned char)1);
}
}
#line 653 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char read_file(cpp_reader *pfile , _cpp_file *file ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
#line 657
  if (file->buffer_valid) {
#line 658
    return ((unsigned char)1);
  }
#line 661
  if (file->dont_read) {
#line 662
    return ((unsigned char)0);
  } else
#line 661
  if (file->err_no) {
#line 662
    return ((unsigned char)0);
  }
#line 664
  if (file->fd == -1) {
    {
#line 664
    tmp = open_file(file);
    }
#line 664
    if (! tmp) {
      {
#line 666
      open_file_failed(pfile, file, 0);
      }
#line 667
      return ((unsigned char)0);
    }
  }
  {
#line 670
  tmp___0 = read_file_guts(pfile, file);
  }
#line 670
  if (tmp___0) {
#line 670
    tmp___1 = 0;
  } else {
#line 670
    tmp___1 = 1;
  }
  {
#line 670
  file->dont_read = (unsigned char )tmp___1;
#line 671
  close(file->fd);
#line 672
  file->fd = -1;
  }
#line 674
  return ((unsigned char )(! file->dont_read));
}
}
#line 679 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char should_stack_file(cpp_reader *pfile , _cpp_file *file , unsigned char import ) 
{ 
  _cpp_file *f ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  _cpp_file *ref_file ;
  unsigned char same_file_p ;
  unsigned char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 685
  if (file->once_only) {
#line 686
    return ((unsigned char)0);
  }
#line 691
  if (import) {
    {
#line 693
    _cpp_mark_file_once_only(pfile, file);
    }
#line 696
    if (file->stack_count) {
#line 697
      return ((unsigned char)0);
    }
  }
#line 702
  if (file->cmacro) {
#line 702
    if ((unsigned int const   )(file->cmacro)->type == 1U) {
#line 703
      return ((unsigned char)0);
    }
  }
#line 706
  if (file->pch) {
    {
#line 708
    (*(pfile->cb.read_pch))(pfile, file->pchname, file->fd, file->path);
#line 709
    close(file->fd);
#line 710
    file->fd = -1;
    }
#line 711
    return ((unsigned char)0);
  }
  {
#line 714
  tmp = read_file(pfile, file);
  }
#line 714
  if (! tmp) {
#line 715
    return ((unsigned char)0);
  }
  {
#line 720
  tmp___0 = check_file_against_entries(pfile, file, import);
  }
#line 720
  if (tmp___0) {
#line 725
    if (! import) {
      {
#line 726
      _cpp_mark_file_once_only(pfile, file);
      }
    }
#line 727
    return ((unsigned char)0);
  }
#line 732
  if (! pfile->seen_once_only) {
#line 733
    return ((unsigned char)1);
  }
#line 737
  f = pfile->all_files;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! f) {
#line 737
      goto while_break;
    }
#line 739
    if ((unsigned long )f == (unsigned long )file) {
#line 740
      goto __Cont;
    }
#line 742
    if (import) {
#line 742
      goto _L;
    } else
#line 742
    if (f->once_only) {
      _L: /* CIL Label */ 
#line 742
      if (f->err_no == 0) {
#line 742
        if (f->st.st_mtim.tv_sec == file->st.st_mtim.tv_sec) {
#line 742
          if (f->st.st_size == file->st.st_size) {
#line 748
            same_file_p = (unsigned char)0;
#line 750
            if (f->buffer) {
#line 750
              if (! f->buffer_valid) {
                {
#line 754
                ref_file = make_cpp_file(pfile, f->dir, f->name);
#line 755
                ref_file->path = f->path;
                }
              } else {
#line 759
                ref_file = f;
              }
            } else {
#line 759
              ref_file = f;
            }
            {
#line 761
            tmp___1 = read_file(pfile, ref_file);
            }
#line 761
            if (tmp___1) {
#line 761
              if (ref_file->st.st_size == file->st.st_size) {
                {
#line 761
                tmp___2 = memcmp((void const   *)ref_file->buffer, (void const   *)file->buffer,
                                 (size_t )file->st.st_size);
                }
#line 761
                if (tmp___2) {
#line 761
                  tmp___3 = 0;
                } else {
#line 761
                  tmp___3 = 1;
                }
              } else {
#line 761
                tmp___3 = 0;
              }
            } else {
#line 761
              tmp___3 = 0;
            }
#line 761
            same_file_p = (unsigned char )tmp___3;
#line 768
            if (f->buffer) {
#line 768
              if (! f->buffer_valid) {
                {
#line 770
                ref_file->path = (char const   *)0;
#line 771
                destroy_cpp_file(ref_file);
                }
              }
            }
#line 774
            if (same_file_p) {
#line 775
              goto while_break;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 737
    f = f->next_file;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return ((unsigned char )((unsigned long )f == (unsigned long )((void *)0)));
}
}
#line 786 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char _cpp_stack_file(cpp_reader *pfile , _cpp_file *file , unsigned char import ) 
{ 
  cpp_buffer *buffer ;
  int sysp ;
  unsigned char tmp ;
  int tmp___0 ;

  {
  {
#line 792
  tmp = should_stack_file(pfile, file, import);
  }
#line 792
  if (! tmp) {
#line 793
    return ((unsigned char)0);
  }
#line 795
  if ((unsigned long )pfile->buffer == (unsigned long )((void *)0)) {
#line 796
    sysp = 0;
  } else
#line 795
  if ((unsigned long )file->dir == (unsigned long )((void *)0)) {
#line 796
    sysp = 0;
  } else
#line 798
  if ((int )(pfile->buffer)->sysp > (int )(file->dir)->sysp) {
#line 798
    sysp = (int )(pfile->buffer)->sysp;
  } else {
#line 798
    sysp = (int )(file->dir)->sysp;
  }
#line 801
  if ((unsigned int )pfile->opts.deps.style > (unsigned int )(! (! sysp))) {
#line 801
    if (! file->stack_count) {
#line 803
      if (! file->main_file) {
        {
#line 804
        deps_add_dep(pfile->deps, file->path);
        }
      } else
#line 803
      if (! pfile->opts.deps.ignore_main_file) {
        {
#line 804
        deps_add_dep(pfile->deps, file->path);
        }
      }
    }
  }
#line 808
  file->buffer_valid = (unsigned char)0;
#line 809
  file->stack_count = (unsigned short )((int )file->stack_count + 1);
#line 812
  if (pfile->opts.preprocessed) {
#line 812
    if (! pfile->opts.directives_only) {
#line 812
      tmp___0 = 1;
    } else {
#line 812
      tmp___0 = 0;
    }
  } else {
#line 812
    tmp___0 = 0;
  }
  {
#line 812
  buffer = cpp_push_buffer(pfile, file->buffer, (size_t )file->st.st_size, tmp___0);
#line 815
  buffer->file = file;
#line 816
  buffer->sysp = (unsigned char )sysp;
#line 819
  pfile->mi_valid = (unsigned char)1;
#line 820
  pfile->mi_cmacro = (cpp_hashnode const   *)0;
#line 823
  _cpp_do_file_change(pfile, (enum lc_reason )0, file->path, 1U, (unsigned int )sysp);
  }
#line 825
  return ((unsigned char)1);
}
}
#line 829 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_mark_file_once_only(cpp_reader *pfile , struct _cpp_file *file ) 
{ 


  {
#line 832
  pfile->seen_once_only = (unsigned char)1;
#line 833
  file->once_only = (unsigned char)1;
#line 834
  return;
}
}
#line 839 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static struct cpp_dir *search_path_head(cpp_reader *pfile , char const   *fname ,
                                        int angle_brackets , enum include_type type ) 
{ 
  cpp_dir *dir ;
  _cpp_file *file ;
  cpp_dir *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  cpp_dir *tmp___2 ;

  {
#line 846
  if ((int const   )*(fname + 0) == 47) {
#line 847
    return (& pfile->no_search_path);
  }
#line 850
  if ((unsigned long )pfile->buffer == (unsigned long )((void *)0)) {
#line 850
    file = pfile->main_file;
  } else {
#line 850
    file = (pfile->buffer)->file;
  }
#line 855
  if ((unsigned int )type == 1U) {
#line 855
    if (file->dir) {
#line 855
      if ((unsigned long )file->dir != (unsigned long )(& pfile->no_search_path)) {
#line 857
        dir = (file->dir)->next;
      } else {
#line 855
        goto _L___0;
      }
    } else {
#line 855
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 858
  if (angle_brackets) {
#line 859
    dir = pfile->bracket_include;
  } else
#line 860
  if ((unsigned int )type == 3U) {
    {
#line 863
    tmp = make_cpp_dir(pfile, "./", 0);
    }
#line 863
    return (tmp);
  } else
#line 864
  if (pfile->quote_ignores_source_dir) {
#line 865
    dir = pfile->quote_include;
  } else {
#line 867
    if (pfile->buffer) {
#line 867
      tmp___0 = (int )(pfile->buffer)->sysp;
    } else {
#line 867
      tmp___0 = 0;
    }
    {
#line 867
    tmp___1 = dir_name_of_file(file);
#line 867
    tmp___2 = make_cpp_dir(pfile, tmp___1, tmp___0);
    }
#line 867
    return (tmp___2);
  }
#line 870
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 871
    cpp_error(pfile, 3, "no include path in which to search for %s", fname);
    }
  }
#line 874
  return (dir);
}
}
#line 880 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char const   *dir_name_of_file(_cpp_file *file ) 
{ 
  size_t len ;
  char const   *tmp ;
  char *dir_name ;
  void *tmp___0 ;

  {
#line 883
  if (! file->dir_name) {
    {
#line 885
    tmp = lbasename(file->path);
#line 885
    len = (size_t )(tmp - file->path);
#line 886
    tmp___0 = xmalloc(sizeof(char ) * (len + 1UL));
#line 886
    dir_name = (char *)tmp___0;
#line 888
    memcpy((void */* __restrict  */)dir_name, (void const   */* __restrict  */)file->path,
           len);
#line 889
    *(dir_name + len) = (char )'\000';
#line 890
    file->dir_name = (char const   *)dir_name;
    }
  }
#line 893
  return (file->dir_name);
}
}
#line 899 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char _cpp_stack_include(cpp_reader *pfile , char const   *fname , int angle_brackets ,
                                 enum include_type type ) 
{ 
  struct cpp_dir *dir ;
  _cpp_file *file ;
  unsigned char tmp ;

  {
  {
#line 906
  dir = search_path_head(pfile, fname, angle_brackets, type);
  }
#line 907
  if (! dir) {
#line 908
    return ((unsigned char)0);
  }
  {
#line 910
  file = _cpp_find_file(pfile, fname, dir, (unsigned char)0, angle_brackets);
  }
#line 919
  if (! file->pch) {
#line 919
    if (file->err_no == 0) {
#line 919
      if ((unsigned int )type != 3U) {
#line 920
        ((pfile->line_table)->highest_location) --;
      }
    }
  }
  {
#line 922
  tmp = _cpp_stack_file(pfile, file, (unsigned char )((unsigned int )type == 2U));
  }
#line 922
  return (tmp);
}
}
#line 926 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void open_file_failed(cpp_reader *pfile , _cpp_file *file , int angle_brackets ) 
{ 
  int sysp ;
  int tmp ;
  unsigned char print_dep ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 929
  if ((pfile->line_table)->highest_line > 1U) {
#line 929
    if (pfile->buffer) {
#line 929
      tmp = (int )(pfile->buffer)->sysp;
    } else {
#line 929
      tmp = 0;
    }
  } else {
#line 929
    tmp = 0;
  }
#line 929
  sysp = tmp;
#line 930
  if (angle_brackets) {
#line 930
    tmp___0 = 1;
  } else
#line 930
  if (! (! sysp)) {
#line 930
    tmp___0 = 1;
  } else {
#line 930
    tmp___0 = 0;
  }
  {
#line 930
  print_dep = (unsigned char )((unsigned int )pfile->opts.deps.style > (unsigned int )tmp___0);
#line 932
  tmp___1 = __errno_location();
#line 932
  *tmp___1 = file->err_no;
  }
#line 933
  if (print_dep) {
#line 933
    if (pfile->opts.deps.missing_files) {
      {
#line 933
      tmp___2 = __errno_location();
      }
#line 933
      if (*tmp___2 == 2) {
        {
#line 934
        deps_add_dep(pfile->deps, file->name);
        }
      } else {
#line 933
        goto _L___0;
      }
    } else {
#line 933
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 939
  if (pfile->opts.deps.style) {
#line 939
    if (! print_dep) {
      {
#line 940
      cpp_errno(pfile, 0, file->path);
      }
    } else {
      {
#line 942
      cpp_errno(pfile, 3, file->path);
      }
    }
  } else {
    {
#line 942
    cpp_errno(pfile, 3, file->path);
    }
  }
#line 944
  return;
}
}
#line 948 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static struct file_hash_entry *search_cache(struct file_hash_entry *head , cpp_dir const   *start_dir ) 
{ 


  {
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 951
    if (head) {
#line 951
      if (! ((unsigned long )head->start_dir != (unsigned long )start_dir)) {
#line 951
        goto while_break;
      }
    } else {
#line 951
      goto while_break;
    }
#line 952
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  return (head);
}
}
#line 958 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static _cpp_file *make_cpp_file(cpp_reader *pfile , cpp_dir *dir , char const   *fname ) 
{ 
  _cpp_file *file ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 963
  tmp = xcalloc((size_t )1, sizeof(_cpp_file ));
#line 963
  file = (_cpp_file *)tmp;
#line 964
  file->main_file = (unsigned char )(! pfile->buffer);
#line 965
  file->fd = -1;
#line 966
  file->dir = dir;
#line 967
  tmp___0 = xstrdup(fname);
#line 967
  file->name = (char const   *)tmp___0;
  }
#line 969
  return (file);
}
}
#line 973 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void destroy_cpp_file(_cpp_file *file ) 
{ 


  {
#line 976
  if (file->buffer) {
    {
#line 977
    free((void *)file->buffer);
    }
  }
  {
#line 978
  free((void *)file->name);
#line 979
  free((void *)file);
  }
#line 980
  return;
}
}
#line 983 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void destroy_all_cpp_files(cpp_reader *pfile ) 
{ 
  _cpp_file *iter ;
  _cpp_file *next ;

  {
#line 986
  iter = pfile->all_files;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! iter) {
#line 987
      goto while_break;
    }
    {
#line 989
    next = iter->next_file;
#line 990
    destroy_cpp_file(iter);
#line 991
    iter = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  return;
}
}
#line 1002 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static cpp_dir *make_cpp_dir(cpp_reader *pfile , char const   *dir_name , int sysp ) 
{ 
  struct file_hash_entry *entry ;
  struct file_hash_entry **hash_slot ;
  cpp_dir *dir ;
  hashval_t tmp ;
  void **tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1008
  tmp = htab_hash_string((void const   *)dir_name);
#line 1008
  tmp___0 = htab_find_slot_with_hash(pfile->dir_hash, (void const   *)dir_name, tmp,
                                     (enum insert_option )1);
#line 1008
  hash_slot = (struct file_hash_entry **)tmp___0;
#line 1014
  entry = *hash_slot;
  }
  {
#line 1014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1014
    if (! entry) {
#line 1014
      goto while_break;
    }
#line 1015
    if ((unsigned long )entry->start_dir == (unsigned long )((void *)0)) {
#line 1016
      return (entry->u.dir);
    }
#line 1014
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1018
  tmp___1 = xcalloc((size_t )1, sizeof(cpp_dir ));
#line 1018
  dir = (cpp_dir *)tmp___1;
#line 1019
  dir->next = pfile->quote_include;
#line 1020
  dir->name = (char *)dir_name;
#line 1021
  tmp___2 = strlen(dir_name);
#line 1021
  dir->len = (unsigned int )tmp___2;
#line 1022
  dir->sysp = (unsigned char )sysp;
#line 1023
  dir->construct = (char *(*)(char const   *header , cpp_dir *dir ))0;
#line 1026
  entry = new_file_hash_entry(pfile);
#line 1027
  entry->next = *hash_slot;
#line 1028
  entry->start_dir = (cpp_dir *)((void *)0);
#line 1029
  entry->location = (pfile->line_table)->highest_location;
#line 1030
  entry->u.dir = dir;
#line 1031
  *hash_slot = entry;
  }
#line 1033
  return (dir);
}
}
#line 1037 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void allocate_file_hash_entries(cpp_reader *pfile ) 
{ 
  struct file_hash_entry_pool *pool ;
  void *tmp ;

  {
  {
#line 1040
  tmp = xmalloc(sizeof(struct file_hash_entry_pool ));
#line 1040
  pool = (struct file_hash_entry_pool *)tmp;
#line 1041
  pool->file_hash_entries_used = 0U;
#line 1042
  pool->next = pfile->file_hash_entries;
#line 1043
  pfile->file_hash_entries = pool;
  }
#line 1044
  return;
}
}
#line 1047 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static struct file_hash_entry *new_file_hash_entry(cpp_reader *pfile ) 
{ 
  unsigned int idx ;
  unsigned int tmp ;

  {
#line 1051
  if ((pfile->file_hash_entries)->file_hash_entries_used == 127U) {
    {
#line 1052
    allocate_file_hash_entries(pfile);
    }
  }
#line 1054
  tmp = (pfile->file_hash_entries)->file_hash_entries_used;
#line 1054
  ((pfile->file_hash_entries)->file_hash_entries_used) ++;
#line 1054
  idx = tmp;
#line 1055
  return (& (pfile->file_hash_entries)->pool[idx]);
}
}
#line 1059 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void free_file_hash_entries(cpp_reader *pfile ) 
{ 
  struct file_hash_entry_pool *iter ;
  struct file_hash_entry_pool *next ;

  {
#line 1062
  iter = pfile->file_hash_entries;
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    if (! iter) {
#line 1063
      goto while_break;
    }
    {
#line 1065
    next = iter->next;
#line 1066
    free((void *)iter);
#line 1067
    iter = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return;
}
}
#line 1074 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char cpp_included(cpp_reader *pfile , char const   *fname ) 
{ 
  struct file_hash_entry *entry ;
  hashval_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1079
  tmp = htab_hash_string((void const   *)fname);
#line 1079
  tmp___0 = htab_find_with_hash(pfile->file_hash, (void const   *)fname, tmp);
#line 1079
  entry = (struct file_hash_entry *)tmp___0;
  }
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1082
    if (entry) {
#line 1082
      if (! ((unsigned long )entry->start_dir == (unsigned long )((void *)0))) {
#line 1082
        if (! (entry->u.file)->err_no) {
#line 1082
          goto while_break;
        }
      }
    } else {
#line 1082
      goto while_break;
    }
#line 1083
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1085
  return ((unsigned char )((unsigned long )entry != (unsigned long )((void *)0)));
}
}
#line 1091 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char cpp_included_before(cpp_reader *pfile , char const   *fname , source_location location ) 
{ 
  struct file_hash_entry *entry ;
  hashval_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1097
  tmp = htab_hash_string((void const   *)fname);
#line 1097
  tmp___0 = htab_find_with_hash(pfile->file_hash, (void const   *)fname, tmp);
#line 1097
  entry = (struct file_hash_entry *)tmp___0;
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (entry) {
#line 1100
      if (! ((unsigned long )entry->start_dir == (unsigned long )((void *)0))) {
#line 1100
        if (! (entry->u.file)->err_no) {
#line 1100
          if (! (entry->location > location)) {
#line 1100
            goto while_break;
          }
        }
      }
    } else {
#line 1100
      goto while_break;
    }
#line 1102
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  return ((unsigned char )((unsigned long )entry != (unsigned long )((void *)0)));
}
}
#line 1109 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static hashval_t file_hash_hash(void const   *p ) 
{ 
  struct file_hash_entry *entry ;
  char const   *hname ;
  hashval_t tmp ;

  {
#line 1112
  entry = (struct file_hash_entry *)p;
#line 1114
  if (entry->start_dir) {
#line 1115
    hname = (entry->u.file)->name;
  } else {
#line 1117
    hname = (char const   *)(entry->u.dir)->name;
  }
  {
#line 1119
  tmp = htab_hash_string((void const   *)hname);
  }
#line 1119
  return (tmp);
}
}
#line 1123 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static int file_hash_eq(void const   *p , void const   *q ) 
{ 
  struct file_hash_entry *entry ;
  char const   *fname ;
  char const   *hname ;
  int tmp ;

  {
#line 1126
  entry = (struct file_hash_entry *)p;
#line 1127
  fname = (char const   *)q;
#line 1130
  if (entry->start_dir) {
#line 1131
    hname = (entry->u.file)->name;
  } else {
#line 1133
    hname = (char const   *)(entry->u.dir)->name;
  }
  {
#line 1135
  tmp = strcmp(hname, fname);
  }
#line 1135
  return (tmp == 0);
}
}
#line 1140 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static int nonexistent_file_hash_eq(void const   *p , void const   *q ) 
{ 
  int tmp ;

  {
  {
#line 1143
  tmp = strcmp((char const   *)p, (char const   *)q);
  }
#line 1143
  return (tmp == 0);
}
}
#line 1147 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_init_files(cpp_reader *pfile ) 
{ 


  {
  {
#line 1150
  pfile->file_hash = htab_create_alloc((size_t )127, & file_hash_hash, & file_hash_eq,
                                       (void (*)(void * ))((void *)0), & xcalloc,
                                       (void (*)(void * ))(& free));
#line 1152
  pfile->dir_hash = htab_create_alloc((size_t )127, & file_hash_hash, & file_hash_eq,
                                      (void (*)(void * ))((void *)0), & xcalloc, (void (*)(void * ))(& free));
#line 1154
  allocate_file_hash_entries(pfile);
#line 1155
  pfile->nonexistent_file_hash = htab_create_alloc((size_t )127, & htab_hash_string,
                                                   & nonexistent_file_hash_eq, (void (*)(void * ))((void *)0),
                                                   & xcalloc, (void (*)(void * ))(& free));
#line 1158
  _obstack_begin(& pfile->nonexistent_file_ob, 0, 0, (void *(*)(long  ))(& xmalloc),
                 (void (*)(void * ))(& free));
  }
#line 1161
  return;
}
}
#line 1164 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_cleanup_files(cpp_reader *pfile ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 1167
  htab_delete(pfile->file_hash);
#line 1168
  htab_delete(pfile->dir_hash);
#line 1169
  htab_delete(pfile->nonexistent_file_hash);
#line 1170
  __o = & pfile->nonexistent_file_ob;
#line 1170
  __obj = (void *)0;
  }
#line 1170
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1170
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1170
      tmp = (char *)__obj;
#line 1170
      __o->object_base = tmp;
#line 1170
      __o->next_free = tmp;
    } else {
      {
#line 1170
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 1170
    obstack_free(__o, __obj);
    }
  }
  {
#line 1171
  free_file_hash_entries(pfile);
#line 1172
  destroy_all_cpp_files(pfile);
  }
#line 1173
  return;
}
}
#line 1177 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void cpp_clear_file_cache(cpp_reader *pfile ) 
{ 


  {
  {
#line 1180
  _cpp_cleanup_files(pfile);
#line 1181
  pfile->file_hash_entries = (struct file_hash_entry_pool *)((void *)0);
#line 1182
  pfile->all_files = (struct _cpp_file *)((void *)0);
#line 1183
  _cpp_init_files(pfile);
  }
#line 1184
  return;
}
}
#line 1187 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_fake_include(cpp_reader *pfile , char const   *fname ) 
{ 


  {
  {
#line 1190
  _cpp_find_file(pfile, fname, ((pfile->buffer)->file)->dir, (unsigned char)1, 0);
  }
#line 1191
  return;
}
}
#line 1196 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void cpp_make_system_header(cpp_reader *pfile , int syshdr , int externc ) 
{ 
  int flags ;
  struct line_maps  const  *line_table ;
  struct line_map  const  *map ;

  {
#line 1199
  flags = 0;
#line 1200
  line_table = (struct line_maps  const  *)pfile->line_table;
#line 1201
  map = (struct line_map  const  *)(line_table->maps + (line_table->used - 1U));
#line 1204
  if (syshdr) {
#line 1205
    flags = 1 + (externc != 0);
  }
  {
#line 1206
  (pfile->buffer)->sysp = (unsigned char )flags;
#line 1207
  _cpp_do_file_change(pfile, (enum lc_reason )2, (char const   *)map->to_file, (((pfile->line_table)->highest_line - (source_location )map->start_location) >> map->column_bits) + (source_location )map->to_line,
                      (unsigned int )flags);
  }
#line 1209
  return;
}
}
#line 1214 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void cpp_change_file(cpp_reader *pfile , enum lc_reason reason , char const   *new_name ) 
{ 


  {
  {
#line 1218
  _cpp_do_file_change(pfile, reason, new_name, 1U, 0U);
  }
#line 1219
  return;
}
}
#line 1222 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static int report_missing_guard(void **slot , void *b ) 
{ 
  struct file_hash_entry *entry ;
  int *bannerp ;
  _cpp_file *file ;

  {
#line 1225
  entry = (struct file_hash_entry *)*slot;
#line 1226
  bannerp = (int *)b;
#line 1229
  if ((unsigned long )entry->start_dir != (unsigned long )((void *)0)) {
#line 1231
    file = entry->u.file;
#line 1234
    if ((unsigned long )file->cmacro == (unsigned long )((void *)0)) {
#line 1234
      if ((int )file->stack_count == 1) {
#line 1234
        if (! file->main_file) {
#line 1236
          if (*bannerp == 0) {
            {
#line 1238
            fputs_unlocked("Multiple include guards may be useful for:\n", stderr);
#line 1240
            *bannerp = 1;
            }
          }
          {
#line 1243
          fputs_unlocked((entry->u.file)->path, stderr);
#line 1244
          putc_unlocked('\n', stderr);
          }
        }
      }
    }
  }
#line 1248
  return (0);
}
}
#line 1253 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_report_missing_guards(cpp_reader *pfile ) 
{ 
  int banner ;

  {
  {
#line 1256
  banner = 0;
#line 1258
  htab_traverse(pfile->file_hash, & report_missing_guard, (void *)(& banner));
  }
#line 1259
  return;
}
}
#line 1264 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
int _cpp_compare_file_date(cpp_reader *pfile , char const   *fname , int angle_brackets ) 
{ 
  _cpp_file *file ;
  struct cpp_dir *dir ;

  {
  {
#line 1271
  dir = search_path_head(pfile, fname, angle_brackets, (enum include_type )0);
  }
#line 1272
  if (! dir) {
#line 1273
    return (-1);
  }
  {
#line 1275
  file = _cpp_find_file(pfile, fname, dir, (unsigned char)0, angle_brackets);
  }
#line 1276
  if (file->err_no) {
#line 1277
    return (-1);
  }
#line 1279
  if (file->fd != -1) {
    {
#line 1281
    close(file->fd);
#line 1282
    file->fd = -1;
    }
  }
#line 1285
  return (file->st.st_mtim.tv_sec > ((pfile->buffer)->file)->st.st_mtim.tv_sec);
}
}
#line 1290 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char cpp_push_include(cpp_reader *pfile , char const   *fname ) 
{ 
  unsigned char tmp ;

  {
  {
#line 1293
  tmp = _cpp_stack_include(pfile, fname, 0, (enum include_type )3);
  }
#line 1293
  return (tmp);
}
}
#line 1298 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void _cpp_pop_file_buffer(cpp_reader *pfile , struct _cpp_file *file ) 
{ 


  {
#line 1303
  if (pfile->mi_valid) {
#line 1303
    if ((unsigned long )file->cmacro == (unsigned long )((void *)0)) {
#line 1304
      file->cmacro = pfile->mi_cmacro;
    }
  }
#line 1307
  pfile->mi_valid = (unsigned char)0;
#line 1309
  if (file->buffer) {
    {
#line 1311
    free((void *)file->buffer);
#line 1312
    file->buffer = (uchar const   *)((void *)0);
#line 1313
    file->buffer_valid = (unsigned char)0;
    }
  }
#line 1315
  return;
}
}
#line 1318 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct stat *_cpp_get_file_stat(_cpp_file *file ) 
{ 


  {
#line 1321
  return (& file->st);
}
}
#line 1329 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
void cpp_set_include_chains(cpp_reader *pfile , cpp_dir *quote , cpp_dir *bracket ,
                            int quote_ignores_source_dir ) 
{ 
  size_t tmp ;

  {
#line 1333
  pfile->quote_include = quote;
#line 1334
  pfile->bracket_include = quote;
#line 1335
  pfile->quote_ignores_source_dir = (unsigned char )quote_ignores_source_dir;
  {
#line 1337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1337
    if (! quote) {
#line 1337
      goto while_break;
    }
    {
#line 1339
    quote->name_map = (char const   **)((void *)0);
#line 1340
    tmp = strlen((char const   *)quote->name);
#line 1340
    quote->len = (unsigned int )tmp;
    }
#line 1341
    if ((unsigned long )quote == (unsigned long )bracket) {
#line 1342
      pfile->bracket_include = bracket;
    }
#line 1337
    quote = quote->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  return;
}
}
#line 1348 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char *append_file_to_dir(char const   *fname , cpp_dir *dir ) 
{ 
  size_t dlen ;
  size_t flen ;
  char *path ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1354
  dlen = (size_t )dir->len;
#line 1355
  flen = strlen(fname);
#line 1356
  tmp = xmalloc(sizeof(char ) * (((dlen + 1UL) + flen) + 1UL));
#line 1356
  path = (char *)tmp;
#line 1357
  memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)dir->name,
         dlen);
  }
#line 1358
  if (dlen) {
#line 1358
    if ((int )*(path + (dlen - 1UL)) != 47) {
#line 1359
      tmp___0 = dlen;
#line 1359
      dlen ++;
#line 1359
      *(path + tmp___0) = (char )'/';
    }
  }
  {
#line 1360
  memcpy((void */* __restrict  */)(path + dlen), (void const   */* __restrict  */)fname,
         flen + 1UL);
  }
#line 1362
  return (path);
}
}
#line 1367 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char *read_filename_string(int ch , FILE *f ) 
{ 
  char *alloc ;
  char *set ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1373
  len = 20;
#line 1374
  tmp = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 1374
  alloc = (char *)tmp;
#line 1374
  set = alloc;
  }
#line 1375
  if (! ((int const   )_sch_istable[ch & 255] & 3072)) {
#line 1377
    tmp___0 = set;
#line 1377
    set ++;
#line 1377
    *tmp___0 = (char )ch;
    {
#line 1378
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1378
      ch = getc_unlocked(f);
      }
#line 1378
      if (ch != -1) {
#line 1378
        if (! (! ((int const   )_sch_istable[ch & 255] & 3072))) {
#line 1378
          goto while_break;
        }
      } else {
#line 1378
        goto while_break;
      }
#line 1380
      if (set - alloc == (long )len) {
        {
#line 1382
        len *= 2;
#line 1383
        tmp___1 = xrealloc((void *)alloc, sizeof(char ) * (unsigned long )(len + 1));
#line 1383
        alloc = (char *)tmp___1;
#line 1384
        set = alloc + len / 2;
        }
      }
#line 1386
      tmp___2 = set;
#line 1386
      set ++;
#line 1386
      *tmp___2 = (char )ch;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1389
  *set = (char )'\000';
#line 1390
  ungetc(ch, f);
  }
#line 1391
  return (alloc);
}
}
#line 1398 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char const   FILE_NAME_MAP_FILE[11]  = 
#line 1398
  {      (char const   )'h',      (char const   )'e',      (char const   )'a',      (char const   )'d', 
        (char const   )'e',      (char const   )'r',      (char const   )'.',      (char const   )'g', 
        (char const   )'c',      (char const   )'c',      (char const   )'\000'};
#line 1395 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static void read_name_map(cpp_dir *dir ) 
{ 
  char *name ;
  FILE *f ;
  size_t len ;
  size_t count ;
  size_t room ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int ch ;
  char *to ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1401
  count = (size_t )0;
#line 1401
  room = (size_t )9;
#line 1403
  len = (size_t )dir->len;
#line 1404
  tmp = __builtin_alloca((len + sizeof(FILE_NAME_MAP_FILE)) + 1UL);
#line 1404
  name = (char *)tmp;
#line 1405
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)dir->name,
         len);
  }
#line 1406
  if (len) {
#line 1406
    if ((int )*(name + (len - 1UL)) != 47) {
#line 1407
      tmp___0 = len;
#line 1407
      len ++;
#line 1407
      *(name + tmp___0) = (char )'/';
    }
  }
  {
#line 1408
  strcpy((char */* __restrict  */)(name + len), (char const   */* __restrict  */)(FILE_NAME_MAP_FILE));
#line 1409
  f = fopen_unlocked((char const   *)name, "r");
#line 1411
  tmp___1 = xmalloc(sizeof(char const   *) * room);
#line 1411
  dir->name_map = (char const   **)tmp___1;
  }
#line 1414
  if (f) {
    {
#line 1418
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1418
      ch = getc_unlocked(f);
      }
#line 1418
      if (! (ch != -1)) {
#line 1418
        goto while_break;
      }
#line 1422
      if ((int const   )_sch_istable[ch & 255] & 3072) {
#line 1423
        goto while_continue;
      }
#line 1425
      if (count + 2UL > room) {
        {
#line 1427
        room += 8UL;
#line 1428
        tmp___2 = xrealloc((void *)dir->name_map, sizeof(char const   *) * room);
#line 1428
        dir->name_map = (char const   **)tmp___2;
        }
      }
      {
#line 1431
      tmp___3 = read_filename_string(ch, f);
#line 1431
      *(dir->name_map + count) = (char const   *)tmp___3;
      }
      {
#line 1432
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1432
        ch = getc_unlocked(f);
        }
#line 1432
        if (ch != -1) {
#line 1432
          if (! ((int const   )_sch_istable[ch & 255] & 1)) {
#line 1432
            goto while_break___0;
          }
        } else {
#line 1432
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1435
      to = read_filename_string(ch, f);
      }
#line 1436
      if ((int )*(to + 0) == 47) {
#line 1437
        *(dir->name_map + (count + 1UL)) = (char const   *)to;
      } else {
        {
#line 1440
        tmp___4 = append_file_to_dir((char const   *)to, dir);
#line 1440
        *(dir->name_map + (count + 1UL)) = (char const   *)tmp___4;
#line 1441
        free((void *)to);
        }
      }
#line 1444
      count += 2UL;
      {
#line 1445
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1445
        ch = getc_unlocked(f);
        }
#line 1445
        if (! (ch != 10)) {
#line 1445
          goto while_break___1;
        }
#line 1446
        if (ch == -1) {
#line 1447
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1450
    fclose(f);
    }
  }
#line 1454
  *(dir->name_map + count) = (char const   *)((void *)0);
#line 1455
  return;
}
}
#line 1460 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static char *remap_filename(cpp_reader *pfile , _cpp_file *file ) 
{ 
  char const   *fname ;
  char const   *p ;
  char *new_dir ;
  cpp_dir *dir ;
  size_t index___0 ;
  size_t len ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 1468
  dir = file->dir;
#line 1469
  fname = file->name;
  {
#line 1471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1473
    if (! dir->name_map) {
      {
#line 1474
      read_name_map(dir);
      }
    }
#line 1476
    index___0 = (size_t )0;
    {
#line 1476
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1476
      if (! *(dir->name_map + index___0)) {
#line 1476
        goto while_break___0;
      }
      {
#line 1477
      tmp___0 = strcmp(*(dir->name_map + index___0), fname);
      }
#line 1477
      if (! tmp___0) {
        {
#line 1478
        tmp = xstrdup(*(dir->name_map + (index___0 + 1UL)));
        }
#line 1478
        return (tmp);
      }
#line 1476
      index___0 += 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1480
    tmp___1 = strchr(fname, '/');
#line 1480
    p = (char const   *)tmp___1;
    }
#line 1481
    if (! p) {
#line 1482
      return ((char *)((void *)0));
    } else
#line 1481
    if ((unsigned long )p == (unsigned long )fname) {
#line 1482
      return ((char *)((void *)0));
    }
    {
#line 1484
    len = (size_t )((long )dir->len + ((p - fname) + 1L));
#line 1485
    tmp___2 = xmalloc(sizeof(char ) * (len + 1UL));
#line 1485
    new_dir = (char *)tmp___2;
#line 1486
    memcpy((void */* __restrict  */)new_dir, (void const   */* __restrict  */)dir->name,
           (size_t )dir->len);
#line 1487
    memcpy((void */* __restrict  */)(new_dir + dir->len), (void const   */* __restrict  */)fname,
           (size_t )((p - fname) + 1L));
#line 1488
    *(new_dir + len) = (char )'\000';
#line 1490
    dir = make_cpp_dir(pfile, (char const   *)new_dir, (int )dir->sysp);
#line 1491
    fname = p + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1496 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char validate_pch(cpp_reader *pfile , _cpp_file *file , char const   *pchname ) 
{ 
  char const   *saved_path ;
  unsigned char valid ;
  int tmp ;
  unsigned int i ;
  int tmp___0 ;
  unsigned char tmp___1 ;

  {
  {
#line 1499
  saved_path = file->path;
#line 1500
  valid = (unsigned char)0;
#line 1502
  file->path = pchname;
#line 1503
  tmp___1 = open_file(file);
  }
#line 1503
  if (tmp___1) {
    {
#line 1505
    tmp = (*(pfile->cb.valid_pch))(pfile, pchname, file->fd);
#line 1505
    valid = (unsigned char )(1 & tmp);
    }
#line 1507
    if (! valid) {
      {
#line 1509
      close(file->fd);
#line 1510
      file->fd = -1;
      }
    }
#line 1513
    if (pfile->opts.print_include_names) {
#line 1516
      i = 1U;
      {
#line 1516
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1516
        if (! (i < (pfile->line_table)->depth)) {
#line 1516
          goto while_break;
        }
        {
#line 1517
        putc_unlocked('.', stderr);
#line 1516
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1518
      if (valid) {
#line 1518
        tmp___0 = '!';
      } else {
#line 1518
        tmp___0 = 'x';
      }
      {
#line 1518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c %s\n",
              tmp___0, pchname);
      }
    }
  }
#line 1523
  file->path = saved_path;
#line 1524
  return (valid);
}
}
#line 1531 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
char const   *cpp_get_path(struct _cpp_file *f ) 
{ 


  {
#line 1534
  return (f->path);
}
}
#line 1539 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
cpp_dir *cpp_get_dir(struct _cpp_file *f ) 
{ 


  {
#line 1542
  return (f->dir);
}
}
#line 1548 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
cpp_buffer *cpp_get_buffer(cpp_reader *pfile ) 
{ 


  {
#line 1551
  return (pfile->buffer);
}
}
#line 1556 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
struct _cpp_file *cpp_get_file(cpp_buffer *b ) 
{ 


  {
#line 1559
  return (b->file);
}
}
#line 1565 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
cpp_buffer *cpp_get_prev(cpp_buffer *b ) 
{ 


  {
#line 1568
  return (b->prev);
}
}
#line 1600 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static struct pchf_data *pchf  ;
#line 1604 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static int pchf_save_compare(void const   *e1 , void const   *e2 ) 
{ 
  int tmp ;

  {
  {
#line 1607
  tmp = memcmp(e1, e2, sizeof(struct pchf_entry ));
  }
#line 1607
  return (tmp);
}
}
#line 1612 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char _cpp_save_file_entries(cpp_reader *pfile , FILE *fp ) 
{ 
  size_t count ;
  struct pchf_data *result ;
  size_t result_size ;
  _cpp_file *f ;
  void *tmp ;
  size_t count___0 ;
  size_t tmp___0 ;
  FILE *ff ;
  int oldfd ;
  unsigned char tmp___1 ;
  size_t tmp___2 ;

  {
#line 1615
  count = (size_t )0;
#line 1620
  f = pfile->all_files;
  {
#line 1620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1620
    if (! f) {
#line 1620
      goto while_break;
    }
#line 1621
    count ++;
#line 1620
    f = f->next_file;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1623
  result_size = sizeof(struct pchf_data ) + sizeof(struct pchf_entry ) * (count - 1UL);
#line 1625
  tmp = xcalloc((size_t )1, result_size);
#line 1625
  result = (struct pchf_data *)tmp;
#line 1627
  result->count = (size_t )0;
#line 1628
  result->have_once_only = (unsigned char)0;
#line 1630
  f = pfile->all_files;
  }
  {
#line 1630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1630
    if (! f) {
#line 1630
      goto while_break___0;
    }
#line 1636
    if (f->dont_read) {
#line 1637
      goto __Cont;
    } else
#line 1636
    if (f->err_no) {
#line 1637
      goto __Cont;
    }
#line 1639
    if ((int )f->stack_count == 0) {
#line 1640
      goto __Cont;
    }
#line 1642
    tmp___0 = result->count;
#line 1642
    (result->count) ++;
#line 1642
    count___0 = tmp___0;
#line 1644
    result->entries[count___0].once_only = f->once_only;
#line 1646
    result->have_once_only = (unsigned char )((int )result->have_once_only | (int )f->once_only);
#line 1647
    if (f->buffer_valid) {
      {
#line 1648
      md5_buffer((char const   *)f->buffer, (size_t )f->st.st_size, (void *)(result->entries[count___0].sum));
      }
    } else {
      {
#line 1653
      oldfd = f->fd;
#line 1655
      tmp___1 = open_file(f);
      }
#line 1655
      if (! tmp___1) {
        {
#line 1657
        open_file_failed(pfile, f, 0);
        }
#line 1658
        return ((unsigned char)0);
      }
      {
#line 1660
      ff = fdopen_unlocked(f->fd, "rb");
#line 1661
      md5_stream(ff, (void *)(result->entries[count___0].sum));
#line 1662
      fclose(ff);
#line 1663
      f->fd = oldfd;
      }
    }
#line 1665
    result->entries[count___0].size = f->st.st_size;
    __Cont: /* CIL Label */ 
#line 1630
    f = f->next_file;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1668
  result_size = sizeof(struct pchf_data ) + sizeof(struct pchf_entry ) * (result->count - 1UL);
#line 1671
  qsort((void *)(result->entries), result->count, sizeof(struct pchf_entry ), & pchf_save_compare);
#line 1674
  tmp___2 = fwrite_unlocked((void const   */* __restrict  */)result, result_size,
                            (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 1674
  return ((unsigned char )(tmp___2 == 1UL));
}
}
#line 1679 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
unsigned char _cpp_read_file_entries(cpp_reader *pfile  __attribute__((__unused__)) ,
                                     FILE *f ) 
{ 
  struct pchf_data d ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1684
  tmp = fread_unlocked((void */* __restrict  */)(& d), sizeof(struct pchf_data ) - sizeof(struct pchf_entry ),
                       (size_t )1, (FILE */* __restrict  */)f);
  }
#line 1684
  if (tmp != 1UL) {
#line 1686
    return ((unsigned char)0);
  }
  {
#line 1688
  tmp___0 = xmalloc(sizeof(struct pchf_data ) + sizeof(struct pchf_entry ) * (d.count - 1UL));
#line 1688
  pchf = (struct pchf_data *)tmp___0;
#line 1690
  memcpy((void */* __restrict  */)pchf, (void const   */* __restrict  */)(& d), sizeof(struct pchf_data ) - sizeof(struct pchf_entry ));
#line 1691
  tmp___1 = fread_unlocked((void */* __restrict  */)(pchf->entries), sizeof(struct pchf_entry ),
                           d.count, (FILE */* __restrict  */)f);
  }
#line 1691
  if (tmp___1 != d.count) {
#line 1693
    return ((unsigned char)0);
  }
#line 1694
  return ((unsigned char)1);
}
}
#line 1719 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static int pchf_compare(void const   *d_p , void const   *e_p ) 
{ 
  struct pchf_entry  const  *e ;
  struct pchf_compare_data *d ;
  int result ;
  _cpp_file *f ;

  {
  {
#line 1722
  e = (struct pchf_entry  const  *)e_p;
#line 1723
  d = (struct pchf_compare_data *)d_p;
#line 1726
  result = memcmp((void const   *)(& d->size), (void const   *)(& e->size), sizeof(off_t ));
  }
#line 1727
  if (result != 0) {
#line 1728
    return (result);
  }
#line 1730
  if (! d->sum_computed) {
    {
#line 1732
    f = d->f;
#line 1734
    md5_buffer((char const   *)f->buffer, (size_t )f->st.st_size, (void *)(d->sum));
#line 1735
    d->sum_computed = (unsigned char)1;
    }
  }
  {
#line 1738
  result = memcmp((void const   *)(d->sum), (void const   *)(e->sum), (size_t )16);
  }
#line 1739
  if (result != 0) {
#line 1740
    return (result);
  }
#line 1742
  if (d->check_included) {
#line 1743
    return (0);
  } else
#line 1742
  if (e->once_only) {
#line 1743
    return (0);
  } else {
#line 1745
    return (1);
  }
}
}
#line 1752 "/home/wheatley/newnew/temp/nescc-1.3.4/libcpp/files.c"
static unsigned char check_file_against_entries(cpp_reader *pfile  __attribute__((__unused__)) ,
                                                _cpp_file *f , unsigned char check_included ) 
{ 
  struct pchf_compare_data d ;
  void *tmp ;

  {
#line 1759
  if ((unsigned long )pchf == (unsigned long )((void *)0)) {
#line 1761
    return ((unsigned char)0);
  } else
#line 1759
  if (! check_included) {
#line 1759
    if (! pchf->have_once_only) {
#line 1761
      return ((unsigned char)0);
    }
  }
  {
#line 1763
  d.size = f->st.st_size;
#line 1764
  d.sum_computed = (unsigned char)0;
#line 1765
  d.f = f;
#line 1766
  d.check_included = check_included;
#line 1767
  tmp = bsearch((void const   *)(& d), (void const   *)(pchf->entries), pchf->count,
                sizeof(struct pchf_entry ), & pchf_compare);
  }
#line 1767
  return ((unsigned char )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
#line 74 "./libcompat/regions.h"
extern char *rstrdup(region r , char const   *s ) ;
#line 231 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type type_default_conversion(type from ) ;
#line 1769 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
variable_decl new_variable_decl(region r , location location___0 , declarator declarator___0 ,
                                attribute attributes , expression arg1 , asm_stmt asm_stmt___0 ,
                                data_declaration ddecl ) ;
#line 1824
string_cst new_string_cst(region r , location location___0 , cstring cstring___0 ) ;
#line 1825
string new_string(region r , location location___0 , string_cst strings , data_declaration ddecl ) ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.h"
data_decl build_declaration(region r , struct environment *e , type t , char const   *name ,
                            expression init , data_declaration *oddecl ) ;
#line 37
data_declaration add_temporary(region r , compound_stmt block , type t ) ;
#line 39
word build_word(region r , char const   *cword ) ;
#line 41
expression build_string(region r , location loc , char const   *str ) ;
#line 42
expression build_function_call(region r , location loc , expression fn , expression arglist ) ;
#line 166 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern void init_data_declaration(data_declaration dd , declaration ast , char const   *name ,
                                  type t ) ;
#line 168
extern data_declaration declare(environment env , data_declaration from , bool ignore_shadow ) ;
#line 172
extern data_declaration declare_string(char const   *name , cstring value , bool wide ) ;
#line 67 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
known_cst foldaddress_string(string s ) ;
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
data_decl build_declaration(region r , struct environment *e , type t , char const   *name ,
                            expression init , data_declaration *oddecl ) 
{ 
  struct data_declaration tempdecl ;
  identifier_declarator id ;
  variable_decl vd ;
  data_decl dd ;
  declarator tdeclarator ;
  type_element tmodifiers ;
  type tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  cstring tmp___2 ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  data_declaration tmp___3 ;

  {
  {
#line 47
  tmp___1 = type_array(t);
  }
#line 47
  if (tmp___1) {
    {
#line 48
    tmp = type_array_of(t);
#line 48
    t = make_pointer_type(tmp);
    }
  } else {
    {
#line 49
    tmp___0 = type_function(t);
    }
#line 49
    if (tmp___0) {
      {
#line 50
      t = make_pointer_type(t);
      }
    }
  }
  {
#line 53
  t = make_qualified_type(t, (type_quals )0);
#line 56
  tmp___2 = str2cstring(r, name);
#line 56
  id = new_identifier_declarator(r, dummy_location, tmp___2);
#line 57
  tEmPcast = (AST_generic )id;
  }
#line 57
  if (tEmPcast) {
#line 57
    if ((unsigned int )tEmPcast->kind >= 175U) {
#line 57
      if (! ((unsigned int )tEmPcast->kind <= 183U)) {
        {
#line 57
        __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 57U, "build_declaration");
        }
      }
    } else {
      {
#line 57
      __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 57U, "build_declaration");
      }
    }
  }
  {
#line 57
  type2ast(r, dummy_location, t, (declarator )tEmPcast, & tdeclarator, & tmodifiers);
#line 58
  vd = new_variable_decl(r, dummy_location, tdeclarator, (attribute )((void *)0),
                         init, (asm_stmt )((void *)0), (data_declaration )((void *)0));
#line 59
  vd->declared_type = t;
#line 60
  tEmPcast___0 = (AST_generic )vd;
  }
#line 60
  if (tEmPcast___0) {
#line 60
    if ((unsigned int )tEmPcast___0->kind >= 43U) {
#line 60
      if (! ((unsigned int )tEmPcast___0->kind <= 64U)) {
        {
#line 60
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 60U, "build_declaration");
        }
      }
    } else {
      {
#line 60
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 60U, "build_declaration");
      }
    }
  }
  {
#line 60
  dd = new_data_decl(r, dummy_location, tmodifiers, (declaration )tEmPcast___0);
  }
#line 62
  if (e) {
#line 64
    tEmPcast___1 = (AST_generic )vd;
#line 64
    if (tEmPcast___1) {
#line 64
      if ((unsigned int )tEmPcast___1->kind >= 43U) {
#line 64
        if (! ((unsigned int )tEmPcast___1->kind <= 64U)) {
          {
#line 64
          __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 64U,
                        "build_declaration");
          }
        }
      } else {
        {
#line 64
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 64U, "build_declaration");
        }
      }
    }
    {
#line 64
    init_data_declaration(& tempdecl, (declaration )tEmPcast___1, (char const   *)id->cstring.data,
                          t);
#line 65
    tempdecl.kind = (data_kind )0;
#line 66
    tempdecl.vtype = (enum __anonenum_vtype_42 )2;
#line 67
    tempdecl.islocal = (bool )1;
#line 68
    tmp___3 = declare(e, & tempdecl, (bool )0);
#line 68
    vd->ddecl = tmp___3;
#line 68
    *oddecl = tmp___3;
    }
  }
#line 71
  return (dd);
}
}
#line 78
char *next_temporary(void) ;
#line 78 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
static long nextid  =    42L;
#line 79 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
static char idname[32UL]  ;
#line 76 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
char *next_temporary(void) 
{ 
  long tmp ;

  {
  {
#line 81
  tmp = nextid;
#line 81
  nextid ++;
#line 81
  sprintf((char */* __restrict  */)(idname), (char const   */* __restrict  */)"__nesc_temp%ld",
          tmp);
  }
#line 83
  return (idname);
}
}
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
data_declaration add_temporary(region r , compound_stmt block , type t ) 
{ 
  char const   *name ;
  char *tmp ;
  data_decl dd ;
  data_decl tmp___0 ;
  struct data_declaration tempdecl ;
  data_declaration ddecl ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  char *tmp___1 ;
  AST_generic tEmPcast___1 ;

  {
  {
#line 91
  tmp = next_temporary();
#line 91
  name = (char const   *)tmp;
#line 92
  tmp___0 = build_declaration(r, (struct environment *)((void *)0), t, name, (expression )((void *)0),
                              (data_declaration *)((void *)0));
#line 92
  dd = tmp___0;
#line 97
  tEmPcast = (AST_generic )block->decls;
  }
#line 97
  if (tEmPcast) {
#line 97
    if ((unsigned int )tEmPcast->kind >= 42U) {
#line 97
      if (! ((unsigned int )tEmPcast->kind <= 199U)) {
        {
#line 97
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 97U, "add_temporary");
        }
      }
    } else {
      {
#line 97
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 97U, "add_temporary");
      }
    }
  }
#line 97
  dd->next = (node )tEmPcast;
#line 98
  tEmPcast___0 = (AST_generic )dd;
#line 98
  if (tEmPcast___0) {
#line 98
    if ((unsigned int )tEmPcast___0->kind >= 43U) {
#line 98
      if (! ((unsigned int )tEmPcast___0->kind <= 64U)) {
        {
#line 98
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 98U, "add_temporary");
        }
      }
    } else {
      {
#line 98
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 98U, "add_temporary");
      }
    }
  }
  {
#line 98
  block->decls = (declaration )tEmPcast___0;
#line 110
  tmp___1 = rstrdup(r, name);
#line 110
  init_data_declaration(& tempdecl, dd->decls, (char const   *)tmp___1, t);
#line 111
  tempdecl.kind = (data_kind )0;
#line 112
  tempdecl.vtype = (enum __anonenum_vtype_42 )2;
#line 113
  tempdecl.islocal = (bool )1;
#line 114
  ddecl = declare(block->env, & tempdecl, (bool )0);
#line 115
  tEmPcast___1 = (AST_generic )dd->decls;
  }
#line 115
  if (tEmPcast___1) {
#line 115
    if ((unsigned int )tEmPcast___1->kind >= 52U) {
#line 115
      if (! ((unsigned int )tEmPcast___1->kind <= 52U)) {
        {
#line 115
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 115U, "add_temporary");
        }
      }
    } else {
      {
#line 115
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 115U, "add_temporary");
      }
    }
  }
#line 115
  ((variable_decl )tEmPcast___1)->ddecl = ddecl;
#line 117
  return (ddecl);
}
}
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
word build_word(region r , char const   *cword ) 
{ 
  cstring tmp ;
  word tmp___0 ;

  {
  {
#line 122
  tmp = str2cstring(r, cword);
#line 122
  tmp___0 = new_word(r, dummy_location, tmp);
  }
#line 122
  return (tmp___0);
}
}
#line 125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
expression build_string(region r , location loc , char const   *str ) 
{ 
  string_cst elems ;
  cstring tmp ;
  string_cst tmp___0 ;
  data_declaration sdecl ;
  cstring tmp___1 ;
  data_declaration tmp___2 ;
  string s ;
  string tmp___3 ;
  AST_generic tEmPcast ;

  {
  {
#line 127
  tmp = str2cstring(r, "oops");
#line 127
  tmp___0 = new_string_cst(r, loc, tmp);
#line 127
  elems = tmp___0;
#line 128
  tmp___1 = str2cstring(r, str);
#line 128
  tmp___2 = declare_string((char const   *)((void *)0), tmp___1, (bool )0);
#line 128
  sdecl = tmp___2;
#line 129
  tmp___3 = new_string(r, loc, elems, sdecl);
#line 129
  s = tmp___3;
#line 131
  s->type = sdecl->type;
#line 132
  s->static_address = foldaddress_string(s);
#line 133
  s->lvalue = (bool )1;
#line 135
  tEmPcast = (AST_generic )s;
  }
#line 135
  if (tEmPcast) {
#line 135
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 135
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 135
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 135U, "build_string");
        }
      }
    } else {
      {
#line 135
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 135U, "build_string");
      }
    }
  }
#line 135
  return ((expression )tEmPcast);
}
}
#line 138 "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c"
expression build_function_call(region r , location loc , expression fn , expression arglist ) 
{ 
  expression result ;
  AST_generic tEmPcast ;
  function_call tmp ;
  type fntype ;
  type tmp___0 ;
  type rettype ;
  bool tmp___1 ;

  {
  {
#line 141
  tmp = new_function_call(r, loc, fn, arglist, (asttype )((void *)0), (nesc_call_kind )3);
#line 141
  tEmPcast = (AST_generic )tmp;
  }
#line 141
  if (tEmPcast) {
#line 141
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 141
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 141U, "build_function_call");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/edit.c", 141U, "build_function_call");
      }
    }
  }
  {
#line 141
  result = (expression )tEmPcast;
#line 142
  tmp___0 = type_default_conversion(fn->type);
#line 142
  fntype = tmp___0;
#line 144
  tmp___1 = type_pointer(fntype);
  }
#line 144
  if (tmp___1) {
    {
#line 147
    fntype = type_points_to(fntype);
    }
  }
  {
#line 149
  rettype = type_function_return_type(fntype);
#line 150
  result->type = rettype;
#line 151
  result->cst = fold_function_call(result, 0);
  }
#line 153
  return (result);
}
}
#line 54 "/home/wheatley/newnew/temp/nescc-1.3.4/src/utils.h"
extern unsigned long hash_ptr(void *p ) ;
#line 57
extern unsigned long hash_str(char const   * ) ;
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.h"
env new_env(region r , env parent ) ;
#line 38
env env_parent(env e ) ;
#line 41
region env_region(env e ) ;
#line 58
void env_scan(env e , env_scanner *scanner ) ;
#line 59
bool env_next(env_scanner *scanner , char const   **name , void **value ) ;
#line 42 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
static int env_compare(void *entry1 , void *entry2 ) 
{ 
  struct entry *e1 ;
  struct entry *e2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 44
  e1 = (struct entry *)entry1;
#line 44
  e2 = (struct entry *)entry2;
#line 46
  if (e1->name) {
#line 46
    if (e2->name) {
      {
#line 46
      tmp = strcmp(e1->name, e2->name);
      }
#line 46
      if (tmp == 0) {
#line 46
        tmp___0 = 1;
      } else {
#line 46
        tmp___0 = 0;
      }
    } else {
#line 46
      tmp___0 = 0;
    }
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
}
}
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
static unsigned long env_hash(void *entry ) 
{ 
  struct entry *e ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 51
  e = (struct entry *)entry;
#line 53
  if (e->name) {
    {
#line 54
    tmp = hash_str(e->name);
    }
#line 54
    return (tmp);
  } else {
    {
#line 56
    tmp___0 = hash_ptr((void *)e);
    }
#line 56
    return (tmp___0);
  }
}
}
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
env new_env(region r , env parent ) 
{ 
  env e ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 63
  if (sizeof(struct env ) < (unsigned long )(1 << 9)) {
    {
#line 63
    tmp = __rcralloc_small0(r, sizeof(struct env ));
#line 63
    tmp___1 = tmp;
    }
  } else {
    {
#line 63
    tmp___0 = typed_ralloc(r, sizeof(struct env ), 0);
#line 63
    tmp___1 = tmp___0;
    }
  }
  {
#line 63
  e = (env )tmp___1;
#line 65
  e->r = r;
#line 66
  e->parent = parent;
#line 67
  e->table = new_dhash_table(r, 16UL, & env_compare, & env_hash);
  }
#line 69
  return (e);
}
}
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
env env_parent(env e ) 
{ 


  {
#line 75
  return (e->parent);
}
}
#line 79 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
region env_region(env e ) 
{ 


  {
#line 81
  return (e->r);
}
}
#line 87 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
void *env_lookup(env e , char const   *s , bool this_level_only ) 
{ 
  struct entry lookup ;
  struct entry *found ;
  void *tmp ;

  {
#line 91
  lookup.name = s;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp = dhlookup(e->table, (void *)(& lookup));
#line 94
    found = (struct entry *)tmp;
    }
#line 95
    if (found) {
#line 96
      return (found->value);
    }
#line 97
    if (this_level_only) {
#line 98
      return ((void *)0);
    } else
#line 97
    if (! e->parent) {
#line 98
      return ((void *)0);
    }
#line 99
    e = e->parent;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 106 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
void env_add(env e , char const   *s , void *value ) 
{ 
  struct entry *newe ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 108
  if (sizeof(struct entry ) < (unsigned long )(1 << 9)) {
    {
#line 108
    tmp = __rcralloc_small0(e->r, sizeof(struct entry ));
#line 108
    tmp___1 = tmp;
    }
  } else {
    {
#line 108
    tmp___0 = typed_ralloc(e->r, sizeof(struct entry ), 0);
#line 108
    tmp___1 = tmp___0;
    }
  }
  {
#line 108
  newe = (struct entry *)tmp___1;
#line 110
  newe->name = s;
#line 111
  newe->value = value;
#line 112
  dhadd(e->table, (void *)newe);
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
void env_scan(env e , env_scanner *scanner ) 
{ 


  {
  {
#line 117
  *scanner = dhscan(e->table);
  }
#line 118
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/env.c"
bool env_next(env_scanner *scanner , char const   **name , void **value ) 
{ 
  struct entry *next ;
  void *tmp ;

  {
  {
#line 122
  tmp = dhnext(scanner);
#line 122
  next = (struct entry *)tmp;
  }
#line 123
  if (! next) {
#line 124
    return ((bool )0);
  }
#line 126
  *name = next->name;
#line 127
  *value = next->value;
#line 129
  return ((bool )1);
}
}
#line 44 "./libcompat/regions.h"
extern region permanent ;
#line 72
extern char *rstralloc(region r , size_t size ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cstring.h"
extern cstring make_cstring(region r , char const   *s , int l ) ;
#line 40
extern cstring alloc_cstring(region r , int l ) ;
#line 31 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.h"
struct array *new_array(region r , size_t initialsize , size_t typesize , type_t typeinfo ) ;
#line 33
void *array_extend(struct array *a , int by ) ;
#line 34
void array_reset(struct array *a ) ;
#line 35
size_t array_length(struct array *a ) ;
#line 36
void *array_data(struct array *a ) ;
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/utils.h"
extern char_array new_char_array(region r , size_t initialsize ) ;
#line 45
extern char *char_array_extend(char_array a , int by ) ;
#line 45
extern void char_array_reset(char_array a ) ;
#line 45
extern size_t char_array_length(char_array a ) ;
#line 45
extern char *char_array_data(char_array a ) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
location dummy_location  ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.h"
location toplevel_location  ;
#line 39
location new_location(char const   *filename , int lineno ) ;
#line 40
location make_location(struct location l ) ;
#line 41
void set_lex_location(location loc ) ;
#line 42
location last_location(void) ;
#line 82
void init_lex(void) ;
#line 83
bool start_lex(source_language l , char const   *path ) ;
#line 84
void start_lex_string(source_language l , char const   *string___0 ) ;
#line 85
void end_lex(void) ;
#line 95
bool get_raw_docstring(char const   **docs , location *docl ) ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type float_type ;
#line 50
extern type long_double_type ;
#line 50
extern type long_type ;
#line 50
extern type unsigned_long_type ;
#line 50
extern type long_long_type ;
#line 50
extern type unsigned_long_long_type ;
#line 50
extern type wchar_type ;
#line 81
extern type make_complex_type(type t ) ;
#line 128
extern largest_uint type_size_int(type t ) ;
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_pedantic_errors ;
#line 41
int inhibit_warnings ;
#line 47
int warnings_are_errors ;
#line 138
int warn_traditional ;
#line 153
int warn_multichar ;
#line 189
int flag_signed_char ;
#line 226
int warn_unexpected_docstring ;
#line 262
int warn_comments ;
#line 266
int warn_trigraphs ;
#line 269
int warn_unused_macros ;
#line 272
int warn_endif_labels ;
#line 275
int warn_system_headers ;
#line 278
int warn_undef ;
#line 281
int warn_missing_include_dirs ;
#line 287
int flag_trigraphs ;
#line 311
int print_include_names ;
#line 6 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex-state.h"
int input_file_stack_tick  ;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
lexical_cst fold_lexical_real(type realtype , location loc , cstring tok ) ;
#line 49
lexical_cst fold_lexical_char(location loc , cstring tok , bool wide_flag , int charvalue ) ;
#line 51
string fold_lexical_string(location loc , string_cst components , cstring value ,
                           bool wide_flag ) ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-cpp.h"
extern void start_macro_saving(void) ;
#line 35
extern void save_pp_token(struct cpp_token  const  *tok ) ;
#line 36
extern void save_pp_line_change(struct cpp_reader *pfile , struct cpp_token  const  *token ) ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-paths.h"
extern void set_cpp_include_path(void) ;
#line 106 "./../libcpp/include/line-map.h"
extern void linemap_init(struct line_maps * ) ;
#line 135
extern struct line_map  const  *linemap_add(struct line_maps * , enum lc_reason  ,
                                            unsigned int sysp , char const   *to_file ,
                                            unsigned int to_line ) ;
#line 141
extern struct line_map  const  *linemap_lookup(struct line_maps * , source_location  ) ;
#line 624 "./../libcpp/include/cpplib.h"
extern cpp_reader *cpp_create_reader(enum c_lang  , struct ht * , struct line_maps * ) ;
#line 644
extern cpp_callbacks *cpp_get_callbacks(cpp_reader * ) ;
#line 653
extern char const   *cpp_read_main_file(cpp_reader * , char const   * ) ;
#line 657
extern void cpp_init_special_builtins(cpp_reader * ) ;
#line 667
extern void cpp_init_iconv(cpp_reader * ) ;
#line 674
extern int cpp_finish(cpp_reader * , FILE *deps_stream ) ;
#line 679
extern void cpp_destroy(cpp_reader * ) ;
#line 684
extern unsigned int cpp_token_len(cpp_token const   * ) ;
#line 685
extern unsigned char *cpp_token_as_text(cpp_reader * , cpp_token const   * ) ;
#line 686
extern unsigned char *cpp_spell_token(cpp_reader * , cpp_token const   * , unsigned char * ,
                                      unsigned char  ) ;
#line 694
extern cpp_token const   *cpp_get_token(cpp_reader * ) ;
#line 699
extern void _cpp_backup_tokens(cpp_reader * , unsigned int  ) ;
#line 702
extern cppchar_t cpp_interpret_charconst(cpp_reader * , cpp_token const   * , unsigned int * ,
                                         int * ) ;
#line 705
extern unsigned char cpp_interpret_string(cpp_reader * , cpp_string const   * , size_t  ,
                                          cpp_string * , unsigned char  ) ;
#line 781
extern unsigned int cpp_classify_number(cpp_reader * , cpp_token const   * ) ;
#line 784
extern cpp_num cpp_interpret_integer(cpp_reader * , cpp_token const   * , unsigned int type ) ;
#line 789
extern cpp_num cpp_num_sign_extend(cpp_num  , size_t  ) ;
#line 40 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static char_array doc_string  ;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static location doc_location  ;
#line 43
string_array new_string_array(region r , size_t initialsize ) ;
#line 43
cpp_string *string_array_extend(string_array a , int by ) ;
#line 43
void string_array_reset(string_array a ) ;
#line 43
size_t string_array_length(string_array a ) ;
#line 43
cpp_string *string_array_data(string_array a ) ;
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
string_array new_string_array(region r , size_t initialsize ) 
{ 
  struct array *tmp ;

  {
  {
#line 44
  tmp = new_array(r, initialsize, sizeof(cpp_string ), 0);
  }
#line 44
  return ((string_array )tmp);
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
cpp_string *string_array_extend(string_array a , int by ) 
{ 
  void *tmp ;

  {
  {
#line 44
  tmp = array_extend((struct array *)a, by);
  }
#line 44
  return ((cpp_string *)tmp);
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void string_array_reset(string_array a ) 
{ 


  {
  {
#line 44
  array_reset((struct array *)a);
  }
#line 44
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
size_t string_array_length(string_array a ) 
{ 
  size_t tmp ;

  {
  {
#line 44
  tmp = array_length((struct array *)a);
  }
#line 44
  return (tmp);
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
cpp_string *string_array_data(string_array a ) 
{ 
  void *tmp ;

  {
  {
#line 44
  tmp = array_data((struct array *)a);
  }
#line 44
  return ((cpp_string *)tmp);
}
}
#line 45 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static string_array string_sequence  ;
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static cpp_token const   *last_token  ;
#line 55 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static location last_allocated_location  ;
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
location make_location(struct location l ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 59
  if (l.lineno == last_allocated_location->lineno) {
#line 59
    if ((unsigned long )l.filename == (unsigned long )last_allocated_location->filename) {
#line 59
      if ((unsigned long )l.container == (unsigned long )last_allocated_location->container) {
#line 59
        if ((int )l.in_system_header == (int )last_allocated_location->in_system_header) {
#line 63
          return (last_allocated_location);
        }
      }
    }
  }
#line 65
  if (sizeof(struct location ) < (unsigned long )(1 << 9)) {
    {
#line 65
    tmp = __rcralloc_small0(parse_region, sizeof(struct location ));
#line 65
    last_allocated_location = (location )tmp;
    }
  } else {
    {
#line 65
    tmp___0 = typed_ralloc(parse_region, sizeof(struct location ), 0);
#line 65
    last_allocated_location = (location )tmp___0;
    }
  }
#line 66
  *last_allocated_location = l;
#line 68
  return (last_allocated_location);
}
}
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
location new_location(char const   *filename , int lineno ) 
{ 
  location l ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 73
  if (sizeof(struct location ) < (unsigned long )(1 << 9)) {
    {
#line 73
    tmp = __rcralloc_small0(parse_region, sizeof(struct location ));
#line 73
    tmp___1 = tmp;
    }
  } else {
    {
#line 73
    tmp___0 = typed_ralloc(parse_region, sizeof(struct location ), 0);
#line 73
    tmp___1 = tmp___0;
    }
  }
#line 73
  l = (location )tmp___1;
#line 75
  l->filename = filename;
#line 76
  l->lineno = (unsigned long )lineno;
#line 77
  l->in_system_header = (bool )0;
#line 79
  return (l);
}
}
#line 82 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void set_lex_location(location loc ) 
{ 
  struct line_map  const  *new_line ;

  {
  {
#line 86
  new_line = linemap_add(current.lex.line_map, (enum lc_reason )2, 0U, loc->filename,
                         (unsigned int )loc->lineno);
#line 88
  (current.lex.input)->l = *loc;
  }
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
location last_location(void) 
{ 
  location tmp ;

  {
  {
#line 93
  tmp = make_location((current.lex.input)->l);
  }
#line 93
  return (tmp);
}
}
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void push_input(void) 
{ 
  struct file_stack *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 100
  if (sizeof(struct file_stack ) < (unsigned long )(1 << 9)) {
    {
#line 100
    tmp = __rcralloc_small0(current.fileregion, sizeof(struct file_stack ));
#line 100
    tmp___1 = tmp;
    }
  } else {
    {
#line 100
    tmp___0 = typed_ralloc(current.fileregion, sizeof(struct file_stack ), 0);
#line 100
    tmp___1 = tmp___0;
    }
  }
#line 100
  p = (struct file_stack *)tmp___1;
#line 102
  p->next = current.lex.input;
#line 103
  p->l.filename = (char const   *)((void *)0);
#line 104
  p->l.lineno = 0UL;
#line 105
  p->l.in_system_header = (bool )0;
#line 106
  p->l.container = (struct nesc_declaration *)((void *)0);
#line 107
  current.lex.input = p;
#line 109
  input_file_stack_tick ++;
#line 110
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void pop_input(void) 
{ 


  {
#line 114
  current.lex.input = (current.lex.input)->next;
#line 115
  input_file_stack_tick ++;
#line 116
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void cb_file_change(cpp_reader *reader , struct line_map  const  *new_map ) 
{ 
  int included_at ;
  char *tmp ;

  {
#line 120
  if ((unsigned long )new_map == (unsigned long )((void *)0)) {
#line 121
    return;
  }
#line 123
  if ((unsigned int const   )new_map->reason == 0U) {
#line 125
    if (! (new_map->included_from < 0)) {
#line 127
      included_at = (int )(((((((((new_map - 1) + 1)->start_location - 1U) - (new_map - 1)->start_location) & (unsigned int const   )(~ ((1 << (new_map - 1)->column_bits) - 1))) + (new_map - 1)->start_location) - (new_map - 1)->start_location) >> (new_map - 1)->column_bits) + (new_map - 1)->to_line);
#line 128
      (current.lex.input)->l.lineno = (unsigned long )included_at;
    }
    {
#line 130
    push_input();
    }
  } else
#line 132
  if ((unsigned int const   )new_map->reason == 1U) {
    {
#line 133
    pop_input();
    }
  }
  {
#line 135
  (current.lex.input)->l.in_system_header = (bool )((int const   )new_map->sysp != 0);
#line 137
  tmp = rstrdup(permanent, (char const   *)new_map->to_file);
#line 137
  (current.lex.input)->l.filename = (char const   *)tmp;
#line 138
  (current.lex.input)->l.lineno = (unsigned long )new_map->to_line;
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void cb_line_change(cpp_reader *reader , cpp_token const   *token , int parsing_args ) 
{ 
  source_location loc ;
  struct line_map  const  *map ;
  struct line_map  const  *tmp ;

  {
#line 144
  if ((unsigned int const   )token->type != 22U) {
#line 144
    if (! parsing_args) {
      {
#line 146
      loc = (source_location )token->src_loc;
#line 147
      tmp = linemap_lookup(current.lex.line_map, loc);
#line 147
      map = tmp;
#line 149
      (current.lex.input)->l.lineno = (unsigned long )(((loc - (source_location )map->start_location) >> map->column_bits) + (source_location )map->to_line);
#line 151
      save_pp_line_change(reader, token);
      }
    }
  }
#line 153
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
__inline static unsigned int hash(char const   *str , unsigned int len ) ;
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
static unsigned char asso_values[256]  = 
#line 71
  {      (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)1, 
        (unsigned char)152,      (unsigned char)34,      (unsigned char)53,      (unsigned char)5, 
        (unsigned char)34,      (unsigned char)2,      (unsigned char)19,      (unsigned char)41, 
        (unsigned char)2,      (unsigned char)16,      (unsigned char)152,      (unsigned char)54, 
        (unsigned char)50,      (unsigned char)23,      (unsigned char)2,      (unsigned char)31, 
        (unsigned char)66,      (unsigned char)152,      (unsigned char)25,      (unsigned char)14, 
        (unsigned char)1,      (unsigned char)61,      (unsigned char)50,      (unsigned char)22, 
        (unsigned char)6,      (unsigned char)8,      (unsigned char)2,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152};
#line 60 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
__inline static unsigned int hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 100
  hval = (int )len;
  {
#line 111
  if (hval == 3) {
#line 111
    goto case_3;
  }
#line 111
  if (hval == 4) {
#line 111
    goto case_3;
  }
#line 111
  if (hval == 5) {
#line 111
    goto case_3;
  }
#line 111
  if (hval == 6) {
#line 111
    goto case_3;
  }
#line 111
  if (hval == 7) {
#line 111
    goto case_3;
  }
#line 115
  if (hval == 1) {
#line 115
    goto case_1;
  }
#line 115
  if (hval == 2) {
#line 115
    goto case_1;
  }
#line 104
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 105
  hval += (int )asso_values[(unsigned char )*(str + 7)];
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 112
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 116
  hval += (int )asso_values[(unsigned char )*(str + 0)];
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 119
  return ((unsigned int )(hval + (int )asso_values[(unsigned char )*(str + (len - 1U))]));
}
}
#line 122 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
static struct resword wordlist[152]  = 
#line 122
  {      {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"event", (short)261, (enum rid )276}, 
        {(char *)"extern", (short)261, (enum rid )16}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"const", (short)263, (enum rid )2}, 
        {(char *)"__const", (short)263, (enum rid )2}, 
        {(char *)"nx_union", (short)326, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__const__", (short)263, (enum rid )2}, 
        {(char *)"nx_struct", (short)325, (enum rid )0}, 
        {(char *)"continue", (short)282, (enum rid )0}, 
        {(char *)"__complex__", (short)262, (enum rid )10}, 
        {(char *)"int", (short)262, (enum rid )1}, 
        {(char *)"else", (short)274, (enum rid )0}, 
        {(char *)"__complex", (short)262, (enum rid )10}, 
        {(char *)"extends", (short)329, (enum rid )256}, 
        {(char *)"case", (short)279, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__imag__", (short)292, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__inline", (short)261, (enum rid )11}, 
        {(char *)"__inline__", (short)261, (enum rid )11}, 
        {(char *)"__extension__", (short)289, (enum rid )0}, 
        {(char *)"__typeof__", (short)286, (enum rid )0}, 
        {(char *)"interface", (short)311, (enum rid )0}, 
        {(char *)"return", (short)283, (enum rid )0}, 
        {(char *)"norace", (short)261, (enum rid )13}, 
        {(char *)"__real__", (short)291, (enum rid )0}, 
        {(char *)"if", (short)273, (enum rid )0}, 
        {(char *)"switch", (short)278, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"component", (short)328, (enum rid )0}, 
        {(char *)"sizeof", (short)269, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__asm__", (short)285, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"while", (short)275, (enum rid )0}, 
        {(char *)"struct", (short)271, (enum rid )0}, 
        {(char *)"configuration", (short)316, (enum rid )0}, 
        {(char *)"__typeof", (short)286, (enum rid )0}, 
        {(char *)"new", (short)324, (enum rid )256}, 
        {(char *)"as", (short)317, (enum rid )256}, 
        {(char *)"short", (short)262, (enum rid )7}, 
        {(char *)"async", (short)261, (enum rid )278}, 
        {(char *)"__restrict", (short)263, (enum rid )8}, 
        {(char *)"components", (short)312, (enum rid )256}, 
        {(char *)"generic", (short)323, (enum rid )0}, 
        {(char *)"float", (short)262, (enum rid )3}, 
        {(char *)"includes", (short)315, (enum rid )0}, 
        {(char *)"abstract", (short)327, (enum rid )256}, 
        {(char *)"static", (short)261, (enum rid )15}, 
        {(char *)"__signed__", (short)262, (enum rid )9}, 
        {(char *)"default", (short)280, (enum rid )0}, 
        {(char *)"__label__", (short)290, (enum rid )0}, 
        {(char *)"__asm", (short)285, (enum rid )0}, 
        {(char *)"__imag", (short)292, (enum rid )0}, 
        {(char *)"module", (short)314, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"do", (short)276, (enum rid )0}, 
        {(char *)"char", (short)262, (enum rid )2}, 
        {(char *)"command", (short)261, (enum rid )275}, 
        {(char *)"auto", (short)261, (enum rid )14}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"for", (short)277, (enum rid )0}, 
        {(char *)"task", (short)261, (enum rid )277}, 
        {(char *)"inline", (short)261, (enum rid )11}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"atomic", (short)309, (enum rid )0}, 
        {(char *)"goto", (short)284, (enum rid )0}, 
        {(char *)"__alignof__", (short)287, (enum rid )0}, 
        {(char *)"__volatile", (short)263, (enum rid )4}, 
        {(char *)"__volatile__", (short)263, (enum rid )4}, 
        {(char *)"uses", (short)310, (enum rid )256}, 
        {(char *)"__real", (short)291, (enum rid )0}, 
        {(char *)"asm", (short)285, (enum rid )0}, 
        {(char *)"union", (short)272, (enum rid )0}, 
        {(char *)"post", (short)322, (enum rid )256}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"enum", (short)270, (enum rid )0}, 
        {(char *)"__signed", (short)262, (enum rid )9}, 
        {(char *)"typeof", (short)286, (enum rid )0}, 
        {(char *)"typedef", (short)261, (enum rid )18}, 
        {(char *)"__alignof", (short)287, (enum rid )0}, 
        {(char *)"signed", (short)262, (enum rid )9}, 
        {(char *)"offsetof", (short)294, (enum rid )0}, 
        {(char *)"long", (short)262, (enum rid )8}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"implementation", (short)319, (enum rid )256}, 
        {(char *)"__attribute", (short)288, (enum rid )0}, 
        {(char *)"__attribute__", (short)288, (enum rid )0}, 
        {(char *)"double", (short)262, (enum rid )4}, 
        {(char *)"void", (short)262, (enum rid )5}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__builtin_offsetof", (short)294, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"call", (short)320, (enum rid )256}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"signal", (short)321, (enum rid )256}, 
        {(char *)"volatile", (short)263, (enum rid )4}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"break", (short)281, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"register", (short)261, (enum rid )17}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"__builtin_va_arg", (short)293, (enum rid )0}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"provides", (short)313, (enum rid )256}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"", (short)0, 0U}, 
        {(char *)"unsigned", (short)262, (enum rid )6}};
#line 238 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-gperf.h"
__inline struct resword  __attribute__((__gnu_inline__)) *is_reserved_word(char const   *str ,
                                                                           unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 248
  if (len <= 18U) {
#line 248
    if (len >= 2U) {
      {
#line 250
      tmp = hash(str, len);
#line 250
      key = (int )tmp;
      }
#line 252
      if (key <= 151) {
#line 252
        if (key >= 0) {
#line 254
          s = (char const   *)wordlist[key].name;
#line 256
          if ((int const   )*str == (int const   )*s) {
            {
#line 256
            tmp___0 = strcmp(str + 1, s + 1);
            }
#line 256
            if (! tmp___0) {
#line 257
              return ((struct resword  __attribute__((__gnu_inline__)) *)(& wordlist[key]));
            }
          }
        }
      }
    }
  }
#line 260
  return ((struct resword  __attribute__((__gnu_inline__)) *)0);
}
}
#line 162 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static struct location dummy  ;
#line 162 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static struct location toplevel  ;
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void init_lex(void) 
{ 


  {
  {
#line 164
  dummy.lineno = 0UL;
#line 165
  dummy.filename = "<dummy>";
#line 166
  dummy.in_system_header = (bool )0;
#line 167
  last_allocated_location = & dummy;
#line 167
  dummy_location = last_allocated_location;
#line 169
  toplevel.filename = "<commandline>";
#line 170
  toplevel.lineno = 0UL;
#line 171
  toplevel.in_system_header = (bool )0;
#line 172
  toplevel_location = & toplevel;
#line 174
  string_sequence = new_string_array(parse_region, (size_t )16);
#line 175
  doc_string = new_char_array(parse_region, (size_t )2048);
  }
#line 176
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static cpp_reader *current_reader(void) 
{ 


  {
#line 180
  return (current.lex.finput);
}
}
#line 183 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void start_lex_common(source_language l ) 
{ 
  cpp_options *cpp_opts ;
  cpp_callbacks *cpp_cbacks ;
  void *tmp ;
  void *tmp___0 ;
  cpp_reader *tmp___1 ;
  int tmp___2 ;
  cpp_reader *tmp___3 ;
  cpp_reader *tmp___4 ;
  cpp_reader *tmp___5 ;

  {
  {
#line 190
  if ((unsigned int )l == 2U) {
#line 190
    goto case_2;
  }
#line 190
  if ((unsigned int )l == 1U) {
#line 190
    goto case_2;
  }
#line 193
  if ((unsigned int )l == 0U) {
#line 193
    goto case_0;
  }
#line 196
  if ((unsigned int )l == 4U) {
#line 196
    goto case_4;
  }
#line 199
  if ((unsigned int )l == 5U) {
#line 199
    goto case_5;
  }
#line 202
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 191
  current.lex.token_s1 = 306;
#line 192
  goto switch_break;
  case_0: /* CIL Label */ 
#line 194
  current.lex.token_s1 = 305;
#line 195
  goto switch_break;
  case_4: /* CIL Label */ 
#line 197
  current.lex.token_s1 = 307;
#line 198
  goto switch_break;
  case_5: /* CIL Label */ 
#line 200
  current.lex.token_s1 = 308;
#line 201
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 203
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c", 203U, "start_lex_common");
  }
#line 204
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 206
  current.lex.token_s2 = -1;
#line 208
  if (sizeof(struct line_maps ) < (unsigned long )(1 << 9)) {
    {
#line 208
    tmp = __rcralloc_small0(current.fileregion, sizeof(struct line_maps ));
#line 208
    current.lex.line_map = (struct line_maps *)tmp;
    }
  } else {
    {
#line 208
    tmp___0 = typed_ralloc(current.fileregion, sizeof(struct line_maps ), 0);
#line 208
    current.lex.line_map = (struct line_maps *)tmp___0;
    }
  }
  {
#line 209
  linemap_init(current.lex.line_map);
#line 210
  (current.lex.line_map)->trace_includes = (unsigned char )print_include_names;
#line 211
  current.lex.finput = cpp_create_reader((enum c_lang )0, (struct ht *)((void *)0),
                                         current.lex.line_map);
#line 212
  current.lex.pp.outf = (FILE *)((void *)0);
#line 213
  tmp___1 = current_reader();
#line 213
  cpp_opts = cpp_get_options(tmp___1);
#line 214
  cpp_opts->discard_comments = (unsigned char)0;
#line 215
  cpp_opts->dollars_in_ident = (unsigned char)0;
#line 216
  cpp_opts->warn_long_long = (unsigned char)0;
#line 217
  cpp_opts->wchar_precision = 8UL * target->wchar_t_size;
#line 218
  cpp_opts->int_precision = 8UL * target->tint.size;
#line 219
  cpp_opts->precision = 8UL * target->tlong_long.size;
#line 220
  cpp_opts->unsigned_char = (unsigned char )(! flag_signed_char);
#line 221
  cpp_opts->unsigned_wchar = (unsigned char )(! target->wchar_t_signed);
#line 222
  cpp_opts->cplusplus_comments = (unsigned char)1;
#line 223
  cpp_opts->bytes_big_endian = target->big_endian;
#line 225
  cpp_opts->warnings_are_errors = (unsigned char )warnings_are_errors;
#line 226
  cpp_opts->inhibit_warnings = (unsigned char )inhibit_warnings;
#line 227
  cpp_opts->trigraphs = (unsigned char )flag_trigraphs;
#line 228
  cpp_opts->warn_comments = (unsigned char )warn_comments;
#line 229
  cpp_opts->warn_trigraphs = (unsigned char )warn_trigraphs;
#line 230
  cpp_opts->warn_unused_macros = (unsigned char )warn_unused_macros;
  }
#line 231
  if (warn_endif_labels) {
#line 231
    tmp___2 = 1;
  } else
#line 231
  if (pedantic) {
#line 231
    tmp___2 = 1;
  } else {
#line 231
    tmp___2 = 0;
  }
  {
#line 231
  cpp_opts->warn_endif_labels = (unsigned char )tmp___2;
#line 232
  cpp_opts->warn_system_headers = (unsigned char )warn_system_headers;
#line 233
  cpp_opts->warn_undef = (unsigned char )warn_undef;
#line 234
  cpp_opts->warn_missing_include_dirs = (unsigned char )warn_missing_include_dirs;
#line 235
  cpp_opts->warn_multichar = (unsigned char )warn_multichar;
#line 236
  cpp_opts->warn_traditional = (unsigned char )warn_traditional;
#line 237
  cpp_opts->pedantic_errors = (unsigned char )flag_pedantic_errors;
#line 238
  cpp_opts->pedantic = pedantic;
#line 239
  cpp_opts->print_include_names = (unsigned char )print_include_names;
#line 241
  tmp___3 = current_reader();
#line 241
  cpp_init_iconv(tmp___3);
#line 242
  tmp___4 = current_reader();
#line 242
  cpp_init_special_builtins(tmp___4);
#line 244
  tmp___5 = current_reader();
#line 244
  cpp_cbacks = cpp_get_callbacks(tmp___5);
#line 245
  cpp_cbacks->file_change = & cb_file_change;
#line 246
  cpp_cbacks->line_change = & cb_line_change;
#line 248
  set_cpp_include_path();
  }
#line 249
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void setup_macros(void) 
{ 
  struct line_map  const  *tmp ;
  cpp_reader *tmp___0 ;
  struct line_map  const  *tmp___1 ;
  cpp_reader *tmp___2 ;

  {
  {
#line 253
  tmp = linemap_add(current.lex.line_map, (enum lc_reason )0, 0U, "<built-in>", 0U);
#line 253
  tmp___0 = current_reader();
#line 253
  cb_file_change(tmp___0, tmp);
#line 256
  start_macro_saving();
#line 257
  tmp___1 = linemap_add(current.lex.line_map, (enum lc_reason )1, 0U, (char const   *)((void *)0),
                        0U);
#line 257
  tmp___2 = current_reader();
#line 257
  cb_file_change(tmp___2, tmp___1);
  }
#line 259
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
bool start_lex(source_language l , char const   *path ) 
{ 
  cpp_reader *tmp ;

  {
  {
#line 263
  start_lex_common(l);
#line 264
  tmp = current_reader();
#line 264
  path = cpp_read_main_file(tmp, path);
#line 265
  setup_macros();
  }
#line 267
  return ((bool )((unsigned long )path != (unsigned long )((void *)0)));
}
}
#line 270 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void start_lex_string(source_language l , char const   *string___0 ) 
{ 
  int slen ;
  size_t tmp ;
  char *scopy ;
  char *tmp___0 ;
  cpp_reader *tmp___1 ;

  {
  {
#line 272
  tmp = strlen(string___0);
#line 272
  slen = (int )tmp;
#line 273
  tmp___0 = rstralloc(current.fileregion, (size_t )(slen + 2));
#line 273
  scopy = tmp___0;
#line 276
  memcpy((void */* __restrict  */)scopy, (void const   */* __restrict  */)string___0,
         (size_t )slen);
#line 277
  *(scopy + slen) = (char )'\n';
#line 278
  *(scopy + (slen + 1)) = (char )'\000';
#line 280
  start_lex_common(l);
#line 281
  tmp___1 = current_reader();
#line 281
  cpp_push_buffer(tmp___1, (unsigned char const   *)scopy, (size_t )(slen + 1), 1);
#line 283
  setup_macros();
  }
#line 284
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void end_lex(void) 
{ 
  cpp_reader *tmp ;
  int tmp___0 ;
  cpp_reader *tmp___1 ;

  {
  {
#line 288
  tmp = current_reader();
#line 288
  tmp___0 = cpp_finish(tmp, (FILE *)((void *)0));
#line 288
  errorcount += tmp___0;
#line 289
  tmp___1 = current_reader();
#line 289
  cpp_destroy(tmp___1);
#line 290
  current.lex.finput = (struct cpp_reader *)((void *)0);
  }
#line 291
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static cstring make_token_cstring(cpp_token const   *token ) 
{ 
  unsigned int len ;
  unsigned int tmp ;
  cstring tokcs ;
  cstring tmp___0 ;
  unsigned char *end ;
  cpp_reader *tmp___1 ;

  {
  {
#line 295
  tmp = cpp_token_len(token);
#line 295
  len = tmp + 1U;
#line 296
  tmp___0 = alloc_cstring(parse_region, (int )len);
#line 296
  tokcs = tmp___0;
#line 299
  tmp___1 = current_reader();
#line 299
  end = cpp_spell_token(tmp___1, token, (unsigned char *)tokcs.data, (unsigned char)0);
#line 301
  *(end + 0) = (unsigned char )'\000';
#line 302
  tokcs.length = (int )((char *)end - tokcs.data);
  }
#line 304
  return (tokcs);
}
}
#line 307 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void handle_comment(cpp_token const   *token ) 
{ 
  cpp_string const   *comment ;
  bool new_docstring ;
  char *tmp ;
  location tmp___0 ;
  location tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 309
  comment = & token->val.str;
#line 310
  new_docstring = (bool )0;
#line 312
  tmp___3 = strncmp((char const   *)((char *)comment->text), "/**", (size_t )3);
  }
#line 312
  if (tmp___3) {
    {
#line 314
    tmp___2 = strncmp((char const   *)((char *)comment->text), "///", (size_t )3);
    }
#line 314
    if (! tmp___2) {
#line 316
      if (doc_location) {
        {
#line 316
        tmp___0 = last_location();
        }
#line 316
        if ((unsigned long )tmp___0->filename == (unsigned long )doc_location->filename) {
          {
#line 316
          tmp___1 = last_location();
          }
#line 316
          if (tmp___1->lineno + 1UL == doc_location->lineno) {
            {
#line 318
            tmp = char_array_extend(doc_string, (int )comment->len);
#line 318
            memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)comment->text,
                   (size_t )comment->len);
            }
          } else {
#line 321
            new_docstring = (bool )1;
          }
        } else {
#line 321
          new_docstring = (bool )1;
        }
      } else {
#line 321
        new_docstring = (bool )1;
      }
    }
  } else {
#line 313
    new_docstring = (bool )1;
  }
#line 324
  if (new_docstring) {
#line 326
    if (warn_unexpected_docstring) {
      {
#line 326
      tmp___4 = char_array_length(doc_string);
      }
#line 326
      if (tmp___4) {
        {
#line 327
        warning_with_location(doc_location, "discarding unexpected docstring");
        }
      }
    }
    {
#line 329
    char_array_reset(doc_string);
#line 330
    tmp___5 = char_array_extend(doc_string, (int )comment->len);
#line 330
    memcpy((void */* __restrict  */)tmp___5, (void const   */* __restrict  */)comment->text,
           (size_t )comment->len);
#line 332
    doc_location = last_location();
    }
  }
#line 334
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
bool get_raw_docstring(char const   **docs , location *docl ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 338
  tmp___1 = char_array_length(doc_string);
  }
#line 338
  if (tmp___1) {
    {
#line 340
    tmp = char_array_extend(doc_string, 1);
#line 340
    *tmp = (char )'\000';
#line 341
    tmp___0 = char_array_data(doc_string);
#line 341
    *docs = (char const   *)tmp___0;
#line 342
    *docl = doc_location;
#line 343
    char_array_reset(doc_string);
    }
#line 345
    return ((bool )1);
  } else {
#line 348
    return ((bool )0);
  }
}
}
#line 364 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void lex_string(cpp_token const   *tok , struct yystype *lvalp ) 
{ 
  cpp_token const   *first___0 ;
  bool wide ;
  location first_loc ;
  location tmp ;
  cpp_string istr ;
  cstring cstr ;
  string_cst string_components ;
  string_cst *next_sc ;
  string_cst one_string ;
  cstring tmp___0 ;
  location tmp___1 ;
  string_cst tmp___2 ;
  AST_generic *tEmPcast ;
  cpp_string *tmp___3 ;
  cpp_reader *tmp___4 ;
  cpp_reader *tmp___5 ;
  largest_uint tmp___6 ;
  largest_uint tmp___7 ;
  size_t tmp___8 ;
  cpp_string *tmp___9 ;
  cpp_reader *tmp___10 ;
  unsigned char tmp___11 ;

  {
  {
#line 366
  first___0 = tok;
#line 367
  wide = (bool )0;
#line 368
  tmp = last_location();
#line 368
  first_loc = tmp;
#line 371
  string_components = (string_cst )((void *)0);
#line 371
  next_sc = & string_components;
#line 374
  string_array_reset(string_sequence);
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 377
    tmp___0 = make_token_cstring(tok);
#line 377
    tmp___1 = last_location();
#line 377
    tmp___2 = new_string_cst(parse_region, tmp___1, tmp___0);
#line 377
    one_string = tmp___2;
#line 380
    *next_sc = one_string;
#line 381
    tEmPcast = (AST_generic *)(& one_string->next);
    }
#line 381
    if (tEmPcast) {
#line 381
      if (*tEmPcast) {
#line 381
        if ((unsigned int )(*tEmPcast)->kind >= 152U) {
#line 381
          if (! ((unsigned int )(*tEmPcast)->kind <= 152U)) {
            {
#line 381
            __assert_fail("((*tEmPcast)->kind >= kind_string_cst && (*tEmPcast)->kind <= postkind_string_cst)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c", 381U,
                          "lex_string");
            }
          }
        } else {
          {
#line 381
          __assert_fail("((*tEmPcast)->kind >= kind_string_cst && (*tEmPcast)->kind <= postkind_string_cst)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c", 381U,
                        "lex_string");
          }
        }
      }
    }
    {
#line 381
    next_sc = (string_cst *)tEmPcast;
#line 383
    tmp___3 = string_array_extend(string_sequence, 1);
#line 383
    *tmp___3 = (cpp_string )tok->val.str;
    }
#line 385
    if ((unsigned int const   )tok->type == 61U) {
#line 386
      wide = (bool )1;
    }
    retry: 
#line 389
    if ((unsigned long )tok != (unsigned long )first___0) {
      {
#line 390
      save_pp_token(tok);
      }
    }
    {
#line 391
    tmp___4 = current_reader();
#line 391
    tok = cpp_get_token(tmp___4);
    }
#line 392
    if ((unsigned int const   )tok->type == 68U) {
#line 393
      goto retry;
    }
#line 394
    if ((unsigned int const   )tok->type == 64U) {
      {
#line 396
      handle_comment(tok);
      }
#line 397
      goto retry;
    }
#line 375
    if (! ((unsigned int const   )tok->type == 60U)) {
#line 375
      if (! ((unsigned int const   )tok->type == 61U)) {
#line 375
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 403
  tmp___5 = current_reader();
#line 403
  _cpp_backup_tokens(tmp___5, 1U);
#line 405
  tmp___8 = string_array_length(string_sequence);
#line 405
  tmp___9 = string_array_data(string_sequence);
#line 405
  tmp___10 = current_reader();
#line 405
  tmp___11 = cpp_interpret_string(tmp___10, (cpp_string const   *)tmp___9, tmp___8,
                                  & istr, wide);
  }
#line 405
  if (tmp___11) {
    {
#line 410
    cstr = make_cstring(parse_region, (char const   *)((char *)istr.text), (int )(istr.len - 1U));
#line 411
    free((void *)((char *)istr.text));
    }
  } else {
#line 417
    if (wide) {
      {
#line 417
      tmp___6 = type_size_int(wchar_type);
#line 417
      tmp___7 = tmp___6;
      }
    } else {
#line 417
      tmp___7 = (largest_uint )1;
    }
    {
#line 417
    cstr = make_cstring(parse_region, "\000\000\000", (int )tmp___7);
    }
  }
  {
#line 421
  lvalp->u.string = fold_lexical_string(first_loc, string_components, cstr, wide);
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void lex_charconst(cpp_token const   *token , struct yystype *lvalp ) 
{ 
  cppchar_t result ;
  unsigned int chars_seen ;
  int unsignedp ;
  cpp_reader *tmp ;
  cstring tmp___0 ;
  location tmp___1 ;

  {
  {
#line 430
  tmp = current_reader();
#line 430
  result = cpp_interpret_charconst(tmp, token, & chars_seen, & unsignedp);
#line 432
  tmp___0 = make_token_cstring(token);
#line 432
  tmp___1 = last_location();
#line 432
  lvalp->u.constant = fold_lexical_char(tmp___1, tmp___0, (bool )((unsigned int const   )token->type == 58U),
                                        (int )result);
  }
#line 434
  return;
}
}
#line 437 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static lexical_cst interpret_integer(cpp_token const   *token , unsigned int flags ) 
{ 
  type t ;
  cpp_num integer ;
  cpp_options *options ;
  cpp_reader *tmp ;
  cpp_options *tmp___0 ;
  cpp_reader *tmp___1 ;
  cstring tmp___2 ;
  location tmp___3 ;
  lexical_cst tmp___4 ;

  {
  {
#line 441
  tmp = current_reader();
#line 441
  tmp___0 = cpp_get_options(tmp);
#line 441
  options = tmp___0;
#line 443
  tmp___1 = current_reader();
#line 443
  integer = cpp_interpret_integer(tmp___1, token, flags);
#line 444
  integer = cpp_num_sign_extend(integer, options->precision);
  }
#line 446
  if (flags & 4096U) {
#line 446
    goto _L;
  } else
#line 446
  if ((flags & 3840U) != 256U) {
    _L: /* CIL Label */ 
#line 451
    if ((flags & 240U) == 16U) {
#line 452
      t = unsigned_int_type;
    } else
#line 453
    if ((flags & 240U) == 32U) {
#line 454
      t = unsigned_long_type;
    } else {
#line 456
      t = unsigned_long_long_type;
    }
  } else
#line 458
  if ((flags & 240U) == 16U) {
#line 459
    t = int_type;
  } else
#line 460
  if ((flags & 240U) == 32U) {
#line 461
    t = long_type;
  } else {
#line 463
    t = long_long_type;
  }
#line 468
  if (! (sizeof(long long ) == sizeof(largest_uint ))) {
    {
#line 468
    __assert_fail("sizeof(long long) == sizeof(largest_uint)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c",
                  468U, "interpret_integer");
    }
  }
  {
#line 469
  tmp___2 = make_token_cstring(token);
#line 469
  tmp___3 = last_location();
#line 469
  tmp___4 = fold_lexical_int(t, tmp___3, tmp___2, (bool )((flags & 8192U) != 0U),
                             integer.low, integer.overflow);
  }
#line 469
  return (tmp___4);
}
}
#line 477 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static lexical_cst interpret_float(cpp_token const   *token , unsigned int flags ) 
{ 
  type t ;
  cstring tmp ;
  location tmp___0 ;
  lexical_cst tmp___1 ;

  {
#line 482
  if (flags & 1048576U) {
#line 483
    return ((lexical_cst )((void *)0));
  } else
#line 482
  if (flags & 2097152U) {
#line 483
    return ((lexical_cst )((void *)0));
  }
#line 485
  if (flags & 16384U) {
#line 486
    return ((lexical_cst )((void *)0));
  } else
#line 485
  if (flags & 983040U) {
#line 486
    return ((lexical_cst )((void *)0));
  }
#line 489
  if ((flags & 240U) == 64U) {
#line 490
    t = long_double_type;
  } else
#line 491
  if ((flags & 240U) == 16U) {
#line 492
    t = float_type;
  } else {
#line 494
    t = double_type;
  }
#line 496
  if (flags & 8192U) {
    {
#line 497
    t = make_complex_type(t);
    }
  }
  {
#line 499
  tmp = make_token_cstring(token);
#line 499
  tmp___0 = last_location();
#line 499
  tmp___1 = fold_lexical_real(t, tmp___0, tmp);
  }
#line 499
  return (tmp___1);
}
}
#line 502 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static bool is_nesc_keyword(struct resword *word___0 ) 
{ 
  int tmp ;

  {
#line 504
  if ((int )word___0->token != 263) {
#line 504
    if ((unsigned int )word___0->rid & 256U) {
#line 504
      tmp = 1;
    } else {
#line 504
      tmp = 0;
    }
  } else {
#line 504
    tmp = 0;
  }
#line 504
  return ((bool )tmp);
}
}
#line 507 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static int interpret_name(cpp_token const   *token , struct yystype *lvalp ) 
{ 
  ht_identifier *id ;
  struct resword *ptr ;
  data_declaration decl ;
  int kind ;
  struct resword  __attribute__((__gnu_inline__)) *tmp ;
  bool tmp___0 ;

  {
  {
#line 509
  id = (ht_identifier *)token->val.node;
#line 512
  kind = 258;
#line 515
  tmp = is_reserved_word((char const   *)id->str, id->len);
#line 515
  ptr = (struct resword *)tmp;
  }
#line 515
  if (ptr) {
    {
#line 515
    tmp___0 = is_nesc_keyword(ptr);
    }
#line 515
    if (tmp___0) {
#line 515
      if (! ((unsigned int )current.language == 0U)) {
#line 515
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 518
      if ((int )ptr->token == 263) {
#line 519
        lvalp->u.itoken.i = (int )ptr->rid;
      } else {
#line 521
        lvalp->u.itoken.i = (int )((unsigned int )ptr->rid & 4294967039U);
      }
#line 524
      if (pedantic) {
#line 524
        if ((int )ptr->token == 285) {
#line 524
          goto _L;
        } else
#line 524
        if ((int )ptr->token == 286) {
#line 524
          goto _L;
        } else
#line 524
        if ((unsigned int )ptr->rid == 11U) {
          _L: /* CIL Label */ 
#line 524
          if ((int const   )*(id->str + 0) != 95) {
            {
#line 528
            pedwarn("ANSI does not permit the keyword `%s\'", id->str);
            }
          }
        }
      }
#line 530
      return ((int )ptr->token);
    }
  }
#line 534
  if (target->token) {
    {
#line 535
    kind = (*(target->token))((char const   *)((char *)id->str), (int )id->len, lvalp);
    }
  }
#line 537
  if (kind == 258) {
    {
#line 539
    lvalp->idtoken.location = last_location();
#line 540
    lvalp->idtoken.id = make_token_cstring(token);
#line 541
    decl = lookup_id((char const   *)lvalp->idtoken.id.data, (bool )0);
#line 542
    lvalp->idtoken.decl = decl;
    }
#line 544
    if (decl) {
      {
#line 547
      if ((unsigned int )decl->kind == 3U) {
#line 547
        goto case_3;
      }
#line 548
      if ((unsigned int )decl->kind == 5U) {
#line 548
        goto case_5;
      }
#line 549
      if ((unsigned int )decl->kind == 8U) {
#line 549
        goto case_8;
      }
#line 550
      goto switch_default;
      case_3: /* CIL Label */ 
#line 547
      kind = 259;
#line 547
      goto switch_break;
      case_5: /* CIL Label */ 
#line 548
      kind = 267;
#line 548
      goto switch_break;
      case_8: /* CIL Label */ 
#line 549
      kind = 260;
#line 549
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 550
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 553
  return (kind);
}
}
#line 556 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static int lex_token(struct yystype *lvalp ) 
{ 
  cpp_token const   *tok ;
  enum cpp_ttype type___0 ;
  cpp_reader *tmp ;
  int tmp___0 ;
  unsigned int flags ;
  cpp_reader *tmp___1 ;
  unsigned int tmp___2 ;
  lexical_cst num ;
  cstring tmp___3 ;
  location tmp___4 ;
  unsigned char name[4] ;
  cpp_reader *tmp___5 ;
  unsigned char *tmp___6 ;
  cppchar_t c ;

  {
  retry: 
  {
#line 562
  tmp = current_reader();
#line 562
  tok = cpp_get_token(tmp);
#line 562
  last_token = tok;
#line 563
  save_pp_token(tok);
#line 564
  type___0 = (enum cpp_ttype )tok->type;
#line 565
  lvalp->u.itoken.location = last_location();
#line 566
  lvalp->u.itoken.i = 0;
  }
  {
#line 570
  if ((unsigned int )type___0 == 22U) {
#line 570
    goto case_22;
  }
#line 573
  if ((unsigned int )type___0 == 68U) {
#line 573
    goto case_68;
  }
#line 576
  if ((unsigned int )type___0 == 64U) {
#line 576
    goto case_64;
  }
#line 580
  if ((unsigned int )type___0 == 54U) {
#line 580
    goto case_54;
  }
#line 583
  if ((unsigned int )type___0 == 56U) {
#line 583
    goto case_56;
  }
#line 612
  if ((unsigned int )type___0 == 52U) {
#line 612
    goto case_52;
  }
#line 612
  if ((unsigned int )type___0 == 51U) {
#line 612
    goto case_52;
  }
#line 612
  if ((unsigned int )type___0 == 50U) {
#line 612
    goto case_52;
  }
#line 612
  if ((unsigned int )type___0 == 38U) {
#line 612
    goto case_52;
  }
#line 612
  if ((unsigned int )type___0 == 37U) {
#line 612
    goto case_52;
  }
#line 622
  if ((unsigned int )type___0 == 59U) {
#line 622
    goto case_59;
  }
#line 636
  if ((unsigned int )type___0 == 58U) {
#line 636
    goto case_58;
  }
#line 636
  if ((unsigned int )type___0 == 57U) {
#line 636
    goto case_58;
  }
#line 641
  if ((unsigned int )type___0 == 61U) {
#line 641
    goto case_61;
  }
#line 641
  if ((unsigned int )type___0 == 60U) {
#line 641
    goto case_61;
  }
#line 645
  if ((unsigned int )type___0 == 66U) {
#line 645
    goto case_66;
  }
#line 650
  if ((unsigned int )type___0 == 0U) {
#line 650
    goto case_0;
  }
#line 651
  if ((unsigned int )type___0 == 1U) {
#line 651
    goto case_1___0;
  }
#line 652
  if ((unsigned int )type___0 == 2U) {
#line 652
    goto case_2___0;
  }
#line 653
  if ((unsigned int )type___0 == 3U) {
#line 653
    goto case_3;
  }
#line 654
  if ((unsigned int )type___0 == 4U) {
#line 654
    goto case_4;
  }
#line 655
  if ((unsigned int )type___0 == 5U) {
#line 655
    goto case_5;
  }
#line 656
  if ((unsigned int )type___0 == 6U) {
#line 656
    goto case_6;
  }
#line 657
  if ((unsigned int )type___0 == 7U) {
#line 657
    goto case_7;
  }
#line 658
  if ((unsigned int )type___0 == 8U) {
#line 658
    goto case_8;
  }
#line 659
  if ((unsigned int )type___0 == 9U) {
#line 659
    goto case_9;
  }
#line 660
  if ((unsigned int )type___0 == 10U) {
#line 660
    goto case_10;
  }
#line 661
  if ((unsigned int )type___0 == 11U) {
#line 661
    goto case_11;
  }
#line 662
  if ((unsigned int )type___0 == 12U) {
#line 662
    goto case_12;
  }
#line 663
  if ((unsigned int )type___0 == 13U) {
#line 663
    goto case_13;
  }
#line 664
  if ((unsigned int )type___0 == 14U) {
#line 664
    goto case_14;
  }
#line 665
  if ((unsigned int )type___0 == 15U) {
#line 665
    goto case_15;
  }
#line 666
  if ((unsigned int )type___0 == 16U) {
#line 666
    goto case_16;
  }
#line 667
  if ((unsigned int )type___0 == 17U) {
#line 667
    goto case_17;
  }
#line 668
  if ((unsigned int )type___0 == 18U) {
#line 668
    goto case_18;
  }
#line 669
  if ((unsigned int )type___0 == 19U) {
#line 669
    goto case_19;
  }
#line 670
  if ((unsigned int )type___0 == 20U) {
#line 670
    goto case_20;
  }
#line 671
  if ((unsigned int )type___0 == 21U) {
#line 671
    goto case_21;
  }
#line 672
  if ((unsigned int )type___0 == 23U) {
#line 672
    goto case_23;
  }
#line 673
  if ((unsigned int )type___0 == 24U) {
#line 673
    goto case_24;
  }
#line 674
  if ((unsigned int )type___0 == 25U) {
#line 674
    goto case_25;
  }
#line 675
  if ((unsigned int )type___0 == 26U) {
#line 675
    goto case_26;
  }
#line 676
  if ((unsigned int )type___0 == 27U) {
#line 676
    goto case_27;
  }
#line 677
  if ((unsigned int )type___0 == 28U) {
#line 677
    goto case_28;
  }
#line 678
  if ((unsigned int )type___0 == 29U) {
#line 678
    goto case_29;
  }
#line 679
  if ((unsigned int )type___0 == 30U) {
#line 679
    goto case_30;
  }
#line 680
  if ((unsigned int )type___0 == 31U) {
#line 680
    goto case_31;
  }
#line 681
  if ((unsigned int )type___0 == 32U) {
#line 681
    goto case_32;
  }
#line 682
  if ((unsigned int )type___0 == 33U) {
#line 682
    goto case_33;
  }
#line 683
  if ((unsigned int )type___0 == 34U) {
#line 683
    goto case_34;
  }
#line 684
  if ((unsigned int )type___0 == 35U) {
#line 684
    goto case_35;
  }
#line 685
  if ((unsigned int )type___0 == 36U) {
#line 685
    goto case_36;
  }
#line 686
  if ((unsigned int )type___0 == 39U) {
#line 686
    goto case_39;
  }
#line 687
  if ((unsigned int )type___0 == 40U) {
#line 687
    goto case_40;
  }
#line 688
  if ((unsigned int )type___0 == 41U) {
#line 688
    goto case_41;
  }
#line 689
  if ((unsigned int )type___0 == 42U) {
#line 689
    goto case_42;
  }
#line 690
  if ((unsigned int )type___0 == 43U) {
#line 690
    goto case_43;
  }
#line 691
  if ((unsigned int )type___0 == 44U) {
#line 691
    goto case_44;
  }
#line 692
  if ((unsigned int )type___0 == 45U) {
#line 692
    goto case_45;
  }
#line 693
  if ((unsigned int )type___0 == 46U) {
#line 693
    goto case_46;
  }
#line 694
  if ((unsigned int )type___0 == 47U) {
#line 694
    goto case_47;
  }
#line 695
  if ((unsigned int )type___0 == 48U) {
#line 695
    goto case_48;
  }
#line 696
  if ((unsigned int )type___0 == 49U) {
#line 696
    goto case_49;
  }
#line 697
  if ((unsigned int )type___0 == 53U) {
#line 697
    goto case_53;
  }
#line 702
  goto switch_default;
  case_22: /* CIL Label */ 
#line 571
  return (-1);
  case_68: /* CIL Label */ 
#line 574
  goto retry;
  case_64: /* CIL Label */ 
  {
#line 577
  handle_comment(tok);
  }
#line 578
  goto retry;
  case_54: /* CIL Label */ 
  {
#line 581
  tmp___0 = interpret_name(tok, lvalp);
  }
#line 581
  return (tmp___0);
  case_56: /* CIL Label */ 
  {
#line 585
  tmp___1 = current_reader();
#line 585
  tmp___2 = cpp_classify_number(tmp___1, tok);
#line 585
  flags = tmp___2;
#line 586
  num = (lexical_cst )((void *)0);
  }
  {
#line 590
  if ((flags & 15U) == 1U) {
#line 590
    goto case_1;
  }
#line 593
  if ((flags & 15U) == 2U) {
#line 593
    goto case_2;
  }
#line 588
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 591
  num = interpret_integer(tok, flags);
  }
#line 592
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 594
  num = interpret_float(tok, flags);
  }
#line 595
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 599
  if ((unsigned long )num == (unsigned long )((void *)0)) {
    {
#line 600
    tmp___3 = make_token_cstring(tok);
#line 600
    tmp___4 = last_location();
#line 600
    num = fold_lexical_int(int_type, tmp___4, tmp___3, (bool )0, (largest_uint )0,
                           (bool )0);
    }
  }
#line 604
  lvalp->u.constant = num;
#line 605
  return (265);
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 616
  tmp___5 = current_reader();
#line 616
  tmp___6 = cpp_spell_token(tmp___5, tok, name, (unsigned char)1);
#line 616
  *tmp___6 = (unsigned char)0;
#line 618
  error("stray %qs in program", name);
  }
#line 620
  goto retry;
  case_59: /* CIL Label */ 
#line 624
  c = (cppchar_t )*(tok->val.str.text + 0);
#line 626
  if (c == 34U) {
    {
#line 627
    error("missing terminating %c character", (int )c);
    }
  } else
#line 626
  if (c == 39U) {
    {
#line 627
    error("missing terminating %c character", (int )c);
    }
  } else
#line 628
  if ((int const   )_sch_istable[c & 255U] & 172) {
    {
#line 629
    error("stray %qc in program", (int )c);
    }
  } else {
    {
#line 631
    error("stray %<\\%o%> in program", (int )c);
    }
  }
#line 633
  goto retry;
  case_58: /* CIL Label */ 
  case_57: /* CIL Label */ 
  {
#line 637
  lex_charconst(tok, lvalp);
  }
#line 638
  return (265);
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  {
#line 642
  lex_string(tok, lvalp);
  }
#line 643
  return (266);
  case_66: /* CIL Label */ 
#line 646
  goto retry;
  case_0: /* CIL Label */ 
#line 650
  return ('=');
  case_1___0: /* CIL Label */ 
#line 651
  return ('!');
  case_2___0: /* CIL Label */ 
#line 652
  return ('>');
  case_3: /* CIL Label */ 
#line 653
  return ('<');
  case_4: /* CIL Label */ 
#line 654
  return ('+');
  case_5: /* CIL Label */ 
#line 655
  return ('-');
  case_6: /* CIL Label */ 
#line 656
  return ('*');
  case_7: /* CIL Label */ 
#line 657
  return ('/');
  case_8: /* CIL Label */ 
#line 658
  return ('%');
  case_9: /* CIL Label */ 
#line 659
  return ('&');
  case_10: /* CIL Label */ 
#line 660
  return ('|');
  case_11: /* CIL Label */ 
#line 661
  return ('^');
  case_12: /* CIL Label */ 
#line 662
  return (300);
  case_13: /* CIL Label */ 
#line 663
  return (301);
  case_14: /* CIL Label */ 
#line 664
  return ('~');
  case_15: /* CIL Label */ 
#line 665
  return (297);
  case_16: /* CIL Label */ 
#line 666
  return (296);
  case_17: /* CIL Label */ 
#line 667
  return ('?');
  case_18: /* CIL Label */ 
#line 668
  return (':');
  case_19: /* CIL Label */ 
#line 669
  return (',');
  case_20: /* CIL Label */ 
#line 670
  return ('(');
  case_21: /* CIL Label */ 
#line 671
  return (')');
  case_23: /* CIL Label */ 
#line 672
  lvalp->u.itoken.i = 113;
#line 672
  return (298);
  case_24: /* CIL Label */ 
#line 673
  lvalp->u.itoken.i = 114;
#line 673
  return (298);
  case_25: /* CIL Label */ 
#line 674
  lvalp->u.itoken.i = 110;
#line 674
  return (299);
  case_26: /* CIL Label */ 
#line 675
  lvalp->u.itoken.i = 109;
#line 675
  return (299);
  case_27: /* CIL Label */ 
#line 676
  lvalp->u.itoken.i = 117;
#line 676
  return (295);
  case_28: /* CIL Label */ 
#line 677
  lvalp->u.itoken.i = 118;
#line 677
  return (295);
  case_29: /* CIL Label */ 
#line 678
  lvalp->u.itoken.i = 119;
#line 678
  return (295);
  case_30: /* CIL Label */ 
#line 679
  lvalp->u.itoken.i = 120;
#line 679
  return (295);
  case_31: /* CIL Label */ 
#line 680
  lvalp->u.itoken.i = 121;
#line 680
  return (295);
  case_32: /* CIL Label */ 
#line 681
  lvalp->u.itoken.i = 124;
#line 681
  return (295);
  case_33: /* CIL Label */ 
#line 682
  lvalp->u.itoken.i = 125;
#line 682
  return (295);
  case_34: /* CIL Label */ 
#line 683
  lvalp->u.itoken.i = 126;
#line 683
  return (295);
  case_35: /* CIL Label */ 
#line 684
  lvalp->u.itoken.i = 123;
#line 684
  return (295);
  case_36: /* CIL Label */ 
#line 685
  lvalp->u.itoken.i = 122;
#line 685
  return (295);
  case_39: /* CIL Label */ 
#line 686
  return ('[');
  case_40: /* CIL Label */ 
#line 687
  return (']');
  case_41: /* CIL Label */ 
#line 688
  return ('{');
  case_42: /* CIL Label */ 
#line 689
  return ('}');
  case_43: /* CIL Label */ 
#line 690
  return (';');
  case_44: /* CIL Label */ 
#line 691
  return (268);
  case_45: /* CIL Label */ 
#line 692
  return (303);
  case_46: /* CIL Label */ 
#line 693
  return (302);
  case_47: /* CIL Label */ 
#line 694
  return (304);
  case_48: /* CIL Label */ 
#line 695
  return (318);
  case_49: /* CIL Label */ 
#line 696
  return ('.');
  case_53: /* CIL Label */ 
#line 697
  return ('@');
  switch_default: /* CIL Label */ 
  {
#line 703
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c", 703U, "lex_token");
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 723 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static int poptoken(struct yystype *lvalp ) 
{ 
  int token ;
  int tmp ;

  {
#line 726
  if (current.lex.token_s1 != -1) {
#line 728
    token = current.lex.token_s1;
#line 729
    *lvalp = current.lex.token_l1;
#line 731
    current.lex.token_s1 = current.lex.token_s2;
#line 732
    current.lex.token_l1 = current.lex.token_l2;
#line 733
    current.lex.token_s2 = -1;
#line 735
    return (token);
  } else {
    {
#line 738
    tmp = lex_token(lvalp);
    }
#line 738
    return (tmp);
  }
}
}
#line 741 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
static void pushtoken(int t , struct yystype *lvalp ) 
{ 


  {
#line 744
  if (current.lex.token_s1 == -1) {
#line 746
    current.lex.token_s1 = t;
#line 747
    current.lex.token_l1 = *lvalp;
  } else {
#line 751
    current.lex.token_s2 = t;
#line 752
    current.lex.token_l2 = *lvalp;
  }
#line 754
  return;
}
}
#line 756 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
int yylex(struct yystype *lvalp ) 
{ 
  int token ;
  int tmp ;
  struct yystype val1 ;
  int token1 ;
  int tmp___0 ;
  struct yystype val2 ;
  int token2 ;
  int tmp___1 ;
  data_declaration cref ;
  data_declaration fdecl ;
  void *tmp___2 ;

  {
  {
#line 759
  tmp = poptoken(lvalp);
#line 759
  token = tmp;
  }
#line 766
  if (token == 260) {
    {
#line 769
    tmp___0 = poptoken(& val1);
#line 769
    token1 = tmp___0;
#line 771
    token = 258;
    }
#line 772
    if (token1 == 46) {
      {
#line 775
      tmp___1 = poptoken(& val2);
#line 775
      token2 = tmp___1;
      }
#line 777
      if (token2 == 258) {
#line 777
        goto _L;
      } else
#line 777
      if (token2 == 259) {
#line 777
        goto _L;
      } else
#line 777
      if (token2 == 267) {
        _L: /* CIL Label */ 
        {
#line 780
        cref = lvalp->idtoken.decl;
#line 781
        tmp___2 = env_lookup(((cref->ctype)->env)->id_env, (char const   *)val2.idtoken.id.data,
                             (bool )1);
#line 781
        fdecl = (data_declaration )tmp___2;
        }
#line 783
        if (fdecl) {
#line 783
          if ((unsigned int )fdecl->kind == 3U) {
#line 786
            token = 260;
#line 787
            token2 = 258;
#line 788
            val2.idtoken.decl = fdecl;
          }
        }
      }
      {
#line 791
      pushtoken(token1, & val1);
#line 792
      pushtoken(token2, & val2);
      }
    } else {
      {
#line 795
      pushtoken(token1, & val1);
      }
    }
  }
#line 798
  return (token);
}
}
#line 801 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void yyerror(char *string___0 ) 
{ 
  char buf___0[200] ;
  enum cpp_ttype ttype ;
  unsigned char *ttext ;
  cpp_reader *tmp ;
  size_t tmp___0 ;

  {
#line 807
  if (! last_token) {
    {
#line 809
    error((char const   *)string___0);
    }
#line 810
    return;
  }
#line 813
  ttype = (enum cpp_ttype )last_token->type;
#line 814
  if ((unsigned int )ttype != 22U) {
    {
#line 815
    tmp = current_reader();
#line 815
    ttext = cpp_token_as_text(tmp, last_token);
    }
  }
  {
#line 817
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)string___0);
#line 819
  ttype = (enum cpp_ttype )last_token->type;
  }
#line 819
  if ((unsigned int )ttype == 22U) {
    {
#line 820
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" at end of input");
    }
  } else
#line 821
  if ((unsigned int )ttype == 60U) {
    {
#line 822
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" before string constant");
    }
  } else
#line 821
  if ((unsigned int )ttype == 61U) {
    {
#line 822
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" before string constant");
    }
  } else
#line 823
  if ((unsigned int )ttype == 57U) {
    {
#line 824
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" before character constant");
    }
  } else
#line 823
  if ((unsigned int )ttype == 58U) {
    {
#line 824
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" before character constant");
    }
  } else
#line 825
  if ((int )*(ttext + 0) < 32) {
    {
#line 826
    tmp___0 = strlen((char const   *)(buf___0));
#line 826
    sprintf((char */* __restrict  */)(buf___0 + tmp___0), (char const   */* __restrict  */)" before character 0%o",
            (int )*(ttext + 0));
    }
  } else
#line 825
  if ((int )*(ttext + 0) >= 127) {
    {
#line 826
    tmp___0 = strlen((char const   *)(buf___0));
#line 826
    sprintf((char */* __restrict  */)(buf___0 + tmp___0), (char const   */* __restrict  */)" before character 0%o",
            (int )*(ttext + 0));
    }
  } else {
    {
#line 828
    strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" before `%s\'");
    }
  }
  {
#line 830
  error((char const   *)(buf___0), ttext);
  }
#line 831
  return;
}
}
#line 834 "/home/wheatley/newnew/temp/nescc-1.3.4/src/c-lex.c"
void yyprint(FILE *file , int yychar , struct yystype yylval ) 
{ 


  {
  {
#line 838
  if (yychar == 258) {
#line 838
    goto case_258;
  }
#line 836
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 839
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" \'%s\'",
          yylval.idtoken.id.data);
  }
#line 840
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 842
  return;
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 120 "./../include/libiberty.h"
extern char *lrealpath(char const   * ) ;
#line 201
char *make_relative_prefix(char const   *progname___0 , char const   *bin_prefix ,
                           char const   *prefix )  __attribute__((__malloc__)) ;
#line 208
char *make_relative_prefix_ignore_links(char const   *progname___0 , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) ;
#line 99
static char **split_directories(char const   *name , int *ptr_num_dirs ) ;
#line 100
static void free_split_directories(char **dirs ) ;
#line 102 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) 
{ 
  char *result ;
  void *tmp ;

  {
  {
#line 105
  tmp = malloc((size_t )(len + 1));
#line 105
  result = (char *)tmp;
#line 107
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)s, (size_t )len);
#line 108
  *(result + len) = (char)0;
  }
#line 109
  return (result);
}
}
#line 114 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
static char **split_directories(char const   *name , int *ptr_num_dirs ) 
{ 
  int num_dirs ;
  char **dirs ;
  char const   *p ;
  char const   *q ;
  int ch ;
  char const   *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 117
  num_dirs = 0;
#line 124
  p = name;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    tmp = p;
#line 133
    p ++;
#line 133
    ch = (int )*tmp;
#line 133
    if (! (ch != 0)) {
#line 133
      goto while_break;
    }
#line 135
    if (ch == 47) {
#line 137
      num_dirs ++;
      {
#line 138
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 138
        if (! ((int const   )*p == 47)) {
#line 138
          goto while_break___0;
        }
#line 139
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp___0 = malloc(sizeof(char *) * (unsigned long )(num_dirs + 2));
#line 143
  dirs = (char **)tmp___0;
  }
#line 144
  if ((unsigned long )dirs == (unsigned long )((void *)0)) {
#line 145
    return ((char **)((void *)0));
  }
#line 148
  num_dirs = 0;
#line 149
  p = name;
#line 163
  q = p;
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    tmp___2 = p;
#line 164
    p ++;
#line 164
    ch = (int )*tmp___2;
#line 164
    if (! (ch != 0)) {
#line 164
      goto while_break___1;
    }
#line 166
    if (ch == 47) {
      {
#line 168
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 168
        if (! ((int const   )*p == 47)) {
#line 168
          goto while_break___2;
        }
#line 169
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 171
      tmp___1 = num_dirs;
#line 171
      num_dirs ++;
#line 171
      *(dirs + tmp___1) = save_string(q, (int )(p - q));
      }
#line 172
      if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
        {
#line 174
        *(dirs + num_dirs) = (char *)((void *)0);
#line 175
        free_split_directories(dirs);
        }
#line 176
        return ((char **)((void *)0));
      }
#line 178
      q = p;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 182
  if ((p - 1) - q > 0L) {
    {
#line 183
    tmp___3 = num_dirs;
#line 183
    num_dirs ++;
#line 183
    *(dirs + tmp___3) = save_string(q, (int )((p - 1) - q));
    }
  }
#line 184
  *(dirs + num_dirs) = (char *)((void *)0);
#line 186
  if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
    {
#line 188
    free_split_directories(dirs);
    }
#line 189
    return ((char **)((void *)0));
  }
#line 192
  if (ptr_num_dirs) {
#line 193
    *ptr_num_dirs = num_dirs;
  }
#line 194
  return (dirs);
}
}
#line 199 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
static void free_split_directories(char **dirs ) 
{ 
  int i ;
  int tmp ;

  {
#line 202
  i = 0;
#line 204
  if ((unsigned long )dirs != (unsigned long )((void *)0)) {
    {
#line 206
    while (1) {
      while_continue: /* CIL Label */ ;
#line 206
      if (! ((unsigned long )*(dirs + i) != (unsigned long )((void *)0))) {
#line 206
        goto while_break;
      }
      {
#line 207
      tmp = i;
#line 207
      i ++;
#line 207
      free((void *)*(dirs + tmp));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 209
    free((void *)((char *)dirs));
    }
  }
#line 211
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
static char *make_relative_prefix_1(char const   *progname___0 , char const   *bin_prefix ,
                                    char const   *prefix , int const   resolve_links ) 
{ 
  char **prog_dirs ;
  char **bin_dirs ;
  char **prefix_dirs ;
  int prog_num ;
  int bin_num ;
  int prefix_num ;
  int i ;
  int n ;
  int common ;
  int needed_len ;
  char *ret ;
  char *ptr ;
  char *full_progname ;
  char *temp ;
  char *startp ;
  char *endp ;
  char *nstore ;
  size_t prefixlen ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;

  {
#line 227
  prog_dirs = (char **)((void *)0);
#line 227
  bin_dirs = (char **)((void *)0);
#line 227
  prefix_dirs = (char **)((void *)0);
#line 231
  ret = (char *)((void *)0);
#line 233
  if ((unsigned long )progname___0 == (unsigned long )((void *)0)) {
#line 234
    return ((char *)((void *)0));
  } else
#line 233
  if ((unsigned long )bin_prefix == (unsigned long )((void *)0)) {
#line 234
    return ((char *)((void *)0));
  } else
#line 233
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 234
    return ((char *)((void *)0));
  }
  {
#line 238
  tmp___3 = lbasename(progname___0);
  }
#line 238
  if ((unsigned long )tmp___3 == (unsigned long )progname___0) {
    {
#line 242
    temp = getenv("PATH");
    }
#line 243
    if (temp) {
      {
#line 246
      tmp = strlen((char const   *)temp);
#line 246
      prefixlen = tmp + 1UL;
      }
#line 247
      if (prefixlen < 2UL) {
#line 248
        prefixlen = (size_t )2;
      }
      {
#line 250
      tmp___0 = strlen(progname___0);
#line 250
      tmp___1 = __builtin_alloca((prefixlen + tmp___0) + 1UL);
#line 250
      nstore = (char *)tmp___1;
#line 252
      endp = temp;
#line 252
      startp = endp;
      }
      {
#line 253
      while (1) {
        while_continue: /* CIL Label */ ;
#line 255
        if ((int )*endp == 58) {
#line 255
          goto _L;
        } else
#line 255
        if ((int )*endp == 0) {
          _L: /* CIL Label */ 
#line 257
          if ((unsigned long )endp == (unsigned long )startp) {
#line 259
            *(nstore + 0) = (char )'.';
#line 260
            *(nstore + 1) = (char )'/';
#line 261
            *(nstore + 2) = (char )'\000';
          } else {
            {
#line 265
            strncpy((char */* __restrict  */)nstore, (char const   */* __restrict  */)startp,
                    (size_t )(endp - startp));
            }
#line 266
            if (! ((int )*(endp + -1) == 47)) {
#line 268
              *(nstore + (endp - startp)) = (char )'/';
#line 269
              *(nstore + ((endp - startp) + 1L)) = (char)0;
            } else {
#line 272
              *(nstore + (endp - startp)) = (char)0;
            }
          }
          {
#line 274
          strcat((char */* __restrict  */)nstore, (char const   */* __restrict  */)progname___0);
#line 275
          tmp___2 = access((char const   *)nstore, 1);
          }
#line 275
          if (! tmp___2) {
#line 281
            progname___0 = (char const   *)nstore;
#line 282
            goto while_break;
          }
#line 285
          if ((int )*endp == 0) {
#line 286
            goto while_break;
          }
#line 287
          startp = endp + 1;
#line 287
          endp = startp;
        } else {
#line 290
          endp ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 295
  if (resolve_links) {
    {
#line 297
    full_progname = lrealpath(progname___0);
    }
#line 298
    if ((unsigned long )full_progname == (unsigned long )((void *)0)) {
#line 299
      return ((char *)((void *)0));
    }
  } else {
    {
#line 302
    full_progname = strdup(progname___0);
    }
  }
  {
#line 304
  prog_dirs = split_directories((char const   *)full_progname, & prog_num);
#line 305
  free((void *)full_progname);
  }
#line 306
  if ((unsigned long )prog_dirs == (unsigned long )((void *)0)) {
#line 307
    return ((char *)((void *)0));
  }
  {
#line 309
  bin_dirs = split_directories(bin_prefix, & bin_num);
  }
#line 310
  if ((unsigned long )bin_dirs == (unsigned long )((void *)0)) {
#line 311
    goto bailout;
  }
#line 314
  prog_num --;
#line 320
  if (prog_num == bin_num) {
#line 322
    i = 0;
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if (! (i < bin_num)) {
#line 322
        goto while_break___0;
      }
      {
#line 324
      tmp___4 = strcmp((char const   *)*(prog_dirs + i), (char const   *)*(bin_dirs + i));
      }
#line 324
      if (tmp___4 != 0) {
#line 325
        goto while_break___0;
      }
#line 322
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 328
    if (prog_num <= 0) {
#line 329
      goto bailout;
    } else
#line 328
    if (i == bin_num) {
#line 329
      goto bailout;
    }
  }
  {
#line 332
  prefix_dirs = split_directories(prefix, & prefix_num);
  }
#line 333
  if ((unsigned long )prefix_dirs == (unsigned long )((void *)0)) {
#line 334
    goto bailout;
  }
#line 337
  if (prefix_num < bin_num) {
#line 337
    n = prefix_num;
  } else {
#line 337
    n = bin_num;
  }
#line 338
  common = 0;
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! (common < n)) {
#line 338
      goto while_break___1;
    }
    {
#line 340
    tmp___5 = strcmp((char const   *)*(bin_dirs + common), (char const   *)*(prefix_dirs + common));
    }
#line 340
    if (tmp___5 != 0) {
#line 341
      goto while_break___1;
    }
#line 338
    common ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 345
  if (common == 0) {
#line 346
    goto bailout;
  }
#line 350
  needed_len = 0;
#line 351
  i = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (i < prog_num)) {
#line 351
      goto while_break___2;
    }
    {
#line 352
    tmp___6 = strlen((char const   *)*(prog_dirs + i));
#line 352
    needed_len = (int )((size_t )needed_len + tmp___6);
#line 351
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 353
  needed_len = (int )((unsigned long )needed_len + sizeof("..") * (unsigned long )(bin_num - common));
#line 354
  i = common;
  {
#line 354
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 354
    if (! (i < prefix_num)) {
#line 354
      goto while_break___3;
    }
    {
#line 355
    tmp___7 = strlen((char const   *)*(prefix_dirs + i));
#line 355
    needed_len = (int )((size_t )needed_len + tmp___7);
#line 354
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 356
  needed_len ++;
#line 358
  tmp___8 = malloc((size_t )needed_len);
#line 358
  ret = (char *)tmp___8;
  }
#line 359
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 360
    goto bailout;
  }
#line 363
  *ret = (char )'\000';
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 364
    if (! (i < prog_num)) {
#line 364
      goto while_break___4;
    }
    {
#line 365
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prog_dirs + i));
#line 364
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 368
  tmp___9 = strlen((char const   *)ret);
#line 368
  ptr = ret + tmp___9;
#line 369
  i = common;
  }
  {
#line 369
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 369
    if (! (i < bin_num)) {
#line 369
      goto while_break___5;
    }
    {
#line 371
    strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"..");
#line 372
    ptr += sizeof("..") - 1UL;
#line 373
    tmp___10 = ptr;
#line 373
    ptr ++;
#line 373
    *tmp___10 = (char )'/';
#line 369
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 375
  *ptr = (char )'\000';
#line 378
  i = common;
  {
#line 378
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 378
    if (! (i < prefix_num)) {
#line 378
      goto while_break___6;
    }
    {
#line 379
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prefix_dirs + i));
#line 378
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  bailout: 
  {
#line 382
  free_split_directories(prog_dirs);
#line 383
  free_split_directories(bin_dirs);
#line 384
  free_split_directories(prefix_dirs);
  }
#line 386
  return (ret);
}
}
#line 395
char *make_relative_prefix(char const   *progname___0 , char const   *bin_prefix ,
                           char const   *prefix )  __attribute__((__malloc__)) ;
#line 395 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
char *make_relative_prefix(char const   *progname___0 , char const   *bin_prefix ,
                           char const   *prefix ) 
{ 
  char *tmp ;

  {
  {
#line 399
  tmp = make_relative_prefix_1(progname___0, bin_prefix, prefix, (int const   )1);
  }
#line 399
  return (tmp);
}
}
#line 407
char *make_relative_prefix_ignore_links(char const   *progname___0 , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 407 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./make-relative-prefix.c"
char *make_relative_prefix_ignore_links(char const   *progname___0 , char const   *bin_prefix ,
                                        char const   *prefix ) 
{ 
  char *tmp ;

  {
  {
#line 412
  tmp = make_relative_prefix_1(progname___0, bin_prefix, prefix, (int const   )0);
  }
#line 412
  return (tmp);
}
}
#line 481 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
AST_kind AST_parent_kind[158] ;
#line 483
AST_kind AST_post_kind[158] ;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.h"
AST_walker new_AST_walker(region r ) ;
#line 48
void AST_walker_handle(AST_walker spec , AST_kind kind , AST_walker_result (*fn)() ) ;
#line 54
void AST_walk(AST_walker spec , void *data , node *n ) ;
#line 56
void AST_walk_list(AST_walker s , void *d , node *n ) ;
#line 63
void AST_walk_children(AST_walker s , void *d , node n ) ;
#line 66
AST_walker_result AST_walker_call(AST_walker spec , AST_kind kind , void *data , node *n ) ;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
static AST_walker_result default_walker(AST_walker spec , void *data , node *n ) 
{ 


  {
#line 30
  return ((AST_walker_result )0);
}
}
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
AST_walker new_AST_walker(region r ) 
{ 
  AST_walker walker ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 37
  if (sizeof(struct AST_walker ) < (unsigned long )(1 << 9)) {
    {
#line 37
    tmp = __rcralloc_small0(r, sizeof(struct AST_walker ));
#line 37
    tmp___1 = tmp;
    }
  } else {
    {
#line 37
    tmp___0 = typed_ralloc(r, sizeof(struct AST_walker ), 0);
#line 37
    tmp___1 = tmp___0;
    }
  }
  {
#line 37
  walker = (AST_walker )tmp___1;
#line 39
  AST_walker_handle(walker, (AST_kind )42, (AST_walker_result (*)())(& default_walker));
  }
#line 41
  return (walker);
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
void AST_walker_handle(AST_walker spec , AST_kind kind , AST_walker_result (*fn)() ) 
{ 
  AST_kind k ;

  {
#line 51
  if ((unsigned int )kind >= 42U) {
#line 51
    if (! ((unsigned int )kind <= 199U)) {
      {
#line 51
      __assert_fail("kind >= kind_node && kind <= postkind_node", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c",
                    51U, "AST_walker_handle");
      }
    }
  } else {
    {
#line 51
    __assert_fail("kind >= kind_node && kind <= postkind_node", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c",
                  51U, "AST_walker_handle");
    }
  }
#line 52
  k = kind;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned int )k <= (unsigned int )AST_post_kind[(unsigned int )kind - 42U])) {
#line 52
      goto while_break;
    }
#line 53
    spec->walkers[(unsigned int )k - 42U] = fn;
#line 52
    k = (AST_kind )((unsigned int )k + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
AST_walker_result AST_walker_call(AST_walker spec , AST_kind kind , void *data , node *n ) 
{ 
  AST_walker_result tmp ;

  {
#line 59
  if ((unsigned int )kind >= 42U) {
#line 59
    if ((unsigned int )kind <= 199U) {
#line 59
      if ((unsigned int )(*n)->kind >= (unsigned int )kind) {
#line 59
        if (! ((unsigned int )(*n)->kind <= (unsigned int )AST_post_kind[(unsigned int )kind - 42U])) {
          {
#line 59
          __assert_fail("kind >= kind_node && kind <= postkind_node && ((*n)->kind >= (kind) && (*n)->kind <= AST_post_kind[(kind) - kind_node])",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c", 59U,
                        "AST_walker_call");
          }
        }
      } else {
        {
#line 59
        __assert_fail("kind >= kind_node && kind <= postkind_node && ((*n)->kind >= (kind) && (*n)->kind <= AST_post_kind[(kind) - kind_node])",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c", 59U,
                      "AST_walker_call");
        }
      }
    } else {
      {
#line 59
      __assert_fail("kind >= kind_node && kind <= postkind_node && ((*n)->kind >= (kind) && (*n)->kind <= AST_post_kind[(kind) - kind_node])",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c", 59U,
                    "AST_walker_call");
      }
    }
  } else {
    {
#line 59
    __assert_fail("kind >= kind_node && kind <= postkind_node && ((*n)->kind >= (kind) && (*n)->kind <= AST_post_kind[(kind) - kind_node])",
                  "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c", 59U, "AST_walker_call");
    }
  }
  {
#line 60
  tmp = (*(spec->walkers[(unsigned int )kind - 42U]))(spec, data, n);
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
void AST_walk_list(AST_walker s , void *d , node *n ) 
{ 


  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! *n) {
#line 65
      goto while_break;
    }
    {
#line 67
    AST_walk(s, d, n);
#line 68
    n = & (*n)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
void AST_walk_children(AST_walker s , void *d , node n ) 
{ 
  asm_decl x ;
  AST_generic tEmPcast ;
  data_decl x___0 ;
  AST_generic tEmPcast___0 ;
  extension_decl x___1 ;
  AST_generic tEmPcast___1 ;
  enumerator x___2 ;
  AST_generic tEmPcast___2 ;
  function_decl x___3 ;
  AST_generic tEmPcast___3 ;
  variable_decl x___4 ;
  AST_generic tEmPcast___4 ;
  field_decl x___5 ;
  AST_generic tEmPcast___5 ;
  asttype x___6 ;
  AST_generic tEmPcast___6 ;
  typeof_expr x___7 ;
  AST_generic tEmPcast___7 ;
  typeof_type x___8 ;
  AST_generic tEmPcast___8 ;
  attribute x___9 ;
  AST_generic tEmPcast___9 ;
  gcc_attribute x___10 ;
  AST_generic tEmPcast___10 ;
  tag_ref x___11 ;
  AST_generic tEmPcast___11 ;
  struct_ref x___12 ;
  AST_generic tEmPcast___12 ;
  union_ref x___13 ;
  AST_generic tEmPcast___13 ;
  nested_declarator x___14 ;
  AST_generic tEmPcast___14 ;
  function_declarator x___15 ;
  AST_generic tEmPcast___15 ;
  pointer_declarator x___16 ;
  AST_generic tEmPcast___16 ;
  qualified_declarator x___17 ;
  AST_generic tEmPcast___17 ;
  array_declarator x___18 ;
  AST_generic tEmPcast___18 ;
  asm_stmt x___19 ;
  AST_generic tEmPcast___19 ;
  compound_stmt x___20 ;
  AST_generic tEmPcast___20 ;
  if_stmt x___21 ;
  AST_generic tEmPcast___21 ;
  labeled_stmt x___22 ;
  AST_generic tEmPcast___22 ;
  expression_stmt x___23 ;
  AST_generic tEmPcast___23 ;
  conditional_stmt x___24 ;
  AST_generic tEmPcast___24 ;
  switch_stmt x___25 ;
  AST_generic tEmPcast___25 ;
  for_stmt x___26 ;
  AST_generic tEmPcast___26 ;
  return_stmt x___27 ;
  AST_generic tEmPcast___27 ;
  goto_stmt x___28 ;
  AST_generic tEmPcast___28 ;
  computed_goto_stmt x___29 ;
  AST_generic tEmPcast___29 ;
  unary x___30 ;
  AST_generic tEmPcast___30 ;
  binary x___31 ;
  AST_generic tEmPcast___31 ;
  comma x___32 ;
  AST_generic tEmPcast___32 ;
  sizeof_type x___33 ;
  AST_generic tEmPcast___33 ;
  alignof_type x___34 ;
  AST_generic tEmPcast___34 ;
  label_address x___35 ;
  AST_generic tEmPcast___35 ;
  cast x___36 ;
  AST_generic tEmPcast___36 ;
  cast_list x___37 ;
  AST_generic tEmPcast___37 ;
  conditional x___38 ;
  AST_generic tEmPcast___38 ;
  compound_expr x___39 ;
  AST_generic tEmPcast___39 ;
  function_call x___40 ;
  AST_generic tEmPcast___40 ;
  field_ref x___41 ;
  AST_generic tEmPcast___41 ;
  increment x___42 ;
  AST_generic tEmPcast___42 ;
  comparison x___43 ;
  AST_generic tEmPcast___43 ;
  assignment x___44 ;
  AST_generic tEmPcast___44 ;
  init_list x___45 ;
  AST_generic tEmPcast___45 ;
  init_specific x___46 ;
  AST_generic tEmPcast___46 ;
  designate_index x___47 ;
  AST_generic tEmPcast___47 ;
  string x___48 ;
  AST_generic tEmPcast___48 ;
  case_label x___49 ;
  AST_generic tEmPcast___49 ;
  asm_operand x___50 ;
  AST_generic tEmPcast___50 ;
  nesc_decl x___51 ;
  AST_generic tEmPcast___51 ;
  interface x___52 ;
  AST_generic tEmPcast___52 ;
  component x___53 ;
  AST_generic tEmPcast___53 ;
  configuration x___54 ;
  AST_generic tEmPcast___54 ;
  module x___55 ;
  AST_generic tEmPcast___55 ;
  rp_interface x___56 ;
  AST_generic tEmPcast___56 ;
  interface_ref x___57 ;
  AST_generic tEmPcast___57 ;
  component_ref x___58 ;
  AST_generic tEmPcast___58 ;
  connection x___59 ;
  AST_generic tEmPcast___59 ;
  endpoint x___60 ;
  AST_generic tEmPcast___60 ;
  parameterised_identifier x___61 ;
  AST_generic tEmPcast___61 ;
  generic_declarator x___62 ;
  AST_generic tEmPcast___62 ;
  generic_call x___63 ;
  AST_generic tEmPcast___63 ;
  interface_ref_declarator x___64 ;
  AST_generic tEmPcast___64 ;
  interface_deref x___65 ;
  AST_generic tEmPcast___65 ;
  component_deref x___66 ;
  AST_generic tEmPcast___66 ;
  atomic_stmt x___67 ;
  AST_generic tEmPcast___67 ;
  nesc_attribute x___68 ;
  AST_generic tEmPcast___68 ;
  type_argument x___69 ;
  AST_generic tEmPcast___69 ;
  attribute_ref x___70 ;
  AST_generic tEmPcast___70 ;
  enum_ref x___71 ;
  AST_generic tEmPcast___71 ;
  while_stmt x___72 ;
  AST_generic tEmPcast___72 ;
  dowhile_stmt x___73 ;
  AST_generic tEmPcast___73 ;
  array_ref x___74 ;
  AST_generic tEmPcast___74 ;
  dereference x___75 ;
  AST_generic tEmPcast___75 ;
  extension_expr x___76 ;
  AST_generic tEmPcast___76 ;
  sizeof_expr x___77 ;
  AST_generic tEmPcast___77 ;
  alignof_expr x___78 ;
  AST_generic tEmPcast___78 ;
  realpart x___79 ;
  AST_generic tEmPcast___79 ;
  imagpart x___80 ;
  AST_generic tEmPcast___80 ;
  address_of x___81 ;
  AST_generic tEmPcast___81 ;
  unary_minus x___82 ;
  AST_generic tEmPcast___82 ;
  unary_plus x___83 ;
  AST_generic tEmPcast___83 ;
  conjugate x___84 ;
  AST_generic tEmPcast___84 ;
  bitnot x___85 ;
  AST_generic tEmPcast___85 ;
  not x___86 ;
  AST_generic tEmPcast___86 ;
  preincrement x___87 ;
  AST_generic tEmPcast___87 ;
  predecrement x___88 ;
  AST_generic tEmPcast___88 ;
  postincrement x___89 ;
  AST_generic tEmPcast___89 ;
  postdecrement x___90 ;
  AST_generic tEmPcast___90 ;
  plus x___91 ;
  AST_generic tEmPcast___91 ;
  minus x___92 ;
  AST_generic tEmPcast___92 ;
  times x___93 ;
  AST_generic tEmPcast___93 ;
  divide x___94 ;
  AST_generic tEmPcast___94 ;
  modulo x___95 ;
  AST_generic tEmPcast___95 ;
  lshift x___96 ;
  AST_generic tEmPcast___96 ;
  rshift x___97 ;
  AST_generic tEmPcast___97 ;
  leq x___98 ;
  AST_generic tEmPcast___98 ;
  geq x___99 ;
  AST_generic tEmPcast___99 ;
  lt x___100 ;
  AST_generic tEmPcast___100 ;
  gt x___101 ;
  AST_generic tEmPcast___101 ;
  eq x___102 ;
  AST_generic tEmPcast___102 ;
  ne x___103 ;
  AST_generic tEmPcast___103 ;
  bitand x___104 ;
  AST_generic tEmPcast___104 ;
  bitor x___105 ;
  AST_generic tEmPcast___105 ;
  bitxor x___106 ;
  AST_generic tEmPcast___106 ;
  andand x___107 ;
  AST_generic tEmPcast___107 ;
  oror x___108 ;
  AST_generic tEmPcast___108 ;
  assign x___109 ;
  AST_generic tEmPcast___109 ;
  plus_assign x___110 ;
  AST_generic tEmPcast___110 ;
  minus_assign x___111 ;
  AST_generic tEmPcast___111 ;
  times_assign x___112 ;
  AST_generic tEmPcast___112 ;
  divide_assign x___113 ;
  AST_generic tEmPcast___113 ;
  modulo_assign x___114 ;
  AST_generic tEmPcast___114 ;
  lshift_assign x___115 ;
  AST_generic tEmPcast___115 ;
  rshift_assign x___116 ;
  AST_generic tEmPcast___116 ;
  bitand_assign x___117 ;
  AST_generic tEmPcast___117 ;
  bitor_assign x___118 ;
  AST_generic tEmPcast___118 ;
  bitxor_assign x___119 ;
  AST_generic tEmPcast___119 ;
  rp_connection x___120 ;
  AST_generic tEmPcast___120 ;
  eq_connection x___121 ;
  AST_generic tEmPcast___121 ;
  nx_struct_ref x___122 ;
  AST_generic tEmPcast___122 ;
  nx_union_ref x___123 ;
  AST_generic tEmPcast___123 ;
  target_attribute x___124 ;
  AST_generic tEmPcast___124 ;

  {
  {
#line 4
  if ((unsigned int )n->kind == 44U) {
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c"
    goto case_44;
  }
#line 10
  if ((unsigned int )n->kind == 45U) {
#line 10
    goto case_45;
  }
#line 17
  if ((unsigned int )n->kind == 46U) {
#line 17
    goto case_46;
  }
#line 23
  if ((unsigned int )n->kind == 48U) {
#line 23
    goto case_48;
  }
#line 29
  if ((unsigned int )n->kind == 50U) {
#line 29
    goto case_50;
  }
#line 38
  if ((unsigned int )n->kind == 52U) {
#line 38
    goto case_52;
  }
#line 47
  if ((unsigned int )n->kind == 53U) {
#line 47
    goto case_53;
  }
#line 55
  if ((unsigned int )n->kind == 188U) {
#line 55
    goto case_188;
  }
#line 62
  if ((unsigned int )n->kind == 160U) {
#line 62
    goto case_160;
  }
#line 68
  if ((unsigned int )n->kind == 161U) {
#line 68
    goto case_161;
  }
#line 74
  if ((unsigned int )n->kind == 162U) {
#line 74
    goto case_162;
  }
#line 80
  if ((unsigned int )n->kind == 163U) {
#line 80
    goto case_163;
  }
#line 87
  if ((unsigned int )n->kind == 168U) {
#line 87
    goto case_168;
  }
#line 95
  if ((unsigned int )n->kind == 169U) {
#line 95
    goto case_169;
  }
#line 103
  if ((unsigned int )n->kind == 171U) {
#line 103
    goto case_171;
  }
#line 111
  if ((unsigned int )n->kind == 176U) {
#line 111
    goto case_176;
  }
#line 117
  if ((unsigned int )n->kind == 177U) {
#line 117
    goto case_177;
  }
#line 127
  if ((unsigned int )n->kind == 178U) {
#line 127
    goto case_178;
  }
#line 133
  if ((unsigned int )n->kind == 179U) {
#line 133
    goto case_179;
  }
#line 140
  if ((unsigned int )n->kind == 180U) {
#line 140
    goto case_180;
  }
#line 147
  if ((unsigned int )n->kind == 66U) {
#line 147
    goto case_66;
  }
#line 157
  if ((unsigned int )n->kind == 67U) {
#line 157
    goto case_67;
  }
#line 165
  if ((unsigned int )n->kind == 68U) {
#line 165
    goto case_68;
  }
#line 173
  if ((unsigned int )n->kind == 69U) {
#line 173
    goto case_69;
  }
#line 180
  if ((unsigned int )n->kind == 70U) {
#line 180
    goto case_70;
  }
#line 186
  if ((unsigned int )n->kind == 71U) {
#line 186
    goto case_71;
  }
#line 193
  if ((unsigned int )n->kind == 72U) {
#line 193
    goto case_72;
  }
#line 200
  if ((unsigned int )n->kind == 75U) {
#line 200
    goto case_75;
  }
#line 209
  if ((unsigned int )n->kind == 78U) {
#line 209
    goto case_78;
  }
#line 215
  if ((unsigned int )n->kind == 79U) {
#line 215
    goto case_79;
  }
#line 221
  if ((unsigned int )n->kind == 80U) {
#line 221
    goto case_80;
  }
#line 227
  if ((unsigned int )n->kind == 85U) {
#line 227
    goto case_85;
  }
#line 233
  if ((unsigned int )n->kind == 107U) {
#line 233
    goto case_107;
  }
#line 240
  if ((unsigned int )n->kind == 140U) {
#line 240
    goto case_140;
  }
#line 246
  if ((unsigned int )n->kind == 141U) {
#line 246
    goto case_141;
  }
#line 252
  if ((unsigned int )n->kind == 142U) {
#line 252
    goto case_142;
  }
#line 258
  if ((unsigned int )n->kind == 143U) {
#line 258
    goto case_143;
  }
#line 264
  if ((unsigned int )n->kind == 86U) {
#line 264
    goto case_86;
  }
#line 271
  if ((unsigned int )n->kind == 144U) {
#line 271
    goto case_144;
  }
#line 278
  if ((unsigned int )n->kind == 145U) {
#line 278
    goto case_145;
  }
#line 286
  if ((unsigned int )n->kind == 147U) {
#line 286
    goto case_147;
  }
#line 292
  if ((unsigned int )n->kind == 148U) {
#line 292
    goto case_148;
  }
#line 299
  if ((unsigned int )n->kind == 87U) {
#line 299
    goto case_87;
  }
#line 305
  if ((unsigned int )n->kind == 88U) {
#line 305
    goto case_88;
  }
#line 311
  if ((unsigned int )n->kind == 108U) {
#line 311
    goto case_108;
  }
#line 318
  if ((unsigned int )n->kind == 115U) {
#line 318
    goto case_115;
  }
#line 325
  if ((unsigned int )n->kind == 149U) {
#line 325
    goto case_149;
  }
#line 331
  if ((unsigned int )n->kind == 150U) {
#line 331
    goto case_150;
  }
#line 338
  if ((unsigned int )n->kind == 191U) {
#line 338
    goto case_191;
  }
#line 345
  if ((unsigned int )n->kind == 153U) {
#line 345
    goto case_153;
  }
#line 351
  if ((unsigned int )n->kind == 186U) {
#line 351
    goto case_186;
  }
#line 358
  if ((unsigned int )n->kind == 193U) {
#line 358
    goto case_193;
  }
#line 366
  if ((unsigned int )n->kind == 54U) {
#line 366
    goto case_54;
  }
#line 373
  if ((unsigned int )n->kind == 55U) {
#line 373
    goto case_55;
  }
#line 381
  if ((unsigned int )n->kind == 56U) {
#line 381
    goto case_56;
  }
#line 391
  if ((unsigned int )n->kind == 195U) {
#line 391
    goto case_195;
  }
#line 397
  if ((unsigned int )n->kind == 196U) {
#line 397
    goto case_196;
  }
#line 403
  if ((unsigned int )n->kind == 57U) {
#line 403
    goto case_57;
  }
#line 409
  if ((unsigned int )n->kind == 58U) {
#line 409
    goto case_58;
  }
#line 419
  if ((unsigned int )n->kind == 59U) {
#line 419
    goto case_59;
  }
#line 427
  if ((unsigned int )n->kind == 60U) {
#line 427
    goto case_60;
  }
#line 434
  if ((unsigned int )n->kind == 198U) {
#line 434
    goto case_198;
  }
#line 440
  if ((unsigned int )n->kind == 199U) {
#line 440
    goto case_199;
  }
#line 447
  if ((unsigned int )n->kind == 183U) {
#line 447
    goto case_183;
  }
#line 454
  if ((unsigned int )n->kind == 154U) {
#line 454
    goto case_154;
  }
#line 461
  if ((unsigned int )n->kind == 181U) {
#line 461
    goto case_181;
  }
#line 468
  if ((unsigned int )n->kind == 93U) {
#line 468
    goto case_93;
  }
#line 474
  if ((unsigned int )n->kind == 94U) {
#line 474
    goto case_94;
  }
#line 480
  if ((unsigned int )n->kind == 82U) {
#line 480
    goto case_82;
  }
#line 486
  if ((unsigned int )n->kind == 165U) {
#line 486
    goto case_165;
  }
#line 493
  if ((unsigned int )n->kind == 155U) {
#line 493
    goto case_155;
  }
#line 499
  if ((unsigned int )n->kind == 173U) {
#line 499
    goto case_173;
  }
#line 507
  if ((unsigned int )n->kind == 174U) {
#line 507
    goto case_174;
  }
#line 515
  if ((unsigned int )n->kind == 73U) {
#line 515
    goto case_73;
  }
#line 522
  if ((unsigned int )n->kind == 74U) {
#line 522
    goto case_74;
  }
#line 529
  if ((unsigned int )n->kind == 127U) {
#line 529
    goto case_127;
  }
#line 536
  if ((unsigned int )n->kind == 95U) {
#line 536
    goto case_95;
  }
#line 542
  if ((unsigned int )n->kind == 96U) {
#line 542
    goto case_96;
  }
#line 548
  if ((unsigned int )n->kind == 97U) {
#line 548
    goto case_97;
  }
#line 554
  if ((unsigned int )n->kind == 98U) {
#line 554
    goto case_98;
  }
#line 560
  if ((unsigned int )n->kind == 99U) {
#line 560
    goto case_99;
  }
#line 566
  if ((unsigned int )n->kind == 100U) {
#line 566
    goto case_100;
  }
#line 572
  if ((unsigned int )n->kind == 101U) {
#line 572
    goto case_101;
  }
#line 578
  if ((unsigned int )n->kind == 102U) {
#line 578
    goto case_102;
  }
#line 584
  if ((unsigned int )n->kind == 103U) {
#line 584
    goto case_103;
  }
#line 590
  if ((unsigned int )n->kind == 104U) {
#line 590
    goto case_104;
  }
#line 596
  if ((unsigned int )n->kind == 105U) {
#line 596
    goto case_105;
  }
#line 602
  if ((unsigned int )n->kind == 106U) {
#line 602
    goto case_106;
  }
#line 608
  if ((unsigned int )n->kind == 89U) {
#line 608
    goto case_89;
  }
#line 614
  if ((unsigned int )n->kind == 90U) {
#line 614
    goto case_90;
  }
#line 620
  if ((unsigned int )n->kind == 91U) {
#line 620
    goto case_91;
  }
#line 626
  if ((unsigned int )n->kind == 92U) {
#line 626
    goto case_92;
  }
#line 632
  if ((unsigned int )n->kind == 128U) {
#line 632
    goto case_128;
  }
#line 639
  if ((unsigned int )n->kind == 129U) {
#line 639
    goto case_129;
  }
#line 646
  if ((unsigned int )n->kind == 130U) {
#line 646
    goto case_130;
  }
#line 653
  if ((unsigned int )n->kind == 131U) {
#line 653
    goto case_131;
  }
#line 660
  if ((unsigned int )n->kind == 132U) {
#line 660
    goto case_132;
  }
#line 667
  if ((unsigned int )n->kind == 133U) {
#line 667
    goto case_133;
  }
#line 674
  if ((unsigned int )n->kind == 134U) {
#line 674
    goto case_134;
  }
#line 681
  if ((unsigned int )n->kind == 109U) {
#line 681
    goto case_109;
  }
#line 688
  if ((unsigned int )n->kind == 110U) {
#line 688
    goto case_110;
  }
#line 695
  if ((unsigned int )n->kind == 111U) {
#line 695
    goto case_111;
  }
#line 702
  if ((unsigned int )n->kind == 112U) {
#line 702
    goto case_112;
  }
#line 709
  if ((unsigned int )n->kind == 113U) {
#line 709
    goto case_113;
  }
#line 716
  if ((unsigned int )n->kind == 114U) {
#line 716
    goto case_114;
  }
#line 723
  if ((unsigned int )n->kind == 135U) {
#line 723
    goto case_135;
  }
#line 730
  if ((unsigned int )n->kind == 136U) {
#line 730
    goto case_136;
  }
#line 737
  if ((unsigned int )n->kind == 137U) {
#line 737
    goto case_137;
  }
#line 744
  if ((unsigned int )n->kind == 138U) {
#line 744
    goto case_138;
  }
#line 751
  if ((unsigned int )n->kind == 139U) {
#line 751
    goto case_139;
  }
#line 758
  if ((unsigned int )n->kind == 116U) {
#line 758
    goto case_116;
  }
#line 765
  if ((unsigned int )n->kind == 117U) {
#line 765
    goto case_117;
  }
#line 772
  if ((unsigned int )n->kind == 118U) {
#line 772
    goto case_118;
  }
#line 779
  if ((unsigned int )n->kind == 119U) {
#line 779
    goto case_119;
  }
#line 786
  if ((unsigned int )n->kind == 120U) {
#line 786
    goto case_120;
  }
#line 793
  if ((unsigned int )n->kind == 121U) {
#line 793
    goto case_121;
  }
#line 800
  if ((unsigned int )n->kind == 122U) {
#line 800
    goto case_122;
  }
#line 807
  if ((unsigned int )n->kind == 123U) {
#line 807
    goto case_123;
  }
#line 814
  if ((unsigned int )n->kind == 124U) {
#line 814
    goto case_124;
  }
#line 821
  if ((unsigned int )n->kind == 125U) {
#line 821
    goto case_125;
  }
#line 828
  if ((unsigned int )n->kind == 126U) {
#line 828
    goto case_126;
  }
#line 835
  if ((unsigned int )n->kind == 61U) {
#line 835
    goto case_61;
  }
#line 842
  if ((unsigned int )n->kind == 62U) {
#line 842
    goto case_62;
  }
#line 849
  if ((unsigned int )n->kind == 170U) {
#line 849
    goto case_170;
  }
#line 857
  if ((unsigned int )n->kind == 172U) {
#line 857
    goto case_172;
  }
#line 865
  if ((unsigned int )n->kind == 164U) {
#line 865
    goto case_164;
  }
#line 77 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
  goto switch_default;
  case_44: /* CIL Label */ 
#line 5 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c"
  tEmPcast = (AST_generic )n;
#line 5
  if (tEmPcast) {
#line 5
    if ((unsigned int )tEmPcast->kind >= 44U) {
#line 5
      if (! ((unsigned int )tEmPcast->kind <= 44U)) {
        {
#line 5
        __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      5U, "AST_walk_children");
        }
      }
    } else {
      {
#line 5
      __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    5U, "AST_walk_children");
      }
    }
  }
  {
#line 5
  x = (asm_decl )tEmPcast;
#line 7
  AST_walk_list(s, d, (node *)(& x->asm_stmt));
  }
#line 8
  goto switch_break;
  case_45: /* CIL Label */ 
#line 11
  tEmPcast___0 = (AST_generic )n;
#line 11
  if (tEmPcast___0) {
#line 11
    if ((unsigned int )tEmPcast___0->kind >= 45U) {
#line 11
      if (! ((unsigned int )tEmPcast___0->kind <= 45U)) {
        {
#line 11
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      11U, "AST_walk_children");
        }
      }
    } else {
      {
#line 11
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    11U, "AST_walk_children");
      }
    }
  }
  {
#line 11
  x___0 = (data_decl )tEmPcast___0;
#line 13
  AST_walk_list(s, d, (node *)(& x___0->modifiers));
#line 14
  AST_walk_list(s, d, (node *)(& x___0->decls));
  }
#line 15
  goto switch_break;
  case_46: /* CIL Label */ 
#line 18
  tEmPcast___1 = (AST_generic )n;
#line 18
  if (tEmPcast___1) {
#line 18
    if ((unsigned int )tEmPcast___1->kind >= 46U) {
#line 18
      if (! ((unsigned int )tEmPcast___1->kind <= 46U)) {
        {
#line 18
        __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      18U, "AST_walk_children");
        }
      }
    } else {
      {
#line 18
      __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    18U, "AST_walk_children");
      }
    }
  }
  {
#line 18
  x___1 = (extension_decl )tEmPcast___1;
#line 20
  AST_walk_list(s, d, (node *)(& x___1->decl));
  }
#line 21
  goto switch_break;
  case_48: /* CIL Label */ 
#line 24
  tEmPcast___2 = (AST_generic )n;
#line 24
  if (tEmPcast___2) {
#line 24
    if ((unsigned int )tEmPcast___2->kind >= 48U) {
#line 24
      if (! ((unsigned int )tEmPcast___2->kind <= 48U)) {
        {
#line 24
        __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      24U, "AST_walk_children");
        }
      }
    } else {
      {
#line 24
      __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    24U, "AST_walk_children");
      }
    }
  }
  {
#line 24
  x___2 = (enumerator )tEmPcast___2;
#line 26
  AST_walk_list(s, d, (node *)(& x___2->arg1));
  }
#line 27
  goto switch_break;
  case_50: /* CIL Label */ 
#line 30
  tEmPcast___3 = (AST_generic )n;
#line 30
  if (tEmPcast___3) {
#line 30
    if ((unsigned int )tEmPcast___3->kind >= 50U) {
#line 30
      if (! ((unsigned int )tEmPcast___3->kind <= 50U)) {
        {
#line 30
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      30U, "AST_walk_children");
        }
      }
    } else {
      {
#line 30
      __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    30U, "AST_walk_children");
      }
    }
  }
  {
#line 30
  x___3 = (function_decl )tEmPcast___3;
#line 32
  AST_walk_list(s, d, (node *)(& x___3->declarator));
#line 33
  AST_walk_list(s, d, (node *)(& x___3->modifiers));
#line 34
  AST_walk_list(s, d, (node *)(& x___3->attributes));
#line 35
  AST_walk_list(s, d, (node *)(& x___3->stmt));
  }
#line 36
  goto switch_break;
  case_52: /* CIL Label */ 
#line 39
  tEmPcast___4 = (AST_generic )n;
#line 39
  if (tEmPcast___4) {
#line 39
    if ((unsigned int )tEmPcast___4->kind >= 52U) {
#line 39
      if (! ((unsigned int )tEmPcast___4->kind <= 52U)) {
        {
#line 39
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      39U, "AST_walk_children");
        }
      }
    } else {
      {
#line 39
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    39U, "AST_walk_children");
      }
    }
  }
  {
#line 39
  x___4 = (variable_decl )tEmPcast___4;
#line 41
  AST_walk_list(s, d, (node *)(& x___4->declarator));
#line 42
  AST_walk_list(s, d, (node *)(& x___4->attributes));
#line 43
  AST_walk_list(s, d, (node *)(& x___4->arg1));
#line 44
  AST_walk_list(s, d, (node *)(& x___4->asm_stmt));
  }
#line 45
  goto switch_break;
  case_53: /* CIL Label */ 
#line 48
  tEmPcast___5 = (AST_generic )n;
#line 48
  if (tEmPcast___5) {
#line 48
    if ((unsigned int )tEmPcast___5->kind >= 53U) {
#line 48
      if (! ((unsigned int )tEmPcast___5->kind <= 53U)) {
        {
#line 48
        __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      48U, "AST_walk_children");
        }
      }
    } else {
      {
#line 48
      __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    48U, "AST_walk_children");
      }
    }
  }
  {
#line 48
  x___5 = (field_decl )tEmPcast___5;
#line 50
  AST_walk_list(s, d, (node *)(& x___5->declarator));
#line 51
  AST_walk_list(s, d, (node *)(& x___5->attributes));
#line 52
  AST_walk_list(s, d, (node *)(& x___5->arg1));
  }
#line 53
  goto switch_break;
  case_188: /* CIL Label */ 
#line 56
  tEmPcast___6 = (AST_generic )n;
#line 56
  if (tEmPcast___6) {
#line 56
    if ((unsigned int )tEmPcast___6->kind >= 188U) {
#line 56
      if (! ((unsigned int )tEmPcast___6->kind <= 188U)) {
        {
#line 56
        __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      56U, "AST_walk_children");
        }
      }
    } else {
      {
#line 56
      __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    56U, "AST_walk_children");
      }
    }
  }
  {
#line 56
  x___6 = (asttype )tEmPcast___6;
#line 58
  AST_walk_list(s, d, (node *)(& x___6->declarator));
#line 59
  AST_walk_list(s, d, (node *)(& x___6->qualifiers));
  }
#line 60
  goto switch_break;
  case_160: /* CIL Label */ 
#line 63
  tEmPcast___7 = (AST_generic )n;
#line 63
  if (tEmPcast___7) {
#line 63
    if ((unsigned int )tEmPcast___7->kind >= 160U) {
#line 63
      if (! ((unsigned int )tEmPcast___7->kind <= 160U)) {
        {
#line 63
        __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      63U, "AST_walk_children");
        }
      }
    } else {
      {
#line 63
      __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    63U, "AST_walk_children");
      }
    }
  }
  {
#line 63
  x___7 = (typeof_expr )tEmPcast___7;
#line 65
  AST_walk_list(s, d, (node *)(& x___7->arg1));
  }
#line 66
  goto switch_break;
  case_161: /* CIL Label */ 
#line 69
  tEmPcast___8 = (AST_generic )n;
#line 69
  if (tEmPcast___8) {
#line 69
    if ((unsigned int )tEmPcast___8->kind >= 161U) {
#line 69
      if (! ((unsigned int )tEmPcast___8->kind <= 161U)) {
        {
#line 69
        __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      69U, "AST_walk_children");
        }
      }
    } else {
      {
#line 69
      __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    69U, "AST_walk_children");
      }
    }
  }
  {
#line 69
  x___8 = (typeof_type )tEmPcast___8;
#line 71
  AST_walk_list(s, d, (node *)(& x___8->asttype));
  }
#line 72
  goto switch_break;
  case_162: /* CIL Label */ 
#line 75
  tEmPcast___9 = (AST_generic )n;
#line 75
  if (tEmPcast___9) {
#line 75
    if ((unsigned int )tEmPcast___9->kind >= 162U) {
#line 75
      if (! ((unsigned int )tEmPcast___9->kind <= 165U)) {
        {
#line 75
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      75U, "AST_walk_children");
        }
      }
    } else {
      {
#line 75
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    75U, "AST_walk_children");
      }
    }
  }
  {
#line 75
  x___9 = (attribute )tEmPcast___9;
#line 77
  AST_walk_list(s, d, (node *)(& x___9->word1));
  }
#line 78
  goto switch_break;
  case_163: /* CIL Label */ 
#line 81
  tEmPcast___10 = (AST_generic )n;
#line 81
  if (tEmPcast___10) {
#line 81
    if ((unsigned int )tEmPcast___10->kind >= 163U) {
#line 81
      if (! ((unsigned int )tEmPcast___10->kind <= 164U)) {
        {
#line 81
        __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      81U, "AST_walk_children");
        }
      }
    } else {
      {
#line 81
      __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    81U, "AST_walk_children");
      }
    }
  }
  {
#line 81
  x___10 = (gcc_attribute )tEmPcast___10;
#line 83
  AST_walk_list(s, d, (node *)(& x___10->word1));
#line 84
  AST_walk_list(s, d, (node *)(& x___10->args));
  }
#line 85
  goto switch_break;
  case_168: /* CIL Label */ 
#line 88
  tEmPcast___11 = (AST_generic )n;
#line 88
  if (tEmPcast___11) {
#line 88
    if ((unsigned int )tEmPcast___11->kind >= 168U) {
#line 88
      if (! ((unsigned int )tEmPcast___11->kind <= 174U)) {
        {
#line 88
        __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      88U, "AST_walk_children");
        }
      }
    } else {
      {
#line 88
      __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    88U, "AST_walk_children");
      }
    }
  }
  {
#line 88
  x___11 = (tag_ref )tEmPcast___11;
#line 90
  AST_walk_list(s, d, (node *)(& x___11->word1));
#line 91
  AST_walk_list(s, d, (node *)(& x___11->attributes));
#line 92
  AST_walk_list(s, d, (node *)(& x___11->fields));
  }
#line 93
  goto switch_break;
  case_169: /* CIL Label */ 
#line 96
  tEmPcast___12 = (AST_generic )n;
#line 96
  if (tEmPcast___12) {
#line 96
    if ((unsigned int )tEmPcast___12->kind >= 169U) {
#line 96
      if (! ((unsigned int )tEmPcast___12->kind <= 170U)) {
        {
#line 96
        __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      96U, "AST_walk_children");
        }
      }
    } else {
      {
#line 96
      __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    96U, "AST_walk_children");
      }
    }
  }
  {
#line 96
  x___12 = (struct_ref )tEmPcast___12;
#line 98
  AST_walk_list(s, d, (node *)(& x___12->word1));
#line 99
  AST_walk_list(s, d, (node *)(& x___12->attributes));
#line 100
  AST_walk_list(s, d, (node *)(& x___12->fields));
  }
#line 101
  goto switch_break;
  case_171: /* CIL Label */ 
#line 104
  tEmPcast___13 = (AST_generic )n;
#line 104
  if (tEmPcast___13) {
#line 104
    if ((unsigned int )tEmPcast___13->kind >= 171U) {
#line 104
      if (! ((unsigned int )tEmPcast___13->kind <= 172U)) {
        {
#line 104
        __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      104U, "AST_walk_children");
        }
      }
    } else {
      {
#line 104
      __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    104U, "AST_walk_children");
      }
    }
  }
  {
#line 104
  x___13 = (union_ref )tEmPcast___13;
#line 106
  AST_walk_list(s, d, (node *)(& x___13->word1));
#line 107
  AST_walk_list(s, d, (node *)(& x___13->attributes));
#line 108
  AST_walk_list(s, d, (node *)(& x___13->fields));
  }
#line 109
  goto switch_break;
  case_176: /* CIL Label */ 
#line 112
  tEmPcast___14 = (AST_generic )n;
#line 112
  if (tEmPcast___14) {
#line 112
    if ((unsigned int )tEmPcast___14->kind >= 176U) {
#line 112
      if (! ((unsigned int )tEmPcast___14->kind <= 181U)) {
        {
#line 112
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      112U, "AST_walk_children");
        }
      }
    } else {
      {
#line 112
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    112U, "AST_walk_children");
      }
    }
  }
  {
#line 112
  x___14 = (nested_declarator )tEmPcast___14;
#line 114
  AST_walk_list(s, d, (node *)(& x___14->declarator));
  }
#line 115
  goto switch_break;
  case_177: /* CIL Label */ 
#line 118
  tEmPcast___15 = (AST_generic )n;
#line 118
  if (tEmPcast___15) {
#line 118
    if ((unsigned int )tEmPcast___15->kind >= 177U) {
#line 118
      if (! ((unsigned int )tEmPcast___15->kind <= 177U)) {
        {
#line 118
        __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      118U, "AST_walk_children");
        }
      }
    } else {
      {
#line 118
      __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    118U, "AST_walk_children");
      }
    }
  }
  {
#line 118
  x___15 = (function_declarator )tEmPcast___15;
#line 120
  AST_walk_list(s, d, (node *)(& x___15->declarator));
#line 121
  AST_walk_list(s, d, (node *)(& x___15->parms));
#line 122
  AST_walk_list(s, d, (node *)(& x___15->gparms));
#line 123
  AST_walk_list(s, d, (node *)(& x___15->qualifiers));
#line 124
  AST_walk_list(s, d, (node *)(& x___15->return_type));
  }
#line 125
  goto switch_break;
  case_178: /* CIL Label */ 
#line 128
  tEmPcast___16 = (AST_generic )n;
#line 128
  if (tEmPcast___16) {
#line 128
    if ((unsigned int )tEmPcast___16->kind >= 178U) {
#line 128
      if (! ((unsigned int )tEmPcast___16->kind <= 178U)) {
        {
#line 128
        __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      128U, "AST_walk_children");
        }
      }
    } else {
      {
#line 128
      __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    128U, "AST_walk_children");
      }
    }
  }
  {
#line 128
  x___16 = (pointer_declarator )tEmPcast___16;
#line 130
  AST_walk_list(s, d, (node *)(& x___16->declarator));
  }
#line 131
  goto switch_break;
  case_179: /* CIL Label */ 
#line 134
  tEmPcast___17 = (AST_generic )n;
#line 134
  if (tEmPcast___17) {
#line 134
    if ((unsigned int )tEmPcast___17->kind >= 179U) {
#line 134
      if (! ((unsigned int )tEmPcast___17->kind <= 179U)) {
        {
#line 134
        __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      134U, "AST_walk_children");
        }
      }
    } else {
      {
#line 134
      __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    134U, "AST_walk_children");
      }
    }
  }
  {
#line 134
  x___17 = (qualified_declarator )tEmPcast___17;
#line 136
  AST_walk_list(s, d, (node *)(& x___17->declarator));
#line 137
  AST_walk_list(s, d, (node *)(& x___17->modifiers));
  }
#line 138
  goto switch_break;
  case_180: /* CIL Label */ 
#line 141
  tEmPcast___18 = (AST_generic )n;
#line 141
  if (tEmPcast___18) {
#line 141
    if ((unsigned int )tEmPcast___18->kind >= 180U) {
#line 141
      if (! ((unsigned int )tEmPcast___18->kind <= 180U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      141U, "AST_walk_children");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    141U, "AST_walk_children");
      }
    }
  }
  {
#line 141
  x___18 = (array_declarator )tEmPcast___18;
#line 143
  AST_walk_list(s, d, (node *)(& x___18->declarator));
#line 144
  AST_walk_list(s, d, (node *)(& x___18->arg1));
  }
#line 145
  goto switch_break;
  case_66: /* CIL Label */ 
#line 148
  tEmPcast___19 = (AST_generic )n;
#line 148
  if (tEmPcast___19) {
#line 148
    if ((unsigned int )tEmPcast___19->kind >= 66U) {
#line 148
      if (! ((unsigned int )tEmPcast___19->kind <= 66U)) {
        {
#line 148
        __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      148U, "AST_walk_children");
        }
      }
    } else {
      {
#line 148
      __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    148U, "AST_walk_children");
      }
    }
  }
  {
#line 148
  x___19 = (asm_stmt )tEmPcast___19;
#line 150
  AST_walk_list(s, d, (node *)(& x___19->arg1));
#line 151
  AST_walk_list(s, d, (node *)(& x___19->asm_operands1));
#line 152
  AST_walk_list(s, d, (node *)(& x___19->asm_operands2));
#line 153
  AST_walk_list(s, d, (node *)(& x___19->asm_clobbers));
#line 154
  AST_walk_list(s, d, (node *)(& x___19->qualifiers));
  }
#line 155
  goto switch_break;
  case_67: /* CIL Label */ 
#line 158
  tEmPcast___20 = (AST_generic )n;
#line 158
  if (tEmPcast___20) {
#line 158
    if ((unsigned int )tEmPcast___20->kind >= 67U) {
#line 158
      if (! ((unsigned int )tEmPcast___20->kind <= 67U)) {
        {
#line 158
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      158U, "AST_walk_children");
        }
      }
    } else {
      {
#line 158
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    158U, "AST_walk_children");
      }
    }
  }
  {
#line 158
  x___20 = (compound_stmt )tEmPcast___20;
#line 160
  AST_walk_list(s, d, (node *)(& x___20->id_labels));
#line 161
  AST_walk_list(s, d, (node *)(& x___20->decls));
#line 162
  AST_walk_list(s, d, (node *)(& x___20->stmts));
  }
#line 163
  goto switch_break;
  case_68: /* CIL Label */ 
#line 166
  tEmPcast___21 = (AST_generic )n;
#line 166
  if (tEmPcast___21) {
#line 166
    if ((unsigned int )tEmPcast___21->kind >= 68U) {
#line 166
      if (! ((unsigned int )tEmPcast___21->kind <= 68U)) {
        {
#line 166
        __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      166U, "AST_walk_children");
        }
      }
    } else {
      {
#line 166
      __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    166U, "AST_walk_children");
      }
    }
  }
  {
#line 166
  x___21 = (if_stmt )tEmPcast___21;
#line 168
  AST_walk_list(s, d, (node *)(& x___21->condition));
#line 169
  AST_walk_list(s, d, (node *)(& x___21->stmt1));
#line 170
  AST_walk_list(s, d, (node *)(& x___21->stmt2));
  }
#line 171
  goto switch_break;
  case_69: /* CIL Label */ 
#line 174
  tEmPcast___22 = (AST_generic )n;
#line 174
  if (tEmPcast___22) {
#line 174
    if ((unsigned int )tEmPcast___22->kind >= 69U) {
#line 174
      if (! ((unsigned int )tEmPcast___22->kind <= 69U)) {
        {
#line 174
        __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      174U, "AST_walk_children");
        }
      }
    } else {
      {
#line 174
      __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    174U, "AST_walk_children");
      }
    }
  }
  {
#line 174
  x___22 = (labeled_stmt )tEmPcast___22;
#line 176
  AST_walk_list(s, d, (node *)(& x___22->label));
#line 177
  AST_walk_list(s, d, (node *)(& x___22->stmt));
  }
#line 178
  goto switch_break;
  case_70: /* CIL Label */ 
#line 181
  tEmPcast___23 = (AST_generic )n;
#line 181
  if (tEmPcast___23) {
#line 181
    if ((unsigned int )tEmPcast___23->kind >= 70U) {
#line 181
      if (! ((unsigned int )tEmPcast___23->kind <= 70U)) {
        {
#line 181
        __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      181U, "AST_walk_children");
        }
      }
    } else {
      {
#line 181
      __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    181U, "AST_walk_children");
      }
    }
  }
  {
#line 181
  x___23 = (expression_stmt )tEmPcast___23;
#line 183
  AST_walk_list(s, d, (node *)(& x___23->arg1));
  }
#line 184
  goto switch_break;
  case_71: /* CIL Label */ 
#line 187
  tEmPcast___24 = (AST_generic )n;
#line 187
  if (tEmPcast___24) {
#line 187
    if ((unsigned int )tEmPcast___24->kind >= 71U) {
#line 187
      if (! ((unsigned int )tEmPcast___24->kind <= 74U)) {
        {
#line 187
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      187U, "AST_walk_children");
        }
      }
    } else {
      {
#line 187
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    187U, "AST_walk_children");
      }
    }
  }
  {
#line 187
  x___24 = (conditional_stmt )tEmPcast___24;
#line 189
  AST_walk_list(s, d, (node *)(& x___24->condition));
#line 190
  AST_walk_list(s, d, (node *)(& x___24->stmt));
  }
#line 191
  goto switch_break;
  case_72: /* CIL Label */ 
#line 194
  tEmPcast___25 = (AST_generic )n;
#line 194
  if (tEmPcast___25) {
#line 194
    if ((unsigned int )tEmPcast___25->kind >= 72U) {
#line 194
      if (! ((unsigned int )tEmPcast___25->kind <= 72U)) {
        {
#line 194
        __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      194U, "AST_walk_children");
        }
      }
    } else {
      {
#line 194
      __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    194U, "AST_walk_children");
      }
    }
  }
  {
#line 194
  x___25 = (switch_stmt )tEmPcast___25;
#line 196
  AST_walk_list(s, d, (node *)(& x___25->condition));
#line 197
  AST_walk_list(s, d, (node *)(& x___25->stmt));
  }
#line 198
  goto switch_break;
  case_75: /* CIL Label */ 
#line 201
  tEmPcast___26 = (AST_generic )n;
#line 201
  if (tEmPcast___26) {
#line 201
    if ((unsigned int )tEmPcast___26->kind >= 75U) {
#line 201
      if (! ((unsigned int )tEmPcast___26->kind <= 75U)) {
        {
#line 201
        __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      201U, "AST_walk_children");
        }
      }
    } else {
      {
#line 201
      __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    201U, "AST_walk_children");
      }
    }
  }
  {
#line 201
  x___26 = (for_stmt )tEmPcast___26;
#line 203
  AST_walk_list(s, d, (node *)(& x___26->arg1));
#line 204
  AST_walk_list(s, d, (node *)(& x___26->arg2));
#line 205
  AST_walk_list(s, d, (node *)(& x___26->arg3));
#line 206
  AST_walk_list(s, d, (node *)(& x___26->stmt));
  }
#line 207
  goto switch_break;
  case_78: /* CIL Label */ 
#line 210
  tEmPcast___27 = (AST_generic )n;
#line 210
  if (tEmPcast___27) {
#line 210
    if ((unsigned int )tEmPcast___27->kind >= 78U) {
#line 210
      if (! ((unsigned int )tEmPcast___27->kind <= 78U)) {
        {
#line 210
        __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      210U, "AST_walk_children");
        }
      }
    } else {
      {
#line 210
      __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    210U, "AST_walk_children");
      }
    }
  }
  {
#line 210
  x___27 = (return_stmt )tEmPcast___27;
#line 212
  AST_walk_list(s, d, (node *)(& x___27->arg1));
  }
#line 213
  goto switch_break;
  case_79: /* CIL Label */ 
#line 216
  tEmPcast___28 = (AST_generic )n;
#line 216
  if (tEmPcast___28) {
#line 216
    if ((unsigned int )tEmPcast___28->kind >= 79U) {
#line 216
      if (! ((unsigned int )tEmPcast___28->kind <= 79U)) {
        {
#line 216
        __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      216U, "AST_walk_children");
        }
      }
    } else {
      {
#line 216
      __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    216U, "AST_walk_children");
      }
    }
  }
  {
#line 216
  x___28 = (goto_stmt )tEmPcast___28;
#line 218
  AST_walk_list(s, d, (node *)(& x___28->id_label));
  }
#line 219
  goto switch_break;
  case_80: /* CIL Label */ 
#line 222
  tEmPcast___29 = (AST_generic )n;
#line 222
  if (tEmPcast___29) {
#line 222
    if ((unsigned int )tEmPcast___29->kind >= 80U) {
#line 222
      if (! ((unsigned int )tEmPcast___29->kind <= 80U)) {
        {
#line 222
        __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      222U, "AST_walk_children");
        }
      }
    } else {
      {
#line 222
      __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    222U, "AST_walk_children");
      }
    }
  }
  {
#line 222
  x___29 = (computed_goto_stmt )tEmPcast___29;
#line 224
  AST_walk_list(s, d, (node *)(& x___29->arg1));
  }
#line 225
  goto switch_break;
  case_85: /* CIL Label */ 
#line 228
  tEmPcast___30 = (AST_generic )n;
#line 228
  if (tEmPcast___30) {
#line 228
    if ((unsigned int )tEmPcast___30->kind >= 85U) {
#line 228
      if (! ((unsigned int )tEmPcast___30->kind <= 106U)) {
        {
#line 228
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      228U, "AST_walk_children");
        }
      }
    } else {
      {
#line 228
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    228U, "AST_walk_children");
      }
    }
  }
  {
#line 228
  x___30 = (unary )tEmPcast___30;
#line 230
  AST_walk_list(s, d, (node *)(& x___30->arg1));
  }
#line 231
  goto switch_break;
  case_107: /* CIL Label */ 
#line 234
  tEmPcast___31 = (AST_generic )n;
#line 234
  if (tEmPcast___31) {
#line 234
    if ((unsigned int )tEmPcast___31->kind >= 107U) {
#line 234
      if (! ((unsigned int )tEmPcast___31->kind <= 139U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      234U, "AST_walk_children");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    234U, "AST_walk_children");
      }
    }
  }
  {
#line 234
  x___31 = (binary )tEmPcast___31;
#line 236
  AST_walk_list(s, d, (node *)(& x___31->arg1));
#line 237
  AST_walk_list(s, d, (node *)(& x___31->arg2));
  }
#line 238
  goto switch_break;
  case_140: /* CIL Label */ 
#line 241
  tEmPcast___32 = (AST_generic )n;
#line 241
  if (tEmPcast___32) {
#line 241
    if ((unsigned int )tEmPcast___32->kind >= 140U) {
#line 241
      if (! ((unsigned int )tEmPcast___32->kind <= 140U)) {
        {
#line 241
        __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      241U, "AST_walk_children");
        }
      }
    } else {
      {
#line 241
      __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    241U, "AST_walk_children");
      }
    }
  }
  {
#line 241
  x___32 = (comma )tEmPcast___32;
#line 243
  AST_walk_list(s, d, (node *)(& x___32->arg1));
  }
#line 244
  goto switch_break;
  case_141: /* CIL Label */ 
#line 247
  tEmPcast___33 = (AST_generic )n;
#line 247
  if (tEmPcast___33) {
#line 247
    if ((unsigned int )tEmPcast___33->kind >= 141U) {
#line 247
      if (! ((unsigned int )tEmPcast___33->kind <= 141U)) {
        {
#line 247
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      247U, "AST_walk_children");
        }
      }
    } else {
      {
#line 247
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    247U, "AST_walk_children");
      }
    }
  }
  {
#line 247
  x___33 = (sizeof_type )tEmPcast___33;
#line 249
  AST_walk_list(s, d, (node *)(& x___33->asttype));
  }
#line 250
  goto switch_break;
  case_142: /* CIL Label */ 
#line 253
  tEmPcast___34 = (AST_generic )n;
#line 253
  if (tEmPcast___34) {
#line 253
    if ((unsigned int )tEmPcast___34->kind >= 142U) {
#line 253
      if (! ((unsigned int )tEmPcast___34->kind <= 142U)) {
        {
#line 253
        __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      253U, "AST_walk_children");
        }
      }
    } else {
      {
#line 253
      __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    253U, "AST_walk_children");
      }
    }
  }
  {
#line 253
  x___34 = (alignof_type )tEmPcast___34;
#line 255
  AST_walk_list(s, d, (node *)(& x___34->asttype));
  }
#line 256
  goto switch_break;
  case_143: /* CIL Label */ 
#line 259
  tEmPcast___35 = (AST_generic )n;
#line 259
  if (tEmPcast___35) {
#line 259
    if ((unsigned int )tEmPcast___35->kind >= 143U) {
#line 259
      if (! ((unsigned int )tEmPcast___35->kind <= 143U)) {
        {
#line 259
        __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      259U, "AST_walk_children");
        }
      }
    } else {
      {
#line 259
      __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    259U, "AST_walk_children");
      }
    }
  }
  {
#line 259
  x___35 = (label_address )tEmPcast___35;
#line 261
  AST_walk_list(s, d, (node *)(& x___35->id_label));
  }
#line 262
  goto switch_break;
  case_86: /* CIL Label */ 
#line 265
  tEmPcast___36 = (AST_generic )n;
#line 265
  if (tEmPcast___36) {
#line 265
    if ((unsigned int )tEmPcast___36->kind >= 86U) {
#line 265
      if (! ((unsigned int )tEmPcast___36->kind <= 86U)) {
        {
#line 265
        __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      265U, "AST_walk_children");
        }
      }
    } else {
      {
#line 265
      __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    265U, "AST_walk_children");
      }
    }
  }
  {
#line 265
  x___36 = (cast )tEmPcast___36;
#line 267
  AST_walk_list(s, d, (node *)(& x___36->arg1));
#line 268
  AST_walk_list(s, d, (node *)(& x___36->asttype));
  }
#line 269
  goto switch_break;
  case_144: /* CIL Label */ 
#line 272
  tEmPcast___37 = (AST_generic )n;
#line 272
  if (tEmPcast___37) {
#line 272
    if ((unsigned int )tEmPcast___37->kind >= 144U) {
#line 272
      if (! ((unsigned int )tEmPcast___37->kind <= 144U)) {
        {
#line 272
        __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      272U, "AST_walk_children");
        }
      }
    } else {
      {
#line 272
      __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    272U, "AST_walk_children");
      }
    }
  }
  {
#line 272
  x___37 = (cast_list )tEmPcast___37;
#line 274
  AST_walk_list(s, d, (node *)(& x___37->asttype));
#line 275
  AST_walk_list(s, d, (node *)(& x___37->init_expr));
  }
#line 276
  goto switch_break;
  case_145: /* CIL Label */ 
#line 279
  tEmPcast___38 = (AST_generic )n;
#line 279
  if (tEmPcast___38) {
#line 279
    if ((unsigned int )tEmPcast___38->kind >= 145U) {
#line 279
      if (! ((unsigned int )tEmPcast___38->kind <= 145U)) {
        {
#line 279
        __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      279U, "AST_walk_children");
        }
      }
    } else {
      {
#line 279
      __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    279U, "AST_walk_children");
      }
    }
  }
  {
#line 279
  x___38 = (conditional )tEmPcast___38;
#line 281
  AST_walk_list(s, d, (node *)(& x___38->condition));
#line 282
  AST_walk_list(s, d, (node *)(& x___38->arg1));
#line 283
  AST_walk_list(s, d, (node *)(& x___38->arg2));
  }
#line 284
  goto switch_break;
  case_147: /* CIL Label */ 
#line 287
  tEmPcast___39 = (AST_generic )n;
#line 287
  if (tEmPcast___39) {
#line 287
    if ((unsigned int )tEmPcast___39->kind >= 147U) {
#line 287
      if (! ((unsigned int )tEmPcast___39->kind <= 147U)) {
        {
#line 287
        __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      287U, "AST_walk_children");
        }
      }
    } else {
      {
#line 287
      __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    287U, "AST_walk_children");
      }
    }
  }
  {
#line 287
  x___39 = (compound_expr )tEmPcast___39;
#line 289
  AST_walk_list(s, d, (node *)(& x___39->stmt));
  }
#line 290
  goto switch_break;
  case_148: /* CIL Label */ 
#line 293
  tEmPcast___40 = (AST_generic )n;
#line 293
  if (tEmPcast___40) {
#line 293
    if ((unsigned int )tEmPcast___40->kind >= 148U) {
#line 293
      if (! ((unsigned int )tEmPcast___40->kind <= 148U)) {
        {
#line 293
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      293U, "AST_walk_children");
        }
      }
    } else {
      {
#line 293
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    293U, "AST_walk_children");
      }
    }
  }
  {
#line 293
  x___40 = (function_call )tEmPcast___40;
#line 295
  AST_walk_list(s, d, (node *)(& x___40->arg1));
#line 296
  AST_walk_list(s, d, (node *)(& x___40->args));
  }
#line 297
  goto switch_break;
  case_87: /* CIL Label */ 
#line 300
  tEmPcast___41 = (AST_generic )n;
#line 300
  if (tEmPcast___41) {
#line 300
    if ((unsigned int )tEmPcast___41->kind >= 87U) {
#line 300
      if (! ((unsigned int )tEmPcast___41->kind <= 87U)) {
        {
#line 300
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      300U, "AST_walk_children");
        }
      }
    } else {
      {
#line 300
      __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    300U, "AST_walk_children");
      }
    }
  }
  {
#line 300
  x___41 = (field_ref )tEmPcast___41;
#line 302
  AST_walk_list(s, d, (node *)(& x___41->arg1));
  }
#line 303
  goto switch_break;
  case_88: /* CIL Label */ 
#line 306
  tEmPcast___42 = (AST_generic )n;
#line 306
  if (tEmPcast___42) {
#line 306
    if ((unsigned int )tEmPcast___42->kind >= 88U) {
#line 306
      if (! ((unsigned int )tEmPcast___42->kind <= 92U)) {
        {
#line 306
        __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      306U, "AST_walk_children");
        }
      }
    } else {
      {
#line 306
      __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    306U, "AST_walk_children");
      }
    }
  }
  {
#line 306
  x___42 = (increment )tEmPcast___42;
#line 308
  AST_walk_list(s, d, (node *)(& x___42->arg1));
  }
#line 309
  goto switch_break;
  case_108: /* CIL Label */ 
#line 312
  tEmPcast___43 = (AST_generic )n;
#line 312
  if (tEmPcast___43) {
#line 312
    if ((unsigned int )tEmPcast___43->kind >= 108U) {
#line 312
      if (! ((unsigned int )tEmPcast___43->kind <= 114U)) {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      312U, "AST_walk_children");
        }
      }
    } else {
      {
#line 312
      __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    312U, "AST_walk_children");
      }
    }
  }
  {
#line 312
  x___43 = (comparison )tEmPcast___43;
#line 314
  AST_walk_list(s, d, (node *)(& x___43->arg1));
#line 315
  AST_walk_list(s, d, (node *)(& x___43->arg2));
  }
#line 316
  goto switch_break;
  case_115: /* CIL Label */ 
#line 319
  tEmPcast___44 = (AST_generic )n;
#line 319
  if (tEmPcast___44) {
#line 319
    if ((unsigned int )tEmPcast___44->kind >= 115U) {
#line 319
      if (! ((unsigned int )tEmPcast___44->kind <= 126U)) {
        {
#line 319
        __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      319U, "AST_walk_children");
        }
      }
    } else {
      {
#line 319
      __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    319U, "AST_walk_children");
      }
    }
  }
  {
#line 319
  x___44 = (assignment )tEmPcast___44;
#line 321
  AST_walk_list(s, d, (node *)(& x___44->arg1));
#line 322
  AST_walk_list(s, d, (node *)(& x___44->arg2));
  }
#line 323
  goto switch_break;
  case_149: /* CIL Label */ 
#line 326
  tEmPcast___45 = (AST_generic )n;
#line 326
  if (tEmPcast___45) {
#line 326
    if ((unsigned int )tEmPcast___45->kind >= 149U) {
#line 326
      if (! ((unsigned int )tEmPcast___45->kind <= 149U)) {
        {
#line 326
        __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      326U, "AST_walk_children");
        }
      }
    } else {
      {
#line 326
      __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    326U, "AST_walk_children");
      }
    }
  }
  {
#line 326
  x___45 = (init_list )tEmPcast___45;
#line 328
  AST_walk_list(s, d, (node *)(& x___45->args));
  }
#line 329
  goto switch_break;
  case_150: /* CIL Label */ 
#line 332
  tEmPcast___46 = (AST_generic )n;
#line 332
  if (tEmPcast___46) {
#line 332
    if ((unsigned int )tEmPcast___46->kind >= 150U) {
#line 332
      if (! ((unsigned int )tEmPcast___46->kind <= 150U)) {
        {
#line 332
        __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      332U, "AST_walk_children");
        }
      }
    } else {
      {
#line 332
      __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    332U, "AST_walk_children");
      }
    }
  }
  {
#line 332
  x___46 = (init_specific )tEmPcast___46;
#line 334
  AST_walk_list(s, d, (node *)(& x___46->designator));
#line 335
  AST_walk_list(s, d, (node *)(& x___46->init_expr));
  }
#line 336
  goto switch_break;
  case_191: /* CIL Label */ 
#line 339
  tEmPcast___47 = (AST_generic )n;
#line 339
  if (tEmPcast___47) {
#line 339
    if ((unsigned int )tEmPcast___47->kind >= 191U) {
#line 339
      if (! ((unsigned int )tEmPcast___47->kind <= 191U)) {
        {
#line 339
        __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      339U, "AST_walk_children");
        }
      }
    } else {
      {
#line 339
      __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    339U, "AST_walk_children");
      }
    }
  }
  {
#line 339
  x___47 = (designate_index )tEmPcast___47;
#line 341
  AST_walk_list(s, d, (node *)(& x___47->arg1));
#line 342
  AST_walk_list(s, d, (node *)(& x___47->arg2));
  }
#line 343
  goto switch_break;
  case_153: /* CIL Label */ 
#line 346
  tEmPcast___48 = (AST_generic )n;
#line 346
  if (tEmPcast___48) {
#line 346
    if ((unsigned int )tEmPcast___48->kind >= 153U) {
#line 346
      if (! ((unsigned int )tEmPcast___48->kind <= 153U)) {
        {
#line 346
        __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      346U, "AST_walk_children");
        }
      }
    } else {
      {
#line 346
      __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    346U, "AST_walk_children");
      }
    }
  }
  {
#line 346
  x___48 = (string )tEmPcast___48;
#line 348
  AST_walk_list(s, d, (node *)(& x___48->strings));
  }
#line 349
  goto switch_break;
  case_186: /* CIL Label */ 
#line 352
  tEmPcast___49 = (AST_generic )n;
#line 352
  if (tEmPcast___49) {
#line 352
    if ((unsigned int )tEmPcast___49->kind >= 186U) {
#line 352
      if (! ((unsigned int )tEmPcast___49->kind <= 186U)) {
        {
#line 352
        __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      352U, "AST_walk_children");
        }
      }
    } else {
      {
#line 352
      __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    352U, "AST_walk_children");
      }
    }
  }
  {
#line 352
  x___49 = (case_label )tEmPcast___49;
#line 354
  AST_walk_list(s, d, (node *)(& x___49->arg1));
#line 355
  AST_walk_list(s, d, (node *)(& x___49->arg2));
  }
#line 356
  goto switch_break;
  case_193: /* CIL Label */ 
#line 359
  tEmPcast___50 = (AST_generic )n;
#line 359
  if (tEmPcast___50) {
#line 359
    if ((unsigned int )tEmPcast___50->kind >= 193U) {
#line 359
      if (! ((unsigned int )tEmPcast___50->kind <= 193U)) {
        {
#line 359
        __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      359U, "AST_walk_children");
        }
      }
    } else {
      {
#line 359
      __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    359U, "AST_walk_children");
      }
    }
  }
  {
#line 359
  x___50 = (asm_operand )tEmPcast___50;
#line 361
  AST_walk_list(s, d, (node *)(& x___50->word1));
#line 362
  AST_walk_list(s, d, (node *)(& x___50->string));
#line 363
  AST_walk_list(s, d, (node *)(& x___50->arg1));
  }
#line 364
  goto switch_break;
  case_54: /* CIL Label */ 
#line 367
  tEmPcast___51 = (AST_generic )n;
#line 367
  if (tEmPcast___51) {
#line 367
    if ((unsigned int )tEmPcast___51->kind >= 54U) {
#line 367
      if (! ((unsigned int )tEmPcast___51->kind <= 56U)) {
        {
#line 367
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      367U, "AST_walk_children");
        }
      }
    } else {
      {
#line 367
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    367U, "AST_walk_children");
      }
    }
  }
  {
#line 367
  x___51 = (nesc_decl )tEmPcast___51;
#line 369
  AST_walk_list(s, d, (node *)(& x___51->word1));
#line 370
  AST_walk_list(s, d, (node *)(& x___51->attributes));
  }
#line 371
  goto switch_break;
  case_55: /* CIL Label */ 
#line 374
  tEmPcast___52 = (AST_generic )n;
#line 374
  if (tEmPcast___52) {
#line 374
    if ((unsigned int )tEmPcast___52->kind >= 55U) {
#line 374
      if (! ((unsigned int )tEmPcast___52->kind <= 55U)) {
        {
#line 374
        __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      374U, "AST_walk_children");
        }
      }
    } else {
      {
#line 374
      __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    374U, "AST_walk_children");
      }
    }
  }
  {
#line 374
  x___52 = (interface )tEmPcast___52;
#line 376
  AST_walk_list(s, d, (node *)(& x___52->word1));
#line 377
  AST_walk_list(s, d, (node *)(& x___52->attributes));
#line 378
  AST_walk_list(s, d, (node *)(& x___52->decls));
  }
#line 379
  goto switch_break;
  case_56: /* CIL Label */ 
#line 382
  tEmPcast___53 = (AST_generic )n;
#line 382
  if (tEmPcast___53) {
#line 382
    if ((unsigned int )tEmPcast___53->kind >= 56U) {
#line 382
      if (! ((unsigned int )tEmPcast___53->kind <= 56U)) {
        {
#line 382
        __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      382U, "AST_walk_children");
        }
      }
    } else {
      {
#line 382
      __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    382U, "AST_walk_children");
      }
    }
  }
  {
#line 382
  x___53 = (component )tEmPcast___53;
#line 384
  AST_walk_list(s, d, (node *)(& x___53->word1));
#line 385
  AST_walk_list(s, d, (node *)(& x___53->attributes));
#line 386
  AST_walk_list(s, d, (node *)(& x___53->parms));
#line 387
  AST_walk_list(s, d, (node *)(& x___53->decls));
#line 388
  AST_walk_list(s, d, (node *)(& x___53->implementation));
  }
#line 389
  goto switch_break;
  case_195: /* CIL Label */ 
#line 392
  tEmPcast___54 = (AST_generic )n;
#line 392
  if (tEmPcast___54) {
#line 392
    if ((unsigned int )tEmPcast___54->kind >= 195U) {
#line 392
      if (! ((unsigned int )tEmPcast___54->kind <= 195U)) {
        {
#line 392
        __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      392U, "AST_walk_children");
        }
      }
    } else {
      {
#line 392
      __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    392U, "AST_walk_children");
      }
    }
  }
  {
#line 392
  x___54 = (configuration )tEmPcast___54;
#line 394
  AST_walk_list(s, d, (node *)(& x___54->decls));
  }
#line 395
  goto switch_break;
  case_196: /* CIL Label */ 
#line 398
  tEmPcast___55 = (AST_generic )n;
#line 398
  if (tEmPcast___55) {
#line 398
    if ((unsigned int )tEmPcast___55->kind >= 196U) {
#line 398
      if (! ((unsigned int )tEmPcast___55->kind <= 196U)) {
        {
#line 398
        __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      398U, "AST_walk_children");
        }
      }
    } else {
      {
#line 398
      __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    398U, "AST_walk_children");
      }
    }
  }
  {
#line 398
  x___55 = (module )tEmPcast___55;
#line 400
  AST_walk_list(s, d, (node *)(& x___55->decls));
  }
#line 401
  goto switch_break;
  case_57: /* CIL Label */ 
#line 404
  tEmPcast___56 = (AST_generic )n;
#line 404
  if (tEmPcast___56) {
#line 404
    if ((unsigned int )tEmPcast___56->kind >= 57U) {
#line 404
      if (! ((unsigned int )tEmPcast___56->kind <= 57U)) {
        {
#line 404
        __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      404U, "AST_walk_children");
        }
      }
    } else {
      {
#line 404
      __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    404U, "AST_walk_children");
      }
    }
  }
  {
#line 404
  x___56 = (rp_interface )tEmPcast___56;
#line 406
  AST_walk_list(s, d, (node *)(& x___56->decls));
  }
#line 407
  goto switch_break;
  case_58: /* CIL Label */ 
#line 410
  tEmPcast___57 = (AST_generic )n;
#line 410
  if (tEmPcast___57) {
#line 410
    if ((unsigned int )tEmPcast___57->kind >= 58U) {
#line 410
      if (! ((unsigned int )tEmPcast___57->kind <= 58U)) {
        {
#line 410
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      410U, "AST_walk_children");
        }
      }
    } else {
      {
#line 410
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    410U, "AST_walk_children");
      }
    }
  }
  {
#line 410
  x___57 = (interface_ref )tEmPcast___57;
#line 412
  AST_walk_list(s, d, (node *)(& x___57->word1));
#line 413
  AST_walk_list(s, d, (node *)(& x___57->args));
#line 414
  AST_walk_list(s, d, (node *)(& x___57->word2));
#line 415
  AST_walk_list(s, d, (node *)(& x___57->gparms));
#line 416
  AST_walk_list(s, d, (node *)(& x___57->attributes));
  }
#line 417
  goto switch_break;
  case_59: /* CIL Label */ 
#line 420
  tEmPcast___58 = (AST_generic )n;
#line 420
  if (tEmPcast___58) {
#line 420
    if ((unsigned int )tEmPcast___58->kind >= 59U) {
#line 420
      if (! ((unsigned int )tEmPcast___58->kind <= 59U)) {
        {
#line 420
        __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      420U, "AST_walk_children");
        }
      }
    } else {
      {
#line 420
      __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    420U, "AST_walk_children");
      }
    }
  }
  {
#line 420
  x___58 = (component_ref )tEmPcast___58;
#line 422
  AST_walk_list(s, d, (node *)(& x___58->word1));
#line 423
  AST_walk_list(s, d, (node *)(& x___58->word2));
#line 424
  AST_walk_list(s, d, (node *)(& x___58->args));
  }
#line 425
  goto switch_break;
  case_60: /* CIL Label */ 
#line 428
  tEmPcast___59 = (AST_generic )n;
#line 428
  if (tEmPcast___59) {
#line 428
    if ((unsigned int )tEmPcast___59->kind >= 60U) {
#line 428
      if (! ((unsigned int )tEmPcast___59->kind <= 62U)) {
        {
#line 428
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      428U, "AST_walk_children");
        }
      }
    } else {
      {
#line 428
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    428U, "AST_walk_children");
      }
    }
  }
  {
#line 428
  x___59 = (connection )tEmPcast___59;
#line 430
  AST_walk_list(s, d, (node *)(& x___59->ep1));
#line 431
  AST_walk_list(s, d, (node *)(& x___59->ep2));
  }
#line 432
  goto switch_break;
  case_198: /* CIL Label */ 
#line 435
  tEmPcast___60 = (AST_generic )n;
#line 435
  if (tEmPcast___60) {
#line 435
    if ((unsigned int )tEmPcast___60->kind >= 198U) {
#line 435
      if (! ((unsigned int )tEmPcast___60->kind <= 198U)) {
        {
#line 435
        __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      435U, "AST_walk_children");
        }
      }
    } else {
      {
#line 435
      __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    435U, "AST_walk_children");
      }
    }
  }
  {
#line 435
  x___60 = (endpoint )tEmPcast___60;
#line 437
  AST_walk_list(s, d, (node *)(& x___60->ids));
  }
#line 438
  goto switch_break;
  case_199: /* CIL Label */ 
#line 441
  tEmPcast___61 = (AST_generic )n;
#line 441
  if (tEmPcast___61) {
#line 441
    if ((unsigned int )tEmPcast___61->kind >= 199U) {
#line 441
      if (! ((unsigned int )tEmPcast___61->kind <= 199U)) {
        {
#line 441
        __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      441U, "AST_walk_children");
        }
      }
    } else {
      {
#line 441
      __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    441U, "AST_walk_children");
      }
    }
  }
  {
#line 441
  x___61 = (parameterised_identifier )tEmPcast___61;
#line 443
  AST_walk_list(s, d, (node *)(& x___61->word1));
#line 444
  AST_walk_list(s, d, (node *)(& x___61->args));
  }
#line 445
  goto switch_break;
  case_183: /* CIL Label */ 
#line 448
  tEmPcast___62 = (AST_generic )n;
#line 448
  if (tEmPcast___62) {
#line 448
    if ((unsigned int )tEmPcast___62->kind >= 183U) {
#line 448
      if (! ((unsigned int )tEmPcast___62->kind <= 183U)) {
        {
#line 448
        __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      448U, "AST_walk_children");
        }
      }
    } else {
      {
#line 448
      __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    448U, "AST_walk_children");
      }
    }
  }
  {
#line 448
  x___62 = (generic_declarator )tEmPcast___62;
#line 450
  AST_walk_list(s, d, (node *)(& x___62->declarator));
#line 451
  AST_walk_list(s, d, (node *)(& x___62->parms));
  }
#line 452
  goto switch_break;
  case_154: /* CIL Label */ 
#line 455
  tEmPcast___63 = (AST_generic )n;
#line 455
  if (tEmPcast___63) {
#line 455
    if ((unsigned int )tEmPcast___63->kind >= 154U) {
#line 455
      if (! ((unsigned int )tEmPcast___63->kind <= 154U)) {
        {
#line 455
        __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      455U, "AST_walk_children");
        }
      }
    } else {
      {
#line 455
      __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    455U, "AST_walk_children");
      }
    }
  }
  {
#line 455
  x___63 = (generic_call )tEmPcast___63;
#line 457
  AST_walk_list(s, d, (node *)(& x___63->arg1));
#line 458
  AST_walk_list(s, d, (node *)(& x___63->args));
  }
#line 459
  goto switch_break;
  case_181: /* CIL Label */ 
#line 462
  tEmPcast___64 = (AST_generic )n;
#line 462
  if (tEmPcast___64) {
#line 462
    if ((unsigned int )tEmPcast___64->kind >= 181U) {
#line 462
      if (! ((unsigned int )tEmPcast___64->kind <= 181U)) {
        {
#line 462
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      462U, "AST_walk_children");
        }
      }
    } else {
      {
#line 462
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    462U, "AST_walk_children");
      }
    }
  }
  {
#line 462
  x___64 = (interface_ref_declarator )tEmPcast___64;
#line 464
  AST_walk_list(s, d, (node *)(& x___64->declarator));
#line 465
  AST_walk_list(s, d, (node *)(& x___64->word1));
  }
#line 466
  goto switch_break;
  case_93: /* CIL Label */ 
#line 469
  tEmPcast___65 = (AST_generic )n;
#line 469
  if (tEmPcast___65) {
#line 469
    if ((unsigned int )tEmPcast___65->kind >= 93U) {
#line 469
      if (! ((unsigned int )tEmPcast___65->kind <= 93U)) {
        {
#line 469
        __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      469U, "AST_walk_children");
        }
      }
    } else {
      {
#line 469
      __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    469U, "AST_walk_children");
      }
    }
  }
  {
#line 469
  x___65 = (interface_deref )tEmPcast___65;
#line 471
  AST_walk_list(s, d, (node *)(& x___65->arg1));
  }
#line 472
  goto switch_break;
  case_94: /* CIL Label */ 
#line 475
  tEmPcast___66 = (AST_generic )n;
#line 475
  if (tEmPcast___66) {
#line 475
    if ((unsigned int )tEmPcast___66->kind >= 94U) {
#line 475
      if (! ((unsigned int )tEmPcast___66->kind <= 94U)) {
        {
#line 475
        __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      475U, "AST_walk_children");
        }
      }
    } else {
      {
#line 475
      __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    475U, "AST_walk_children");
      }
    }
  }
  {
#line 475
  x___66 = (component_deref )tEmPcast___66;
#line 477
  AST_walk_list(s, d, (node *)(& x___66->arg1));
  }
#line 478
  goto switch_break;
  case_82: /* CIL Label */ 
#line 481
  tEmPcast___67 = (AST_generic )n;
#line 481
  if (tEmPcast___67) {
#line 481
    if ((unsigned int )tEmPcast___67->kind >= 82U) {
#line 481
      if (! ((unsigned int )tEmPcast___67->kind <= 82U)) {
        {
#line 481
        __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      481U, "AST_walk_children");
        }
      }
    } else {
      {
#line 481
      __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    481U, "AST_walk_children");
      }
    }
  }
  {
#line 481
  x___67 = (atomic_stmt )tEmPcast___67;
#line 483
  AST_walk_list(s, d, (node *)(& x___67->stmt));
  }
#line 484
  goto switch_break;
  case_165: /* CIL Label */ 
#line 487
  tEmPcast___68 = (AST_generic )n;
#line 487
  if (tEmPcast___68) {
#line 487
    if ((unsigned int )tEmPcast___68->kind >= 165U) {
#line 487
      if (! ((unsigned int )tEmPcast___68->kind <= 165U)) {
        {
#line 487
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      487U, "AST_walk_children");
        }
      }
    } else {
      {
#line 487
      __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    487U, "AST_walk_children");
      }
    }
  }
  {
#line 487
  x___68 = (nesc_attribute )tEmPcast___68;
#line 489
  AST_walk_list(s, d, (node *)(& x___68->word1));
#line 490
  AST_walk_list(s, d, (node *)(& x___68->arg1));
  }
#line 491
  goto switch_break;
  case_155: /* CIL Label */ 
#line 494
  tEmPcast___69 = (AST_generic )n;
#line 494
  if (tEmPcast___69) {
#line 494
    if ((unsigned int )tEmPcast___69->kind >= 155U) {
#line 494
      if (! ((unsigned int )tEmPcast___69->kind <= 155U)) {
        {
#line 494
        __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      494U, "AST_walk_children");
        }
      }
    } else {
      {
#line 494
      __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    494U, "AST_walk_children");
      }
    }
  }
  {
#line 494
  x___69 = (type_argument )tEmPcast___69;
#line 496
  AST_walk_list(s, d, (node *)(& x___69->asttype));
  }
#line 497
  goto switch_break;
  case_173: /* CIL Label */ 
#line 500
  tEmPcast___70 = (AST_generic )n;
#line 500
  if (tEmPcast___70) {
#line 500
    if ((unsigned int )tEmPcast___70->kind >= 173U) {
#line 500
      if (! ((unsigned int )tEmPcast___70->kind <= 173U)) {
        {
#line 500
        __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      500U, "AST_walk_children");
        }
      }
    } else {
      {
#line 500
      __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    500U, "AST_walk_children");
      }
    }
  }
  {
#line 500
  x___70 = (attribute_ref )tEmPcast___70;
#line 502
  AST_walk_list(s, d, (node *)(& x___70->word1));
#line 503
  AST_walk_list(s, d, (node *)(& x___70->attributes));
#line 504
  AST_walk_list(s, d, (node *)(& x___70->fields));
  }
#line 505
  goto switch_break;
  case_174: /* CIL Label */ 
#line 508
  tEmPcast___71 = (AST_generic )n;
#line 508
  if (tEmPcast___71) {
#line 508
    if ((unsigned int )tEmPcast___71->kind >= 174U) {
#line 508
      if (! ((unsigned int )tEmPcast___71->kind <= 174U)) {
        {
#line 508
        __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      508U, "AST_walk_children");
        }
      }
    } else {
      {
#line 508
      __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    508U, "AST_walk_children");
      }
    }
  }
  {
#line 508
  x___71 = (enum_ref )tEmPcast___71;
#line 510
  AST_walk_list(s, d, (node *)(& x___71->word1));
#line 511
  AST_walk_list(s, d, (node *)(& x___71->attributes));
#line 512
  AST_walk_list(s, d, (node *)(& x___71->fields));
  }
#line 513
  goto switch_break;
  case_73: /* CIL Label */ 
#line 516
  tEmPcast___72 = (AST_generic )n;
#line 516
  if (tEmPcast___72) {
#line 516
    if ((unsigned int )tEmPcast___72->kind >= 73U) {
#line 516
      if (! ((unsigned int )tEmPcast___72->kind <= 73U)) {
        {
#line 516
        __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      516U, "AST_walk_children");
        }
      }
    } else {
      {
#line 516
      __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    516U, "AST_walk_children");
      }
    }
  }
  {
#line 516
  x___72 = (while_stmt )tEmPcast___72;
#line 518
  AST_walk_list(s, d, (node *)(& x___72->condition));
#line 519
  AST_walk_list(s, d, (node *)(& x___72->stmt));
  }
#line 520
  goto switch_break;
  case_74: /* CIL Label */ 
#line 523
  tEmPcast___73 = (AST_generic )n;
#line 523
  if (tEmPcast___73) {
#line 523
    if ((unsigned int )tEmPcast___73->kind >= 74U) {
#line 523
      if (! ((unsigned int )tEmPcast___73->kind <= 74U)) {
        {
#line 523
        __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      523U, "AST_walk_children");
        }
      }
    } else {
      {
#line 523
      __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    523U, "AST_walk_children");
      }
    }
  }
  {
#line 523
  x___73 = (dowhile_stmt )tEmPcast___73;
#line 525
  AST_walk_list(s, d, (node *)(& x___73->condition));
#line 526
  AST_walk_list(s, d, (node *)(& x___73->stmt));
  }
#line 527
  goto switch_break;
  case_127: /* CIL Label */ 
#line 530
  tEmPcast___74 = (AST_generic )n;
#line 530
  if (tEmPcast___74) {
#line 530
    if ((unsigned int )tEmPcast___74->kind >= 127U) {
#line 530
      if (! ((unsigned int )tEmPcast___74->kind <= 127U)) {
        {
#line 530
        __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      530U, "AST_walk_children");
        }
      }
    } else {
      {
#line 530
      __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    530U, "AST_walk_children");
      }
    }
  }
  {
#line 530
  x___74 = (array_ref )tEmPcast___74;
#line 532
  AST_walk_list(s, d, (node *)(& x___74->arg1));
#line 533
  AST_walk_list(s, d, (node *)(& x___74->arg2));
  }
#line 534
  goto switch_break;
  case_95: /* CIL Label */ 
#line 537
  tEmPcast___75 = (AST_generic )n;
#line 537
  if (tEmPcast___75) {
#line 537
    if ((unsigned int )tEmPcast___75->kind >= 95U) {
#line 537
      if (! ((unsigned int )tEmPcast___75->kind <= 95U)) {
        {
#line 537
        __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      537U, "AST_walk_children");
        }
      }
    } else {
      {
#line 537
      __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    537U, "AST_walk_children");
      }
    }
  }
  {
#line 537
  x___75 = (dereference )tEmPcast___75;
#line 539
  AST_walk_list(s, d, (node *)(& x___75->arg1));
  }
#line 540
  goto switch_break;
  case_96: /* CIL Label */ 
#line 543
  tEmPcast___76 = (AST_generic )n;
#line 543
  if (tEmPcast___76) {
#line 543
    if ((unsigned int )tEmPcast___76->kind >= 96U) {
#line 543
      if (! ((unsigned int )tEmPcast___76->kind <= 96U)) {
        {
#line 543
        __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      543U, "AST_walk_children");
        }
      }
    } else {
      {
#line 543
      __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    543U, "AST_walk_children");
      }
    }
  }
  {
#line 543
  x___76 = (extension_expr )tEmPcast___76;
#line 545
  AST_walk_list(s, d, (node *)(& x___76->arg1));
  }
#line 546
  goto switch_break;
  case_97: /* CIL Label */ 
#line 549
  tEmPcast___77 = (AST_generic )n;
#line 549
  if (tEmPcast___77) {
#line 549
    if ((unsigned int )tEmPcast___77->kind >= 97U) {
#line 549
      if (! ((unsigned int )tEmPcast___77->kind <= 97U)) {
        {
#line 549
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      549U, "AST_walk_children");
        }
      }
    } else {
      {
#line 549
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    549U, "AST_walk_children");
      }
    }
  }
  {
#line 549
  x___77 = (sizeof_expr )tEmPcast___77;
#line 551
  AST_walk_list(s, d, (node *)(& x___77->arg1));
  }
#line 552
  goto switch_break;
  case_98: /* CIL Label */ 
#line 555
  tEmPcast___78 = (AST_generic )n;
#line 555
  if (tEmPcast___78) {
#line 555
    if ((unsigned int )tEmPcast___78->kind >= 98U) {
#line 555
      if (! ((unsigned int )tEmPcast___78->kind <= 98U)) {
        {
#line 555
        __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      555U, "AST_walk_children");
        }
      }
    } else {
      {
#line 555
      __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    555U, "AST_walk_children");
      }
    }
  }
  {
#line 555
  x___78 = (alignof_expr )tEmPcast___78;
#line 557
  AST_walk_list(s, d, (node *)(& x___78->arg1));
  }
#line 558
  goto switch_break;
  case_99: /* CIL Label */ 
#line 561
  tEmPcast___79 = (AST_generic )n;
#line 561
  if (tEmPcast___79) {
#line 561
    if ((unsigned int )tEmPcast___79->kind >= 99U) {
#line 561
      if (! ((unsigned int )tEmPcast___79->kind <= 99U)) {
        {
#line 561
        __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      561U, "AST_walk_children");
        }
      }
    } else {
      {
#line 561
      __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    561U, "AST_walk_children");
      }
    }
  }
  {
#line 561
  x___79 = (realpart )tEmPcast___79;
#line 563
  AST_walk_list(s, d, (node *)(& x___79->arg1));
  }
#line 564
  goto switch_break;
  case_100: /* CIL Label */ 
#line 567
  tEmPcast___80 = (AST_generic )n;
#line 567
  if (tEmPcast___80) {
#line 567
    if ((unsigned int )tEmPcast___80->kind >= 100U) {
#line 567
      if (! ((unsigned int )tEmPcast___80->kind <= 100U)) {
        {
#line 567
        __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      567U, "AST_walk_children");
        }
      }
    } else {
      {
#line 567
      __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    567U, "AST_walk_children");
      }
    }
  }
  {
#line 567
  x___80 = (imagpart )tEmPcast___80;
#line 569
  AST_walk_list(s, d, (node *)(& x___80->arg1));
  }
#line 570
  goto switch_break;
  case_101: /* CIL Label */ 
#line 573
  tEmPcast___81 = (AST_generic )n;
#line 573
  if (tEmPcast___81) {
#line 573
    if ((unsigned int )tEmPcast___81->kind >= 101U) {
#line 573
      if (! ((unsigned int )tEmPcast___81->kind <= 101U)) {
        {
#line 573
        __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      573U, "AST_walk_children");
        }
      }
    } else {
      {
#line 573
      __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    573U, "AST_walk_children");
      }
    }
  }
  {
#line 573
  x___81 = (address_of )tEmPcast___81;
#line 575
  AST_walk_list(s, d, (node *)(& x___81->arg1));
  }
#line 576
  goto switch_break;
  case_102: /* CIL Label */ 
#line 579
  tEmPcast___82 = (AST_generic )n;
#line 579
  if (tEmPcast___82) {
#line 579
    if ((unsigned int )tEmPcast___82->kind >= 102U) {
#line 579
      if (! ((unsigned int )tEmPcast___82->kind <= 102U)) {
        {
#line 579
        __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      579U, "AST_walk_children");
        }
      }
    } else {
      {
#line 579
      __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    579U, "AST_walk_children");
      }
    }
  }
  {
#line 579
  x___82 = (unary_minus )tEmPcast___82;
#line 581
  AST_walk_list(s, d, (node *)(& x___82->arg1));
  }
#line 582
  goto switch_break;
  case_103: /* CIL Label */ 
#line 585
  tEmPcast___83 = (AST_generic )n;
#line 585
  if (tEmPcast___83) {
#line 585
    if ((unsigned int )tEmPcast___83->kind >= 103U) {
#line 585
      if (! ((unsigned int )tEmPcast___83->kind <= 103U)) {
        {
#line 585
        __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      585U, "AST_walk_children");
        }
      }
    } else {
      {
#line 585
      __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    585U, "AST_walk_children");
      }
    }
  }
  {
#line 585
  x___83 = (unary_plus )tEmPcast___83;
#line 587
  AST_walk_list(s, d, (node *)(& x___83->arg1));
  }
#line 588
  goto switch_break;
  case_104: /* CIL Label */ 
#line 591
  tEmPcast___84 = (AST_generic )n;
#line 591
  if (tEmPcast___84) {
#line 591
    if ((unsigned int )tEmPcast___84->kind >= 104U) {
#line 591
      if (! ((unsigned int )tEmPcast___84->kind <= 104U)) {
        {
#line 591
        __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      591U, "AST_walk_children");
        }
      }
    } else {
      {
#line 591
      __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    591U, "AST_walk_children");
      }
    }
  }
  {
#line 591
  x___84 = (conjugate )tEmPcast___84;
#line 593
  AST_walk_list(s, d, (node *)(& x___84->arg1));
  }
#line 594
  goto switch_break;
  case_105: /* CIL Label */ 
#line 597
  tEmPcast___85 = (AST_generic )n;
#line 597
  if (tEmPcast___85) {
#line 597
    if ((unsigned int )tEmPcast___85->kind >= 105U) {
#line 597
      if (! ((unsigned int )tEmPcast___85->kind <= 105U)) {
        {
#line 597
        __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      597U, "AST_walk_children");
        }
      }
    } else {
      {
#line 597
      __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    597U, "AST_walk_children");
      }
    }
  }
  {
#line 597
  x___85 = (bitnot )tEmPcast___85;
#line 599
  AST_walk_list(s, d, (node *)(& x___85->arg1));
  }
#line 600
  goto switch_break;
  case_106: /* CIL Label */ 
#line 603
  tEmPcast___86 = (AST_generic )n;
#line 603
  if (tEmPcast___86) {
#line 603
    if ((unsigned int )tEmPcast___86->kind >= 106U) {
#line 603
      if (! ((unsigned int )tEmPcast___86->kind <= 106U)) {
        {
#line 603
        __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      603U, "AST_walk_children");
        }
      }
    } else {
      {
#line 603
      __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    603U, "AST_walk_children");
      }
    }
  }
  {
#line 603
  x___86 = (not )tEmPcast___86;
#line 605
  AST_walk_list(s, d, (node *)(& x___86->arg1));
  }
#line 606
  goto switch_break;
  case_89: /* CIL Label */ 
#line 609
  tEmPcast___87 = (AST_generic )n;
#line 609
  if (tEmPcast___87) {
#line 609
    if ((unsigned int )tEmPcast___87->kind >= 89U) {
#line 609
      if (! ((unsigned int )tEmPcast___87->kind <= 89U)) {
        {
#line 609
        __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      609U, "AST_walk_children");
        }
      }
    } else {
      {
#line 609
      __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    609U, "AST_walk_children");
      }
    }
  }
  {
#line 609
  x___87 = (preincrement )tEmPcast___87;
#line 611
  AST_walk_list(s, d, (node *)(& x___87->arg1));
  }
#line 612
  goto switch_break;
  case_90: /* CIL Label */ 
#line 615
  tEmPcast___88 = (AST_generic )n;
#line 615
  if (tEmPcast___88) {
#line 615
    if ((unsigned int )tEmPcast___88->kind >= 90U) {
#line 615
      if (! ((unsigned int )tEmPcast___88->kind <= 90U)) {
        {
#line 615
        __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      615U, "AST_walk_children");
        }
      }
    } else {
      {
#line 615
      __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    615U, "AST_walk_children");
      }
    }
  }
  {
#line 615
  x___88 = (predecrement )tEmPcast___88;
#line 617
  AST_walk_list(s, d, (node *)(& x___88->arg1));
  }
#line 618
  goto switch_break;
  case_91: /* CIL Label */ 
#line 621
  tEmPcast___89 = (AST_generic )n;
#line 621
  if (tEmPcast___89) {
#line 621
    if ((unsigned int )tEmPcast___89->kind >= 91U) {
#line 621
      if (! ((unsigned int )tEmPcast___89->kind <= 91U)) {
        {
#line 621
        __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      621U, "AST_walk_children");
        }
      }
    } else {
      {
#line 621
      __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    621U, "AST_walk_children");
      }
    }
  }
  {
#line 621
  x___89 = (postincrement )tEmPcast___89;
#line 623
  AST_walk_list(s, d, (node *)(& x___89->arg1));
  }
#line 624
  goto switch_break;
  case_92: /* CIL Label */ 
#line 627
  tEmPcast___90 = (AST_generic )n;
#line 627
  if (tEmPcast___90) {
#line 627
    if ((unsigned int )tEmPcast___90->kind >= 92U) {
#line 627
      if (! ((unsigned int )tEmPcast___90->kind <= 92U)) {
        {
#line 627
        __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      627U, "AST_walk_children");
        }
      }
    } else {
      {
#line 627
      __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    627U, "AST_walk_children");
      }
    }
  }
  {
#line 627
  x___90 = (postdecrement )tEmPcast___90;
#line 629
  AST_walk_list(s, d, (node *)(& x___90->arg1));
  }
#line 630
  goto switch_break;
  case_128: /* CIL Label */ 
#line 633
  tEmPcast___91 = (AST_generic )n;
#line 633
  if (tEmPcast___91) {
#line 633
    if ((unsigned int )tEmPcast___91->kind >= 128U) {
#line 633
      if (! ((unsigned int )tEmPcast___91->kind <= 128U)) {
        {
#line 633
        __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      633U, "AST_walk_children");
        }
      }
    } else {
      {
#line 633
      __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    633U, "AST_walk_children");
      }
    }
  }
  {
#line 633
  x___91 = (plus )tEmPcast___91;
#line 635
  AST_walk_list(s, d, (node *)(& x___91->arg1));
#line 636
  AST_walk_list(s, d, (node *)(& x___91->arg2));
  }
#line 637
  goto switch_break;
  case_129: /* CIL Label */ 
#line 640
  tEmPcast___92 = (AST_generic )n;
#line 640
  if (tEmPcast___92) {
#line 640
    if ((unsigned int )tEmPcast___92->kind >= 129U) {
#line 640
      if (! ((unsigned int )tEmPcast___92->kind <= 129U)) {
        {
#line 640
        __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      640U, "AST_walk_children");
        }
      }
    } else {
      {
#line 640
      __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    640U, "AST_walk_children");
      }
    }
  }
  {
#line 640
  x___92 = (minus )tEmPcast___92;
#line 642
  AST_walk_list(s, d, (node *)(& x___92->arg1));
#line 643
  AST_walk_list(s, d, (node *)(& x___92->arg2));
  }
#line 644
  goto switch_break;
  case_130: /* CIL Label */ 
#line 647
  tEmPcast___93 = (AST_generic )n;
#line 647
  if (tEmPcast___93) {
#line 647
    if ((unsigned int )tEmPcast___93->kind >= 130U) {
#line 647
      if (! ((unsigned int )tEmPcast___93->kind <= 130U)) {
        {
#line 647
        __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      647U, "AST_walk_children");
        }
      }
    } else {
      {
#line 647
      __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    647U, "AST_walk_children");
      }
    }
  }
  {
#line 647
  x___93 = (times )tEmPcast___93;
#line 649
  AST_walk_list(s, d, (node *)(& x___93->arg1));
#line 650
  AST_walk_list(s, d, (node *)(& x___93->arg2));
  }
#line 651
  goto switch_break;
  case_131: /* CIL Label */ 
#line 654
  tEmPcast___94 = (AST_generic )n;
#line 654
  if (tEmPcast___94) {
#line 654
    if ((unsigned int )tEmPcast___94->kind >= 131U) {
#line 654
      if (! ((unsigned int )tEmPcast___94->kind <= 131U)) {
        {
#line 654
        __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      654U, "AST_walk_children");
        }
      }
    } else {
      {
#line 654
      __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    654U, "AST_walk_children");
      }
    }
  }
  {
#line 654
  x___94 = (divide )tEmPcast___94;
#line 656
  AST_walk_list(s, d, (node *)(& x___94->arg1));
#line 657
  AST_walk_list(s, d, (node *)(& x___94->arg2));
  }
#line 658
  goto switch_break;
  case_132: /* CIL Label */ 
#line 661
  tEmPcast___95 = (AST_generic )n;
#line 661
  if (tEmPcast___95) {
#line 661
    if ((unsigned int )tEmPcast___95->kind >= 132U) {
#line 661
      if (! ((unsigned int )tEmPcast___95->kind <= 132U)) {
        {
#line 661
        __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      661U, "AST_walk_children");
        }
      }
    } else {
      {
#line 661
      __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    661U, "AST_walk_children");
      }
    }
  }
  {
#line 661
  x___95 = (modulo )tEmPcast___95;
#line 663
  AST_walk_list(s, d, (node *)(& x___95->arg1));
#line 664
  AST_walk_list(s, d, (node *)(& x___95->arg2));
  }
#line 665
  goto switch_break;
  case_133: /* CIL Label */ 
#line 668
  tEmPcast___96 = (AST_generic )n;
#line 668
  if (tEmPcast___96) {
#line 668
    if ((unsigned int )tEmPcast___96->kind >= 133U) {
#line 668
      if (! ((unsigned int )tEmPcast___96->kind <= 133U)) {
        {
#line 668
        __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      668U, "AST_walk_children");
        }
      }
    } else {
      {
#line 668
      __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    668U, "AST_walk_children");
      }
    }
  }
  {
#line 668
  x___96 = (lshift )tEmPcast___96;
#line 670
  AST_walk_list(s, d, (node *)(& x___96->arg1));
#line 671
  AST_walk_list(s, d, (node *)(& x___96->arg2));
  }
#line 672
  goto switch_break;
  case_134: /* CIL Label */ 
#line 675
  tEmPcast___97 = (AST_generic )n;
#line 675
  if (tEmPcast___97) {
#line 675
    if ((unsigned int )tEmPcast___97->kind >= 134U) {
#line 675
      if (! ((unsigned int )tEmPcast___97->kind <= 134U)) {
        {
#line 675
        __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      675U, "AST_walk_children");
        }
      }
    } else {
      {
#line 675
      __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    675U, "AST_walk_children");
      }
    }
  }
  {
#line 675
  x___97 = (rshift )tEmPcast___97;
#line 677
  AST_walk_list(s, d, (node *)(& x___97->arg1));
#line 678
  AST_walk_list(s, d, (node *)(& x___97->arg2));
  }
#line 679
  goto switch_break;
  case_109: /* CIL Label */ 
#line 682
  tEmPcast___98 = (AST_generic )n;
#line 682
  if (tEmPcast___98) {
#line 682
    if ((unsigned int )tEmPcast___98->kind >= 109U) {
#line 682
      if (! ((unsigned int )tEmPcast___98->kind <= 109U)) {
        {
#line 682
        __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      682U, "AST_walk_children");
        }
      }
    } else {
      {
#line 682
      __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    682U, "AST_walk_children");
      }
    }
  }
  {
#line 682
  x___98 = (leq )tEmPcast___98;
#line 684
  AST_walk_list(s, d, (node *)(& x___98->arg1));
#line 685
  AST_walk_list(s, d, (node *)(& x___98->arg2));
  }
#line 686
  goto switch_break;
  case_110: /* CIL Label */ 
#line 689
  tEmPcast___99 = (AST_generic )n;
#line 689
  if (tEmPcast___99) {
#line 689
    if ((unsigned int )tEmPcast___99->kind >= 110U) {
#line 689
      if (! ((unsigned int )tEmPcast___99->kind <= 110U)) {
        {
#line 689
        __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      689U, "AST_walk_children");
        }
      }
    } else {
      {
#line 689
      __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    689U, "AST_walk_children");
      }
    }
  }
  {
#line 689
  x___99 = (geq )tEmPcast___99;
#line 691
  AST_walk_list(s, d, (node *)(& x___99->arg1));
#line 692
  AST_walk_list(s, d, (node *)(& x___99->arg2));
  }
#line 693
  goto switch_break;
  case_111: /* CIL Label */ 
#line 696
  tEmPcast___100 = (AST_generic )n;
#line 696
  if (tEmPcast___100) {
#line 696
    if ((unsigned int )tEmPcast___100->kind >= 111U) {
#line 696
      if (! ((unsigned int )tEmPcast___100->kind <= 111U)) {
        {
#line 696
        __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      696U, "AST_walk_children");
        }
      }
    } else {
      {
#line 696
      __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    696U, "AST_walk_children");
      }
    }
  }
  {
#line 696
  x___100 = (lt )tEmPcast___100;
#line 698
  AST_walk_list(s, d, (node *)(& x___100->arg1));
#line 699
  AST_walk_list(s, d, (node *)(& x___100->arg2));
  }
#line 700
  goto switch_break;
  case_112: /* CIL Label */ 
#line 703
  tEmPcast___101 = (AST_generic )n;
#line 703
  if (tEmPcast___101) {
#line 703
    if ((unsigned int )tEmPcast___101->kind >= 112U) {
#line 703
      if (! ((unsigned int )tEmPcast___101->kind <= 112U)) {
        {
#line 703
        __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      703U, "AST_walk_children");
        }
      }
    } else {
      {
#line 703
      __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    703U, "AST_walk_children");
      }
    }
  }
  {
#line 703
  x___101 = (gt )tEmPcast___101;
#line 705
  AST_walk_list(s, d, (node *)(& x___101->arg1));
#line 706
  AST_walk_list(s, d, (node *)(& x___101->arg2));
  }
#line 707
  goto switch_break;
  case_113: /* CIL Label */ 
#line 710
  tEmPcast___102 = (AST_generic )n;
#line 710
  if (tEmPcast___102) {
#line 710
    if ((unsigned int )tEmPcast___102->kind >= 113U) {
#line 710
      if (! ((unsigned int )tEmPcast___102->kind <= 113U)) {
        {
#line 710
        __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      710U, "AST_walk_children");
        }
      }
    } else {
      {
#line 710
      __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    710U, "AST_walk_children");
      }
    }
  }
  {
#line 710
  x___102 = (eq )tEmPcast___102;
#line 712
  AST_walk_list(s, d, (node *)(& x___102->arg1));
#line 713
  AST_walk_list(s, d, (node *)(& x___102->arg2));
  }
#line 714
  goto switch_break;
  case_114: /* CIL Label */ 
#line 717
  tEmPcast___103 = (AST_generic )n;
#line 717
  if (tEmPcast___103) {
#line 717
    if ((unsigned int )tEmPcast___103->kind >= 114U) {
#line 717
      if (! ((unsigned int )tEmPcast___103->kind <= 114U)) {
        {
#line 717
        __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      717U, "AST_walk_children");
        }
      }
    } else {
      {
#line 717
      __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    717U, "AST_walk_children");
      }
    }
  }
  {
#line 717
  x___103 = (ne )tEmPcast___103;
#line 719
  AST_walk_list(s, d, (node *)(& x___103->arg1));
#line 720
  AST_walk_list(s, d, (node *)(& x___103->arg2));
  }
#line 721
  goto switch_break;
  case_135: /* CIL Label */ 
#line 724
  tEmPcast___104 = (AST_generic )n;
#line 724
  if (tEmPcast___104) {
#line 724
    if ((unsigned int )tEmPcast___104->kind >= 135U) {
#line 724
      if (! ((unsigned int )tEmPcast___104->kind <= 135U)) {
        {
#line 724
        __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      724U, "AST_walk_children");
        }
      }
    } else {
      {
#line 724
      __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    724U, "AST_walk_children");
      }
    }
  }
  {
#line 724
  x___104 = (bitand )tEmPcast___104;
#line 726
  AST_walk_list(s, d, (node *)(& x___104->arg1));
#line 727
  AST_walk_list(s, d, (node *)(& x___104->arg2));
  }
#line 728
  goto switch_break;
  case_136: /* CIL Label */ 
#line 731
  tEmPcast___105 = (AST_generic )n;
#line 731
  if (tEmPcast___105) {
#line 731
    if ((unsigned int )tEmPcast___105->kind >= 136U) {
#line 731
      if (! ((unsigned int )tEmPcast___105->kind <= 136U)) {
        {
#line 731
        __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      731U, "AST_walk_children");
        }
      }
    } else {
      {
#line 731
      __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    731U, "AST_walk_children");
      }
    }
  }
  {
#line 731
  x___105 = (bitor )tEmPcast___105;
#line 733
  AST_walk_list(s, d, (node *)(& x___105->arg1));
#line 734
  AST_walk_list(s, d, (node *)(& x___105->arg2));
  }
#line 735
  goto switch_break;
  case_137: /* CIL Label */ 
#line 738
  tEmPcast___106 = (AST_generic )n;
#line 738
  if (tEmPcast___106) {
#line 738
    if ((unsigned int )tEmPcast___106->kind >= 137U) {
#line 738
      if (! ((unsigned int )tEmPcast___106->kind <= 137U)) {
        {
#line 738
        __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      738U, "AST_walk_children");
        }
      }
    } else {
      {
#line 738
      __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    738U, "AST_walk_children");
      }
    }
  }
  {
#line 738
  x___106 = (bitxor )tEmPcast___106;
#line 740
  AST_walk_list(s, d, (node *)(& x___106->arg1));
#line 741
  AST_walk_list(s, d, (node *)(& x___106->arg2));
  }
#line 742
  goto switch_break;
  case_138: /* CIL Label */ 
#line 745
  tEmPcast___107 = (AST_generic )n;
#line 745
  if (tEmPcast___107) {
#line 745
    if ((unsigned int )tEmPcast___107->kind >= 138U) {
#line 745
      if (! ((unsigned int )tEmPcast___107->kind <= 138U)) {
        {
#line 745
        __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      745U, "AST_walk_children");
        }
      }
    } else {
      {
#line 745
      __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    745U, "AST_walk_children");
      }
    }
  }
  {
#line 745
  x___107 = (andand )tEmPcast___107;
#line 747
  AST_walk_list(s, d, (node *)(& x___107->arg1));
#line 748
  AST_walk_list(s, d, (node *)(& x___107->arg2));
  }
#line 749
  goto switch_break;
  case_139: /* CIL Label */ 
#line 752
  tEmPcast___108 = (AST_generic )n;
#line 752
  if (tEmPcast___108) {
#line 752
    if ((unsigned int )tEmPcast___108->kind >= 139U) {
#line 752
      if (! ((unsigned int )tEmPcast___108->kind <= 139U)) {
        {
#line 752
        __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      752U, "AST_walk_children");
        }
      }
    } else {
      {
#line 752
      __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    752U, "AST_walk_children");
      }
    }
  }
  {
#line 752
  x___108 = (oror )tEmPcast___108;
#line 754
  AST_walk_list(s, d, (node *)(& x___108->arg1));
#line 755
  AST_walk_list(s, d, (node *)(& x___108->arg2));
  }
#line 756
  goto switch_break;
  case_116: /* CIL Label */ 
#line 759
  tEmPcast___109 = (AST_generic )n;
#line 759
  if (tEmPcast___109) {
#line 759
    if ((unsigned int )tEmPcast___109->kind >= 116U) {
#line 759
      if (! ((unsigned int )tEmPcast___109->kind <= 116U)) {
        {
#line 759
        __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      759U, "AST_walk_children");
        }
      }
    } else {
      {
#line 759
      __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    759U, "AST_walk_children");
      }
    }
  }
  {
#line 759
  x___109 = (assign )tEmPcast___109;
#line 761
  AST_walk_list(s, d, (node *)(& x___109->arg1));
#line 762
  AST_walk_list(s, d, (node *)(& x___109->arg2));
  }
#line 763
  goto switch_break;
  case_117: /* CIL Label */ 
#line 766
  tEmPcast___110 = (AST_generic )n;
#line 766
  if (tEmPcast___110) {
#line 766
    if ((unsigned int )tEmPcast___110->kind >= 117U) {
#line 766
      if (! ((unsigned int )tEmPcast___110->kind <= 117U)) {
        {
#line 766
        __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      766U, "AST_walk_children");
        }
      }
    } else {
      {
#line 766
      __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    766U, "AST_walk_children");
      }
    }
  }
  {
#line 766
  x___110 = (plus_assign )tEmPcast___110;
#line 768
  AST_walk_list(s, d, (node *)(& x___110->arg1));
#line 769
  AST_walk_list(s, d, (node *)(& x___110->arg2));
  }
#line 770
  goto switch_break;
  case_118: /* CIL Label */ 
#line 773
  tEmPcast___111 = (AST_generic )n;
#line 773
  if (tEmPcast___111) {
#line 773
    if ((unsigned int )tEmPcast___111->kind >= 118U) {
#line 773
      if (! ((unsigned int )tEmPcast___111->kind <= 118U)) {
        {
#line 773
        __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      773U, "AST_walk_children");
        }
      }
    } else {
      {
#line 773
      __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    773U, "AST_walk_children");
      }
    }
  }
  {
#line 773
  x___111 = (minus_assign )tEmPcast___111;
#line 775
  AST_walk_list(s, d, (node *)(& x___111->arg1));
#line 776
  AST_walk_list(s, d, (node *)(& x___111->arg2));
  }
#line 777
  goto switch_break;
  case_119: /* CIL Label */ 
#line 780
  tEmPcast___112 = (AST_generic )n;
#line 780
  if (tEmPcast___112) {
#line 780
    if ((unsigned int )tEmPcast___112->kind >= 119U) {
#line 780
      if (! ((unsigned int )tEmPcast___112->kind <= 119U)) {
        {
#line 780
        __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      780U, "AST_walk_children");
        }
      }
    } else {
      {
#line 780
      __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    780U, "AST_walk_children");
      }
    }
  }
  {
#line 780
  x___112 = (times_assign )tEmPcast___112;
#line 782
  AST_walk_list(s, d, (node *)(& x___112->arg1));
#line 783
  AST_walk_list(s, d, (node *)(& x___112->arg2));
  }
#line 784
  goto switch_break;
  case_120: /* CIL Label */ 
#line 787
  tEmPcast___113 = (AST_generic )n;
#line 787
  if (tEmPcast___113) {
#line 787
    if ((unsigned int )tEmPcast___113->kind >= 120U) {
#line 787
      if (! ((unsigned int )tEmPcast___113->kind <= 120U)) {
        {
#line 787
        __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      787U, "AST_walk_children");
        }
      }
    } else {
      {
#line 787
      __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    787U, "AST_walk_children");
      }
    }
  }
  {
#line 787
  x___113 = (divide_assign )tEmPcast___113;
#line 789
  AST_walk_list(s, d, (node *)(& x___113->arg1));
#line 790
  AST_walk_list(s, d, (node *)(& x___113->arg2));
  }
#line 791
  goto switch_break;
  case_121: /* CIL Label */ 
#line 794
  tEmPcast___114 = (AST_generic )n;
#line 794
  if (tEmPcast___114) {
#line 794
    if ((unsigned int )tEmPcast___114->kind >= 121U) {
#line 794
      if (! ((unsigned int )tEmPcast___114->kind <= 121U)) {
        {
#line 794
        __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      794U, "AST_walk_children");
        }
      }
    } else {
      {
#line 794
      __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    794U, "AST_walk_children");
      }
    }
  }
  {
#line 794
  x___114 = (modulo_assign )tEmPcast___114;
#line 796
  AST_walk_list(s, d, (node *)(& x___114->arg1));
#line 797
  AST_walk_list(s, d, (node *)(& x___114->arg2));
  }
#line 798
  goto switch_break;
  case_122: /* CIL Label */ 
#line 801
  tEmPcast___115 = (AST_generic )n;
#line 801
  if (tEmPcast___115) {
#line 801
    if ((unsigned int )tEmPcast___115->kind >= 122U) {
#line 801
      if (! ((unsigned int )tEmPcast___115->kind <= 122U)) {
        {
#line 801
        __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      801U, "AST_walk_children");
        }
      }
    } else {
      {
#line 801
      __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    801U, "AST_walk_children");
      }
    }
  }
  {
#line 801
  x___115 = (lshift_assign )tEmPcast___115;
#line 803
  AST_walk_list(s, d, (node *)(& x___115->arg1));
#line 804
  AST_walk_list(s, d, (node *)(& x___115->arg2));
  }
#line 805
  goto switch_break;
  case_123: /* CIL Label */ 
#line 808
  tEmPcast___116 = (AST_generic )n;
#line 808
  if (tEmPcast___116) {
#line 808
    if ((unsigned int )tEmPcast___116->kind >= 123U) {
#line 808
      if (! ((unsigned int )tEmPcast___116->kind <= 123U)) {
        {
#line 808
        __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      808U, "AST_walk_children");
        }
      }
    } else {
      {
#line 808
      __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    808U, "AST_walk_children");
      }
    }
  }
  {
#line 808
  x___116 = (rshift_assign )tEmPcast___116;
#line 810
  AST_walk_list(s, d, (node *)(& x___116->arg1));
#line 811
  AST_walk_list(s, d, (node *)(& x___116->arg2));
  }
#line 812
  goto switch_break;
  case_124: /* CIL Label */ 
#line 815
  tEmPcast___117 = (AST_generic )n;
#line 815
  if (tEmPcast___117) {
#line 815
    if ((unsigned int )tEmPcast___117->kind >= 124U) {
#line 815
      if (! ((unsigned int )tEmPcast___117->kind <= 124U)) {
        {
#line 815
        __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      815U, "AST_walk_children");
        }
      }
    } else {
      {
#line 815
      __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    815U, "AST_walk_children");
      }
    }
  }
  {
#line 815
  x___117 = (bitand_assign )tEmPcast___117;
#line 817
  AST_walk_list(s, d, (node *)(& x___117->arg1));
#line 818
  AST_walk_list(s, d, (node *)(& x___117->arg2));
  }
#line 819
  goto switch_break;
  case_125: /* CIL Label */ 
#line 822
  tEmPcast___118 = (AST_generic )n;
#line 822
  if (tEmPcast___118) {
#line 822
    if ((unsigned int )tEmPcast___118->kind >= 125U) {
#line 822
      if (! ((unsigned int )tEmPcast___118->kind <= 125U)) {
        {
#line 822
        __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      822U, "AST_walk_children");
        }
      }
    } else {
      {
#line 822
      __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    822U, "AST_walk_children");
      }
    }
  }
  {
#line 822
  x___118 = (bitor_assign )tEmPcast___118;
#line 824
  AST_walk_list(s, d, (node *)(& x___118->arg1));
#line 825
  AST_walk_list(s, d, (node *)(& x___118->arg2));
  }
#line 826
  goto switch_break;
  case_126: /* CIL Label */ 
#line 829
  tEmPcast___119 = (AST_generic )n;
#line 829
  if (tEmPcast___119) {
#line 829
    if ((unsigned int )tEmPcast___119->kind >= 126U) {
#line 829
      if (! ((unsigned int )tEmPcast___119->kind <= 126U)) {
        {
#line 829
        __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      829U, "AST_walk_children");
        }
      }
    } else {
      {
#line 829
      __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    829U, "AST_walk_children");
      }
    }
  }
  {
#line 829
  x___119 = (bitxor_assign )tEmPcast___119;
#line 831
  AST_walk_list(s, d, (node *)(& x___119->arg1));
#line 832
  AST_walk_list(s, d, (node *)(& x___119->arg2));
  }
#line 833
  goto switch_break;
  case_61: /* CIL Label */ 
#line 836
  tEmPcast___120 = (AST_generic )n;
#line 836
  if (tEmPcast___120) {
#line 836
    if ((unsigned int )tEmPcast___120->kind >= 61U) {
#line 836
      if (! ((unsigned int )tEmPcast___120->kind <= 61U)) {
        {
#line 836
        __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      836U, "AST_walk_children");
        }
      }
    } else {
      {
#line 836
      __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    836U, "AST_walk_children");
      }
    }
  }
  {
#line 836
  x___120 = (rp_connection )tEmPcast___120;
#line 838
  AST_walk_list(s, d, (node *)(& x___120->ep1));
#line 839
  AST_walk_list(s, d, (node *)(& x___120->ep2));
  }
#line 840
  goto switch_break;
  case_62: /* CIL Label */ 
#line 843
  tEmPcast___121 = (AST_generic )n;
#line 843
  if (tEmPcast___121) {
#line 843
    if ((unsigned int )tEmPcast___121->kind >= 62U) {
#line 843
      if (! ((unsigned int )tEmPcast___121->kind <= 62U)) {
        {
#line 843
        __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      843U, "AST_walk_children");
        }
      }
    } else {
      {
#line 843
      __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    843U, "AST_walk_children");
      }
    }
  }
  {
#line 843
  x___121 = (eq_connection )tEmPcast___121;
#line 845
  AST_walk_list(s, d, (node *)(& x___121->ep1));
#line 846
  AST_walk_list(s, d, (node *)(& x___121->ep2));
  }
#line 847
  goto switch_break;
  case_170: /* CIL Label */ 
#line 850
  tEmPcast___122 = (AST_generic )n;
#line 850
  if (tEmPcast___122) {
#line 850
    if ((unsigned int )tEmPcast___122->kind >= 170U) {
#line 850
      if (! ((unsigned int )tEmPcast___122->kind <= 170U)) {
        {
#line 850
        __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      850U, "AST_walk_children");
        }
      }
    } else {
      {
#line 850
      __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    850U, "AST_walk_children");
      }
    }
  }
  {
#line 850
  x___122 = (nx_struct_ref )tEmPcast___122;
#line 852
  AST_walk_list(s, d, (node *)(& x___122->word1));
#line 853
  AST_walk_list(s, d, (node *)(& x___122->attributes));
#line 854
  AST_walk_list(s, d, (node *)(& x___122->fields));
  }
#line 855
  goto switch_break;
  case_172: /* CIL Label */ 
#line 858
  tEmPcast___123 = (AST_generic )n;
#line 858
  if (tEmPcast___123) {
#line 858
    if ((unsigned int )tEmPcast___123->kind >= 172U) {
#line 858
      if (! ((unsigned int )tEmPcast___123->kind <= 172U)) {
        {
#line 858
        __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      858U, "AST_walk_children");
        }
      }
    } else {
      {
#line 858
      __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    858U, "AST_walk_children");
      }
    }
  }
  {
#line 858
  x___123 = (nx_union_ref )tEmPcast___123;
#line 860
  AST_walk_list(s, d, (node *)(& x___123->word1));
#line 861
  AST_walk_list(s, d, (node *)(& x___123->attributes));
#line 862
  AST_walk_list(s, d, (node *)(& x___123->fields));
  }
#line 863
  goto switch_break;
  case_164: /* CIL Label */ 
#line 866
  tEmPcast___124 = (AST_generic )n;
#line 866
  if (tEmPcast___124) {
#line 866
    if ((unsigned int )tEmPcast___124->kind >= 164U) {
#line 866
      if (! ((unsigned int )tEmPcast___124->kind <= 164U)) {
        {
#line 866
        __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                      866U, "AST_walk_children");
        }
      }
    } else {
      {
#line 866
      __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk_children.c",
                    866U, "AST_walk_children");
      }
    }
  }
  {
#line 866
  x___124 = (target_attribute )tEmPcast___124;
#line 868
  AST_walk_list(s, d, (node *)(& x___124->word1));
#line 869
  AST_walk_list(s, d, (node *)(& x___124->args));
  }
#line 870
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 78 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_walk.c"
void AST_walk(AST_walker spec , void *data , node *n ) 
{ 
  AST_kind k ;
  AST_walker_result tmp ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    k = (*n)->kind;
#line 89
    tmp = AST_walker_call(spec, k, data, n);
    }
    {
#line 91
    if ((unsigned int )tmp == 2U) {
#line 91
      goto case_2;
    }
#line 92
    if ((unsigned int )tmp == 1U) {
#line 92
      goto case_1;
    }
#line 97
    if ((unsigned int )tmp == 0U) {
#line 97
      goto case_0;
    }
#line 89
    goto switch_break;
    case_2: /* CIL Label */ 
#line 91
    return;
    case_1: /* CIL Label */ 
#line 93
    k = AST_parent_kind[(unsigned int )k - 42U];
#line 94
    if (! k) {
#line 95
      return;
    }
#line 96
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 98
    AST_walk_children(spec, data, *n);
    }
#line 99
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cstring.h"
extern char *cstring2str(region r , cstring s ) ;
#line 81 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval make_cval_signed(largest_int i , type t ) ;
#line 82
cval make_cval_unsigned(largest_uint i , type t ) ;
#line 117
bool cval_isaddress(cval c ) ;
#line 132
bool cval_knownbool(cval c ) ;
#line 169
data_declaration cval_ddecl(cval c ) ;
#line 185 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern bool type_char(type t ) ;
#line 1823 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
lexical_cst new_lexical_cst(region r , location location___0 , cstring cstring___0 ) ;
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.h"
data_declaration get_parameter(declaration d ) ;
#line 29
function_declarator get_fdeclarator(declarator d ) ;
#line 30
bool oldstyle_function(function_decl fn ) ;
#line 31
bool is_void_parms(declaration parms ) ;
#line 32
bool is_localvar(expression e ) ;
#line 33
compound_stmt parent_block(node n ) ;
#line 34
function_decl parent_function(node n ) ;
#line 35
expression expression_of_stmt(compound_expr ce ) ;
#line 36
bool expression_used(expression e ) ;
#line 38
data_declaration base_identifier(data_declaration d ) ;
#line 39
bool same_function(data_declaration d1 , data_declaration d2 ) ;
#line 40
bool call_to(data_declaration fnd , function_call fce ) ;
#line 41
expression ignore_fields(expression e ) ;
#line 45
bool zero_expression(expression e ) ;
#line 47
expression build_int_constant(region r , location loc , type t , largest_int c ) ;
#line 48
expression build_uint_constant(region r , location loc , type t , largest_uint c ) ;
#line 53
cval value_of_enumerator(enumerator e ) ;
#line 55
int asm_rwmode(string s ) ;
#line 61
declaration ignore_extensions(declaration d ) ;
#line 64
tag_declaration get_unnamed_tag_decl(data_decl decl ) ;
#line 68
char const   *nice_field_name(char const   *s ) ;
#line 75
conditional conditional_lvalue(expression e ) ;
#line 77
data_declaration string_ddecl(expression s ) ;
#line 79
char *ddecl2str(region r , data_declaration ddecl ) ;
#line 85
bool is_attr_name(char const   *arg , char const   *name ) ;
#line 88
type_element interesting_element(type_element elems ) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
known_cst make_cst(cval c , type t ) ;
#line 26 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool oldstyle_function(function_decl fn ) 
{ 
  int tmp ;

  {
#line 28
  if (! (fn->fdeclarator)->parms) {
#line 28
    tmp = 1;
  } else
#line 28
  if ((unsigned int )((fn->fdeclarator)->parms)->kind >= 49U) {
#line 28
    if ((unsigned int )((fn->fdeclarator)->parms)->kind <= 49U) {
#line 28
      tmp = 1;
    } else {
#line 28
      tmp = 0;
    }
  } else {
#line 28
    tmp = 0;
  }
#line 28
  return ((bool )tmp);
}
}
#line 32 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool is_void_parms(declaration parms ) 
{ 
  data_decl dd ;
  variable_decl vd ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  int tmp ;

  {
#line 37
  if (! parms) {
#line 38
    return ((bool )0);
  } else
#line 37
  if (parms->next) {
#line 38
    return ((bool )0);
  } else
#line 37
  if ((unsigned int )parms->kind >= 45U) {
#line 37
    if (! ((unsigned int )parms->kind <= 45U)) {
#line 38
      return ((bool )0);
    }
  } else {
#line 38
    return ((bool )0);
  }
#line 40
  tEmPcast = (AST_generic )parms;
#line 40
  if (tEmPcast) {
#line 40
    if ((unsigned int )tEmPcast->kind >= 45U) {
#line 40
      if (! ((unsigned int )tEmPcast->kind <= 45U)) {
        {
#line 40
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 40U,
                      "is_void_parms");
        }
      }
    } else {
      {
#line 40
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 40U,
                    "is_void_parms");
      }
    }
  }
#line 40
  dd = (data_decl )tEmPcast;
#line 41
  tEmPcast___0 = (AST_generic )dd->decls;
#line 41
  if (tEmPcast___0) {
#line 41
    if ((unsigned int )tEmPcast___0->kind >= 52U) {
#line 41
      if (! ((unsigned int )tEmPcast___0->kind <= 52U)) {
        {
#line 41
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 41U,
                      "is_void_parms");
        }
      }
    } else {
      {
#line 41
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 41U,
                    "is_void_parms");
      }
    }
  }
#line 41
  vd = (variable_decl )tEmPcast___0;
#line 42
  if (! (! vd->next)) {
    {
#line 42
    __assert_fail("!vd->next", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                  42U, "is_void_parms");
    }
  }
#line 45
  if (! vd->declarator) {
#line 45
    if (dd->modifiers) {
#line 45
      if (! (dd->modifiers)->next) {
#line 45
        if ((unsigned int )(dd->modifiers)->kind >= 166U) {
#line 45
          if ((unsigned int )(dd->modifiers)->kind <= 166U) {
#line 45
            tEmPcast___1 = (AST_generic )dd->modifiers;
#line 45
            if (tEmPcast___1) {
#line 45
              if ((unsigned int )tEmPcast___1->kind >= 166U) {
#line 45
                if (! ((unsigned int )tEmPcast___1->kind <= 166U)) {
                  {
#line 45
                  __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                                "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                                45U, "is_void_parms");
                  }
                }
              } else {
                {
#line 45
                __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                              45U, "is_void_parms");
                }
              }
            }
#line 45
            if ((unsigned int )((rid )tEmPcast___1)->id == 5U) {
#line 45
              tmp = 1;
            } else {
#line 45
              tmp = 0;
            }
          } else {
#line 45
            tmp = 0;
          }
        } else {
#line 45
          tmp = 0;
        }
      } else {
#line 45
        tmp = 0;
      }
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 44
  return ((bool )tmp);
}
}
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
function_declarator get_fdeclarator(declarator d ) 
{ 
  function_declarator fd ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 50
  fd = (function_declarator )((void *)0);
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! d) {
#line 52
      goto while_break;
    }
    {
#line 55
    if ((unsigned int )d->kind == 182U) {
#line 55
      goto case_182;
    }
#line 57
    if ((unsigned int )d->kind == 177U) {
#line 57
      goto case_177;
    }
#line 60
    goto switch_default;
    case_182: /* CIL Label */ 
#line 56
    return (fd);
    case_177: /* CIL Label */ 
#line 58
    tEmPcast = (AST_generic )d;
#line 58
    if (tEmPcast) {
#line 58
      if ((unsigned int )tEmPcast->kind >= 177U) {
#line 58
        if (! ((unsigned int )tEmPcast->kind <= 177U)) {
          {
#line 58
          __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        58U, "get_fdeclarator");
          }
        }
      } else {
        {
#line 58
        __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 58U,
                      "get_fdeclarator");
        }
      }
    }
#line 58
    fd = (function_declarator )tEmPcast;
    switch_default: /* CIL Label */ 
#line 61
    tEmPcast___0 = (AST_generic )d;
#line 61
    if (tEmPcast___0) {
#line 61
      if ((unsigned int )tEmPcast___0->kind >= 176U) {
#line 61
        if (! ((unsigned int )tEmPcast___0->kind <= 181U)) {
          {
#line 61
          __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        61U, "get_fdeclarator");
          }
        }
      } else {
        {
#line 61
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 61U,
                      "get_fdeclarator");
        }
      }
    }
#line 61
    d = ((nested_declarator )tEmPcast___0)->declarator;
#line 62
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (fd);
}
}
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
data_declaration get_parameter(declaration d ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;

  {
  {
#line 72
  if ((unsigned int )d->kind == 47U) {
#line 72
    goto case_47;
  }
#line 74
  if ((unsigned int )d->kind == 49U) {
#line 74
    goto case_49;
  }
#line 76
  if ((unsigned int )d->kind == 45U) {
#line 76
    goto case_45;
  }
#line 78
  goto switch_default;
  case_47: /* CIL Label */ 
#line 73
  return ((data_declaration )((void *)0));
  case_49: /* CIL Label */ 
#line 75
  tEmPcast = (AST_generic )d;
#line 75
  if (tEmPcast) {
#line 75
    if ((unsigned int )tEmPcast->kind >= 49U) {
#line 75
      if (! ((unsigned int )tEmPcast->kind <= 49U)) {
        {
#line 75
        __assert_fail("((tEmPcast)->kind >= kind_oldidentifier_decl && (tEmPcast)->kind <= postkind_oldidentifier_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 75U,
                      "get_parameter");
        }
      }
    } else {
      {
#line 75
      __assert_fail("((tEmPcast)->kind >= kind_oldidentifier_decl && (tEmPcast)->kind <= postkind_oldidentifier_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 75U,
                    "get_parameter");
      }
    }
  }
#line 75
  return (((oldidentifier_decl )tEmPcast)->ddecl);
  case_45: /* CIL Label */ 
#line 77
  tEmPcast___1 = (AST_generic )d;
#line 77
  if (tEmPcast___1) {
#line 77
    if ((unsigned int )tEmPcast___1->kind >= 45U) {
#line 77
      if (! ((unsigned int )tEmPcast___1->kind <= 45U)) {
        {
#line 77
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 77U,
                      "get_parameter");
        }
      }
    } else {
      {
#line 77
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 77U,
                    "get_parameter");
      }
    }
  }
#line 77
  tEmPcast___0 = (AST_generic )((data_decl )tEmPcast___1)->decls;
#line 77
  if (tEmPcast___0) {
#line 77
    if ((unsigned int )tEmPcast___0->kind >= 52U) {
#line 77
      if (! ((unsigned int )tEmPcast___0->kind <= 52U)) {
        {
#line 77
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 77U,
                      "get_parameter");
        }
      }
    } else {
      {
#line 77
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 77U,
                    "get_parameter");
      }
    }
  }
#line 77
  return (((variable_decl )tEmPcast___0)->ddecl);
  switch_default: /* CIL Label */ 
  {
#line 79
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 79U,
                "get_parameter");
  }
#line 79
  return ((data_declaration )((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
data_declaration base_identifier(data_declaration d ) 
{ 


  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (d->isfilescoperef) {
#line 85
      if (! d->shadowed) {
#line 85
        goto while_break;
      }
    } else {
#line 85
      goto while_break;
    }
#line 86
    d = d->shadowed;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (d);
}
}
#line 91 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool same_function(data_declaration d1 , data_declaration d2 ) 
{ 
  int tmp ;

  {
  {
#line 93
  d1 = base_identifier(d1);
#line 94
  d2 = base_identifier(d2);
  }
#line 95
  if ((unsigned int )d1->kind == 2U) {
#line 95
    if ((unsigned long )d1 == (unsigned long )d2) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 0;
    }
  } else {
#line 95
    tmp = 0;
  }
#line 95
  return ((bool )tmp);
}
}
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool call_to(data_declaration fnd , function_call fce ) 
{ 
  AST_generic tEmPcast ;
  bool tmp ;
  int tmp___0 ;

  {
#line 101
  if ((unsigned int )(fce->arg1)->kind >= 146U) {
#line 101
    if ((unsigned int )(fce->arg1)->kind <= 146U) {
#line 101
      if (fnd) {
#line 101
        tEmPcast = (AST_generic )fce->arg1;
#line 101
        if (tEmPcast) {
#line 101
          if ((unsigned int )tEmPcast->kind >= 146U) {
#line 101
            if (! ((unsigned int )tEmPcast->kind <= 146U)) {
              {
#line 101
              __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            101U, "call_to");
              }
            }
          } else {
            {
#line 101
            __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          101U, "call_to");
            }
          }
        }
        {
#line 101
        tmp = same_function(((identifier )tEmPcast)->ddecl, fnd);
        }
#line 101
        if (tmp) {
#line 101
          tmp___0 = 1;
        } else {
#line 101
          tmp___0 = 0;
        }
      } else {
#line 101
        tmp___0 = 0;
      }
    } else {
#line 101
      tmp___0 = 0;
    }
  } else {
#line 101
    tmp___0 = 0;
  }
#line 100
  return ((bool )tmp___0);
}
}
#line 104 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool is_localvar(expression e ) 
{ 
  data_declaration decl ;
  AST_generic tEmPcast ;
  int tmp ;

  {
#line 108
  if ((unsigned int )e->kind >= 146U) {
#line 108
    if (! ((unsigned int )e->kind <= 146U)) {
#line 109
      return ((bool )0);
    }
  } else {
#line 109
    return ((bool )0);
  }
#line 111
  tEmPcast = (AST_generic )e;
#line 111
  if (tEmPcast) {
#line 111
    if ((unsigned int )tEmPcast->kind >= 146U) {
#line 111
      if (! ((unsigned int )tEmPcast->kind <= 146U)) {
        {
#line 111
        __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 111U,
                      "is_localvar");
        }
      }
    } else {
      {
#line 111
      __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 111U,
                    "is_localvar");
      }
    }
  }
#line 111
  decl = ((identifier )tEmPcast)->ddecl;
#line 112
  if ((unsigned int )decl->kind == 0U) {
#line 112
    if (decl->islocal) {
#line 112
      tmp = 1;
    } else {
#line 112
      tmp = 0;
    }
  } else {
#line 112
    tmp = 0;
  }
#line 112
  return ((bool )tmp);
}
}
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
compound_stmt parent_block(node n ) 
{ 
  AST_generic tEmPcast ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if ((unsigned int )n->kind >= 67U) {
#line 120
      if ((unsigned int )n->kind <= 67U) {
#line 120
        if ((unsigned int )(n->parent)->kind >= 147U) {
#line 120
          if (! ((unsigned int )(n->parent)->kind <= 147U)) {
#line 120
            goto while_break;
          }
        } else {
#line 120
          goto while_break;
        }
      }
    }
#line 121
    n = n->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  tEmPcast = (AST_generic )n;
#line 123
  if (tEmPcast) {
#line 123
    if ((unsigned int )tEmPcast->kind >= 67U) {
#line 123
      if (! ((unsigned int )tEmPcast->kind <= 67U)) {
        {
#line 123
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 123U,
                      "parent_block");
        }
      }
    } else {
      {
#line 123
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 123U,
                    "parent_block");
      }
    }
  }
#line 123
  return ((compound_stmt )tEmPcast);
}
}
#line 126 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
function_decl parent_function(node n ) 
{ 
  AST_generic tEmPcast ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if ((unsigned int )n->kind >= 50U) {
#line 128
      if ((unsigned int )n->kind <= 50U) {
#line 128
        goto while_break;
      }
    }
#line 129
    n = n->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  tEmPcast = (AST_generic )n;
#line 131
  if (tEmPcast) {
#line 131
    if ((unsigned int )tEmPcast->kind >= 50U) {
#line 131
      if (! ((unsigned int )tEmPcast->kind <= 50U)) {
        {
#line 131
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 131U,
                      "parent_function");
        }
      }
    } else {
      {
#line 131
      __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 131U,
                    "parent_function");
      }
    }
  }
#line 131
  return ((function_decl )tEmPcast);
}
}
#line 134 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
expression ignore_fields(expression e ) 
{ 
  AST_generic tEmPcast ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned int )e->kind == 87U)) {
#line 136
      goto while_break;
    }
#line 137
    tEmPcast = (AST_generic )e;
#line 137
    if (tEmPcast) {
#line 137
      if ((unsigned int )tEmPcast->kind >= 87U) {
#line 137
        if (! ((unsigned int )tEmPcast->kind <= 87U)) {
          {
#line 137
          __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        137U, "ignore_fields");
          }
        }
      } else {
        {
#line 137
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 137U,
                      "ignore_fields");
        }
      }
    }
#line 137
    e = ((field_ref )tEmPcast)->arg1;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (e);
}
}
#line 142 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
expression expression_of_stmt(compound_expr ce ) 
{ 
  compound_stmt blk ;
  AST_generic tEmPcast ;
  statement last_stmt ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;
  expression_stmt es ;
  AST_generic tEmPcast___2 ;

  {
#line 144
  tEmPcast = (AST_generic )ce->stmt;
#line 144
  if (tEmPcast) {
#line 144
    if ((unsigned int )tEmPcast->kind >= 67U) {
#line 144
      if (! ((unsigned int )tEmPcast->kind <= 67U)) {
        {
#line 144
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 144U,
                      "expression_of_stmt");
        }
      }
    } else {
      {
#line 144
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 144U,
                    "expression_of_stmt");
      }
    }
  }
#line 144
  blk = (compound_stmt )tEmPcast;
#line 145
  tEmPcast___1 = (AST_generic )blk->stmts;
#line 145
  if (tEmPcast___1) {
#line 145
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 145
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 145
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 145U,
                      "expression_of_stmt");
        }
      }
    } else {
      {
#line 145
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 145U,
                    "expression_of_stmt");
      }
    }
  }
  {
#line 145
  tmp = AST_node_last((node )tEmPcast___1);
#line 145
  tEmPcast___0 = (AST_generic )tmp;
  }
#line 145
  if (tEmPcast___0) {
#line 145
    if ((unsigned int )tEmPcast___0->kind >= 65U) {
#line 145
      if (! ((unsigned int )tEmPcast___0->kind <= 83U)) {
        {
#line 145
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 145U,
                      "expression_of_stmt");
        }
      }
    } else {
      {
#line 145
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 145U,
                    "expression_of_stmt");
      }
    }
  }
#line 145
  last_stmt = (statement )tEmPcast___0;
#line 147
  if (last_stmt) {
#line 147
    if ((unsigned int )last_stmt->kind >= 70U) {
#line 147
      if ((unsigned int )last_stmt->kind <= 70U) {
#line 149
        tEmPcast___2 = (AST_generic )last_stmt;
#line 149
        if (tEmPcast___2) {
#line 149
          if ((unsigned int )tEmPcast___2->kind >= 70U) {
#line 149
            if (! ((unsigned int )tEmPcast___2->kind <= 70U)) {
              {
#line 149
              __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            149U, "expression_of_stmt");
              }
            }
          } else {
            {
#line 149
            __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          149U, "expression_of_stmt");
            }
          }
        }
#line 149
        es = (expression_stmt )tEmPcast___2;
#line 151
        return (es->arg1);
      }
    }
  }
#line 153
  return ((expression )((void *)0));
}
}
#line 156 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool expression_used(expression e ) 
{ 
  node p1 ;
  node n1 ;

  {
#line 158
  p1 = e->parent;
#line 158
  n1 = e->next;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if ((unsigned int )p1->kind >= 70U) {
#line 167
      if ((unsigned int )p1->kind <= 70U) {
#line 168
        return ((bool )0);
      }
    }
#line 169
    if ((unsigned int )p1->kind >= 140U) {
#line 169
      if (! ((unsigned int )p1->kind <= 140U)) {
#line 170
        return ((bool )1);
      }
    } else {
#line 170
      return ((bool )1);
    }
#line 171
    if (n1) {
#line 172
      return ((bool )0);
    }
#line 173
    n1 = p1->next;
#line 174
    p1 = p1->parent;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 178 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool zero_expression(expression e ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  AST_generic tEmPcast___2 ;
  AST_generic tEmPcast___3 ;
  AST_generic tEmPcast___4 ;
  AST_generic tEmPcast___5 ;
  node tmp ;
  bool tmp___0 ;

  {
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((unsigned int )e->kind >= 116U) {
#line 184
      if ((unsigned int )e->kind <= 116U) {
#line 186
        tEmPcast = (AST_generic )e;
#line 186
        if (tEmPcast) {
#line 186
          if ((unsigned int )tEmPcast->kind >= 116U) {
#line 186
            if (! ((unsigned int )tEmPcast->kind <= 116U)) {
              {
#line 186
              __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            186U, "zero_expression");
              }
            }
          } else {
            {
#line 186
            __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          186U, "zero_expression");
            }
          }
        }
#line 186
        e = ((assign )tEmPcast)->arg2;
#line 187
        goto __Cont;
      }
    }
#line 189
    if ((unsigned int )e->kind >= 86U) {
#line 189
      if ((unsigned int )e->kind <= 86U) {
#line 191
        tEmPcast___0 = (AST_generic )e;
#line 191
        if (tEmPcast___0) {
#line 191
          if ((unsigned int )tEmPcast___0->kind >= 86U) {
#line 191
            if (! ((unsigned int )tEmPcast___0->kind <= 86U)) {
              {
#line 191
              __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            191U, "zero_expression");
              }
            }
          } else {
            {
#line 191
            __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          191U, "zero_expression");
            }
          }
        }
#line 191
        e = ((cast )tEmPcast___0)->arg1;
#line 192
        goto __Cont;
      }
    }
#line 194
    if ((unsigned int )e->kind >= 140U) {
#line 194
      if ((unsigned int )e->kind <= 140U) {
#line 196
        tEmPcast___5 = (AST_generic )e;
#line 196
        if (tEmPcast___5) {
#line 196
          if ((unsigned int )tEmPcast___5->kind >= 140U) {
#line 196
            if (! ((unsigned int )tEmPcast___5->kind <= 140U)) {
              {
#line 196
              __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            196U, "zero_expression");
              }
            }
          } else {
            {
#line 196
            __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          196U, "zero_expression");
            }
          }
        }
#line 196
        tEmPcast___4 = (AST_generic )((comma )tEmPcast___5)->arg1;
#line 196
        if (tEmPcast___4) {
#line 196
          if ((unsigned int )tEmPcast___4->kind >= 42U) {
#line 196
            if (! ((unsigned int )tEmPcast___4->kind <= 199U)) {
              {
#line 196
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            196U, "zero_expression");
              }
            }
          } else {
            {
#line 196
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          196U, "zero_expression");
            }
          }
        }
#line 196
        tEmPcast___3 = (AST_generic )((node )tEmPcast___4);
#line 196
        if (tEmPcast___3) {
#line 196
          if ((unsigned int )tEmPcast___3->kind >= 42U) {
#line 196
            if (! ((unsigned int )tEmPcast___3->kind <= 199U)) {
              {
#line 196
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            196U, "zero_expression");
              }
            }
          } else {
            {
#line 196
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          196U, "zero_expression");
            }
          }
        }
        {
#line 196
        tmp = AST_node_last((node )tEmPcast___3);
#line 196
        tEmPcast___2 = (AST_generic )tmp;
        }
#line 196
        if (tEmPcast___2) {
#line 196
          if ((unsigned int )tEmPcast___2->kind >= 42U) {
#line 196
            if (! ((unsigned int )tEmPcast___2->kind <= 199U)) {
              {
#line 196
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            196U, "zero_expression");
              }
            }
          } else {
            {
#line 196
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          196U, "zero_expression");
            }
          }
        }
#line 196
        tEmPcast___1 = (AST_generic )((node )tEmPcast___2);
#line 196
        if (tEmPcast___1) {
#line 196
          if ((unsigned int )tEmPcast___1->kind >= 84U) {
#line 196
            if (! ((unsigned int )tEmPcast___1->kind <= 156U)) {
              {
#line 196
              __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            196U, "zero_expression");
              }
            }
          } else {
            {
#line 196
            __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          196U, "zero_expression");
            }
          }
        }
#line 196
        e = (expression )tEmPcast___1;
#line 197
        goto __Cont;
      }
    }
#line 199
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  tmp___0 = definite_zero(e);
  }
#line 202
  return (tmp___0);
}
}
#line 205 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
expression build_int_constant(region r , location loc , type t , largest_int c ) 
{ 
  char cstbuf[64] ;
  cstring csts ;
  lexical_cst cst ;
  size_t tmp ;
  cval tmp___0 ;
  AST_generic tEmPcast ;

  {
  {
#line 211
  snprintf((char */* __restrict  */)(cstbuf), sizeof(cstbuf), (char const   */* __restrict  */)"%lld",
           c);
#line 212
  csts.data = rstrdup(r, (char const   *)(cstbuf));
#line 213
  tmp = strlen((char const   *)(cstbuf));
#line 213
  csts.length = (int )tmp;
#line 214
  cst = new_lexical_cst(r, loc, csts);
#line 215
  cst->type = t;
#line 216
  tmp___0 = make_cval_signed(c, t);
#line 216
  cst->cst = make_cst(tmp___0, t);
#line 218
  tEmPcast = (AST_generic )cst;
  }
#line 218
  if (tEmPcast) {
#line 218
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 218
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 218
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 218U,
                      "build_int_constant");
        }
      }
    } else {
      {
#line 218
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 218U,
                    "build_int_constant");
      }
    }
  }
#line 218
  return ((expression )tEmPcast);
}
}
#line 221 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
expression build_uint_constant(region r , location loc , type t , largest_uint c ) 
{ 
  char cstbuf[64] ;
  cstring csts ;
  lexical_cst cst ;
  size_t tmp ;
  cval tmp___0 ;
  AST_generic tEmPcast ;

  {
  {
#line 227
  snprintf((char */* __restrict  */)(cstbuf), sizeof(cstbuf), (char const   */* __restrict  */)"%llu",
           c);
#line 228
  csts.data = rstrdup(r, (char const   *)(cstbuf));
#line 229
  tmp = strlen((char const   *)(cstbuf));
#line 229
  csts.length = (int )tmp;
#line 230
  cst = new_lexical_cst(r, loc, csts);
#line 231
  cst->type = t;
#line 232
  tmp___0 = make_cval_unsigned(c, t);
#line 232
  cst->cst = make_cst(tmp___0, t);
#line 234
  tEmPcast = (AST_generic )cst;
  }
#line 234
  if (tEmPcast) {
#line 234
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 234
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 234U,
                      "build_uint_constant");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 234U,
                    "build_uint_constant");
      }
    }
  }
#line 234
  return ((expression )tEmPcast);
}
}
#line 237 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
cval value_of_enumerator(enumerator e ) 
{ 


  {
#line 239
  return (((e->ddecl)->value)->cval);
}
}
#line 242 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
expression build_identifier(region r , location loc , data_declaration id ) 
{ 
  identifier e ;
  cstring tmp ;
  identifier tmp___0 ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
  {
#line 244
  tmp = str2cstring(r, id->name);
#line 244
  tmp___0 = new_identifier(r, loc, tmp, id);
#line 244
  e = tmp___0;
  }
#line 246
  if (! ((unsigned int )id->kind == 0U)) {
#line 246
    if (! ((unsigned int )id->kind == 2U)) {
#line 246
      if (! ((unsigned int )id->kind == 1U)) {
#line 246
        if (! ((unsigned int )id->kind == 6U)) {
          {
#line 246
          __assert_fail("id->kind == decl_variable || id->kind == decl_function || id->kind == decl_constant || id->kind == decl_magic_function",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        247U, "build_identifier");
          }
        }
      }
    }
  }
#line 248
  e->type = id->type;
#line 249
  tEmPcast = (AST_generic )e;
#line 249
  if (tEmPcast) {
#line 249
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 249
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 249
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 249U,
                      "build_identifier");
        }
      }
    } else {
      {
#line 249
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 249U,
                    "build_identifier");
      }
    }
  }
  {
#line 249
  e->cst = fold_identifier((expression )tEmPcast, id, 0);
#line 251
  tEmPcast___0 = (AST_generic )e;
  }
#line 251
  if (tEmPcast___0) {
#line 251
    if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 251
      if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
        {
#line 251
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 251U,
                      "build_identifier");
        }
      }
    } else {
      {
#line 251
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 251U,
                    "build_identifier");
      }
    }
  }
#line 251
  return ((expression )tEmPcast___0);
}
}
#line 254 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
int asm_rwmode(string s ) 
{ 


  {
#line 256
  if ((s->ddecl)->schars.length > 0) {
#line 257
    return ((int )*((s->ddecl)->schars.data + 0));
  } else {
#line 259
    return (-1);
  }
}
}
#line 262 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
declaration ignore_extensions(declaration d ) 
{ 
  AST_generic tEmPcast ;

  {
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if ((unsigned int )d->kind >= 46U) {
#line 264
      if (! ((unsigned int )d->kind <= 46U)) {
#line 264
        goto while_break;
      }
    } else {
#line 264
      goto while_break;
    }
#line 265
    tEmPcast = (AST_generic )d;
#line 265
    if (tEmPcast) {
#line 265
      if ((unsigned int )tEmPcast->kind >= 46U) {
#line 265
        if (! ((unsigned int )tEmPcast->kind <= 46U)) {
          {
#line 265
          __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        265U, "ignore_extensions");
          }
        }
      } else {
        {
#line 265
        __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 265U,
                      "ignore_extensions");
        }
      }
    }
#line 265
    d = ((extension_decl )tEmPcast)->decl;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return (d);
}
}
#line 270 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
tag_declaration get_unnamed_tag_decl(data_decl decl ) 
{ 
  type_element elem ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 276
  elem = decl->modifiers;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! elem) {
#line 276
      goto while_break;
    }
#line 277
    if ((unsigned int )elem->kind >= 169U) {
#line 277
      if ((unsigned int )elem->kind <= 170U) {
#line 277
        goto _L;
      } else {
#line 277
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 277
    if ((unsigned int )elem->kind >= 171U) {
#line 277
      if ((unsigned int )elem->kind <= 172U) {
        _L: /* CIL Label */ 
#line 278
        tEmPcast___0 = (AST_generic )elem;
#line 278
        if (tEmPcast___0) {
#line 278
          if ((unsigned int )tEmPcast___0->kind >= 168U) {
#line 278
            if (! ((unsigned int )tEmPcast___0->kind <= 174U)) {
              {
#line 278
              __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            278U, "get_unnamed_tag_decl");
              }
            }
          } else {
            {
#line 278
            __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          278U, "get_unnamed_tag_decl");
            }
          }
        }
#line 278
        return (((tag_ref )tEmPcast___0)->tdecl);
      }
    }
#line 276
    tEmPcast = (AST_generic )elem->next;
#line 276
    if (tEmPcast) {
#line 276
      if ((unsigned int )tEmPcast->kind >= 157U) {
#line 276
        if (! ((unsigned int )tEmPcast->kind <= 174U)) {
          {
#line 276
          __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        276U, "get_unnamed_tag_decl");
          }
        }
      } else {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 276U,
                      "get_unnamed_tag_decl");
        }
      }
    }
#line 276
    elem = (type_element )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((tag_declaration )((void *)0));
}
}
#line 283 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
char const   *nice_field_name(char const   *s ) 
{ 


  {
#line 288
  if (s) {
#line 289
    return (s);
  }
#line 290
  return ("(anonymous)");
}
}
#line 293 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
char const   *tagkind_name(int tagkind ) 
{ 


  {
  {
#line 297
  if (tagkind == 173) {
#line 297
    goto case_173;
  }
#line 298
  if (tagkind == 169) {
#line 298
    goto case_169;
  }
#line 299
  if (tagkind == 171) {
#line 299
    goto case_171;
  }
#line 300
  if (tagkind == 170) {
#line 300
    goto case_170;
  }
#line 301
  if (tagkind == 172) {
#line 301
    goto case_172;
  }
#line 302
  if (tagkind == 174) {
#line 302
    goto case_174;
  }
#line 303
  goto switch_default;
  case_173: /* CIL Label */ 
#line 297
  return ("attribute");
  case_169: /* CIL Label */ 
#line 298
  return ("struct");
  case_171: /* CIL Label */ 
#line 299
  return ("union");
  case_170: /* CIL Label */ 
#line 300
  return ("nx_struct");
  case_172: /* CIL Label */ 
#line 301
  return ("nx_union");
  case_174: /* CIL Label */ 
#line 302
  return ("enum");
  switch_default: /* CIL Label */ 
  {
#line 303
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 303U,
                "tagkind_name");
  }
#line 303
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 307 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
conditional conditional_lvalue(expression e ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  AST_generic tEmPcast___2 ;
  AST_generic tEmPcast___3 ;
  AST_generic tEmPcast___4 ;
  node tmp ;
  AST_generic tEmPcast___5 ;

  {
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if ((unsigned int )e->kind >= 86U) {
#line 313
      if ((unsigned int )e->kind <= 86U) {
#line 315
        tEmPcast = (AST_generic )e;
#line 315
        if (tEmPcast) {
#line 315
          if ((unsigned int )tEmPcast->kind >= 86U) {
#line 315
            if (! ((unsigned int )tEmPcast->kind <= 86U)) {
              {
#line 315
              __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            315U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 315
            __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          315U, "conditional_lvalue");
            }
          }
        }
#line 315
        e = ((cast )tEmPcast)->arg1;
#line 316
        goto __Cont;
      }
    }
#line 318
    if ((unsigned int )e->kind >= 140U) {
#line 318
      if ((unsigned int )e->kind <= 140U) {
#line 320
        tEmPcast___4 = (AST_generic )e;
#line 320
        if (tEmPcast___4) {
#line 320
          if ((unsigned int )tEmPcast___4->kind >= 140U) {
#line 320
            if (! ((unsigned int )tEmPcast___4->kind <= 140U)) {
              {
#line 320
              __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            320U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 320
            __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          320U, "conditional_lvalue");
            }
          }
        }
#line 320
        tEmPcast___3 = (AST_generic )((comma )tEmPcast___4)->arg1;
#line 320
        if (tEmPcast___3) {
#line 320
          if ((unsigned int )tEmPcast___3->kind >= 42U) {
#line 320
            if (! ((unsigned int )tEmPcast___3->kind <= 199U)) {
              {
#line 320
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            320U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 320
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          320U, "conditional_lvalue");
            }
          }
        }
#line 320
        tEmPcast___2 = (AST_generic )((node )tEmPcast___3);
#line 320
        if (tEmPcast___2) {
#line 320
          if ((unsigned int )tEmPcast___2->kind >= 42U) {
#line 320
            if (! ((unsigned int )tEmPcast___2->kind <= 199U)) {
              {
#line 320
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            320U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 320
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          320U, "conditional_lvalue");
            }
          }
        }
        {
#line 320
        tmp = AST_node_last((node )tEmPcast___2);
#line 320
        tEmPcast___1 = (AST_generic )tmp;
        }
#line 320
        if (tEmPcast___1) {
#line 320
          if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 320
            if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
              {
#line 320
              __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            320U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 320
            __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          320U, "conditional_lvalue");
            }
          }
        }
#line 320
        tEmPcast___0 = (AST_generic )((node )tEmPcast___1);
#line 320
        if (tEmPcast___0) {
#line 320
          if ((unsigned int )tEmPcast___0->kind >= 84U) {
#line 320
            if (! ((unsigned int )tEmPcast___0->kind <= 156U)) {
              {
#line 320
              __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                            320U, "conditional_lvalue");
              }
            }
          } else {
            {
#line 320
            __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          320U, "conditional_lvalue");
            }
          }
        }
#line 320
        e = (expression )tEmPcast___0;
#line 321
        goto __Cont;
      }
    }
#line 323
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if ((unsigned int )e->kind >= 145U) {
#line 326
    if ((unsigned int )e->kind <= 145U) {
#line 327
      tEmPcast___5 = (AST_generic )e;
#line 327
      if (tEmPcast___5) {
#line 327
        if ((unsigned int )tEmPcast___5->kind >= 145U) {
#line 327
          if (! ((unsigned int )tEmPcast___5->kind <= 145U)) {
            {
#line 327
            __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                          327U, "conditional_lvalue");
            }
          }
        } else {
          {
#line 327
          __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        327U, "conditional_lvalue");
          }
        }
      }
#line 327
      return ((conditional )tEmPcast___5);
    } else {
#line 329
      return ((conditional )((void *)0));
    }
  } else {
#line 329
    return ((conditional )((void *)0));
  }
}
}
#line 332 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
data_declaration string_ddecl(expression s ) 
{ 
  data_declaration sdecl ;
  data_declaration tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 334
  if (s->cst) {
    {
#line 334
    tmp___1 = cval_isaddress((s->cst)->cval);
    }
#line 334
    if (tmp___1) {
      {
#line 336
      tmp = cval_ddecl((s->cst)->cval);
#line 336
      sdecl = tmp;
      }
#line 339
      if (sdecl) {
#line 339
        if ((unsigned int )sdecl->kind == 5U) {
          {
#line 339
          tmp___0 = cval_knownbool((s->cst)->cval);
          }
#line 339
          if (tmp___0) {
#line 341
            return (sdecl);
          }
        }
      }
    }
  }
#line 343
  return ((data_declaration )((void *)0));
}
}
#line 346 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
char *ddecl2str(region r , data_declaration ddecl ) 
{ 
  char *tmp ;
  type tmp___0 ;
  bool tmp___1 ;

  {
#line 352
  if (! ((unsigned int )ddecl->kind == 5U)) {
    {
#line 352
    __assert_fail("ddecl->kind == decl_magic_string", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                  352U, "ddecl2str");
    }
  }
  {
#line 354
  tmp___0 = type_array_of(ddecl->type);
#line 354
  tmp___1 = type_char(tmp___0);
  }
#line 354
  if (tmp___1) {
    {
#line 357
    tmp = cstring2str(r, ddecl->schars);
    }
#line 357
    return (tmp);
  } else {
#line 355
    return ((char *)((void *)0));
  }
}
}
#line 361 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
bool is_attr_name(char const   *arg , char const   *name ) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 365
  tmp = strcmp(arg, name);
  }
#line 365
  if (! tmp) {
#line 366
    return ((bool )1);
  }
  {
#line 368
  tmp___0 = strncmp(arg, "__", (size_t )2);
  }
#line 368
  if (tmp___0) {
#line 369
    return ((bool )0);
  }
  {
#line 371
  tmp___1 = strlen(name);
#line 371
  l = (int )tmp___1;
#line 372
  tmp___2 = strncmp(arg + 2, name, (size_t )l);
  }
#line 372
  if (tmp___2) {
#line 372
    tmp___4 = 0;
  } else {
    {
#line 372
    tmp___3 = strcmp((arg + 2) + l, "__");
    }
#line 372
    if (tmp___3) {
#line 372
      tmp___4 = 0;
    } else {
#line 372
      tmp___4 = 1;
    }
  }
#line 372
  return ((bool )tmp___4);
}
}
#line 375 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c"
type_element interesting_element(type_element elems ) 
{ 
  type_element elem ;
  AST_generic tEmPcast ;

  {
#line 379
  elem = elems;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! elem) {
#line 379
      goto while_break;
    }
#line 380
    if ((unsigned int )elem->kind >= 168U) {
#line 380
      if ((unsigned int )elem->kind <= 174U) {
#line 381
        return (elem);
      }
    }
#line 379
    tEmPcast = (AST_generic )elem->next;
#line 379
    if (tEmPcast) {
#line 379
      if ((unsigned int )tEmPcast->kind >= 157U) {
#line 379
        if (! ((unsigned int )tEmPcast->kind <= 174U)) {
          {
#line 379
          __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c",
                        379U, "interesting_element");
          }
        }
      } else {
        {
#line 379
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_utils.c", 379U,
                      "interesting_element");
        }
      }
    }
#line 379
    elem = (type_element )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return ((type_element )((void *)0));
}
}
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.h"
void dd_add_first(region r , dd_list l , void *data ) ;
#line 55
void dd_insert_before(region r , dd_list_pos where , void *data ) ;
#line 59
void dd_insert_after(region r , dd_list_pos where , void *data ) ;
#line 63
void dd_remove(dd_list_pos what ) ;
#line 72
dd_list_pos dd_last(dd_list l ) ;
#line 117
unsigned long dd_length(dd_list l ) ;
#line 121
void dd_append(dd_list l1 , dd_list l2 ) ;
#line 127
dd_list dd_copy(region r , dd_list l ) ;
#line 131
void dd_free_list(dd_list l , void (*delete)(dd_list_pos p ) ) ;
#line 137
dd_list_pos dd_find(dd_list l , void *find ) ;
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
static dd_list_pos new_hdr(region r , void *data , dd_list_pos previous , dd_list_pos next ) 
{ 
  dd_list_pos new ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 53
  if (sizeof(struct dd_list_pos ) < (unsigned long )(1 << 9)) {
    {
#line 53
    tmp = __rcralloc_small0(r, sizeof(struct dd_list_pos ));
#line 53
    tmp___1 = tmp;
    }
  } else {
    {
#line 53
    tmp___0 = typed_ralloc(r, sizeof(struct dd_list_pos ), 0);
#line 53
    tmp___1 = tmp___0;
    }
  }
#line 53
  new = (dd_list_pos )tmp___1;
#line 55
  new->data = data;
#line 56
  new->previous = previous;
#line 57
  new->next = next;
#line 59
  return (new);
}
}
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
dd_list dd_new_list(region r ) 
{ 
  dd_list new ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 66
  if (sizeof(struct dd_list ) < (unsigned long )(1 << 9)) {
    {
#line 66
    tmp = __rcralloc_small0(r, sizeof(struct dd_list ));
#line 66
    tmp___1 = tmp;
    }
  } else {
    {
#line 66
    tmp___0 = typed_ralloc(r, sizeof(struct dd_list ), 0);
#line 66
    tmp___1 = tmp___0;
    }
  }
#line 66
  new = (dd_list )tmp___1;
#line 69
  new->first = (dd_list_pos )(& new->null);
#line 70
  new->null = (struct dd_list_pos *)((void *)0);
#line 71
  new->last = (dd_list_pos )new;
#line 73
  return (new);
}
}
#line 76 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_add_first(region r , dd_list l , void *data ) 
{ 


  {
  {
#line 81
  dd_insert_after(r, (dd_list_pos )l, data);
  }
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_add_last(region r , dd_list l , void *data ) 
{ 


  {
  {
#line 86
  dd_insert_before(r, (dd_list_pos )(& l->null), data);
  }
#line 87
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_insert_before(region r , dd_list_pos where , void *data ) 
{ 
  dd_list_pos new ;
  dd_list_pos tmp ;

  {
  {
#line 94
  tmp = new_hdr(r, data, where->previous, where);
#line 94
  new = tmp;
#line 96
  (where->previous)->next = new;
#line 97
  where->previous = new;
  }
#line 98
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_insert_after(region r , dd_list_pos where , void *data ) 
{ 
  dd_list_pos new ;
  dd_list_pos tmp ;

  {
  {
#line 105
  tmp = new_hdr(r, data, where, where->next);
#line 105
  new = tmp;
#line 107
  (where->next)->previous = new;
#line 108
  where->next = new;
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_remove(dd_list_pos what ) 
{ 
  struct dd_list_pos *tmp ;

  {
#line 117
  (what->previous)->next = what->next;
#line 118
  (what->next)->previous = what->previous;
#line 120
  tmp = (struct dd_list_pos *)((void *)0);
#line 120
  what->previous = tmp;
#line 120
  what->next = tmp;
#line 121
  what->data = (void *)0;
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
dd_list_pos dd_first(dd_list l ) 
{ 


  {
#line 128
  return (l->first);
}
}
#line 131 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
dd_list_pos dd_last(dd_list l ) 
{ 


  {
#line 135
  return (l->last);
}
}
#line 138 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
unsigned long dd_length(dd_list l ) 
{ 
  dd_list_pos scan ;
  unsigned long len ;

  {
  {
#line 143
  len = 0UL;
#line 145
  scan = dd_first(l);
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (! (! scan->next))) {
#line 145
      goto while_break;
    }
#line 145
    len ++;
#line 145
    scan = scan->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (len);
}
}
#line 150 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_append(dd_list l1 , dd_list l2 ) 
{ 
  struct dd_list_pos *tmp ;

  {
#line 156
  (l1->last)->next = l2->first;
#line 157
  (l2->first)->previous = l1->last;
#line 158
  (l2->last)->next = (dd_list_pos )(& l1->null);
#line 159
  l1->last = l2->last;
#line 161
  tmp = (struct dd_list_pos *)((void *)0);
#line 161
  l2->last = tmp;
#line 161
  l2->first = tmp;
#line 162
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
dd_list dd_copy(region r , dd_list l ) 
{ 
  dd_list new ;
  dd_list tmp ;
  dd_list_pos scan ;

  {
  {
#line 168
  tmp = dd_new_list(r);
#line 168
  new = tmp;
#line 171
  scan = dd_first(l);
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (! (! scan->next))) {
#line 171
      goto while_break;
    }
    {
#line 171
    dd_add_last(r, new, scan->data);
#line 171
    scan = scan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (new);
}
}
#line 176 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
void dd_free_list(dd_list l , void (*delete)(dd_list_pos p ) ) 
{ 
  dd_list_pos scan ;
  dd_list_pos next ;
  struct dd_list_pos *tmp ;
  struct dd_list_pos *tmp___0 ;

  {
  {
#line 183
  scan = dd_first(l);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (! (! scan->next))) {
#line 184
      goto while_break;
    }
#line 186
    next = scan->next;
#line 187
    if (delete) {
      {
#line 187
      (*delete)(next);
      }
    }
#line 189
    tmp = (struct dd_list_pos *)((void *)0);
#line 189
    scan->previous = tmp;
#line 189
    scan->next = tmp;
#line 190
    scan->data = (void *)0;
#line 192
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  tmp___0 = (struct dd_list_pos *)((void *)0);
#line 194
  l->last = tmp___0;
#line 194
  l->first = tmp___0;
#line 195
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/nescc-1.3.4/src/dd_list.c"
dd_list_pos dd_find(dd_list l , void *find ) 
{ 
  dd_list_pos scan ;

  {
  {
#line 203
  scan = dd_first(l);
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (! (! scan->next))) {
#line 203
      goto while_break;
    }
#line 204
    if ((unsigned long )scan->data == (unsigned long )find) {
#line 204
      return (scan);
    }
#line 203
    scan = scan->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return ((dd_list_pos )((void *)0));
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 70 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_top  ;
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_unknown_number  ;
#line 72 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_unknown_address  ;
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_zero  ;
#line 75 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_one  ;
#line 77 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.h"
cval cval_bitsperbyte  ;
#line 79
void cval_init(void) ;
#line 84
cval make_type_cval(size_t s ) ;
#line 91
cval make_cval_float(long double d ) ;
#line 92
cval make_cval_complex(cval r , cval i ) ;
#line 93
cval make_cval_address(data_declaration ddecl , label_declaration ldecl , largest_int offset ) ;
#line 96
cval make_cval_address_unknown_offset(cval c ) ;
#line 101
bool cval_isunknown(cval c ) ;
#line 120
bool cval_isinteger(cval c ) ;
#line 123
bool cval_isunsigned(cval c ) ;
#line 126
bool cval_isfloating(cval c ) ;
#line 129
bool cval_iscomplex(cval c ) ;
#line 138
bool cval_boolvalue(cval c ) ;
#line 143
bool cval_knownvalue(cval c ) ;
#line 149
largest_uint cval_uint_value(cval c ) ;
#line 154
largest_int cval_sint_value(cval c ) ;
#line 159
long double cval_float_value(cval c ) ;
#line 164
bool cval_isone(cval c ) ;
#line 174
label_declaration cval_ldecl(cval c ) ;
#line 182
cval cval_cast(cval c , type to ) ;
#line 183
cval cval_not(cval c ) ;
#line 184
cval cval_negate(cval c ) ;
#line 185
cval cval_bitnot(cval c ) ;
#line 186
cval cval_conjugate(cval c ) ;
#line 187
cval cval_realpart(cval c ) ;
#line 188
cval cval_imagpart(cval c ) ;
#line 192
cval cval_add(cval c1 , cval c2 ) ;
#line 193
cval cval_sub(cval c1 , cval c2 ) ;
#line 194
cval cval_times(cval c1 , cval c2 ) ;
#line 195
cval cval_divide(cval c1 , cval c2 ) ;
#line 196
cval cval_modulo(cval c1 , cval c2 ) ;
#line 197
cval cval_lshift(cval c1 , cval c2 ) ;
#line 198
cval cval_rshift(cval c1 , cval c2 ) ;
#line 199
cval cval_bitand(cval c1 , cval c2 ) ;
#line 200
cval cval_bitor(cval c1 , cval c2 ) ;
#line 201
cval cval_bitxor(cval c1 , cval c2 ) ;
#line 202
cval cval_eq(cval c1 , cval c2 ) ;
#line 204
cval cval_leq(cval c1 , cval c2 ) ;
#line 214
bool uint_inrange(largest_uint x , type t ) ;
#line 215
bool sint_inrange(largest_int x , type t ) ;
#line 217
bool cval_inrange(cval c , type t ) ;
#line 221
largest_int cval_intcompare(cval c1 , cval c2 ) ;
#line 226
void cval_print(FILE *f , cval c ) ;
#line 232
cval cval_lcm(cval x , cval y ) ;
#line 233
cval cval_gcd(cval x , cval y ) ;
#line 234
cval cval_align_to(cval n , cval alignment ) ;
#line 235
cval cval_max(cval c1 , cval c2 ) ;
#line 236
cval cval_min(cval c1 , cval c2 ) ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type intptr_type ;
#line 126
extern cval type_size(type t ) ;
#line 183
extern bool type_double(type t ) ;
#line 51 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
void cval_init(void) 
{ 


  {
#line 54
  if (! (sizeof(largest_int ) == sizeof(largest_uint ))) {
    {
#line 54
    __assert_fail("sizeof(largest_int) == sizeof(largest_uint)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  54U, "cval_init");
    }
  }
#line 57
  cval_top.kind = (enum __anonenum_kind_32 )0;
#line 58
  cval_unknown_number.kind = (enum __anonenum_kind_32 )1;
#line 59
  cval_unknown_address.kind = (enum __anonenum_kind_32 )2;
#line 60
  cval_zero.kind = (enum __anonenum_kind_32 )9;
#line 61
  cval_zero.__annonCompField6.__annonCompField5.__annonCompField2.si = (largest_int )0;
#line 62
  cval_zero.__annonCompField6.__annonCompField5.isize = target->tint.size;
#line 63
  cval_one.kind = (enum __anonenum_kind_32 )9;
#line 64
  cval_one.__annonCompField6.__annonCompField5.__annonCompField2.si = (largest_int )1;
#line 65
  cval_one.__annonCompField6.__annonCompField5.isize = target->tint.size;
#line 66
  cval_bitsperbyte.kind = (enum __anonenum_kind_32 )7;
#line 67
  cval_bitsperbyte.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )8;
#line 68
  cval_bitsperbyte.__annonCompField6.__annonCompField5.isize = target->size_t_size;
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_unsigned(largest_uint i , type t ) 
{ 
  cval c ;
  bool tmp ;
  bool tmp___0 ;
  largest_uint tmp___1 ;

  {
  {
#line 75
  tmp = type_integral(t);
  }
#line 75
  if (tmp) {
    {
#line 75
    tmp___0 = type_unsigned(t);
    }
#line 75
    if (! tmp___0) {
      {
#line 75
      __assert_fail("type_integral(t) && type_unsigned(t)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    75U, "make_cval_unsigned");
      }
    }
  } else {
    {
#line 75
    __assert_fail("type_integral(t) && type_unsigned(t)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  75U, "make_cval_unsigned");
    }
  }
  {
#line 76
  c.kind = (enum __anonenum_kind_32 )7;
#line 77
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = i;
#line 78
  tmp___1 = type_size_int(t);
#line 78
  c.__annonCompField6.__annonCompField5.isize = (size_t )tmp___1;
  }
#line 79
  return (c);
}
}
#line 82 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_signed(largest_int i , type t ) 
{ 
  cval c ;
  bool tmp ;
  bool tmp___0 ;
  largest_uint tmp___1 ;

  {
  {
#line 86
  tmp = type_integral(t);
  }
#line 86
  if (tmp) {
    {
#line 86
    tmp___0 = type_unsigned(t);
    }
#line 86
    if (tmp___0) {
      {
#line 86
      __assert_fail("type_integral(t) && !type_unsigned(t)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    86U, "make_cval_signed");
      }
    }
  } else {
    {
#line 86
    __assert_fail("type_integral(t) && !type_unsigned(t)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  86U, "make_cval_signed");
    }
  }
  {
#line 87
  c.kind = (enum __anonenum_kind_32 )9;
#line 88
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = i;
#line 89
  tmp___1 = type_size_int(t);
#line 89
  c.__annonCompField6.__annonCompField5.isize = (size_t )tmp___1;
  }
#line 90
  return (c);
}
}
#line 93 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_type_cval(size_t s ) 
{ 
  cval c ;

  {
#line 102
  c.kind = (enum __anonenum_kind_32 )7;
#line 103
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )s;
#line 104
  c.__annonCompField6.__annonCompField5.isize = target->size_t_size;
#line 106
  return (c);
}
}
#line 109 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_float(long double d ) 
{ 
  cval c ;

  {
#line 112
  c.kind = (enum __anonenum_kind_32 )5;
#line 113
  c.__annonCompField6.__annonCompField1.d = d;
#line 114
  return (c);
}
}
#line 117 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_complex(cval r , cval i ) 
{ 


  {
#line 119
  if (! ((unsigned int )r.kind == (unsigned int )i.kind)) {
    {
#line 119
    __assert_fail("r.kind == i.kind", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  119U, "make_cval_complex");
    }
  }
  {
#line 123
  if ((unsigned int )r.kind == 5U) {
#line 123
    goto case_5;
  }
#line 127
  if ((unsigned int )r.kind == 7U) {
#line 127
    goto case_7;
  }
#line 132
  if ((unsigned int )r.kind == 9U) {
#line 132
    goto case_9;
  }
#line 138
  goto switch_default;
  case_5: /* CIL Label */ 
#line 124
  r.__annonCompField6.__annonCompField1.d_i = i.__annonCompField6.__annonCompField1.d;
#line 125
  r.kind = (enum __anonenum_kind_32 )6;
#line 126
  return (r);
  case_7: /* CIL Label */ 
#line 128
  if (! (r.__annonCompField6.__annonCompField5.isize == i.__annonCompField6.__annonCompField5.isize)) {
    {
#line 128
    __assert_fail("r.isize == i.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  128U, "make_cval_complex");
    }
  }
#line 129
  r.kind = (enum __anonenum_kind_32 )8;
#line 130
  r.__annonCompField6.__annonCompField5.__annonCompField4.ui_i = i.__annonCompField6.__annonCompField5.__annonCompField2.ui;
#line 131
  return (r);
  case_9: /* CIL Label */ 
#line 133
  if (! (r.__annonCompField6.__annonCompField5.isize == i.__annonCompField6.__annonCompField5.isize)) {
    {
#line 133
    __assert_fail("r.isize == i.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  133U, "make_cval_complex");
    }
  }
#line 134
  r.kind = (enum __anonenum_kind_32 )10;
#line 135
  r.__annonCompField6.__annonCompField5.__annonCompField4.si_i = i.__annonCompField6.__annonCompField5.__annonCompField2.si;
#line 136
  return (r);
  switch_default: /* CIL Label */ 
  {
#line 138
  abort();
  }
#line 138
  return (r);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 142 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_address(data_declaration ddecl , label_declaration ldecl , largest_int offset ) 
{ 
  cval c ;
  cval tmp ;

  {
  {
#line 145
  tmp = make_cval_signed(offset, ptrdiff_t_type);
#line 145
  c = tmp;
  }
#line 147
  if (ldecl) {
#line 147
    if (ddecl) {
      {
#line 147
      __assert_fail("!(ldecl && ddecl)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    147U, "make_cval_address");
      }
    }
  }
#line 148
  c.kind = (enum __anonenum_kind_32 )4;
#line 149
  c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl = ddecl;
#line 150
  c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl = ldecl;
#line 152
  return (c);
}
}
#line 155 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval make_cval_address_unknown_offset(cval c ) 
{ 
  bool tmp ;

  {
  {
#line 160
  tmp = cval_isaddress(c);
  }
#line 160
  if (! tmp) {
    {
#line 160
    __assert_fail("cval_isaddress(c)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  160U, "make_cval_address_unknown_offset");
    }
  }
#line 161
  if ((unsigned int )c.kind == 4U) {
#line 162
    c.kind = (enum __anonenum_kind_32 )3;
  }
#line 164
  return (c);
}
}
#line 167 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isunknown(cval c ) 
{ 
  int tmp ;

  {
#line 170
  if ((unsigned int )c.kind == 1U) {
#line 170
    tmp = 1;
  } else
#line 170
  if ((unsigned int )c.kind == 2U) {
#line 170
    tmp = 1;
  } else {
#line 170
    tmp = 0;
  }
#line 170
  return ((bool )tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isaddress(cval c ) 
{ 
  int tmp ;

  {
#line 175
  if ((unsigned int )c.kind == 2U) {
#line 175
    tmp = 1;
  } else
#line 175
  if ((unsigned int )c.kind == 4U) {
#line 175
    tmp = 1;
  } else
#line 175
  if ((unsigned int )c.kind == 3U) {
#line 175
    tmp = 1;
  } else {
#line 175
    tmp = 0;
  }
#line 175
  return ((bool )tmp);
}
}
#line 179 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isinteger(cval c ) 
{ 
  int tmp ;

  {
#line 181
  if ((unsigned int )c.kind == 9U) {
#line 181
    tmp = 1;
  } else
#line 181
  if ((unsigned int )c.kind == 7U) {
#line 181
    tmp = 1;
  } else {
#line 181
    tmp = 0;
  }
#line 181
  return ((bool )tmp);
}
}
#line 184 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isunsigned(cval c ) 
{ 


  {
#line 186
  return ((bool )((unsigned int )c.kind == 7U));
}
}
#line 189 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isfloating(cval c ) 
{ 


  {
#line 191
  return ((bool )((unsigned int )c.kind == 5U));
}
}
#line 194 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_iscomplex(cval c ) 
{ 
  int tmp ;

  {
#line 196
  if ((unsigned int )c.kind == 10U) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((unsigned int )c.kind == 8U) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((unsigned int )c.kind == 6U) {
#line 196
    tmp = 1;
  } else {
#line 196
    tmp = 0;
  }
#line 196
  return ((bool )tmp);
}
}
#line 200 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_knownbool(cval c ) 
{ 


  {
  {
#line 207
  if ((unsigned int )c.kind == 3U) {
#line 207
    goto case_3;
  }
#line 207
  if ((unsigned int )c.kind == 2U) {
#line 207
    goto case_3;
  }
#line 207
  if ((unsigned int )c.kind == 1U) {
#line 207
    goto case_3;
  }
#line 209
  if ((unsigned int )c.kind == 4U) {
#line 209
    goto case_4;
  }
#line 211
  if ((unsigned int )c.kind == 6U) {
#line 211
    goto case_6;
  }
#line 211
  if ((unsigned int )c.kind == 10U) {
#line 211
    goto case_6;
  }
#line 211
  if ((unsigned int )c.kind == 8U) {
#line 211
    goto case_6;
  }
#line 211
  if ((unsigned int )c.kind == 5U) {
#line 211
    goto case_6;
  }
#line 211
  if ((unsigned int )c.kind == 9U) {
#line 211
    goto case_6;
  }
#line 211
  if ((unsigned int )c.kind == 7U) {
#line 211
    goto case_6;
  }
#line 206
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 206
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 206U, "cval_knownbool");
  }
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 208
  return ((bool )0);
  case_4: /* CIL Label */ 
#line 209
  return ((bool )(c.__annonCompField6.__annonCompField5.__annonCompField2.si == 0LL));
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 212
  return ((bool )1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 216 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_boolvalue(cval c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 223
  if ((unsigned int )c.kind == 4U) {
#line 223
    goto case_4;
  }
#line 224
  if ((unsigned int )c.kind == 7U) {
#line 224
    goto case_7;
  }
#line 225
  if ((unsigned int )c.kind == 9U) {
#line 225
    goto case_9;
  }
#line 226
  if ((unsigned int )c.kind == 5U) {
#line 226
    goto case_5;
  }
#line 227
  if ((unsigned int )c.kind == 8U) {
#line 227
    goto case_8;
  }
#line 228
  if ((unsigned int )c.kind == 10U) {
#line 228
    goto case_10;
  }
#line 229
  if ((unsigned int )c.kind == 6U) {
#line 229
    goto case_6;
  }
#line 222
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 222
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 222U, "cval_boolvalue");
  }
  case_4: /* CIL Label */ 
#line 223
  if (! (c.__annonCompField6.__annonCompField5.__annonCompField2.si == 0LL)) {
    {
#line 223
    __assert_fail("c.si == 0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  223U, "cval_boolvalue");
    }
  }
#line 223
  return ((bool )1);
  case_7: /* CIL Label */ 
#line 224
  return ((bool )(c.__annonCompField6.__annonCompField5.__annonCompField2.ui != 0ULL));
  case_9: /* CIL Label */ 
#line 225
  return ((bool )(c.__annonCompField6.__annonCompField5.__annonCompField2.si != 0LL));
  case_5: /* CIL Label */ 
#line 226
  return ((bool )(c.__annonCompField6.__annonCompField1.d != (long double )0));
  case_8: /* CIL Label */ 
#line 227
  if (c.__annonCompField6.__annonCompField5.__annonCompField2.ui) {
#line 227
    if (c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i) {
#line 227
      tmp = 1;
    } else {
#line 227
      tmp = 0;
    }
  } else {
#line 227
    tmp = 0;
  }
#line 227
  return ((bool )tmp);
  case_10: /* CIL Label */ 
#line 228
  if (c.__annonCompField6.__annonCompField5.__annonCompField2.si) {
#line 228
    if (c.__annonCompField6.__annonCompField5.__annonCompField4.si_i) {
#line 228
      tmp___0 = 1;
    } else {
#line 228
      tmp___0 = 0;
    }
  } else {
#line 228
    tmp___0 = 0;
  }
#line 228
  return ((bool )tmp___0);
  case_6: /* CIL Label */ 
#line 229
  if (c.__annonCompField6.__annonCompField1.d) {
#line 229
    if (c.__annonCompField6.__annonCompField1.d_i) {
#line 229
      tmp___1 = 1;
    } else {
#line 229
      tmp___1 = 0;
    }
  } else {
#line 229
    tmp___1 = 0;
  }
#line 229
  return ((bool )tmp___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 233 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_knownvalue(cval c ) 
{ 


  {
  {
#line 242
  if ((unsigned int )c.kind == 4U) {
#line 242
    goto case_4;
  }
#line 242
  if ((unsigned int )c.kind == 3U) {
#line 242
    goto case_4;
  }
#line 242
  if ((unsigned int )c.kind == 2U) {
#line 242
    goto case_4;
  }
#line 242
  if ((unsigned int )c.kind == 1U) {
#line 242
    goto case_4;
  }
#line 244
  if ((unsigned int )c.kind == 6U) {
#line 244
    goto case_6;
  }
#line 244
  if ((unsigned int )c.kind == 10U) {
#line 244
    goto case_6;
  }
#line 244
  if ((unsigned int )c.kind == 8U) {
#line 244
    goto case_6;
  }
#line 244
  if ((unsigned int )c.kind == 5U) {
#line 244
    goto case_6;
  }
#line 244
  if ((unsigned int )c.kind == 9U) {
#line 244
    goto case_6;
  }
#line 244
  if ((unsigned int )c.kind == 7U) {
#line 244
    goto case_6;
  }
#line 240
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 240
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 240U, "cval_knownvalue");
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 242
  return ((bool )0);
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 245
  return ((bool )1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 249 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
largest_uint cval_uint_value(cval c ) 
{ 


  {
  {
#line 256
  if ((unsigned int )c.kind == 7U) {
#line 256
    goto case_7;
  }
#line 257
  if ((unsigned int )c.kind == 9U) {
#line 257
    goto case_9;
  }
#line 258
  if ((unsigned int )c.kind == 5U) {
#line 258
    goto case_5;
  }
#line 255
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 255
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 255U, "cval_uint_value");
  }
#line 255
  return ((largest_uint )0);
  case_7: /* CIL Label */ 
#line 256
  return (c.__annonCompField6.__annonCompField5.__annonCompField2.ui);
  case_9: /* CIL Label */ 
#line 257
  return ((largest_uint )c.__annonCompField6.__annonCompField5.__annonCompField2.si);
  case_5: /* CIL Label */ 
#line 258
  return ((largest_uint )c.__annonCompField6.__annonCompField1.d);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 262 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
largest_int cval_sint_value(cval c ) 
{ 


  {
  {
#line 269
  if ((unsigned int )c.kind == 7U) {
#line 269
    goto case_7;
  }
#line 270
  if ((unsigned int )c.kind == 9U) {
#line 270
    goto case_9;
  }
#line 271
  if ((unsigned int )c.kind == 5U) {
#line 271
    goto case_5;
  }
#line 268
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 268
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 268U, "cval_sint_value");
  }
#line 268
  return ((largest_int )0);
  case_7: /* CIL Label */ 
#line 269
  return ((largest_int )c.__annonCompField6.__annonCompField5.__annonCompField2.ui);
  case_9: /* CIL Label */ 
#line 270
  return (c.__annonCompField6.__annonCompField5.__annonCompField2.si);
  case_5: /* CIL Label */ 
#line 271
  return ((largest_int )c.__annonCompField6.__annonCompField1.d);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 275 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
long double cval_float_value(cval c ) 
{ 


  {
  {
#line 282
  if ((unsigned int )c.kind == 7U) {
#line 282
    goto case_7;
  }
#line 283
  if ((unsigned int )c.kind == 9U) {
#line 283
    goto case_9;
  }
#line 284
  if ((unsigned int )c.kind == 5U) {
#line 284
    goto case_5;
  }
#line 281
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 281
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 281U, "cval_float_value");
  }
#line 281
  return ((long double )0);
  case_7: /* CIL Label */ 
#line 282
  return ((long double )c.__annonCompField6.__annonCompField5.__annonCompField2.ui);
  case_9: /* CIL Label */ 
#line 283
  return ((long double )c.__annonCompField6.__annonCompField5.__annonCompField2.si);
  case_5: /* CIL Label */ 
#line 284
  return (c.__annonCompField6.__annonCompField1.d);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 288 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_isone(cval c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 296
  if ((unsigned int )c.kind == 4U) {
#line 296
    goto case_4;
  }
#line 296
  if ((unsigned int )c.kind == 3U) {
#line 296
    goto case_4;
  }
#line 296
  if ((unsigned int )c.kind == 2U) {
#line 296
    goto case_4;
  }
#line 296
  if ((unsigned int )c.kind == 1U) {
#line 296
    goto case_4;
  }
#line 297
  if ((unsigned int )c.kind == 7U) {
#line 297
    goto case_7;
  }
#line 298
  if ((unsigned int )c.kind == 9U) {
#line 298
    goto case_9;
  }
#line 299
  if ((unsigned int )c.kind == 5U) {
#line 299
    goto case_5;
  }
#line 300
  if ((unsigned int )c.kind == 8U) {
#line 300
    goto case_8;
  }
#line 301
  if ((unsigned int )c.kind == 10U) {
#line 301
    goto case_10;
  }
#line 302
  if ((unsigned int )c.kind == 6U) {
#line 302
    goto case_6;
  }
#line 294
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 294
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 294U, "cval_isone");
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 296
  return ((bool )0);
  case_7: /* CIL Label */ 
#line 297
  return ((bool )(c.__annonCompField6.__annonCompField5.__annonCompField2.ui == 1ULL));
  case_9: /* CIL Label */ 
#line 298
  return ((bool )(c.__annonCompField6.__annonCompField5.__annonCompField2.si == 1LL));
  case_5: /* CIL Label */ 
#line 299
  return ((bool )(c.__annonCompField6.__annonCompField1.d == (long double )1));
  case_8: /* CIL Label */ 
#line 300
  if (c.__annonCompField6.__annonCompField5.__annonCompField2.ui == 1ULL) {
#line 300
    if (c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i == 0ULL) {
#line 300
      tmp = 1;
    } else {
#line 300
      tmp = 0;
    }
  } else {
#line 300
    tmp = 0;
  }
#line 300
  return ((bool )tmp);
  case_10: /* CIL Label */ 
#line 301
  if (c.__annonCompField6.__annonCompField5.__annonCompField2.si == 1LL) {
#line 301
    if (c.__annonCompField6.__annonCompField5.__annonCompField4.si_i == 0LL) {
#line 301
      tmp___0 = 1;
    } else {
#line 301
      tmp___0 = 0;
    }
  } else {
#line 301
    tmp___0 = 0;
  }
#line 301
  return ((bool )tmp___0);
  case_6: /* CIL Label */ 
#line 302
  if (c.__annonCompField6.__annonCompField1.d == (long double )1) {
#line 302
    if (c.__annonCompField6.__annonCompField1.d_i == (long double )0) {
#line 302
      tmp___1 = 1;
    } else {
#line 302
      tmp___1 = 0;
    }
  } else {
#line 302
    tmp___1 = 0;
  }
#line 302
  return ((bool )tmp___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
static largest_uint truncate_unsigned(largest_uint x , size_t tsize ) 
{ 


  {
#line 310
  if (! (tsize <= sizeof(largest_uint ))) {
    {
#line 310
    __assert_fail("tsize <= sizeof(largest_uint)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  310U, "truncate_unsigned");
    }
  }
#line 312
  if (tsize == sizeof(largest_uint )) {
#line 313
    return (x);
  } else {
#line 315
    return (x & ((1ULL << 8UL * tsize) - 1ULL));
  }
}
}
#line 319 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
static largest_int truncate_signed(largest_int x , size_t tsize ) 
{ 
  largest_uint umask ;
  largest_uint uval ;

  {
#line 323
  if (! (tsize <= sizeof(largest_int ))) {
    {
#line 323
    __assert_fail("tsize <= sizeof(largest_int)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  323U, "truncate_signed");
    }
  }
#line 325
  if (tsize == sizeof(largest_int )) {
#line 326
    return (x);
  }
#line 329
  umask = (1ULL << 8UL * tsize) - 1ULL;
#line 330
  uval = (unsigned long long )x & umask;
#line 332
  if (uval & (1ULL << (8UL * tsize - 1UL))) {
#line 333
    return ((largest_int )((0xffffffffffffffffULL & ~ umask) | uval));
  } else {
#line 335
    return ((largest_int )uval);
  }
}
}
#line 341 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_cast(cval c , type to ) 
{ 
  type base ;
  type tmp ;
  cval tmp___0 ;
  cval tmp___1 ;
  cval tmp___2 ;
  cval tmp___3 ;
  cval tmp___4 ;
  cval tmp___5 ;
  cval tmp___6 ;
  cval tmp___7 ;
  bool tmp___8 ;
  cval tmp___9 ;
  cval tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  cval tosize_cval ;
  cval tmp___14 ;
  size_t tosize ;
  largest_uint tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  largest_uint tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;

  {
#line 346
  if ((unsigned int )c.kind == 0U) {
#line 347
    return (cval_top);
  }
#line 349
  if ((unsigned int )c.kind == 1U) {
#line 350
    return (cval_unknown_number);
  }
  {
#line 352
  tmp___8 = type_complex(to);
  }
#line 352
  if (tmp___8) {
    {
#line 354
    tmp = make_base_type(to);
#line 354
    base = tmp;
    }
    {
#line 358
    if ((unsigned int )c.kind == 4U) {
#line 358
      goto case_4;
    }
#line 358
    if ((unsigned int )c.kind == 3U) {
#line 358
      goto case_4;
    }
#line 358
    if ((unsigned int )c.kind == 2U) {
#line 358
      goto case_4;
    }
#line 360
    if ((unsigned int )c.kind == 5U) {
#line 360
      goto case_5;
    }
#line 360
    if ((unsigned int )c.kind == 7U) {
#line 360
      goto case_5;
    }
#line 360
    if ((unsigned int )c.kind == 9U) {
#line 360
      goto case_5;
    }
#line 364
    if ((unsigned int )c.kind == 6U) {
#line 364
      goto case_6;
    }
#line 364
    if ((unsigned int )c.kind == 8U) {
#line 364
      goto case_6;
    }
#line 364
    if ((unsigned int )c.kind == 10U) {
#line 364
      goto case_6;
    }
#line 367
    goto switch_default;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 359
    return (cval_top);
    case_5: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 361
    tmp___0 = cval_cast(cval_zero, base);
#line 361
    tmp___1 = cval_cast(c, base);
#line 361
    tmp___2 = make_cval_complex(tmp___1, tmp___0);
    }
#line 361
    return (tmp___2);
#line 363
    return (c);
    case_6: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 365
    tmp___3 = cval_imagpart(c);
#line 365
    tmp___4 = cval_cast(tmp___3, base);
#line 365
    tmp___5 = cval_realpart(c);
#line 365
    tmp___6 = cval_cast(tmp___5, base);
#line 365
    tmp___7 = make_cval_complex(tmp___6, tmp___4);
    }
#line 365
    return (tmp___7);
    switch_default: /* CIL Label */ 
    {
#line 367
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 367U,
                  "cval_cast");
    }
#line 367
    return (c);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 371
  tmp___11 = cval_iscomplex(c);
  }
#line 371
  if (tmp___11) {
    {
#line 372
    tmp___9 = cval_realpart(c);
#line 372
    tmp___10 = cval_cast(tmp___9, to);
    }
#line 372
    return (tmp___10);
  }
  {
#line 374
  tmp___22 = type_floating(to);
  }
#line 374
  if (tmp___22) {
    {
#line 378
    if ((unsigned int )c.kind == 4U) {
#line 378
      goto case_4___0;
    }
#line 378
    if ((unsigned int )c.kind == 3U) {
#line 378
      goto case_4___0;
    }
#line 378
    if ((unsigned int )c.kind == 2U) {
#line 378
      goto case_4___0;
    }
#line 380
    if ((unsigned int )c.kind == 7U) {
#line 380
      goto case_7___0;
    }
#line 380
    if ((unsigned int )c.kind == 9U) {
#line 380
      goto case_7___0;
    }
#line 387
    if ((unsigned int )c.kind == 5U) {
#line 387
      goto case_5___0;
    }
#line 393
    goto switch_default___0;
    case_4___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 379
    return (cval_top);
    case_7___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
#line 381
    c.kind = (enum __anonenum_kind_32 )5;
#line 385
    if ((unsigned int )c.kind == 9U) {
#line 385
      c.__annonCompField6.__annonCompField1.d = (long double )c.__annonCompField6.__annonCompField5.__annonCompField2.si;
    } else {
#line 385
      c.__annonCompField6.__annonCompField1.d = (long double )c.__annonCompField6.__annonCompField5.__annonCompField2.ui;
    }
#line 386
    return (c);
    case_5___0: /* CIL Label */ 
    {
#line 388
    tmp___13 = type_float(to);
    }
#line 388
    if (tmp___13) {
#line 389
      c.__annonCompField6.__annonCompField1.d = (long double )((float )c.__annonCompField6.__annonCompField1.d);
    } else {
      {
#line 390
      tmp___12 = type_double(to);
      }
#line 390
      if (tmp___12) {
#line 391
        c.__annonCompField6.__annonCompField1.d = (long double )((double )c.__annonCompField6.__annonCompField1.d);
      }
    }
#line 392
    return (c);
    switch_default___0: /* CIL Label */ 
    {
#line 393
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 393U,
                  "cval_cast");
    }
#line 393
    return (c);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 398
    tmp___14 = type_size(to);
#line 398
    tosize_cval = tmp___14;
    }
#line 402
    if ((unsigned int )tosize_cval.kind == 1U) {
      {
#line 406
      if ((unsigned int )c.kind == 4U) {
#line 406
        goto case_4___1;
      }
#line 406
      if ((unsigned int )c.kind == 3U) {
#line 406
        goto case_4___1;
      }
#line 406
      if ((unsigned int )c.kind == 2U) {
#line 406
        goto case_4___1;
      }
#line 408
      goto switch_default___1;
      case_4___1: /* CIL Label */ 
      case_3___1: /* CIL Label */ 
      case_2___1: /* CIL Label */ 
#line 407
      return (cval_unknown_address);
      switch_default___1: /* CIL Label */ 
#line 409
      return (cval_unknown_number);
      switch_break___1: /* CIL Label */ ;
      }
    }
    {
#line 412
    tmp___15 = cval_uint_value(tosize_cval);
#line 412
    tosize = (size_t )tmp___15;
    }
    {
#line 415
    if ((unsigned int )c.kind == 5U) {
#line 415
      goto case_5___1;
    }
#line 433
    if ((unsigned int )c.kind == 4U) {
#line 433
      goto case_4___2;
    }
#line 433
    if ((unsigned int )c.kind == 3U) {
#line 433
      goto case_4___2;
    }
#line 433
    if ((unsigned int )c.kind == 2U) {
#line 433
      goto case_4___2;
    }
#line 441
    if ((unsigned int )c.kind == 9U) {
#line 441
      goto case_9___1;
    }
#line 441
    if ((unsigned int )c.kind == 7U) {
#line 441
      goto case_9___1;
    }
#line 459
    goto switch_default___2;
    case_5___1: /* CIL Label */ 
    {
#line 418
    tmp___16 = type_pointer(to);
    }
#line 418
    if (tmp___16) {
      {
#line 418
      __assert_fail("!type_pointer(to)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    418U, "cval_cast");
      }
    }
    {
#line 419
    tmp___17 = type_unsigned(to);
    }
#line 419
    if (tmp___17) {
#line 421
      c.kind = (enum __anonenum_kind_32 )7;
#line 422
      c.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )c.__annonCompField6.__annonCompField1.d;
#line 423
      c.__annonCompField6.__annonCompField5.isize = tosize;
    } else {
#line 427
      c.kind = (enum __anonenum_kind_32 )9;
#line 428
      c.__annonCompField6.__annonCompField5.__annonCompField2.si = (largest_int )c.__annonCompField6.__annonCompField1.d;
#line 429
      c.__annonCompField6.__annonCompField5.isize = tosize;
    }
#line 431
    return (c);
    case_4___2: /* CIL Label */ 
    case_3___2: /* CIL Label */ 
    case_2___2: /* CIL Label */ 
    {
#line 435
    tmp___18 = type_array(to);
    }
#line 435
    if (! tmp___18) {
      {
#line 435
      tmp___19 = type_size_int(intptr_type);
      }
#line 435
      if ((largest_uint )tosize < tmp___19) {
#line 436
        return (cval_top);
      }
    }
#line 439
    return (c);
    case_9___1: /* CIL Label */ 
    case_7___1: /* CIL Label */ 
    {
#line 442
    c.__annonCompField6.__annonCompField5.isize = tosize;
#line 443
    tmp___20 = type_unsigned(to);
    }
#line 443
    if (tmp___20) {
#line 443
      goto _L;
    } else {
      {
#line 443
      tmp___21 = type_pointer(to);
      }
#line 443
      if (tmp___21) {
        _L: /* CIL Label */ 
#line 445
        if ((unsigned int )c.kind == 9U) {
#line 446
          c.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )c.__annonCompField6.__annonCompField5.__annonCompField2.si;
        }
        {
#line 447
        c.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                       tosize);
#line 448
        c.kind = (enum __anonenum_kind_32 )7;
        }
      } else {
#line 452
        if ((unsigned int )c.kind == 7U) {
#line 453
          c.__annonCompField6.__annonCompField5.__annonCompField2.si = (largest_int )c.__annonCompField6.__annonCompField5.__annonCompField2.ui;
        }
        {
#line 454
        c.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                     tosize);
#line 455
        c.kind = (enum __anonenum_kind_32 )9;
        }
      }
    }
#line 457
    return (c);
    switch_default___2: /* CIL Label */ 
    {
#line 459
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 459U,
                  "cval_cast");
    }
#line 459
    return (c);
    switch_break___2: /* CIL Label */ ;
    }
  }
}
}
#line 464 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_not(cval c ) 
{ 
  bool tmp ;
  int tmp___0 ;
  cval tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 466
  if ((unsigned int )c.kind == 0U) {
#line 467
    return (cval_top);
  } else {
    {
#line 468
    tmp___3 = cval_isunknown(c);
    }
#line 468
    if (tmp___3) {
#line 469
      return (cval_unknown_number);
    } else {
      {
#line 470
      tmp___2 = cval_knownbool(c);
      }
#line 470
      if (tmp___2) {
        {
#line 473
        tmp = cval_boolvalue(c);
        }
#line 473
        if (tmp) {
#line 473
          tmp___0 = 0;
        } else {
#line 473
          tmp___0 = 1;
        }
        {
#line 473
        tmp___1 = make_cval_signed((largest_int )tmp___0, int_type);
        }
#line 473
        return (tmp___1);
      } else {
#line 471
        return (cval_top);
      }
    }
  }
}
}
#line 476 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_negate(cval c ) 
{ 


  {
  {
#line 480
  if ((unsigned int )c.kind == 0U) {
#line 480
    goto case_0;
  }
#line 481
  if ((unsigned int )c.kind == 1U) {
#line 481
    goto case_1;
  }
#line 482
  if ((unsigned int )c.kind == 3U) {
#line 482
    goto case_3;
  }
#line 482
  if ((unsigned int )c.kind == 2U) {
#line 482
    goto case_3;
  }
#line 482
  if ((unsigned int )c.kind == 4U) {
#line 482
    goto case_3;
  }
#line 484
  if ((unsigned int )c.kind == 9U) {
#line 484
    goto case_9;
  }
#line 485
  if ((unsigned int )c.kind == 7U) {
#line 485
    goto case_7;
  }
#line 486
  if ((unsigned int )c.kind == 5U) {
#line 486
    goto case_5;
  }
#line 487
  if ((unsigned int )c.kind == 10U) {
#line 487
    goto case_10;
  }
#line 491
  if ((unsigned int )c.kind == 8U) {
#line 491
    goto case_8;
  }
#line 495
  if ((unsigned int )c.kind == 6U) {
#line 495
    goto case_6;
  }
#line 496
  goto switch_default;
  case_0: /* CIL Label */ 
#line 480
  return (cval_top);
  case_1: /* CIL Label */ 
#line 481
  return (cval_unknown_number);
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 483
  return (cval_top);
  case_9: /* CIL Label */ 
#line 484
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = - c.__annonCompField6.__annonCompField5.__annonCompField2.si;
#line 484
  return (c);
  case_7: /* CIL Label */ 
  {
#line 485
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(- c.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                 c.__annonCompField6.__annonCompField5.isize);
  }
#line 485
  return (c);
  case_5: /* CIL Label */ 
#line 486
  c.__annonCompField6.__annonCompField1.d = - c.__annonCompField6.__annonCompField1.d;
#line 486
  return (c);
  case_10: /* CIL Label */ 
#line 488
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = - c.__annonCompField6.__annonCompField5.__annonCompField2.si;
#line 489
  c.__annonCompField6.__annonCompField5.__annonCompField4.si_i = - c.__annonCompField6.__annonCompField5.__annonCompField4.si_i;
#line 490
  return (c);
  case_8: /* CIL Label */ 
  {
#line 492
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(- c.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                 c.__annonCompField6.__annonCompField5.isize);
#line 493
  c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i = truncate_unsigned(- c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i,
                                                                                   c.__annonCompField6.__annonCompField5.isize);
  }
#line 494
  return (c);
  case_6: /* CIL Label */ 
#line 495
  c.__annonCompField6.__annonCompField1.d = - c.__annonCompField6.__annonCompField1.d;
#line 495
  c.__annonCompField6.__annonCompField1.d_i = - c.__annonCompField6.__annonCompField1.d_i;
#line 495
  return (c);
  switch_default: /* CIL Label */ 
  {
#line 496
  abort();
  }
#line 496
  return (cval_top);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 500 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_bitnot(cval c ) 
{ 


  {
  {
#line 504
  if ((unsigned int )c.kind == 0U) {
#line 504
    goto case_0;
  }
#line 505
  if ((unsigned int )c.kind == 1U) {
#line 505
    goto case_1;
  }
#line 506
  if ((unsigned int )c.kind == 3U) {
#line 506
    goto case_3;
  }
#line 506
  if ((unsigned int )c.kind == 2U) {
#line 506
    goto case_3;
  }
#line 506
  if ((unsigned int )c.kind == 4U) {
#line 506
    goto case_3;
  }
#line 508
  if ((unsigned int )c.kind == 9U) {
#line 508
    goto case_9;
  }
#line 509
  if ((unsigned int )c.kind == 7U) {
#line 509
    goto case_7;
  }
#line 510
  goto switch_default;
  case_0: /* CIL Label */ 
#line 504
  return (cval_top);
  case_1: /* CIL Label */ 
#line 505
  return (cval_unknown_number);
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 507
  return (cval_top);
  case_9: /* CIL Label */ 
  {
#line 508
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(~ c.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                               c.__annonCompField6.__annonCompField5.isize);
  }
#line 508
  return (c);
  case_7: /* CIL Label */ 
  {
#line 509
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(~ c.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                 c.__annonCompField6.__annonCompField5.isize);
  }
#line 509
  return (c);
  switch_default: /* CIL Label */ 
  {
#line 510
  abort();
  }
#line 510
  return (cval_top);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 514 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_conjugate(cval c ) 
{ 


  {
  {
#line 518
  if ((unsigned int )c.kind == 0U) {
#line 518
    goto case_0;
  }
#line 519
  if ((unsigned int )c.kind == 1U) {
#line 519
    goto case_1;
  }
#line 520
  if ((unsigned int )c.kind == 10U) {
#line 520
    goto case_10;
  }
#line 523
  if ((unsigned int )c.kind == 8U) {
#line 523
    goto case_8;
  }
#line 526
  if ((unsigned int )c.kind == 6U) {
#line 526
    goto case_6;
  }
#line 527
  goto switch_default;
  case_0: /* CIL Label */ 
#line 518
  return (cval_top);
  case_1: /* CIL Label */ 
#line 519
  return (cval_unknown_number);
  case_10: /* CIL Label */ 
#line 521
  c.__annonCompField6.__annonCompField5.__annonCompField4.si_i = - c.__annonCompField6.__annonCompField5.__annonCompField4.si_i;
#line 522
  return (c);
  case_8: /* CIL Label */ 
  {
#line 524
  c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i = truncate_unsigned(- c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i,
                                                                                   c.__annonCompField6.__annonCompField5.isize);
  }
#line 525
  return (c);
  case_6: /* CIL Label */ 
#line 526
  c.__annonCompField6.__annonCompField1.d_i = - c.__annonCompField6.__annonCompField1.d_i;
#line 526
  return (c);
  switch_default: /* CIL Label */ 
  {
#line 527
  abort();
  }
#line 527
  return (cval_top);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 531 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_realpart(cval c ) 
{ 


  {
  {
#line 535
  if ((unsigned int )c.kind == 0U) {
#line 535
    goto case_0;
  }
#line 536
  if ((unsigned int )c.kind == 1U) {
#line 536
    goto case_1;
  }
#line 537
  if ((unsigned int )c.kind == 10U) {
#line 537
    goto case_10;
  }
#line 538
  if ((unsigned int )c.kind == 8U) {
#line 538
    goto case_8;
  }
#line 539
  if ((unsigned int )c.kind == 6U) {
#line 539
    goto case_6;
  }
#line 540
  if ((unsigned int )c.kind == 5U) {
#line 540
    goto case_5;
  }
#line 540
  if ((unsigned int )c.kind == 7U) {
#line 540
    goto case_5;
  }
#line 540
  if ((unsigned int )c.kind == 9U) {
#line 540
    goto case_5;
  }
#line 541
  goto switch_default;
  case_0: /* CIL Label */ 
#line 535
  return (cval_top);
  case_1: /* CIL Label */ 
#line 536
  return (cval_unknown_number);
  case_10: /* CIL Label */ 
#line 537
  c.kind = (enum __anonenum_kind_32 )9;
#line 537
  return (c);
  case_8: /* CIL Label */ 
#line 538
  c.kind = (enum __anonenum_kind_32 )7;
#line 538
  return (c);
  case_6: /* CIL Label */ 
#line 539
  c.kind = (enum __anonenum_kind_32 )5;
#line 539
  return (c);
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 540
  return (c);
  switch_default: /* CIL Label */ 
  {
#line 541
  abort();
  }
#line 541
  return (cval_top);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 545 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_imagpart(cval c ) 
{ 


  {
  {
#line 549
  if ((unsigned int )c.kind == 0U) {
#line 549
    goto case_0;
  }
#line 550
  if ((unsigned int )c.kind == 1U) {
#line 550
    goto case_1;
  }
#line 551
  if ((unsigned int )c.kind == 10U) {
#line 551
    goto case_10;
  }
#line 552
  if ((unsigned int )c.kind == 8U) {
#line 552
    goto case_8;
  }
#line 553
  if ((unsigned int )c.kind == 6U) {
#line 553
    goto case_6;
  }
#line 554
  if ((unsigned int )c.kind == 9U) {
#line 554
    goto case_9;
  }
#line 555
  if ((unsigned int )c.kind == 7U) {
#line 555
    goto case_7;
  }
#line 556
  if ((unsigned int )c.kind == 5U) {
#line 556
    goto case_5;
  }
#line 557
  goto switch_default;
  case_0: /* CIL Label */ 
#line 549
  return (cval_top);
  case_1: /* CIL Label */ 
#line 550
  return (cval_unknown_number);
  case_10: /* CIL Label */ 
#line 551
  c.kind = (enum __anonenum_kind_32 )9;
#line 551
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = c.__annonCompField6.__annonCompField5.__annonCompField4.si_i;
#line 551
  return (c);
  case_8: /* CIL Label */ 
#line 552
  c.kind = (enum __anonenum_kind_32 )7;
#line 552
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i;
#line 552
  return (c);
  case_6: /* CIL Label */ 
#line 553
  c.kind = (enum __anonenum_kind_32 )5;
#line 553
  c.__annonCompField6.__annonCompField1.d = c.__annonCompField6.__annonCompField1.d_i;
#line 553
  return (c);
  case_9: /* CIL Label */ 
#line 554
  c.__annonCompField6.__annonCompField5.__annonCompField2.si = (largest_int )0;
#line 554
  return (c);
  case_7: /* CIL Label */ 
#line 555
  c.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )0;
#line 555
  return (c);
  case_5: /* CIL Label */ 
#line 556
  c.__annonCompField6.__annonCompField1.d = (long double )0;
#line 556
  return (c);
  switch_default: /* CIL Label */ 
  {
#line 557
  abort();
  }
#line 557
  return (cval_top);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 563 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_add(cval c1 , cval c2 ) 
{ 
  cval tmp ;
  bool tmp___0 ;
  cval tmp___1 ;
  bool tmp___2 ;

  {
#line 565
  if ((unsigned int )c1.kind == 0U) {
#line 566
    return (cval_top);
  } else
#line 565
  if ((unsigned int )c2.kind == 0U) {
#line 566
    return (cval_top);
  }
  {
#line 568
  tmp___0 = cval_isaddress(c2);
  }
#line 568
  if (tmp___0) {
#line 570
    tmp = c1;
#line 570
    c1 = c2;
#line 570
    c2 = tmp;
  }
  {
#line 573
  tmp___2 = cval_isaddress(c1);
  }
#line 573
  if (tmp___2) {
    {
#line 576
    if ((unsigned int )c2.kind == 1U) {
#line 576
      goto case_1;
    }
#line 577
    if ((unsigned int )c2.kind == 3U) {
#line 577
      goto case_3;
    }
#line 577
    if ((unsigned int )c2.kind == 2U) {
#line 577
      goto case_3;
    }
#line 577
    if ((unsigned int )c2.kind == 4U) {
#line 577
      goto case_3;
    }
#line 579
    if ((unsigned int )c2.kind == 9U) {
#line 579
      goto case_9;
    }
#line 580
    if ((unsigned int )c2.kind == 7U) {
#line 580
      goto case_7;
    }
#line 581
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 576
    tmp___1 = make_cval_address_unknown_offset(c1);
    }
#line 576
    return (tmp___1);
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 578
    return (cval_top);
    case_9: /* CIL Label */ 
    {
#line 579
    c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si + c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
    }
#line 579
    return (c1);
    case_7: /* CIL Label */ 
    {
#line 580
    c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed((largest_int )((largest_uint )c1.__annonCompField6.__annonCompField5.__annonCompField2.si + c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
    }
#line 580
    return (c1);
    switch_default: /* CIL Label */ 
    {
#line 581
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 581U,
                  "cval_add");
    }
#line 581
    return (c1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 584
  if ((unsigned int )c1.kind == 1U) {
#line 585
    return (cval_unknown_number);
  } else
#line 584
  if ((unsigned int )c2.kind == 1U) {
#line 585
    return (cval_unknown_number);
  }
  {
#line 589
  if ((unsigned int )c1.kind == 5U) {
#line 589
    goto case_5;
  }
#line 594
  if ((unsigned int )c1.kind == 9U) {
#line 594
    goto case_9___0;
  }
#line 599
  if ((unsigned int )c1.kind == 7U) {
#line 599
    goto case_7___0;
  }
#line 604
  if ((unsigned int )c1.kind == 6U) {
#line 604
    goto case_6;
  }
#line 610
  if ((unsigned int )c1.kind == 10U) {
#line 610
    goto case_10;
  }
#line 616
  if ((unsigned int )c1.kind == 8U) {
#line 616
    goto case_8;
  }
#line 622
  goto switch_default___0;
  case_5: /* CIL Label */ 
#line 590
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 590
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  590U, "cval_add");
    }
  }
#line 591
  c1.__annonCompField6.__annonCompField1.d += c2.__annonCompField6.__annonCompField1.d;
#line 592
  return (c1);
  case_9___0: /* CIL Label */ 
#line 595
  if ((unsigned int )c2.kind == 9U) {
#line 595
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 595
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    595U, "cval_add");
      }
    }
  } else {
    {
#line 595
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  595U, "cval_add");
    }
  }
  {
#line 596
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si + c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 597
  return (c1);
  case_7___0: /* CIL Label */ 
#line 600
  if ((unsigned int )c2.kind == 7U) {
#line 600
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 600
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    600U, "cval_add");
      }
    }
  } else {
    {
#line 600
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  600U, "cval_add");
    }
  }
  {
#line 601
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui + c2.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
  }
#line 602
  return (c1);
  case_6: /* CIL Label */ 
#line 605
  if (! ((unsigned int )c2.kind == 6U)) {
    {
#line 605
    __assert_fail("c2.kind == cval_float_complex", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  605U, "cval_add");
    }
  }
#line 606
  c1.__annonCompField6.__annonCompField1.d += c2.__annonCompField6.__annonCompField1.d;
#line 607
  c1.__annonCompField6.__annonCompField1.d_i += c2.__annonCompField6.__annonCompField1.d_i;
#line 608
  return (c1);
  case_10: /* CIL Label */ 
#line 611
  if ((unsigned int )c2.kind == 10U) {
#line 611
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 611
      __assert_fail("c2.kind == cval_sint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    611U, "cval_add");
      }
    }
  } else {
    {
#line 611
    __assert_fail("c2.kind == cval_sint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  611U, "cval_add");
    }
  }
  {
#line 612
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si + c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
#line 613
  c1.__annonCompField6.__annonCompField5.__annonCompField4.si_i = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField4.si_i + c2.__annonCompField6.__annonCompField5.__annonCompField4.si_i,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
  }
#line 614
  return (c1);
  case_8: /* CIL Label */ 
#line 617
  if ((unsigned int )c2.kind == 8U) {
#line 617
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 617
      __assert_fail("c2.kind == cval_uint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    617U, "cval_add");
      }
    }
  } else {
    {
#line 617
    __assert_fail("c2.kind == cval_uint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  617U, "cval_add");
    }
  }
  {
#line 618
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui + c2.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
#line 619
  c1.__annonCompField6.__annonCompField5.__annonCompField4.ui_i = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField4.ui_i + c2.__annonCompField6.__annonCompField5.__annonCompField4.ui_i,
                                                                                    c1.__annonCompField6.__annonCompField5.isize);
  }
#line 620
  return (c1);
  switch_default___0: /* CIL Label */ 
  {
#line 623
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 623U, "cval_add");
  }
#line 624
  return (c1);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 628 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_sub(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  cval tmp___1 ;
  bool tmp___2 ;

  {
#line 630
  if ((unsigned int )c1.kind == 0U) {
#line 631
    return (cval_top);
  } else
#line 630
  if ((unsigned int )c2.kind == 0U) {
#line 631
    return (cval_top);
  }
  {
#line 635
  tmp___0 = cval_isaddress(c2);
  }
#line 635
  if (tmp___0) {
    {
#line 637
    tmp = cval_isaddress(c1);
    }
#line 637
    if (tmp) {
#line 637
      if (! ((unsigned int )c1.kind == 2U)) {
#line 637
        if (! ((unsigned int )c2.kind == 2U)) {
#line 637
          if ((unsigned long )c1.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl == (unsigned long )c2.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl) {
#line 637
            if ((unsigned long )c1.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl == (unsigned long )c2.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl) {
#line 641
              if ((unsigned int )c1.kind == 3U) {
#line 643
                return (cval_unknown_number);
              } else
#line 641
              if ((unsigned int )c2.kind == 3U) {
#line 643
                return (cval_unknown_number);
              }
              {
#line 645
              c1.kind = (enum __anonenum_kind_32 )9;
#line 646
              c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                            c1.__annonCompField6.__annonCompField5.isize);
              }
#line 647
              return (c1);
            }
          }
        }
      }
    }
#line 649
    return (cval_top);
  }
  {
#line 652
  tmp___2 = cval_isaddress(c1);
  }
#line 652
  if (tmp___2) {
    {
#line 655
    if ((unsigned int )c2.kind == 1U) {
#line 655
      goto case_1;
    }
#line 656
    if ((unsigned int )c2.kind == 9U) {
#line 656
      goto case_9;
    }
#line 657
    if ((unsigned int )c2.kind == 7U) {
#line 657
      goto case_7;
    }
#line 658
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 655
    tmp___1 = make_cval_address_unknown_offset(c1);
    }
#line 655
    return (tmp___1);
    case_9: /* CIL Label */ 
    {
#line 656
    c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
    }
#line 656
    return (c1);
    case_7: /* CIL Label */ 
    {
#line 657
    c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed((largest_int )((largest_uint )c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
    }
#line 657
    return (c1);
    switch_default: /* CIL Label */ 
    {
#line 658
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 658U,
                  "cval_sub");
    }
#line 658
    return (c1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 661
  if ((unsigned int )c1.kind == 1U) {
#line 662
    return (cval_unknown_number);
  } else
#line 661
  if ((unsigned int )c2.kind == 1U) {
#line 662
    return (cval_unknown_number);
  }
  {
#line 666
  if ((unsigned int )c1.kind == 5U) {
#line 666
    goto case_5;
  }
#line 671
  if ((unsigned int )c1.kind == 9U) {
#line 671
    goto case_9___0;
  }
#line 676
  if ((unsigned int )c1.kind == 7U) {
#line 676
    goto case_7___0;
  }
#line 681
  if ((unsigned int )c1.kind == 6U) {
#line 681
    goto case_6;
  }
#line 687
  if ((unsigned int )c1.kind == 10U) {
#line 687
    goto case_10;
  }
#line 693
  if ((unsigned int )c1.kind == 8U) {
#line 693
    goto case_8;
  }
#line 699
  goto switch_default___0;
  case_5: /* CIL Label */ 
#line 667
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 667
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  667U, "cval_sub");
    }
  }
#line 668
  c1.__annonCompField6.__annonCompField1.d -= c2.__annonCompField6.__annonCompField1.d;
#line 669
  return (c1);
  case_9___0: /* CIL Label */ 
#line 672
  if ((unsigned int )c2.kind == 9U) {
#line 672
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 672
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    672U, "cval_sub");
      }
    }
  } else {
    {
#line 672
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  672U, "cval_sub");
    }
  }
  {
#line 673
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 674
  return (c1);
  case_7___0: /* CIL Label */ 
#line 677
  if ((unsigned int )c2.kind == 7U) {
#line 677
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 677
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    677U, "cval_sub");
      }
    }
  } else {
    {
#line 677
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  677U, "cval_sub");
    }
  }
  {
#line 678
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui - c2.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
  }
#line 679
  return (c1);
  case_6: /* CIL Label */ 
#line 682
  if (! ((unsigned int )c2.kind == 6U)) {
    {
#line 682
    __assert_fail("c2.kind == cval_float_complex", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  682U, "cval_sub");
    }
  }
#line 683
  c1.__annonCompField6.__annonCompField1.d -= c2.__annonCompField6.__annonCompField1.d;
#line 684
  c1.__annonCompField6.__annonCompField1.d_i -= c2.__annonCompField6.__annonCompField1.d_i;
#line 685
  return (c1);
  case_10: /* CIL Label */ 
#line 688
  if ((unsigned int )c2.kind == 10U) {
#line 688
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 688
      __assert_fail("c2.kind == cval_sint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    688U, "cval_sub");
      }
    }
  } else {
    {
#line 688
    __assert_fail("c2.kind == cval_sint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  688U, "cval_sub");
    }
  }
  {
#line 689
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
#line 690
  c1.__annonCompField6.__annonCompField5.__annonCompField4.si_i = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField4.si_i - c2.__annonCompField6.__annonCompField5.__annonCompField4.si_i,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
  }
#line 691
  return (c1);
  case_8: /* CIL Label */ 
#line 694
  if ((unsigned int )c2.kind == 8U) {
#line 694
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 694
      __assert_fail("c2.kind == cval_uint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    694U, "cval_sub");
      }
    }
  } else {
    {
#line 694
    __assert_fail("c2.kind == cval_uint_complex && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  694U, "cval_sub");
    }
  }
  {
#line 695
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui - c2.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
#line 696
  c1.__annonCompField6.__annonCompField5.__annonCompField4.ui_i = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField4.ui_i - c2.__annonCompField6.__annonCompField5.__annonCompField4.ui_i,
                                                                                    c1.__annonCompField6.__annonCompField5.isize);
  }
#line 697
  return (c1);
  switch_default___0: /* CIL Label */ 
  {
#line 700
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 700U, "cval_sub");
  }
#line 701
  return (c1);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 705 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_times(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  cval c1r ;
  cval tmp___3 ;
  cval c1i ;
  cval tmp___4 ;
  cval c2r ;
  cval tmp___5 ;
  cval c2i ;
  cval tmp___6 ;
  bool tmp___7 ;
  cval tmp___8 ;
  cval tmp___9 ;
  cval tmp___10 ;
  cval tmp___11 ;
  cval tmp___12 ;
  cval tmp___13 ;
  cval tmp___14 ;
  bool tmp___15 ;

  {
#line 707
  if ((unsigned int )c1.kind == 0U) {
#line 708
    return (cval_top);
  } else
#line 707
  if ((unsigned int )c2.kind == 0U) {
#line 708
    return (cval_top);
  }
  {
#line 712
  tmp___1 = cval_isaddress(c1);
  }
#line 712
  if (tmp___1) {
#line 712
    goto _L;
  } else {
    {
#line 712
    tmp___2 = cval_isaddress(c2);
    }
#line 712
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 714
      tmp = cval_isone(c1);
      }
#line 714
      if (tmp) {
#line 715
        return (c2);
      }
      {
#line 716
      tmp___0 = cval_isone(c2);
      }
#line 716
      if (tmp___0) {
#line 717
        return (c1);
      }
#line 718
      return (cval_top);
    }
  }
#line 721
  if ((unsigned int )c1.kind == 1U) {
#line 722
    return (cval_unknown_number);
  } else
#line 721
  if ((unsigned int )c2.kind == 1U) {
#line 722
    return (cval_unknown_number);
  }
  {
#line 724
  tmp___15 = cval_iscomplex(c1);
  }
#line 724
  if (tmp___15) {
    {
#line 726
    tmp___3 = cval_realpart(c1);
#line 726
    c1r = tmp___3;
#line 726
    tmp___4 = cval_imagpart(c1);
#line 726
    c1i = tmp___4;
#line 726
    tmp___5 = cval_realpart(c2);
#line 726
    c2r = tmp___5;
#line 726
    tmp___6 = cval_imagpart(c2);
#line 726
    c2i = tmp___6;
#line 729
    tmp___7 = cval_iscomplex(c2);
    }
#line 729
    if (! tmp___7) {
      {
#line 729
      __assert_fail("cval_iscomplex(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    729U, "cval_times");
      }
    }
    {
#line 733
    tmp___8 = cval_times(c1i, c2r);
#line 733
    tmp___9 = cval_times(c1r, c2i);
#line 733
    tmp___10 = cval_add(tmp___9, tmp___8);
#line 733
    tmp___11 = cval_times(c1i, c2i);
#line 733
    tmp___12 = cval_times(c1r, c2r);
#line 733
    tmp___13 = cval_sub(tmp___12, tmp___11);
#line 733
    tmp___14 = make_cval_complex(tmp___13, tmp___10);
    }
#line 733
    return (tmp___14);
  }
  {
#line 741
  if ((unsigned int )c1.kind == 5U) {
#line 741
    goto case_5;
  }
#line 746
  if ((unsigned int )c1.kind == 9U) {
#line 746
    goto case_9;
  }
#line 751
  if ((unsigned int )c1.kind == 7U) {
#line 751
    goto case_7;
  }
#line 756
  goto switch_default;
  case_5: /* CIL Label */ 
#line 742
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 742
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  742U, "cval_times");
    }
  }
#line 743
  c1.__annonCompField6.__annonCompField1.d *= c2.__annonCompField6.__annonCompField1.d;
#line 744
  return (c1);
  case_9: /* CIL Label */ 
#line 747
  if ((unsigned int )c2.kind == 9U) {
#line 747
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 747
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    747U, "cval_times");
      }
    }
  } else {
    {
#line 747
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  747U, "cval_times");
    }
  }
  {
#line 748
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si * c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 749
  return (c1);
  case_7: /* CIL Label */ 
#line 752
  if ((unsigned int )c2.kind == 7U) {
#line 752
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 752
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    752U, "cval_times");
      }
    }
  } else {
    {
#line 752
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  752U, "cval_times");
    }
  }
  {
#line 753
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = truncate_unsigned(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui * c2.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                                                                                  c1.__annonCompField6.__annonCompField5.isize);
  }
#line 754
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 757
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 757U, "cval_times");
  }
#line 758
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 762 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_divide(cval c1 , cval c2 ) 
{ 
  cval tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  cval c1r ;
  cval tmp___4 ;
  cval c1i ;
  cval tmp___5 ;
  cval c2r ;
  cval tmp___6 ;
  cval c2i ;
  cval tmp___7 ;
  cval mag ;
  cval tmp___8 ;
  cval tmp___9 ;
  cval tmp___10 ;
  bool tmp___11 ;
  cval tmp___12 ;
  cval tmp___13 ;
  cval tmp___14 ;
  cval tmp___15 ;
  cval tmp___16 ;
  cval tmp___17 ;
  cval tmp___18 ;
  cval tmp___19 ;
  cval tmp___20 ;
  bool tmp___21 ;

  {
#line 764
  if ((unsigned int )c1.kind == 0U) {
#line 765
    return (cval_top);
  } else
#line 764
  if ((unsigned int )c2.kind == 0U) {
#line 765
    return (cval_top);
  }
  {
#line 768
  tmp___2 = cval_isaddress(c1);
  }
#line 768
  if (tmp___2) {
#line 768
    goto _L;
  } else {
    {
#line 768
    tmp___3 = cval_isaddress(c2);
    }
#line 768
    if (tmp___3) {
      _L: /* CIL Label */ 
      {
#line 769
      tmp___1 = cval_isone(c2);
      }
#line 769
      if (tmp___1) {
#line 769
        tmp___0 = c1;
      } else {
#line 769
        tmp___0 = cval_top;
      }
#line 769
      return (tmp___0);
    }
  }
#line 771
  if ((unsigned int )c1.kind == 1U) {
#line 772
    return (cval_unknown_number);
  } else
#line 771
  if ((unsigned int )c2.kind == 1U) {
#line 772
    return (cval_unknown_number);
  }
  {
#line 774
  tmp___21 = cval_iscomplex(c1);
  }
#line 774
  if (tmp___21) {
    {
#line 776
    tmp___4 = cval_realpart(c1);
#line 776
    c1r = tmp___4;
#line 776
    tmp___5 = cval_imagpart(c1);
#line 776
    c1i = tmp___5;
#line 776
    tmp___6 = cval_realpart(c2);
#line 776
    c2r = tmp___6;
#line 776
    tmp___7 = cval_imagpart(c2);
#line 776
    c2i = tmp___7;
#line 778
    tmp___8 = cval_times(c1i, c2i);
#line 778
    tmp___9 = cval_times(c1r, c2r);
#line 778
    tmp___10 = cval_add(tmp___9, tmp___8);
#line 778
    mag = tmp___10;
#line 780
    tmp___11 = cval_iscomplex(c2);
    }
#line 780
    if (! tmp___11) {
      {
#line 780
      __assert_fail("cval_iscomplex(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    780U, "cval_divide");
      }
    }
    {
#line 784
    tmp___12 = cval_times(c1r, c2i);
#line 784
    tmp___13 = cval_times(c1i, c2r);
#line 784
    tmp___14 = cval_sub(tmp___13, tmp___12);
#line 784
    tmp___15 = cval_divide(tmp___14, mag);
#line 784
    tmp___16 = cval_times(c1i, c2i);
#line 784
    tmp___17 = cval_times(c1r, c2r);
#line 784
    tmp___18 = cval_add(tmp___17, tmp___16);
#line 784
    tmp___19 = cval_divide(tmp___18, mag);
#line 784
    tmp___20 = make_cval_complex(tmp___19, tmp___15);
    }
#line 784
    return (tmp___20);
  }
  {
#line 794
  if ((unsigned int )c1.kind == 5U) {
#line 794
    goto case_5;
  }
#line 799
  if ((unsigned int )c1.kind == 9U) {
#line 799
    goto case_9;
  }
#line 807
  if ((unsigned int )c1.kind == 7U) {
#line 807
    goto case_7;
  }
#line 814
  goto switch_default;
  case_5: /* CIL Label */ 
#line 795
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 795
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  795U, "cval_divide");
    }
  }
#line 796
  c1.__annonCompField6.__annonCompField1.d /= c2.__annonCompField6.__annonCompField1.d;
#line 797
  return (c1);
  case_9: /* CIL Label */ 
#line 800
  if ((unsigned int )c2.kind == 9U) {
#line 800
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 800
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    800U, "cval_divide");
      }
    }
  } else {
    {
#line 800
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  800U, "cval_divide");
    }
  }
#line 801
  if (c2.__annonCompField6.__annonCompField5.__annonCompField2.si == 0LL) {
#line 802
    return (cval_top);
  }
  {
#line 804
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si / c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 805
  return (c1);
  case_7: /* CIL Label */ 
#line 808
  if ((unsigned int )c2.kind == 7U) {
#line 808
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 808
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    808U, "cval_divide");
      }
    }
  } else {
    {
#line 808
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  808U, "cval_divide");
    }
  }
#line 809
  if (c2.__annonCompField6.__annonCompField5.__annonCompField2.ui == 0ULL) {
#line 810
    return (cval_top);
  }
#line 811
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui /= c2.__annonCompField6.__annonCompField5.__annonCompField2.ui;
#line 812
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 815
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 815U, "cval_divide");
  }
#line 816
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 820 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_modulo(cval c1 , cval c2 ) 
{ 
  cval tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 822
  if ((unsigned int )c1.kind == 0U) {
#line 823
    return (cval_top);
  } else
#line 822
  if ((unsigned int )c2.kind == 0U) {
#line 823
    return (cval_top);
  }
  {
#line 825
  tmp___0 = cval_isone(c2);
  }
#line 825
  if (tmp___0) {
    {
#line 826
    tmp = make_cval_signed((largest_int )0, int_type);
    }
#line 826
    return (tmp);
  }
  {
#line 828
  tmp___1 = cval_isaddress(c1);
  }
#line 828
  if (tmp___1) {
#line 829
    return (cval_top);
  } else {
    {
#line 828
    tmp___2 = cval_isaddress(c2);
    }
#line 828
    if (tmp___2) {
#line 829
      return (cval_top);
    }
  }
#line 831
  if ((unsigned int )c1.kind == 1U) {
#line 832
    return (cval_unknown_number);
  } else
#line 831
  if ((unsigned int )c2.kind == 1U) {
#line 832
    return (cval_unknown_number);
  }
  {
#line 836
  if ((unsigned int )c1.kind == 5U) {
#line 836
    goto case_5;
  }
#line 841
  if ((unsigned int )c1.kind == 9U) {
#line 841
    goto case_9;
  }
#line 848
  if ((unsigned int )c1.kind == 7U) {
#line 848
    goto case_7;
  }
#line 855
  goto switch_default;
  case_5: /* CIL Label */ 
#line 837
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 837
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  837U, "cval_modulo");
    }
  }
#line 838
  c1.__annonCompField6.__annonCompField1.d /= c2.__annonCompField6.__annonCompField1.d;
#line 839
  return (c1);
  case_9: /* CIL Label */ 
#line 842
  if ((unsigned int )c2.kind == 9U) {
#line 842
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 842
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    842U, "cval_modulo");
      }
    }
  } else {
    {
#line 842
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  842U, "cval_modulo");
    }
  }
#line 843
  if (c2.__annonCompField6.__annonCompField5.__annonCompField2.si == 0LL) {
#line 844
    return (cval_top);
  }
  {
#line 845
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si % c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 846
  return (c1);
  case_7: /* CIL Label */ 
#line 849
  if ((unsigned int )c2.kind == 7U) {
#line 849
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 849
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    849U, "cval_modulo");
      }
    }
  } else {
    {
#line 849
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  849U, "cval_modulo");
    }
  }
#line 850
  if (c2.__annonCompField6.__annonCompField5.__annonCompField2.ui == 0ULL) {
#line 851
    return (cval_top);
  }
#line 852
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui %= c2.__annonCompField6.__annonCompField5.__annonCompField2.ui;
#line 853
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 856
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 856U, "cval_modulo");
  }
#line 857
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 888 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_lshift(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  largest_int tmp___1 ;

  {
#line 888
  if ((unsigned int )c1.kind == 0U) {
#line 888
    return (cval_top);
  } else
#line 888
  if ((unsigned int )c2.kind == 0U) {
#line 888
    return (cval_top);
  }
  {
#line 888
  tmp = cval_isaddress(c1);
  }
#line 888
  if (tmp) {
#line 888
    return (cval_top);
  } else {
    {
#line 888
    tmp___0 = cval_isaddress(c2);
    }
#line 888
    if (tmp___0) {
#line 888
      return (cval_top);
    }
  }
#line 888
  if ((unsigned int )c1.kind == 1U) {
#line 888
    return (cval_unknown_number);
  } else
#line 888
  if ((unsigned int )c2.kind == 1U) {
#line 888
    return (cval_unknown_number);
  }
#line 888
  if ((unsigned int )c1.kind == (unsigned int )c2.kind) {
#line 888
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 888
      __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    888U, "cval_lshift");
      }
    }
  } else {
    {
#line 888
    __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  888U, "cval_lshift");
    }
  }
  {
#line 888
  if ((unsigned int )c1.kind == 9U) {
#line 888
    goto case_9;
  }
#line 888
  if ((unsigned int )c1.kind == 7U) {
#line 888
    goto case_7;
  }
#line 888
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 888
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si << c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 888
  return (c1);
  case_7: /* CIL Label */ 
  {
#line 888
  tmp___1 = truncate_signed((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui << c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                            c1.__annonCompField6.__annonCompField5.isize);
#line 888
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )tmp___1;
  }
#line 888
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 888
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 888U, "cval_lshift");
  }
#line 888
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 889 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_rshift(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  largest_int tmp___1 ;

  {
#line 889
  if ((unsigned int )c1.kind == 0U) {
#line 889
    return (cval_top);
  } else
#line 889
  if ((unsigned int )c2.kind == 0U) {
#line 889
    return (cval_top);
  }
  {
#line 889
  tmp = cval_isaddress(c1);
  }
#line 889
  if (tmp) {
#line 889
    return (cval_top);
  } else {
    {
#line 889
    tmp___0 = cval_isaddress(c2);
    }
#line 889
    if (tmp___0) {
#line 889
      return (cval_top);
    }
  }
#line 889
  if ((unsigned int )c1.kind == 1U) {
#line 889
    return (cval_unknown_number);
  } else
#line 889
  if ((unsigned int )c2.kind == 1U) {
#line 889
    return (cval_unknown_number);
  }
#line 889
  if ((unsigned int )c1.kind == (unsigned int )c2.kind) {
#line 889
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 889
      __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    889U, "cval_rshift");
      }
    }
  } else {
    {
#line 889
    __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  889U, "cval_rshift");
    }
  }
  {
#line 889
  if ((unsigned int )c1.kind == 9U) {
#line 889
    goto case_9;
  }
#line 889
  if ((unsigned int )c1.kind == 7U) {
#line 889
    goto case_7;
  }
#line 889
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 889
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si >> c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 889
  return (c1);
  case_7: /* CIL Label */ 
  {
#line 889
  tmp___1 = truncate_signed((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui >> c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                            c1.__annonCompField6.__annonCompField5.isize);
#line 889
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )tmp___1;
  }
#line 889
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 889
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 889U, "cval_rshift");
  }
#line 889
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 890 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_bitand(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  largest_int tmp___1 ;

  {
#line 890
  if ((unsigned int )c1.kind == 0U) {
#line 890
    return (cval_top);
  } else
#line 890
  if ((unsigned int )c2.kind == 0U) {
#line 890
    return (cval_top);
  }
  {
#line 890
  tmp = cval_isaddress(c1);
  }
#line 890
  if (tmp) {
#line 890
    return (cval_top);
  } else {
    {
#line 890
    tmp___0 = cval_isaddress(c2);
    }
#line 890
    if (tmp___0) {
#line 890
      return (cval_top);
    }
  }
#line 890
  if ((unsigned int )c1.kind == 1U) {
#line 890
    return (cval_unknown_number);
  } else
#line 890
  if ((unsigned int )c2.kind == 1U) {
#line 890
    return (cval_unknown_number);
  }
#line 890
  if ((unsigned int )c1.kind == (unsigned int )c2.kind) {
#line 890
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 890
      __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    890U, "cval_bitand");
      }
    }
  } else {
    {
#line 890
    __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  890U, "cval_bitand");
    }
  }
  {
#line 890
  if ((unsigned int )c1.kind == 9U) {
#line 890
    goto case_9;
  }
#line 890
  if ((unsigned int )c1.kind == 7U) {
#line 890
    goto case_7;
  }
#line 890
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 890
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si & c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 890
  return (c1);
  case_7: /* CIL Label */ 
  {
#line 890
  tmp___1 = truncate_signed((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui & c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                            c1.__annonCompField6.__annonCompField5.isize);
#line 890
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )tmp___1;
  }
#line 890
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 890
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 890U, "cval_bitand");
  }
#line 890
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 891 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_bitor(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  largest_int tmp___1 ;

  {
#line 891
  if ((unsigned int )c1.kind == 0U) {
#line 891
    return (cval_top);
  } else
#line 891
  if ((unsigned int )c2.kind == 0U) {
#line 891
    return (cval_top);
  }
  {
#line 891
  tmp = cval_isaddress(c1);
  }
#line 891
  if (tmp) {
#line 891
    return (cval_top);
  } else {
    {
#line 891
    tmp___0 = cval_isaddress(c2);
    }
#line 891
    if (tmp___0) {
#line 891
      return (cval_top);
    }
  }
#line 891
  if ((unsigned int )c1.kind == 1U) {
#line 891
    return (cval_unknown_number);
  } else
#line 891
  if ((unsigned int )c2.kind == 1U) {
#line 891
    return (cval_unknown_number);
  }
#line 891
  if ((unsigned int )c1.kind == (unsigned int )c2.kind) {
#line 891
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 891
      __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    891U, "cval_bitor");
      }
    }
  } else {
    {
#line 891
    __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  891U, "cval_bitor");
    }
  }
  {
#line 891
  if ((unsigned int )c1.kind == 9U) {
#line 891
    goto case_9;
  }
#line 891
  if ((unsigned int )c1.kind == 7U) {
#line 891
    goto case_7;
  }
#line 891
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 891
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si | c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 891
  return (c1);
  case_7: /* CIL Label */ 
  {
#line 891
  tmp___1 = truncate_signed((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui | c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                            c1.__annonCompField6.__annonCompField5.isize);
#line 891
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )tmp___1;
  }
#line 891
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 891
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 891U, "cval_bitor");
  }
#line 891
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 892 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_bitxor(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  largest_int tmp___1 ;

  {
#line 892
  if ((unsigned int )c1.kind == 0U) {
#line 892
    return (cval_top);
  } else
#line 892
  if ((unsigned int )c2.kind == 0U) {
#line 892
    return (cval_top);
  }
  {
#line 892
  tmp = cval_isaddress(c1);
  }
#line 892
  if (tmp) {
#line 892
    return (cval_top);
  } else {
    {
#line 892
    tmp___0 = cval_isaddress(c2);
    }
#line 892
    if (tmp___0) {
#line 892
      return (cval_top);
    }
  }
#line 892
  if ((unsigned int )c1.kind == 1U) {
#line 892
    return (cval_unknown_number);
  } else
#line 892
  if ((unsigned int )c2.kind == 1U) {
#line 892
    return (cval_unknown_number);
  }
#line 892
  if ((unsigned int )c1.kind == (unsigned int )c2.kind) {
#line 892
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 892
      __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    892U, "cval_bitxor");
      }
    }
  } else {
    {
#line 892
    __assert_fail("c1.kind == c2.kind && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  892U, "cval_bitxor");
    }
  }
  {
#line 892
  if ((unsigned int )c1.kind == 9U) {
#line 892
    goto case_9;
  }
#line 892
  if ((unsigned int )c1.kind == 7U) {
#line 892
    goto case_7;
  }
#line 892
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 892
  c1.__annonCompField6.__annonCompField5.__annonCompField2.si = truncate_signed(c1.__annonCompField6.__annonCompField5.__annonCompField2.si ^ c2.__annonCompField6.__annonCompField5.__annonCompField2.si,
                                                                                c1.__annonCompField6.__annonCompField5.isize);
  }
#line 892
  return (c1);
  case_7: /* CIL Label */ 
  {
#line 892
  tmp___1 = truncate_signed((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui ^ c2.__annonCompField6.__annonCompField5.__annonCompField2.ui),
                            c1.__annonCompField6.__annonCompField5.isize);
#line 892
  c1.__annonCompField6.__annonCompField5.__annonCompField2.ui = (largest_uint )tmp___1;
  }
#line 892
  return (c1);
  switch_default: /* CIL Label */ 
  {
#line 892
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 892U, "cval_bitxor");
  }
#line 892
  return (c1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 932 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
static cval cval_simpleeq(cval c1 , cval c2 ) 
{ 
  bool res ;
  bool tmp ;
  bool tmp___0 ;
  cval tmp___1 ;

  {
#line 932
  if ((unsigned int )c1.kind == 0U) {
#line 932
    return (cval_top);
  } else
#line 932
  if ((unsigned int )c2.kind == 0U) {
#line 932
    return (cval_top);
  }
  {
#line 932
  tmp = cval_isaddress(c1);
  }
#line 932
  if (tmp) {
#line 932
    return (cval_top);
  } else {
    {
#line 932
    tmp___0 = cval_isaddress(c2);
    }
#line 932
    if (tmp___0) {
#line 932
      return (cval_top);
    }
  }
#line 932
  if ((unsigned int )c1.kind == 1U) {
#line 932
    return (cval_unknown_number);
  } else
#line 932
  if ((unsigned int )c2.kind == 1U) {
#line 932
    return (cval_unknown_number);
  }
  {
#line 932
  if ((unsigned int )c1.kind == 5U) {
#line 932
    goto case_5;
  }
#line 932
  if ((unsigned int )c1.kind == 9U) {
#line 932
    goto case_9;
  }
#line 932
  if ((unsigned int )c1.kind == 7U) {
#line 932
    goto case_7;
  }
#line 932
  goto switch_default;
  case_5: /* CIL Label */ 
#line 932
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 932
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  932U, "cval_simpleeq");
    }
  }
#line 932
  res = (bool )(c1.__annonCompField6.__annonCompField1.d == c2.__annonCompField6.__annonCompField1.d);
#line 932
  goto switch_break;
  case_9: /* CIL Label */ 
#line 932
  if ((unsigned int )c2.kind == 9U) {
#line 932
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 932
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    932U, "cval_simpleeq");
      }
    }
  } else {
    {
#line 932
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  932U, "cval_simpleeq");
    }
  }
#line 932
  res = (bool )(c1.__annonCompField6.__annonCompField5.__annonCompField2.si == c2.__annonCompField6.__annonCompField5.__annonCompField2.si);
#line 932
  goto switch_break;
  case_7: /* CIL Label */ 
#line 932
  if ((unsigned int )c2.kind == 7U) {
#line 932
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 932
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    932U, "cval_simpleeq");
      }
    }
  } else {
    {
#line 932
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  932U, "cval_simpleeq");
    }
  }
#line 932
  res = (bool )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui == c2.__annonCompField6.__annonCompField5.__annonCompField2.ui);
#line 932
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 932
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 932U, "cval_simpleeq");
#line 932
  res = (bool )0;
  }
#line 932
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 932
  tmp___1 = make_cval_signed((largest_int )res, int_type);
  }
#line 932
  return (tmp___1);
}
}
#line 933 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_leq(cval c1 , cval c2 ) 
{ 
  bool res ;
  bool tmp ;
  bool tmp___0 ;
  cval tmp___1 ;

  {
#line 933
  if ((unsigned int )c1.kind == 0U) {
#line 933
    return (cval_top);
  } else
#line 933
  if ((unsigned int )c2.kind == 0U) {
#line 933
    return (cval_top);
  }
  {
#line 933
  tmp = cval_isaddress(c1);
  }
#line 933
  if (tmp) {
#line 933
    return (cval_top);
  } else {
    {
#line 933
    tmp___0 = cval_isaddress(c2);
    }
#line 933
    if (tmp___0) {
#line 933
      return (cval_top);
    }
  }
#line 933
  if ((unsigned int )c1.kind == 1U) {
#line 933
    return (cval_unknown_number);
  } else
#line 933
  if ((unsigned int )c2.kind == 1U) {
#line 933
    return (cval_unknown_number);
  }
  {
#line 933
  if ((unsigned int )c1.kind == 5U) {
#line 933
    goto case_5;
  }
#line 933
  if ((unsigned int )c1.kind == 9U) {
#line 933
    goto case_9;
  }
#line 933
  if ((unsigned int )c1.kind == 7U) {
#line 933
    goto case_7;
  }
#line 933
  goto switch_default;
  case_5: /* CIL Label */ 
#line 933
  if (! ((unsigned int )c2.kind == 5U)) {
    {
#line 933
    __assert_fail("c2.kind == cval_float", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  933U, "cval_leq");
    }
  }
#line 933
  res = (bool )(c1.__annonCompField6.__annonCompField1.d <= c2.__annonCompField6.__annonCompField1.d);
#line 933
  goto switch_break;
  case_9: /* CIL Label */ 
#line 933
  if ((unsigned int )c2.kind == 9U) {
#line 933
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 933
      __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    933U, "cval_leq");
      }
    }
  } else {
    {
#line 933
    __assert_fail("c2.kind == cval_sint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  933U, "cval_leq");
    }
  }
#line 933
  res = (bool )(c1.__annonCompField6.__annonCompField5.__annonCompField2.si <= c2.__annonCompField6.__annonCompField5.__annonCompField2.si);
#line 933
  goto switch_break;
  case_7: /* CIL Label */ 
#line 933
  if ((unsigned int )c2.kind == 7U) {
#line 933
    if (! (c1.__annonCompField6.__annonCompField5.isize == c2.__annonCompField6.__annonCompField5.isize)) {
      {
#line 933
      __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    933U, "cval_leq");
      }
    }
  } else {
    {
#line 933
    __assert_fail("c2.kind == cval_uint && c1.isize == c2.isize", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  933U, "cval_leq");
    }
  }
#line 933
  res = (bool )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui <= c2.__annonCompField6.__annonCompField5.__annonCompField2.ui);
#line 933
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 933
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 933U, "cval_leq");
#line 933
  res = (bool )0;
  }
#line 933
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 933
  tmp___1 = make_cval_signed((largest_int )res, int_type);
  }
#line 933
  return (tmp___1);
}
}
#line 935 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_eq(cval c1 , cval c2 ) 
{ 
  cval req ;
  cval tmp ;
  cval tmp___0 ;
  cval tmp___1 ;
  cval ieq ;
  cval tmp___2 ;
  cval tmp___3 ;
  cval tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  cval tmp___8 ;
  cval tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;

  {
  {
#line 937
  tmp___10 = cval_iscomplex(c1);
  }
#line 937
  if (tmp___10) {
    {
#line 937
    tmp___11 = cval_iscomplex(c2);
    }
#line 937
    if (tmp___11) {
      {
#line 939
      tmp = cval_realpart(c2);
#line 939
      tmp___0 = cval_realpart(c1);
#line 939
      tmp___1 = cval_simpleeq(tmp___0, tmp);
#line 939
      req = tmp___1;
#line 940
      tmp___2 = cval_imagpart(c2);
#line 940
      tmp___3 = cval_imagpart(c1);
#line 940
      tmp___4 = cval_simpleeq(tmp___3, tmp___2);
#line 940
      ieq = tmp___4;
#line 942
      tmp___5 = cval_isone(req);
      }
#line 942
      if (tmp___5) {
        {
#line 942
        tmp___6 = cval_isone(ieq);
        }
#line 942
        if (tmp___6) {
#line 942
          tmp___7 = 1;
        } else {
#line 942
          tmp___7 = 0;
        }
      } else {
#line 942
        tmp___7 = 0;
      }
      {
#line 942
      tmp___8 = make_cval_signed((largest_int )tmp___7, int_type);
      }
#line 942
      return (tmp___8);
    } else {
      {
#line 945
      tmp___9 = cval_simpleeq(c1, c2);
      }
#line 945
      return (tmp___9);
    }
  } else {
    {
#line 945
    tmp___9 = cval_simpleeq(c1, c2);
    }
#line 945
    return (tmp___9);
  }
}
}
#line 949 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool uint_inrange(largest_uint x , type t ) 
{ 
  size_t tsize ;
  largest_uint tmp ;
  largest_uint max ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 951
  tmp = type_size_int(t);
#line 951
  tsize = (size_t )tmp;
  }
#line 954
  if (! (tsize <= sizeof(largest_uint ))) {
    {
#line 954
    __assert_fail("tsize <= sizeof(largest_uint)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  954U, "uint_inrange");
    }
  }
#line 956
  if (tsize == sizeof(largest_uint )) {
    {
#line 956
    tmp___0 = type_unsigned(t);
    }
#line 956
    if (tmp___0) {
#line 957
      return ((bool )1);
    }
  }
  {
#line 959
  tmp___1 = type_unsigned(t);
  }
#line 959
  if (tmp___1) {
#line 959
    tmp___2 = 0;
  } else {
#line 959
    tmp___2 = 1;
  }
#line 959
  max = 1ULL << (8UL * tsize - (size_t )tmp___2);
#line 961
  return ((bool )(x < max));
}
}
#line 964 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool sint_inrange(largest_int x , type t ) 
{ 
  size_t tsize ;
  largest_uint tmp ;
  largest_int max ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 966
  tmp = type_size_int(t);
#line 966
  tsize = (size_t )tmp;
  }
#line 969
  if (! (tsize <= sizeof(largest_uint ))) {
    {
#line 969
    __assert_fail("tsize <= sizeof(largest_uint)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  969U, "sint_inrange");
    }
  }
#line 971
  if (x < 0LL) {
    {
#line 971
    tmp___0 = type_unsigned(t);
    }
#line 971
    if (tmp___0) {
#line 972
      return ((bool )0);
    }
  }
#line 974
  if (tsize == sizeof(largest_uint )) {
#line 975
    return ((bool )1);
  }
  {
#line 977
  tmp___1 = type_unsigned(t);
  }
#line 977
  if (tmp___1) {
#line 977
    tmp___2 = 0;
  } else {
#line 977
    tmp___2 = 1;
  }
#line 977
  max = 1LL << (8UL * tsize - (size_t )tmp___2);
#line 980
  if (x >= - max) {
#line 980
    if (x < max) {
#line 980
      tmp___3 = 1;
    } else {
#line 980
      tmp___3 = 0;
    }
  } else {
#line 980
    tmp___3 = 0;
  }
#line 980
  return ((bool )tmp___3);
}
}
#line 983 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
bool cval_inrange(cval c , type t ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 989
  if ((unsigned int )c.kind == 9U) {
#line 989
    goto case_9;
  }
#line 990
  if ((unsigned int )c.kind == 7U) {
#line 990
    goto case_7;
  }
#line 991
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 989
  tmp = sint_inrange(c.__annonCompField6.__annonCompField5.__annonCompField2.si, t);
  }
#line 989
  return (tmp);
  case_7: /* CIL Label */ 
  {
#line 990
  tmp___0 = uint_inrange(c.__annonCompField6.__annonCompField5.__annonCompField2.ui,
                         t);
  }
#line 990
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 991
  abort();
  }
#line 991
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 995 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
largest_int cval_intcompare(cval c1 , cval c2 ) 
{ 


  {
  {
#line 1003
  if ((unsigned int )c1.kind == 9U) {
#line 1003
    goto case_9;
  }
#line 1015
  if ((unsigned int )c1.kind == 7U) {
#line 1015
    goto case_7___0;
  }
#line 1033
  goto switch_default___1;
  case_9: /* CIL Label */ 
  {
#line 1006
  if ((unsigned int )c2.kind == 9U) {
#line 1006
    goto case_9___0;
  }
#line 1008
  if ((unsigned int )c2.kind == 7U) {
#line 1008
    goto case_7;
  }
#line 1013
  goto switch_default;
  case_9___0: /* CIL Label */ 
#line 1007
  return (c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.si);
  case_7: /* CIL Label */ 
#line 1010
  if (c1.__annonCompField6.__annonCompField5.__annonCompField2.si < 0LL) {
#line 1011
    return ((largest_int )-1);
  } else
#line 1010
  if ((largest_uint )c1.__annonCompField6.__annonCompField5.__annonCompField2.si < c2.__annonCompField6.__annonCompField5.__annonCompField2.ui) {
#line 1011
    return ((largest_int )-1);
  }
#line 1012
  return ((largest_int )((largest_uint )c1.__annonCompField6.__annonCompField5.__annonCompField2.si - c2.__annonCompField6.__annonCompField5.__annonCompField2.ui));
  switch_default: /* CIL Label */ 
  {
#line 1013
  abort();
  }
#line 1013
  return ((largest_int )0);
  switch_break___0: /* CIL Label */ ;
  }
  case_7___0: /* CIL Label */ 
  {
#line 1018
  if ((unsigned int )c2.kind == 9U) {
#line 1018
    goto case_9___1;
  }
#line 1023
  if ((unsigned int )c2.kind == 7U) {
#line 1023
    goto case_7___1;
  }
#line 1031
  goto switch_default___0;
  case_9___1: /* CIL Label */ 
#line 1019
  if (c2.__annonCompField6.__annonCompField5.__annonCompField2.si < 0LL) {
#line 1020
    return ((largest_int )1);
  } else
#line 1019
  if (c1.__annonCompField6.__annonCompField5.__annonCompField2.ui < (largest_uint )c2.__annonCompField6.__annonCompField5.__annonCompField2.si) {
#line 1020
    return ((largest_int )1);
  }
#line 1022
  return ((largest_int )(c1.__annonCompField6.__annonCompField5.__annonCompField2.ui - (largest_uint )c2.__annonCompField6.__annonCompField5.__annonCompField2.si > 0ULL));
  case_7___1: /* CIL Label */ 
#line 1026
  if (c1.__annonCompField6.__annonCompField5.__annonCompField2.ui < c2.__annonCompField6.__annonCompField5.__annonCompField2.ui) {
#line 1027
    return ((largest_int )-1);
  }
#line 1028
  if (c1.__annonCompField6.__annonCompField5.__annonCompField2.ui > c2.__annonCompField6.__annonCompField5.__annonCompField2.ui) {
#line 1029
    return ((largest_int )1);
  }
#line 1030
  return ((largest_int )0);
  switch_default___0: /* CIL Label */ 
  {
#line 1031
  abort();
  }
#line 1031
  return ((largest_int )0);
  switch_break___1: /* CIL Label */ ;
  }
  switch_default___1: /* CIL Label */ 
  {
#line 1033
  abort();
  }
#line 1033
  return ((largest_int )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1037 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
void cval_print(FILE *f , cval c ) 
{ 


  {
  {
#line 1044
  if ((unsigned int )c.kind == 6U) {
#line 1044
    goto case_6;
  }
#line 1044
  if ((unsigned int )c.kind == 5U) {
#line 1044
    goto case_6;
  }
#line 1046
  if ((unsigned int )c.kind == 7U) {
#line 1046
    goto case_7;
  }
#line 1047
  if ((unsigned int )c.kind == 8U) {
#line 1047
    goto case_8;
  }
#line 1048
  if ((unsigned int )c.kind == 9U) {
#line 1048
    goto case_9;
  }
#line 1049
  if ((unsigned int )c.kind == 10U) {
#line 1049
    goto case_10;
  }
#line 1050
  goto switch_default;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1045
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1046
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%llu", c.__annonCompField6.__annonCompField5.__annonCompField2.ui);
  }
#line 1046
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1047
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%llu %llu",
          c.__annonCompField6.__annonCompField5.__annonCompField2.ui, c.__annonCompField6.__annonCompField5.__annonCompField4.ui_i);
  }
#line 1047
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1048
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lld", c.__annonCompField6.__annonCompField5.__annonCompField2.si);
  }
#line 1048
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1049
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lld %lld",
          c.__annonCompField6.__annonCompField5.__annonCompField2.si, c.__annonCompField6.__annonCompField5.__annonCompField4.si_i);
  }
#line 1049
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1050
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c", 1050U, "cval_print");
  }
#line 1050
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1052
  return;
}
}
#line 1054 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
void cval_debug(cval c ) 
{ 


  {
  {
#line 1059
  if ((unsigned int )c.kind == 0U) {
#line 1059
    goto case_0;
  }
#line 1060
  if ((unsigned int )c.kind == 1U) {
#line 1060
    goto case_1;
  }
#line 1061
  if ((unsigned int )c.kind == 2U) {
#line 1061
    goto case_2;
  }
#line 1062
  if ((unsigned int )c.kind == 3U) {
#line 1062
    goto case_3;
  }
#line 1062
  if ((unsigned int )c.kind == 4U) {
#line 1062
    goto case_3;
  }
#line 1074
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1059
  printf((char const   */* __restrict  */)"<top>");
  }
#line 1059
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1060
  printf((char const   */* __restrict  */)"<number>");
  }
#line 1060
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1061
  printf((char const   */* __restrict  */)"<address>");
  }
#line 1061
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1063
  if (c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl) {
    {
#line 1064
    printf((char const   */* __restrict  */)"<address label=%s(%p)", (c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl)->name,
           c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl);
    }
  } else {
    {
#line 1066
    printf((char const   */* __restrict  */)"<address sym=%s(%p)", (c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl)->name,
           c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl);
    }
  }
#line 1067
  if ((unsigned int )c.kind == 3U) {
    {
#line 1068
    printf((char const   */* __restrict  */)" + <number>");
    }
  } else
#line 1069
  if (c.__annonCompField6.__annonCompField5.__annonCompField2.si > 0LL) {
    {
#line 1070
    printf((char const   */* __restrict  */)" + %lld", c.__annonCompField6.__annonCompField5.__annonCompField2.si);
    }
  } else {
    {
#line 1072
    printf((char const   */* __restrict  */)" - %lld", - c.__annonCompField6.__annonCompField5.__annonCompField2.si);
    }
  }
  {
#line 1073
  printf((char const   */* __restrict  */)">");
  }
  switch_default: /* CIL Label */ 
  {
#line 1075
  printf((char const   */* __restrict  */)"[size: %u]", (unsigned int )c.__annonCompField6.__annonCompField5.isize);
#line 1076
  cval_print(stdout, c);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1078
  printf((char const   */* __restrict  */)"\n");
  }
#line 1079
  return;
}
}
#line 1081 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_align_to(cval n , cval alignment ) 
{ 
  cval count ;
  cval tmp ;
  cval tmp___0 ;
  cval tmp___1 ;
  cval tmp___2 ;
  cval tmp___3 ;

  {
  {
#line 1083
  tmp = make_type_cval((size_t )1);
#line 1083
  tmp___0 = cval_add(n, alignment);
#line 1083
  tmp___1 = cval_sub(tmp___0, tmp);
#line 1083
  tmp___2 = cval_divide(tmp___1, alignment);
#line 1083
  count = tmp___2;
#line 1087
  tmp___3 = cval_times(count, alignment);
  }
#line 1087
  return (tmp___3);
}
}
#line 1090 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_gcd(cval x , cval y ) 
{ 
  cval z ;
  bool tmp ;

  {
#line 1094
  if ((unsigned int )x.kind == 0U) {
#line 1095
    return (cval_top);
  } else
#line 1094
  if ((unsigned int )y.kind == 0U) {
#line 1095
    return (cval_top);
  }
#line 1097
  if ((unsigned int )x.kind == 1U) {
#line 1098
    return (cval_unknown_number);
  } else
#line 1097
  if ((unsigned int )y.kind == 1U) {
#line 1098
    return (cval_unknown_number);
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1102
    tmp = cval_boolvalue(y);
    }
#line 1102
    if (! tmp) {
#line 1103
      return (x);
    }
    {
#line 1105
    z = cval_modulo(x, y);
#line 1105
    x = y;
#line 1105
    y = z;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1109 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_lcm(cval x , cval y ) 
{ 
  cval tmp ;
  cval tmp___0 ;
  cval tmp___1 ;

  {
  {
#line 1112
  tmp = cval_gcd(x, y);
#line 1112
  tmp___0 = cval_times(x, y);
#line 1112
  tmp___1 = cval_divide(tmp___0, tmp);
  }
#line 1112
  return (tmp___1);
}
}
#line 1115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_max(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  cval tmp___2 ;
  largest_int tmp___3 ;

  {
#line 1117
  if ((unsigned int )c1.kind == 0U) {
#line 1118
    return (cval_top);
  } else
#line 1117
  if ((unsigned int )c2.kind == 0U) {
#line 1118
    return (cval_top);
  }
#line 1120
  if ((unsigned int )c1.kind == 1U) {
#line 1121
    return (cval_unknown_number);
  } else
#line 1120
  if ((unsigned int )c2.kind == 1U) {
#line 1121
    return (cval_unknown_number);
  }
  {
#line 1124
  tmp = cval_isinteger(c1);
  }
#line 1124
  if (tmp) {
    {
#line 1124
    tmp___0 = cval_isinteger(c2);
    }
#line 1124
    if (! tmp___0) {
      {
#line 1124
      __assert_fail("cval_isinteger(c1) && cval_isinteger(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    1124U, "cval_max");
      }
    }
  } else {
    {
#line 1124
    __assert_fail("cval_isinteger(c1) && cval_isinteger(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  1124U, "cval_max");
    }
  }
  {
#line 1126
  tmp___3 = cval_intcompare(c1, c2);
  }
#line 1126
  if (tmp___3 > 0LL) {
#line 1126
    tmp___2 = c1;
  } else {
#line 1126
    tmp___2 = c2;
  }
#line 1126
  return (tmp___2);
}
}
#line 1129 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
cval cval_min(cval c1 , cval c2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  cval tmp___2 ;
  largest_int tmp___3 ;

  {
#line 1131
  if ((unsigned int )c1.kind == 0U) {
#line 1132
    return (cval_top);
  } else
#line 1131
  if ((unsigned int )c2.kind == 0U) {
#line 1132
    return (cval_top);
  }
#line 1134
  if ((unsigned int )c1.kind == 1U) {
#line 1135
    return (cval_unknown_number);
  } else
#line 1134
  if ((unsigned int )c2.kind == 1U) {
#line 1135
    return (cval_unknown_number);
  }
  {
#line 1138
  tmp = cval_isinteger(c1);
  }
#line 1138
  if (tmp) {
    {
#line 1138
    tmp___0 = cval_isinteger(c2);
    }
#line 1138
    if (! tmp___0) {
      {
#line 1138
      __assert_fail("cval_isinteger(c1) && cval_isinteger(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    1138U, "cval_min");
      }
    }
  } else {
    {
#line 1138
    __assert_fail("cval_isinteger(c1) && cval_isinteger(c2)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  1138U, "cval_min");
    }
  }
  {
#line 1140
  tmp___3 = cval_intcompare(c1, c2);
  }
#line 1140
  if (tmp___3 < 0LL) {
#line 1140
    tmp___2 = c1;
  } else {
#line 1140
    tmp___2 = c2;
  }
#line 1140
  return (tmp___2);
}
}
#line 1143 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
data_declaration cval_ddecl(cval c ) 
{ 
  bool tmp ;

  {
  {
#line 1149
  tmp = cval_isaddress(c);
  }
#line 1149
  if (tmp) {
#line 1149
    if (! (! ((unsigned int )c.kind == 2U))) {
      {
#line 1149
      __assert_fail("cval_isaddress(c) && !((c).kind == cval_unk_address)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    1149U, "cval_ddecl");
      }
    }
  } else {
    {
#line 1149
    __assert_fail("cval_isaddress(c) && !((c).kind == cval_unk_address)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  1149U, "cval_ddecl");
    }
  }
#line 1150
  return (c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ddecl);
}
}
#line 1153 "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c"
label_declaration cval_ldecl(cval c ) 
{ 
  bool tmp ;

  {
  {
#line 1158
  tmp = cval_isaddress(c);
  }
#line 1158
  if (tmp) {
#line 1158
    if (! (! ((unsigned int )c.kind == 2U))) {
      {
#line 1158
      __assert_fail("cval_isaddress(c) && !((c).kind == cval_unk_address)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                    1158U, "cval_ldecl");
      }
    }
  } else {
    {
#line 1158
    __assert_fail("cval_isaddress(c) && !((c).kind == cval_unk_address)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/cval.c",
                  1158U, "cval_ldecl");
    }
  }
#line 1159
  return (c.__annonCompField6.__annonCompField5.__annonCompField4.__annonCompField3.ldecl);
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "./libcompat/regions.h"
extern region newregion(void) ;
#line 88
extern nomem_handler set_nomem_handler(void (*newhandler)(void) ) ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_syntax_only ;
#line 36
int flag_pack_struct ;
#line 50
int warn_unused ;
#line 53
int warn_uninitialized ;
#line 56
int warn_shadow ;
#line 60
int warn_switch ;
#line 64
int warn_return_type ;
#line 69
int warn_cast_align ;
#line 83
int warn_inline ;
#line 87
int warn_aggregate_return ;
#line 90
int dollars_in_ident ;
#line 97
int flag_no_asm ;
#line 108
int warn_write_strings ;
#line 115
int warn_strict_prototypes ;
#line 119
int warn_redundant_decls ;
#line 126
int warn_nested_externs ;
#line 141
int warn_format ;
#line 150
int warn_main ;
#line 166
int warn_missing_braces ;
#line 169
int warn_sign_compare ;
#line 173
int mesg_implicit_function_declaration ;
#line 178
int warn_implicit_int ;
#line 182
int warn_missing_prototypes ;
#line 186
int warn_missing_declarations ;
#line 192
int flag_short_enums ;
#line 195
int flag_signed_bitfields ;
#line 198
int flag_parse_only ;
#line 223
int flag_verbose ;
#line 290
int flag_nostdinc ;
#line 293
int flag_undef ;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
char const   *progname ;
#line 37
location current_location(void) ;
#line 60
void fatal(char const   *format  , ...) ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-main.h"
extern void add_nesc_include(char const   *name , bool name_is_path ) ;
#line 22
extern void nesc_compile(char const   *component_name , char const   *target_name ) ;
#line 24
extern int nesc_option(char *p ) ;
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-paths.h"
extern void init_nesc_paths_start(region r ) ;
#line 26
extern void add_nesc_dir(char const   *path , int chain ) ;
#line 23 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-cpp.h"
extern void save_cpp_option(char const   *option , char const   *arg ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
static struct __anonstruct_fW_options_87 fW_options[50]  = 
#line 48 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
  {      {(char )'f', (char *)"syntax-only", & flag_syntax_only, 1}, 
        {(char )'f', (char *)"parse-only", & flag_parse_only, 1}, 
        {(char )'f', (char *)"pack-struct", & flag_pack_struct, 1}, 
        {(char )'f', (char *)"allow-single-precision", & flag_allow_single_precision,
      1}, 
        {(char )'f', (char *)"signed-char", & flag_signed_char, 1}, 
        {(char )'f', (char *)"unsigned-char", & flag_signed_char, 0}, 
        {(char )'f', (char *)"signed-bitfields", & flag_signed_bitfields, 1}, 
        {(char )'f', (char *)"unsigned-bitfields", & flag_signed_bitfields, 0}, 
        {(char )'f', (char *)"short-enums", & flag_short_enums, 1}, 
        {(char )'f', (char *)"cond-mismatch", & flag_cond_mismatch, 1}, 
        {(char )'f', (char *)"asm", & flag_no_asm, 0}, 
        {(char )'W', (char *)"unused", & warn_unused, 1}, 
        {(char )'W', (char *)"error", & warnings_are_errors, 1}, 
        {(char )'W', (char *)"shadow", & warn_shadow, 1}, 
        {(char )'W', (char *)"switch", & warn_switch, 1}, 
        {(char )'W', (char *)"aggregate-return", & warn_aggregate_return, 1}, 
        {(char )'W', (char *)"cast-align", & warn_cast_align, 1}, 
        {(char )'W', (char *)"uninitialized", & warn_uninitialized, 1}, 
        {(char )'W', (char *)"inline", & warn_inline, 1}, 
        {(char )'W', (char *)"error-implicit-function-declaration", & mesg_implicit_function_declaration,
      2}, 
        {(char )'W', (char *)"implicit-function-declaration", & mesg_implicit_function_declaration,
      1}, 
        {(char )'W', (char *)"implicit-int", & warn_implicit_int, 1}, 
        {(char )'W', (char *)"write-strings", & warn_write_strings, 1}, 
        {(char )'W', (char *)"cast-qual", & warn_cast_qual, 1}, 
        {(char )'W', (char *)"bad-function-cast", & warn_bad_function_cast, 1}, 
        {(char )'W', (char *)"pointer-arith", & warn_pointer_arith, 1}, 
        {(char )'W', (char *)"strict-prototypes", & warn_strict_prototypes, 1}, 
        {(char )'W', (char *)"missing-prototypes", & warn_missing_prototypes, 1}, 
        {(char )'W', (char *)"missing-declarations", & warn_missing_declarations, 1}, 
        {(char )'W',
      (char *)"redundant-decls", & warn_redundant_decls, 1}, 
        {(char )'W', (char *)"nested-externs", & warn_nested_externs, 1}, 
        {(char )'W', (char *)"traditional", & warn_traditional, 1}, 
        {(char )'W', (char *)"format", & warn_format, 1}, 
        {(char )'W', (char *)"char-subscripts", & warn_char_subscripts, 1}, 
        {(char )'W', (char *)"conversion", & warn_conversion, 1}, 
        {(char )'W', (char *)"parentheses", & warn_parentheses, 1}, 
        {(char )'W', (char *)"return-type", & warn_return_type, 1}, 
        {(char )'W', (char *)"missing-braces", & warn_missing_braces, 1}, 
        {(char )'W', (char *)"main", & warn_main, 1}, 
        {(char )'W', (char *)"sign-compare", & warn_sign_compare, 1}, 
        {(char )'W', (char *)"multichar", & warn_multichar, 1}, 
        {(char )'W', (char *)"comment", & warn_comments, 1}, 
        {(char )'W', (char *)"comments", & warn_comments, 1}, 
        {(char )'W', (char *)"trigraphs", & warn_trigraphs, 1}, 
        {(char )'W', (char *)"unused-macros", & warn_unused_macros, 1}, 
        {(char )'W', (char *)"endif-labels", & warn_endif_labels, 1}, 
        {(char )'W', (char *)"system-headers", & warn_system_headers, 1}, 
        {(char )'W', (char *)"undef", & warn_undef, 1}, 
        {(char )'W', (char *)"missing-include-dirs", & warn_missing_include_dirs, 1}, 
        {(char )'W',
      (char *)"multichar", & warn_multichar, 1}};
#line 106 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
char const   *opts_with_args[8]  = 
#line 106
  {      "include",      "imacros",      "idirafter",      "iprefix", 
        "iwithprefix",      "iwithprefixbefore",      "isystem",      "iquote"};
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
static void pipe_closed(int signo ) 
{ 


  {
  {
#line 122
  fatal("output pipe has been closed");
  }
#line 123
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
static bool c_option(char *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 133
  tmp___14 = strcmp((char const   *)p, "-v");
  }
#line 133
  if (tmp___14) {
    {
#line 135
    tmp___13 = strcmp((char const   *)p, "-traditional");
    }
#line 135
    if (tmp___13) {
      {
#line 137
      tmp___12 = strcmp((char const   *)p, "-trigraphs");
      }
#line 137
      if (tmp___12) {
        {
#line 139
        tmp___11 = strcmp((char const   *)p, "-ansi");
        }
#line 139
        if (tmp___11) {
          {
#line 141
          tmp___10 = strcmp((char const   *)p, "-pedantic");
          }
#line 141
          if (tmp___10) {
            {
#line 143
            tmp___9 = strcmp((char const   *)p, "-pedantic-errors");
            }
#line 143
            if (tmp___9) {
              {
#line 145
              tmp___8 = strcmp((char const   *)p, "-nostdinc");
              }
#line 145
              if (tmp___8) {
                {
#line 147
                tmp___7 = strcmp((char const   *)p, "-undef");
                }
#line 147
                if (tmp___7) {
                  {
#line 149
                  tmp___6 = strcmp((char const   *)p, "-fdollars-in-identifiers");
                  }
#line 149
                  if (tmp___6) {
                    {
#line 151
                    tmp___5 = strcmp((char const   *)p, "-fno-dollars-in-identifiers");
                    }
#line 151
                    if (tmp___5) {
                      {
#line 153
                      tmp___4 = strcmp((char const   *)p, "-w");
                      }
#line 153
                      if (tmp___4) {
                        {
#line 155
                        tmp___3 = strcmp((char const   *)p, "-Wimplicit");
                        }
#line 155
                        if (tmp___3) {
                          {
#line 161
                          tmp___2 = strcmp((char const   *)p, "-Wno-implicit");
                          }
#line 161
                          if (tmp___2) {
                            {
#line 163
                            tmp___1 = strcmp((char const   *)p, "-W");
                            }
#line 163
                            if (tmp___1) {
                              {
#line 172
                              tmp___0 = strcmp((char const   *)p, "-Wall");
                              }
#line 172
                              if (tmp___0) {
                                {
#line 195
                                tmp = strcmp((char const   *)p, "-H");
                                }
#line 195
                                if (tmp) {
#line 200
                                  return ((bool )0);
                                } else {
#line 197
                                  print_include_names = 1;
                                }
                              } else {
#line 177
                                if (warn_uninitialized != 1) {
#line 178
                                  warn_uninitialized = 2;
                                }
#line 179
                                warn_implicit_int = 1;
#line 180
                                mesg_implicit_function_declaration = 1;
#line 181
                                warn_return_type = 1;
#line 182
                                warn_unused = 1;
#line 183
                                warn_switch = 1;
#line 184
                                warn_format = 1;
#line 185
                                warn_char_subscripts = 1;
#line 186
                                warn_parentheses = 1;
#line 187
                                warn_missing_braces = 1;
#line 190
                                warn_main = 2;
#line 192
                                warn_trigraphs = 1;
#line 193
                                warn_comments = 1;
                              }
                            } else {
#line 165
                              extra_warnings = 1;
#line 169
                              if (warn_uninitialized != 1) {
#line 170
                                warn_uninitialized = 2;
                              }
                            }
                          } else {
#line 162
                            warn_implicit_int = 0;
#line 162
                            mesg_implicit_function_declaration = 0;
                          }
                        } else {
#line 157
                          warn_implicit_int = 1;
#line 158
                          if (mesg_implicit_function_declaration != 2) {
#line 159
                            mesg_implicit_function_declaration = 1;
                          }
                        }
                      } else {
#line 154
                        inhibit_warnings = 1;
                      }
                    } else {
#line 152
                      dollars_in_ident = 0;
                    }
                  } else {
                    {
#line 150
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nesC does not support $ in identifiers");
                    }
                  }
                } else {
#line 148
                  flag_undef = 1;
                }
              } else {
#line 146
                flag_nostdinc = 1;
              }
            } else {
#line 144
              pedantic = (bool )1;
#line 144
              flag_pedantic_errors = (int )pedantic;
            }
          } else {
#line 142
            pedantic = (bool )1;
          }
        } else {
#line 140
          flag_no_asm = 1;
        }
      } else {
#line 138
        flag_trigraphs = 1;
      }
    } else {
#line 136
      flag_traditional = 1;
    }
  } else {
#line 134
    flag_verbose = 1;
  }
#line 202
  return ((bool )1);
}
}
#line 205 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
static void rcc_aborting(int s ) 
{ 
  location where ;
  char *tmp ;

  {
  {
#line 209
  signal(6, (void (*)(int  ))0);
#line 210
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nesC: Internal error. Please send a bug report to the nesC bug mailing list\nat nescc-bugs@lists.sourceforge.net\n");
#line 211
  where = current_location();
  }
#line 212
  if ((unsigned long )where != (unsigned long )dummy_location) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Current location (guess): %s:%lu\n",
            where->filename, where->lineno);
    }
  }
  {
#line 214
  tmp = getenv("RCCDEBUG");
  }
#line 214
  if (tmp) {
    {
#line 215
    abort();
    }
  } else {
    {
#line 217
    exit(33);
    }
  }
}
}
#line 224 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
static void outofmemory(void) 
{ 


  {
  {
#line 226
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory - exiting\n");
#line 227
  exit(33);
  }
}
}
#line 230 "/home/wheatley/newnew/temp/nescc-1.3.4/src/toplev.c"
int region_main(int argc , char **argv ) 
{ 
  int i ;
  char *filename ;
  char *targetfile ;
  char *p ;
  char *waitforgdb ;
  __pid_t tmp ;
  region tmp___0 ;
  size_t tmp___1 ;
  int j ;
  char *str ;
  int tmp___2 ;
  char *arg ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char kind ;
  char *p___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;

  {
  {
#line 233
  filename = (char *)0;
#line 234
  targetfile = (char *)0;
#line 245
  waitforgdb = getenv("NCCGDB");
  }
#line 246
  if (waitforgdb) {
    {
#line 248
    tmp = getpid();
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ncc pid %d waiting for gdb attach\n",
            tmp);
#line 249
    poll((struct pollfd *)0, (nfds_t )0, -1);
    }
  }
  {
#line 253
  signal(6, & rcc_aborting);
#line 254
  signal(11, & rcc_aborting);
#line 256
  signal(7, & rcc_aborting);
#line 258
  set_nomem_handler(& outofmemory);
#line 260
  tmp___0 = newregion();
#line 260
  init_nesc_paths_start(tmp___0);
#line 262
  tmp___1 = strlen((char const   *)*(argv + 0));
#line 262
  p = *(argv + 0) + tmp___1;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if ((unsigned long )p != (unsigned long )*(argv + 0)) {
#line 263
      if (! ((int )*(p + -1) != 47)) {
#line 263
        goto while_break;
      }
    } else {
#line 263
      goto while_break;
    }
#line 268
    p --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  progname = (char const   *)p;
#line 272
  signal(13, & pipe_closed);
#line 275
  flag_signed_char = 2;
#line 277
  i = 1;
  }
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 277
    if (! (i < argc)) {
#line 277
      goto while_break___0;
    }
    {
#line 281
    tmp___11 = c_option(*(argv + i));
    }
#line 281
    if (tmp___11) {
#line 282
      i ++;
    } else {
      {
#line 281
      tmp___12 = nesc_option(*(argv + i));
      }
#line 281
      if (tmp___12) {
#line 282
        i ++;
      } else
#line 283
      if ((int )*(*(argv + i) + 0) == 45) {
#line 283
        if ((int )*(*(argv + i) + 1) != 0) {
          {
#line 285
          tmp___2 = i;
#line 285
          i ++;
#line 285
          str = *(argv + tmp___2) + 1;
#line 286
          arg = (char *)((void *)0);
#line 288
          tmp___4 = strchr("DUAIo", (int )*(str + 0));
          }
#line 288
          if (tmp___4) {
#line 290
            if (! *(str + 1)) {
#line 291
              if (i < argc) {
#line 292
                tmp___3 = i;
#line 292
                i ++;
#line 292
                arg = *(argv + tmp___3);
              } else {
                {
#line 295
                str = (char *)"";
#line 296
                error("argument to `-%c\' is missing", (int )*(str + 0));
                }
              }
            } else {
#line 299
              arg = str + 1;
            }
          }
#line 302
          j = 0;
          {
#line 302
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 302
            if (! ((unsigned long )j < sizeof(opts_with_args) / sizeof(opts_with_args[0]))) {
#line 302
              goto while_break___1;
            }
            {
#line 303
            tmp___6 = strcmp((char const   *)str, opts_with_args[j]);
            }
#line 303
            if (! tmp___6) {
#line 305
              if (i < argc) {
#line 306
                tmp___5 = i;
#line 306
                i ++;
#line 306
                arg = *(argv + tmp___5);
              } else {
                {
#line 309
                str = (char *)"";
#line 310
                error("argument to `-%s\' is missing", str);
                }
              }
#line 312
              goto while_break___1;
            }
#line 302
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 315
          if ((int )*(str + 0) == 111) {
#line 316
            targetfile = arg;
          } else
#line 317
          if ((int )*(str + 0) == 73) {
            {
#line 318
            add_nesc_dir((char const   *)arg, 1);
            }
          } else
#line 319
          if ((int )*(str + 0) == 68) {
            {
#line 320
            save_cpp_option((char const   *)str, (char const   *)arg);
            }
          } else
#line 319
          if ((int )*(str + 0) == 85) {
            {
#line 320
            save_cpp_option((char const   *)str, (char const   *)arg);
            }
          } else
#line 319
          if ((int )*(str + 0) == 65) {
            {
#line 320
            save_cpp_option((char const   *)str, (char const   *)arg);
            }
          } else
#line 321
          if ((int )*(str + 0) == 102) {
#line 321
            goto _L;
          } else
#line 321
          if ((int )*(str + 0) == 87) {
            _L: /* CIL Label */ 
#line 323
            kind = *(str + 0);
#line 324
            p___0 = str + 1;
#line 329
            j = 0;
            {
#line 329
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 329
              if (! ((unsigned long )j < sizeof(fW_options) / sizeof(fW_options[0]))) {
#line 329
                goto while_break___2;
              }
#line 333
              if ((int )kind == (int )fW_options[j].c) {
                {
#line 333
                tmp___7 = strcmp((char const   *)p___0, (char const   *)fW_options[j].string);
                }
#line 333
                if (! tmp___7) {
#line 336
                  *(fW_options[j].variable) = fW_options[j].on_value;
#line 337
                  goto while_break___2;
                }
              }
#line 339
              if ((int )kind == (int )fW_options[j].c) {
#line 339
                if ((int )*(p___0 + 0) == 110) {
#line 339
                  if ((int )*(p___0 + 1) == 111) {
#line 339
                    if ((int )*(p___0 + 2) == 45) {
                      {
#line 339
                      tmp___8 = strcmp((char const   *)(p___0 + 3), (char const   *)fW_options[j].string);
                      }
#line 339
                      if (! tmp___8) {
#line 343
                        *(fW_options[j].variable) = ! fW_options[j].on_value;
#line 344
                        goto while_break___2;
                      }
                    }
                  }
                }
              }
#line 329
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 348
            tmp___9 = strcmp((char const   *)str, "include");
            }
#line 348
            if (! tmp___9) {
              {
#line 349
              add_nesc_include((char const   *)arg, (bool )1);
              }
            }
          }
        } else {
#line 352
          tmp___10 = i;
#line 352
          i ++;
#line 352
          filename = *(argv + tmp___10);
        }
      } else {
#line 352
        tmp___10 = i;
#line 352
        i ++;
#line 352
        filename = *(argv + tmp___10);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 356
  if (target->handle_option) {
#line 357
    i = 1;
    {
#line 357
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 357
      if (! (i < argc)) {
#line 357
        goto while_break___3;
      }
#line 358
      if ((int )*(*(argv + i) + 0) == 45) {
#line 358
        if ((int )*(*(argv + i) + 1) != 0) {
          {
#line 359
          (*(target->handle_option))((char const   *)*(argv + i));
          }
        }
      }
#line 357
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 361
  if (target->preinit) {
    {
#line 362
    (*(target->preinit))();
    }
  }
#line 364
  if (flag_signed_char == 2) {
#line 365
    flag_signed_char = (int )target->char_signed;
  }
#line 367
  if (filename) {
    {
#line 368
    nesc_compile((char const   *)filename, (char const   *)targetfile);
    }
  } else {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [options] <filename>\n",
            *(argv + 0));
#line 372
    exit(33);
    }
  }
#line 375
  if (errorcount) {
    {
#line 376
    exit(33);
    }
  } else {
    {
#line 378
    exit(0);
    }
  }
#line 379
  return (0);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 72 "./../include/demangle.h"
enum demangling_styles current_demangling_style ;
#line 116
struct demangler_engine  const  libiberty_demanglers[11] ;
#line 123
char *cplus_demangle(char const   *mangled , int options ) ;
#line 126
int cplus_demangle_opname(char const   *opname , char *result , int options ) ;
#line 129
char const   *cplus_mangle_opname(char const   *opname , int options ) ;
#line 134
void set_cplus_marker_for_demangling(int ch ) ;
#line 137
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) ;
#line 140
enum demangling_styles cplus_demangle_name_to_style(char const   *name ) ;
#line 153
extern char *cplus_demangle_v3(char const   *mangled , int options ) ;
#line 160
extern char *java_demangle_v3(char const   *mangled ) ;
#line 65 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) ;
#line 95 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
enum demangling_styles current_demangling_style  =    (enum demangling_styles )256;
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char cplus_markers[4]  = {      (char )'$',      (char )'.',      (char )'$',      (char )'\000'};
#line 99 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char char_str[2]  = {      (char )'\000',      (char )'\000'};
#line 101 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
void set_cplus_marker_for_demangling(int ch ) 
{ 


  {
#line 104
  cplus_markers[0] = (char )ch;
#line 105
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static struct optable  const  optable[79]  = 
#line 147
  {      {(char const   */* const  */)"nw", (char const   */* const  */)" new", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"dl",
      (char const   */* const  */)" delete", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"new", (char const   */* const  */)" new", (int const   )0}, 
        {(char const   */* const  */)"delete",
      (char const   */* const  */)" delete", (int const   )0}, 
        {(char const   */* const  */)"vn", (char const   */* const  */)" new []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"vd",
      (char const   */* const  */)" delete []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"as", (char const   */* const  */)"=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ne",
      (char const   */* const  */)"!=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"eq", (char const   */* const  */)"==", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ge",
      (char const   */* const  */)">=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"gt", (char const   */* const  */)">", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"le",
      (char const   */* const  */)"<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"lt", (char const   */* const  */)"<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"plus",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"pl", (char const   */* const  */)"+", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"apl",
      (char const   */* const  */)"+=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"minus", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"mi",
      (char const   */* const  */)"-", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ami", (char const   */* const  */)"-=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"mult",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"ml", (char const   */* const  */)"*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amu",
      (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aml", (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"convert",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"negate", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"trunc_mod",
      (char const   */* const  */)"%", (int const   )0}, 
        {(char const   */* const  */)"md", (char const   */* const  */)"%", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amd",
      (char const   */* const  */)"%=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"trunc_div", (char const   */* const  */)"/", (int const   )0}, 
        {(char const   */* const  */)"dv",
      (char const   */* const  */)"/", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"adv", (char const   */* const  */)"/=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_andif",
      (char const   */* const  */)"&&", (int const   )0}, 
        {(char const   */* const  */)"aa", (char const   */* const  */)"&&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_orif",
      (char const   */* const  */)"||", (int const   )0}, 
        {(char const   */* const  */)"oo", (char const   */* const  */)"||", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_not",
      (char const   */* const  */)"!", (int const   )0}, 
        {(char const   */* const  */)"nt", (char const   */* const  */)"!", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postincrement",
      (char const   */* const  */)"++", (int const   )0}, 
        {(char const   */* const  */)"pp", (char const   */* const  */)"++", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postdecrement",
      (char const   */* const  */)"--", (int const   )0}, 
        {(char const   */* const  */)"mm", (char const   */* const  */)"--", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_ior",
      (char const   */* const  */)"|", (int const   )0}, 
        {(char const   */* const  */)"or", (char const   */* const  */)"|", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aor",
      (char const   */* const  */)"|=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_xor", (char const   */* const  */)"^", (int const   )0}, 
        {(char const   */* const  */)"er",
      (char const   */* const  */)"^", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aer", (char const   */* const  */)"^=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_and",
      (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"ad", (char const   */* const  */)"&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aad",
      (char const   */* const  */)"&=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_not", (char const   */* const  */)"~", (int const   )0}, 
        {(char const   */* const  */)"co",
      (char const   */* const  */)"~", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"call", (char const   */* const  */)"()", (int const   )0}, 
        {(char const   */* const  */)"cl",
      (char const   */* const  */)"()", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"alshift", (char const   */* const  */)"<<", (int const   )0}, 
        {(char const   */* const  */)"ls",
      (char const   */* const  */)"<<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"als", (char const   */* const  */)"<<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"arshift",
      (char const   */* const  */)">>", (int const   )0}, 
        {(char const   */* const  */)"rs", (char const   */* const  */)">>", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ars",
      (char const   */* const  */)">>=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"component", (char const   */* const  */)"->", (int const   )0}, 
        {(char const   */* const  */)"pt",
      (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"rf", (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"indirect",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"method_call", (char const   */* const  */)"->()",
      (int const   )0}, 
        {(char const   */* const  */)"addr", (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"array",
      (char const   */* const  */)"[]", (int const   )0}, 
        {(char const   */* const  */)"vc", (char const   */* const  */)"[]", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"compound",
      (char const   */* const  */)", ", (int const   )0}, 
        {(char const   */* const  */)"cm", (char const   */* const  */)", ", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"cond",
      (char const   */* const  */)"?:", (int const   )0}, 
        {(char const   */* const  */)"cn", (char const   */* const  */)"?:", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"max",
      (char const   */* const  */)">?", (int const   )0}, 
        {(char const   */* const  */)"mx", (char const   */* const  */)">?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"min",
      (char const   */* const  */)"<?", (int const   )0}, 
        {(char const   */* const  */)"mn", (char const   */* const  */)"<?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"nop",
      (char const   */* const  */)"", (int const   )0}, 
        {(char const   */* const  */)"rm", (char const   */* const  */)"->*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"sz",
      (char const   */* const  */)"sizeof ", (int const   )(1 << 1)}};
#line 248 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
struct demangler_engine  const  libiberty_demanglers[11]  = 
#line 248
  {      {(char const   */* const  */)"none", (enum demangling_styles  const  )-1, (char const   */* const  */)"Demangling disabled"}, 
        {(char const   */* const  */)"auto",
      (enum demangling_styles  const  )256, (char const   */* const  */)"Automatic selection based on executable"}, 
        {(char const   */* const  */)"gnu",
      (enum demangling_styles  const  )512, (char const   */* const  */)"GNU (g++) style demangling"}, 
        {(char const   */* const  */)"lucid",
      (enum demangling_styles  const  )1024, (char const   */* const  */)"Lucid (lcc) style demangling"}, 
        {(char const   */* const  */)"arm",
      (enum demangling_styles  const  )2048, (char const   */* const  */)"ARM style demangling"}, 
        {(char const   */* const  */)"hp",
      (enum demangling_styles  const  )4096, (char const   */* const  */)"HP (aCC) style demangling"}, 
        {(char const   */* const  */)"edg",
      (enum demangling_styles  const  )8192, (char const   */* const  */)"EDG style demangling"}, 
        {(char const   */* const  */)"gnu-v3",
      (enum demangling_styles  const  )16384, (char const   */* const  */)"GNU (g++) V3 ABI-style demangling"}, 
        {(char const   */* const  */)"java",
      (enum demangling_styles  const  )4, (char const   */* const  */)"Java style demangling"}, 
        {(char const   */* const  */)"gnat",
      (enum demangling_styles  const  )32768, (char const   */* const  */)"GNAT style demangling"}, 
        {(char const   */* const  */)((void *)0),
      (enum demangling_styles  const  )0, (char const   */* const  */)((void *)0)}};
#line 329
static void delete_work_stuff(struct work_stuff *work ) ;
#line 331
static void delete_non_B_K_work_stuff(struct work_stuff *work ) ;
#line 333
static char *mop_up(struct work_stuff *work , string___0 *declp , int success ) ;
#line 335
static void squangle_mop_up(struct work_stuff *work ) ;
#line 337
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) ;
#line 344
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) ;
#line 347
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string___0 *tname ) ;
#line 351
static int demangle_template(struct work_stuff *work , char const   **mangled , string___0 *tname ,
                             string___0 *trawname , int is_type , int remember ) ;
#line 355
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) ;
#line 359
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string___0 *declp ) ;
#line 362
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string___0 *result ,
                              int isfuncname , int append ) ;
#line 366
static int demangle_class(struct work_stuff *work , char const   **mangled , string___0 *declp ) ;
#line 368
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string___0 *result ) ;
#line 370
static int demangle_signature(struct work_stuff *work , char const   **mangled , string___0 *declp ) ;
#line 372
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string___0 *declp ) ;
#line 374
static int gnu_special(struct work_stuff *work , char const   **mangled , string___0 *declp ) ;
#line 376
static int arm_special(char const   **mangled , string___0 *declp ) ;
#line 378
static void string_need(string___0 *s , int n ) ;
#line 380
static void string_delete(string___0 *s ) ;
#line 382
static void string_init(string___0 *s ) ;
#line 385
static void string_clear(string___0 *s ) ;
#line 391
static void string_append(string___0 *p , char const   *s ) ;
#line 393
static void string_appends(string___0 *p , string___0 *s ) ;
#line 395
static void string_appendn(string___0 *p , char const   *s , int n ) ;
#line 397
static void string_prepend(string___0 *p , char const   *s ) ;
#line 399
static void string_prependn(string___0 *p , char const   *s , int n ) ;
#line 401
static void string_append_template_idx(string___0 *s , int idx ) ;
#line 403
static int get_count(char const   **type , int *count ) ;
#line 405
static int consume_count(char const   **type ) ;
#line 407
static int consume_count_with_underscores(char const   **mangled ) ;
#line 409
static int demangle_args(struct work_stuff *work , char const   **mangled , string___0 *declp ) ;
#line 411
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string___0 *declp ) ;
#line 413
static int do_type(struct work_stuff *work , char const   **mangled , string___0 *result ) ;
#line 415
static int do_arg(struct work_stuff *work , char const   **mangled , string___0 *result ) ;
#line 417
static void demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                   string___0 *declp , char const   *scan ) ;
#line 421
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string___0 *declp , char const   *scan ) ;
#line 425
static void remember_type(struct work_stuff *work , char const   *start , int len ) ;
#line 427
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) ;
#line 429
static int register_Btype(struct work_stuff *work ) ;
#line 431
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) ;
#line 433
static void forget_types(struct work_stuff *work ) ;
#line 435
static void forget_B_and_K_types(struct work_stuff *work ) ;
#line 437
static void string_prepends(string___0 *p , string___0 *s ) ;
#line 439
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string___0 *s , type_kind_t tk ) ;
#line 443
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string___0 *result ) ;
#line 446
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string___0 *result ) ;
#line 449
static int snarf_numeric_literal(char const   **args , string___0 *arg ) ;
#line 460
static int code_for_qualifier(int c ) ;
#line 462
static char const   *qualifier_string(int type_quals ) ;
#line 464
static char const   *demangle_qualifier(int c ) ;
#line 466
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string___0 *s , type_kind_t tk ) ;
#line 469
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string___0 *s ) ;
#line 472
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string___0 *s ) ;
#line 475
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string___0 *declp ) ;
#line 478
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string___0 *result , int namelength ) ;
#line 481
static void grow_vect(char **old_vect , size_t *size , size_t min_size , int element_size ) ;
#line 491 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int consume_count(char const   **type ) 
{ 
  int count ;

  {
#line 494
  count = 0;
#line 496
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 497
    return (-1);
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 499
      goto while_break;
    }
#line 501
    count *= 10;
#line 508
    if (count % 10 != 0) {
      {
#line 510
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 510
        if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 510
          goto while_break___0;
        }
#line 511
        (*type) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 512
      return (-1);
    }
#line 515
    count += (int )((int const   )*(*type) - 48);
#line 516
    (*type) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if (count < 0) {
#line 520
    count = -1;
  }
#line 522
  return (count);
}
}
#line 530 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int consume_count_with_underscores(char const   **mangled ) 
{ 
  int idx ;

  {
#line 535
  if ((int const   )*(*mangled) == 95) {
#line 537
    (*mangled) ++;
#line 538
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 539
      return (-1);
    }
    {
#line 541
    idx = consume_count(mangled);
    }
#line 542
    if ((int const   )*(*mangled) != 95) {
#line 544
      return (-1);
    }
#line 546
    (*mangled) ++;
  } else {
#line 550
    if ((int const   )*(*mangled) < 48) {
#line 551
      return (-1);
    } else
#line 550
    if ((int const   )*(*mangled) > 57) {
#line 551
      return (-1);
    }
#line 553
    idx = (int )((int const   )*(*mangled) - 48);
#line 554
    (*mangled) ++;
  }
#line 557
  return (idx);
}
}
#line 563 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int code_for_qualifier(int c ) 
{ 


  {
  {
#line 568
  if (c == 67) {
#line 568
    goto case_67;
  }
#line 571
  if (c == 86) {
#line 571
    goto case_86;
  }
#line 574
  if (c == 117) {
#line 574
    goto case_117;
  }
#line 577
  goto switch_default;
  case_67: /* CIL Label */ 
#line 569
  return (1);
  case_86: /* CIL Label */ 
#line 572
  return (2);
  case_117: /* CIL Label */ 
#line 575
  return (4);
  switch_default: /* CIL Label */ 
#line 578
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 582
  abort();
  }
}
}
#line 588 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char const   *qualifier_string(int type_quals ) 
{ 


  {
  {
#line 593
  if (type_quals == 0) {
#line 593
    goto case_0;
  }
#line 596
  if (type_quals == 1) {
#line 596
    goto case_1;
  }
#line 599
  if (type_quals == 2) {
#line 599
    goto case_2;
  }
#line 602
  if (type_quals == 4) {
#line 602
    goto case_4;
  }
#line 605
  if (type_quals == 3) {
#line 605
    goto case_3;
  }
#line 608
  if (type_quals == 5) {
#line 608
    goto case_5;
  }
#line 611
  if (type_quals == 6) {
#line 611
    goto case_6;
  }
#line 614
  if (type_quals == 7) {
#line 614
    goto case_7;
  }
#line 617
  goto switch_default;
  case_0: /* CIL Label */ 
#line 594
  return ("");
  case_1: /* CIL Label */ 
#line 597
  return ("const");
  case_2: /* CIL Label */ 
#line 600
  return ("volatile");
  case_4: /* CIL Label */ 
#line 603
  return ("__restrict");
  case_3: /* CIL Label */ 
#line 606
  return ("const volatile");
  case_5: /* CIL Label */ 
#line 609
  return ("const __restrict");
  case_6: /* CIL Label */ 
#line 612
  return ("volatile __restrict");
  case_7: /* CIL Label */ 
#line 615
  return ("const volatile __restrict");
  switch_default: /* CIL Label */ 
#line 618
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 622
  abort();
  }
}
}
#line 629 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char const   *demangle_qualifier(int c ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 632
  tmp = code_for_qualifier(c);
#line 632
  tmp___0 = qualifier_string(tmp);
  }
#line 632
  return (tmp___0);
}
}
#line 635 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
int cplus_demangle_opname(char const   *opname , char *result , int options ) 
{ 
  int len ;
  int len1 ;
  int ret ;
  string___0 type ;
  struct work_stuff work[1] ;
  char const   *tem ;
  size_t tmp ;
  int tmp___0 ;
  size_t i ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t i___0 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t i___1 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t i___2 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 643
  tmp = strlen(opname);
#line 643
  len = (int )tmp;
#line 644
  *(result + 0) = (char )'\000';
#line 645
  ret = 0;
#line 646
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 647
  work[0].options = options;
  }
#line 649
  if ((int const   )*(opname + 0) == 95) {
#line 649
    if ((int const   )*(opname + 1) == 95) {
#line 649
      if ((int const   )*(opname + 2) == 111) {
#line 649
        if ((int const   )*(opname + 3) == 112) {
          {
#line 654
          tem = opname + 4;
#line 655
          tmp___0 = do_type(work, & tem, & type);
          }
#line 655
          if (tmp___0) {
            {
#line 657
            strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 658
            strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                    (size_t )(type.p - type.b));
#line 659
            string_delete(& type);
#line 660
            ret = 1;
            }
          }
        } else {
#line 649
          goto _L___8;
        }
      } else {
#line 649
        goto _L___8;
      }
    } else {
#line 649
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 663
  if ((int const   )*(opname + 0) == 95) {
#line 663
    if ((int const   )*(opname + 1) == 95) {
#line 663
      if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 2)) & 255] & 8) {
#line 663
        if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 3)) & 255] & 8) {
#line 667
          if ((int const   )*(opname + 4) == 0) {
#line 671
            i = (size_t )0;
            {
#line 671
            while (1) {
              while_continue: /* CIL Label */ ;
#line 671
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 671
                goto while_break;
              }
              {
#line 673
              tmp___1 = strlen((char const   *)optable[i].in);
              }
#line 673
              if (tmp___1 == 2UL) {
                {
#line 673
                tmp___2 = memcmp((void const   *)optable[i].in, (void const   *)(opname + 2),
                                 (size_t )2);
                }
#line 673
                if (tmp___2 == 0) {
                  {
#line 676
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 677
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i].out);
#line 678
                  ret = 1;
                  }
#line 679
                  goto while_break;
                }
              }
#line 671
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else
#line 685
          if ((int const   )*(opname + 2) == 97) {
#line 685
            if ((int const   )*(opname + 5) == 0) {
#line 689
              i___0 = (size_t )0;
              {
#line 689
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 689
                if (! (i___0 < sizeof(optable) / sizeof(optable[0]))) {
#line 689
                  goto while_break___0;
                }
                {
#line 691
                tmp___3 = strlen((char const   *)optable[i___0].in);
                }
#line 691
                if (tmp___3 == 3UL) {
                  {
#line 691
                  tmp___4 = memcmp((void const   *)optable[i___0].in, (void const   *)(opname + 2),
                                   (size_t )3);
                  }
#line 691
                  if (tmp___4 == 0) {
                    {
#line 694
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 695
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___0].out);
#line 696
                    ret = 1;
                    }
#line 697
                    goto while_break___0;
                  }
                }
#line 689
                i___0 ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
          }
        } else {
#line 663
          goto _L___5;
        }
      } else {
#line 663
        goto _L___5;
      }
    } else {
#line 663
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 703
  if (len >= 3) {
#line 703
    if ((int const   )*(opname + 0) == 111) {
#line 703
      if ((int const   )*(opname + 1) == 112) {
        {
#line 703
        tmp___13 = strchr((char const   *)(cplus_markers), (int )*(opname + 2));
        }
#line 703
        if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 709
          if (len >= 10) {
            {
#line 709
            tmp___9 = memcmp((void const   *)(opname + 3), (void const   *)"assign_",
                             (size_t )7);
            }
#line 709
            if (tmp___9 == 0) {
#line 713
              i___1 = (size_t )0;
              {
#line 713
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 713
                if (! (i___1 < sizeof(optable) / sizeof(optable[0]))) {
#line 713
                  goto while_break___1;
                }
                {
#line 715
                len1 = len - 10;
#line 716
                tmp___5 = strlen((char const   *)optable[i___1].in);
                }
#line 716
                if ((int )tmp___5 == len1) {
                  {
#line 716
                  tmp___6 = memcmp((void const   *)optable[i___1].in, (void const   *)(opname + 10),
                                   (size_t )len1);
                  }
#line 716
                  if (tmp___6 == 0) {
                    {
#line 719
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 720
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___1].out);
#line 721
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"=");
#line 722
                    ret = 1;
                    }
#line 723
                    goto while_break___1;
                  }
                }
#line 713
                i___1 ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 709
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 730
            i___2 = (size_t )0;
            {
#line 730
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 730
              if (! (i___2 < sizeof(optable) / sizeof(optable[0]))) {
#line 730
                goto while_break___2;
              }
              {
#line 732
              len1 = len - 3;
#line 733
              tmp___7 = strlen((char const   *)optable[i___2].in);
              }
#line 733
              if ((int )tmp___7 == len1) {
                {
#line 733
                tmp___8 = memcmp((void const   *)optable[i___2].in, (void const   *)(opname + 3),
                                 (size_t )len1);
                }
#line 733
                if (tmp___8 == 0) {
                  {
#line 736
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 737
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___2].out);
#line 738
                  ret = 1;
                  }
#line 739
                  goto while_break___2;
                }
              }
#line 730
              i___2 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 703
          goto _L___2;
        }
      } else {
#line 703
        goto _L___2;
      }
    } else {
#line 703
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 744
  if (len >= 5) {
    {
#line 744
    tmp___11 = memcmp((void const   *)opname, (void const   *)"type", (size_t )4);
    }
#line 744
    if (tmp___11 == 0) {
      {
#line 744
      tmp___12 = strchr((char const   *)(cplus_markers), (int )*(opname + 4));
      }
#line 744
      if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
        {
#line 748
        tem = opname + 5;
#line 749
        tmp___10 = do_type(work, & tem, & type);
        }
#line 749
        if (tmp___10) {
          {
#line 751
          strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 752
          strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                  (size_t )(type.p - type.b));
#line 753
          string_delete(& type);
#line 754
          ret = 1;
          }
        }
      }
    }
  }
  {
#line 757
  squangle_mop_up(work);
  }
#line 758
  return (ret);
}
}
#line 768 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
char const   *cplus_mangle_opname(char const   *opname , int options ) 
{ 
  size_t i ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 774
  tmp = strlen(opname);
#line 774
  len = (int )tmp;
#line 775
  i = (size_t )0;
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 775
      goto while_break;
    }
    {
#line 777
    tmp___0 = strlen((char const   *)optable[i].out);
    }
#line 777
    if ((int )tmp___0 == len) {
#line 777
      if ((options & (1 << 1)) == (int )(optable[i].flags & (int const   )(1 << 1))) {
        {
#line 777
        tmp___1 = memcmp((void const   *)optable[i].out, (void const   *)opname, (size_t )len);
        }
#line 777
        if (tmp___1 == 0) {
#line 780
          return ((char const   *)optable[i].in);
        }
      }
    }
#line 775
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 782
  return ((char const   *)0);
}
}
#line 788 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) 
{ 
  struct demangler_engine  const  *demangler ;

  {
#line 791
  demangler = libiberty_demanglers;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 793
      goto while_break;
    }
#line 794
    if ((int )style == (int )demangler->demangling_style) {
#line 796
      current_demangling_style = style;
#line 797
      return (current_demangling_style);
    }
#line 793
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  return ((enum demangling_styles )0);
}
}
#line 805 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_name_to_style(char const   *name ) 
{ 
  struct demangler_engine  const  *demangler ;
  int tmp ;

  {
#line 808
  demangler = libiberty_demanglers;
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 810
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 810
      goto while_break;
    }
    {
#line 811
    tmp = strcmp(name, (char const   *)demangler->demangling_style_name);
    }
#line 811
    if (tmp == 0) {
#line 812
      return ((enum demangling_styles )demangler->demangling_style);
    }
#line 810
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return ((enum demangling_styles )0);
}
}
#line 845 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
char *cplus_demangle(char const   *mangled , int options ) 
{ 
  char *ret ;
  struct work_stuff work[1] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 851
  if ((int )current_demangling_style == -1) {
    {
#line 852
    tmp = xstrdup(mangled);
    }
#line 852
    return (tmp);
  }
  {
#line 854
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 855
  work[0].options = options;
  }
#line 856
  if ((work[0].options & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15))) == 0) {
#line 857
    work[0].options |= (int )current_demangling_style & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15));
  }
#line 860
  if (work[0].options & (1 << 14)) {
#line 860
    goto _L;
  } else
#line 860
  if (work[0].options & (1 << 8)) {
    _L: /* CIL Label */ 
    {
#line 862
    ret = cplus_demangle_v3(mangled, work[0].options);
    }
#line 863
    if (ret) {
#line 864
      return (ret);
    } else
#line 863
    if (work[0].options & (1 << 14)) {
#line 864
      return (ret);
    }
  }
#line 867
  if (work[0].options & (1 << 2)) {
    {
#line 869
    ret = java_demangle_v3(mangled);
    }
#line 870
    if (ret) {
#line 871
      return (ret);
    }
  }
#line 874
  if (work[0].options & (1 << 15)) {
    {
#line 875
    tmp___0 = ada_demangle(mangled, options);
    }
#line 875
    return (tmp___0);
  }
  {
#line 877
  ret = internal_cplus_demangle(work, mangled);
#line 878
  squangle_mop_up(work);
  }
#line 879
  return (ret);
}
}
#line 887 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void grow_vect(char **old_vect , size_t *size , size_t min_size , int element_size ) 
{ 
  void *tmp ;

  {
#line 890
  if (*size < min_size) {
#line 892
    *size *= 2UL;
#line 893
    if (*size < min_size) {
#line 894
      *size = min_size;
    }
    {
#line 895
    tmp = xrealloc((void *)*old_vect, *size * (size_t )element_size);
#line 895
    *old_vect = (char *)tmp;
    }
  }
#line 897
  return;
}
}
#line 907 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) 
{ 
  int i ;
  int j ;
  int len0 ;
  char const   *p ;
  char *demangled ;
  int changed ;
  size_t demangled_size ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 913
  demangled = (char *)((void *)0);
#line 915
  demangled_size = (size_t )0;
#line 917
  changed = 0;
#line 919
  tmp = strncmp(mangled, "_ada_", (size_t )5);
  }
#line 919
  if (tmp == 0) {
#line 921
    mangled += 5;
#line 922
    changed = 1;
  }
#line 925
  if ((int const   )*(mangled + 0) == 95) {
#line 926
    goto Suppress;
  } else
#line 925
  if ((int const   )*(mangled + 0) == 60) {
#line 926
    goto Suppress;
  }
  {
#line 928
  tmp___0 = strstr(mangled, "___");
#line 928
  p = (char const   *)tmp___0;
  }
#line 929
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 930
    tmp___1 = strlen(mangled);
#line 930
    len0 = (int )tmp___1;
    }
  } else
#line 933
  if ((int const   )*(p + 3) == 88) {
#line 935
    len0 = (int )(p - mangled);
#line 936
    changed = 1;
  } else {
#line 939
    goto Suppress;
  }
  {
#line 943
  grow_vect(& demangled, & demangled_size, (size_t )(2 * len0 + 1), (int )sizeof(char ));
  }
#line 947
  if ((int const   )_sch_istable[(int )((unsigned char )*(mangled + (len0 - 1))) & 255] & 4) {
#line 948
    i = len0 - 2;
    {
#line 948
    while (1) {
      while_continue: /* CIL Label */ ;
#line 948
      if (i >= 0) {
#line 948
        if (! ((int const   )_sch_istable[(int )((unsigned char )*(mangled + i)) & 255] & 4)) {
#line 948
          goto while_break;
        }
      } else {
#line 948
        goto while_break;
      }
#line 948
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 950
    if (i > 1) {
#line 950
      if ((int const   )*(mangled + i) == 95) {
#line 950
        if ((int const   )*(mangled + (i - 1)) == 95) {
#line 952
          len0 = i - 1;
#line 953
          changed = 1;
        } else {
#line 950
          goto _L___0;
        }
      } else {
#line 950
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 955
    if ((int const   )*(mangled + i) == 36) {
#line 957
      len0 = i;
#line 958
      changed = 1;
    }
  }
#line 962
  i = 0;
#line 962
  j = 0;
  {
#line 962
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 962
    if (i < len0) {
#line 962
      if (! (! ((int const   )_sch_istable[(int )((unsigned char )*(mangled + i)) & 255] & 136))) {
#line 962
        goto while_break___0;
      }
    } else {
#line 962
      goto while_break___0;
    }
#line 964
    *(demangled + j) = (char )*(mangled + i);
#line 962
    i ++;
#line 962
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 966
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 966
    if (! (i < len0)) {
#line 966
      goto while_break___1;
    }
#line 968
    if (i < len0 - 2) {
#line 968
      if ((int const   )*(mangled + i) == 95) {
#line 968
        if ((int const   )*(mangled + (i + 1)) == 95) {
#line 970
          *(demangled + j) = (char )'.';
#line 971
          changed = 1;
#line 972
          i += 2;
#line 972
          j ++;
        } else {
#line 976
          *(demangled + j) = (char )*(mangled + i);
#line 977
          i ++;
#line 977
          j ++;
        }
      } else {
#line 976
        *(demangled + j) = (char )*(mangled + i);
#line 977
        i ++;
#line 977
        j ++;
      }
    } else {
#line 976
      *(demangled + j) = (char )*(mangled + i);
#line 977
      i ++;
#line 977
      j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 980
  *(demangled + j) = (char )'\000';
#line 982
  i = 0;
  {
#line 982
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 982
    if (! ((int )*(demangled + i) != 0)) {
#line 982
      goto while_break___2;
    }
#line 983
    if ((int const   )_sch_istable[(int )((unsigned char )*(demangled + i)) & 255] & 128) {
#line 984
      goto Suppress;
    } else
#line 983
    if ((int )*(demangled + i) == 32) {
#line 984
      goto Suppress;
    }
#line 982
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 986
  if (! changed) {
#line 987
    return ((char *)((void *)0));
  } else {
#line 989
    return (demangled);
  }
  Suppress: 
  {
#line 992
  tmp___2 = strlen(mangled);
#line 992
  grow_vect(& demangled, & demangled_size, tmp___2 + 3UL, (int )sizeof(char ));
  }
#line 996
  if ((int const   )*(mangled + 0) == 60) {
    {
#line 997
    strcpy((char */* __restrict  */)demangled, (char const   */* __restrict  */)mangled);
    }
  } else {
    {
#line 999
    sprintf((char */* __restrict  */)demangled, (char const   */* __restrict  */)"<%s>",
            mangled);
    }
  }
#line 1001
  return (demangled);
}
}
#line 1010 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) 
{ 
  string___0 decl ;
  int success ;
  char *demangled ;
  int s1 ;
  int s2 ;
  int s3 ;
  int s4 ;
  int tmp ;

  {
#line 1015
  success = 0;
#line 1016
  demangled = (char *)((void *)0);
#line 1018
  s1 = work->constructor;
#line 1019
  s2 = work->destructor;
#line 1020
  s3 = work->static_type;
#line 1021
  s4 = work->type_quals;
#line 1022
  tmp = 0;
#line 1022
  work->destructor = tmp;
#line 1022
  work->constructor = tmp;
#line 1023
  work->type_quals = 0;
#line 1024
  work->dllimported = 0;
#line 1026
  if ((unsigned long )mangled != (unsigned long )((void *)0)) {
#line 1026
    if ((int const   )*mangled != 0) {
      {
#line 1028
      string_init(& decl);
      }
#line 1037
      if (work->options & (1 << 8)) {
        {
#line 1039
        success = gnu_special(work, & mangled, & decl);
        }
      } else
#line 1037
      if (work->options & (1 << 9)) {
        {
#line 1039
        success = gnu_special(work, & mangled, & decl);
        }
      }
#line 1041
      if (! success) {
        {
#line 1043
        success = demangle_prefix(work, & mangled, & decl);
        }
      }
#line 1045
      if (success) {
#line 1045
        if ((int const   )*mangled != 0) {
          {
#line 1047
          success = demangle_signature(work, & mangled, & decl);
          }
        }
      }
#line 1049
      if (work->constructor == 2) {
        {
#line 1051
        string_prepend(& decl, "global constructors keyed to ");
#line 1052
        work->constructor = 0;
        }
      } else
#line 1054
      if (work->destructor == 2) {
        {
#line 1056
        string_prepend(& decl, "global destructors keyed to ");
#line 1057
        work->destructor = 0;
        }
      } else
#line 1059
      if (work->dllimported == 1) {
        {
#line 1061
        string_prepend(& decl, "import stub for ");
#line 1062
        work->dllimported = 0;
        }
      }
      {
#line 1064
      demangled = mop_up(work, & decl, success);
      }
    }
  }
#line 1066
  work->constructor = s1;
#line 1067
  work->destructor = s2;
#line 1068
  work->static_type = s3;
#line 1069
  work->type_quals = s4;
#line 1070
  return (demangled);
}
}
#line 1075 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void squangle_mop_up(struct work_stuff *work ) 
{ 


  {
  {
#line 1079
  forget_B_and_K_types(work);
  }
#line 1080
  if ((unsigned long )work->btypevec != (unsigned long )((void *)0)) {
    {
#line 1082
    free((void *)((char *)work->btypevec));
    }
  }
#line 1084
  if ((unsigned long )work->ktypevec != (unsigned long )((void *)0)) {
    {
#line 1086
    free((void *)((char *)work->ktypevec));
    }
  }
#line 1088
  return;
}
}
#line 1093 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) 
{ 
  int i ;
  void *tmp ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int len___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int len___1 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int len___2 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 1098
  delete_work_stuff(to);
#line 1101
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, sizeof(*to));
  }
#line 1104
  if (from->typevec_size) {
    {
#line 1105
    tmp = xmalloc(sizeof(char *) * (unsigned long )from->typevec_size);
#line 1105
    to->typevec = (char **)tmp;
    }
  }
#line 1107
  i = 0;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! (i < from->ntypes)) {
#line 1107
      goto while_break;
    }
    {
#line 1109
    tmp___0 = strlen((char const   *)*(from->typevec + i));
#line 1109
    len = (int )(tmp___0 + 1UL);
#line 1111
    tmp___1 = xmalloc(sizeof(char ) * (unsigned long )len);
#line 1111
    *(to->typevec + i) = (char *)tmp___1;
#line 1112
    memcpy((void */* __restrict  */)*(to->typevec + i), (void const   */* __restrict  */)*(from->typevec + i),
           (size_t )len);
#line 1107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  if (from->ksize) {
    {
#line 1116
    tmp___2 = xmalloc(sizeof(char *) * (unsigned long )from->ksize);
#line 1116
    to->ktypevec = (char **)tmp___2;
    }
  }
#line 1118
  i = 0;
  {
#line 1118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1118
    if (! (i < from->numk)) {
#line 1118
      goto while_break___0;
    }
    {
#line 1120
    tmp___3 = strlen((char const   *)*(from->ktypevec + i));
#line 1120
    len___0 = (int )(tmp___3 + 1UL);
#line 1122
    tmp___4 = xmalloc(sizeof(char ) * (unsigned long )len___0);
#line 1122
    *(to->ktypevec + i) = (char *)tmp___4;
#line 1123
    memcpy((void */* __restrict  */)*(to->ktypevec + i), (void const   */* __restrict  */)*(from->ktypevec + i),
           (size_t )len___0);
#line 1118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1126
  if (from->bsize) {
    {
#line 1127
    tmp___5 = xmalloc(sizeof(char *) * (unsigned long )from->bsize);
#line 1127
    to->btypevec = (char **)tmp___5;
    }
  }
#line 1129
  i = 0;
  {
#line 1129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1129
    if (! (i < from->numb)) {
#line 1129
      goto while_break___1;
    }
    {
#line 1131
    tmp___6 = strlen((char const   *)*(from->btypevec + i));
#line 1131
    len___1 = (int )(tmp___6 + 1UL);
#line 1133
    tmp___7 = xmalloc(sizeof(char ) * (unsigned long )len___1);
#line 1133
    *(to->btypevec + i) = (char *)tmp___7;
#line 1134
    memcpy((void */* __restrict  */)*(to->btypevec + i), (void const   */* __restrict  */)*(from->btypevec + i),
           (size_t )len___1);
#line 1129
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1137
  if (from->ntmpl_args) {
    {
#line 1138
    tmp___8 = xmalloc(sizeof(char *) * (unsigned long )from->ntmpl_args);
#line 1138
    to->tmpl_argvec = (char **)tmp___8;
    }
  }
#line 1140
  i = 0;
  {
#line 1140
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1140
    if (! (i < from->ntmpl_args)) {
#line 1140
      goto while_break___2;
    }
    {
#line 1142
    tmp___9 = strlen((char const   *)*(from->tmpl_argvec + i));
#line 1142
    len___2 = (int )(tmp___9 + 1UL);
#line 1144
    tmp___10 = xmalloc(sizeof(char ) * (unsigned long )len___2);
#line 1144
    *(to->tmpl_argvec + i) = (char *)tmp___10;
#line 1145
    memcpy((void */* __restrict  */)*(to->tmpl_argvec + i), (void const   */* __restrict  */)*(from->tmpl_argvec + i),
           (size_t )len___2);
#line 1140
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1148
  if (from->previous_argument) {
    {
#line 1150
    tmp___11 = xmalloc(sizeof(string___0 ));
#line 1150
    to->previous_argument = (string___0 *)tmp___11;
#line 1151
    string_init(to->previous_argument);
#line 1152
    string_appends(to->previous_argument, from->previous_argument);
    }
  }
#line 1154
  return;
}
}
#line 1159 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void delete_non_B_K_work_stuff(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 1164
  forget_types(work);
  }
#line 1165
  if ((unsigned long )work->typevec != (unsigned long )((void *)0)) {
    {
#line 1167
    free((void *)((char *)work->typevec));
#line 1168
    work->typevec = (char **)((void *)0);
#line 1169
    work->typevec_size = 0;
    }
  }
#line 1171
  if (work->tmpl_argvec) {
#line 1175
    i = 0;
    {
#line 1175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1175
      if (! (i < work->ntmpl_args)) {
#line 1175
        goto while_break;
      }
#line 1176
      if (*(work->tmpl_argvec + i)) {
        {
#line 1177
        free((void *)*(work->tmpl_argvec + i));
        }
      }
#line 1175
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1179
    free((void *)((char *)work->tmpl_argvec));
#line 1180
    work->tmpl_argvec = (char **)((void *)0);
    }
  }
#line 1182
  if (work->previous_argument) {
    {
#line 1184
    string_delete(work->previous_argument);
#line 1185
    free((void *)((char *)work->previous_argument));
#line 1186
    work->previous_argument = (string___0 *)((void *)0);
    }
  }
#line 1188
  return;
}
}
#line 1192 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void delete_work_stuff(struct work_stuff *work ) 
{ 


  {
  {
#line 1195
  delete_non_B_K_work_stuff(work);
#line 1196
  squangle_mop_up(work);
  }
#line 1197
  return;
}
}
#line 1202 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static char *mop_up(struct work_stuff *work , string___0 *declp , int success ) 
{ 
  char *demangled ;

  {
  {
#line 1205
  demangled = (char *)((void *)0);
#line 1207
  delete_non_B_K_work_stuff(work);
  }
#line 1212
  if (! success) {
    {
#line 1214
    string_delete(declp);
    }
  } else {
    {
#line 1218
    string_appendn(declp, "", 1);
#line 1219
    demangled = declp->b;
    }
  }
#line 1221
  return (demangled);
}
}
#line 1254 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_signature(struct work_stuff *work , char const   **mangled , string___0 *declp ) 
{ 
  int success ;
  int func_done ;
  int expect_func ;
  int expect_return_type ;
  char const   *oldmangled ;
  string___0 trawname ;
  string___0 tname ;
  int tmp ;
  string___0 s ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  string___0 return_type ;
  char const   *tmp___2 ;

  {
#line 1258
  success = 1;
#line 1259
  func_done = 0;
#line 1260
  expect_func = 0;
#line 1261
  expect_return_type = 0;
#line 1262
  oldmangled = (char const   *)((void *)0);
  {
#line 1266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1266
    if (success) {
#line 1266
      if (! ((int const   )*(*mangled) != 0)) {
#line 1266
        goto while_break;
      }
    } else {
#line 1266
      goto while_break;
    }
    {
#line 1270
    if ((int const   )*(*mangled) == 81) {
#line 1270
      goto case_81;
    }
#line 1280
    if ((int const   )*(*mangled) == 75) {
#line 1280
      goto case_75;
    }
#line 1290
    if ((int const   )*(*mangled) == 83) {
#line 1290
      goto case_83;
    }
#line 1302
    if ((int const   )*(*mangled) == 117) {
#line 1302
      goto case_117;
    }
#line 1302
    if ((int const   )*(*mangled) == 86) {
#line 1302
      goto case_117;
    }
#line 1302
    if ((int const   )*(*mangled) == 67) {
#line 1302
      goto case_117;
    }
#line 1311
    if ((int const   )*(*mangled) == 76) {
#line 1311
      goto case_76;
    }
#line 1327
    if ((int const   )*(*mangled) == 57) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 56) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 55) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 54) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 53) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 52) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 51) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 50) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 49) {
#line 1327
      goto case_57;
    }
#line 1327
    if ((int const   )*(*mangled) == 48) {
#line 1327
      goto case_57;
    }
#line 1348
    if ((int const   )*(*mangled) == 66) {
#line 1348
      goto case_66;
    }
#line 1363
    if ((int const   )*(*mangled) == 70) {
#line 1363
      goto case_70;
    }
#line 1397
    if ((int const   )*(*mangled) == 116) {
#line 1397
      goto case_116;
    }
#line 1431
    if ((int const   )*(*mangled) == 95) {
#line 1431
      goto case_95;
    }
#line 1464
    if ((int const   )*(*mangled) == 72) {
#line 1464
      goto case_72;
    }
#line 1479
    goto switch_default;
    case_81: /* CIL Label */ 
    {
#line 1271
    oldmangled = *mangled;
#line 1272
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1273
    if (success) {
      {
#line 1274
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1275
    if (work->options & (1 << 8)) {
#line 1276
      expect_func = 1;
    } else
#line 1275
    if (work->options & (1 << 9)) {
#line 1276
      expect_func = 1;
    }
#line 1277
    oldmangled = (char const   *)((void *)0);
#line 1278
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1281
    oldmangled = *mangled;
#line 1282
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1283
    if (work->options & (1 << 8)) {
#line 1285
      expect_func = 1;
    } else
#line 1283
    if (work->options & (1 << 9)) {
#line 1285
      expect_func = 1;
    }
#line 1287
    oldmangled = (char const   *)((void *)0);
#line 1288
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1292
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1294
      oldmangled = *mangled;
    }
#line 1296
    (*mangled) ++;
#line 1297
    work->static_type = 1;
#line 1298
    goto switch_break;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
    {
#line 1303
    tmp = code_for_qualifier((int )*(*mangled));
#line 1303
    work->type_quals |= tmp;
    }
#line 1306
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1307
      oldmangled = *mangled;
    }
#line 1308
    (*mangled) ++;
#line 1309
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1313
    if (work->options & (1 << 12)) {
      {
#line 1315
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1315
        if (*(*mangled)) {
#line 1315
          if (! ((int const   )*(*mangled) != 95)) {
#line 1315
            goto while_break___0;
          }
        } else {
#line 1315
          goto while_break___0;
        }
#line 1316
        (*mangled) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1317
      if (! *(*mangled)) {
#line 1318
        success = 0;
      } else {
#line 1320
        (*mangled) ++;
      }
    } else {
#line 1323
      success = 0;
    }
#line 1324
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1328
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1330
      oldmangled = *mangled;
    }
    {
#line 1332
    work->temp_start = -1;
#line 1333
    success = demangle_class(work, mangled, declp);
    }
#line 1334
    if (success) {
      {
#line 1336
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1338
    if (work->options & (1 << 8)) {
#line 1338
      goto _L;
    } else
#line 1338
    if (work->options & (1 << 9)) {
#line 1338
      goto _L;
    } else
#line 1338
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
#line 1342
      if ((int const   )*(*mangled) != 70) {
#line 1343
        expect_func = 1;
      }
    }
#line 1345
    oldmangled = (char const   *)((void *)0);
#line 1346
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1351
    success = do_type(work, mangled, & s);
    }
#line 1352
    if (success) {
#line 1354
      if (work->options & (1 << 2)) {
#line 1354
        tmp___0 = ".";
      } else {
#line 1354
        tmp___0 = "::";
      }
      {
#line 1354
      string_append(& s, tmp___0);
#line 1355
      string_prepends(declp, & s);
#line 1356
      string_delete(& s);
      }
    }
#line 1358
    oldmangled = (char const   *)((void *)0);
#line 1359
    expect_func = 1;
#line 1361
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1370
    oldmangled = (char const   *)((void *)0);
#line 1371
    func_done = 1;
#line 1372
    (*mangled) ++;
#line 1379
    if (work->options & (1 << 10)) {
      {
#line 1381
      forget_types(work);
      }
    } else
#line 1379
    if (work->options & (1 << 11)) {
      {
#line 1381
      forget_types(work);
      }
    } else
#line 1379
    if (work->options & (1 << 12)) {
      {
#line 1381
      forget_types(work);
      }
    } else
#line 1379
    if (work->options & (1 << 13)) {
      {
#line 1381
      forget_types(work);
      }
    }
    {
#line 1383
    success = demangle_args(work, mangled, declp);
    }
#line 1387
    if (success) {
#line 1387
      if (work->options & (1 << 8)) {
#line 1387
        goto _L___0;
      } else
#line 1387
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 1387
        if ((int const   )*(*mangled) == 95) {
          {
#line 1389
          (*mangled) ++;
#line 1391
          success = do_type(work, mangled, & tname);
#line 1392
          string_delete(& tname);
          }
        }
      }
    }
#line 1395
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1399
    string_init(& trawname);
#line 1400
    string_init(& tname);
    }
#line 1401
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1403
      oldmangled = *mangled;
    }
    {
#line 1405
    success = demangle_template(work, mangled, & tname, & trawname, 1, 1);
    }
#line 1407
    if (success) {
      {
#line 1409
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1411
    if (work->options & (1 << 2)) {
#line 1411
      tmp___1 = ".";
    } else {
#line 1411
      tmp___1 = "::";
    }
    {
#line 1411
    string_append(& tname, tmp___1);
#line 1413
    string_prepends(declp, & tname);
    }
#line 1414
    if (work->destructor & 1) {
      {
#line 1416
      string_prepend(& trawname, "~");
#line 1417
      string_appends(declp, & trawname);
#line 1418
      (work->destructor) --;
      }
    }
#line 1420
    if (work->constructor & 1) {
      {
#line 1422
      string_appends(declp, & trawname);
#line 1423
      (work->constructor) --;
      }
    } else
#line 1420
    if (work->destructor & 1) {
      {
#line 1422
      string_appends(declp, & trawname);
#line 1423
      (work->constructor) --;
      }
    }
    {
#line 1425
    string_delete(& trawname);
#line 1426
    string_delete(& tname);
#line 1427
    oldmangled = (char const   *)((void *)0);
#line 1428
    expect_func = 1;
    }
#line 1429
    goto switch_break;
    case_95: /* CIL Label */ 
#line 1432
    if (work->options & (1 << 8)) {
#line 1432
      goto _L___2;
    } else
#line 1432
    if (work->options & (1 << 9)) {
      _L___2: /* CIL Label */ 
#line 1432
      if (expect_return_type) {
        {
#line 1437
        (*mangled) ++;
#line 1438
        success = do_type(work, mangled, & return_type);
        }
#line 1439
        if (! ((unsigned long )return_type.b == (unsigned long )return_type.p)) {
          {
#line 1439
          string_append(& return_type, " ");
          }
        }
        {
#line 1441
        string_prepends(declp, & return_type);
#line 1442
        string_delete(& return_type);
        }
#line 1443
        goto switch_break;
      } else {
#line 1432
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1454
    if (work->options & (1 << 12)) {
#line 1456
      (*mangled) ++;
      {
#line 1457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1457
        if (*(*mangled)) {
#line 1457
          if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1457
            goto while_break___1;
          }
        } else {
#line 1457
          goto while_break___1;
        }
#line 1458
        (*mangled) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1461
      success = 0;
    }
#line 1462
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1465
    if (work->options & (1 << 8)) {
#line 1465
      goto _L___3;
    } else
#line 1465
    if (work->options & (1 << 9)) {
      _L___3: /* CIL Label */ 
      {
#line 1468
      success = demangle_template(work, mangled, declp, (string___0 *)0, 0, 0);
      }
#line 1470
      if (! (work->constructor & 1)) {
#line 1471
        expect_return_type = 1;
      }
#line 1472
      (*mangled) ++;
#line 1473
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1480
    if (work->options & (1 << 8)) {
      {
#line 1484
      func_done = 1;
#line 1485
      success = demangle_args(work, mangled, declp);
      }
    } else
#line 1480
    if (work->options & (1 << 9)) {
      {
#line 1484
      func_done = 1;
#line 1485
      success = demangle_args(work, mangled, declp);
      }
    } else {
#line 1493
      success = 0;
    }
#line 1495
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1501
    if (success) {
#line 1501
      if (expect_func) {
#line 1503
        func_done = 1;
#line 1504
        if (work->options & (1 << 10)) {
          {
#line 1506
          forget_types(work);
          }
        } else
#line 1504
        if (work->options & (1 << 11)) {
          {
#line 1506
          forget_types(work);
          }
        } else
#line 1504
        if (work->options & (1 << 13)) {
          {
#line 1506
          forget_types(work);
          }
        }
        {
#line 1508
        success = demangle_args(work, mangled, declp);
#line 1512
        expect_func = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1516
  if (success) {
#line 1516
    if (! func_done) {
#line 1518
      if (work->options & (1 << 8)) {
        {
#line 1526
        success = demangle_args(work, mangled, declp);
        }
      } else
#line 1518
      if (work->options & (1 << 9)) {
        {
#line 1526
        success = demangle_args(work, mangled, declp);
        }
      }
    }
  }
#line 1529
  if (success) {
#line 1529
    if (work->options & 1) {
#line 1531
      if (work->static_type) {
        {
#line 1532
        string_append(declp, " static");
        }
      }
#line 1533
      if (work->type_quals != 0) {
#line 1535
        if (! ((unsigned long )declp->b == (unsigned long )declp->p)) {
          {
#line 1535
          string_append(declp, " ");
          }
        }
        {
#line 1536
        tmp___2 = qualifier_string(work->type_quals);
#line 1536
        string_append(declp, tmp___2);
        }
      }
    }
  }
#line 1540
  return (success);
}
}
#line 1566 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string___0 *tname ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  string___0 temp ;
  int tmp ;

  {
  {
#line 1572
  need_comma = 0;
#line 1573
  success = 1;
#line 1576
  string_append(tname, "template <");
#line 1578
  tmp = get_count(mangled, & r);
  }
#line 1578
  if (tmp) {
#line 1580
    i = 0;
    {
#line 1580
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1580
      if (! (i < r)) {
#line 1580
        goto while_break;
      }
#line 1582
      if (need_comma) {
        {
#line 1584
        string_append(tname, ", ");
        }
      }
#line 1588
      if ((int const   )*(*mangled) == 90) {
        {
#line 1590
        (*mangled) ++;
#line 1591
        string_append(tname, "class");
        }
      } else
#line 1594
      if ((int const   )*(*mangled) == 122) {
        {
#line 1596
        (*mangled) ++;
#line 1597
        success = demangle_template_template_parm(work, mangled, tname);
        }
#line 1599
        if (! success) {
#line 1601
          goto while_break;
        }
      } else {
        {
#line 1607
        success = do_type(work, mangled, & temp);
        }
#line 1608
        if (success) {
          {
#line 1610
          string_appends(tname, & temp);
          }
        }
        {
#line 1612
        string_delete(& temp);
        }
#line 1613
        if (! success) {
#line 1615
          goto while_break;
        }
      }
#line 1618
      need_comma = 1;
#line 1580
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1622
  if ((int )*(tname->p + -1) == 62) {
    {
#line 1623
    string_append(tname, " ");
    }
  }
  {
#line 1624
  string_append(tname, "> class");
  }
#line 1625
  return (success);
}
}
#line 1628 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string___0 *s , type_kind_t tk ) 
{ 
  int need_operator ;
  int success ;
  size_t i ;
  size_t len ;
  size_t l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1632
  need_operator = 0;
#line 1635
  success = 1;
#line 1636
  string_appendn(s, "(", 1);
#line 1637
  (*mangled) ++;
  }
  {
#line 1638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1638
    if (success) {
#line 1638
      if ((int const   )*(*mangled) != 87) {
#line 1638
        if (! ((int const   )*(*mangled) != 0)) {
#line 1638
          goto while_break;
        }
      } else {
#line 1638
        goto while_break;
      }
    } else {
#line 1638
      goto while_break;
    }
#line 1640
    if (need_operator) {
      {
#line 1645
      success = 0;
#line 1647
      len = strlen(*mangled);
#line 1649
      i = (size_t )0;
      }
      {
#line 1649
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1649
        if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 1649
          goto while_break___0;
        }
        {
#line 1651
        tmp = strlen((char const   *)optable[i].in);
#line 1651
        l = tmp;
        }
#line 1653
        if (l <= len) {
          {
#line 1653
          tmp___0 = memcmp((void const   *)optable[i].in, (void const   *)*mangled,
                           l);
          }
#line 1653
          if (tmp___0 == 0) {
            {
#line 1656
            string_appendn(s, " ", 1);
#line 1657
            string_append(s, (char const   *)optable[i].out);
#line 1658
            string_appendn(s, " ", 1);
#line 1659
            success = 1;
#line 1660
            *mangled += l;
            }
#line 1661
            goto while_break___0;
          }
        }
#line 1649
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1665
      if (! success) {
#line 1666
        goto while_break;
      }
    } else {
#line 1669
      need_operator = 1;
    }
    {
#line 1671
    success = demangle_template_value_parm(work, mangled, s, tk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1674
  if ((int const   )*(*mangled) != 87) {
#line 1675
    success = 0;
  } else {
    {
#line 1678
    string_appendn(s, ")", 1);
#line 1679
    (*mangled) ++;
    }
  }
#line 1682
  return (success);
}
}
#line 1685 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string___0 *s ) 
{ 
  int success ;
  int value ;
  int multidigit_without_leading_underscore ;
  int leave_following_underscore ;
  char buf___0[32] ;

  {
#line 1691
  if ((int const   )*(*mangled) == 69) {
    {
#line 1692
    success = demangle_expression(work, mangled, s, (type_kind_t )3);
    }
  } else
#line 1693
  if ((int const   )*(*mangled) == 81) {
    {
#line 1694
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else
#line 1693
  if ((int const   )*(*mangled) == 75) {
    {
#line 1694
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else {
#line 1701
    multidigit_without_leading_underscore = 0;
#line 1702
    leave_following_underscore = 0;
#line 1704
    success = 0;
#line 1706
    if ((int const   )*(*mangled) == 95) {
#line 1708
      if ((int const   )*(*(mangled + 0) + 1) == 109) {
        {
#line 1714
        multidigit_without_leading_underscore = 1;
#line 1715
        string_appendn(s, "-", 1);
#line 1716
        *mangled += 2;
        }
      } else {
#line 1723
        leave_following_underscore = 1;
      }
    } else {
#line 1729
      if ((int const   )*(*mangled) == 109) {
        {
#line 1731
        string_appendn(s, "-", 1);
#line 1732
        (*mangled) ++;
        }
      }
#line 1738
      multidigit_without_leading_underscore = 1;
#line 1741
      leave_following_underscore = 1;
    }
#line 1748
    if (multidigit_without_leading_underscore) {
      {
#line 1749
      value = consume_count(mangled);
      }
    } else {
      {
#line 1751
      value = consume_count_with_underscores(mangled);
      }
    }
#line 1753
    if (value != -1) {
      {
#line 1756
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              value);
#line 1757
      string_append(s, (char const   *)(buf___0));
      }
#line 1766
      if (value > 9) {
#line 1766
        goto _L;
      } else
#line 1766
      if (multidigit_without_leading_underscore) {
        _L: /* CIL Label */ 
#line 1766
        if (! leave_following_underscore) {
#line 1766
          if ((int const   )*(*mangled) == 95) {
#line 1769
            (*mangled) ++;
          }
        }
      }
#line 1772
      success = 1;
    }
  }
#line 1776
  return (success);
}
}
#line 1781 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string___0 *s ) 
{ 
  int tmp ;

  {
#line 1785
  if ((int const   )*(*mangled) == 69) {
    {
#line 1786
    tmp = demangle_expression(work, mangled, s, (type_kind_t )6);
    }
#line 1786
    return (tmp);
  }
#line 1788
  if ((int const   )*(*mangled) == 109) {
    {
#line 1790
    string_appendn(s, "-", 1);
#line 1791
    (*mangled) ++;
    }
  }
  {
#line 1793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1793
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1793
      goto while_break;
    }
    {
#line 1795
    string_appendn(s, *mangled, 1);
#line 1796
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1798
  if ((int const   )*(*mangled) == 46) {
    {
#line 1800
    string_appendn(s, ".", 1);
#line 1801
    (*mangled) ++;
    }
    {
#line 1802
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1802
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1802
        goto while_break___0;
      }
      {
#line 1804
      string_appendn(s, *mangled, 1);
#line 1805
      (*mangled) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1808
  if ((int const   )*(*mangled) == 101) {
    {
#line 1810
    string_appendn(s, "e", 1);
#line 1811
    (*mangled) ++;
    }
    {
#line 1812
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1812
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1812
        goto while_break___1;
      }
      {
#line 1814
      string_appendn(s, *mangled, 1);
#line 1815
      (*mangled) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1819
  return (1);
}
}
#line 1822 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string___0 *s , type_kind_t tk ) 
{ 
  int success ;
  int idx ;
  int tmp ;
  char tmp___0[2] ;
  int val ;
  int val___0 ;
  int tmp___1 ;
  int symbol_len ;
  int tmp___2 ;
  char *p ;
  void *tmp___3 ;
  char *q ;

  {
#line 1826
  success = 1;
#line 1828
  if ((int const   )*(*mangled) == 89) {
    {
#line 1833
    (*mangled) ++;
#line 1834
    idx = consume_count_with_underscores(mangled);
    }
#line 1835
    if (idx == -1) {
#line 1838
      return (-1);
    } else
#line 1835
    if (work->tmpl_argvec) {
#line 1835
      if (idx >= work->ntmpl_args) {
#line 1838
        return (-1);
      } else {
#line 1835
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1835
      tmp = consume_count_with_underscores(mangled);
      }
#line 1835
      if (tmp == -1) {
#line 1838
        return (-1);
      }
    }
#line 1839
    if (work->tmpl_argvec) {
      {
#line 1840
      string_append(s, (char const   *)*(work->tmpl_argvec + idx));
      }
    } else {
      {
#line 1842
      string_append_template_idx(s, idx);
      }
    }
  } else
#line 1844
  if ((unsigned int )tk == 3U) {
    {
#line 1845
    success = demangle_integral_value(work, mangled, s);
    }
  } else
#line 1846
  if ((unsigned int )tk == 5U) {
#line 1850
    if ((int const   )*(*mangled) == 109) {
      {
#line 1852
      string_appendn(s, "-", 1);
#line 1853
      (*mangled) ++;
      }
    }
    {
#line 1855
    string_appendn(s, "\'", 1);
#line 1856
    val = consume_count(mangled);
    }
#line 1857
    if (val <= 0) {
#line 1858
      success = 0;
    } else {
      {
#line 1861
      tmp___0[0] = (char )val;
#line 1862
      tmp___0[1] = (char )'\000';
#line 1863
      string_appendn(s, (char const   *)(& tmp___0[0]), 1);
#line 1864
      string_appendn(s, "\'", 1);
      }
    }
  } else
#line 1867
  if ((unsigned int )tk == 4U) {
    {
#line 1869
    tmp___1 = consume_count(mangled);
#line 1869
    val___0 = tmp___1;
    }
#line 1870
    if (val___0 == 0) {
      {
#line 1871
      string_appendn(s, "false", 5);
      }
    } else
#line 1872
    if (val___0 == 1) {
      {
#line 1873
      string_appendn(s, "true", 4);
      }
    } else {
#line 1875
      success = 0;
    }
  } else
#line 1877
  if ((unsigned int )tk == 6U) {
    {
#line 1878
    success = demangle_real_value(work, mangled, s);
    }
  } else
#line 1879
  if ((unsigned int )tk == 1U) {
#line 1879
    goto _L___0;
  } else
#line 1879
  if ((unsigned int )tk == 2U) {
    _L___0: /* CIL Label */ 
#line 1881
    if ((int const   )*(*mangled) == 81) {
      {
#line 1882
      success = demangle_qualified(work, mangled, s, 0, 1);
      }
    } else {
      {
#line 1887
      tmp___2 = consume_count(mangled);
#line 1887
      symbol_len = tmp___2;
      }
#line 1888
      if (symbol_len == -1) {
#line 1889
        return (-1);
      }
#line 1890
      if (symbol_len == 0) {
        {
#line 1891
        string_appendn(s, "0", 1);
        }
      } else {
        {
#line 1894
        tmp___3 = xmalloc(sizeof(char ) * (unsigned long )(symbol_len + 1));
#line 1894
        p = (char *)tmp___3;
#line 1895
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)*mangled,
                (size_t )symbol_len);
#line 1896
        *(p + symbol_len) = (char )'\000';
#line 1902
        q = cplus_demangle((char const   *)p, work->options);
        }
#line 1903
        if ((unsigned int )tk == 1U) {
          {
#line 1904
          string_appendn(s, "&", 1);
          }
        }
#line 1907
        if (q) {
          {
#line 1909
          string_append(s, (char const   *)q);
#line 1910
          free((void *)q);
          }
        } else {
          {
#line 1913
          string_append(s, (char const   *)p);
          }
        }
        {
#line 1914
        free((void *)p);
        }
      }
#line 1916
      *mangled += symbol_len;
    }
  }
#line 1920
  return (success);
}
}
#line 1931 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_template(struct work_stuff *work , char const   **mangled , string___0 *tname ,
                             string___0 *trawname , int is_type , int remember ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  int is_java_array ;
  string___0 temp ;
  int idx ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int len ;
  void *tmp___5 ;
  int r2 ;
  int len___0 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  string___0 param ;
  string___0 *s ;
  int len___1 ;
  void *tmp___8 ;
  int bindex ;
  int tmp___9 ;
  long tmp___10 ;

  {
#line 1938
  need_comma = 0;
#line 1939
  success = 0;
#line 1940
  is_java_array = 0;
#line 1943
  (*mangled) ++;
#line 1944
  if (is_type) {
#line 1947
    if ((int const   )*(*mangled) == 122) {
      {
#line 1950
      (*mangled) ++;
#line 1951
      (*mangled) ++;
#line 1953
      idx = consume_count_with_underscores(mangled);
      }
#line 1954
      if (idx == -1) {
#line 1957
        return (0);
      } else
#line 1954
      if (work->tmpl_argvec) {
#line 1954
        if (idx >= work->ntmpl_args) {
#line 1957
          return (0);
        } else {
#line 1954
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1954
        tmp = consume_count_with_underscores(mangled);
        }
#line 1954
        if (tmp == -1) {
#line 1957
          return (0);
        }
      }
#line 1959
      if (work->tmpl_argvec) {
        {
#line 1961
        string_append(tname, (char const   *)*(work->tmpl_argvec + idx));
        }
#line 1962
        if (trawname) {
          {
#line 1963
          string_append(trawname, (char const   *)*(work->tmpl_argvec + idx));
          }
        }
      } else {
        {
#line 1967
        string_append_template_idx(tname, idx);
        }
#line 1968
        if (trawname) {
          {
#line 1969
          string_append_template_idx(trawname, idx);
          }
        }
      }
    } else {
      {
#line 1974
      r = consume_count(mangled);
      }
#line 1974
      if (r <= 0) {
#line 1977
        return (0);
      } else {
        {
#line 1974
        tmp___0 = strlen(*mangled);
        }
#line 1974
        if ((int )tmp___0 < r) {
#line 1977
          return (0);
        }
      }
#line 1979
      if (work->options & (1 << 2)) {
        {
#line 1979
        tmp___1 = strncmp(*mangled, "JArray1Z", (size_t )8);
        }
#line 1979
        if (tmp___1 == 0) {
#line 1979
          tmp___2 = 1;
        } else {
#line 1979
          tmp___2 = 0;
        }
      } else {
#line 1979
        tmp___2 = 0;
      }
#line 1979
      is_java_array = tmp___2;
#line 1981
      if (! is_java_array) {
        {
#line 1983
        string_appendn(tname, *mangled, r);
        }
      }
#line 1985
      if (trawname) {
        {
#line 1986
        string_appendn(trawname, *mangled, r);
        }
      }
#line 1987
      *mangled += r;
    }
  }
#line 1990
  if (! is_java_array) {
    {
#line 1991
    string_append(tname, "<");
    }
  }
  {
#line 1993
  tmp___3 = get_count(mangled, & r);
  }
#line 1993
  if (! tmp___3) {
#line 1995
    return (0);
  }
#line 1997
  if (! is_type) {
    {
#line 2000
    tmp___4 = xmalloc(sizeof(char *) * (unsigned long )r);
#line 2000
    work->tmpl_argvec = (char **)tmp___4;
#line 2001
    work->ntmpl_args = r;
#line 2002
    i = 0;
    }
    {
#line 2002
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2002
      if (! (i < r)) {
#line 2002
        goto while_break;
      }
#line 2003
      *(work->tmpl_argvec + i) = (char *)0;
#line 2002
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2005
  i = 0;
  {
#line 2005
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2005
    if (! (i < r)) {
#line 2005
      goto while_break___0;
    }
#line 2007
    if (need_comma) {
      {
#line 2009
      string_append(tname, ", ");
      }
    }
#line 2012
    if ((int const   )*(*mangled) == 90) {
      {
#line 2014
      (*mangled) ++;
#line 2016
      success = do_type(work, mangled, & temp);
      }
#line 2017
      if (success) {
        {
#line 2019
        string_appends(tname, & temp);
        }
#line 2021
        if (! is_type) {
          {
#line 2024
          len = (int )(temp.p - temp.b);
#line 2025
          tmp___5 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 2025
          *(work->tmpl_argvec + i) = (char *)tmp___5;
#line 2026
          memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)temp.b,
                 (size_t )len);
#line 2027
          *(*(work->tmpl_argvec + i) + len) = (char )'\000';
          }
        }
      }
      {
#line 2030
      string_delete(& temp);
      }
#line 2031
      if (! success) {
#line 2033
        goto while_break___0;
      }
    } else
#line 2037
    if ((int const   )*(*mangled) == 122) {
      {
#line 2040
      (*mangled) ++;
#line 2041
      success = demangle_template_template_parm(work, mangled, tname);
      }
#line 2043
      if (success) {
        {
#line 2043
        r2 = consume_count(mangled);
        }
#line 2043
        if (r2 > 0) {
          {
#line 2043
          tmp___7 = strlen(*mangled);
          }
#line 2043
          if ((int )tmp___7 >= r2) {
            {
#line 2047
            string_append(tname, " ");
#line 2048
            string_appendn(tname, *mangled, r2);
            }
#line 2049
            if (! is_type) {
              {
#line 2052
              len___0 = r2;
#line 2053
              tmp___6 = xmalloc(sizeof(char ) * (unsigned long )(len___0 + 1));
#line 2053
              *(work->tmpl_argvec + i) = (char *)tmp___6;
#line 2054
              memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)*mangled,
                     (size_t )len___0);
#line 2055
              *(*(work->tmpl_argvec + i) + len___0) = (char )'\000';
              }
            }
#line 2057
            *mangled += r2;
          }
        }
      }
#line 2059
      if (! success) {
#line 2061
        goto while_break___0;
      }
    } else {
      {
#line 2072
      success = do_type(work, mangled, & temp);
#line 2073
      string_delete(& temp);
      }
#line 2074
      if (! success) {
#line 2075
        goto while_break___0;
      }
#line 2077
      if (! is_type) {
        {
#line 2079
        s = & param;
#line 2080
        string_init(s);
        }
      } else {
#line 2083
        s = tname;
      }
      {
#line 2085
      success = demangle_template_value_parm(work, mangled, s, (type_kind_t )success);
      }
#line 2088
      if (! success) {
#line 2090
        if (! is_type) {
          {
#line 2091
          string_delete(s);
          }
        }
#line 2092
        success = 0;
#line 2093
        goto while_break___0;
      }
#line 2096
      if (! is_type) {
        {
#line 2098
        len___1 = (int )(s->p - s->b);
#line 2099
        tmp___8 = xmalloc(sizeof(char ) * (unsigned long )(len___1 + 1));
#line 2099
        *(work->tmpl_argvec + i) = (char *)tmp___8;
#line 2100
        memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)s->b,
               (size_t )len___1);
#line 2101
        *(*(work->tmpl_argvec + i) + len___1) = (char )'\000';
#line 2103
        string_appends(tname, s);
#line 2104
        string_delete(s);
        }
      }
    }
#line 2107
    need_comma = 1;
#line 2005
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2109
  if (is_java_array) {
    {
#line 2111
    string_append(tname, "[]");
    }
  } else {
#line 2115
    if ((int )*(tname->p + -1) == 62) {
      {
#line 2116
      string_append(tname, " ");
      }
    }
    {
#line 2117
    string_append(tname, ">");
    }
  }
#line 2120
  if (is_type) {
#line 2120
    if (remember) {
      {
#line 2122
      tmp___9 = register_Btype(work);
#line 2122
      bindex = tmp___9;
      }
#line 2123
      if ((unsigned long )tname->b == (unsigned long )tname->p) {
#line 2123
        tmp___10 = 0L;
      } else {
#line 2123
        tmp___10 = tname->p - tname->b;
      }
      {
#line 2123
      remember_Btype(work, (char const   *)tname->b, (int )tmp___10, bindex);
      }
    }
  }
#line 2139
  return (success);
}
}
#line 2142 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) 
{ 
  int len ;
  char const   *tmp ;
  char *tmp___0 ;
  int len___0 ;
  int len___1 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;

  {
#line 2148
  if (work->options & (1 << 11)) {
#line 2148
    goto _L;
  } else
#line 2148
  if (work->options & (1 << 12)) {
    _L: /* CIL Label */ 
    {
#line 2148
    tmp___0 = strstr(mangled, "__pt__");
#line 2148
    tmp = (char const   *)tmp___0;
#line 2148
    *anchor = tmp;
    }
#line 2148
    if (tmp) {
      {
#line 2151
      *args = *anchor + 6;
#line 2152
      len = consume_count(args);
      }
#line 2153
      if (len == -1) {
#line 2154
        return (0);
      }
#line 2155
      if ((unsigned long )(*args + len) == (unsigned long )(mangled + n)) {
#line 2155
        if ((int const   )*(*args) == 95) {
#line 2157
          (*args) ++;
#line 2158
          return (1);
        }
      }
    }
  }
#line 2161
  if (work->options & (1 << 8)) {
#line 2161
    goto _L___1;
  } else
#line 2161
  if (work->options & (1 << 13)) {
    _L___1: /* CIL Label */ 
    {
#line 2163
    tmp___4 = strstr(mangled, "__tm__");
#line 2163
    tmp___3 = (char const   *)tmp___4;
#line 2163
    *anchor = tmp___3;
    }
#line 2163
    if (tmp___3) {
#line 2163
      goto _L___0;
    } else {
      {
#line 2163
      tmp___6 = strstr(mangled, "__ps__");
#line 2163
      tmp___5 = (char const   *)tmp___6;
#line 2163
      *anchor = tmp___5;
      }
#line 2163
      if (tmp___5) {
#line 2163
        goto _L___0;
      } else {
        {
#line 2163
        tmp___8 = strstr(mangled, "__pt__");
#line 2163
        tmp___7 = (char const   *)tmp___8;
#line 2163
        *anchor = tmp___7;
        }
#line 2163
        if (tmp___7) {
          _L___0: /* CIL Label */ 
          {
#line 2168
          *args = *anchor + 6;
#line 2169
          len___0 = consume_count(args);
          }
#line 2170
          if (len___0 == -1) {
#line 2171
            return (0);
          }
#line 2172
          if ((unsigned long )(*args + len___0) == (unsigned long )(mangled + n)) {
#line 2172
            if ((int const   )*(*args) == 95) {
#line 2174
              (*args) ++;
#line 2175
              return (1);
            }
          }
        } else {
          {
#line 2178
          tmp___2 = strstr(mangled, "__S");
#line 2178
          tmp___1 = (char const   *)tmp___2;
#line 2178
          *anchor = tmp___1;
          }
#line 2178
          if (tmp___1) {
            {
#line 2181
            *args = *anchor + 3;
#line 2182
            len___1 = consume_count(args);
            }
#line 2183
            if (len___1 == -1) {
#line 2184
              return (0);
            }
#line 2185
            if ((unsigned long )(*args + len___1) == (unsigned long )(mangled + n)) {
#line 2185
              if ((int const   )*(*args) == 95) {
#line 2187
                (*args) ++;
#line 2188
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 2193
  return (0);
}
}
#line 2196 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string___0 *declp ) 
{ 
  char const   *p ;
  char const   *args ;
  char const   *e ;
  string___0 arg ;
  char *start_spec_args ;
  int hold_options ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int hold_options___0 ;
  string___0 type_str ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *old_args ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 2202
  e = *mangled + n;
#line 2207
  if (work->options & (1 << 12)) {
#line 2207
    if ((int const   )*(*mangled + n) == 88) {
      {
#line 2209
      start_spec_args = (char *)((void *)0);
#line 2214
      start_spec_args = strchr(*mangled, '<');
      }
#line 2215
      if (start_spec_args) {
#line 2215
        if (start_spec_args - (char *)*mangled < (long )n) {
          {
#line 2216
          string_appendn(declp, *mangled, (int )(start_spec_args - (char *)*mangled));
          }
        } else {
          {
#line 2218
          string_appendn(declp, *mangled, n);
          }
        }
      } else {
        {
#line 2218
        string_appendn(declp, *mangled, n);
        }
      }
      {
#line 2219
      *mangled += n + 1;
#line 2220
      string_init(& arg);
      }
#line 2221
      if (work->temp_start == -1) {
#line 2222
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2226
      hold_options = work->options;
#line 2227
      work->options |= 1;
#line 2229
      string_append(declp, "<");
      }
      {
#line 2230
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2232
        string_delete(& arg);
        }
        {
#line 2235
        if ((int const   )*(*mangled) == 84) {
#line 2235
          goto case_84;
        }
#line 2243
        if ((int const   )*(*mangled) == 83) {
#line 2243
          goto case_83;
        }
#line 2243
        if ((int const   )*(*mangled) == 85) {
#line 2243
          goto case_83;
        }
#line 2249
        if ((int const   )*(*mangled) == 65) {
#line 2249
          goto case_65;
        }
#line 2255
        goto switch_default;
        case_84: /* CIL Label */ 
        {
#line 2237
        (*mangled) ++;
#line 2238
        tmp = do_type(work, mangled, & arg);
        }
#line 2238
        if (! tmp) {
#line 2239
          goto hpacc_template_args_done;
        }
#line 2240
        goto switch_break;
        case_83: /* CIL Label */ 
        case_85: /* CIL Label */ 
        {
#line 2245
        tmp___0 = do_hpacc_template_const_value(work, mangled, & arg);
        }
#line 2245
        if (! tmp___0) {
#line 2246
          goto hpacc_template_args_done;
        }
#line 2247
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 2251
        tmp___1 = do_hpacc_template_literal(work, mangled, & arg);
        }
#line 2251
        if (! tmp___1) {
#line 2252
          goto hpacc_template_args_done;
        }
#line 2253
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2259
        goto hpacc_template_args_done;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2261
        string_appends(declp, & arg);
        }
#line 2265
        if ((int const   )*(*mangled) == 0) {
#line 2266
          goto while_break;
        } else
#line 2265
        if ((int const   )*(*mangled) == 95) {
#line 2266
          goto while_break;
        } else {
          {
#line 2268
          string_append(declp, ",");
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      hpacc_template_args_done: 
      {
#line 2271
      string_append(declp, ">");
#line 2272
      string_delete(& arg);
      }
#line 2273
      if ((int const   )*(*mangled) == 95) {
#line 2274
        (*mangled) ++;
      }
#line 2275
      work->options = hold_options;
#line 2276
      return;
    } else {
#line 2207
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2279
    tmp___8 = arm_pt(work, *mangled, n, & p, & args);
    }
#line 2279
    if (tmp___8) {
      {
#line 2284
      string_init(& arg);
#line 2285
      string_appendn(declp, *mangled, (int )(p - *mangled));
      }
#line 2286
      if (work->temp_start == -1) {
#line 2287
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2291
      hold_options___0 = work->options;
#line 2292
      work->options |= 1;
#line 2294
      string_append(declp, "<");
      }
      {
#line 2296
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2296
        if (! ((unsigned long )args < (unsigned long )e)) {
#line 2296
          goto while_break___0;
        }
        {
#line 2297
        string_delete(& arg);
        }
        {
#line 2305
        if ((int const   )*args == 88) {
#line 2305
          goto case_88;
        }
#line 2322
        if ((int const   )*args == 76) {
#line 2322
          goto case_76;
        }
#line 2328
        goto switch_default___0;
        case_88: /* CIL Label */ 
        {
#line 2307
        args ++;
#line 2308
        tmp___2 = do_type(work, & args, & type_str);
        }
#line 2308
        if (! tmp___2) {
#line 2309
          goto cfront_template_args_done;
        }
        {
#line 2310
        string_append(& arg, "(");
#line 2311
        string_appends(& arg, & type_str);
#line 2312
        string_delete(& type_str);
#line 2313
        string_append(& arg, ")");
        }
#line 2314
        if ((int const   )*args != 76) {
#line 2315
          goto cfront_template_args_done;
        }
        {
#line 2316
        args ++;
#line 2318
        tmp___3 = snarf_numeric_literal(& args, & arg);
        }
#line 2318
        if (! tmp___3) {
#line 2319
          goto cfront_template_args_done;
        }
#line 2320
        goto switch_break___0;
        case_76: /* CIL Label */ 
        {
#line 2324
        args ++;
#line 2325
        tmp___4 = snarf_numeric_literal(& args, & arg);
        }
#line 2325
        if (! tmp___4) {
#line 2326
          goto cfront_template_args_done;
        }
#line 2327
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 2331
        old_args = args;
#line 2332
        tmp___5 = do_type(work, & args, & arg);
        }
#line 2332
        if (! tmp___5) {
#line 2333
          goto cfront_template_args_done;
        }
#line 2336
        if ((unsigned long )args == (unsigned long )old_args) {
#line 2338
          work->options = hold_options___0;
#line 2339
          return;
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 2343
        string_appends(declp, & arg);
#line 2344
        string_append(declp, ",");
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      cfront_template_args_done: 
      {
#line 2347
      string_delete(& arg);
      }
#line 2348
      if ((unsigned long )args >= (unsigned long )e) {
#line 2349
        (declp->p) --;
      }
      {
#line 2350
      string_append(declp, ">");
#line 2351
      work->options = hold_options___0;
      }
    } else
#line 2353
    if (n > 10) {
      {
#line 2353
      tmp___6 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2353
      if (tmp___6 == 0) {
#line 2353
        if ((int const   )*(*mangled + 9) == 78) {
#line 2353
          if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
            {
#line 2353
            tmp___7 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
            }
#line 2353
            if (tmp___7) {
              {
#line 2359
              string_append(declp, "{anonymous}");
              }
            } else {
#line 2353
              goto _L___2;
            }
          } else {
#line 2353
            goto _L___2;
          }
        } else {
#line 2353
          goto _L___2;
        }
      } else {
#line 2353
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 2363
      if (work->temp_start == -1) {
#line 2364
        work->temp_start = 0;
      }
      {
#line 2365
      string_appendn(declp, *mangled, n);
      }
    }
  }
#line 2367
  *mangled += n;
#line 2368
  return;
}
}
#line 2374 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string___0 *declp ) 
{ 
  int n ;
  int success ;
  size_t tmp ;

  {
  {
#line 2379
  success = 0;
#line 2381
  n = consume_count(mangled);
  }
#line 2382
  if (n == -1) {
#line 2383
    return (0);
  }
  {
#line 2384
  tmp = strlen(*mangled);
  }
#line 2384
  if ((int )tmp >= n) {
    {
#line 2386
    demangle_arm_hp_template(work, mangled, n, declp);
#line 2387
    success = 1;
    }
  }
#line 2390
  return (success);
}
}
#line 2428 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_class(struct work_stuff *work , char const   **mangled , string___0 *declp ) 
{ 
  int success ;
  int btype ;
  string___0 class_name ;
  char *save_class_name_end ;
  long tmp ;
  long tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2431
  success = 0;
#line 2434
  save_class_name_end = (char *)0;
#line 2436
  string_init(& class_name);
#line 2437
  btype = register_Btype(work);
#line 2438
  tmp___2 = demangle_class_name(work, mangled, & class_name);
  }
#line 2438
  if (tmp___2) {
#line 2440
    save_class_name_end = class_name.p;
#line 2441
    if (work->constructor & 1) {
#line 2441
      goto _L;
    } else
#line 2441
    if (work->destructor & 1) {
      _L: /* CIL Label */ 
#line 2444
      if (work->temp_start) {
#line 2444
        if (work->temp_start != -1) {
#line 2446
          class_name.p = class_name.b + work->temp_start;
        }
      }
      {
#line 2448
      string_prepends(declp, & class_name);
      }
#line 2449
      if (work->destructor & 1) {
        {
#line 2451
        string_prepend(declp, "~");
#line 2452
        (work->destructor) --;
        }
      } else {
#line 2456
        (work->constructor) --;
      }
    }
#line 2459
    class_name.p = save_class_name_end;
#line 2460
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2460
      tmp = 0L;
    } else {
#line 2460
      tmp = class_name.p - class_name.b;
    }
    {
#line 2460
    remember_Ktype(work, (char const   *)class_name.b, (int )tmp);
    }
#line 2461
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2461
      tmp___0 = 0L;
    } else {
#line 2461
      tmp___0 = class_name.p - class_name.b;
    }
    {
#line 2461
    remember_Btype(work, (char const   *)class_name.b, (int )tmp___0, btype);
    }
#line 2462
    if (work->options & (1 << 2)) {
#line 2462
      tmp___1 = ".";
    } else {
#line 2462
      tmp___1 = "::";
    }
    {
#line 2462
    string_prepend(declp, tmp___1);
#line 2463
    string_prepends(declp, & class_name);
#line 2464
    success = 1;
    }
  }
  {
#line 2466
  string_delete(& class_name);
  }
#line 2467
  return (success);
}
}
#line 2480 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string___0 *declp , char const   *scan ) 
{ 
  char const   *mangle_init ;
  int success ;
  string___0 decl_init ;
  struct work_stuff work_init ;
  char *tmp ;

  {
#line 2484
  mangle_init = *mangled;
#line 2485
  success = 0;
#line 2489
  if ((int const   )*(scan + 2) == 0) {
#line 2490
    return (0);
  }
#line 2494
  if (work->options & (1 << 11)) {
    {
#line 2497
    demangle_function_name(work, mangled, declp, scan);
    }
#line 2498
    return (1);
  } else
#line 2494
  if (work->options & (1 << 10)) {
    {
#line 2497
    demangle_function_name(work, mangled, declp, scan);
    }
#line 2498
    return (1);
  } else
#line 2494
  if (work->options & (1 << 12)) {
    {
#line 2497
    demangle_function_name(work, mangled, declp, scan);
    }
#line 2498
    return (1);
  } else
#line 2494
  if (work->options & (1 << 13)) {
    {
#line 2497
    demangle_function_name(work, mangled, declp, scan);
    }
#line 2498
    return (1);
  } else {
    {
#line 2494
    tmp = strstr(scan + 2, "__");
    }
#line 2494
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 2497
      demangle_function_name(work, mangled, declp, scan);
      }
#line 2498
      return (1);
    }
  }
  {
#line 2503
  string_init(& decl_init);
#line 2504
  string_appends(& decl_init, declp);
#line 2505
  memset((void *)(& work_init), 0, sizeof(work_init));
#line 2506
  work_stuff_copy_to_from(& work_init, work);
  }
  {
#line 2514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2514
    if (! *(scan + 2)) {
#line 2514
      goto while_break;
    }
    {
#line 2516
    demangle_function_name(work, mangled, declp, scan);
#line 2517
    success = demangle_signature(work, mangled, declp);
    }
#line 2518
    if (success) {
#line 2519
      goto while_break;
    }
    {
#line 2522
    *mangled = mangle_init;
#line 2523
    string_clear(declp);
#line 2524
    string_appends(declp, & decl_init);
#line 2525
    work_stuff_copy_to_from(work, & work_init);
#line 2528
    scan += 2;
    }
    {
#line 2531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2531
      if (*scan) {
#line 2531
        if (! ((int const   )*(scan + 0) != 95)) {
#line 2531
          if (! ((int const   )*(scan + 1) != 95)) {
#line 2531
            goto while_break___0;
          }
        }
      } else {
#line 2531
        goto while_break___0;
      }
#line 2532
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2535
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2535
      if (*scan) {
#line 2535
        if (! ((int const   )*scan == 95)) {
#line 2535
          goto while_break___1;
        }
      } else {
#line 2535
        goto while_break___1;
      }
#line 2536
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2537
    scan -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2541
  delete_work_stuff(& work_init);
#line 2542
  string_delete(& decl_init);
  }
#line 2544
  return (success);
}
}
#line 2580 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string___0 *declp ) 
{ 
  int success ;
  char const   *scan ;
  int i ;
  char *marker ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;

  {
  {
#line 2584
  success = 1;
#line 2588
  tmp___6 = strlen(*mangled);
  }
#line 2588
  if (tmp___6 > 6UL) {
    {
#line 2588
    tmp___7 = strncmp(*mangled, "_imp__", (size_t )6);
    }
#line 2588
    if (tmp___7 == 0) {
#line 2595
      *mangled += 6;
#line 2596
      work->dllimported = 1;
    } else {
      {
#line 2588
      tmp___8 = strncmp(*mangled, "__imp_", (size_t )6);
      }
#line 2588
      if (tmp___8 == 0) {
#line 2595
        *mangled += 6;
#line 2596
        work->dllimported = 1;
      } else {
#line 2588
        goto _L___3;
      }
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2598
    tmp___4 = strlen(*mangled);
    }
#line 2598
    if (tmp___4 >= 11UL) {
      {
#line 2598
      tmp___5 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2598
      if (tmp___5 == 0) {
        {
#line 2600
        tmp = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
#line 2600
        marker = tmp;
        }
#line 2601
        if ((unsigned long )marker != (unsigned long )((void *)0)) {
#line 2601
          if ((int )*marker == (int )*(*mangled + 10)) {
#line 2603
            if ((int const   )*(*mangled + 9) == 68) {
              {
#line 2606
              *mangled += 11;
#line 2607
              work->destructor = 2;
#line 2608
              tmp___0 = gnu_special(work, mangled, declp);
              }
#line 2608
              if (tmp___0) {
#line 2609
                return (success);
              }
            } else
#line 2611
            if ((int const   )*(*mangled + 9) == 73) {
              {
#line 2614
              *mangled += 11;
#line 2615
              work->constructor = 2;
#line 2616
              tmp___1 = gnu_special(work, mangled, declp);
              }
#line 2616
              if (tmp___1) {
#line 2617
                return (success);
              }
            }
          }
        }
      } else {
#line 2598
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2621
    if (work->options & (1 << 11)) {
#line 2621
      goto _L___1;
    } else
#line 2621
    if (work->options & (1 << 12)) {
#line 2621
      goto _L___1;
    } else
#line 2621
    if (work->options & (1 << 13)) {
      _L___1: /* CIL Label */ 
      {
#line 2621
      tmp___3 = strncmp(*mangled, "__std__", (size_t )7);
      }
#line 2621
      if (tmp___3 == 0) {
#line 2624
        *mangled += 7;
#line 2625
        work->destructor = 2;
      } else {
#line 2621
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2627
    if (work->options & (1 << 11)) {
#line 2627
      goto _L;
    } else
#line 2627
    if (work->options & (1 << 12)) {
#line 2627
      goto _L;
    } else
#line 2627
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
      {
#line 2627
      tmp___2 = strncmp(*mangled, "__sti__", (size_t )7);
      }
#line 2627
      if (tmp___2 == 0) {
#line 2630
        *mangled += 7;
#line 2631
        work->constructor = 2;
      }
    }
  }
#line 2639
  scan = *mangled;
  {
#line 2641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2642
    tmp___9 = strchr(scan, '_');
#line 2642
    scan = (char const   *)tmp___9;
    }
#line 2641
    if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2641
      scan ++;
#line 2641
      if (! ((int const   )*scan != 95)) {
#line 2641
        goto while_break;
      }
    } else {
#line 2641
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2645
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2645
    scan --;
  }
#line 2648
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
    {
#line 2652
    tmp___10 = strspn(scan, "_");
#line 2652
    i = (int )tmp___10;
    }
#line 2653
    if (i > 2) {
#line 2655
      scan += i - 2;
    }
  }
#line 2659
  if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2661
    success = 0;
  } else
#line 2663
  if (work->static_type) {
#line 2665
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 0)) & 255] & 4)) {
#line 2665
      if ((int const   )*(scan + 0) != 116) {
#line 2667
        success = 0;
      }
    }
  } else
#line 2670
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2670
    if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
#line 2670
      goto _L___16;
    } else
#line 2670
    if ((int const   )*(scan + 2) == 81) {
#line 2670
      goto _L___16;
    } else
#line 2670
    if ((int const   )*(scan + 2) == 116) {
#line 2670
      goto _L___16;
    } else
#line 2670
    if ((int const   )*(scan + 2) == 75) {
#line 2670
      goto _L___16;
    } else
#line 2670
    if ((int const   )*(scan + 2) == 72) {
      _L___16: /* CIL Label */ 
#line 2677
      if (work->options & (1 << 10)) {
#line 2677
        goto _L___5;
      } else
#line 2677
      if (work->options & (1 << 11)) {
#line 2677
        goto _L___5;
      } else
#line 2677
      if (work->options & (1 << 12)) {
        _L___5: /* CIL Label */ 
#line 2677
        if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
          {
#line 2680
          *mangled = scan + 2;
#line 2681
          consume_count(mangled);
#line 2682
          string_append(declp, *mangled);
#line 2683
          tmp___11 = strlen(*mangled);
#line 2683
          *mangled += tmp___11;
#line 2684
          success = 1;
          }
        } else {
#line 2677
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 2692
        if (! (work->options & (1 << 10))) {
#line 2692
          if (! (work->options & (1 << 11))) {
#line 2692
            if (! (work->options & (1 << 12))) {
#line 2692
              if (! (work->options & (1 << 13))) {
#line 2693
                (work->constructor) ++;
              }
            }
          }
        }
#line 2694
        *mangled = scan + 2;
      }
    } else {
#line 2670
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 2697
  if (work->options & (1 << 11)) {
#line 2697
    if ((int const   )*(scan + 2) == 112) {
#line 2697
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2700
        success = 1;
#line 2703
        tmp___12 = strlen(*mangled);
#line 2703
        demangle_arm_hp_template(work, mangled, (int )tmp___12, declp);
        }
      } else {
#line 2697
        goto _L___14;
      }
    } else {
#line 2697
      goto _L___14;
    }
  } else
  _L___14: /* CIL Label */ 
#line 2705
  if (work->options & (1 << 13)) {
#line 2705
    if ((int const   )*(scan + 2) == 116) {
#line 2705
      if ((int const   )*(scan + 3) == 109) {
        {
#line 2710
        success = 1;
#line 2713
        tmp___13 = strlen(*mangled);
#line 2713
        demangle_arm_hp_template(work, mangled, (int )tmp___13, declp);
        }
      } else {
#line 2705
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 2705
    if ((int const   )*(scan + 2) == 112) {
#line 2705
      if ((int const   )*(scan + 3) == 115) {
        {
#line 2710
        success = 1;
#line 2713
        tmp___13 = strlen(*mangled);
#line 2713
        demangle_arm_hp_template(work, mangled, (int )tmp___13, declp);
        }
      } else {
#line 2705
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 2705
    if ((int const   )*(scan + 2) == 112) {
#line 2705
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2710
        success = 1;
#line 2713
        tmp___13 = strlen(*mangled);
#line 2713
        demangle_arm_hp_template(work, mangled, (int )tmp___13, declp);
        }
      } else {
#line 2705
        goto _L___10;
      }
    } else {
#line 2705
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2715
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2715
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4)) {
#line 2715
      if ((int const   )*(scan + 2) != 116) {
#line 2721
        if (work->options & (1 << 11)) {
#line 2721
          goto _L___7;
        } else
#line 2721
        if (work->options & (1 << 10)) {
#line 2721
          goto _L___7;
        } else
#line 2721
        if (work->options & (1 << 12)) {
#line 2721
          goto _L___7;
        } else
#line 2721
        if (work->options & (1 << 13)) {
          _L___7: /* CIL Label */ 
          {
#line 2721
          tmp___16 = arm_special(mangled, declp);
          }
#line 2721
          if (tmp___16 == 0) {
            _L___6: /* CIL Label */ 
            {
#line 2724
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 2724
              if (! ((int const   )*scan == 95)) {
#line 2724
                goto while_break___0;
              }
#line 2726
              scan ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 2728
            tmp___15 = strstr(scan, "__");
#line 2728
            scan = (char const   *)tmp___15;
            }
#line 2728
            if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2732
              success = 0;
            } else
#line 2728
            if ((int const   )*(scan + 2) == 0) {
#line 2732
              success = 0;
            } else {
              {
#line 2735
              tmp___14 = iterate_demangle_function(work, mangled, declp, scan);
              }
#line 2735
              return (tmp___14);
            }
          }
        } else {
#line 2721
          goto _L___6;
        }
      } else {
#line 2715
        goto _L___9;
      }
    } else {
#line 2715
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2738
  if ((int const   )*(scan + 2) != 0) {
    {
#line 2744
    tmp___17 = iterate_demangle_function(work, mangled, declp, scan);
    }
#line 2744
    return (tmp___17);
  } else {
#line 2749
    success = 0;
  }
#line 2752
  if (! success) {
#line 2752
    if (work->constructor == 2) {
      {
#line 2754
      string_append(declp, *mangled);
#line 2755
      tmp___18 = strlen(*mangled);
#line 2755
      *mangled += tmp___18;
#line 2756
      success = 1;
      }
    } else
#line 2752
    if (work->destructor == 2) {
      {
#line 2754
      string_append(declp, *mangled);
#line 2755
      tmp___18 = strlen(*mangled);
#line 2755
      *mangled += tmp___18;
#line 2756
      success = 1;
      }
    }
  }
#line 2758
  return (success);
}
}
#line 2789 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int gnu_special(struct work_stuff *work , char const   **mangled , string___0 *declp ) 
{ 
  int n ;
  int success ;
  char const   *p ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  int delta ;
  char *method ;
  char *tmp___9 ;
  char buf___0[50] ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 2793
  success = 1;
#line 2796
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 2796
    tmp___16 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 1));
    }
#line 2796
    if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 2796
      if ((int const   )*(*mangled + 2) == 95) {
#line 2801
        *mangled += 3;
#line 2802
        (work->destructor) ++;
      } else {
#line 2796
        goto _L___9;
      }
    } else {
#line 2796
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2804
  if ((int const   )*(*mangled + 0) == 95) {
#line 2804
    if ((int const   )*(*mangled + 1) == 95) {
#line 2804
      if ((int const   )*(*mangled + 2) == 118) {
#line 2804
        if ((int const   )*(*mangled + 3) == 116) {
#line 2804
          if ((int const   )*(*mangled + 4) == 95) {
#line 2804
            goto _L___4;
          } else {
#line 2804
            goto _L___7;
          }
        } else {
#line 2804
          goto _L___7;
        }
      } else {
#line 2804
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 2804
    if ((int const   )*(*mangled + 1) == 118) {
#line 2804
      if ((int const   )*(*mangled + 2) == 116) {
        {
#line 2804
        tmp___15 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 3));
        }
#line 2804
        if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
          _L___4: /* CIL Label */ 
#line 2817
          if ((int const   )*(*mangled + 2) == 118) {
#line 2818
            *mangled += 5;
          } else {
#line 2820
            *mangled += 4;
          }
          {
#line 2821
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2821
            if (! ((int const   )*(*mangled) != 0)) {
#line 2821
              goto while_break;
            }
            {
#line 2826
            if ((int const   )*(*mangled) == 75) {
#line 2826
              goto case_75;
            }
#line 2826
            if ((int const   )*(*mangled) == 81) {
#line 2826
              goto case_75;
            }
#line 2829
            if ((int const   )*(*mangled) == 116) {
#line 2829
              goto case_116;
            }
#line 2833
            goto switch_default;
            case_75: /* CIL Label */ 
            case_81: /* CIL Label */ 
            {
#line 2827
            success = demangle_qualified(work, mangled, declp, 0, 1);
            }
#line 2828
            goto switch_break;
            case_116: /* CIL Label */ 
            {
#line 2830
            success = demangle_template(work, mangled, declp, (string___0 *)0, 1,
                                        1);
            }
#line 2832
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 2834
            if ((int const   )_sch_istable[(int )((unsigned char )*(*(mangled + 0))) & 255] & 4) {
              {
#line 2836
              n = consume_count(mangled);
#line 2841
              tmp = strlen(*mangled);
              }
#line 2841
              if (n > (int )tmp) {
#line 2843
                success = 1;
#line 2844
                goto switch_break;
              }
            } else {
              {
#line 2849
              tmp___0 = strcspn(*mangled, (char const   *)(cplus_markers));
#line 2849
              n = (int )tmp___0;
              }
            }
            {
#line 2851
            string_appendn(declp, *mangled, n);
#line 2852
            *mangled += n;
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 2855
            tmp___1 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 2855
            p = (char const   *)tmp___1;
            }
#line 2856
            if (success) {
#line 2856
              if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2856
                goto _L;
              } else
#line 2856
              if ((unsigned long )p == (unsigned long )*mangled) {
                _L: /* CIL Label */ 
#line 2858
                if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2860
                  if (work->options & (1 << 2)) {
#line 2860
                    tmp___2 = ".";
                  } else {
#line 2860
                    tmp___2 = "::";
                  }
                  {
#line 2860
                  string_append(declp, tmp___2);
#line 2861
                  (*mangled) ++;
                  }
                }
              } else {
#line 2866
                success = 0;
#line 2867
                goto while_break;
              }
            } else {
#line 2866
              success = 0;
#line 2867
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 2870
          if (success) {
            {
#line 2871
            string_append(declp, " virtual table");
            }
          }
        } else {
#line 2804
          goto _L___3;
        }
      } else {
#line 2804
        goto _L___3;
      }
    } else {
#line 2804
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2873
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 2873
    tmp___13 = strchr("0123456789Qt", (int )*(*mangled + 1));
    }
#line 2873
    if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
      {
#line 2873
      tmp___14 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 2873
      p = (char const   *)tmp___14;
      }
#line 2873
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2878
        (*mangled) ++;
        {
#line 2882
        if ((int const   )*(*mangled) == 75) {
#line 2882
          goto case_75___0;
        }
#line 2882
        if ((int const   )*(*mangled) == 81) {
#line 2882
          goto case_75___0;
        }
#line 2885
        if ((int const   )*(*mangled) == 116) {
#line 2885
          goto case_116___0;
        }
#line 2888
        goto switch_default___0;
        case_75___0: /* CIL Label */ 
        case_81___0: /* CIL Label */ 
        {
#line 2883
        success = demangle_qualified(work, mangled, declp, 0, 1);
        }
#line 2884
        goto switch_break___0;
        case_116___0: /* CIL Label */ 
        {
#line 2886
        success = demangle_template(work, mangled, declp, (string___0 *)0, 1, 1);
        }
#line 2887
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 2889
        n = consume_count(mangled);
        }
#line 2890
        if (n < 0) {
#line 2892
          success = 0;
#line 2893
          goto switch_break___0;
        } else {
          {
#line 2890
          tmp___3 = strlen(*mangled);
          }
#line 2890
          if ((long )n > (long )tmp___3) {
#line 2892
            success = 0;
#line 2893
            goto switch_break___0;
          }
        }
#line 2896
        if (n > 10) {
          {
#line 2896
          tmp___5 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
          }
#line 2896
          if (tmp___5 == 0) {
#line 2896
            if ((int const   )*(*mangled + 9) == 78) {
#line 2896
              if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
                {
#line 2896
                tmp___6 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
                }
#line 2896
                if (tmp___6) {
                  {
#line 2905
                  string_append(declp, "{anonymous}");
#line 2906
                  *mangled += n;
#line 2910
                  tmp___4 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 2910
                  p = (char const   *)tmp___4;
                  }
#line 2911
                  goto switch_break___0;
                }
              }
            }
          }
        }
        {
#line 2914
        string_appendn(declp, *mangled, n);
#line 2915
        *mangled += n;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 2917
        if (success) {
#line 2917
          if ((unsigned long )p == (unsigned long )*mangled) {
#line 2921
            (*mangled) ++;
#line 2922
            if (work->options & (1 << 2)) {
#line 2922
              tmp___7 = ".";
            } else {
#line 2922
              tmp___7 = "::";
            }
            {
#line 2922
            string_append(declp, tmp___7);
#line 2923
            tmp___8 = strlen(*mangled);
#line 2923
            n = (int )tmp___8;
#line 2924
            string_appendn(declp, *mangled, n);
#line 2925
            *mangled += n;
            }
          } else {
#line 2929
            success = 0;
          }
        } else {
#line 2929
          success = 0;
        }
      } else {
#line 2873
        goto _L___2;
      }
    } else {
#line 2873
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 2932
    tmp___12 = strncmp(*mangled, "__thunk_", (size_t )8);
    }
#line 2932
    if (tmp___12 == 0) {
      {
#line 2936
      *mangled += 8;
#line 2937
      delta = consume_count(mangled);
      }
#line 2938
      if (delta == -1) {
#line 2939
        success = 0;
      } else {
        {
#line 2942
        (*mangled) ++;
#line 2942
        tmp___9 = internal_cplus_demangle(work, *mangled);
#line 2942
        method = tmp___9;
        }
#line 2944
        if (method) {
          {
#line 2947
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"virtual function thunk (delta:%d) for ",
                  - delta);
#line 2948
          string_append(declp, (char const   *)(buf___0));
#line 2949
          string_append(declp, (char const   *)method);
#line 2950
          free((void *)method);
#line 2951
          tmp___10 = strlen(*mangled);
#line 2951
          n = (int )tmp___10;
#line 2952
          *mangled += n;
          }
        } else {
#line 2956
          success = 0;
        }
      }
    } else {
      {
#line 2960
      tmp___11 = strncmp(*mangled, "__t", (size_t )3);
      }
#line 2960
      if (tmp___11 == 0) {
#line 2960
        if ((int const   )*(*mangled + 3) == 105) {
#line 2960
          goto _L___0;
        } else
#line 2960
        if ((int const   )*(*mangled + 3) == 102) {
          _L___0: /* CIL Label */ 
#line 2963
          if ((int const   )*(*mangled + 3) == 105) {
#line 2963
            p = " type_info node";
          } else {
#line 2963
            p = " type_info function";
          }
#line 2964
          *mangled += 4;
          {
#line 2968
          if ((int const   )*(*mangled) == 75) {
#line 2968
            goto case_75___1;
          }
#line 2968
          if ((int const   )*(*mangled) == 81) {
#line 2968
            goto case_75___1;
          }
#line 2971
          if ((int const   )*(*mangled) == 116) {
#line 2971
            goto case_116___1;
          }
#line 2974
          goto switch_default___1;
          case_75___1: /* CIL Label */ 
          case_81___1: /* CIL Label */ 
          {
#line 2969
          success = demangle_qualified(work, mangled, declp, 0, 1);
          }
#line 2970
          goto switch_break___1;
          case_116___1: /* CIL Label */ 
          {
#line 2972
          success = demangle_template(work, mangled, declp, (string___0 *)0, 1, 1);
          }
#line 2973
          goto switch_break___1;
          switch_default___1: /* CIL Label */ 
          {
#line 2975
          success = do_type(work, mangled, declp);
          }
#line 2976
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 2978
          if (success) {
#line 2978
            if ((int const   )*(*mangled) != 0) {
#line 2979
              success = 0;
            }
          }
#line 2980
          if (success) {
            {
#line 2981
            string_append(declp, p);
            }
          }
        } else {
#line 2985
          success = 0;
        }
      } else {
#line 2985
        success = 0;
      }
    }
  }
#line 2987
  return (success);
}
}
#line 2990 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string___0 *result , int namelength ) 
{ 
  char *recurse ;
  char *recurse_dem ;
  void *tmp ;

  {
  {
#line 2994
  recurse = (char *)((void *)0);
#line 2995
  recurse_dem = (char *)((void *)0);
#line 2997
  tmp = xmalloc(sizeof(char ) * (unsigned long )(namelength + 1));
#line 2997
  recurse = (char *)tmp;
#line 2998
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )namelength);
#line 2999
  *(recurse + namelength) = (char )'\000';
#line 3001
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 3003
  if (recurse_dem) {
    {
#line 3005
    string_append(result, (char const   *)recurse_dem);
#line 3006
    free((void *)recurse_dem);
    }
  } else {
    {
#line 3010
    string_appendn(result, *mangled, namelength);
    }
  }
  {
#line 3012
  free((void *)recurse);
#line 3013
  *mangled += namelength;
  }
#line 3014
  return;
}
}
#line 3039 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int arm_special(char const   **mangled , string___0 *declp ) 
{ 
  int n ;
  int success ;
  char const   *scan ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 3043
  success = 1;
#line 3046
  tmp___0 = strncmp(*mangled, "__vtbl__", (size_t )8);
  }
#line 3046
  if (tmp___0 == 0) {
#line 3052
    scan = *mangled + 8;
    {
#line 3053
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3053
      if (! ((int const   )*scan != 0)) {
#line 3053
        goto while_break;
      }
      {
#line 3055
      n = consume_count(& scan);
      }
#line 3056
      if (n == -1) {
#line 3058
        return (0);
      }
#line 3060
      scan += n;
#line 3061
      if ((int const   )*(scan + 0) == 95) {
#line 3061
        if ((int const   )*(scan + 1) == 95) {
#line 3063
          scan += 2;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3066
    *mangled += 8;
    {
#line 3067
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3067
      if (! ((int const   )*(*mangled) != 0)) {
#line 3067
        goto while_break___0;
      }
      {
#line 3069
      n = consume_count(mangled);
      }
#line 3070
      if (n == -1) {
#line 3072
        return (0);
      } else {
        {
#line 3070
        tmp = strlen(*mangled);
        }
#line 3070
        if ((long )n > (long )tmp) {
#line 3072
          return (0);
        }
      }
      {
#line 3073
      string_prependn(declp, *mangled, n);
#line 3074
      *mangled += n;
      }
#line 3075
      if ((int const   )*(*mangled + 0) == 95) {
#line 3075
        if ((int const   )*(*mangled + 1) == 95) {
          {
#line 3077
          string_prepend(declp, "::");
#line 3078
          *mangled += 2;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3081
    string_append(declp, " virtual table");
    }
  } else {
#line 3085
    success = 0;
  }
#line 3087
  return (success);
}
}
#line 3122 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string___0 *result ,
                              int isfuncname , int append ) 
{ 
  int qualifiers ;
  int success ;
  char num[2] ;
  string___0 temp ;
  string___0 last_name ;
  int bindex ;
  int tmp ;
  int tmp___0 ;
  int idx ;
  int remember_K ;
  int idx___0 ;
  int namelength ;
  long tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 3126
  qualifiers = 0;
#line 3127
  success = 1;
#line 3131
  tmp = register_Btype(work);
#line 3131
  bindex = tmp;
  }
#line 3135
  if (isfuncname) {
#line 3135
    if (work->constructor & 1) {
#line 3135
      tmp___0 = 1;
    } else
#line 3135
    if (work->destructor & 1) {
#line 3135
      tmp___0 = 1;
    } else {
#line 3135
      tmp___0 = 0;
    }
  } else {
#line 3135
    tmp___0 = 0;
  }
  {
#line 3135
  isfuncname = tmp___0;
#line 3138
  string_init(& temp);
#line 3139
  string_init(& last_name);
  }
#line 3141
  if ((int const   )*(*mangled + 0) == 75) {
    {
#line 3145
    (*mangled) ++;
#line 3146
    idx = consume_count_with_underscores(mangled);
    }
#line 3147
    if (idx == -1) {
#line 3148
      success = 0;
    } else
#line 3147
    if (idx >= work->numk) {
#line 3148
      success = 0;
    } else {
      {
#line 3150
      string_append(& temp, (char const   *)*(work->ktypevec + idx));
      }
    }
  } else {
    {
#line 3155
    if ((int const   )*(*mangled + 1) == 95) {
#line 3155
      goto case_95;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 57) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 56) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 55) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 54) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 53) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 52) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 51) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 50) {
#line 3173
      goto case_57;
    }
#line 3173
    if ((int const   )*(*mangled + 1) == 49) {
#line 3173
      goto case_57;
    }
#line 3190
    goto switch_default;
    case_95: /* CIL Label */ 
    {
#line 3159
    (*mangled) ++;
#line 3160
    qualifiers = consume_count_with_underscores(mangled);
    }
#line 3161
    if (qualifiers == -1) {
#line 3162
      success = 0;
    }
#line 3163
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 3175
    num[0] = (char )*(*mangled + 1);
#line 3176
    num[1] = (char )'\000';
#line 3177
    qualifiers = atoi((char const   *)(num));
    }
#line 3182
    if ((int const   )*(*mangled + 2) == 95) {
#line 3184
      (*mangled) ++;
    }
#line 3186
    *mangled += 2;
#line 3187
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3191
    success = 0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3194
  if (! success) {
#line 3195
    return (success);
  }
  {
#line 3200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3200
    tmp___3 = qualifiers;
#line 3200
    qualifiers --;
#line 3200
    if (! (tmp___3 > 0)) {
#line 3200
      goto while_break;
    }
    {
#line 3202
    remember_K = 1;
#line 3203
    string_clear(& last_name);
    }
#line 3205
    if ((int const   )*(*(mangled + 0)) == 95) {
#line 3206
      (*mangled) ++;
    }
#line 3208
    if ((int const   )*(*(mangled + 0)) == 116) {
      {
#line 3216
      success = demangle_template(work, mangled, & temp, & last_name, 1, 0);
      }
#line 3218
      if (! success) {
#line 3219
        goto while_break;
      }
    } else
#line 3221
    if ((int const   )*(*(mangled + 0)) == 75) {
      {
#line 3224
      (*mangled) ++;
#line 3225
      idx___0 = consume_count_with_underscores(mangled);
      }
#line 3226
      if (idx___0 == -1) {
#line 3227
        success = 0;
      } else
#line 3226
      if (idx___0 >= work->numk) {
#line 3227
        success = 0;
      } else {
        {
#line 3229
        string_append(& temp, (char const   *)*(work->ktypevec + idx___0));
        }
      }
#line 3230
      remember_K = 0;
#line 3232
      if (! success) {
#line 3232
        goto while_break;
      }
    } else
#line 3236
    if (work->options & (1 << 13)) {
      {
#line 3242
      namelength = consume_count(mangled);
      }
#line 3243
      if (namelength == -1) {
#line 3245
        success = 0;
#line 3246
        goto while_break;
      }
      {
#line 3248
      recursively_demangle(work, mangled, & temp, namelength);
      }
    } else {
      {
#line 3252
      string_delete(& last_name);
#line 3253
      success = do_type(work, mangled, & last_name);
      }
#line 3254
      if (! success) {
#line 3255
        goto while_break;
      }
      {
#line 3256
      string_appends(& temp, & last_name);
      }
    }
#line 3260
    if (remember_K) {
#line 3261
      if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3261
        tmp___1 = 0L;
      } else {
#line 3261
        tmp___1 = temp.p - temp.b;
      }
      {
#line 3261
      remember_Ktype(work, (char const   *)temp.b, (int )tmp___1);
      }
    }
#line 3263
    if (qualifiers > 0) {
#line 3264
      if (work->options & (1 << 2)) {
#line 3264
        tmp___2 = ".";
      } else {
#line 3264
        tmp___2 = "::";
      }
      {
#line 3264
      string_append(& temp, tmp___2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3267
  if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3267
    tmp___4 = 0L;
  } else {
#line 3267
    tmp___4 = temp.p - temp.b;
  }
  {
#line 3267
  remember_Btype(work, (char const   *)temp.b, (int )tmp___4, bindex);
  }
#line 3274
  if (isfuncname) {
#line 3276
    if (work->options & (1 << 2)) {
#line 3276
      tmp___5 = ".";
    } else {
#line 3276
      tmp___5 = "::";
    }
    {
#line 3276
    string_append(& temp, tmp___5);
    }
#line 3277
    if (work->destructor & 1) {
      {
#line 3278
      string_append(& temp, "~");
      }
    }
    {
#line 3279
    string_appends(& temp, & last_name);
    }
  }
#line 3285
  if (append) {
    {
#line 3286
    string_appends(result, & temp);
    }
  } else {
#line 3289
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
#line 3290
      if (work->options & (1 << 2)) {
#line 3290
        tmp___6 = ".";
      } else {
#line 3290
        tmp___6 = "::";
      }
      {
#line 3290
      string_append(& temp, tmp___6);
      }
    }
    {
#line 3291
    string_prepends(result, & temp);
    }
  }
  {
#line 3294
  string_delete(& last_name);
#line 3295
  string_delete(& temp);
  }
#line 3296
  return (success);
}
}
#line 3345 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int get_count(char const   **type , int *count ) 
{ 
  char const   *p ;
  int n ;

  {
#line 3351
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 3352
    return (0);
  } else {
#line 3355
    *count = (int )((int const   )*(*type) - 48);
#line 3356
    (*type) ++;
#line 3357
    if ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4) {
#line 3359
      p = *type;
#line 3360
      n = *count;
      {
#line 3361
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3363
        n *= 10;
#line 3364
        n += (int )((int const   )*p - 48);
#line 3365
        p ++;
#line 3361
        if (! ((int const   )_sch_istable[(int )((unsigned char )*p) & 255] & 4)) {
#line 3361
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3368
      if ((int const   )*p == 95) {
#line 3370
        *type = p + 1;
#line 3371
        *count = n;
      }
    }
  }
#line 3375
  return (1);
}
}
#line 3381 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int do_type(struct work_stuff *work , char const   **mangled , string___0 *result ) 
{ 
  int n ;
  int done ;
  int success ;
  string___0 decl ;
  char const   *remembered_type ;
  int type_quals ;
  type_kind_t tk ;
  int member ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  string___0 temp ;
  string___0 temp___0 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int idx ;
  int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 3390
  tk = (type_kind_t )0;
#line 3392
  string_init(& decl);
#line 3393
  string_init(result);
#line 3395
  done = 0;
#line 3396
  success = 1;
  }
  {
#line 3397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3397
    if (success) {
#line 3397
      if (! (! done)) {
#line 3397
        goto while_break;
      }
    } else {
#line 3397
      goto while_break;
    }
    {
#line 3405
    if ((int const   )*(*mangled) == 112) {
#line 3405
      goto case_112;
    }
#line 3405
    if ((int const   )*(*mangled) == 80) {
#line 3405
      goto case_112;
    }
#line 3414
    if ((int const   )*(*mangled) == 82) {
#line 3414
      goto case_82;
    }
#line 3422
    if ((int const   )*(*mangled) == 65) {
#line 3422
      goto case_65;
    }
#line 3442
    if ((int const   )*(*mangled) == 84) {
#line 3442
      goto case_84;
    }
#line 3456
    if ((int const   )*(*mangled) == 70) {
#line 3456
      goto case_70;
    }
#line 3478
    if ((int const   )*(*mangled) == 79) {
#line 3478
      goto case_79;
    }
#line 3478
    if ((int const   )*(*mangled) == 77) {
#line 3478
      goto case_79;
    }
#line 3579
    if ((int const   )*(*mangled) == 71) {
#line 3579
      goto case_71;
    }
#line 3585
    if ((int const   )*(*mangled) == 117) {
#line 3585
      goto case_117___0;
    }
#line 3585
    if ((int const   )*(*mangled) == 86) {
#line 3585
      goto case_117___0;
    }
#line 3585
    if ((int const   )*(*mangled) == 67) {
#line 3585
      goto case_117___0;
    }
#line 3600
    goto switch_default___0;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 3406
    (*mangled) ++;
#line 3407
    if (! (work->options & (1 << 2))) {
      {
#line 3408
      string_prepend(& decl, "*");
      }
    }
#line 3409
    if ((unsigned int )tk == 0U) {
#line 3410
      tk = (type_kind_t )1;
    }
#line 3411
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 3415
    (*mangled) ++;
#line 3416
    string_prepend(& decl, "&");
    }
#line 3417
    if ((unsigned int )tk == 0U) {
#line 3418
      tk = (type_kind_t )2;
    }
#line 3419
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3424
    (*mangled) ++;
#line 3425
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3425
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3428
        string_prepend(& decl, "(");
#line 3429
        string_append(& decl, ")");
        }
      } else
#line 3425
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3428
        string_prepend(& decl, "(");
#line 3429
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3431
    string_append(& decl, "[");
    }
#line 3432
    if ((int const   )*(*mangled) != 95) {
      {
#line 3433
      success = demangle_template_value_parm(work, mangled, & decl, (type_kind_t )3);
      }
    }
#line 3435
    if ((int const   )*(*mangled) == 95) {
#line 3436
      (*mangled) ++;
    }
    {
#line 3437
    string_append(& decl, "]");
    }
#line 3438
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 3443
    (*mangled) ++;
#line 3444
    tmp = get_count(mangled, & n);
    }
#line 3444
    if (tmp) {
#line 3444
      if (n >= work->ntypes) {
#line 3446
        success = 0;
      } else {
#line 3450
        remembered_type = (char const   *)*(work->typevec + n);
#line 3451
        mangled = & remembered_type;
      }
    } else {
#line 3446
      success = 0;
    }
#line 3453
    goto switch_break;
    case_70: /* CIL Label */ 
#line 3457
    (*mangled) ++;
#line 3458
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3458
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3461
        string_prepend(& decl, "(");
#line 3462
        string_append(& decl, ")");
        }
      } else
#line 3458
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3461
        string_prepend(& decl, "(");
#line 3462
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3467
    tmp___0 = demangle_nested_args(work, mangled, & decl);
    }
#line 3467
    if (tmp___0) {
#line 3467
      if ((int const   )*(*mangled) != 95) {
#line 3467
        if ((int const   )*(*mangled) != 0) {
#line 3470
          success = 0;
#line 3471
          goto switch_break;
        }
      }
    } else {
#line 3470
      success = 0;
#line 3471
      goto switch_break;
    }
#line 3473
    if (success) {
#line 3473
      if ((int const   )*(*mangled) == 95) {
#line 3474
        (*mangled) ++;
      }
    }
#line 3475
    goto switch_break;
    case_79: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 3480
    type_quals = 0;
#line 3482
    member = (int const   )*(*mangled) == 77;
#line 3483
    (*mangled) ++;
#line 3485
    string_append(& decl, ")");
    }
#line 3489
    if ((int const   )*(*mangled) != 81) {
#line 3490
      if (work->options & (1 << 2)) {
#line 3490
        tmp___1 = ".";
      } else {
#line 3490
        tmp___1 = "::";
      }
      {
#line 3490
      string_prepend(& decl, tmp___1);
      }
    }
#line 3492
    if ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4) {
      {
#line 3494
      n = consume_count(mangled);
      }
#line 3495
      if (n == -1) {
#line 3498
        success = 0;
#line 3499
        goto switch_break;
      } else {
        {
#line 3495
        tmp___2 = strlen(*mangled);
        }
#line 3495
        if ((int )tmp___2 < n) {
#line 3498
          success = 0;
#line 3499
          goto switch_break;
        }
      }
      {
#line 3501
      string_prependn(& decl, *mangled, n);
#line 3502
      *mangled += n;
      }
    } else
#line 3504
    if ((int const   )*(*mangled) == 88) {
      {
#line 3507
      do_type(work, mangled, & temp);
#line 3508
      string_prepends(& decl, & temp);
#line 3509
      string_delete(& temp);
      }
    } else
#line 3504
    if ((int const   )*(*mangled) == 89) {
      {
#line 3507
      do_type(work, mangled, & temp);
#line 3508
      string_prepends(& decl, & temp);
#line 3509
      string_delete(& temp);
      }
    } else
#line 3511
    if ((int const   )*(*mangled) == 116) {
      {
#line 3514
      string_init(& temp___0);
#line 3515
      success = demangle_template(work, mangled, & temp___0, (string___0 *)((void *)0),
                                  1, 1);
      }
#line 3517
      if (success) {
        {
#line 3519
        string_prependn(& decl, (char const   *)temp___0.b, (int )(temp___0.p - temp___0.b));
#line 3520
        string_delete(& temp___0);
        }
      } else {
#line 3523
        goto switch_break;
      }
    } else
#line 3525
    if ((int const   )*(*mangled) == 81) {
      {
#line 3527
      success = demangle_qualified(work, mangled, & decl, 0, 0);
      }
#line 3530
      if (! success) {
#line 3531
        goto switch_break;
      }
    } else {
#line 3535
      success = 0;
#line 3536
      goto switch_break;
    }
    {
#line 3539
    string_prepend(& decl, "(");
    }
#line 3540
    if (member) {
      {
#line 3546
      if ((int const   )*(*mangled) == 117) {
#line 3546
        goto case_117;
      }
#line 3546
      if ((int const   )*(*mangled) == 86) {
#line 3546
        goto case_117;
      }
#line 3546
      if ((int const   )*(*mangled) == 67) {
#line 3546
        goto case_117;
      }
#line 3551
      goto switch_default;
      case_117: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_67: /* CIL Label */ 
      {
#line 3547
      tmp___3 = code_for_qualifier((int )*(*mangled));
#line 3547
      type_quals |= tmp___3;
#line 3548
      (*mangled) ++;
      }
#line 3549
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 3552
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3555
      tmp___4 = *mangled;
#line 3555
      (*mangled) ++;
#line 3555
      if ((int const   )*tmp___4 != 70) {
#line 3557
        success = 0;
#line 3558
        goto switch_break;
      }
    }
#line 3561
    if (member) {
      {
#line 3561
      tmp___5 = demangle_nested_args(work, mangled, & decl);
      }
#line 3561
      if (tmp___5) {
#line 3561
        goto _L;
      } else {
#line 3564
        success = 0;
#line 3565
        goto switch_break;
      }
    } else
    _L: /* CIL Label */ 
#line 3561
    if ((int const   )*(*mangled) != 95) {
#line 3564
      success = 0;
#line 3565
      goto switch_break;
    }
#line 3567
    (*mangled) ++;
#line 3568
    if (! (work->options & (1 << 1))) {
#line 3570
      goto switch_break;
    }
#line 3572
    if (type_quals != 0) {
#line 3574
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3574
        string_append(& decl, " ");
        }
      }
      {
#line 3575
      tmp___6 = qualifier_string(type_quals);
#line 3575
      string_append(& decl, tmp___6);
      }
    }
#line 3577
    goto switch_break;
    case_71: /* CIL Label */ 
#line 3580
    (*mangled) ++;
#line 3581
    goto switch_break;
    case_117___0: /* CIL Label */ 
    case_86___0: /* CIL Label */ 
    case_67___0: /* CIL Label */ 
#line 3586
    if (work->options & (1 << 1)) {
#line 3588
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3589
        string_prepend(& decl, " ");
        }
      }
      {
#line 3591
      tmp___7 = demangle_qualifier((int )*(*mangled));
#line 3591
      string_prepend(& decl, tmp___7);
      }
    }
#line 3593
    (*mangled) ++;
#line 3594
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 3601
    done = 1;
#line 3602
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3606
  if (success) {
    {
#line 3610
    if ((int const   )*(*mangled) == 75) {
#line 3610
      goto case_75;
    }
#line 3610
    if ((int const   )*(*mangled) == 81) {
#line 3610
      goto case_75;
    }
#line 3617
    if ((int const   )*(*mangled) == 66) {
#line 3617
      goto case_66;
    }
#line 3626
    if ((int const   )*(*mangled) == 89) {
#line 3626
      goto case_89;
    }
#line 3626
    if ((int const   )*(*mangled) == 88) {
#line 3626
      goto case_89;
    }
#line 3651
    goto switch_default___1;
    case_75: /* CIL Label */ 
    case_81: /* CIL Label */ 
    {
#line 3612
    success = demangle_qualified(work, mangled, result, 0, 1);
    }
#line 3613
    goto switch_break___1;
    case_66: /* CIL Label */ 
    {
#line 3618
    (*mangled) ++;
#line 3619
    tmp___8 = get_count(mangled, & n);
    }
#line 3619
    if (tmp___8) {
#line 3619
      if (n >= work->numb) {
#line 3620
        success = 0;
      } else {
        {
#line 3622
        string_append(result, (char const   *)*(work->btypevec + n));
        }
      }
    } else {
#line 3620
      success = 0;
    }
#line 3623
    goto switch_break___1;
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    {
#line 3631
    (*mangled) ++;
#line 3632
    idx = consume_count_with_underscores(mangled);
    }
#line 3634
    if (idx == -1) {
#line 3638
      success = 0;
#line 3639
      goto switch_break___1;
    } else
#line 3634
    if (work->tmpl_argvec) {
#line 3634
      if (idx >= work->ntmpl_args) {
#line 3638
        success = 0;
#line 3639
        goto switch_break___1;
      } else {
#line 3634
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 3634
      tmp___9 = consume_count_with_underscores(mangled);
      }
#line 3634
      if (tmp___9 == -1) {
#line 3638
        success = 0;
#line 3639
        goto switch_break___1;
      }
    }
#line 3642
    if (work->tmpl_argvec) {
      {
#line 3643
      string_append(result, (char const   *)*(work->tmpl_argvec + idx));
      }
    } else {
      {
#line 3645
      string_append_template_idx(result, idx);
      }
    }
#line 3647
    success = 1;
#line 3649
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 3652
    success = demangle_fund_type(work, mangled, result);
    }
#line 3653
    if ((unsigned int )tk == 0U) {
#line 3654
      tk = (type_kind_t )success;
    }
#line 3655
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 3658
  if (success) {
#line 3660
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
      {
#line 3662
      string_append(result, " ");
#line 3663
      string_appends(result, & decl);
      }
    }
  } else {
    {
#line 3667
    string_delete(result);
    }
  }
  {
#line 3668
  string_delete(& decl);
  }
#line 3670
  if (success) {
#line 3672
    if ((unsigned int )tk == 0U) {
#line 3672
      tmp___10 = 3U;
    } else {
#line 3672
      tmp___10 = (unsigned int )tk;
    }
#line 3672
    return ((int )tmp___10);
  } else {
#line 3674
    return (0);
  }
}
}
#line 3690 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string___0 *result ) 
{ 
  int done ;
  int success ;
  char buf___0[37] ;
  unsigned int dec ;
  type_kind_t tk ;
  char const   *tmp ;
  int i ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int bindex ;
  int tmp___4 ;
  string___0 btype ;
  long tmp___5 ;
  int tmp___6 ;
  string___0 btype___0 ;
  int tmp___7 ;

  {
#line 3694
  done = 0;
#line 3695
  success = 1;
#line 3697
  dec = 0U;
#line 3698
  tk = (type_kind_t )3;
  {
#line 3702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3702
    if (! (! done)) {
#line 3702
      goto while_break;
    }
    {
#line 3708
    if ((int const   )*(*mangled) == 117) {
#line 3708
      goto case_117;
    }
#line 3708
    if ((int const   )*(*mangled) == 86) {
#line 3708
      goto case_117;
    }
#line 3708
    if ((int const   )*(*mangled) == 67) {
#line 3708
      goto case_117;
    }
#line 3717
    if ((int const   )*(*mangled) == 85) {
#line 3717
      goto case_85;
    }
#line 3722
    if ((int const   )*(*mangled) == 83) {
#line 3722
      goto case_83;
    }
#line 3727
    if ((int const   )*(*mangled) == 74) {
#line 3727
      goto case_74;
    }
#line 3732
    goto switch_default;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 3709
    if (work->options & (1 << 1)) {
#line 3711
      if (! ((unsigned long )result->b == (unsigned long )result->p)) {
        {
#line 3712
        string_prepend(result, " ");
        }
      }
      {
#line 3713
      tmp = demangle_qualifier((int )*(*mangled));
#line 3713
      string_prepend(result, tmp);
      }
    }
#line 3715
    (*mangled) ++;
#line 3716
    goto switch_break;
    case_85: /* CIL Label */ 
#line 3718
    (*mangled) ++;
#line 3719
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3719
      string_append(result, " ");
      }
    }
    {
#line 3720
    string_append(result, "unsigned");
    }
#line 3721
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3723
    (*mangled) ++;
#line 3724
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3724
      string_append(result, " ");
      }
    }
    {
#line 3725
    string_append(result, "signed");
    }
#line 3726
    goto switch_break;
    case_74: /* CIL Label */ 
#line 3728
    (*mangled) ++;
#line 3729
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3729
      string_append(result, " ");
      }
    }
    {
#line 3730
    string_append(result, "__complex");
    }
#line 3731
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3733
    done = 1;
#line 3734
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3743
  if ((int const   )*(*mangled) == 95) {
#line 3743
    goto case_95;
  }
#line 3743
  if ((int const   )*(*mangled) == 0) {
#line 3743
    goto case_95;
  }
#line 3745
  if ((int const   )*(*mangled) == 118) {
#line 3745
    goto case_118;
  }
#line 3750
  if ((int const   )*(*mangled) == 120) {
#line 3750
    goto case_120;
  }
#line 3755
  if ((int const   )*(*mangled) == 108) {
#line 3755
    goto case_108;
  }
#line 3760
  if ((int const   )*(*mangled) == 105) {
#line 3760
    goto case_105;
  }
#line 3765
  if ((int const   )*(*mangled) == 115) {
#line 3765
    goto case_115;
  }
#line 3770
  if ((int const   )*(*mangled) == 98) {
#line 3770
    goto case_98;
  }
#line 3776
  if ((int const   )*(*mangled) == 99) {
#line 3776
    goto case_99;
  }
#line 3782
  if ((int const   )*(*mangled) == 119) {
#line 3782
    goto case_119;
  }
#line 3788
  if ((int const   )*(*mangled) == 114) {
#line 3788
    goto case_114;
  }
#line 3794
  if ((int const   )*(*mangled) == 100) {
#line 3794
    goto case_100;
  }
#line 3800
  if ((int const   )*(*mangled) == 102) {
#line 3800
    goto case_102;
  }
#line 3806
  if ((int const   )*(*mangled) == 71) {
#line 3806
    goto case_71;
  }
#line 3813
  if ((int const   )*(*mangled) == 73) {
#line 3813
    goto case_73;
  }
#line 3854
  if ((int const   )*(*mangled) == 57) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 56) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 55) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 54) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 53) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 52) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 51) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 50) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 49) {
#line 3854
    goto case_57;
  }
#line 3854
  if ((int const   )*(*mangled) == 48) {
#line 3854
    goto case_57;
  }
#line 3869
  if ((int const   )*(*mangled) == 116) {
#line 3869
    goto case_116;
  }
#line 3878
  goto switch_default___0;
  case_95: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 3744
  goto switch_break___0;
  case_118: /* CIL Label */ 
#line 3746
  (*mangled) ++;
#line 3747
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3747
    string_append(result, " ");
    }
  }
  {
#line 3748
  string_append(result, "void");
  }
#line 3749
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 3751
  (*mangled) ++;
#line 3752
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3752
    string_append(result, " ");
    }
  }
  {
#line 3753
  string_append(result, "long long");
  }
#line 3754
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 3756
  (*mangled) ++;
#line 3757
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3757
    string_append(result, " ");
    }
  }
  {
#line 3758
  string_append(result, "long");
  }
#line 3759
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 3761
  (*mangled) ++;
#line 3762
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3762
    string_append(result, " ");
    }
  }
  {
#line 3763
  string_append(result, "int");
  }
#line 3764
  goto switch_break___0;
  case_115: /* CIL Label */ 
#line 3766
  (*mangled) ++;
#line 3767
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3767
    string_append(result, " ");
    }
  }
  {
#line 3768
  string_append(result, "short");
  }
#line 3769
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 3771
  (*mangled) ++;
#line 3772
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3772
    string_append(result, " ");
    }
  }
  {
#line 3773
  string_append(result, "bool");
#line 3774
  tk = (type_kind_t )4;
  }
#line 3775
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 3777
  (*mangled) ++;
#line 3778
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3778
    string_append(result, " ");
    }
  }
  {
#line 3779
  string_append(result, "char");
#line 3780
  tk = (type_kind_t )5;
  }
#line 3781
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 3783
  (*mangled) ++;
#line 3784
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3784
    string_append(result, " ");
    }
  }
  {
#line 3785
  string_append(result, "wchar_t");
#line 3786
  tk = (type_kind_t )5;
  }
#line 3787
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 3789
  (*mangled) ++;
#line 3790
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3790
    string_append(result, " ");
    }
  }
  {
#line 3791
  string_append(result, "long double");
#line 3792
  tk = (type_kind_t )6;
  }
#line 3793
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 3795
  (*mangled) ++;
#line 3796
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3796
    string_append(result, " ");
    }
  }
  {
#line 3797
  string_append(result, "double");
#line 3798
  tk = (type_kind_t )6;
  }
#line 3799
  goto switch_break___0;
  case_102: /* CIL Label */ 
#line 3801
  (*mangled) ++;
#line 3802
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3802
    string_append(result, " ");
    }
  }
  {
#line 3803
  string_append(result, "float");
#line 3804
  tk = (type_kind_t )6;
  }
#line 3805
  goto switch_break___0;
  case_71: /* CIL Label */ 
#line 3807
  (*mangled) ++;
#line 3808
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 3810
    success = 0;
#line 3811
    goto switch_break___0;
  }
  case_73: /* CIL Label */ 
#line 3814
  (*mangled) ++;
#line 3815
  if ((int const   )*(*mangled) == 95) {
#line 3818
    (*mangled) ++;
#line 3819
    i = 0;
    {
#line 3819
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3819
      if ((long )i < (long )sizeof(buf___0) - 1L) {
#line 3819
        if (*(*mangled)) {
#line 3819
          if (! ((int const   )*(*mangled) != 95)) {
#line 3819
            goto while_break___0;
          }
        } else {
#line 3819
          goto while_break___0;
        }
      } else {
#line 3819
        goto while_break___0;
      }
#line 3822
      buf___0[i] = (char )*(*mangled);
#line 3819
      (*mangled) ++;
#line 3819
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3823
    if ((int const   )*(*mangled) != 95) {
#line 3825
      success = 0;
#line 3826
      goto switch_break___0;
    }
#line 3828
    buf___0[i] = (char )'\000';
#line 3829
    (*mangled) ++;
  } else {
    {
#line 3833
    strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)*mangled,
            (size_t )2);
#line 3834
    buf___0[2] = (char )'\000';
#line 3835
    tmp___3 = strlen(*mangled);
    }
#line 3835
    if (tmp___3 < 2UL) {
      {
#line 3835
      tmp___1 = strlen(*mangled);
#line 3835
      tmp___2 = tmp___1;
      }
    } else {
#line 3835
      tmp___2 = (size_t )2;
    }
#line 3835
    *mangled += tmp___2;
  }
  {
#line 3837
  sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%x",
         & dec);
#line 3838
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"int%u_t",
          dec);
  }
#line 3839
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3839
    string_append(result, " ");
    }
  }
  {
#line 3840
  string_append(result, (char const   *)(buf___0));
  }
#line 3841
  goto switch_break___0;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 3856
  tmp___4 = register_Btype(work);
#line 3856
  bindex = tmp___4;
#line 3858
  string_init(& btype);
#line 3859
  tmp___6 = demangle_class_name(work, mangled, & btype);
  }
#line 3859
  if (tmp___6) {
#line 3860
    if ((unsigned long )btype.b == (unsigned long )btype.p) {
#line 3860
      tmp___5 = 0L;
    } else {
#line 3860
      tmp___5 = btype.p - btype.b;
    }
    {
#line 3860
    remember_Btype(work, (char const   *)btype.b, (int )tmp___5, bindex);
    }
#line 3861
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3861
      string_append(result, " ");
      }
    }
    {
#line 3862
    string_appends(result, & btype);
    }
  } else {
#line 3865
    success = 0;
  }
  {
#line 3866
  string_delete(& btype);
  }
#line 3867
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 3872
  string_init(& btype___0);
#line 3873
  success = demangle_template(work, mangled, & btype___0, (string___0 *)0, 1, 1);
#line 3874
  string_appends(result, & btype___0);
#line 3875
  string_delete(& btype___0);
  }
#line 3876
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 3879
  success = 0;
#line 3880
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3883
  if (success) {
#line 3883
    tmp___7 = (int )tk;
  } else {
#line 3883
    tmp___7 = 0;
  }
#line 3883
  return (tmp___7);
}
}
#line 3890 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string___0 *result ) 
{ 
  int unsigned_const ;

  {
#line 3896
  if ((int const   )*(*mangled) != 85) {
#line 3896
    if ((int const   )*(*mangled) != 83) {
#line 3897
      return (0);
    }
  }
#line 3899
  unsigned_const = (int const   )*(*mangled) == 85;
#line 3901
  (*mangled) ++;
  {
#line 3905
  if ((int const   )*(*mangled) == 78) {
#line 3905
    goto case_78;
  }
#line 3908
  if ((int const   )*(*mangled) == 80) {
#line 3908
    goto case_80;
  }
#line 3911
  if ((int const   )*(*mangled) == 77) {
#line 3911
    goto case_77;
  }
#line 3916
  goto switch_default;
  case_78: /* CIL Label */ 
  {
#line 3906
  string_append(result, "-");
  }
  case_80: /* CIL Label */ 
#line 3909
  (*mangled) ++;
#line 3910
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 3913
  string_append(result, "-2147483648");
#line 3914
  (*mangled) ++;
  }
#line 3915
  return (1);
  switch_default: /* CIL Label */ 
#line 3917
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 3921
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 3922
    return (0);
  }
  {
#line 3926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3926
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 3926
      goto while_break;
    }
    {
#line 3928
    char_str[0] = (char )*(*mangled);
#line 3929
    string_append(result, (char const   *)(char_str));
#line 3930
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3933
  if (unsigned_const) {
    {
#line 3934
    string_append(result, "U");
    }
  }
#line 3939
  return (1);
}
}
#line 3945 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string___0 *result ) 
{ 
  int literal_len ;
  char *recurse ;
  char *recurse_dem ;
  void *tmp ;

  {
#line 3949
  literal_len = 0;
#line 3953
  if ((int const   )*(*mangled) != 65) {
#line 3954
    return (0);
  }
  {
#line 3956
  (*mangled) ++;
#line 3958
  literal_len = consume_count(mangled);
  }
#line 3960
  if (literal_len <= 0) {
#line 3961
    return (0);
  }
  {
#line 3965
  string_append(result, "&");
#line 3968
  tmp = xmalloc(sizeof(char ) * (unsigned long )(literal_len + 1));
#line 3968
  recurse = (char *)tmp;
#line 3969
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )literal_len);
#line 3970
  *(recurse + literal_len) = (char )'\000';
#line 3972
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 3974
  if (recurse_dem) {
    {
#line 3976
    string_append(result, (char const   *)recurse_dem);
#line 3977
    free((void *)recurse_dem);
    }
  } else {
    {
#line 3981
    string_appendn(result, *mangled, literal_len);
    }
  }
  {
#line 3983
  *mangled += literal_len;
#line 3984
  free((void *)recurse);
  }
#line 3986
  return (1);
}
}
#line 3989 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int snarf_numeric_literal(char const   **args , string___0 *arg ) 
{ 


  {
#line 3992
  if ((int const   )*(*args) == 45) {
    {
#line 3994
    char_str[0] = (char )'-';
#line 3995
    string_append(arg, (char const   *)(char_str));
#line 3996
    (*args) ++;
    }
  } else
#line 3998
  if ((int const   )*(*args) == 43) {
#line 3999
    (*args) ++;
  }
#line 4001
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4002
    return (0);
  }
  {
#line 4004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4004
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4004
      goto while_break;
    }
    {
#line 4006
    char_str[0] = (char )*(*args);
#line 4007
    string_append(arg, (char const   *)(char_str));
#line 4008
    (*args) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4011
  return (1);
}
}
#line 4018 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int do_arg(struct work_stuff *work , char const   **mangled , string___0 *result ) 
{ 
  char const   *start ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4023
  start = *mangled;
#line 4025
  string_init(result);
  }
#line 4027
  if (work->nrepeats > 0) {
#line 4029
    (work->nrepeats) --;
#line 4031
    if ((unsigned long )work->previous_argument == (unsigned long )((string___0 *)0)) {
#line 4032
      return (0);
    }
    {
#line 4035
    string_appends(result, work->previous_argument);
    }
#line 4036
    return (1);
  }
#line 4039
  if ((int const   )*(*mangled) == 110) {
    {
#line 4042
    (*mangled) ++;
#line 4043
    work->nrepeats = consume_count(mangled);
    }
#line 4045
    if (work->nrepeats <= 0) {
#line 4047
      return (0);
    }
#line 4049
    if (work->nrepeats > 9) {
#line 4051
      if ((int const   )*(*mangled) != 95) {
#line 4054
        return (0);
      } else {
#line 4056
        (*mangled) ++;
      }
    }
    {
#line 4060
    tmp = do_arg(work, mangled, result);
    }
#line 4060
    return (tmp);
  }
#line 4067
  if (work->previous_argument) {
    {
#line 4068
    string_delete(work->previous_argument);
    }
  } else {
    {
#line 4070
    tmp___0 = xmalloc(sizeof(string___0 ));
#line 4070
    work->previous_argument = (string___0 *)tmp___0;
    }
  }
  {
#line 4072
  tmp___1 = do_type(work, mangled, work->previous_argument);
  }
#line 4072
  if (! tmp___1) {
#line 4073
    return (0);
  }
  {
#line 4075
  string_appends(result, work->previous_argument);
#line 4077
  remember_type(work, start, (int )(*mangled - start));
  }
#line 4078
  return (1);
}
}
#line 4081 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void remember_type(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 4086
  if (work->forgetting_types) {
#line 4087
    return;
  }
#line 4089
  if (work->ntypes >= work->typevec_size) {
#line 4091
    if (work->typevec_size == 0) {
      {
#line 4093
      work->typevec_size = 3;
#line 4094
      tmp = xmalloc(sizeof(char *) * (unsigned long )work->typevec_size);
#line 4094
      work->typevec = (char **)tmp;
      }
    } else {
      {
#line 4098
      work->typevec_size *= 2;
#line 4099
      tmp___0 = xrealloc((void *)work->typevec, sizeof(char *) * (unsigned long )work->typevec_size);
#line 4099
      work->typevec = (char **)tmp___0;
      }
    }
  }
  {
#line 4103
  tmp___1 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4103
  tem = (char *)tmp___1;
#line 4104
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4105
  *(tem + len) = (char )'\000';
#line 4106
  tmp___2 = work->ntypes;
#line 4106
  (work->ntypes) ++;
#line 4106
  *(work->typevec + tmp___2) = tem;
  }
#line 4107
  return;
}
}
#line 4111 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 4116
  if (work->numk >= work->ksize) {
#line 4118
    if (work->ksize == 0) {
      {
#line 4120
      work->ksize = 5;
#line 4121
      tmp = xmalloc(sizeof(char *) * (unsigned long )work->ksize);
#line 4121
      work->ktypevec = (char **)tmp;
      }
    } else {
      {
#line 4125
      work->ksize *= 2;
#line 4126
      tmp___0 = xrealloc((void *)work->ktypevec, sizeof(char *) * (unsigned long )work->ksize);
#line 4126
      work->ktypevec = (char **)tmp___0;
      }
    }
  }
  {
#line 4130
  tmp___1 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4130
  tem = (char *)tmp___1;
#line 4131
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4132
  *(tem + len) = (char )'\000';
#line 4133
  tmp___2 = work->numk;
#line 4133
  (work->numk) ++;
#line 4133
  *(work->ktypevec + tmp___2) = tem;
  }
#line 4134
  return;
}
}
#line 4140 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int register_Btype(struct work_stuff *work ) 
{ 
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 4145
  if (work->numb >= work->bsize) {
#line 4147
    if (work->bsize == 0) {
      {
#line 4149
      work->bsize = 5;
#line 4150
      tmp = xmalloc(sizeof(char *) * (unsigned long )work->bsize);
#line 4150
      work->btypevec = (char **)tmp;
      }
    } else {
      {
#line 4154
      work->bsize *= 2;
#line 4155
      tmp___0 = xrealloc((void *)work->btypevec, sizeof(char *) * (unsigned long )work->bsize);
#line 4155
      work->btypevec = (char **)tmp___0;
      }
    }
  }
#line 4159
  tmp___1 = work->numb;
#line 4159
  (work->numb) ++;
#line 4159
  ret = tmp___1;
#line 4160
  *(work->btypevec + ret) = (char *)((void *)0);
#line 4161
  return (ret);
}
}
#line 4166 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) 
{ 
  char *tem ;
  void *tmp ;

  {
  {
#line 4172
  tmp = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4172
  tem = (char *)tmp;
#line 4173
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4174
  *(tem + len) = (char )'\000';
#line 4175
  *(work->btypevec + index___0) = tem;
  }
#line 4176
  return;
}
}
#line 4179 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void forget_B_and_K_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4184
    if (! (work->numk > 0)) {
#line 4184
      goto while_break;
    }
#line 4186
    (work->numk) --;
#line 4186
    i = work->numk;
#line 4187
    if ((unsigned long )*(work->ktypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4189
      free((void *)*(work->ktypevec + i));
#line 4190
      *(work->ktypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4194
    if (! (work->numb > 0)) {
#line 4194
      goto while_break___0;
    }
#line 4196
    (work->numb) --;
#line 4196
    i = work->numb;
#line 4197
    if ((unsigned long )*(work->btypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4199
      free((void *)*(work->btypevec + i));
#line 4200
      *(work->btypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4203
  return;
}
}
#line 4206 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void forget_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4211
    if (! (work->ntypes > 0)) {
#line 4211
      goto while_break;
    }
#line 4213
    (work->ntypes) --;
#line 4213
    i = work->ntypes;
#line 4214
    if ((unsigned long )*(work->typevec + i) != (unsigned long )((void *)0)) {
      {
#line 4216
      free((void *)*(work->typevec + i));
#line 4217
      *(work->typevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4220
  return;
}
}
#line 4264 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_args(struct work_stuff *work , char const   **mangled , string___0 *declp ) 
{ 
  string___0 arg ;
  int need_comma ;
  int r ;
  int t ;
  char const   *tem ;
  char temptype ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4269
  need_comma = 0;
#line 4275
  if (work->options & 1) {
    {
#line 4277
    string_append(declp, "(");
    }
#line 4278
    if ((int const   )*(*mangled) == 0) {
      {
#line 4280
      string_append(declp, "void");
      }
    }
  }
  {
#line 4284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4284
    if ((int const   )*(*mangled) != 95) {
#line 4284
      if ((int const   )*(*mangled) != 0) {
#line 4284
        if (! ((int const   )*(*mangled) != 101)) {
#line 4284
          goto _L___3;
        }
      } else {
#line 4284
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 4284
    if (! (work->nrepeats > 0)) {
#line 4284
      goto while_break;
    }
#line 4287
    if ((int const   )*(*mangled) == 78) {
#line 4287
      goto _L___1;
    } else
#line 4287
    if ((int const   )*(*mangled) == 84) {
      _L___1: /* CIL Label */ 
#line 4289
      tmp = *mangled;
#line 4289
      (*mangled) ++;
#line 4289
      temptype = (char )*tmp;
#line 4291
      if ((int )temptype == 78) {
        {
#line 4293
        tmp___0 = get_count(mangled, & r);
        }
#line 4293
        if (! tmp___0) {
#line 4295
          return (0);
        }
      } else {
#line 4300
        r = 1;
      }
#line 4302
      if (work->options & (1 << 12)) {
#line 4302
        goto _L___0;
      } else
#line 4302
      if (work->options & (1 << 11)) {
#line 4302
        goto _L___0;
      } else
#line 4302
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 4302
        if (work->ntypes >= 10) {
          {
#line 4310
          t = consume_count(mangled);
          }
#line 4310
          if (t <= 0) {
#line 4312
            return (0);
          }
        } else {
#line 4302
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 4317
        tmp___1 = get_count(mangled, & t);
        }
#line 4317
        if (! tmp___1) {
#line 4319
          return (0);
        }
      }
#line 4322
      if (work->options & (1 << 10)) {
#line 4324
        t --;
      } else
#line 4322
      if (work->options & (1 << 11)) {
#line 4324
        t --;
      } else
#line 4322
      if (work->options & (1 << 12)) {
#line 4324
        t --;
      } else
#line 4322
      if (work->options & (1 << 13)) {
#line 4324
        t --;
      }
#line 4328
      if (t < 0) {
#line 4330
        return (0);
      } else
#line 4328
      if (t >= work->ntypes) {
#line 4330
        return (0);
      }
      {
#line 4332
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4332
        if (! (work->nrepeats > 0)) {
#line 4332
          r --;
#line 4332
          if (! (r >= 0)) {
#line 4332
            goto while_break___0;
          }
        }
#line 4334
        tem = (char const   *)*(work->typevec + t);
#line 4335
        if (need_comma) {
#line 4335
          if (work->options & 1) {
            {
#line 4337
            string_append(declp, ", ");
            }
          }
        }
        {
#line 4339
        tmp___2 = do_arg(work, & tem, & arg);
        }
#line 4339
        if (! tmp___2) {
#line 4341
          return (0);
        }
#line 4343
        if (work->options & 1) {
          {
#line 4345
          string_appends(declp, & arg);
          }
        }
        {
#line 4347
        string_delete(& arg);
#line 4348
        need_comma = 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 4353
      if (need_comma) {
#line 4353
        if (work->options & 1) {
          {
#line 4354
          string_append(declp, ", ");
          }
        }
      }
      {
#line 4355
      tmp___3 = do_arg(work, mangled, & arg);
      }
#line 4355
      if (! tmp___3) {
#line 4356
        return (0);
      }
#line 4357
      if (work->options & 1) {
        {
#line 4358
        string_appends(declp, & arg);
        }
      }
      {
#line 4359
      string_delete(& arg);
#line 4360
      need_comma = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4364
  if ((int const   )*(*mangled) == 101) {
#line 4366
    (*mangled) ++;
#line 4367
    if (work->options & 1) {
#line 4369
      if (need_comma) {
        {
#line 4371
        string_append(declp, ",");
        }
      }
      {
#line 4373
      string_append(declp, "...");
      }
    }
  }
#line 4377
  if (work->options & 1) {
    {
#line 4379
    string_append(declp, ")");
    }
  }
#line 4381
  return (1);
}
}
#line 4387 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string___0 *declp ) 
{ 
  string___0 *saved_previous_argument ;
  int result ;
  int saved_nrepeats ;

  {
  {
#line 4399
  (work->forgetting_types) ++;
#line 4403
  saved_previous_argument = work->previous_argument;
#line 4404
  saved_nrepeats = work->nrepeats;
#line 4405
  work->previous_argument = (string___0 *)0;
#line 4406
  work->nrepeats = 0;
#line 4409
  result = demangle_args(work, mangled, declp);
  }
#line 4412
  if (work->previous_argument) {
    {
#line 4414
    string_delete(work->previous_argument);
#line 4415
    free((void *)((char *)work->previous_argument));
    }
  }
#line 4417
  work->previous_argument = saved_previous_argument;
#line 4418
  (work->forgetting_types) --;
#line 4419
  work->nrepeats = saved_nrepeats;
#line 4421
  return (result);
}
}
#line 4424 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                   string___0 *declp , char const   *scan ) 
{ 
  size_t i ;
  string___0 type ;
  char const   *tem ;
  int tmp ;
  int tmp___0 ;
  int len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int len___0 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 4432
  string_appendn(declp, *mangled, (int )(scan - *mangled));
#line 4433
  string_need(declp, 1);
#line 4434
  *(declp->p) = (char )'\000';
#line 4440
  *mangled = scan + 2;
  }
#line 4446
  if (work->options & (1 << 12)) {
#line 4446
    if ((int const   )*(*mangled) == 88) {
      {
#line 4448
      demangle_arm_hp_template(work, mangled, 0, declp);
      }
    }
  }
#line 4452
  if (work->options & (1 << 10)) {
#line 4452
    goto _L;
  } else
#line 4452
  if (work->options & (1 << 11)) {
#line 4452
    goto _L;
  } else
#line 4452
  if (work->options & (1 << 12)) {
#line 4452
    goto _L;
  } else
#line 4452
  if (work->options & (1 << 13)) {
    _L: /* CIL Label */ 
    {
#line 4460
    tmp___0 = strcmp((char const   *)declp->b, "__ct");
    }
#line 4460
    if (tmp___0 == 0) {
      {
#line 4462
      (work->constructor) ++;
#line 4463
      string_clear(declp);
      }
#line 4464
      return;
    } else {
      {
#line 4466
      tmp = strcmp((char const   *)declp->b, "__dt");
      }
#line 4466
      if (tmp == 0) {
        {
#line 4468
        (work->destructor) ++;
#line 4469
        string_clear(declp);
        }
#line 4470
        return;
      }
    }
  }
#line 4474
  if (declp->p - declp->b >= 3L) {
#line 4474
    if ((int )*(declp->b + 0) == 111) {
#line 4474
      if ((int )*(declp->b + 1) == 112) {
        {
#line 4474
        tmp___14 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 2));
        }
#line 4474
        if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 4480
          if (declp->p - declp->b >= 10L) {
            {
#line 4480
            tmp___5 = memcmp((void const   *)(declp->b + 3), (void const   *)"assign_",
                             (size_t )7);
            }
#line 4480
            if (tmp___5 == 0) {
#line 4483
              i = (size_t )0;
              {
#line 4483
              while (1) {
                while_continue: /* CIL Label */ ;
#line 4483
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4483
                  goto while_break;
                }
                {
#line 4485
                len = (int )((declp->p - declp->b) - 10L);
#line 4486
                tmp___1 = strlen((char const   *)optable[i].in);
                }
#line 4486
                if ((int )tmp___1 == len) {
                  {
#line 4486
                  tmp___2 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 10),
                                   (size_t )len);
                  }
#line 4486
                  if (tmp___2 == 0) {
                    {
#line 4489
                    string_clear(declp);
#line 4490
                    string_append(declp, "operator");
#line 4491
                    string_append(declp, (char const   *)optable[i].out);
#line 4492
                    string_append(declp, "=");
                    }
#line 4493
                    goto while_break;
                  }
                }
#line 4483
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 4480
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 4499
            i = (size_t )0;
            {
#line 4499
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4499
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4499
                goto while_break___0;
              }
              {
#line 4501
              len___0 = (int )((declp->p - declp->b) - 3L);
#line 4502
              tmp___3 = strlen((char const   *)optable[i].in);
              }
#line 4502
              if ((int )tmp___3 == len___0) {
                {
#line 4502
                tmp___4 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 3),
                                 (size_t )len___0);
                }
#line 4502
                if (tmp___4 == 0) {
                  {
#line 4505
                  string_clear(declp);
#line 4506
                  string_append(declp, "operator");
#line 4507
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4508
                  goto while_break___0;
                }
              }
#line 4499
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        } else {
#line 4474
          goto _L___8;
        }
      } else {
#line 4474
        goto _L___8;
      }
    } else {
#line 4474
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 4513
  if (declp->p - declp->b >= 5L) {
    {
#line 4513
    tmp___12 = memcmp((void const   *)declp->b, (void const   *)"type", (size_t )4);
    }
#line 4513
    if (tmp___12 == 0) {
      {
#line 4513
      tmp___13 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 4));
      }
#line 4513
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
        {
#line 4517
        tem = (char const   *)(declp->b + 5);
#line 4518
        tmp___6 = do_type(work, & tem, & type);
        }
#line 4518
        if (tmp___6) {
          {
#line 4520
          string_clear(declp);
#line 4521
          string_append(declp, "operator ");
#line 4522
          string_appends(declp, & type);
#line 4523
          string_delete(& type);
          }
        }
      } else {
#line 4513
        goto _L___5;
      }
    } else {
#line 4513
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 4526
  if ((int )*(declp->b + 0) == 95) {
#line 4526
    if ((int )*(declp->b + 1) == 95) {
#line 4526
      if ((int )*(declp->b + 2) == 111) {
#line 4526
        if ((int )*(declp->b + 3) == 112) {
          {
#line 4531
          tem = (char const   *)(declp->b + 4);
#line 4532
          tmp___7 = do_type(work, & tem, & type);
          }
#line 4532
          if (tmp___7) {
            {
#line 4534
            string_clear(declp);
#line 4535
            string_append(declp, "operator ");
#line 4536
            string_appends(declp, & type);
#line 4537
            string_delete(& type);
            }
          }
        } else {
#line 4526
          goto _L___3;
        }
      } else {
#line 4526
        goto _L___3;
      }
    } else {
#line 4526
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 4540
  if ((int )*(declp->b + 0) == 95) {
#line 4540
    if ((int )*(declp->b + 1) == 95) {
#line 4540
      if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 2)) & 255] & 8) {
#line 4540
        if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 3)) & 255] & 8) {
#line 4544
          if ((int )*(declp->b + 4) == 0) {
#line 4547
            i = (size_t )0;
            {
#line 4547
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4547
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4547
                goto while_break___1;
              }
              {
#line 4549
              tmp___8 = strlen((char const   *)optable[i].in);
              }
#line 4549
              if (tmp___8 == 2UL) {
                {
#line 4549
                tmp___9 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                 (size_t )2);
                }
#line 4549
                if (tmp___9 == 0) {
                  {
#line 4552
                  string_clear(declp);
#line 4553
                  string_append(declp, "operator");
#line 4554
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4555
                  goto while_break___1;
                }
              }
#line 4547
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else
#line 4561
          if ((int )*(declp->b + 2) == 97) {
#line 4561
            if ((int )*(declp->b + 5) == 0) {
#line 4564
              i = (size_t )0;
              {
#line 4564
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4564
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4564
                  goto while_break___2;
                }
                {
#line 4566
                tmp___10 = strlen((char const   *)optable[i].in);
                }
#line 4566
                if (tmp___10 == 3UL) {
                  {
#line 4566
                  tmp___11 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                    (size_t )3);
                  }
#line 4566
                  if (tmp___11 == 0) {
                    {
#line 4569
                    string_clear(declp);
#line 4570
                    string_append(declp, "operator");
#line 4571
                    string_append(declp, (char const   *)optable[i].out);
                    }
#line 4572
                    goto while_break___2;
                  }
                }
#line 4564
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
  }
#line 4578
  return;
}
}
#line 4582 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_need(string___0 *s , int n ) 
{ 
  int tem ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4587
  if ((unsigned long )s->b == (unsigned long )((void *)0)) {
#line 4589
    if (n < 32) {
#line 4591
      n = 32;
    }
    {
#line 4593
    tmp___0 = xmalloc(sizeof(char ) * (unsigned long )n);
#line 4593
    tmp = (char *)tmp___0;
#line 4593
    s->b = tmp;
#line 4593
    s->p = tmp;
#line 4594
    s->e = s->b + n;
    }
  } else
#line 4596
  if (s->e - s->p < (long )n) {
    {
#line 4598
    tem = (int )(s->p - s->b);
#line 4599
    n += tem;
#line 4600
    n *= 2;
#line 4601
    tmp___1 = xrealloc((void *)s->b, sizeof(char ) * (unsigned long )n);
#line 4601
    s->b = (char *)tmp___1;
#line 4602
    s->p = s->b + tem;
#line 4603
    s->e = s->b + n;
    }
  }
#line 4605
  return;
}
}
#line 4607 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_delete(string___0 *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 4610
  if ((unsigned long )s->b != (unsigned long )((void *)0)) {
    {
#line 4612
    free((void *)s->b);
#line 4613
    tmp___0 = (char *)((void *)0);
#line 4613
    s->p = tmp___0;
#line 4613
    tmp = tmp___0;
#line 4613
    s->e = tmp;
#line 4613
    s->b = tmp;
    }
  }
#line 4615
  return;
}
}
#line 4617 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_init(string___0 *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 4620
  tmp___0 = (char *)((void *)0);
#line 4620
  s->e = tmp___0;
#line 4620
  tmp = tmp___0;
#line 4620
  s->p = tmp;
#line 4620
  s->b = tmp;
#line 4621
  return;
}
}
#line 4623 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_clear(string___0 *s ) 
{ 


  {
#line 4626
  s->p = s->b;
#line 4627
  return;
}
}
#line 4639 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_append(string___0 *p , char const   *s ) 
{ 
  int n ;
  size_t tmp ;

  {
#line 4643
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 4644
    return;
  } else
#line 4643
  if ((int const   )*s == 0) {
#line 4644
    return;
  }
  {
#line 4645
  tmp = strlen(s);
#line 4645
  n = (int )tmp;
#line 4646
  string_need(p, n);
#line 4647
  memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4648
  p->p += n;
  }
#line 4649
  return;
}
}
#line 4651 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_appends(string___0 *p , string___0 *s ) 
{ 
  int n ;

  {
#line 4656
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4658
    n = (int )(s->p - s->b);
#line 4659
    string_need(p, n);
#line 4660
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s->b, (size_t )n);
#line 4661
    p->p += n;
    }
  }
#line 4663
  return;
}
}
#line 4665 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_appendn(string___0 *p , char const   *s , int n ) 
{ 


  {
#line 4668
  if (n != 0) {
    {
#line 4670
    string_need(p, n);
#line 4671
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4672
    p->p += n;
    }
  }
#line 4674
  return;
}
}
#line 4676 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_prepend(string___0 *p , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 4679
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 4679
    if ((int const   )*s != 0) {
      {
#line 4681
      tmp = strlen(s);
#line 4681
      string_prependn(p, s, (int )tmp);
      }
    }
  }
#line 4683
  return;
}
}
#line 4685 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_prepends(string___0 *p , string___0 *s ) 
{ 


  {
#line 4688
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4690
    string_prependn(p, (char const   *)s->b, (int )(s->p - s->b));
    }
  }
#line 4692
  return;
}
}
#line 4694 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_prependn(string___0 *p , char const   *s , int n ) 
{ 
  char *q ;

  {
#line 4699
  if (n != 0) {
    {
#line 4701
    string_need(p, n);
#line 4702
    q = p->p - 1;
    }
    {
#line 4702
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4702
      if (! ((unsigned long )q >= (unsigned long )p->b)) {
#line 4702
        goto while_break;
      }
#line 4704
      *(q + n) = *(q + 0);
#line 4702
      q --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4706
    memcpy((void */* __restrict  */)p->b, (void const   */* __restrict  */)s, (size_t )n);
#line 4707
    p->p += n;
    }
  }
#line 4709
  return;
}
}
#line 4711 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./cplus-dem.c"
static void string_append_template_idx(string___0 *s , int idx ) 
{ 
  char buf___0[33] ;

  {
  {
#line 4715
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"T%d",
          idx);
#line 4716
  string_append(s, (char const   *)(buf___0));
  }
#line 4717
  return;
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-ndoc.h"
extern bool get_latest_docstring(struct docstring *doc , region tags_r , dd_list *tags ) ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type char_type ;
#line 50
extern type const_ptr_void_type ;
#line 90
extern type qualify_type1(type t , type t1 ) ;
#line 110
extern type build_function_type(region r , type returns  , ...) ;
#line 264
extern type make_combiner_type(type t , data_declaration combiner ) ;
#line 276
extern type make_variable_type(data_declaration tdecl ) ;
#line 303
extern bool type_chararray(type t , bool no_size_allowed ) ;
#line 1852 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
type_parm_decl new_type_parm_decl(region r , location location___0 , cstring cstring___0 ,
                                  data_declaration ddecl ) ;
#line 1853
type_argument new_type_argument(region r , location location___0 , asttype asttype___0 ) ;
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
void warning_or_error_with_location(bool iswarning , location l , char const   *format 
                                    , ...) ;
#line 25 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.h"
void init_internal_nesc_attributes(void) ;
#line 29
bool nesc_filename(char const   *name ) ;
#line 31
char const   *element_name(region r , char const   *path ) ;
#line 37
node compile(location loc , nesc_declaration container , char const   *name , bool name_is_path ) ;
#line 40
nesc_declaration load(source_language sl , location l , char const   *name , bool name_is_path ) ;
#line 43
type get_actual_function_type(type t ) ;
#line 48
function_declarator ddecl_get_fdeclarator(data_declaration fndecl ) ;
#line 53
declaration ddecl_get_gparms(data_declaration fndecl ) ;
#line 58
bool ddecl_is_command_or_event(data_declaration decl ) ;
#line 60
bool nesc_attributep(gcc_attribute a ) ;
#line 64
char const   *language_name(source_language l ) ;
#line 66
nesc_decl dummy_nesc_decl(location loc , nesc_declaration d ) ;
#line 67
void build(nesc_decl ast ) ;
#line 70
bool is_module_variable(data_declaration ddecl ) ;
#line 75
bool is_module_local_static(data_declaration ddecl ) ;
#line 79
char const   *make_intf_printname(char const   *iname , char const   *fname ) ;
#line 95
void handle_combine_attribute(location loc , char const   *combiner , type *t ) ;
#line 100
void handle_nxbase_attribute(location loc , bool be , bool allow_bf , char const   *basename ,
                             data_declaration ddecl ) ;
#line 120
nesc_declaration original_component(nesc_declaration c ) ;
#line 126
data_declaration declare_function(location loc , char const   *name , type signature ) ;
#line 135
nesc_declaration ddecl_container(data_declaration ddecl ) ;
#line 136
nesc_declaration tdecl_container(tag_declaration tdecl ) ;
#line 138
void check_name(char const   *name ) ;
#line 49 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern environment global_env ;
#line 174
extern environment new_environment(region r , environment parent , bool global_level ,
                                   bool parm_level ) ;
#line 183
extern void start_semantics(source_language l , nesc_declaration container , environment parent_env ) ;
#line 217
extern void check_variable_scflags(scflags scf , location l , char const   *kind ,
                                   char const   *name ) ;
#line 220
extern void parse_declarator(type_element modifiers , declarator d , bool bitfield ,
                             bool require_parm_names , int *oclass , scflags *oscf ,
                             char const   **ointf , char const   **oname , type *ot ,
                             bool *owarn_defaulted_int , function_declarator *ofunction_declarator ,
                             dd_list *oattributes ) ;
#line 228
extern int duplicate_decls(data_declaration newdecl , data_declaration olddecl , bool different_binding_level ,
                           bool newinitialised ) ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-paths.h"
extern char const   *find_nesc_file(region r , source_language l , char const   *name ) ;
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-cpp.h"
extern void save_pp_file_start(char const   *path ) ;
#line 34
extern void save_pp_file_end(void) ;
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-env.h"
extern nesc_declaration new_nesc_declaration(region r , source_language kind , char const   *name ) ;
#line 29
extern void nesc_declare(nesc_declaration d ) ;
#line 20 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-component.h"
extern void build_component(region r , nesc_declaration cdecl ) ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-interface.h"
extern void build_interface(region r , nesc_declaration idecl ) ;
#line 9 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-attributes.h"
extern void define_internal_attribute(char const   *name , void (*handle_ndecl)(nesc_attribute attr ,
                                                                                nesc_declaration ndecl ) ,
                                      void (*handle_decl)(nesc_attribute attr , data_declaration ddecl ) ,
                                      void (*handle_tag)(nesc_attribute attr , tag_declaration tdecl ) ,
                                      void (*handle_field)(nesc_attribute attr , field_declaration fdecl ) ,
                                      void (*handle_type)(nesc_attribute attr , type *t ) 
                                      , ...) ;
#line 31
extern ivalue lookup_attribute_field(nesc_attribute attr , char const   *name ) ;
#line 7 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.h"
void ignored_attributes(attribute alist ) ;
#line 8
void ignored_dd_attributes(dd_list alist ) ;
#line 31
void handle_decl_attributes(attribute alist , data_declaration ddecl ) ;
#line 35
void handle_decl_dd_attributes(dd_list alist , data_declaration ddecl ) ;
#line 38 "/home/wheatley/newnew/temp/nescc-1.3.4/src/unparse.h"
extern char const   *get_function_separator(void) ;
#line 21 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-deputy.h"
extern void resolve_deputy_scopes(nesc_decl ast ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
bool nesc_attributep(gcc_attribute a ) 
{ 
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 45
  name = (char const   *)(a->word1)->cstring.data;
#line 47
  tmp = strcmp(name, "C");
  }
#line 47
  if (tmp) {
    {
#line 47
    tmp___0 = strcmp(name, "spontaneous");
    }
#line 47
    if (tmp___0) {
      {
#line 47
      tmp___1 = strcmp(name, "combine");
      }
#line 47
      if (tmp___1) {
        {
#line 47
        tmp___2 = strcmp(name, "nx_base");
        }
#line 47
        if (tmp___2) {
          {
#line 47
          tmp___3 = strcmp(name, "nx_base_le");
          }
#line 47
          if (tmp___3) {
            {
#line 47
            tmp___4 = strcmp(name, "nx_base_be");
            }
#line 47
            if (tmp___4) {
              {
#line 47
              tmp___5 = strcmp(name, "hwevent");
              }
#line 47
              if (tmp___5) {
                {
#line 47
                tmp___6 = strcmp(name, "atomic_hwevent");
                }
#line 47
                if (tmp___6) {
#line 47
                  tmp___7 = 0;
                } else {
#line 47
                  tmp___7 = 1;
                }
              } else {
#line 47
                tmp___7 = 1;
              }
            } else {
#line 47
              tmp___7 = 1;
            }
          } else {
#line 47
            tmp___7 = 1;
          }
        } else {
#line 47
          tmp___7 = 1;
        }
      } else {
#line 47
        tmp___7 = 1;
      }
    } else {
#line 47
      tmp___7 = 1;
    }
  } else {
#line 47
    tmp___7 = 1;
  }
#line 47
  return ((bool )tmp___7);
}
}
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
type get_actual_function_type(type t ) 
{ 
  type tmp ;
  bool tmp___0 ;

  {
  {
#line 62
  tmp___0 = type_generic(t);
  }
#line 62
  if (tmp___0) {
    {
#line 63
    tmp = type_function_return_type(t);
    }
#line 63
    return (tmp);
  } else {
#line 65
    return (t);
  }
}
}
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
function_declarator ddecl_get_fdeclarator(data_declaration fndecl ) 
{ 
  declarator fd ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  function_declarator tmp ;

  {
#line 75
  if ((unsigned int )(fndecl->ast)->kind >= 52U) {
#line 75
    if ((unsigned int )(fndecl->ast)->kind <= 52U) {
#line 76
      tEmPcast = (AST_generic )fndecl->ast;
#line 76
      if (tEmPcast) {
#line 76
        if ((unsigned int )tEmPcast->kind >= 52U) {
#line 76
          if (! ((unsigned int )tEmPcast->kind <= 52U)) {
            {
#line 76
            __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                          76U, "ddecl_get_fdeclarator");
            }
          }
        } else {
          {
#line 76
          __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        76U, "ddecl_get_fdeclarator");
          }
        }
      }
#line 76
      fd = ((variable_decl )tEmPcast)->declarator;
    } else {
#line 75
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 78
    tEmPcast___0 = (AST_generic )fndecl->ast;
#line 78
    if (tEmPcast___0) {
#line 78
      if ((unsigned int )tEmPcast___0->kind >= 50U) {
#line 78
        if (! ((unsigned int )tEmPcast___0->kind <= 50U)) {
          {
#line 78
          __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        78U, "ddecl_get_fdeclarator");
          }
        }
      } else {
        {
#line 78
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      78U, "ddecl_get_fdeclarator");
        }
      }
    }
#line 78
    fd = ((function_decl )tEmPcast___0)->declarator;
  }
  {
#line 80
  tmp = get_fdeclarator(fd);
  }
#line 80
  return (tmp);
}
}
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
declaration ddecl_get_gparms(data_declaration fndecl ) 
{ 
  AST_generic tEmPcast ;
  function_declarator tmp ;

  {
#line 89
  if ((unsigned int )fndecl->kind == 2U) {
#line 89
    if (fndecl->interface) {
#line 90
      tEmPcast = (AST_generic )(fndecl->interface)->ast;
#line 90
      if (tEmPcast) {
#line 90
        if ((unsigned int )tEmPcast->kind >= 58U) {
#line 90
          if (! ((unsigned int )tEmPcast->kind <= 58U)) {
            {
#line 90
            __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                          90U, "ddecl_get_gparms");
            }
          }
        } else {
          {
#line 90
          __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        90U, "ddecl_get_gparms");
          }
        }
      }
#line 90
      return (((interface_ref )tEmPcast)->gparms);
    }
  }
  {
#line 93
  tmp = ddecl_get_fdeclarator(fndecl);
  }
#line 93
  return (tmp->gparms);
}
}
#line 96 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
bool ddecl_is_command_or_event(data_declaration decl ) 
{ 
  int tmp ;

  {
#line 98
  if ((unsigned int )decl->kind == 2U) {
#line 98
    if ((unsigned int )decl->ftype == 4U) {
#line 98
      tmp = 1;
    } else
#line 98
    if ((unsigned int )decl->ftype == 5U) {
#line 98
      tmp = 1;
    } else {
#line 98
      tmp = 0;
    }
  } else {
#line 98
    tmp = 0;
  }
#line 98
  return ((bool )tmp);
}
}
#line 102 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
bool nesc_filename(char const   *name ) 
{ 
  char *dot ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 104
  tmp = lbasename(name);
#line 104
  tmp___0 = strrchr(tmp, '.');
#line 104
  dot = tmp___0;
  }
#line 106
  if (dot) {
    {
#line 108
    tmp___1 = strcmp((char const   *)dot, ".nc");
    }
#line 108
    if (! tmp___1) {
#line 109
      return ((bool )1);
    }
  }
#line 111
  return ((bool )0);
}
}
#line 114 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
char const   *element_name(region r , char const   *path ) 
{ 
  char const   *base ;
  char const   *dot ;
  char *tmp ;
  char *copy ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 122
  base = lbasename(path);
#line 123
  tmp = strrchr(base, '.');
#line 123
  dot = (char const   *)tmp;
  }
#line 125
  if (dot) {
    {
#line 128
    tmp___0 = typed_rarrayalloc(r, (size_t )((dot - base) + 1L), sizeof(char ), 0);
#line 128
    copy = (char *)tmp___0;
#line 130
    memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)base, (size_t )(dot - base));
#line 131
    *(copy + (dot - base)) = (char )'\000';
    }
#line 133
    return ((char const   *)copy);
  } else {
    {
#line 136
    tmp___1 = rstrdup(r, base);
    }
#line 136
    return ((char const   *)tmp___1);
  }
}
}
#line 139 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
char const   *language_name(source_language l ) 
{ 


  {
  {
#line 143
  if ((unsigned int )l == 1U) {
#line 143
    goto case_1;
  }
#line 144
  if ((unsigned int )l == 3U) {
#line 144
    goto case_3;
  }
#line 144
  if ((unsigned int )l == 2U) {
#line 144
    goto case_3;
  }
#line 145
  if ((unsigned int )l == 0U) {
#line 145
    goto case_0;
  }
#line 146
  if ((unsigned int )l == 6U) {
#line 146
    goto case_6;
  }
#line 147
  goto switch_default;
  case_1: /* CIL Label */ 
#line 143
  return ("interface");
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 144
  return ("component");
  case_0: /* CIL Label */ 
#line 145
  return ("C file");
  case_6: /* CIL Label */ 
#line 146
  return ("");
  switch_default: /* CIL Label */ 
  {
#line 147
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                147U, "language_name");
  }
#line 147
  return ("BUG");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 151 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
node compile(location loc , nesc_declaration container , char const   *name , bool name_is_path ) 
{ 
  source_language l ;
  unsigned int tmp ;
  char const   *path ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  node parse_tree___0 ;
  struct semantic_state old_semantic_state ;
  bool ok ;
  char const   *tmp___2 ;

  {
#line 154
  if (container) {
#line 154
    tmp = (unsigned int )container->kind;
  } else {
#line 154
    tmp = 0U;
  }
#line 154
  l = (source_language )tmp;
#line 155
  if (name_is_path) {
#line 155
    tmp___1 = name;
  } else {
    {
#line 155
    tmp___0 = find_nesc_file(parse_region, l, name);
#line 155
    tmp___1 = tmp___0;
    }
  }
#line 155
  path = tmp___1;
#line 157
  parse_tree___0 = (node )((void *)0);
#line 158
  old_semantic_state = current;
#line 161
  if (! path) {
    {
#line 162
    tmp___2 = language_name(l);
#line 162
    error_with_location(loc, "%s %s not found", tmp___2, name);
    }
  } else {
#line 165
    if (flag_verbose) {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"preprocessing %s\n",
              path);
      }
    }
    {
#line 168
    current.file = container;
#line 169
    current.fileregion = newregion();
#line 170
    start_semantics((source_language )0, (nesc_declaration )((void *)0), global_env);
#line 171
    ok = start_lex(l, path);
#line 172
    save_pp_file_start(path);
    }
#line 173
    if (! ok) {
      {
#line 174
      error_with_location(loc, "failed to preprocess %s", path);
      }
    } else {
      {
#line 176
      parse_tree___0 = parse();
      }
    }
    {
#line 177
    deleteregion_ptr(& current.fileregion);
#line 178
    end_lex();
#line 179
    save_pp_file_end();
    }
  }
#line 182
  current = old_semantic_state;
#line 184
  return (parse_tree___0);
}
}
#line 187 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_decl dummy_nesc_decl(location loc , nesc_declaration d ) 
{ 
  word wname ;
  word tmp ;
  nesc_decl nd ;
  environment env___0 ;
  environment tmp___0 ;
  implementation impl ;
  AST_generic tEmPcast ;
  module tmp___1 ;
  AST_generic tEmPcast___0 ;
  component tmp___2 ;
  AST_generic tEmPcast___1 ;
  interface tmp___3 ;

  {
  {
#line 189
  tmp = build_word(parse_region, d->name);
#line 189
  wname = tmp;
  }
  {
#line 194
  if ((unsigned int )d->kind == 2U) {
#line 194
    goto case_2;
  }
#line 202
  if ((unsigned int )d->kind == 1U) {
#line 202
    goto case_1;
  }
#line 206
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 195
  tmp___0 = new_environment(parse_region, global_env, (bool )1, (bool )0);
#line 195
  env___0 = tmp___0;
#line 196
  tmp___1 = new_module(parse_region, loc, env___0, (declaration )((void *)0));
#line 196
  tEmPcast = (AST_generic )tmp___1;
  }
#line 196
  if (tEmPcast) {
#line 196
    if ((unsigned int )tEmPcast->kind >= 194U) {
#line 196
      if (! ((unsigned int )tEmPcast->kind <= 197U)) {
        {
#line 196
        __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      197U, "dummy_nesc_decl");
        }
      }
    } else {
      {
#line 196
      __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    197U, "dummy_nesc_decl");
      }
    }
  }
  {
#line 196
  impl = (implementation )tEmPcast;
#line 198
  tmp___2 = new_component(parse_region, dummy_location, wname, (attribute )((void *)0),
                          (bool )0, (declaration )((void *)0), (declaration )((void *)0),
                          impl);
#line 198
  tEmPcast___0 = (AST_generic )tmp___2;
  }
#line 198
  if (tEmPcast___0) {
#line 198
    if ((unsigned int )tEmPcast___0->kind >= 54U) {
#line 198
      if (! ((unsigned int )tEmPcast___0->kind <= 56U)) {
        {
#line 198
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      199U, "dummy_nesc_decl");
        }
      }
    } else {
      {
#line 198
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    199U, "dummy_nesc_decl");
      }
    }
  }
#line 198
  nd = (nesc_decl )tEmPcast___0;
#line 200
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 203
  tmp___3 = new_interface(parse_region, loc, wname, (attribute )((void *)0), (declaration )((void *)0));
#line 203
  tEmPcast___1 = (AST_generic )tmp___3;
  }
#line 203
  if (tEmPcast___1) {
#line 203
    if ((unsigned int )tEmPcast___1->kind >= 54U) {
#line 203
      if (! ((unsigned int )tEmPcast___1->kind <= 56U)) {
        {
#line 203
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      204U, "dummy_nesc_decl");
        }
      }
    } else {
      {
#line 203
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    204U, "dummy_nesc_decl");
      }
    }
  }
#line 203
  nd = (nesc_decl )tEmPcast___1;
#line 205
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 207
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                207U, "dummy_nesc_decl");
#line 208
  nd = (nesc_decl )((void *)0);
  }
#line 209
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 211
  d->ast = nd;
#line 212
  nd->cdecl = d;
#line 214
  build(nd);
  }
#line 216
  return (nd);
}
}
#line 219 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
void build(nesc_decl ast ) 
{ 
  struct semantic_state old_semantic_state ;
  nesc_declaration decl ;

  {
  {
#line 221
  old_semantic_state = current;
#line 222
  decl = ast->cdecl;
#line 224
  current.container = decl;
#line 226
  resolve_deputy_scopes(ast);
  }
  {
#line 230
  if ((unsigned int )decl->kind == 1U) {
#line 230
    goto case_1;
  }
#line 233
  if ((unsigned int )decl->kind == 2U) {
#line 233
    goto case_2;
  }
#line 236
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 231
  build_interface(parse_region, decl);
  }
#line 232
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 234
  build_component(parse_region, decl);
  }
#line 235
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 237
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                237U, "build");
  }
  switch_break: /* CIL Label */ ;
  }
#line 240
  current = old_semantic_state;
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_declaration load(source_language sl , location l , char const   *name , bool name_is_path ) 
{ 
  char const   *element ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *actual_name ;
  node ptree ;
  nesc_decl ast ;
  nesc_declaration decl ;
  unsigned int tmp___1 ;
  nesc_declaration tmp___2 ;
  bool badkind ;
  AST_generic tEmPcast ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  location tmp___7 ;

  {
#line 251
  if (name_is_path) {
    {
#line 251
    tmp = element_name(parse_region, name);
#line 251
    tmp___0 = tmp;
    }
  } else {
#line 251
    tmp___0 = name;
  }
#line 251
  element = tmp___0;
#line 254
  ast = (nesc_decl )((void *)0);
#line 255
  if ((unsigned int )sl == 6U) {
#line 255
    tmp___1 = 2U;
  } else {
#line 255
    tmp___1 = (unsigned int )sl;
  }
  {
#line 255
  tmp___2 = new_nesc_declaration(parse_region, (source_language )tmp___1, element);
#line 255
  decl = tmp___2;
#line 259
  nesc_declare(decl);
#line 261
  ptree = compile(l, decl, name, name_is_path);
  }
#line 262
  if (ptree) {
#line 266
    tEmPcast = (AST_generic )ptree;
#line 266
    if (tEmPcast) {
#line 266
      if ((unsigned int )tEmPcast->kind >= 54U) {
#line 266
        if (! ((unsigned int )tEmPcast->kind <= 56U)) {
          {
#line 266
          __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        266U, "load");
          }
        }
      } else {
        {
#line 266
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      266U, "load");
        }
      }
    }
    {
#line 266
    ast = (nesc_decl )tEmPcast;
#line 267
    build(ast);
#line 269
    actual_name = (char const   *)(ast->word1)->cstring.data;
    }
#line 270
    if ((unsigned int )sl != 6U) {
#line 270
      if ((unsigned int )(ast->cdecl)->kind != (unsigned int )sl) {
#line 270
        tmp___3 = 1;
      } else {
#line 270
        tmp___3 = 0;
      }
    } else {
#line 270
      tmp___3 = 0;
    }
#line 270
    badkind = (bool )tmp___3;
#line 271
    if (badkind) {
      {
#line 272
      tmp___4 = language_name((ast->cdecl)->kind);
#line 272
      tmp___5 = language_name(sl);
#line 272
      warning_or_error_with_location((bool )(! badkind), ast->location, "expected %s `%s\', but got %s \'%s\'",
                                     tmp___5, element, tmp___4, actual_name);
      }
    } else {
      {
#line 271
      tmp___6 = strcmp(element, actual_name);
      }
#line 271
      if (tmp___6) {
        {
#line 272
        tmp___4 = language_name((ast->cdecl)->kind);
#line 272
        tmp___5 = language_name(sl);
#line 272
        warning_or_error_with_location((bool )(! badkind), ast->location, "expected %s `%s\', but got %s \'%s\'",
                                       tmp___5, element, tmp___4, actual_name);
        }
      }
    }
#line 279
    if (badkind) {
#line 280
      ast = (nesc_decl )((void *)0);
    }
  }
#line 283
  if (! ast) {
    {
#line 284
    tmp___7 = new_location(name, 0);
#line 284
    ast = dummy_nesc_decl(tmp___7, decl);
    }
  }
#line 286
  return (ast->cdecl);
}
}
#line 289 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_declaration start_nesc_entity(source_language sl , word name ) 
{ 
  nesc_declaration decl ;

  {
#line 297
  if ((unsigned int )sl == (unsigned int )(current.file)->kind) {
#line 298
    decl = current.file;
  } else {
    {
#line 300
    decl = new_nesc_declaration(parse_region, sl, (char const   *)name->cstring.data);
    }
  }
  {
#line 302
  get_latest_docstring(& decl->doc, permanent, (dd_list *)((void *)0));
#line 304
  start_semantics(sl, decl, decl->env);
  }
#line 306
  return (decl);
}
}
#line 309 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
bool is_module_local_static(data_declaration ddecl ) 
{ 
  int tmp ;

  {
#line 311
  if ((unsigned int )ddecl->kind == 0U) {
#line 311
    if ((unsigned int )ddecl->vtype == 1U) {
#line 311
      if (ddecl->container_function) {
#line 311
        if ((ddecl->container_function)->container) {
#line 311
          tmp = 1;
        } else {
#line 311
          tmp = 0;
        }
      } else {
#line 311
        tmp = 0;
      }
    } else {
#line 311
      tmp = 0;
    }
  } else {
#line 311
    tmp = 0;
  }
#line 311
  return ((bool )tmp);
}
}
#line 316 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
bool is_module_variable(data_declaration ddecl ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 318
  if ((unsigned int )ddecl->kind == 0U) {
#line 318
    if ((int )ddecl->Cname == 0) {
#line 318
      if (ddecl->container) {
#line 318
        tmp___0 = 1;
      } else {
        {
#line 318
        tmp = is_module_local_static(ddecl);
        }
#line 318
        if (tmp) {
#line 318
          tmp___0 = 1;
        } else {
#line 318
          tmp___0 = 0;
        }
      }
    } else {
#line 318
      tmp___0 = 0;
    }
  } else {
#line 318
    tmp___0 = 0;
  }
#line 318
  return ((bool )tmp___0);
}
}
#line 324 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_declaration ddecl_container(data_declaration ddecl ) 
{ 


  {
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! ddecl->container_function) {
#line 326
      goto while_break;
    }
#line 327
    ddecl = ddecl->container_function;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (ddecl->container);
}
}
#line 332 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_declaration tdecl_container(tag_declaration tdecl ) 
{ 


  {
#line 339
  return (tdecl->container);
}
}
#line 342 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
char const   *make_intf_printname(char const   *iname , char const   *fname ) 
{ 
  size_t ilen ;
  size_t tmp ;
  size_t dlen ;
  size_t tmp___0 ;
  char *fullname ;
  char *tmp___1 ;

  {
  {
#line 346
  tmp = strlen(iname);
#line 346
  ilen = tmp;
#line 347
  tmp___0 = strlen(fname);
#line 347
  dlen = tmp___0;
#line 348
  tmp___1 = rstralloc(current.fileregion, (ilen + dlen) + 2UL);
#line 348
  fullname = tmp___1;
#line 350
  memcpy((void */* __restrict  */)fullname, (void const   */* __restrict  */)iname,
         ilen);
#line 351
  *(fullname + ilen) = (char )'.';
#line 352
  strcpy((char */* __restrict  */)((fullname + ilen) + 1), (char const   */* __restrict  */)fname);
  }
#line 354
  return ((char const   *)fullname);
}
}
#line 357 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
char const   *decl_printname(data_declaration ddecl ) 
{ 
  char const   *tmp ;
  bool tmp___0 ;

  {
  {
#line 359
  tmp___0 = ddecl_is_command_or_event(ddecl);
  }
#line 359
  if (tmp___0) {
#line 359
    if (ddecl->interface) {
      {
#line 360
      tmp = make_intf_printname((ddecl->interface)->name, ddecl->name);
      }
#line 360
      return (tmp);
    } else {
#line 362
      return (ddecl->name);
    }
  } else {
#line 362
    return (ddecl->name);
  }
}
}
#line 365 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
data_declaration get_function_ddecl(expression e ) 
{ 
  identifier id ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 370
  if ((unsigned int )e->kind >= 146U) {
#line 370
    if ((unsigned int )e->kind <= 146U) {
#line 372
      tEmPcast = (AST_generic )e;
#line 372
      if (tEmPcast) {
#line 372
        if ((unsigned int )tEmPcast->kind >= 146U) {
#line 372
          if (! ((unsigned int )tEmPcast->kind <= 146U)) {
            {
#line 372
            __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                          372U, "get_function_ddecl");
            }
          }
        } else {
          {
#line 372
          __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        372U, "get_function_ddecl");
          }
        }
      }
#line 372
      id = (identifier )tEmPcast;
#line 374
      if ((unsigned int )(id->ddecl)->kind == 2U) {
#line 375
        return (id->ddecl);
      }
    } else {
#line 370
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 377
  if ((unsigned int )e->kind >= 93U) {
#line 377
    if ((unsigned int )e->kind <= 93U) {
#line 378
      tEmPcast___0 = (AST_generic )e;
#line 378
      if (tEmPcast___0) {
#line 378
        if ((unsigned int )tEmPcast___0->kind >= 93U) {
#line 378
          if (! ((unsigned int )tEmPcast___0->kind <= 93U)) {
            {
#line 378
            __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                          378U, "get_function_ddecl");
            }
          }
        } else {
          {
#line 378
          __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        378U, "get_function_ddecl");
          }
        }
      }
#line 378
      return (((interface_deref )tEmPcast___0)->ddecl);
    }
  }
#line 380
  return ((data_declaration )((void *)0));
}
}
#line 383 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
data_declaration declare_function(location loc , char const   *name , type signature ) 
{ 
  data_declaration fdecl ;
  bool ok ;
  bool tmp ;
  struct data_declaration tempdecl ;
  declaration dummy___0 ;
  declaration tmp___0 ;
  data_declaration tmp___1 ;

  {
  {
#line 393
  ok = (bool )0;
#line 397
  fdecl = lookup_id(name, (bool )0);
  }
#line 398
  if (fdecl) {
#line 400
    if ((unsigned int )fdecl->kind != 2U) {
      {
#line 402
      error_with_location(loc, "function `%s\' is not a C function", name);
      }
    } else
#line 400
    if ((unsigned int )fdecl->ftype == 1U) {
#line 400
      goto _L;
    } else
#line 400
    if ((unsigned int )fdecl->ftype == 2U) {
      _L: /* CIL Label */ 
      {
#line 404
      tmp = type_compatible_unqualified(fdecl->type, signature);
      }
#line 404
      if (tmp) {
#line 408
        ok = (bool )1;
      } else {
        {
#line 405
        error_with_location(loc, "function `%s\' does not have the right signature",
                            name);
        }
      }
    } else {
      {
#line 402
      error_with_location(loc, "function `%s\' is not a C function", name);
      }
    }
  } else {
    {
#line 413
    tmp___0 = make_error_decl();
#line 413
    dummy___0 = tmp___0;
#line 416
    dummy___0->location = loc;
#line 417
    init_data_declaration(& tempdecl, dummy___0, name, signature);
#line 418
    tempdecl.kind = (data_kind )2;
#line 419
    tempdecl.ftype = (enum __anonenum_ftype_41 )1;
#line 420
    tempdecl.isfilescoperef = (bool )1;
#line 420
    tempdecl.isexternalscope = tempdecl.isfilescoperef;
#line 421
    fdecl = declare(current.env, & tempdecl, (bool )0);
#line 423
    ok = (bool )1;
    }
  }
#line 425
  if (ok) {
#line 425
    tmp___1 = fdecl;
  } else {
#line 425
    tmp___1 = (data_declaration )((void *)0);
  }
#line 425
  return (tmp___1);
}
}
#line 428 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
void handle_combine_attribute(location loc , char const   *combiner , type *t ) 
{ 
  data_declaration cdecl ;
  type tmp ;
  data_declaration tmp___0 ;

  {
  {
#line 430
  tmp = build_function_type(parse_region, *t, *t, *t, (void *)0);
#line 430
  tmp___0 = declare_function(loc, combiner, tmp);
#line 430
  cdecl = tmp___0;
  }
#line 434
  if (cdecl) {
    {
#line 435
    *t = make_combiner_type(*t, cdecl);
    }
  }
#line 436
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
void handle_nxbase_attribute(location loc , bool be , bool allow_bf , char const   *basename ,
                             data_declaration ddecl ) 
{ 
  region r ;
  char *encoder_name ;
  char *decoder_name ;
  type t ;
  size_t tmp ;
  size_t tmp___0 ;
  type tmp___1 ;
  type tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  type tmp___5 ;
  type tmp___6 ;

  {
  {
#line 441
  r = parse_region;
#line 443
  t = ddecl->type;
#line 445
  tmp = strlen(basename);
#line 445
  encoder_name = rstralloc(r, tmp + 13UL);
#line 446
  sprintf((char */* __restrict  */)encoder_name, (char const   */* __restrict  */)"__nesc_hton_%s",
          basename);
#line 447
  tmp___0 = strlen(basename);
#line 447
  decoder_name = rstralloc(r, tmp___0 + 13UL);
#line 448
  sprintf((char */* __restrict  */)decoder_name, (char const   */* __restrict  */)"__nesc_ntoh_%s",
          basename);
#line 450
  tmp___1 = build_function_type(r, t, ptr_void_type, t, (void *)0);
#line 450
  ddecl->encoder = declare_function(loc, (char const   *)encoder_name, tmp___1);
#line 454
  tmp___2 = build_function_type(r, t, const_ptr_void_type, (void *)0);
#line 454
  ddecl->decoder = declare_function(loc, (char const   *)decoder_name, tmp___2);
  }
#line 458
  if (allow_bf) {
    {
#line 460
    tmp___3 = strlen(basename);
#line 460
    encoder_name = rstralloc(r, tmp___3 + 15UL);
#line 461
    sprintf((char */* __restrict  */)encoder_name, (char const   */* __restrict  */)"__nesc_htonbf_%s",
            basename);
#line 462
    tmp___4 = strlen(basename);
#line 462
    decoder_name = rstralloc(r, tmp___4 + 15UL);
#line 463
    sprintf((char */* __restrict  */)decoder_name, (char const   */* __restrict  */)"__nesc_ntohbf_%s",
            basename);
#line 466
    tmp___5 = build_function_type(r, t, ptr_void_type, unsigned_int_type, unsigned_char_type,
                                  t, (void *)0);
#line 466
    ddecl->bf_encoder = declare_function(loc, (char const   *)encoder_name, tmp___5);
#line 470
    tmp___6 = build_function_type(r, t, const_ptr_void_type, unsigned_int_type, unsigned_char_type,
                                  (void *)0);
#line 470
    ddecl->bf_decoder = declare_function(loc, (char const   *)decoder_name, tmp___6);
    }
  }
#line 474
  ddecl->isbe = be;
#line 478
  ddecl->basetype = t;
#line 479
  return;
}
}
#line 485 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
declaration declare_template_parameter(declarator d , type_element elements , attribute attributes ) 
{ 
  location l ;
  location tmp ;
  variable_decl vd ;
  variable_decl tmp___0 ;
  data_decl dd ;
  AST_generic tEmPcast ;
  data_decl tmp___1 ;
  data_declaration ddecl ;
  data_declaration old_decl ;
  struct data_declaration tempdecl ;
  dd_list extra_attr ;
  int class ;
  scflags scf ;
  char const   *name ;
  bool defaulted_int ;
  type parm_type ;
  AST_generic tEmPcast___0 ;
  declaration tmp___2 ;
  type_element elem ;
  typename tname ;
  bool ok ;
  AST_generic tEmPcast___1 ;
  AST_generic tEmPcast___2 ;
  AST_generic tEmPcast___3 ;
  cstring cname ;
  size_t tmp___3 ;
  cstring tmp___4 ;
  declaration tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  type tmp___8 ;
  type tmp___9 ;
  bool tmp___10 ;
  AST_generic tEmPcast___4 ;
  int tmp___11 ;
  AST_generic tEmPcast___5 ;

  {
#line 489
  if (d) {
#line 489
    tmp = d->location;
  } else {
#line 489
    tmp = elements->location;
  }
  {
#line 489
  l = tmp;
#line 490
  tmp___0 = new_variable_decl(parse_region, l, d, attributes, (expression )((void *)0),
                              (asm_stmt )((void *)0), (data_declaration )((void *)0));
#line 490
  vd = tmp___0;
#line 493
  tEmPcast = (AST_generic )vd;
  }
#line 493
  if (tEmPcast) {
#line 493
    if ((unsigned int )tEmPcast->kind >= 43U) {
#line 493
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 493
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      493U, "declare_template_parameter");
        }
      }
    } else {
      {
#line 493
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    493U, "declare_template_parameter");
      }
    }
  }
  {
#line 493
  tmp___1 = new_data_decl(parse_region, l, elements, (declaration )tEmPcast);
#line 493
  dd = tmp___1;
#line 494
  ddecl = (data_declaration )((void *)0);
#line 494
  old_decl = (data_declaration )((void *)0);
#line 503
  parse_declarator(elements, vd->declarator, (bool )0, (bool )0, & class, & scf, (char const   **)((void *)0),
                   & name, & parm_type, & defaulted_int, (function_declarator *)((void *)0),
                   & extra_attr);
#line 506
  vd->declared_type = parm_type;
  }
#line 509
  if (class) {
#line 512
    if (class == 18) {
#line 512
      if (defaulted_int) {
#line 512
        if ((unsigned int )d->kind >= 182U) {
#line 512
          if ((unsigned int )d->kind <= 182U) {
#line 515
            tEmPcast___0 = (AST_generic )d;
#line 515
            if (tEmPcast___0) {
#line 515
              if ((unsigned int )tEmPcast___0->kind >= 182U) {
#line 515
                if (! ((unsigned int )tEmPcast___0->kind <= 182U)) {
                  {
#line 515
                  __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                                "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                                515U, "declare_template_parameter");
                  }
                }
              } else {
                {
#line 515
                __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                              515U, "declare_template_parameter");
                }
              }
            }
            {
#line 515
            tmp___2 = declare_type_parameter(d->location, ((identifier_declarator )tEmPcast___0)->cstring,
                                             attributes, extra_attr);
            }
#line 514
            return (tmp___2);
          } else {
#line 512
            goto _L___2;
          }
        } else {
#line 512
          goto _L___2;
        }
      } else {
#line 512
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 517
    if (class == 18) {
#line 517
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 523
        ok = (bool )1;
#line 526
        elem = elements;
        {
#line 526
        while (1) {
          while_continue: /* CIL Label */ ;
#line 526
          if (! elem) {
#line 526
            goto while_break;
          }
#line 527
          if ((unsigned int )elem->kind >= 158U) {
#line 527
            if ((unsigned int )elem->kind <= 159U) {
#line 528
              tEmPcast___2 = (AST_generic )elem;
#line 528
              if (tEmPcast___2) {
#line 528
                if ((unsigned int )tEmPcast___2->kind >= 158U) {
#line 528
                  if (! ((unsigned int )tEmPcast___2->kind <= 159U)) {
                    {
#line 528
                    __assert_fail("((tEmPcast)->kind >= kind_typename && (tEmPcast)->kind <= postkind_typename)",
                                  "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                                  528U, "declare_template_parameter");
                    }
                  }
                } else {
                  {
#line 528
                  __assert_fail("((tEmPcast)->kind >= kind_typename && (tEmPcast)->kind <= postkind_typename)",
                                "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                                528U, "declare_template_parameter");
                  }
                }
              }
#line 528
              tname = (typename )tEmPcast___2;
            } else {
#line 527
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 530
          if ((unsigned int )elem->kind >= 162U) {
#line 530
            if (! ((unsigned int )elem->kind <= 165U)) {
#line 530
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 530
          if ((unsigned int )elem->kind >= 166U) {
#line 530
            if ((unsigned int )elem->kind <= 166U) {
#line 530
              tEmPcast___3 = (AST_generic )elem;
#line 530
              if (tEmPcast___3) {
#line 530
                if ((unsigned int )tEmPcast___3->kind >= 166U) {
#line 530
                  if (! ((unsigned int )tEmPcast___3->kind <= 166U)) {
                    {
#line 530
                    __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                                  "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                                  530U, "declare_template_parameter");
                    }
                  }
                } else {
                  {
#line 530
                  __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                                "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                                530U, "declare_template_parameter");
                  }
                }
              }
#line 530
              if (! ((unsigned int )((rid )tEmPcast___3)->id == 18U)) {
#line 531
                ok = (bool )0;
              }
            } else {
#line 531
              ok = (bool )0;
            }
          } else {
#line 531
            ok = (bool )0;
          }
#line 526
          tEmPcast___1 = (AST_generic )elem->next;
#line 526
          if (tEmPcast___1) {
#line 526
            if ((unsigned int )tEmPcast___1->kind >= 157U) {
#line 526
              if (! ((unsigned int )tEmPcast___1->kind <= 174U)) {
                {
#line 526
                __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                              526U, "declare_template_parameter");
                }
              }
            } else {
              {
#line 526
              __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                            526U, "declare_template_parameter");
              }
            }
          }
#line 526
          elem = (type_element )tEmPcast___1;
        }
        while_break: /* CIL Label */ ;
        }
#line 533
        if (ok) {
#line 533
          if (tname) {
            {
#line 535
            tmp___3 = strlen((tname->ddecl)->name);
#line 535
            tmp___4 = make_cstring(parse_region, (tname->ddecl)->name, (int )tmp___3);
#line 535
            cname = tmp___4;
#line 537
            tmp___5 = declare_type_parameter(l, cname, attributes, extra_attr);
            }
#line 537
            return (tmp___5);
          }
        }
      }
    }
  }
#line 543
  if (! name) {
    {
#line 544
    error("no name specified for parameter");
    }
  } else
#line 545
  if (class) {
    {
#line 546
    error("storage class specified for parameter `%s\'", name);
    }
  }
  {
#line 548
  check_variable_scflags(scf, vd->location, "parameter", name);
#line 552
  tmp___6 = type_real(parm_type);
  }
#line 552
  if (! tmp___6) {
    {
#line 552
    tmp___7 = type_chararray(parm_type, (bool )1);
    }
#line 552
    if (! tmp___7) {
      {
#line 553
      error("only char [] and arithmetic types allowed as component arguments");
      }
    }
  }
  {
#line 555
  tmp___10 = type_array(parm_type);
  }
#line 555
  if (tmp___10) {
    {
#line 557
    tmp___8 = type_array_of(parm_type);
#line 557
    tmp___9 = qualify_type1(tmp___8, parm_type);
#line 557
    parm_type = make_pointer_type(tmp___9);
    }
  }
#line 560
  tEmPcast___4 = (AST_generic )vd;
#line 560
  if (tEmPcast___4) {
#line 560
    if ((unsigned int )tEmPcast___4->kind >= 43U) {
#line 560
      if (! ((unsigned int )tEmPcast___4->kind <= 64U)) {
        {
#line 560
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      560U, "declare_template_parameter");
        }
      }
    } else {
      {
#line 560
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    560U, "declare_template_parameter");
      }
    }
  }
  {
#line 560
  init_data_declaration(& tempdecl, (declaration )tEmPcast___4, name, parm_type);
#line 561
  tempdecl.kind = (data_kind )1;
#line 562
  tempdecl.substitute = (bool )1;
#line 563
  tempdecl.definition = tempdecl.ast;
#line 565
  old_decl = lookup_id(tempdecl.name, (bool )1);
  }
#line 566
  if (old_decl) {
    {
#line 566
    tmp___11 = duplicate_decls(& tempdecl, old_decl, (bool )0, (bool )0);
    }
#line 566
    if (tmp___11) {
#line 567
      ddecl = old_decl;
    } else {
      {
#line 569
      ddecl = declare(current.env, & tempdecl, (bool )0);
      }
    }
  } else {
    {
#line 569
    ddecl = declare(current.env, & tempdecl, (bool )0);
    }
  }
  {
#line 570
  vd->ddecl = ddecl;
#line 572
  ignored_dd_attributes(extra_attr);
#line 573
  ignored_attributes(attributes);
#line 575
  tEmPcast___5 = (AST_generic )dd;
  }
#line 575
  if (tEmPcast___5) {
#line 575
    if ((unsigned int )tEmPcast___5->kind >= 43U) {
#line 575
      if (! ((unsigned int )tEmPcast___5->kind <= 64U)) {
        {
#line 575
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      575U, "declare_template_parameter");
        }
      }
    } else {
      {
#line 575
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    575U, "declare_template_parameter");
      }
    }
  }
#line 575
  return ((declaration )tEmPcast___5);
}
}
#line 578 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
declaration declare_type_parameter(location l , cstring id , attribute attribs , dd_list extra_attr ) 
{ 
  type_parm_decl d ;
  type_parm_decl tmp ;
  data_declaration ddecl ;
  struct data_declaration tempdecl ;
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
  {
#line 581
  tmp = new_type_parm_decl(parse_region, l, id, (data_declaration )((void *)0));
#line 581
  d = tmp;
#line 584
  ddecl = lookup_id((char const   *)id.data, (bool )1);
  }
#line 584
  if (ddecl) {
    {
#line 585
    error("duplicate parameter name `%s\' in parameter list", id.data);
    }
  } else {
#line 590
    tEmPcast = (AST_generic )d;
#line 590
    if (tEmPcast) {
#line 590
      if ((unsigned int )tEmPcast->kind >= 43U) {
#line 590
        if (! ((unsigned int )tEmPcast->kind <= 64U)) {
          {
#line 590
          __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                        590U, "declare_type_parameter");
          }
        }
      } else {
        {
#line 590
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      590U, "declare_type_parameter");
        }
      }
    }
    {
#line 590
    init_data_declaration(& tempdecl, (declaration )tEmPcast, (char const   *)id.data,
                          error_type);
#line 592
    tempdecl.kind = (data_kind )3;
#line 593
    tempdecl.typevar_kind = (enum __anonenum_typevar_kind_43 )1;
#line 594
    tempdecl.definition = tempdecl.ast;
#line 595
    handle_decl_attributes(attribs, & tempdecl);
#line 596
    handle_decl_dd_attributes(extra_attr, & tempdecl);
#line 597
    ddecl = declare(current.env, & tempdecl, (bool )0);
#line 598
    ddecl->type = make_variable_type(ddecl);
    }
  }
#line 600
  d->ddecl = ddecl;
#line 602
  tEmPcast___0 = (AST_generic )d;
#line 602
  if (tEmPcast___0) {
#line 602
    if ((unsigned int )tEmPcast___0->kind >= 43U) {
#line 602
      if (! ((unsigned int )tEmPcast___0->kind <= 64U)) {
        {
#line 602
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      602U, "declare_type_parameter");
        }
      }
    } else {
      {
#line 602
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    602U, "declare_type_parameter");
      }
    }
  }
#line 602
  return ((declaration )tEmPcast___0);
}
}
#line 605 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
expression make_type_argument(asttype t ) 
{ 
  type_argument e ;
  type_argument tmp ;
  AST_generic tEmPcast ;

  {
  {
#line 607
  tmp = new_type_argument(parse_region, t->location, t);
#line 607
  e = tmp;
#line 609
  e->type = t->type;
#line 611
  tEmPcast = (AST_generic )e;
  }
#line 611
  if (tEmPcast) {
#line 611
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 611
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 611
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                      611U, "make_type_argument");
        }
      }
    } else {
      {
#line 611
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c",
                    611U, "make_type_argument");
      }
    }
  }
#line 611
  return ((expression )tEmPcast);
}
}
#line 614 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
nesc_declaration original_component(nesc_declaration c ) 
{ 


  {
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! c->original) {
#line 616
      goto while_break;
    }
#line 617
    c = c->original;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (c);
}
}
#line 622 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_C_tdecl(nesc_attribute attr , tag_declaration tdecl ) 
{ 


  {
#line 624
  if (tdecl->container_function) {
    {
#line 625
    error_with_location(attr->location, "`@C()\' is for symbols with external scope only");
    }
  } else
#line 626
  if (current.container) {
#line 626
    if ((current.container)->abstract) {
      {
#line 627
      error_with_location(attr->location, "@C() cannot be used inside generic components");
      }
    } else {
#line 629
      tdecl->Cname = (bool )1;
    }
  } else {
#line 629
    tdecl->Cname = (bool )1;
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_C_decl(nesc_attribute attr , data_declaration ddecl ) 
{ 


  {
#line 634
  if (! ddecl->isexternalscope) {
    {
#line 635
    error_with_location(attr->location, "`@C()\' is for symbols with external scope only");
    }
  } else
#line 636
  if (current.container) {
#line 636
    if ((current.container)->abstract) {
      {
#line 637
      error_with_location(attr->location, "@C() cannot be used inside generic components");
      }
    } else {
#line 639
      ddecl->Cname = (bool )1;
    }
  } else {
#line 639
    ddecl->Cname = (bool )1;
  }
#line 640
  return;
}
}
#line 642 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static bool require_function(nesc_attribute attr , data_declaration ddecl ) 
{ 


  {
#line 644
  if ((unsigned int )ddecl->kind == 2U) {
#line 644
    if ((unsigned int )ddecl->ftype == 1U) {
#line 645
      return ((bool )1);
    }
  }
  {
#line 647
  error_with_location(attr->location, "`@%s()\' is for external functions only", (attr->word1)->cstring.data);
  }
#line 648
  return ((bool )0);
}
}
#line 651 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_hwevent_decl(nesc_attribute attr , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 653
  tmp = require_function(attr, ddecl);
  }
#line 653
  if (tmp) {
#line 655
    ddecl->async = (bool )1;
#line 656
    ddecl->spontaneous = (call_contexts )2;
  }
#line 658
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_atomic_hwevent_decl(nesc_attribute attr , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 662
  tmp = require_function(attr, ddecl);
  }
#line 662
  if (tmp) {
#line 664
    ddecl->async = (bool )1;
#line 665
    ddecl->spontaneous = (call_contexts )1;
  }
#line 667
  return;
}
}
#line 670 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_spontaneous_decl(nesc_attribute attr , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 672
  tmp = require_function(attr, ddecl);
  }
#line 672
  if (tmp) {
#line 675
    if (! ddecl->spontaneous) {
#line 676
      ddecl->spontaneous = (call_contexts )2;
    }
  }
#line 678
  return;
}
}
#line 680 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_combine_decl(nesc_attribute attr , data_declaration ddecl ) 
{ 
  ivalue fn_init ;
  ivalue tmp ;
  data_declaration fn_name_ddecl ;
  char *fn_name ;

  {
  {
#line 682
  tmp = lookup_attribute_field(attr, "fn");
#line 682
  fn_init = tmp;
  }
#line 686
  if (fn_init) {
#line 686
    if ((unsigned int )fn_init->kind == 0U) {
      {
#line 686
      fn_name_ddecl = string_ddecl(fn_init->u.base.expr);
      }
#line 686
      if (fn_name_ddecl) {
        {
#line 686
        fn_name = ddecl2str(parse_region, fn_name_ddecl);
        }
#line 686
        if (fn_name) {
#line 690
          if ((unsigned int )ddecl->kind == 3U) {
            {
#line 691
            handle_combine_attribute(attr->location, (char const   *)fn_name, & ddecl->type);
            }
          } else {
            {
#line 693
            error_with_location(attr->location, "@combine(\"function-name\") can only be used with typedef");
            }
          }
        } else {
          {
#line 696
          error_with_location(attr->location, "usage is @combine(\"function-name\")");
          }
        }
      } else {
        {
#line 696
        error_with_location(attr->location, "usage is @combine(\"function-name\")");
        }
      }
    } else {
      {
#line 696
      error_with_location(attr->location, "usage is @combine(\"function-name\")");
      }
    }
  } else {
    {
#line 696
    error_with_location(attr->location, "usage is @combine(\"function-name\")");
    }
  }
#line 697
  return;
}
}
#line 699 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static void attr_macro_tdecl(nesc_attribute attr , tag_declaration tdecl ) 
{ 
  ivalue macro_name_init ;
  ivalue tmp ;
  data_declaration macro_name_ddecl ;
  char *macro_name ;
  char *m ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 701
  tmp = lookup_attribute_field(attr, "macro_name");
#line 701
  macro_name_init = tmp;
  }
#line 705
  if (tdecl->kind != 173) {
    {
#line 707
    error_with_location(attr->location, "@macro() can only be applied to attribute declarations");
    }
#line 708
    return;
  }
#line 711
  if (macro_name_init) {
#line 711
    if ((unsigned int )macro_name_init->kind == 0U) {
      {
#line 711
      macro_name_ddecl = string_ddecl(macro_name_init->u.base.expr);
      }
#line 711
      if (macro_name_ddecl) {
        {
#line 711
        macro_name = ddecl2str(parse_region, macro_name_ddecl);
        }
#line 711
        if (! macro_name) {
#line 714
          goto bad;
        }
      } else {
#line 714
        goto bad;
      }
    } else {
#line 714
      goto bad;
    }
  } else {
#line 714
    goto bad;
  }
  {
#line 717
  tmp___0 = __ctype_b_loc();
  }
#line 717
  if (! ((int const   )*(*tmp___0 + (int )*(macro_name + 0)) & 1024)) {
#line 717
    if (! ((int )*(macro_name + 0) == 95)) {
#line 718
      goto bad;
    }
  }
#line 720
  m = macro_name + 1;
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! *m) {
#line 720
      goto while_break;
    }
    {
#line 721
    tmp___1 = __ctype_b_loc();
    }
#line 721
    if (! ((int const   )*(*tmp___1 + (int )*m) & 8)) {
#line 721
      if (! ((int )*m == 95)) {
#line 722
        goto bad;
      }
    }
#line 720
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  tdecl->macro_name = (char const   *)macro_name;
#line 725
  return;
  bad: 
  {
#line 728
  error_with_location(attr->location, "usage is @macro(\"macro-name\")");
  }
#line 729
  return;
}
}
#line 731 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
void init_internal_nesc_attributes(void) 
{ 
  type tmp ;
  type tmp___0 ;

  {
  {
#line 733
  define_internal_attribute("C", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            & attr_C_decl, & attr_C_tdecl, (void (*)(nesc_attribute attr ,
                                                                     field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            (void *)0);
#line 735
  define_internal_attribute("hwevent", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            & attr_hwevent_decl, (void (*)(nesc_attribute attr , tag_declaration tdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            (void *)0);
#line 737
  define_internal_attribute("atomic_hwevent", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            & attr_atomic_hwevent_decl, (void (*)(nesc_attribute attr ,
                                                                  tag_declaration tdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            (void *)0);
#line 739
  define_internal_attribute("spontaneous", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            & attr_spontaneous_decl, (void (*)(nesc_attribute attr ,
                                                               tag_declaration tdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            (void *)0);
#line 741
  tmp = make_pointer_type(char_type);
#line 741
  define_internal_attribute("combine", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            & attr_combine_decl, (void (*)(nesc_attribute attr , tag_declaration tdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            "fn", tmp, (void *)0);
#line 744
  tmp___0 = make_pointer_type(char_type);
#line 744
  define_internal_attribute("macro", (void (*)(nesc_attribute attr , nesc_declaration ndecl ))((void *)0),
                            (void (*)(nesc_attribute attr , data_declaration ddecl ))((void *)0),
                            & attr_macro_tdecl, (void (*)(nesc_attribute attr , field_declaration fdecl ))((void *)0),
                            (void (*)(nesc_attribute attr , type *t ))((void *)0),
                            "macro_name", tmp___0, (void *)0);
  }
#line 746
  return;
}
}
#line 766 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
static int first  =    1;
#line 748 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-semantics.c"
void check_name(char const   *name ) 
{ 
  char const   *occ ;
  char const   *sep ;
  char const   *tmp ;
  int lsep ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 750
  tmp = get_function_separator();
#line 750
  sep = tmp;
#line 751
  tmp___0 = strlen(sep);
#line 751
  lsep = (int )tmp___0;
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 754
    tmp___1 = strncmp(name, sep, (size_t )lsep);
    }
#line 754
    if (tmp___1) {
#line 754
      goto while_break;
    }
#line 755
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 757
  tmp___2 = strstr(name, sep);
#line 757
  occ = (char const   *)tmp___2;
  }
#line 758
  if (! occ) {
#line 759
    return;
  }
  {
#line 762
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 762
    if (*(occ + lsep)) {
      {
#line 762
      tmp___3 = strncmp(occ + 1, sep, (size_t )lsep);
      }
#line 762
      if (tmp___3) {
#line 762
        goto while_break___0;
      }
    } else {
#line 762
      goto while_break___0;
    }
#line 763
    occ ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 764
  if (*(occ + lsep)) {
    {
#line 768
    warning("symbol `%s\' contains the separator `%s\' used in generated code", name,
            sep);
    }
#line 770
    if (first) {
      {
#line 772
      warning("This can cause bugs or compile errors when the C code");
#line 773
      warning("generated by nesC is passed to the underlying C compiler");
#line 774
      first = 0;
      }
    }
  }
#line 777
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_syntax_only  ;
#line 33 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_pedantic_errors  ;
#line 36 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_pack_struct  ;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int inhibit_warnings  ;
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int extra_warnings  ;
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warnings_are_errors  ;
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_unused  ;
#line 53 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_uninitialized  ;
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_shadow  ;
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int error_shadow  ;
#line 60 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_switch  ;
#line 64 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_return_type  ;
#line 69 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_cast_align  ;
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_id_clash  ;
#line 74 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
unsigned int id_clash_len  ;
#line 79 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_larger_than  ;
#line 80 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
unsigned int larger_than_size  ;
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_inline  ;
#line 87 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_aggregate_return  ;
#line 90 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int dollars_in_ident  ;
#line 94 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_cond_mismatch  ;
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_no_asm  ;
#line 100 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_hosted  ;
#line 103 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_implicit  ;
#line 108 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_write_strings  ;
#line 112 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_pointer_arith  ;
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_strict_prototypes  ;
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_redundant_decls  ;
#line 126 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_nested_externs  ;
#line 130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_cast_qual  ;
#line 135 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_bad_function_cast  ;
#line 138 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_traditional  ;
#line 141 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_format  ;
#line 144 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_char_subscripts  ;
#line 147 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_conversion  ;
#line 150 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_main  ;
#line 156 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_traditional  ;
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_allow_single_precision  ;
#line 163 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_parentheses  ;
#line 166 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_missing_braces  ;
#line 169 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_sign_compare  ;
#line 173 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int mesg_implicit_function_declaration  ;
#line 175 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
bool pedantic  ;
#line 178 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_implicit_int  ;
#line 182 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_missing_prototypes  ;
#line 186 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_missing_declarations  ;
#line 189 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_signed_char  ;
#line 192 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_short_enums  ;
#line 198 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_parse_only  ;
#line 203 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_no_debug  ;
#line 207 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_no_inline  ;
#line 210 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_save_macros  ;
#line 214 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
bool use_nido  ;
#line 217
char *nido_num_nodes ;
#line 220
char *nido_mote_number ;
#line 223 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_verbose  ;
#line 226 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_unexpected_docstring  ;
#line 229 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_fnptr  ;
#line 232 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_data_race  ;
#line 235 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_async  ;
#line 238 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_no_combiner  ;
#line 242 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int nesc_error  ;
#line 246 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
char *diff_input  ;
#line 246 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
char *diff_output  ;
#line 250 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_use_scheduler  ;
#line 254 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_mingw_gcc  ;
#line 258 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int nesc_optimise_atomic  ;
#line 262 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_comments  ;
#line 266 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_trigraphs  ;
#line 269 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_unused_macros  ;
#line 272 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_endif_labels  ;
#line 275 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_system_headers  ;
#line 278 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_undef  ;
#line 281 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int warn_missing_include_dirs  ;
#line 287 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_trigraphs  ;
#line 290 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_nostdinc  ;
#line 293 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_undef  ;
#line 296 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_deputy  ;
#line 301 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_default_safe  ;
#line 304 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_c  ;
#line 308 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int flag_gccize  ;
#line 311 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.h"
int print_include_names  ;
#line 152 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.c"
int warn_multichar  =    1;
#line 195 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.c"
int flag_signed_bitfields  =    1;
#line 201 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.c"
char *cmdline_nesc_path  ;
#line 220 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.c"
char *nido_num_nodes  =    (char *)"1000";
#line 223 "/home/wheatley/newnew/temp/nescc-1.3.4/src/flags.c"
char *nido_mote_number  =    (char *)"tos_state.current_node";
#line 230 "./../include/libiberty.h"
int errno_max(void) ;
#line 235
char const   *strerrno(int errnoval ) ;
#line 239
int strtoerrno(char const   *name ) ;
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static void init_error_tables(void) ;
#line 74 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static struct error_info  const  error_table[122]  = 
#line 74
  {      {(int const   )1, (char const   */* const  */)"EPERM"}, 
        {(int const   )2, (char const   */* const  */)"ENOENT"}, 
        {(int const   )3, (char const   */* const  */)"ESRCH"}, 
        {(int const   )4, (char const   */* const  */)"EINTR"}, 
        {(int const   )5, (char const   */* const  */)"EIO"}, 
        {(int const   )6, (char const   */* const  */)"ENXIO"}, 
        {(int const   )7, (char const   */* const  */)"E2BIG"}, 
        {(int const   )8, (char const   */* const  */)"ENOEXEC"}, 
        {(int const   )9, (char const   */* const  */)"EBADF"}, 
        {(int const   )10, (char const   */* const  */)"ECHILD"}, 
        {(int const   )11, (char const   */* const  */)"EWOULDBLOCK"}, 
        {(int const   )11, (char const   */* const  */)"EAGAIN"}, 
        {(int const   )12, (char const   */* const  */)"ENOMEM"}, 
        {(int const   )13, (char const   */* const  */)"EACCES"}, 
        {(int const   )14, (char const   */* const  */)"EFAULT"}, 
        {(int const   )15, (char const   */* const  */)"ENOTBLK"}, 
        {(int const   )16, (char const   */* const  */)"EBUSY"}, 
        {(int const   )17, (char const   */* const  */)"EEXIST"}, 
        {(int const   )18, (char const   */* const  */)"EXDEV"}, 
        {(int const   )19, (char const   */* const  */)"ENODEV"}, 
        {(int const   )20, (char const   */* const  */)"ENOTDIR"}, 
        {(int const   )21, (char const   */* const  */)"EISDIR"}, 
        {(int const   )22, (char const   */* const  */)"EINVAL"}, 
        {(int const   )23, (char const   */* const  */)"ENFILE"}, 
        {(int const   )24, (char const   */* const  */)"EMFILE"}, 
        {(int const   )25, (char const   */* const  */)"ENOTTY"}, 
        {(int const   )26, (char const   */* const  */)"ETXTBSY"}, 
        {(int const   )27, (char const   */* const  */)"EFBIG"}, 
        {(int const   )28, (char const   */* const  */)"ENOSPC"}, 
        {(int const   )29, (char const   */* const  */)"ESPIPE"}, 
        {(int const   )30, (char const   */* const  */)"EROFS"}, 
        {(int const   )31, (char const   */* const  */)"EMLINK"}, 
        {(int const   )32, (char const   */* const  */)"EPIPE"}, 
        {(int const   )33, (char const   */* const  */)"EDOM"}, 
        {(int const   )34, (char const   */* const  */)"ERANGE"}, 
        {(int const   )42, (char const   */* const  */)"ENOMSG"}, 
        {(int const   )43, (char const   */* const  */)"EIDRM"}, 
        {(int const   )44, (char const   */* const  */)"ECHRNG"}, 
        {(int const   )45, (char const   */* const  */)"EL2NSYNC"}, 
        {(int const   )46, (char const   */* const  */)"EL3HLT"}, 
        {(int const   )47, (char const   */* const  */)"EL3RST"}, 
        {(int const   )48, (char const   */* const  */)"ELNRNG"}, 
        {(int const   )49, (char const   */* const  */)"EUNATCH"}, 
        {(int const   )50, (char const   */* const  */)"ENOCSI"}, 
        {(int const   )51, (char const   */* const  */)"EL2HLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLK"}, 
        {(int const   )37, (char const   */* const  */)"ENOLCK"}, 
        {(int const   )52, (char const   */* const  */)"EBADE"}, 
        {(int const   )53, (char const   */* const  */)"EBADR"}, 
        {(int const   )54, (char const   */* const  */)"EXFULL"}, 
        {(int const   )55, (char const   */* const  */)"ENOANO"}, 
        {(int const   )56, (char const   */* const  */)"EBADRQC"}, 
        {(int const   )57, (char const   */* const  */)"EBADSLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLOCK"}, 
        {(int const   )59, (char const   */* const  */)"EBFONT"}, 
        {(int const   )60, (char const   */* const  */)"ENOSTR"}, 
        {(int const   )61, (char const   */* const  */)"ENODATA"}, 
        {(int const   )62, (char const   */* const  */)"ETIME"}, 
        {(int const   )63, (char const   */* const  */)"ENOSR"}, 
        {(int const   )64, (char const   */* const  */)"ENONET"}, 
        {(int const   )65, (char const   */* const  */)"ENOPKG"}, 
        {(int const   )66, (char const   */* const  */)"EREMOTE"}, 
        {(int const   )67, (char const   */* const  */)"ENOLINK"}, 
        {(int const   )68, (char const   */* const  */)"EADV"}, 
        {(int const   )69, (char const   */* const  */)"ESRMNT"}, 
        {(int const   )70, (char const   */* const  */)"ECOMM"}, 
        {(int const   )71, (char const   */* const  */)"EPROTO"}, 
        {(int const   )72, (char const   */* const  */)"EMULTIHOP"}, 
        {(int const   )73, (char const   */* const  */)"EDOTDOT"}, 
        {(int const   )74, (char const   */* const  */)"EBADMSG"}, 
        {(int const   )36, (char const   */* const  */)"ENAMETOOLONG"}, 
        {(int const   )75, (char const   */* const  */)"EOVERFLOW"}, 
        {(int const   )76, (char const   */* const  */)"ENOTUNIQ"}, 
        {(int const   )77, (char const   */* const  */)"EBADFD"}, 
        {(int const   )78, (char const   */* const  */)"EREMCHG"}, 
        {(int const   )79, (char const   */* const  */)"ELIBACC"}, 
        {(int const   )80, (char const   */* const  */)"ELIBBAD"}, 
        {(int const   )81, (char const   */* const  */)"ELIBSCN"}, 
        {(int const   )82, (char const   */* const  */)"ELIBMAX"}, 
        {(int const   )83, (char const   */* const  */)"ELIBEXEC"}, 
        {(int const   )84, (char const   */* const  */)"EILSEQ"}, 
        {(int const   )38, (char const   */* const  */)"ENOSYS"}, 
        {(int const   )40, (char const   */* const  */)"ELOOP"}, 
        {(int const   )85, (char const   */* const  */)"ERESTART"}, 
        {(int const   )86, (char const   */* const  */)"ESTRPIPE"}, 
        {(int const   )39, (char const   */* const  */)"ENOTEMPTY"}, 
        {(int const   )87, (char const   */* const  */)"EUSERS"}, 
        {(int const   )88, (char const   */* const  */)"ENOTSOCK"}, 
        {(int const   )89, (char const   */* const  */)"EDESTADDRREQ"}, 
        {(int const   )90, (char const   */* const  */)"EMSGSIZE"}, 
        {(int const   )91, (char const   */* const  */)"EPROTOTYPE"}, 
        {(int const   )92, (char const   */* const  */)"ENOPROTOOPT"}, 
        {(int const   )93, (char const   */* const  */)"EPROTONOSUPPORT"}, 
        {(int const   )94, (char const   */* const  */)"ESOCKTNOSUPPORT"}, 
        {(int const   )95, (char const   */* const  */)"EOPNOTSUPP"}, 
        {(int const   )96, (char const   */* const  */)"EPFNOSUPPORT"}, 
        {(int const   )97, (char const   */* const  */)"EAFNOSUPPORT"}, 
        {(int const   )98, (char const   */* const  */)"EADDRINUSE"}, 
        {(int const   )99, (char const   */* const  */)"EADDRNOTAVAIL"}, 
        {(int const   )100, (char const   */* const  */)"ENETDOWN"}, 
        {(int const   )101, (char const   */* const  */)"ENETUNREACH"}, 
        {(int const   )102, (char const   */* const  */)"ENETRESET"}, 
        {(int const   )103, (char const   */* const  */)"ECONNABORTED"}, 
        {(int const   )104, (char const   */* const  */)"ECONNRESET"}, 
        {(int const   )105, (char const   */* const  */)"ENOBUFS"}, 
        {(int const   )106, (char const   */* const  */)"EISCONN"}, 
        {(int const   )107, (char const   */* const  */)"ENOTCONN"}, 
        {(int const   )108, (char const   */* const  */)"ESHUTDOWN"}, 
        {(int const   )109, (char const   */* const  */)"ETOOMANYREFS"}, 
        {(int const   )110, (char const   */* const  */)"ETIMEDOUT"}, 
        {(int const   )111, (char const   */* const  */)"ECONNREFUSED"}, 
        {(int const   )112, (char const   */* const  */)"EHOSTDOWN"}, 
        {(int const   )113, (char const   */* const  */)"EHOSTUNREACH"}, 
        {(int const   )114, (char const   */* const  */)"EALREADY"}, 
        {(int const   )115, (char const   */* const  */)"EINPROGRESS"}, 
        {(int const   )116, (char const   */* const  */)"ESTALE"}, 
        {(int const   )117, (char const   */* const  */)"EUCLEAN"}, 
        {(int const   )118, (char const   */* const  */)"ENOTNAM"}, 
        {(int const   )119, (char const   */* const  */)"ENAVAIL"}, 
        {(int const   )120, (char const   */* const  */)"EISNAM"}, 
        {(int const   )121, (char const   */* const  */)"EREMOTEIO"}, 
        {(int const   )0, (char const   */* const  */)((void *)0)}};
#line 452 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static char const   **error_names  ;
#line 453 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static int num_error_names  =    0;
#line 472
extern int sys_nerr ;
#line 505 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static void init_error_tables(void) 
{ 
  struct error_info  const  *eip ;
  int nbytes ;
  void *tmp ;

  {
#line 514
  if (num_error_names == 0) {
#line 516
    eip = error_table;
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 516
        goto while_break;
      }
#line 518
      if (eip->value >= (int const   )num_error_names) {
#line 520
        num_error_names = (int )(eip->value + 1);
      }
#line 516
      eip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 528
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 530
    nbytes = (int )((unsigned long )num_error_names * sizeof(char *));
#line 531
    tmp = malloc((size_t )nbytes);
#line 531
    error_names = (char const   **)tmp;
    }
#line 531
    if ((unsigned long )error_names != (unsigned long )((void *)0)) {
      {
#line 533
      memset((void *)error_names, 0, (size_t )nbytes);
#line 534
      eip = error_table;
      }
      {
#line 534
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 534
        if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 534
          goto while_break___0;
        }
#line 536
        *(error_names + eip->value) = (char const   *)eip->name;
#line 534
        eip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 562
  return;
}
}
#line 586 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
int errno_max(void) 
{ 
  int maxsize ;

  {
#line 591
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 593
    init_error_tables();
    }
  }
#line 595
  if (sys_nerr > num_error_names) {
#line 595
    maxsize = sys_nerr;
  } else {
#line 595
    maxsize = num_error_names;
  }
#line 596
  return (maxsize - 1);
}
}
#line 695 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
static char buf[32]  ;
#line 691 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
char const   *strerrno(int errnoval ) 
{ 
  char const   *name ;

  {
#line 697
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 699
    init_error_tables();
    }
  }
#line 702
  if (errnoval < 0) {
#line 710
    name = (char const   *)((void *)0);
  } else
#line 702
  if (errnoval >= num_error_names) {
#line 710
    name = (char const   *)((void *)0);
  } else
#line 712
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name = (char const   *)(buf);
    }
  } else
#line 712
  if ((unsigned long )*(error_names + errnoval) == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name = (char const   *)(buf);
    }
  } else {
#line 721
    name = *(error_names + errnoval);
  }
#line 724
  return (name);
}
}
#line 738 "/home/wheatley/newnew/temp/nescc-1.3.4/libiberty/./strerror.c"
int strtoerrno(char const   *name ) 
{ 
  int errnoval ;
  int tmp ;

  {
#line 741
  errnoval = 0;
#line 743
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 745
    if ((unsigned long )error_names == (unsigned long )((void *)0)) {
      {
#line 747
      init_error_tables();
      }
    }
#line 749
    errnoval = 0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! (errnoval < num_error_names)) {
#line 749
        goto while_break;
      }
#line 751
      if ((unsigned long )*(error_names + errnoval) != (unsigned long )((void *)0)) {
        {
#line 751
        tmp = strcmp(name, *(error_names + errnoval));
        }
#line 751
        if (tmp == 0) {
#line 754
          goto while_break;
        }
      }
#line 749
      errnoval ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 757
    if (errnoval == num_error_names) {
#line 764
      errnoval = 0;
    }
  }
#line 767
  return (errnoval);
}
}
#line 60 "./libcompat/regions.h"
extern void typed_rarraycopy(void *to , void *from , size_t n , size_t size , type_t type ) ;
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
struct array *new_array(region r , size_t initialsize , size_t typesize , type_t typeinfo ) 
{ 
  struct array *a ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 38
  if (sizeof(struct array ) < (unsigned long )(1 << 9)) {
    {
#line 38
    tmp = __rcralloc_small0(r, sizeof(struct array ));
#line 38
    tmp___1 = tmp;
    }
  } else {
    {
#line 38
    tmp___0 = typed_ralloc(r, sizeof(struct array ), 0);
#line 38
    tmp___1 = tmp___0;
    }
  }
  {
#line 38
  a = (struct array *)tmp___1;
#line 40
  a->r = r;
#line 41
  a->data = typed_rarrayalloc(r, initialsize, typesize, typeinfo);
#line 42
  a->elemsize = typesize;
#line 43
  a->elemtype = typeinfo;
#line 44
  a->nelems = (size_t )0;
#line 45
  a->nalloc = initialsize;
  }
#line 47
  return (a);
}
}
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
void *array_extend(struct array *a , int by ) 
{ 
  size_t oldelems ;
  size_t newsize ;
  void *newdata ;
  void *tmp ;

  {
#line 52
  oldelems = a->nelems;
#line 54
  if (by < 0) {
#line 55
    if ((size_t )(- by) <= a->nelems) {
#line 55
      if (! (by != (-0x7FFFFFFF-1))) {
        {
#line 55
        __assert_fail("-by <= a->nelems && by != (-2147483647 - 1)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c",
                      55U, "array_extend");
        }
      }
    } else {
      {
#line 55
      __assert_fail("-by <= a->nelems && by != (-2147483647 - 1)", "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c",
                    55U, "array_extend");
      }
    }
  } else
#line 56
  if (a->nelems + (size_t )by > a->nalloc) {
    {
#line 58
    newsize = a->nalloc * 2UL + (size_t )by;
#line 59
    tmp = typed_rarrayalloc(a->r, newsize, a->elemsize, a->elemtype);
#line 59
    newdata = tmp;
    }
#line 63
    if (! (newsize > a->nalloc)) {
      {
#line 63
      __assert_fail("newsize > a->nalloc", "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c",
                    63U, "array_extend");
      }
    }
    {
#line 64
    typed_rarraycopy(newdata, a->data, a->nelems, a->elemsize, a->elemtype);
#line 65
    a->data = newdata;
#line 66
    a->nalloc = newsize;
    }
  }
#line 68
  a->nelems += (size_t )by;
#line 70
  return ((void *)((char *)a->data + a->elemsize * oldelems));
}
}
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
void array_reset(struct array *a ) 
{ 


  {
#line 75
  a->nelems = (size_t )0;
#line 76
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
size_t array_length(struct array *a ) 
{ 


  {
#line 80
  return (a->nelems);
}
}
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/array.c"
void *array_data(struct array *a ) 
{ 


  {
#line 85
  return (a->data);
}
}
#line 175 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long double ( __attribute__((__nonnull__(1),
__leaf__)) strtold)(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 127 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern cval type_alignment(type t ) ;
#line 135
extern bool type_has_size(type t ) ;
#line 137
extern bool type_size_cc(type t ) ;
#line 36 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.h"
known_cst make_unknown_cst(cval c , type t ) ;
#line 38
known_cst make_address_cst(data_declaration ddecl , label_declaration ldecl , largest_int offset ,
                           type t ) ;
#line 40
known_cst make_signed_cst(largest_int x , type t ) ;
#line 41
known_cst make_unsigned_cst(largest_uint x , type t ) ;
#line 43
known_cst cast_constant(known_cst c , type to ) ;
#line 56
known_cst fold_alignof(expression e , type atype ) ;
#line 64
known_cst fold_add(type restype , known_cst c1 , known_cst c2 ) ;
#line 72
bool is_zero_constant(known_cst c ) ;
#line 142
bool check_constant_once(expression e , cst_kind k ) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern data_declaration builtin_constant_p ;
#line 20 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-magic.h"
extern known_cst fold_magic(function_call fcall , int pass ) ;
#line 43 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
static known_cst new_known_cst(region r , type t , cval c ) 
{ 
  known_cst kc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 45
  if (sizeof(struct known_cst ) < (unsigned long )(1 << 9)) {
    {
#line 45
    tmp = __rcralloc_small0(parse_region, sizeof(struct known_cst ));
#line 45
    tmp___1 = tmp;
    }
  } else {
    {
#line 45
    tmp___0 = typed_ralloc(parse_region, sizeof(struct known_cst ), 0);
#line 45
    tmp___1 = tmp___0;
    }
  }
#line 45
  kc = (known_cst )tmp___1;
#line 47
  kc->type = t;
#line 48
  kc->cval = c;
#line 50
  return (kc);
}
}
#line 53 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst make_unknown_cst(cval c , type t ) 
{ 
  cval cst ;
  bool tmp ;
  known_cst tmp___0 ;

  {
  {
#line 57
  tmp = cval_isaddress(c);
  }
#line 57
  if (tmp) {
#line 58
    cst = cval_unknown_address;
  } else {
#line 60
    cst = cval_unknown_number;
  }
  {
#line 62
  tmp___0 = new_known_cst(parse_region, t, cst);
  }
#line 62
  return (tmp___0);
}
}
#line 65 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst make_cst(cval c , type t ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;

  {
#line 67
  if ((unsigned int )c.kind == 0U) {
#line 68
    return ((known_cst )((void *)0));
  }
  {
#line 70
  tmp = cval_cast(c, t);
#line 70
  tmp___0 = new_known_cst(parse_region, t, tmp);
  }
#line 70
  return (tmp___0);
}
}
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst make_address_cst(data_declaration ddecl , label_declaration ldecl , largest_int offset ,
                           type t ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;

  {
  {
#line 76
  tmp = make_cval_address(ddecl, ldecl, offset);
#line 76
  tmp___0 = make_cst(tmp, t);
  }
#line 76
  return (tmp___0);
}
}
#line 79 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst make_unsigned_cst(largest_uint x , type t ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;

  {
  {
#line 81
  tmp = make_cval_unsigned(x, t);
#line 81
  tmp___0 = make_cst(tmp, t);
  }
#line 81
  return (tmp___0);
}
}
#line 84 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst make_signed_cst(largest_int x , type t ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;

  {
  {
#line 86
  tmp = make_cval_signed(x, t);
#line 86
  tmp___0 = make_cst(tmp, t);
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst cast_constant(known_cst c , type to ) 
{ 
  bool tmp ;
  cval tmp___0 ;
  known_cst tmp___1 ;

  {
  {
#line 91
  tmp = type_equal(c->type, to);
  }
#line 91
  if (tmp) {
#line 92
    return (c);
  }
  {
#line 94
  tmp___0 = cval_cast(c->cval, to);
#line 94
  tmp___1 = make_cst(tmp___0, to);
  }
#line 94
  return (tmp___1);
}
}
#line 97 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_label_address(expression e ) 
{ 
  AST_generic tEmPcast ;
  known_cst tmp ;

  {
#line 99
  tEmPcast = (AST_generic )e;
#line 99
  if (tEmPcast) {
#line 99
    if ((unsigned int )tEmPcast->kind >= 143U) {
#line 99
      if (! ((unsigned int )tEmPcast->kind <= 143U)) {
        {
#line 99
        __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 99U,
                      "fold_label_address");
        }
      }
    } else {
      {
#line 99
      __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 99U,
                    "fold_label_address");
      }
    }
  }
  {
#line 99
  tmp = make_address_cst((data_declaration )((void *)0), (((label_address )tEmPcast)->id_label)->ldecl,
                         (largest_int )0, e->type);
  }
#line 99
  return (tmp);
}
}
#line 102 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_sizeof(expression e , type stype ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 104
  tmp___1 = type_size_cc(stype);
  }
#line 104
  if (tmp___1) {
    {
#line 105
    tmp = type_size(stype);
#line 105
    tmp___0 = make_cst(tmp, e->type);
    }
#line 105
    return (tmp___0);
  } else {
#line 107
    return ((known_cst )((void *)0));
  }
}
}
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_alignof(expression e , type atype ) 
{ 
  cval tmp ;
  known_cst tmp___0 ;
  known_cst tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 112
  tmp___2 = type_has_size(atype);
  }
#line 112
  if (tmp___2) {
    {
#line 113
    tmp = type_alignment(atype);
#line 113
    tmp___0 = make_cst(tmp, e->type);
    }
#line 113
    return (tmp___0);
  } else {
    {
#line 116
    tmp___1 = make_unsigned_cst((largest_uint )1, e->type);
    }
#line 116
    return (tmp___1);
  }
}
}
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_cast(expression e ) 
{ 
  cast cc ;
  AST_generic tEmPcast ;
  known_cst tmp ;
  bool tmp___0 ;

  {
#line 121
  tEmPcast = (AST_generic )e;
#line 121
  if (tEmPcast) {
#line 121
    if ((unsigned int )tEmPcast->kind >= 86U) {
#line 121
      if (! ((unsigned int )tEmPcast->kind <= 86U)) {
        {
#line 121
        __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 121U,
                      "fold_cast");
        }
      }
    } else {
      {
#line 121
      __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 121U,
                    "fold_cast");
      }
    }
  }
#line 121
  cc = (cast )tEmPcast;
#line 123
  if ((cc->arg1)->cst) {
    {
#line 123
    tmp___0 = type_void(e->type);
    }
#line 123
    if (tmp___0) {
#line 126
      return ((known_cst )((void *)0));
    } else {
      {
#line 124
      tmp = cast_constant((cc->arg1)->cst, e->type);
      }
#line 124
      return (tmp);
    }
  } else {
#line 126
    return ((known_cst )((void *)0));
  }
}
}
#line 130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_unary(expression e ) 
{ 
  unary u ;
  AST_generic tEmPcast ;
  known_cst arg ;
  type t ;
  known_cst tmp ;
  cval tmp___0 ;
  cval tmp___1 ;
  known_cst tmp___2 ;
  cval tmp___3 ;
  cval tmp___4 ;
  known_cst tmp___5 ;
  cval tmp___6 ;
  cval tmp___7 ;
  known_cst tmp___8 ;
  cval tmp___9 ;
  cval tmp___10 ;
  known_cst tmp___11 ;
  known_cst tmp___12 ;
  cval tmp___13 ;
  cval tmp___14 ;
  known_cst tmp___15 ;
  bool tmp___16 ;
  cval tmp___17 ;
  known_cst tmp___18 ;
  cval tmp___19 ;
  cval tmp___20 ;
  known_cst tmp___21 ;
  bool tmp___22 ;

  {
#line 132
  tEmPcast = (AST_generic )e;
#line 132
  if (tEmPcast) {
#line 132
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 132
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 132
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 132U,
                      "fold_unary");
        }
      }
    } else {
      {
#line 132
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 132U,
                    "fold_unary");
      }
    }
  }
#line 132
  u = (unary )tEmPcast;
#line 133
  arg = (u->arg1)->cst;
#line 134
  t = u->type;
#line 136
  if (arg) {
    {
#line 140
    if ((unsigned int )u->kind == 103U) {
#line 140
      goto case_103;
    }
#line 145
    if ((unsigned int )u->kind == 102U) {
#line 145
      goto case_102;
    }
#line 148
    if ((unsigned int )u->kind == 106U) {
#line 148
      goto case_106;
    }
#line 151
    if ((unsigned int )u->kind == 105U) {
#line 151
      goto case_105;
    }
#line 154
    if ((unsigned int )u->kind == 104U) {
#line 154
      goto case_104;
    }
#line 157
    if ((unsigned int )u->kind == 99U) {
#line 157
      goto case_99;
    }
#line 163
    if ((unsigned int )u->kind == 100U) {
#line 163
      goto case_100;
    }
#line 169
    goto switch_default;
    case_103: /* CIL Label */ 
    {
#line 143
    tmp = cast_constant(arg, t);
    }
#line 143
    return (tmp);
    case_102: /* CIL Label */ 
    {
#line 146
    tmp___0 = cval_cast(arg->cval, t);
#line 146
    tmp___1 = cval_negate(tmp___0);
#line 146
    tmp___2 = make_cst(tmp___1, t);
    }
#line 146
    return (tmp___2);
    case_106: /* CIL Label */ 
    {
#line 149
    tmp___3 = cval_cast(arg->cval, t);
#line 149
    tmp___4 = cval_not(tmp___3);
#line 149
    tmp___5 = make_cst(tmp___4, t);
    }
#line 149
    return (tmp___5);
    case_105: /* CIL Label */ 
    {
#line 152
    tmp___6 = cval_cast(arg->cval, t);
#line 152
    tmp___7 = cval_bitnot(tmp___6);
#line 152
    tmp___8 = make_cst(tmp___7, t);
    }
#line 152
    return (tmp___8);
    case_104: /* CIL Label */ 
    {
#line 155
    tmp___9 = cval_cast(arg->cval, t);
#line 155
    tmp___10 = cval_conjugate(tmp___9);
#line 155
    tmp___11 = make_cst(tmp___10, t);
    }
#line 155
    return (tmp___11);
    case_99: /* CIL Label */ 
    {
#line 158
    tmp___16 = type_complex((u->arg1)->type);
    }
#line 158
    if (tmp___16) {
      {
#line 161
      tmp___13 = cval_cast(arg->cval, t);
#line 161
      tmp___14 = cval_realpart(tmp___13);
#line 161
      tmp___15 = make_cst(tmp___14, t);
      }
#line 161
      return (tmp___15);
    } else {
      {
#line 159
      tmp___12 = cast_constant(arg, t);
      }
#line 159
      return (tmp___12);
    }
    case_100: /* CIL Label */ 
    {
#line 164
    tmp___22 = type_complex((u->arg1)->type);
    }
#line 164
    if (tmp___22) {
      {
#line 167
      tmp___19 = cval_cast(arg->cval, t);
#line 167
      tmp___20 = cval_imagpart(tmp___19);
#line 167
      tmp___21 = make_cst(tmp___20, t);
      }
#line 167
      return (tmp___21);
    } else {
      {
#line 165
      tmp___17 = cval_cast(cval_zero, t);
#line 165
      tmp___18 = make_cst(tmp___17, t);
      }
#line 165
      return (tmp___18);
    }
    switch_default: /* CIL Label */ 
    {
#line 170
    __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 170U,
                  "fold_unary");
    }
#line 171
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 174
  return ((known_cst )((void *)0));
}
}
#line 178 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
static known_cst fold_sub(type restype , known_cst c1 , known_cst c2 ) 
{ 
  type t1 ;
  type t2 ;
  type basetype ;
  type ct ;
  cval s ;
  cval tmp ;
  cval res ;
  type tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  cval tmp___6 ;
  cval tmp___7 ;
  cval tmp___8 ;
  cval tmp___9 ;
  cval tmp___10 ;
  cval tmp___11 ;
  cval tmp___12 ;
  cval tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  known_cst tmp___16 ;

  {
  {
#line 180
  t1 = c1->type;
#line 180
  t2 = c2->type;
#line 181
  tmp = make_cval_unsigned((largest_uint )1, size_t_type);
#line 181
  s = tmp;
#line 183
  tmp___4 = type_pointer(t1);
  }
#line 183
  if (tmp___4) {
#line 183
    basetype = t1;
  } else {
    {
#line 183
    tmp___3 = type_pointer(t2);
    }
#line 183
    if (tmp___3) {
#line 183
      tmp___2 = t2;
    } else {
#line 183
      tmp___2 = (type )((void *)0);
    }
#line 183
    basetype = tmp___2;
  }
#line 184
  if (basetype) {
    {
#line 186
    basetype = type_points_to(basetype);
#line 188
    tmp___5 = type_size_cc(basetype);
    }
#line 188
    if (! tmp___5) {
#line 189
      return ((known_cst )((void *)0));
    }
    {
#line 191
    tmp___6 = type_size(basetype);
#line 191
    s = cval_cast(tmp___6, size_t_type);
#line 192
    ct = intptr_type;
    }
  } else {
#line 195
    ct = restype;
  }
  {
#line 197
  s = cval_cast(s, ct);
#line 198
  tmp___14 = type_pointer(t1);
  }
#line 198
  if (tmp___14) {
    {
#line 198
    tmp___15 = type_pointer(t2);
    }
#line 198
    if (tmp___15) {
      {
#line 199
      tmp___7 = cval_cast(c2->cval, ct);
#line 199
      tmp___8 = cval_cast(c1->cval, ct);
#line 199
      tmp___9 = cval_sub(tmp___8, tmp___7);
#line 199
      tmp___10 = cval_cast(tmp___9, ct);
#line 199
      res = cval_divide(tmp___10, s);
      }
    } else {
      {
#line 202
      tmp___11 = cval_cast(c2->cval, ct);
#line 202
      tmp___12 = cval_divide(tmp___11, s);
#line 202
      tmp___13 = cval_cast(c1->cval, ct);
#line 202
      res = cval_sub(tmp___13, tmp___12);
      }
    }
  } else {
    {
#line 202
    tmp___11 = cval_cast(c2->cval, ct);
#line 202
    tmp___12 = cval_divide(tmp___11, s);
#line 202
    tmp___13 = cval_cast(c1->cval, ct);
#line 202
    res = cval_sub(tmp___13, tmp___12);
    }
  }
  {
#line 205
  tmp___16 = make_cst(res, restype);
  }
#line 205
  return (tmp___16);
}
}
#line 209 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_add(type restype , known_cst c1 , known_cst c2 ) 
{ 
  type t1 ;
  type t2 ;
  type ct ;
  cval s ;
  cval tmp ;
  known_cst ctmp ;
  type ttmp ;
  bool tmp___0 ;
  type basetype ;
  type tmp___1 ;
  bool tmp___2 ;
  cval tmp___3 ;
  bool tmp___4 ;
  cval tmp___5 ;
  cval tmp___6 ;
  cval tmp___7 ;
  cval tmp___8 ;
  cval tmp___9 ;
  known_cst tmp___10 ;

  {
  {
#line 211
  t1 = c1->type;
#line 211
  t2 = c2->type;
#line 212
  tmp = make_cval_unsigned((largest_uint )1, size_t_type);
#line 212
  s = tmp;
#line 214
  tmp___0 = type_pointer(t2);
  }
#line 214
  if (tmp___0) {
#line 219
    ctmp = c1;
#line 219
    c1 = c2;
#line 219
    c2 = ctmp;
#line 220
    ttmp = t1;
#line 220
    t1 = t2;
#line 220
    t2 = ttmp;
  }
  {
#line 223
  tmp___4 = type_pointer(t1);
  }
#line 223
  if (tmp___4) {
    {
#line 225
    tmp___1 = type_points_to(t1);
#line 225
    basetype = tmp___1;
#line 227
    tmp___2 = type_size_cc(basetype);
    }
#line 227
    if (! tmp___2) {
#line 228
      return ((known_cst )((void *)0));
    }
    {
#line 230
    tmp___3 = type_size(basetype);
#line 230
    s = cval_cast(tmp___3, size_t_type);
#line 231
    ct = intptr_type;
    }
  } else {
#line 234
    ct = restype;
  }
  {
#line 236
  tmp___5 = cval_cast(s, ct);
#line 236
  tmp___6 = cval_cast(c2->cval, ct);
#line 236
  tmp___7 = cval_times(tmp___6, tmp___5);
#line 236
  tmp___8 = cval_cast(c1->cval, ct);
#line 236
  tmp___9 = cval_add(tmp___8, tmp___7);
#line 236
  tmp___10 = make_cst(tmp___9, restype);
  }
#line 236
  return (tmp___10);
}
}
#line 241 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_binary(type t , expression e ) 
{ 
  binary b ;
  AST_generic tEmPcast ;
  known_cst c1 ;
  known_cst c2 ;
  type t1 ;
  type tmp ;
  type t2 ;
  type tmp___0 ;
  bool c1val ;
  bool tmp___1 ;
  known_cst tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  known_cst tmp___5 ;
  bool c2val ;
  bool tmp___6 ;
  known_cst tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  known_cst tmp___10 ;
  cval cv1 ;
  cval cv2 ;
  known_cst tmp___11 ;
  known_cst tmp___12 ;
  cval res ;
  known_cst tmp___13 ;
  cval res___0 ;
  type ct ;
  bool tmp___14 ;
  bool tmp___15 ;
  cval tmp___16 ;
  cval tmp___17 ;
  cval tmp___18 ;
  known_cst tmp___19 ;

  {
#line 243
  tEmPcast = (AST_generic )e;
#line 243
  if (tEmPcast) {
#line 243
    if ((unsigned int )tEmPcast->kind >= 107U) {
#line 243
      if (! ((unsigned int )tEmPcast->kind <= 139U)) {
        {
#line 243
        __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 243U,
                      "fold_binary");
        }
      }
    } else {
      {
#line 243
      __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 243U,
                    "fold_binary");
      }
    }
  }
  {
#line 243
  b = (binary )tEmPcast;
#line 244
  c1 = (b->arg1)->cst;
#line 244
  c2 = (b->arg2)->cst;
#line 245
  tmp = type_default_conversion((b->arg1)->type);
#line 245
  t1 = tmp;
#line 245
  tmp___0 = type_default_conversion((b->arg2)->type);
#line 245
  t2 = tmp___0;
  }
#line 248
  if ((unsigned int )b->kind == 138U) {
#line 248
    goto _L;
  } else
#line 248
  if ((unsigned int )b->kind == 139U) {
    _L: /* CIL Label */ 
#line 250
    if (c1) {
      {
#line 252
      tmp___4 = cval_knownbool(c1->cval);
      }
#line 252
      if (tmp___4) {
        {
#line 254
        tmp___1 = cval_boolvalue(c1->cval);
#line 254
        c1val = tmp___1;
        }
#line 256
        if ((unsigned int )b->kind == 138U) {
#line 256
          tmp___3 = ! c1val;
        } else {
#line 256
          tmp___3 = (int )c1val;
        }
#line 256
        if (tmp___3) {
          {
#line 257
          tmp___2 = make_signed_cst((largest_int )c1val, t);
          }
#line 257
          return (tmp___2);
        }
      }
#line 259
      if ((unsigned int )c1->cval.kind == 1U) {
        {
#line 260
        tmp___5 = make_unknown_cst(cval_unknown_number, t);
        }
#line 260
        return (tmp___5);
      }
    }
#line 263
    if (c1) {
#line 263
      if (c2) {
        {
#line 265
        tmp___9 = cval_knownbool(c2->cval);
        }
#line 265
        if (tmp___9) {
          {
#line 267
          tmp___6 = cval_boolvalue(c2->cval);
#line 267
          c2val = tmp___6;
          }
#line 268
          if ((unsigned int )b->kind == 138U) {
#line 268
            tmp___8 = ! c2val;
          } else {
#line 268
            tmp___8 = (int )c2val;
          }
#line 268
          if (tmp___8) {
            {
#line 269
            tmp___7 = make_signed_cst((largest_int )c2val, t);
            }
#line 269
            return (tmp___7);
          }
        }
#line 272
        if ((unsigned int )c2->cval.kind == 1U) {
          {
#line 273
          tmp___10 = make_unknown_cst(cval_unknown_number, t);
          }
#line 273
          return (tmp___10);
        }
      }
    }
  } else
#line 276
  if (c1) {
#line 276
    if (c2) {
#line 278
      cv1 = c1->cval;
#line 278
      cv2 = c2->cval;
      {
#line 282
      if ((unsigned int )b->kind == 127U) {
#line 282
        goto case_127;
      }
#line 282
      if ((unsigned int )b->kind == 128U) {
#line 282
        goto case_127;
      }
#line 285
      if ((unsigned int )b->kind == 129U) {
#line 285
        goto case_129;
      }
#line 290
      if ((unsigned int )b->kind == 137U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 136U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 135U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 134U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 133U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 132U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 131U) {
#line 290
        goto case_137;
      }
#line 290
      if ((unsigned int )b->kind == 130U) {
#line 290
        goto case_137;
      }
#line 310
      if ((unsigned int )b->kind == 112U) {
#line 310
        goto case_112;
      }
#line 310
      if ((unsigned int )b->kind == 111U) {
#line 310
        goto case_112;
      }
#line 310
      if ((unsigned int )b->kind == 110U) {
#line 310
        goto case_112;
      }
#line 310
      if ((unsigned int )b->kind == 109U) {
#line 310
        goto case_112;
      }
#line 310
      if ((unsigned int )b->kind == 114U) {
#line 310
        goto case_112;
      }
#line 310
      if ((unsigned int )b->kind == 113U) {
#line 310
        goto case_112;
      }
#line 334
      goto switch_default___1;
      case_127: /* CIL Label */ 
      case_128: /* CIL Label */ 
      {
#line 283
      tmp___11 = fold_add(t, c1, c2);
      }
#line 283
      return (tmp___11);
      case_129: /* CIL Label */ 
      {
#line 286
      tmp___12 = fold_sub(t, c1, c2);
      }
#line 286
      return (tmp___12);
      case_137: /* CIL Label */ 
      case_136: /* CIL Label */ 
      case_135: /* CIL Label */ 
      case_134: /* CIL Label */ 
      case_133: /* CIL Label */ 
      case_132: /* CIL Label */ 
      case_131: /* CIL Label */ 
      case_130: /* CIL Label */ 
      {
#line 293
      cv1 = cval_cast(cv1, t);
#line 294
      cv2 = cval_cast(cv2, t);
      }
      {
#line 297
      if ((unsigned int )b->kind == 130U) {
#line 297
        goto case_130___0;
      }
#line 298
      if ((unsigned int )b->kind == 131U) {
#line 298
        goto case_131___0;
      }
#line 299
      if ((unsigned int )b->kind == 132U) {
#line 299
        goto case_132___0;
      }
#line 300
      if ((unsigned int )b->kind == 133U) {
#line 300
        goto case_133___0;
      }
#line 301
      if ((unsigned int )b->kind == 134U) {
#line 301
        goto case_134___0;
      }
#line 302
      if ((unsigned int )b->kind == 135U) {
#line 302
        goto case_135___0;
      }
#line 303
      if ((unsigned int )b->kind == 136U) {
#line 303
        goto case_136___0;
      }
#line 304
      if ((unsigned int )b->kind == 137U) {
#line 304
        goto case_137___0;
      }
#line 305
      goto switch_default;
      case_130___0: /* CIL Label */ 
      {
#line 297
      res = cval_times(cv1, cv2);
      }
#line 297
      goto switch_break___0;
      case_131___0: /* CIL Label */ 
      {
#line 298
      res = cval_divide(cv1, cv2);
      }
#line 298
      goto switch_break___0;
      case_132___0: /* CIL Label */ 
      {
#line 299
      res = cval_modulo(cv1, cv2);
      }
#line 299
      goto switch_break___0;
      case_133___0: /* CIL Label */ 
      {
#line 300
      res = cval_lshift(cv1, cv2);
      }
#line 300
      goto switch_break___0;
      case_134___0: /* CIL Label */ 
      {
#line 301
      res = cval_rshift(cv1, cv2);
      }
#line 301
      goto switch_break___0;
      case_135___0: /* CIL Label */ 
      {
#line 302
      res = cval_bitand(cv1, cv2);
      }
#line 302
      goto switch_break___0;
      case_136___0: /* CIL Label */ 
      {
#line 303
      res = cval_bitor(cv1, cv2);
      }
#line 303
      goto switch_break___0;
      case_137___0: /* CIL Label */ 
      {
#line 304
      res = cval_bitxor(cv1, cv2);
      }
#line 304
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 305
      abort();
      }
#line 305
      return ((known_cst )((void *)0));
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 307
      tmp___13 = make_cst(res, t);
      }
#line 307
      return (tmp___13);
      case_112: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_109: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_113: /* CIL Label */ 
      {
#line 315
      tmp___14 = type_pointer(t1);
      }
#line 315
      if (tmp___14) {
#line 316
        ct = intptr_type;
      } else {
        {
#line 315
        tmp___15 = type_pointer(t2);
        }
#line 315
        if (tmp___15) {
#line 316
          ct = intptr_type;
        } else {
          {
#line 318
          ct = common_type(t1, t2);
          }
        }
      }
      {
#line 320
      cv1 = cval_cast(cv1, ct);
#line 321
      cv2 = cval_cast(cv2, ct);
      }
      {
#line 324
      if ((unsigned int )b->kind == 113U) {
#line 324
        goto case_113___0;
      }
#line 325
      if ((unsigned int )b->kind == 114U) {
#line 325
        goto case_114___0;
      }
#line 326
      if ((unsigned int )b->kind == 109U) {
#line 326
        goto case_109___0;
      }
#line 327
      if ((unsigned int )b->kind == 110U) {
#line 327
        goto case_110___0;
      }
#line 328
      if ((unsigned int )b->kind == 111U) {
#line 328
        goto case_111___0;
      }
#line 329
      if ((unsigned int )b->kind == 112U) {
#line 329
        goto case_112___0;
      }
#line 330
      goto switch_default___0;
      case_113___0: /* CIL Label */ 
      {
#line 324
      res___0 = cval_eq(cv1, cv2);
      }
#line 324
      goto switch_break___1;
      case_114___0: /* CIL Label */ 
      {
#line 325
      tmp___16 = cval_eq(cv1, cv2);
#line 325
      res___0 = cval_not(tmp___16);
      }
#line 325
      goto switch_break___1;
      case_109___0: /* CIL Label */ 
      {
#line 326
      res___0 = cval_leq(cv1, cv2);
      }
#line 326
      goto switch_break___1;
      case_110___0: /* CIL Label */ 
      {
#line 327
      res___0 = cval_leq(cv2, cv1);
      }
#line 327
      goto switch_break___1;
      case_111___0: /* CIL Label */ 
      {
#line 328
      tmp___17 = cval_leq(cv2, cv1);
#line 328
      res___0 = cval_not(tmp___17);
      }
#line 328
      goto switch_break___1;
      case_112___0: /* CIL Label */ 
      {
#line 329
      tmp___18 = cval_leq(cv1, cv2);
#line 329
      res___0 = cval_not(tmp___18);
      }
#line 329
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 330
      abort();
      }
#line 330
      return ((known_cst )((void *)0));
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 332
      tmp___19 = make_cst(res___0, t);
      }
#line 332
      return (tmp___19);
      switch_default___1: /* CIL Label */ 
      {
#line 335
      __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c",
                    335U, "fold_binary");
      }
#line 335
      return ((known_cst )((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 339
  return ((known_cst )((void *)0));
}
}
#line 342 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_conditional(expression e ) 
{ 
  conditional c ;
  AST_generic tEmPcast ;
  known_cst cond ;
  expression arg1 ;
  expression tmp ;
  known_cst kc1 ;
  known_cst kc2 ;
  expression value ;
  expression tmp___1 ;
  bool tmp___2 ;
  known_cst tmp___3 ;
  cval tmp___5 ;
  bool tmp___6 ;
  known_cst tmp___7 ;
  bool tmp___8 ;

  {
#line 344
  tEmPcast = (AST_generic )e;
#line 344
  if (tEmPcast) {
#line 344
    if ((unsigned int )tEmPcast->kind >= 145U) {
#line 344
      if (! ((unsigned int )tEmPcast->kind <= 145U)) {
        {
#line 344
        __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 344U,
                      "fold_conditional");
        }
      }
    } else {
      {
#line 344
      __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 344U,
                    "fold_conditional");
      }
    }
  }
#line 344
  c = (conditional )tEmPcast;
#line 345
  cond = (c->condition)->cst;
#line 347
  if (cond) {
#line 349
    if (c->arg1) {
#line 349
      tmp = c->arg1;
    } else {
#line 349
      tmp = c->condition;
    }
    {
#line 349
    arg1 = tmp;
#line 350
    kc1 = arg1->cst;
#line 350
    kc2 = (c->arg2)->cst;
#line 352
    tmp___8 = cval_knownbool(cond->cval);
    }
#line 352
    if (tmp___8) {
      {
#line 354
      tmp___2 = cval_boolvalue(cond->cval);
      }
#line 354
      if (tmp___2) {
#line 354
        tmp___1 = arg1;
      } else {
#line 354
        tmp___1 = c->arg2;
      }
#line 354
      value = tmp___1;
#line 356
      e->static_address = value->static_address;
#line 357
      if (value->cst) {
        {
#line 358
        tmp___3 = cast_constant(value->cst, e->type);
        }
#line 358
        return (tmp___3);
      } else {
#line 360
        return ((known_cst )((void *)0));
      }
    } else
#line 362
    if ((unsigned int )cond->cval.kind == 1U) {
#line 362
      if (kc1) {
#line 362
        if (kc2) {
          {
#line 366
          tmp___6 = cval_isaddress(kc1->cval);
          }
#line 366
          if (tmp___6) {
#line 366
            tmp___5 = kc1->cval;
          } else {
#line 366
            tmp___5 = kc2->cval;
          }
          {
#line 366
          tmp___7 = make_unknown_cst(tmp___5, e->type);
          }
#line 366
          return (tmp___7);
        }
      }
    }
  }
#line 370
  return ((known_cst )((void *)0));
}
}
#line 373 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_function_call(expression e , int pass ) 
{ 
  function_call fce ;
  AST_generic tEmPcast ;
  known_cst tmp ;
  bool tmp___0 ;
  known_cst tmp___1 ;

  {
#line 375
  tEmPcast = (AST_generic )e;
#line 375
  if (tEmPcast) {
#line 375
    if ((unsigned int )tEmPcast->kind >= 148U) {
#line 375
      if (! ((unsigned int )tEmPcast->kind <= 148U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 375U,
                      "fold_function_call");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 375U,
                    "fold_function_call");
      }
    }
  }
  {
#line 375
  fce = (function_call )tEmPcast;
#line 377
  tmp___0 = call_to(builtin_constant_p, fce);
  }
#line 377
  if (tmp___0) {
#line 377
    if (fce->args) {
      {
#line 378
      tmp = make_signed_cst((largest_int )((unsigned long )(fce->args)->cst != (unsigned long )((void *)0)),
                            int_type);
      }
#line 378
      return (tmp);
    }
  }
  {
#line 380
  tmp___1 = fold_magic(fce, pass);
  }
#line 380
  return (tmp___1);
}
}
#line 383 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst fold_identifier(expression e , data_declaration decl , int pass ) 
{ 
  cval tmp___0 ;
  bool tmp___1 ;
  known_cst tmp___2 ;
  known_cst tmp___3 ;

  {
#line 385
  if ((unsigned int )decl->kind == 1U) {
#line 387
    if (pass == 0) {
#line 387
      if (decl->substitute) {
        {
#line 387
        tmp___1 = type_real(e->type);
        }
#line 387
        if (tmp___1) {
#line 387
          tmp___0 = cval_unknown_number;
        } else {
#line 387
          tmp___0 = cval_unknown_address;
        }
        {
#line 387
        tmp___2 = make_unknown_cst(tmp___0, e->type);
#line 387
        tmp___3 = tmp___2;
        }
      } else {
#line 387
        tmp___3 = decl->value;
      }
    } else {
#line 387
      tmp___3 = decl->value;
    }
#line 387
    return (tmp___3);
  } else {
#line 392
    return ((known_cst )((void *)0));
  }
}
}
#line 395 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst foldaddress_identifier(expression e , data_declaration decl ) 
{ 
  type tmp ;
  known_cst tmp___0 ;

  {
#line 397
  if ((unsigned int )decl->kind == 2U) {
#line 397
    if ((unsigned int )decl->ftype != 3U) {
      {
#line 400
      tmp = make_pointer_type(e->type);
#line 400
      tmp___0 = make_address_cst(decl, (label_declaration )((void *)0), (largest_int )0,
                                 tmp);
      }
#line 400
      return (tmp___0);
    } else {
#line 397
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 397
  if ((unsigned int )decl->kind == 0U) {
#line 397
    if (! decl->islocal) {
      {
#line 400
      tmp = make_pointer_type(e->type);
#line 400
      tmp___0 = make_address_cst(decl, (label_declaration )((void *)0), (largest_int )0,
                                 tmp);
      }
#line 400
      return (tmp___0);
    } else {
#line 397
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 397
  if ((unsigned int )decl->kind == 5U) {
    {
#line 400
    tmp = make_pointer_type(e->type);
#line 400
    tmp___0 = make_address_cst(decl, (label_declaration )((void *)0), (largest_int )0,
                               tmp);
    }
#line 400
    return (tmp___0);
  } else {
#line 402
    return ((known_cst )((void *)0));
  }
}
}
#line 405 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst foldaddress_string(string s ) 
{ 
  known_cst tmp ;

  {
  {
#line 407
  tmp = make_address_cst(s->ddecl, (label_declaration )((void *)0), (largest_int )0,
                         s->type);
  }
#line 407
  return (tmp);
}
}
#line 410 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
known_cst foldaddress_field_ref(expression e ) 
{ 
  field_ref fref ;
  AST_generic tEmPcast ;
  field_declaration fdecl ;
  known_cst object ;
  cval field_offset ;
  type pftype ;
  known_cst tmp ;
  bool tmp___0 ;
  cval tmp___1 ;
  cval tmp___2 ;
  known_cst tmp___3 ;

  {
#line 412
  tEmPcast = (AST_generic )e;
#line 412
  if (tEmPcast) {
#line 412
    if ((unsigned int )tEmPcast->kind >= 87U) {
#line 412
      if (! ((unsigned int )tEmPcast->kind <= 87U)) {
        {
#line 412
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 412U,
                      "foldaddress_field_ref");
        }
      }
    } else {
      {
#line 412
      __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c", 412U,
                    "foldaddress_field_ref");
      }
    }
  }
#line 412
  fref = (field_ref )tEmPcast;
#line 413
  fdecl = fref->fdecl;
#line 414
  object = (fref->arg1)->static_address;
#line 418
  if (! object) {
#line 419
    return ((known_cst )((void *)0));
  } else
#line 418
  if ((unsigned int )fdecl->offset.kind == 0U) {
#line 419
    return ((known_cst )((void *)0));
  } else
#line 418
  if (! ((unsigned int )fdecl->bitwidth.kind == 0U)) {
#line 419
    return ((known_cst )((void *)0));
  }
  {
#line 421
  tmp___0 = cval_isunknown(object->cval);
  }
#line 421
  if (tmp___0) {
    {
#line 422
    tmp = make_unknown_cst(object->cval, object->type);
    }
#line 422
    return (tmp);
  }
  {
#line 424
  pftype = make_pointer_type(fdecl->type);
#line 425
  field_offset = cval_divide(fdecl->offset, cval_bitsperbyte);
#line 430
  tmp___1 = cval_cast(field_offset, pftype);
#line 430
  tmp___2 = cval_add(object->cval, tmp___1);
#line 430
  tmp___3 = make_cst(tmp___2, pftype);
  }
#line 430
  return (tmp___3);
}
}
#line 438 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
lexical_cst fold_lexical_real(type realtype , location loc , cstring tok ) 
{ 
  lexical_cst c ;
  lexical_cst tmp ;
  cval realvalue ;
  long double tmp___0 ;
  cval tmp___1 ;
  type tmp___2 ;
  cval tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 440
  tmp = new_lexical_cst(parse_region, loc, tok);
#line 440
  c = tmp;
#line 441
  tmp___0 = strtold((char const   */* __restrict  */)tok.data, (char **/* __restrict  */)((void *)0));
#line 441
  tmp___1 = make_cval_float(tmp___0);
#line 441
  realvalue = tmp___1;
#line 443
  tmp___4 = type_complex(realtype);
  }
#line 443
  if (tmp___4) {
    {
#line 444
    tmp___2 = make_base_type(realtype);
#line 444
    tmp___3 = cval_cast(cval_zero, tmp___2);
#line 444
    realvalue = make_cval_complex(tmp___3, realvalue);
    }
  }
  {
#line 445
  c->cst = make_cst(realvalue, realtype);
#line 446
  c->type = realtype;
  }
#line 447
  return (c);
}
}
#line 450 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
lexical_cst fold_lexical_char(location loc , cstring tok , bool wide_flag , int charvalue ) 
{ 
  lexical_cst c ;
  lexical_cst tmp ;
  type ctype ;
  type tmp___0 ;
  cval tmp___2 ;
  cval tmp___3 ;
  cval tmp___4 ;
  bool tmp___5 ;

  {
  {
#line 453
  tmp = new_lexical_cst(parse_region, loc, tok);
#line 453
  c = tmp;
  }
#line 454
  if (wide_flag) {
#line 454
    tmp___0 = wchar_type;
  } else {
#line 454
    tmp___0 = int_type;
  }
  {
#line 454
  ctype = tmp___0;
#line 456
  c->type = ctype;
#line 457
  tmp___5 = type_unsigned(ctype);
  }
#line 457
  if (tmp___5) {
    {
#line 457
    tmp___2 = make_cval_unsigned((largest_uint )charvalue, ctype);
#line 457
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 457
    tmp___3 = make_cval_signed((largest_int )charvalue, ctype);
#line 457
    tmp___4 = tmp___3;
    }
  }
  {
#line 457
  c->cst = make_cst(tmp___4, ctype);
  }
#line 461
  return (c);
}
}
#line 464 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
string fold_lexical_string(location loc , string_cst components , cstring value ,
                           bool wide_flag ) 
{ 
  data_declaration sdecl ;
  data_declaration tmp ;
  string s ;
  string tmp___0 ;

  {
  {
#line 467
  tmp = declare_string((char const   *)((void *)0), value, wide_flag);
#line 467
  sdecl = tmp;
#line 468
  tmp___0 = new_string(parse_region, loc, components, sdecl);
#line 468
  s = tmp___0;
#line 470
  s->type = sdecl->type;
#line 471
  s->static_address = foldaddress_string(s);
#line 472
  s->lvalue = (bool )1;
  }
#line 474
  return (s);
}
}
#line 477 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
lexical_cst fold_lexical_int(type itype , location loc , cstring tok , bool iscomplex ,
                             largest_uint intvalue , bool overflow ) 
{ 
  lexical_cst c ;
  lexical_cst tmp ;
  cval cv ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  cval tmp___7 ;
  cval tmp___8 ;
  bool tmp___9 ;
  cval tmp___10 ;

  {
  {
#line 480
  tmp = new_lexical_cst(parse_region, loc, tok);
#line 480
  c = tmp;
  }
#line 483
  if (overflow) {
    {
#line 485
    warning_with_location(loc, "integer constant out of range");
#line 486
    itype = unsigned_long_long_type;
    }
  } else {
    {
#line 491
    tmp___5 = uint_inrange(intvalue, itype);
    }
#line 491
    if (! tmp___5) {
      {
#line 493
      tmp___4 = uint_inrange(intvalue, unsigned_int_type);
      }
#line 493
      if (tmp___4) {
        {
#line 495
        warning_with_location(loc, "decimal constant is so large that it is unsigned");
#line 496
        itype = unsigned_int_type;
        }
      } else {
        {
#line 499
        tmp___3 = uint_inrange(intvalue, long_type);
        }
#line 499
        if (tmp___3) {
#line 500
          itype = long_type;
        } else {
          {
#line 501
          tmp___2 = uint_inrange(intvalue, unsigned_long_type);
          }
#line 501
          if (tmp___2) {
#line 502
            itype = unsigned_long_type;
          } else {
            {
#line 503
            tmp___1 = uint_inrange(intvalue, long_long_type);
            }
#line 503
            if (tmp___1) {
#line 504
              itype = long_long_type;
            } else {
              {
#line 505
              tmp___0 = uint_inrange(intvalue, unsigned_long_long_type);
              }
#line 505
              if (tmp___0) {
#line 506
                itype = unsigned_long_long_type;
              }
            }
          }
        }
      }
    }
  }
  {
#line 510
  tmp___9 = type_unsigned(itype);
  }
#line 510
  if (tmp___9) {
    {
#line 510
    tmp___7 = make_cval_unsigned(intvalue, itype);
#line 510
    cv = tmp___7;
    }
  } else {
    {
#line 510
    tmp___8 = make_cval_signed((largest_int )intvalue, itype);
#line 510
    cv = tmp___8;
    }
  }
#line 512
  if (iscomplex) {
    {
#line 514
    tmp___10 = cval_cast(cval_zero, itype);
#line 514
    cv = make_cval_complex(tmp___10, cv);
#line 515
    itype = make_complex_type(itype);
    }
  }
  {
#line 518
  c->type = itype;
#line 519
  c->cst = make_cst(cv, itype);
  }
#line 521
  return (c);
}
}
#line 525 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
bool definite_null(expression e ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  type tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
  {
#line 527
  tmp = type_integer(e->type);
  }
#line 527
  if (tmp) {
#line 527
    goto _L;
  } else {
    {
#line 527
    tmp___0 = type_pointer(e->type);
    }
#line 527
    if (tmp___0) {
      {
#line 527
      tmp___1 = type_points_to(e->type);
#line 527
      tmp___2 = type_void(tmp___1);
      }
#line 527
      if (tmp___2) {
        _L: /* CIL Label */ 
        {
#line 527
        tmp___3 = definite_zero(e);
        }
#line 527
        if (tmp___3) {
#line 527
          tmp___4 = 1;
        } else {
#line 527
          tmp___4 = 0;
        }
      } else {
#line 527
        tmp___4 = 0;
      }
    } else {
#line 527
      tmp___4 = 0;
    }
  }
#line 527
  return ((bool )tmp___4);
}
}
#line 533 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
bool definite_zero(expression e ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 535
  if (e->cst) {
    {
#line 535
    tmp = is_zero_constant(e->cst);
    }
#line 535
    if (tmp) {
#line 535
      tmp___0 = 1;
    } else {
#line 535
      tmp___0 = 0;
    }
  } else {
#line 535
    tmp___0 = 0;
  }
#line 535
  return ((bool )tmp___0);
}
}
#line 538 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
bool is_zero_constant(known_cst c ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 540
  tmp = cval_knownbool(c->cval);
  }
#line 540
  if (tmp) {
    {
#line 540
    tmp___0 = cval_boolvalue(c->cval);
    }
#line 540
    if (tmp___0) {
#line 540
      tmp___1 = 0;
    } else {
#line 540
      tmp___1 = 1;
    }
  } else {
#line 540
    tmp___1 = 0;
  }
#line 540
  return ((bool )tmp___1);
}
}
#line 546 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
void constant_overflow_warning(known_cst c ) 
{ 


  {
#line 548
  return;
}
}
#line 550 "/home/wheatley/newnew/temp/nescc-1.3.4/src/constants.c"
bool check_constant_once(expression e , cst_kind k ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 574
  if (e->cst_checked) {
#line 575
    return ((bool )0);
  }
#line 577
  if (e->cst) {
    {
#line 577
    tmp___0 = cval_isunknown((e->cst)->cval);
    }
#line 577
    if (tmp___0) {
#line 579
      if ((unsigned int )k == 0U) {
#line 582
        return ((bool )0);
      } else
#line 579
      if ((unsigned int )k == 1U) {
#line 579
        if ((unsigned int )(e->cst)->cval.kind == 1U) {
#line 582
          return ((bool )0);
        } else {
#line 579
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 579
      if ((unsigned int )k == 2U) {
        {
#line 579
        tmp = cval_isaddress((e->cst)->cval);
        }
#line 579
        if (tmp) {
#line 582
          return ((bool )0);
        }
      }
    }
  }
#line 584
  e->cst_checked = (bool )1;
#line 586
  return ((bool )1);
}
}
#line 36 "/home/wheatley/newnew/temp/nescc-1.3.4/src/utils.h"
extern int ilog2(largest_uint x ) ;
#line 94 "/home/wheatley/newnew/temp/nescc-1.3.4/src/types.h"
extern type align_type(type t , cval new_alignment ) ;
#line 6 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.h"
void ignored_attribute(attribute attr ) ;
#line 9
void ignored_gcc_attribute(gcc_attribute attr ) ;
#line 10
void ignored_nesc_attribute(nesc_attribute attr ) ;
#line 23
void handle_nescdecl_attribute(attribute attr , nesc_declaration ndecl ) ;
#line 24
void handle_decl_attribute(attribute attr , data_declaration ddecl ) ;
#line 25
void handle_field_attribute(attribute attr , field_declaration fdecl ) ;
#line 26
void handle_tag_attribute(attribute attr , tag_declaration tdecl ) ;
#line 27
bool handle_type_attribute(attribute attr , type *t ) ;
#line 32
void handle_field_attributes(attribute alist , field_declaration fdecl ) ;
#line 33
void handle_tag_attributes(attribute alist , tag_declaration tdecl ) ;
#line 34
void handle_nescdecl_dd_attributes(dd_list alist , nesc_declaration ndecl ) ;
#line 36
void handle_field_dd_attributes(dd_list alist , field_declaration fdecl ) ;
#line 37
void handle_tag_dd_attributes(dd_list alist , tag_declaration tdecl ) ;
#line 238 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern bool handle_mode_attribute(location loc , data_declaration ddecl , char const   *mode ) ;
#line 36 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-attributes.h"
extern void handle_nesc_type_attribute(nesc_attribute attr , type *t ) ;
#line 37
extern void handle_nesc_decl_attribute(nesc_attribute attr , data_declaration ddecl ) ;
#line 38
extern void handle_nesc_field_attribute(nesc_attribute attr , field_declaration fdecl ) ;
#line 39
extern void handle_nesc_tag_attribute(nesc_attribute attr , tag_declaration tdecl ) ;
#line 40
extern void handle_nesc_nescdecl_attribute(nesc_attribute attr , nesc_declaration ndecl ) ;
#line 13 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void ignored_attribute(attribute attr ) 
{ 


  {
  {
#line 15
  warning_with_location(attr->location, "`%s\' attribute directive ignored", (attr->word1)->cstring.data);
  }
#line 17
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void ignored_gcc_attribute(gcc_attribute attr ) 
{ 
  AST_generic tEmPcast ;

  {
#line 21
  tEmPcast = (AST_generic )attr;
#line 21
  if (tEmPcast) {
#line 21
    if ((unsigned int )tEmPcast->kind >= 162U) {
#line 21
      if (! ((unsigned int )tEmPcast->kind <= 165U)) {
        {
#line 21
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 21U,
                      "ignored_gcc_attribute");
        }
      }
    } else {
      {
#line 21
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 21U,
                    "ignored_gcc_attribute");
      }
    }
  }
  {
#line 21
  ignored_attribute((attribute )tEmPcast);
  }
#line 22
  return;
}
}
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void ignored_nesc_attribute(nesc_attribute attr ) 
{ 
  AST_generic tEmPcast ;

  {
#line 26
  tEmPcast = (AST_generic )attr;
#line 26
  if (tEmPcast) {
#line 26
    if ((unsigned int )tEmPcast->kind >= 162U) {
#line 26
      if (! ((unsigned int )tEmPcast->kind <= 165U)) {
        {
#line 26
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 26U,
                      "ignored_nesc_attribute");
        }
      }
    } else {
      {
#line 26
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 26U,
                    "ignored_nesc_attribute");
      }
    }
  }
  {
#line 26
  ignored_attribute((attribute )tEmPcast);
  }
#line 27
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void ignored_attributes(attribute alist ) 
{ 
  AST_generic tEmPcast ;

  {
#line 31
  alist = alist;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! alist) {
#line 31
      goto while_break;
    }
    {
#line 32
    ignored_attribute(alist);
#line 31
    tEmPcast = (AST_generic )alist->next;
    }
#line 31
    if (tEmPcast) {
#line 31
      if ((unsigned int )tEmPcast->kind >= 162U) {
#line 31
        if (! ((unsigned int )tEmPcast->kind <= 165U)) {
          {
#line 31
          __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        31U, "ignored_attributes");
          }
        }
      } else {
        {
#line 31
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 31U,
                      "ignored_attributes");
        }
      }
    }
#line 31
    alist = (attribute )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void ignored_dd_attributes(dd_list alist ) 
{ 
  dd_list_pos attr ;

  {
#line 39
  if (alist) {
    {
#line 40
    attr = dd_first(alist);
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! (! (! attr->next))) {
#line 40
        goto while_break;
      }
      {
#line 41
      ignored_attribute((attribute )attr->data);
#line 40
      attr = attr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
cval gcc_attr_get_constant(gcc_attribute attr ) 
{ 


  {
#line 46
  if (! attr->args) {
#line 47
    return (cval_top);
  } else
#line 46
  if ((attr->args)->next) {
#line 47
    return (cval_top);
  } else
#line 46
  if (! (attr->args)->cst) {
#line 47
    return (cval_top);
  } else {
#line 49
    return (((attr->args)->cst)->cval);
  }
}
}
#line 52 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
char const   *gcc_attr_get_word(gcc_attribute attr ) 
{ 
  AST_generic tEmPcast ;

  {
#line 54
  if (attr->args) {
#line 54
    if (! (attr->args)->next) {
#line 54
      if ((unsigned int )(attr->args)->kind >= 146U) {
#line 54
        if ((unsigned int )(attr->args)->kind <= 146U) {
#line 55
          tEmPcast = (AST_generic )attr->args;
#line 55
          if (tEmPcast) {
#line 55
            if ((unsigned int )tEmPcast->kind >= 146U) {
#line 55
              if (! ((unsigned int )tEmPcast->kind <= 146U)) {
                {
#line 55
                __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                              55U, "gcc_attr_get_word");
                }
              }
            } else {
              {
#line 55
              __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                            55U, "gcc_attr_get_word");
              }
            }
          }
#line 55
          return ((char const   *)((identifier )tEmPcast)->cstring.data);
        }
      }
    }
  }
  {
#line 57
  error_with_location(attr->location, "wrong number of arguments specified for `%s\' attribute",
                      (attr->word1)->cstring.data);
  }
#line 60
  return ((char const   *)((void *)0));
}
}
#line 63 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
static size_t max_useful_alignment(void) 
{ 
  size_t max_align ;

  {
#line 65
  max_align = (size_t )0;
#line 71
  if (max_align < target->int8_align) {
#line 71
    max_align = target->int8_align;
  }
#line 72
  if (max_align < target->tptr.align) {
#line 72
    max_align = target->tptr.align;
  }
#line 73
  if (max_align < target->tlong_double.align) {
#line 73
    max_align = target->tlong_double.align;
  }
#line 74
  if (max_align < target->tlong_long.align) {
#line 74
    max_align = target->tlong_long.align;
  }
#line 77
  return (max_align);
}
}
#line 80 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
static cval get_alignment(gcc_attribute attr ) 
{ 
  cval arg ;
  size_t tmp ;
  cval tmp___0 ;
  cval tmp___1 ;
  largest_uint tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 84
  if (! attr->args) {
    {
#line 85
    tmp = max_useful_alignment();
#line 85
    tmp___0 = make_cval_unsigned((largest_uint )tmp, size_t_type);
    }
#line 85
    return (tmp___0);
  }
  {
#line 87
  arg = gcc_attr_get_constant(attr);
#line 88
  tmp___4 = cval_isinteger(arg);
  }
#line 88
  if (tmp___4) {
    {
#line 89
    tmp___2 = cval_uint_value(arg);
#line 89
    tmp___3 = ilog2(tmp___2);
    }
#line 89
    if (tmp___3 != -1) {
      {
#line 90
      tmp___1 = cval_cast(arg, size_t_type);
      }
#line 90
      return (tmp___1);
    } else {
      {
#line 92
      error("requested alignment is not a power of 2");
      }
    }
  } else {
    {
#line 94
    error("requested alignment is not a constant");
    }
  }
#line 96
  return (cval_top);
}
}
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
static void transparent_union_argument(data_declaration ddecl ) 
{ 
  type_quals tmp ;

  {
  {
#line 112
  tmp = type_qualifiers(ddecl->type);
#line 112
  ddecl->type = make_qualified_type(ddecl->type, (type_quals )((unsigned int )tmp | 1U));
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
static bool require_function___0(gcc_attribute attr , data_declaration ddecl ) 
{ 


  {
#line 118
  if ((unsigned int )ddecl->kind == 2U) {
#line 118
    if ((unsigned int )ddecl->ftype == 1U) {
#line 119
      return ((bool )1);
    }
  }
  {
#line 121
  error_with_location(attr->location, "`%s\' attribute is for external functions only",
                      (attr->word1)->cstring.data);
  }
#line 122
  return ((bool )0);
}
}
#line 125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
bool handle_gcc_type_attribute(gcc_attribute attr , type *t ) 
{ 
  char const   *name ;
  char const   *word___0 ;
  char const   *tmp ;
  cval arg ;
  cval tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
  {
#line 127
  name = (char const   *)(attr->word1)->cstring.data;
#line 129
  tmp___5 = is_attr_name(name, "combine");
  }
#line 129
  if (tmp___5) {
    {
#line 131
    tmp = gcc_attr_get_word(attr);
#line 131
    word___0 = tmp;
    }
#line 133
    if (word___0) {
      {
#line 134
      handle_combine_attribute(attr->location, word___0, t);
      }
    }
#line 135
    return ((bool )1);
  } else {
    {
#line 137
    tmp___4 = is_attr_name(name, "aligned");
    }
#line 137
    if (tmp___4) {
      {
#line 139
      tmp___0 = get_alignment(attr);
#line 139
      arg = tmp___0;
#line 141
      tmp___1 = cval_isinteger(arg);
      }
#line 141
      if (tmp___1) {
        {
#line 142
        *t = align_type(*t, arg);
        }
      }
#line 143
      return ((bool )1);
    } else {
#line 146
      if (target->type_attribute) {
        {
#line 146
        tmp___2 = (*(target->type_attribute))(attr, t);
        }
#line 146
        if (tmp___2) {
#line 146
          tmp___3 = 1;
        } else {
#line 146
          tmp___3 = 0;
        }
      } else {
#line 146
        tmp___3 = 0;
      }
#line 146
      return ((bool )tmp___3);
    }
  }
}
}
#line 149 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_gcc_decl_attribute(gcc_attribute attr , data_declaration ddecl ) 
{ 
  char const   *name ;
  bool tmp ;
  bool tmp___0 ;
  cval arg ;
  cval tmp___1 ;
  bool tmp___2 ;
  char const   *word___0 ;
  char const   *tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  char const   *word___1 ;
  char const   *tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  bool tmp___23 ;

  {
  {
#line 151
  name = (char const   *)(attr->word1)->cstring.data;
#line 153
  tmp___23 = is_attr_name(name, "transparent_union");
  }
#line 153
  if (tmp___23) {
#line 155
    if (attr->args) {
      {
#line 156
      error_with_location(attr->location, "wrong number of arguments specified for `transparent_union\' attribute");
      }
    }
#line 158
    if ((unsigned int )ddecl->kind == 0U) {
#line 158
      if (ddecl->isparameter) {
        {
#line 158
        tmp___0 = type_union(ddecl->type);
        }
#line 158
        if (tmp___0) {
          {
#line 160
          transparent_union_argument(ddecl);
          }
        } else {
#line 158
          goto _L___0;
        }
      } else {
#line 158
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if ((unsigned int )ddecl->kind == 3U) {
      {
#line 161
      tmp = type_union(ddecl->type);
      }
#line 161
      if (tmp) {
        {
#line 162
        transparent_union_argument(ddecl);
        }
      } else {
        {
#line 164
        ignored_gcc_attribute(attr);
        }
      }
    } else {
      {
#line 164
      ignored_gcc_attribute(attr);
      }
    }
  } else {
    {
#line 166
    tmp___22 = is_attr_name(name, "aligned");
    }
#line 166
    if (tmp___22) {
      {
#line 168
      tmp___1 = get_alignment(attr);
#line 168
      arg = tmp___1;
#line 170
      tmp___2 = cval_isinteger(arg);
      }
#line 170
      if (tmp___2) {
#line 172
        if ((unsigned int )ddecl->kind == 0U) {
          {
#line 173
          ddecl->type = align_type(ddecl->type, arg);
          }
        } else
#line 172
        if ((unsigned int )ddecl->kind == 3U) {
          {
#line 173
          ddecl->type = align_type(ddecl->type, arg);
          }
        } else {
          {
#line 175
          ignored_gcc_attribute(attr);
          }
        }
      }
    } else {
      {
#line 178
      tmp___21 = is_attr_name(name, "mode");
      }
#line 178
      if (tmp___21) {
        {
#line 180
        tmp___3 = gcc_attr_get_word(attr);
#line 180
        word___0 = tmp___3;
        }
#line 182
        if (word___0) {
          {
#line 183
          tmp___4 = handle_mode_attribute(attr->location, ddecl, word___0);
          }
#line 183
          if (! tmp___4) {
            {
#line 184
            ignored_gcc_attribute(attr);
            }
          }
        }
      } else {
        {
#line 186
        tmp___20 = is_attr_name(name, "C");
        }
#line 186
        if (tmp___20) {
#line 188
          if (! ddecl->isexternalscope) {
            {
#line 189
            error_with_location(attr->location, "`C\' attribute is for symbols with external scope only");
            }
          } else {
#line 191
            ddecl->Cname = (bool )1;
          }
        } else {
          {
#line 193
          tmp___19 = is_attr_name(name, "spontaneous");
          }
#line 193
          if (tmp___19) {
            {
#line 195
            tmp___5 = require_function___0(attr, ddecl);
            }
#line 195
            if (tmp___5) {
#line 198
              if (! ddecl->spontaneous) {
#line 199
                ddecl->spontaneous = (call_contexts )2;
              }
            }
          } else {
            {
#line 202
            tmp___18 = is_attr_name(name, "atomic_hwevent");
            }
#line 202
            if (tmp___18) {
              {
#line 204
              tmp___6 = require_function___0(attr, ddecl);
              }
#line 204
              if (tmp___6) {
#line 206
                ddecl->async = (bool )1;
#line 207
                ddecl->spontaneous = (call_contexts )1;
              }
            } else {
              {
#line 210
              tmp___17 = is_attr_name(name, "hwevent");
              }
#line 210
              if (tmp___17) {
                {
#line 212
                tmp___7 = require_function___0(attr, ddecl);
                }
#line 212
                if (tmp___7) {
#line 214
                  ddecl->async = (bool )1;
#line 215
                  ddecl->spontaneous = (call_contexts )2;
                }
              } else {
                {
#line 218
                tmp___16 = is_attr_name(name, "noinline");
                }
#line 218
                if (tmp___16) {
#line 220
                  ddecl->noinlinep = (bool )1;
                } else {
                  {
#line 222
                  tmp___13 = is_attr_name(name, "nx_base_le");
                  }
#line 222
                  if (tmp___13) {
#line 222
                    goto _L___2;
                  } else {
                    {
#line 222
                    tmp___14 = is_attr_name(name, "nx_base_be");
                    }
#line 222
                    if (tmp___14) {
#line 222
                      goto _L___2;
                    } else {
                      {
#line 222
                      tmp___15 = is_attr_name(name, "nx_base");
                      }
#line 222
                      if (tmp___15) {
                        _L___2: /* CIL Label */ 
                        {
#line 224
                        tmp___8 = gcc_attr_get_word(attr);
#line 224
                        word___1 = tmp___8;
                        }
#line 226
                        if ((unsigned int )ddecl->kind != 3U) {
                          {
#line 227
                          error_with_location(attr->location, "`%s\' attribute can only be applied to typedefs",
                                              name);
                          }
                        } else
#line 228
                        if (word___1) {
                          {
#line 229
                          tmp___9 = is_attr_name(name, "nx_base_be");
#line 229
                          handle_nxbase_attribute(attr->location, tmp___9, (bool )1,
                                                  word___1, ddecl);
                          }
                        }
                      } else
#line 231
                      if (target->decl_attribute) {
                        {
#line 231
                        tmp___10 = (*(target->decl_attribute))(attr, ddecl);
                        }
#line 231
                        if (tmp___10) {
#line 231
                          tmp___12 = 0;
                        } else {
#line 231
                          goto _L___1;
                        }
                      } else {
                        _L___1: /* CIL Label */ 
                        {
#line 231
                        tmp___11 = handle_gcc_type_attribute(attr, & ddecl->type);
                        }
#line 231
                        if (tmp___11) {
#line 231
                          tmp___12 = 0;
                        } else {
#line 231
                          tmp___12 = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 235
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_gcc_field_attribute(gcc_attribute attr , field_declaration fdecl ) 
{ 
  char const   *name ;
  cval arg ;
  cval tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 240
  name = (char const   *)(attr->word1)->cstring.data;
#line 242
  tmp___4 = is_attr_name(name, "packed");
  }
#line 242
  if (tmp___4) {
#line 243
    fdecl->packed = (bool )1;
  } else {
    {
#line 244
    tmp___3 = is_attr_name(name, "aligned");
    }
#line 244
    if (tmp___3) {
      {
#line 246
      tmp = get_alignment(attr);
#line 246
      arg = tmp;
#line 248
      tmp___0 = cval_isinteger(arg);
      }
#line 248
      if (tmp___0) {
        {
#line 249
        fdecl->type = align_type(fdecl->type, arg);
        }
      }
    } else
#line 251
    if (target->field_attribute) {
      {
#line 251
      tmp___1 = (*(target->field_attribute))(attr, fdecl);
      }
#line 251
      if (tmp___1) {
#line 251
        tmp___2 = 0;
      } else {
#line 251
        tmp___2 = 1;
      }
    } else {
#line 251
      tmp___2 = 1;
    }
  }
#line 254
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_gcc_tag_attribute(gcc_attribute attr , tag_declaration tdecl ) 
{ 
  char const   *name ;
  cval arg ;
  cval tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;

  {
  {
#line 258
  name = (char const   *)(attr->word1)->cstring.data;
#line 260
  tmp___6 = is_attr_name(name, "transparent_union");
  }
#line 260
  if (tmp___6) {
#line 262
    if (attr->args) {
      {
#line 263
      error_with_location(attr->location, "wrong number of arguments specified for `transparent_union\' attribute");
      }
    }
#line 265
    if (tdecl->kind == 171) {
#line 267
      tdecl->transparent_union = (bool )1;
    } else {
      {
#line 271
      ignored_gcc_attribute(attr);
      }
    }
  } else {
    {
#line 273
    tmp___5 = is_attr_name(name, "packed");
    }
#line 273
    if (tmp___5) {
#line 274
      tdecl->packed = (bool )1;
    } else {
      {
#line 275
      tmp___4 = is_attr_name(name, "aligned");
      }
#line 275
      if (tmp___4) {
        {
#line 277
        tmp = get_alignment(attr);
#line 277
        arg = tmp;
#line 279
        tmp___0 = cval_isinteger(arg);
        }
#line 279
        if (tmp___0) {
#line 280
          tdecl->user_alignment = arg;
        }
      } else {
        {
#line 282
        tmp___3 = is_attr_name(name, "C");
        }
#line 282
        if (tmp___3) {
#line 284
          if (tdecl->container_function) {
            {
#line 285
            error_with_location(attr->location, "`C\' attribute is for symbols with external scope only");
            }
          } else {
#line 287
            tdecl->Cname = (bool )1;
          }
        } else
#line 289
        if (target->tag_attribute) {
          {
#line 289
          tmp___1 = (*(target->tag_attribute))(attr, tdecl);
          }
#line 289
          if (tmp___1) {
#line 289
            tmp___2 = 0;
          } else {
#line 289
            tmp___2 = 1;
          }
        } else {
#line 289
          tmp___2 = 1;
        }
      }
    }
  }
#line 292
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_nescdecl_attribute(attribute attr , nesc_declaration ndecl ) 
{ 
  AST_generic tEmPcast ;

  {
#line 296
  tEmPcast = (AST_generic )attr;
#line 296
  if (tEmPcast) {
#line 296
    if ((unsigned int )tEmPcast->kind >= 165U) {
#line 296
      if (! ((unsigned int )tEmPcast->kind <= 165U)) {
        {
#line 296
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 296U,
                      "handle_nescdecl_attribute");
        }
      }
    } else {
      {
#line 296
      __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 296U,
                    "handle_nescdecl_attribute");
      }
    }
  }
  {
#line 296
  handle_nesc_nescdecl_attribute((nesc_attribute )tEmPcast, ndecl);
  }
#line 297
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_decl_attribute(attribute attr , data_declaration ddecl ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 301
  if ((unsigned int )attr->kind >= 163U) {
#line 301
    if ((unsigned int )attr->kind <= 164U) {
#line 302
      tEmPcast = (AST_generic )attr;
#line 302
      if (tEmPcast) {
#line 302
        if ((unsigned int )tEmPcast->kind >= 163U) {
#line 302
          if (! ((unsigned int )tEmPcast->kind <= 164U)) {
            {
#line 302
            __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                          302U, "handle_decl_attribute");
            }
          }
        } else {
          {
#line 302
          __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        302U, "handle_decl_attribute");
          }
        }
      }
      {
#line 302
      handle_gcc_decl_attribute((gcc_attribute )tEmPcast, ddecl);
      }
    } else {
#line 301
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 304
    tEmPcast___0 = (AST_generic )attr;
#line 304
    if (tEmPcast___0) {
#line 304
      if ((unsigned int )tEmPcast___0->kind >= 165U) {
#line 304
        if (! ((unsigned int )tEmPcast___0->kind <= 165U)) {
          {
#line 304
          __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        304U, "handle_decl_attribute");
          }
        }
      } else {
        {
#line 304
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 304U,
                      "handle_decl_attribute");
        }
      }
    }
    {
#line 304
    handle_nesc_decl_attribute((nesc_attribute )tEmPcast___0, ddecl);
    }
  }
#line 305
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_field_attribute(attribute attr , field_declaration fdecl ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 309
  if ((unsigned int )attr->kind >= 163U) {
#line 309
    if ((unsigned int )attr->kind <= 164U) {
#line 310
      tEmPcast = (AST_generic )attr;
#line 310
      if (tEmPcast) {
#line 310
        if ((unsigned int )tEmPcast->kind >= 163U) {
#line 310
          if (! ((unsigned int )tEmPcast->kind <= 164U)) {
            {
#line 310
            __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                          310U, "handle_field_attribute");
            }
          }
        } else {
          {
#line 310
          __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        310U, "handle_field_attribute");
          }
        }
      }
      {
#line 310
      handle_gcc_field_attribute((gcc_attribute )tEmPcast, fdecl);
      }
    } else {
#line 309
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    tEmPcast___0 = (AST_generic )attr;
#line 312
    if (tEmPcast___0) {
#line 312
      if ((unsigned int )tEmPcast___0->kind >= 165U) {
#line 312
        if (! ((unsigned int )tEmPcast___0->kind <= 165U)) {
          {
#line 312
          __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        312U, "handle_field_attribute");
          }
        }
      } else {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 312U,
                      "handle_field_attribute");
        }
      }
    }
    {
#line 312
    handle_nesc_field_attribute((nesc_attribute )tEmPcast___0, fdecl);
    }
  }
#line 313
  return;
}
}
#line 315 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_tag_attribute(attribute attr , tag_declaration tdecl ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;

  {
#line 317
  if ((unsigned int )attr->kind >= 163U) {
#line 317
    if ((unsigned int )attr->kind <= 164U) {
#line 318
      tEmPcast = (AST_generic )attr;
#line 318
      if (tEmPcast) {
#line 318
        if ((unsigned int )tEmPcast->kind >= 163U) {
#line 318
          if (! ((unsigned int )tEmPcast->kind <= 164U)) {
            {
#line 318
            __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                          318U, "handle_tag_attribute");
            }
          }
        } else {
          {
#line 318
          __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        318U, "handle_tag_attribute");
          }
        }
      }
      {
#line 318
      handle_gcc_tag_attribute((gcc_attribute )tEmPcast, tdecl);
      }
    } else {
#line 317
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 320
    tEmPcast___0 = (AST_generic )attr;
#line 320
    if (tEmPcast___0) {
#line 320
      if ((unsigned int )tEmPcast___0->kind >= 165U) {
#line 320
        if (! ((unsigned int )tEmPcast___0->kind <= 165U)) {
          {
#line 320
          __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        320U, "handle_tag_attribute");
          }
        }
      } else {
        {
#line 320
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 320U,
                      "handle_tag_attribute");
        }
      }
    }
    {
#line 320
    handle_nesc_tag_attribute((nesc_attribute )tEmPcast___0, tdecl);
    }
  }
#line 321
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
bool handle_type_attribute(attribute attr , type *t ) 
{ 
  AST_generic tEmPcast ;
  bool tmp ;
  AST_generic tEmPcast___0 ;

  {
#line 325
  if ((unsigned int )attr->kind >= 163U) {
#line 325
    if ((unsigned int )attr->kind <= 164U) {
#line 326
      tEmPcast = (AST_generic )attr;
#line 326
      if (tEmPcast) {
#line 326
        if ((unsigned int )tEmPcast->kind >= 163U) {
#line 326
          if (! ((unsigned int )tEmPcast->kind <= 164U)) {
            {
#line 326
            __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                          326U, "handle_type_attribute");
            }
          }
        } else {
          {
#line 326
          __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        326U, "handle_type_attribute");
          }
        }
      }
      {
#line 326
      tmp = handle_gcc_type_attribute((gcc_attribute )tEmPcast, t);
      }
#line 326
      return (tmp);
    } else {
#line 325
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 331
    tEmPcast___0 = (AST_generic )attr;
#line 331
    if (tEmPcast___0) {
#line 331
      if ((unsigned int )tEmPcast___0->kind >= 165U) {
#line 331
        if (! ((unsigned int )tEmPcast___0->kind <= 165U)) {
          {
#line 331
          __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        331U, "handle_type_attribute");
          }
        }
      } else {
        {
#line 331
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 331U,
                      "handle_type_attribute");
        }
      }
    }
    {
#line 331
    handle_nesc_type_attribute((nesc_attribute )tEmPcast___0, t);
    }
#line 332
    return ((bool )1);
  }
}
}
#line 338 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_nescdecl_attributes(attribute alist , nesc_declaration ndecl ) 
{ 
  AST_generic tEmPcast ;

  {
#line 340
  alist = alist;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! alist) {
#line 340
      goto while_break;
    }
    {
#line 341
    handle_nescdecl_attribute(alist, ndecl);
#line 340
    tEmPcast = (AST_generic )alist->next;
    }
#line 340
    if (tEmPcast) {
#line 340
      if ((unsigned int )tEmPcast->kind >= 162U) {
#line 340
        if (! ((unsigned int )tEmPcast->kind <= 165U)) {
          {
#line 340
          __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        340U, "handle_nescdecl_attributes");
          }
        }
      } else {
        {
#line 340
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 340U,
                      "handle_nescdecl_attributes");
        }
      }
    }
#line 340
    alist = (attribute )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_decl_attributes(attribute alist , data_declaration ddecl ) 
{ 
  AST_generic tEmPcast ;

  {
#line 346
  alist = alist;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! alist) {
#line 346
      goto while_break;
    }
    {
#line 347
    handle_decl_attribute(alist, ddecl);
#line 346
    tEmPcast = (AST_generic )alist->next;
    }
#line 346
    if (tEmPcast) {
#line 346
      if ((unsigned int )tEmPcast->kind >= 162U) {
#line 346
        if (! ((unsigned int )tEmPcast->kind <= 165U)) {
          {
#line 346
          __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        346U, "handle_decl_attributes");
          }
        }
      } else {
        {
#line 346
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 346U,
                      "handle_decl_attributes");
        }
      }
    }
#line 346
    alist = (attribute )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return;
}
}
#line 350 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_field_attributes(attribute alist , field_declaration fdecl ) 
{ 
  AST_generic tEmPcast ;

  {
#line 352
  alist = alist;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! alist) {
#line 352
      goto while_break;
    }
    {
#line 353
    handle_field_attribute(alist, fdecl);
#line 352
    tEmPcast = (AST_generic )alist->next;
    }
#line 352
    if (tEmPcast) {
#line 352
      if ((unsigned int )tEmPcast->kind >= 162U) {
#line 352
        if (! ((unsigned int )tEmPcast->kind <= 165U)) {
          {
#line 352
          __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        352U, "handle_field_attributes");
          }
        }
      } else {
        {
#line 352
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 352U,
                      "handle_field_attributes");
        }
      }
    }
#line 352
    alist = (attribute )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_tag_attributes(attribute alist , tag_declaration tdecl ) 
{ 
  AST_generic tEmPcast ;

  {
#line 358
  alist = alist;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! alist) {
#line 358
      goto while_break;
    }
    {
#line 359
    handle_tag_attribute(alist, tdecl);
#line 358
    tEmPcast = (AST_generic )alist->next;
    }
#line 358
    if (tEmPcast) {
#line 358
      if ((unsigned int )tEmPcast->kind >= 162U) {
#line 358
        if (! ((unsigned int )tEmPcast->kind <= 165U)) {
          {
#line 358
          __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c",
                        358U, "handle_tag_attributes");
          }
        }
      } else {
        {
#line 358
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c", 358U,
                      "handle_tag_attributes");
        }
      }
    }
#line 358
    alist = (attribute )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return;
}
}
#line 362 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_nescdecl_dd_attributes(dd_list alist , nesc_declaration ndecl ) 
{ 
  dd_list_pos attr ;

  {
#line 366
  if (alist) {
    {
#line 367
    attr = dd_first(alist);
    }
    {
#line 367
    while (1) {
      while_continue: /* CIL Label */ ;
#line 367
      if (! (! (! attr->next))) {
#line 367
        goto while_break;
      }
      {
#line 368
      handle_nescdecl_attribute((attribute )attr->data, ndecl);
#line 367
      attr = attr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 369
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_decl_dd_attributes(dd_list alist , data_declaration ddecl ) 
{ 
  dd_list_pos attr ;

  {
#line 375
  if (alist) {
    {
#line 376
    attr = dd_first(alist);
    }
    {
#line 376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 376
      if (! (! (! attr->next))) {
#line 376
        goto while_break;
      }
      {
#line 377
      handle_decl_attribute((attribute )attr->data, ddecl);
#line 376
      attr = attr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 378
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_field_dd_attributes(dd_list alist , field_declaration fdecl ) 
{ 
  dd_list_pos attr ;

  {
#line 384
  if (alist) {
    {
#line 385
    attr = dd_first(alist);
    }
    {
#line 385
    while (1) {
      while_continue: /* CIL Label */ ;
#line 385
      if (! (! (! attr->next))) {
#line 385
        goto while_break;
      }
      {
#line 386
      handle_field_attribute((attribute )attr->data, fdecl);
#line 385
      attr = attr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/nescc-1.3.4/src/attributes.c"
void handle_tag_dd_attributes(dd_list alist , tag_declaration tdecl ) 
{ 
  dd_list_pos attr ;

  {
#line 393
  if (alist) {
    {
#line 394
    attr = dd_first(alist);
    }
    {
#line 394
    while (1) {
      while_continue: /* CIL Label */ ;
#line 394
      if (! (! (! attr->next))) {
#line 394
        goto while_break;
      }
      {
#line 395
      handle_tag_attribute((attribute )attr->data, tdecl);
#line 394
      attr = attr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 396
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 485 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.h"
size_t AST_sizeof[158] ;
#line 487
type_t AST_typeof[158] ;
#line 5 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.h"
node AST_node_chain(node l1 , node l2 ) ;
#line 6
int AST_node_length(node l ) ;
#line 640
node node_chain(node l1 , node l2 ) ;
#line 642
statement statement_chain(statement l1 , statement l2 ) ;
#line 645
declarator declarator_chain(declarator l1 , declarator l2 ) ;
#line 646
label label_chain(label l1 , label l2 ) ;
#line 647
asm_decl asm_decl_chain(asm_decl l1 , asm_decl l2 ) ;
#line 648
data_decl data_decl_chain(data_decl l1 , data_decl l2 ) ;
#line 649
extension_decl extension_decl_chain(extension_decl l1 , extension_decl l2 ) ;
#line 650
ellipsis_decl ellipsis_decl_chain(ellipsis_decl l1 , ellipsis_decl l2 ) ;
#line 651
enumerator enumerator_chain(enumerator l1 , enumerator l2 ) ;
#line 652
oldidentifier_decl oldidentifier_decl_chain(oldidentifier_decl l1 , oldidentifier_decl l2 ) ;
#line 653
function_decl function_decl_chain(function_decl l1 , function_decl l2 ) ;
#line 654
implicit_decl implicit_decl_chain(implicit_decl l1 , implicit_decl l2 ) ;
#line 655
variable_decl variable_decl_chain(variable_decl l1 , variable_decl l2 ) ;
#line 656
field_decl field_decl_chain(field_decl l1 , field_decl l2 ) ;
#line 657
asttype asttype_chain(asttype l1 , asttype l2 ) ;
#line 658
typename typename_chain(typename l1 , typename l2 ) ;
#line 659
typeof_expr typeof_expr_chain(typeof_expr l1 , typeof_expr l2 ) ;
#line 660
typeof_type typeof_type_chain(typeof_type l1 , typeof_type l2 ) ;
#line 662
gcc_attribute gcc_attribute_chain(gcc_attribute l1 , gcc_attribute l2 ) ;
#line 663
rid rid_chain(rid l1 , rid l2 ) ;
#line 664
qualifier qualifier_chain(qualifier l1 , qualifier l2 ) ;
#line 665
tag_ref tag_ref_chain(tag_ref l1 , tag_ref l2 ) ;
#line 666
struct_ref struct_ref_chain(struct_ref l1 , struct_ref l2 ) ;
#line 667
union_ref union_ref_chain(union_ref l1 , union_ref l2 ) ;
#line 668
nested_declarator nested_declarator_chain(nested_declarator l1 , nested_declarator l2 ) ;
#line 669
function_declarator function_declarator_chain(function_declarator l1 , function_declarator l2 ) ;
#line 670
pointer_declarator pointer_declarator_chain(pointer_declarator l1 , pointer_declarator l2 ) ;
#line 671
qualified_declarator qualified_declarator_chain(qualified_declarator l1 , qualified_declarator l2 ) ;
#line 672
array_declarator array_declarator_chain(array_declarator l1 , array_declarator l2 ) ;
#line 673
identifier_declarator identifier_declarator_chain(identifier_declarator l1 , identifier_declarator l2 ) ;
#line 674
asm_stmt asm_stmt_chain(asm_stmt l1 , asm_stmt l2 ) ;
#line 675
compound_stmt compound_stmt_chain(compound_stmt l1 , compound_stmt l2 ) ;
#line 676
if_stmt if_stmt_chain(if_stmt l1 , if_stmt l2 ) ;
#line 677
labeled_stmt labeled_stmt_chain(labeled_stmt l1 , labeled_stmt l2 ) ;
#line 678
expression_stmt expression_stmt_chain(expression_stmt l1 , expression_stmt l2 ) ;
#line 679
conditional_stmt conditional_stmt_chain(conditional_stmt l1 , conditional_stmt l2 ) ;
#line 680
switch_stmt switch_stmt_chain(switch_stmt l1 , switch_stmt l2 ) ;
#line 681
for_stmt for_stmt_chain(for_stmt l1 , for_stmt l2 ) ;
#line 682
break_stmt break_stmt_chain(break_stmt l1 , break_stmt l2 ) ;
#line 683
continue_stmt continue_stmt_chain(continue_stmt l1 , continue_stmt l2 ) ;
#line 684
return_stmt return_stmt_chain(return_stmt l1 , return_stmt l2 ) ;
#line 685
goto_stmt goto_stmt_chain(goto_stmt l1 , goto_stmt l2 ) ;
#line 686
computed_goto_stmt computed_goto_stmt_chain(computed_goto_stmt l1 , computed_goto_stmt l2 ) ;
#line 687
empty_stmt empty_stmt_chain(empty_stmt l1 , empty_stmt l2 ) ;
#line 688
unary unary_chain(unary l1 , unary l2 ) ;
#line 689
binary binary_chain(binary l1 , binary l2 ) ;
#line 690
comma comma_chain(comma l1 , comma l2 ) ;
#line 691
sizeof_type sizeof_type_chain(sizeof_type l1 , sizeof_type l2 ) ;
#line 692
alignof_type alignof_type_chain(alignof_type l1 , alignof_type l2 ) ;
#line 693
label_address label_address_chain(label_address l1 , label_address l2 ) ;
#line 694
cast cast_chain(cast l1 , cast l2 ) ;
#line 695
cast_list cast_list_chain(cast_list l1 , cast_list l2 ) ;
#line 696
conditional conditional_chain(conditional l1 , conditional l2 ) ;
#line 697
identifier identifier_chain(identifier l1 , identifier l2 ) ;
#line 698
compound_expr compound_expr_chain(compound_expr l1 , compound_expr l2 ) ;
#line 699
function_call function_call_chain(function_call l1 , function_call l2 ) ;
#line 700
field_ref field_ref_chain(field_ref l1 , field_ref l2 ) ;
#line 701
increment increment_chain(increment l1 , increment l2 ) ;
#line 702
comparison comparison_chain(comparison l1 , comparison l2 ) ;
#line 703
assignment assignment_chain(assignment l1 , assignment l2 ) ;
#line 704
init_list init_list_chain(init_list l1 , init_list l2 ) ;
#line 705
init_specific init_specific_chain(init_specific l1 , init_specific l2 ) ;
#line 707
designate_field designate_field_chain(designate_field l1 , designate_field l2 ) ;
#line 708
designate_index designate_index_chain(designate_index l1 , designate_index l2 ) ;
#line 709
lexical_cst lexical_cst_chain(lexical_cst l1 , lexical_cst l2 ) ;
#line 710
string_cst string_cst_chain(string_cst l1 , string_cst l2 ) ;
#line 713
case_label case_label_chain(case_label l1 , case_label l2 ) ;
#line 714
default_label default_label_chain(default_label l1 , default_label l2 ) ;
#line 715
word word_chain(word l1 , word l2 ) ;
#line 717
nesc_decl nesc_decl_chain(nesc_decl l1 , nesc_decl l2 ) ;
#line 718
interface interface_chain(interface l1 , interface l2 ) ;
#line 719
component component_chain(component l1 , component l2 ) ;
#line 720
implementation implementation_chain(implementation l1 , implementation l2 ) ;
#line 721
configuration configuration_chain(configuration l1 , configuration l2 ) ;
#line 722
module module_chain(module l1 , module l2 ) ;
#line 723
binary_component binary_component_chain(binary_component l1 , binary_component l2 ) ;
#line 724
rp_interface rp_interface_chain(rp_interface l1 , rp_interface l2 ) ;
#line 725
interface_ref interface_ref_chain(interface_ref l1 , interface_ref l2 ) ;
#line 727
connection connection_chain(connection l1 , connection l2 ) ;
#line 728
endpoint endpoint_chain(endpoint l1 , endpoint l2 ) ;
#line 730
generic_declarator generic_declarator_chain(generic_declarator l1 , generic_declarator l2 ) ;
#line 731
generic_call generic_call_chain(generic_call l1 , generic_call l2 ) ;
#line 732
interface_ref_declarator interface_ref_declarator_chain(interface_ref_declarator l1 ,
                                                        interface_ref_declarator l2 ) ;
#line 733
interface_deref interface_deref_chain(interface_deref l1 , interface_deref l2 ) ;
#line 734
component_deref component_deref_chain(component_deref l1 , component_deref l2 ) ;
#line 735
component_typeref component_typeref_chain(component_typeref l1 , component_typeref l2 ) ;
#line 736
atomic_stmt atomic_stmt_chain(atomic_stmt l1 , atomic_stmt l2 ) ;
#line 737
nesc_attribute nesc_attribute_chain(nesc_attribute l1 , nesc_attribute l2 ) ;
#line 738
type_parm_decl type_parm_decl_chain(type_parm_decl l1 , type_parm_decl l2 ) ;
#line 739
type_argument type_argument_chain(type_argument l1 , type_argument l2 ) ;
#line 740
error_decl error_decl_chain(error_decl l1 , error_decl l2 ) ;
#line 741
attribute_ref attribute_ref_chain(attribute_ref l1 , attribute_ref l2 ) ;
#line 742
enum_ref enum_ref_chain(enum_ref l1 , enum_ref l2 ) ;
#line 743
error_stmt error_stmt_chain(error_stmt l1 , error_stmt l2 ) ;
#line 744
while_stmt while_stmt_chain(while_stmt l1 , while_stmt l2 ) ;
#line 745
dowhile_stmt dowhile_stmt_chain(dowhile_stmt l1 , dowhile_stmt l2 ) ;
#line 746
error_expr error_expr_chain(error_expr l1 , error_expr l2 ) ;
#line 747
array_ref array_ref_chain(array_ref l1 , array_ref l2 ) ;
#line 748
dereference dereference_chain(dereference l1 , dereference l2 ) ;
#line 749
extension_expr extension_expr_chain(extension_expr l1 , extension_expr l2 ) ;
#line 750
sizeof_expr sizeof_expr_chain(sizeof_expr l1 , sizeof_expr l2 ) ;
#line 751
alignof_expr alignof_expr_chain(alignof_expr l1 , alignof_expr l2 ) ;
#line 752
realpart realpart_chain(realpart l1 , realpart l2 ) ;
#line 753
imagpart imagpart_chain(imagpart l1 , imagpart l2 ) ;
#line 754
address_of address_of_chain(address_of l1 , address_of l2 ) ;
#line 755
unary_minus unary_minus_chain(unary_minus l1 , unary_minus l2 ) ;
#line 756
unary_plus unary_plus_chain(unary_plus l1 , unary_plus l2 ) ;
#line 757
conjugate conjugate_chain(conjugate l1 , conjugate l2 ) ;
#line 758
bitnot bitnot_chain(bitnot l1 , bitnot l2 ) ;
#line 759
not not_chain(not l1 , not l2 ) ;
#line 760
preincrement preincrement_chain(preincrement l1 , preincrement l2 ) ;
#line 761
predecrement predecrement_chain(predecrement l1 , predecrement l2 ) ;
#line 762
postincrement postincrement_chain(postincrement l1 , postincrement l2 ) ;
#line 763
postdecrement postdecrement_chain(postdecrement l1 , postdecrement l2 ) ;
#line 764
plus plus_chain(plus l1 , plus l2 ) ;
#line 765
minus minus_chain(minus l1 , minus l2 ) ;
#line 766
times times_chain(times l1 , times l2 ) ;
#line 767
divide divide_chain(divide l1 , divide l2 ) ;
#line 768
modulo modulo_chain(modulo l1 , modulo l2 ) ;
#line 769
lshift lshift_chain(lshift l1 , lshift l2 ) ;
#line 770
rshift rshift_chain(rshift l1 , rshift l2 ) ;
#line 771
leq leq_chain(leq l1 , leq l2 ) ;
#line 772
geq geq_chain(geq l1 , geq l2 ) ;
#line 773
lt lt_chain(lt l1 , lt l2 ) ;
#line 774
gt gt_chain(gt l1 , gt l2 ) ;
#line 775
eq eq_chain(eq l1 , eq l2 ) ;
#line 776
ne ne_chain(ne l1 , ne l2 ) ;
#line 777
bitand bitand_chain(bitand l1 , bitand l2 ) ;
#line 778
bitor bitor_chain(bitor l1 , bitor l2 ) ;
#line 779
bitxor bitxor_chain(bitxor l1 , bitxor l2 ) ;
#line 780
andand andand_chain(andand l1 , andand l2 ) ;
#line 781
oror oror_chain(oror l1 , oror l2 ) ;
#line 782
assign assign_chain(assign l1 , assign l2 ) ;
#line 783
plus_assign plus_assign_chain(plus_assign l1 , plus_assign l2 ) ;
#line 784
minus_assign minus_assign_chain(minus_assign l1 , minus_assign l2 ) ;
#line 785
times_assign times_assign_chain(times_assign l1 , times_assign l2 ) ;
#line 786
divide_assign divide_assign_chain(divide_assign l1 , divide_assign l2 ) ;
#line 787
modulo_assign modulo_assign_chain(modulo_assign l1 , modulo_assign l2 ) ;
#line 788
lshift_assign lshift_assign_chain(lshift_assign l1 , lshift_assign l2 ) ;
#line 789
rshift_assign rshift_assign_chain(rshift_assign l1 , rshift_assign l2 ) ;
#line 790
bitand_assign bitand_assign_chain(bitand_assign l1 , bitand_assign l2 ) ;
#line 791
bitor_assign bitor_assign_chain(bitor_assign l1 , bitor_assign l2 ) ;
#line 792
bitxor_assign bitxor_assign_chain(bitxor_assign l1 , bitxor_assign l2 ) ;
#line 793
rp_connection rp_connection_chain(rp_connection l1 , rp_connection l2 ) ;
#line 794
eq_connection eq_connection_chain(eq_connection l1 , eq_connection l2 ) ;
#line 795
nx_struct_ref nx_struct_ref_chain(nx_struct_ref l1 , nx_struct_ref l2 ) ;
#line 796
nx_union_ref nx_union_ref_chain(nx_union_ref l1 , nx_union_ref l2 ) ;
#line 797
target_attribute target_attribute_chain(target_attribute l1 , target_attribute l2 ) ;
#line 1754 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_defs.h"
node new_node(region r , location location___0 ) ;
#line 1755
declaration new_declaration(region r , location location___0 ) ;
#line 1756
statement new_statement(region r , location location___0 ) ;
#line 1757
expression new_expression(region r , location location___0 ) ;
#line 1758
type_element new_type_element(region r , location location___0 ) ;
#line 1759
declarator new_declarator(region r , location location___0 ) ;
#line 1760
label new_label(region r , location location___0 ) ;
#line 1765
enumerator new_enumerator(region r , location location___0 , cstring cstring___0 ,
                          expression arg1 , data_declaration ddecl ) ;
#line 1766
oldidentifier_decl new_oldidentifier_decl(region r , location location___0 , cstring cstring___0 ,
                                          data_declaration ddecl ) ;
#line 1767
function_decl new_function_decl(region r , location location___0 , declarator declarator___0 ,
                                type_element modifiers , attribute attributes , declaration old_parms ,
                                statement stmt , function_decl parent_function___0 ,
                                data_declaration ddecl ) ;
#line 1768
implicit_decl new_implicit_decl(region r , location location___0 , identifier ident ) ;
#line 1770
field_decl new_field_decl(region r , location location___0 , declarator declarator___0 ,
                          attribute attributes , expression arg1 ) ;
#line 1771
asttype new_asttype(region r , location location___0 , declarator declarator___0 ,
                    type_element qualifiers ) ;
#line 1775
attribute new_attribute(region r , location location___0 , word word1 ) ;
#line 1779
tag_ref new_tag_ref(region r , location location___0 , word word1 , attribute attributes ,
                    declaration fields , bool defined ) ;
#line 1780
struct_ref new_struct_ref(region r , location location___0 , word word1 , attribute attributes ,
                          declaration fields , bool defined ) ;
#line 1781
union_ref new_union_ref(region r , location location___0 , word word1 , attribute attributes ,
                        declaration fields , bool defined ) ;
#line 1782
nested_declarator new_nested_declarator(region r , location location___0 , declarator declarator___0 ) ;
#line 1793
conditional_stmt new_conditional_stmt(region r , location location___0 , expression condition ,
                                      statement stmt ) ;
#line 1798
return_stmt new_return_stmt(region r , location location___0 , expression arg1 ) ;
#line 1802
unary new_unary(region r , location location___0 , expression arg1 ) ;
#line 1803
binary new_binary(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1809
cast_list new_cast_list(region r , location location___0 , asttype asttype___0 , expression init_expr ) ;
#line 1815
increment new_increment(region r , location location___0 , expression arg1 ) ;
#line 1816
comparison new_comparison(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1817
assignment new_assignment(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1818
init_list new_init_list(region r , location location___0 , expression args ) ;
#line 1819
init_specific new_init_specific(region r , location location___0 , designator designator___0 ,
                                expression init_expr ) ;
#line 1820
designator new_designator(region r , location location___0 ) ;
#line 1821
designate_field new_designate_field(region r , location location___0 , cstring cstring___0 ) ;
#line 1822
designate_index new_designate_index(region r , location location___0 , expression arg1 ,
                                    expression arg2 ) ;
#line 1831
nesc_decl new_nesc_decl(region r , location location___0 , word word1 , attribute attributes ) ;
#line 1834
implementation new_implementation(region r , location location___0 , environment ienv ) ;
#line 1841
connection new_connection(region r , location location___0 , endpoint ep1 , endpoint ep2 ) ;
#line 1844
generic_declarator new_generic_declarator(region r , location location___0 , declarator declarator___0 ,
                                          declaration parms ) ;
#line 1845
generic_call new_generic_call(region r , location location___0 , expression arg1 ,
                              expression args ) ;
#line 1846
interface_ref_declarator new_interface_ref_declarator(region r , location location___0 ,
                                                      declarator declarator___0 ,
                                                      word word1 ) ;
#line 1847
interface_deref new_interface_deref(region r , location location___0 , expression arg1 ,
                                    cstring cstring___0 , data_declaration ddecl ) ;
#line 1848
component_deref new_component_deref(region r , location location___0 , expression arg1 ,
                                    cstring cstring___0 , data_declaration ddecl ) ;
#line 1851
nesc_attribute new_nesc_attribute(region r , location location___0 , word word1 ,
                                  expression arg1 ) ;
#line 1855
attribute_ref new_attribute_ref(region r , location location___0 , word word1 , attribute attributes ,
                                declaration fields , bool defined ) ;
#line 1856
enum_ref new_enum_ref(region r , location location___0 , word word1 , attribute attributes ,
                      declaration fields , bool defined ) ;
#line 1866
realpart new_realpart(region r , location location___0 , expression arg1 ) ;
#line 1867
imagpart new_imagpart(region r , location location___0 , expression arg1 ) ;
#line 1869
unary_minus new_unary_minus(region r , location location___0 , expression arg1 ) ;
#line 1870
unary_plus new_unary_plus(region r , location location___0 , expression arg1 ) ;
#line 1871
conjugate new_conjugate(region r , location location___0 , expression arg1 ) ;
#line 1872
bitnot new_bitnot(region r , location location___0 , expression arg1 ) ;
#line 1873
not new_not(region r , location location___0 , expression arg1 ) ;
#line 1878
plus new_plus(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1879
minus new_minus(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1880
times new_times(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1881
divide new_divide(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1882
modulo new_modulo(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1883
lshift new_lshift(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1884
rshift new_rshift(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1885
leq new_leq(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1886
geq new_geq(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1887
lt new_lt(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1888
gt new_gt(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1889
eq new_eq(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1890
ne new_ne(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1891
bitand new_bitand(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1892
bitor new_bitor(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1893
bitxor new_bitxor(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1894
andand new_andand(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1895
oror new_oror(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1896
assign new_assign(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1897
plus_assign new_plus_assign(region r , location location___0 , expression arg1 , expression arg2 ) ;
#line 1898
minus_assign new_minus_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) ;
#line 1899
times_assign new_times_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) ;
#line 1900
divide_assign new_divide_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1901
modulo_assign new_modulo_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1902
lshift_assign new_lshift_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1903
rshift_assign new_rshift_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1904
bitand_assign new_bitand_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1905
bitor_assign new_bitor_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) ;
#line 1906
bitxor_assign new_bitxor_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) ;
#line 1909
nx_struct_ref new_nx_struct_ref(region r , location location___0 , word word1 , attribute attributes ,
                                declaration fields , bool defined ) ;
#line 1910
nx_union_ref new_nx_union_ref(region r , location location___0 , word word1 , attribute attributes ,
                              declaration fields , bool defined ) ;
#line 73 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.h"
tag_ref newkind_tag_ref(region r , AST_kind kind , location location___0 , word word1 ,
                        attribute attributes , declaration fields , bool defined ) ;
#line 74
void insert_before(node *list , node before , node n ) ;
#line 76
void AST_set_parents(node n ) ;
#line 77
void set_parent(node *nptr , node parent ) ;
#line 78
void set_parent_list(node *list , node parent ) ;
#line 80
node AST_clone(region r , node n ) ;
#line 82
void AST_print(node n ) ;
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
node new_node(region r , location location___0 ) 
{ 
  node obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6
  if (sizeof(struct AST_node ) < (unsigned long )(1 << 9)) {
    {
#line 6
    tmp = __rcralloc_small0(r, sizeof(struct AST_node ));
#line 6
    tmp___1 = tmp;
    }
  } else {
    {
#line 6
    tmp___0 = typed_ralloc(r, sizeof(struct AST_node ), 0);
#line 6
    tmp___1 = tmp___0;
    }
  }
#line 6
  obj = (node )tmp___1;
#line 8
  obj->kind = (AST_kind )42;
#line 9
  obj->location = location___0;
#line 11
  return (obj);
}
}
#line 14 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
declaration new_declaration(region r , location location___0 ) 
{ 
  declaration obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 16
  if (sizeof(struct AST_declaration ) < (unsigned long )(1 << 9)) {
    {
#line 16
    tmp = __rcralloc_small0(r, sizeof(struct AST_declaration ));
#line 16
    tmp___1 = tmp;
    }
  } else {
    {
#line 16
    tmp___0 = typed_ralloc(r, sizeof(struct AST_declaration ), 0);
#line 16
    tmp___1 = tmp___0;
    }
  }
#line 16
  obj = (declaration )tmp___1;
#line 18
  obj->kind = (AST_kind )43;
#line 19
  obj->location = location___0;
#line 21
  return (obj);
}
}
#line 24 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
statement new_statement(region r , location location___0 ) 
{ 
  statement obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 26
  if (sizeof(struct AST_statement ) < (unsigned long )(1 << 9)) {
    {
#line 26
    tmp = __rcralloc_small0(r, sizeof(struct AST_statement ));
#line 26
    tmp___1 = tmp;
    }
  } else {
    {
#line 26
    tmp___0 = typed_ralloc(r, sizeof(struct AST_statement ), 0);
#line 26
    tmp___1 = tmp___0;
    }
  }
#line 26
  obj = (statement )tmp___1;
#line 28
  obj->kind = (AST_kind )65;
#line 29
  obj->location = location___0;
#line 30
  obj->isatomic = (atomic_t )2;
#line 32
  return (obj);
}
}
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
expression new_expression(region r , location location___0 ) 
{ 
  expression obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 37
  if (sizeof(struct AST_expression ) < (unsigned long )(1 << 9)) {
    {
#line 37
    tmp = __rcralloc_small0(r, sizeof(struct AST_expression ));
#line 37
    tmp___1 = tmp;
    }
  } else {
    {
#line 37
    tmp___0 = typed_ralloc(r, sizeof(struct AST_expression ), 0);
#line 37
    tmp___1 = tmp___0;
    }
  }
#line 37
  obj = (expression )tmp___1;
#line 39
  obj->kind = (AST_kind )84;
#line 40
  obj->location = location___0;
#line 41
  obj->isatomic = (atomic_t )2;
#line 43
  return (obj);
}
}
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
type_element new_type_element(region r , location location___0 ) 
{ 
  type_element obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 48
  if (sizeof(struct AST_type_element ) < (unsigned long )(1 << 9)) {
    {
#line 48
    tmp = __rcralloc_small0(r, sizeof(struct AST_type_element ));
#line 48
    tmp___1 = tmp;
    }
  } else {
    {
#line 48
    tmp___0 = typed_ralloc(r, sizeof(struct AST_type_element ), 0);
#line 48
    tmp___1 = tmp___0;
    }
  }
#line 48
  obj = (type_element )tmp___1;
#line 50
  obj->kind = (AST_kind )157;
#line 51
  obj->location = location___0;
#line 53
  return (obj);
}
}
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
declarator new_declarator(region r , location location___0 ) 
{ 
  declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 58
  if (sizeof(struct AST_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 58
    tmp = __rcralloc_small0(r, sizeof(struct AST_declarator ));
#line 58
    tmp___1 = tmp;
    }
  } else {
    {
#line 58
    tmp___0 = typed_ralloc(r, sizeof(struct AST_declarator ), 0);
#line 58
    tmp___1 = tmp___0;
    }
  }
#line 58
  obj = (declarator )tmp___1;
#line 60
  obj->kind = (AST_kind )175;
#line 61
  obj->location = location___0;
#line 63
  return (obj);
}
}
#line 66 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
label new_label(region r , location location___0 ) 
{ 
  label obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 68
  if (sizeof(struct AST_label ) < (unsigned long )(1 << 9)) {
    {
#line 68
    tmp = __rcralloc_small0(r, sizeof(struct AST_label ));
#line 68
    tmp___1 = tmp;
    }
  } else {
    {
#line 68
    tmp___0 = typed_ralloc(r, sizeof(struct AST_label ), 0);
#line 68
    tmp___1 = tmp___0;
    }
  }
#line 68
  obj = (label )tmp___1;
#line 70
  obj->kind = (AST_kind )184;
#line 71
  obj->location = location___0;
#line 73
  return (obj);
}
}
#line 76 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
asm_decl new_asm_decl(region r , location location___0 , asm_stmt asm_stmt___0 ) 
{ 
  asm_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 78
  if (sizeof(struct AST_asm_decl ) < (unsigned long )(1 << 9)) {
    {
#line 78
    tmp = __rcralloc_small0(r, sizeof(struct AST_asm_decl ));
#line 78
    tmp___1 = tmp;
    }
  } else {
    {
#line 78
    tmp___0 = typed_ralloc(r, sizeof(struct AST_asm_decl ), 0);
#line 78
    tmp___1 = tmp___0;
    }
  }
#line 78
  obj = (asm_decl )tmp___1;
#line 80
  obj->kind = (AST_kind )44;
#line 81
  obj->location = location___0;
#line 82
  obj->asm_stmt = asm_stmt___0;
#line 84
  return (obj);
}
}
#line 87 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
data_decl new_data_decl(region r , location location___0 , type_element modifiers ,
                        declaration decls ) 
{ 
  data_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 89
  if (sizeof(struct AST_data_decl ) < (unsigned long )(1 << 9)) {
    {
#line 89
    tmp = __rcralloc_small0(r, sizeof(struct AST_data_decl ));
#line 89
    tmp___1 = tmp;
    }
  } else {
    {
#line 89
    tmp___0 = typed_ralloc(r, sizeof(struct AST_data_decl ), 0);
#line 89
    tmp___1 = tmp___0;
    }
  }
#line 89
  obj = (data_decl )tmp___1;
#line 91
  obj->kind = (AST_kind )45;
#line 92
  obj->location = location___0;
#line 93
  obj->modifiers = modifiers;
#line 94
  obj->decls = decls;
#line 96
  return (obj);
}
}
#line 99 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
extension_decl new_extension_decl(region r , location location___0 , declaration decl ) 
{ 
  extension_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 101
  if (sizeof(struct AST_extension_decl ) < (unsigned long )(1 << 9)) {
    {
#line 101
    tmp = __rcralloc_small0(r, sizeof(struct AST_extension_decl ));
#line 101
    tmp___1 = tmp;
    }
  } else {
    {
#line 101
    tmp___0 = typed_ralloc(r, sizeof(struct AST_extension_decl ), 0);
#line 101
    tmp___1 = tmp___0;
    }
  }
#line 101
  obj = (extension_decl )tmp___1;
#line 103
  obj->kind = (AST_kind )46;
#line 104
  obj->location = location___0;
#line 105
  obj->decl = decl;
#line 107
  return (obj);
}
}
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
ellipsis_decl new_ellipsis_decl(region r , location location___0 ) 
{ 
  ellipsis_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 112
  if (sizeof(struct AST_ellipsis_decl ) < (unsigned long )(1 << 9)) {
    {
#line 112
    tmp = __rcralloc_small0(r, sizeof(struct AST_ellipsis_decl ));
#line 112
    tmp___1 = tmp;
    }
  } else {
    {
#line 112
    tmp___0 = typed_ralloc(r, sizeof(struct AST_ellipsis_decl ), 0);
#line 112
    tmp___1 = tmp___0;
    }
  }
#line 112
  obj = (ellipsis_decl )tmp___1;
#line 114
  obj->kind = (AST_kind )47;
#line 115
  obj->location = location___0;
#line 117
  return (obj);
}
}
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
enumerator new_enumerator(region r , location location___0 , cstring cstring___0 ,
                          expression arg1 , data_declaration ddecl ) 
{ 
  enumerator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 122
  if (sizeof(struct AST_enumerator ) < (unsigned long )(1 << 9)) {
    {
#line 122
    tmp = __rcralloc_small0(r, sizeof(struct AST_enumerator ));
#line 122
    tmp___1 = tmp;
    }
  } else {
    {
#line 122
    tmp___0 = typed_ralloc(r, sizeof(struct AST_enumerator ), 0);
#line 122
    tmp___1 = tmp___0;
    }
  }
#line 122
  obj = (enumerator )tmp___1;
#line 124
  obj->kind = (AST_kind )48;
#line 125
  obj->location = location___0;
#line 126
  obj->cstring = cstring___0;
#line 127
  obj->arg1 = arg1;
#line 128
  obj->ddecl = ddecl;
#line 130
  return (obj);
}
}
#line 133 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
oldidentifier_decl new_oldidentifier_decl(region r , location location___0 , cstring cstring___0 ,
                                          data_declaration ddecl ) 
{ 
  oldidentifier_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 135
  if (sizeof(struct AST_oldidentifier_decl ) < (unsigned long )(1 << 9)) {
    {
#line 135
    tmp = __rcralloc_small0(r, sizeof(struct AST_oldidentifier_decl ));
#line 135
    tmp___1 = tmp;
    }
  } else {
    {
#line 135
    tmp___0 = typed_ralloc(r, sizeof(struct AST_oldidentifier_decl ), 0);
#line 135
    tmp___1 = tmp___0;
    }
  }
#line 135
  obj = (oldidentifier_decl )tmp___1;
#line 137
  obj->kind = (AST_kind )49;
#line 138
  obj->location = location___0;
#line 139
  obj->cstring = cstring___0;
#line 140
  obj->ddecl = ddecl;
#line 142
  return (obj);
}
}
#line 145 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
function_decl new_function_decl(region r , location location___0 , declarator declarator___0 ,
                                type_element modifiers , attribute attributes , declaration old_parms ,
                                statement stmt , function_decl parent_function___0 ,
                                data_declaration ddecl ) 
{ 
  function_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 147
  if (sizeof(struct AST_function_decl ) < (unsigned long )(1 << 9)) {
    {
#line 147
    tmp = __rcralloc_small0(r, sizeof(struct AST_function_decl ));
#line 147
    tmp___1 = tmp;
    }
  } else {
    {
#line 147
    tmp___0 = typed_ralloc(r, sizeof(struct AST_function_decl ), 0);
#line 147
    tmp___1 = tmp___0;
    }
  }
#line 147
  obj = (function_decl )tmp___1;
#line 149
  obj->kind = (AST_kind )50;
#line 150
  obj->location = location___0;
#line 151
  obj->declarator = declarator___0;
#line 152
  obj->modifiers = modifiers;
#line 153
  obj->attributes = attributes;
#line 154
  obj->old_parms = old_parms;
#line 155
  obj->stmt = stmt;
#line 156
  obj->parent_function = parent_function___0;
#line 157
  obj->ddecl = ddecl;
#line 159
  return (obj);
}
}
#line 162 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
implicit_decl new_implicit_decl(region r , location location___0 , identifier ident ) 
{ 
  implicit_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 164
  if (sizeof(struct AST_implicit_decl ) < (unsigned long )(1 << 9)) {
    {
#line 164
    tmp = __rcralloc_small0(r, sizeof(struct AST_implicit_decl ));
#line 164
    tmp___1 = tmp;
    }
  } else {
    {
#line 164
    tmp___0 = typed_ralloc(r, sizeof(struct AST_implicit_decl ), 0);
#line 164
    tmp___1 = tmp___0;
    }
  }
#line 164
  obj = (implicit_decl )tmp___1;
#line 166
  obj->kind = (AST_kind )51;
#line 167
  obj->location = location___0;
#line 168
  obj->ident = ident;
#line 170
  return (obj);
}
}
#line 173 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
variable_decl new_variable_decl(region r , location location___0 , declarator declarator___0 ,
                                attribute attributes , expression arg1 , asm_stmt asm_stmt___0 ,
                                data_declaration ddecl ) 
{ 
  variable_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 175
  if (sizeof(struct AST_variable_decl ) < (unsigned long )(1 << 9)) {
    {
#line 175
    tmp = __rcralloc_small0(r, sizeof(struct AST_variable_decl ));
#line 175
    tmp___1 = tmp;
    }
  } else {
    {
#line 175
    tmp___0 = typed_ralloc(r, sizeof(struct AST_variable_decl ), 0);
#line 175
    tmp___1 = tmp___0;
    }
  }
#line 175
  obj = (variable_decl )tmp___1;
#line 177
  obj->kind = (AST_kind )52;
#line 178
  obj->location = location___0;
#line 179
  obj->declarator = declarator___0;
#line 180
  obj->attributes = attributes;
#line 181
  obj->arg1 = arg1;
#line 182
  obj->asm_stmt = asm_stmt___0;
#line 183
  obj->ddecl = ddecl;
#line 185
  return (obj);
}
}
#line 188 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
field_decl new_field_decl(region r , location location___0 , declarator declarator___0 ,
                          attribute attributes , expression arg1 ) 
{ 
  field_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 190
  if (sizeof(struct AST_field_decl ) < (unsigned long )(1 << 9)) {
    {
#line 190
    tmp = __rcralloc_small0(r, sizeof(struct AST_field_decl ));
#line 190
    tmp___1 = tmp;
    }
  } else {
    {
#line 190
    tmp___0 = typed_ralloc(r, sizeof(struct AST_field_decl ), 0);
#line 190
    tmp___1 = tmp___0;
    }
  }
#line 190
  obj = (field_decl )tmp___1;
#line 192
  obj->kind = (AST_kind )53;
#line 193
  obj->location = location___0;
#line 194
  obj->declarator = declarator___0;
#line 195
  obj->attributes = attributes;
#line 196
  obj->arg1 = arg1;
#line 198
  return (obj);
}
}
#line 201 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
asttype new_asttype(region r , location location___0 , declarator declarator___0 ,
                    type_element qualifiers ) 
{ 
  asttype obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 203
  if (sizeof(struct AST_asttype ) < (unsigned long )(1 << 9)) {
    {
#line 203
    tmp = __rcralloc_small0(r, sizeof(struct AST_asttype ));
#line 203
    tmp___1 = tmp;
    }
  } else {
    {
#line 203
    tmp___0 = typed_ralloc(r, sizeof(struct AST_asttype ), 0);
#line 203
    tmp___1 = tmp___0;
    }
  }
#line 203
  obj = (asttype )tmp___1;
#line 205
  obj->kind = (AST_kind )188;
#line 206
  obj->location = location___0;
#line 207
  obj->declarator = declarator___0;
#line 208
  obj->qualifiers = qualifiers;
#line 210
  return (obj);
}
}
#line 213 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
typename new_typename(region r , location location___0 , data_declaration ddecl ) 
{ 
  typename obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 215
  if (sizeof(struct AST_typename ) < (unsigned long )(1 << 9)) {
    {
#line 215
    tmp = __rcralloc_small0(r, sizeof(struct AST_typename ));
#line 215
    tmp___1 = tmp;
    }
  } else {
    {
#line 215
    tmp___0 = typed_ralloc(r, sizeof(struct AST_typename ), 0);
#line 215
    tmp___1 = tmp___0;
    }
  }
#line 215
  obj = (typename )tmp___1;
#line 217
  obj->kind = (AST_kind )158;
#line 218
  obj->location = location___0;
#line 219
  obj->ddecl = ddecl;
#line 221
  return (obj);
}
}
#line 224 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
typeof_expr new_typeof_expr(region r , location location___0 , expression arg1 ) 
{ 
  typeof_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (sizeof(struct AST_typeof_expr ) < (unsigned long )(1 << 9)) {
    {
#line 226
    tmp = __rcralloc_small0(r, sizeof(struct AST_typeof_expr ));
#line 226
    tmp___1 = tmp;
    }
  } else {
    {
#line 226
    tmp___0 = typed_ralloc(r, sizeof(struct AST_typeof_expr ), 0);
#line 226
    tmp___1 = tmp___0;
    }
  }
#line 226
  obj = (typeof_expr )tmp___1;
#line 228
  obj->kind = (AST_kind )160;
#line 229
  obj->location = location___0;
#line 230
  obj->arg1 = arg1;
#line 232
  return (obj);
}
}
#line 235 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
typeof_type new_typeof_type(region r , location location___0 , asttype asttype___0 ) 
{ 
  typeof_type obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 237
  if (sizeof(struct AST_typeof_type ) < (unsigned long )(1 << 9)) {
    {
#line 237
    tmp = __rcralloc_small0(r, sizeof(struct AST_typeof_type ));
#line 237
    tmp___1 = tmp;
    }
  } else {
    {
#line 237
    tmp___0 = typed_ralloc(r, sizeof(struct AST_typeof_type ), 0);
#line 237
    tmp___1 = tmp___0;
    }
  }
#line 237
  obj = (typeof_type )tmp___1;
#line 239
  obj->kind = (AST_kind )161;
#line 240
  obj->location = location___0;
#line 241
  obj->asttype = asttype___0;
#line 243
  return (obj);
}
}
#line 246 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
attribute new_attribute(region r , location location___0 , word word1 ) 
{ 
  attribute obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 248
  if (sizeof(struct AST_attribute ) < (unsigned long )(1 << 9)) {
    {
#line 248
    tmp = __rcralloc_small0(r, sizeof(struct AST_attribute ));
#line 248
    tmp___1 = tmp;
    }
  } else {
    {
#line 248
    tmp___0 = typed_ralloc(r, sizeof(struct AST_attribute ), 0);
#line 248
    tmp___1 = tmp___0;
    }
  }
#line 248
  obj = (attribute )tmp___1;
#line 250
  obj->kind = (AST_kind )162;
#line 251
  obj->location = location___0;
#line 252
  obj->word1 = word1;
#line 254
  return (obj);
}
}
#line 257 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
gcc_attribute new_gcc_attribute(region r , location location___0 , word word1 , expression args ) 
{ 
  gcc_attribute obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 259
  if (sizeof(struct AST_gcc_attribute ) < (unsigned long )(1 << 9)) {
    {
#line 259
    tmp = __rcralloc_small0(r, sizeof(struct AST_gcc_attribute ));
#line 259
    tmp___1 = tmp;
    }
  } else {
    {
#line 259
    tmp___0 = typed_ralloc(r, sizeof(struct AST_gcc_attribute ), 0);
#line 259
    tmp___1 = tmp___0;
    }
  }
#line 259
  obj = (gcc_attribute )tmp___1;
#line 261
  obj->kind = (AST_kind )163;
#line 262
  obj->location = location___0;
#line 263
  obj->word1 = word1;
#line 264
  obj->args = args;
#line 266
  return (obj);
}
}
#line 269 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
rid new_rid(region r , location location___0 , enum rid id ) 
{ 
  rid obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 271
  if (sizeof(struct AST_rid ) < (unsigned long )(1 << 9)) {
    {
#line 271
    tmp = __rcralloc_small0(r, sizeof(struct AST_rid ));
#line 271
    tmp___1 = tmp;
    }
  } else {
    {
#line 271
    tmp___0 = typed_ralloc(r, sizeof(struct AST_rid ), 0);
#line 271
    tmp___1 = tmp___0;
    }
  }
#line 271
  obj = (rid )tmp___1;
#line 273
  obj->kind = (AST_kind )166;
#line 274
  obj->location = location___0;
#line 275
  obj->id = id;
#line 277
  return (obj);
}
}
#line 280 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
qualifier new_qualifier(region r , location location___0 , enum rid id ) 
{ 
  qualifier obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 282
  if (sizeof(struct AST_qualifier ) < (unsigned long )(1 << 9)) {
    {
#line 282
    tmp = __rcralloc_small0(r, sizeof(struct AST_qualifier ));
#line 282
    tmp___1 = tmp;
    }
  } else {
    {
#line 282
    tmp___0 = typed_ralloc(r, sizeof(struct AST_qualifier ), 0);
#line 282
    tmp___1 = tmp___0;
    }
  }
#line 282
  obj = (qualifier )tmp___1;
#line 284
  obj->kind = (AST_kind )167;
#line 285
  obj->location = location___0;
#line 286
  obj->id = id;
#line 288
  return (obj);
}
}
#line 291 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
tag_ref new_tag_ref(region r , location location___0 , word word1 , attribute attributes ,
                    declaration fields , bool defined ) 
{ 
  tag_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 293
  if (sizeof(struct AST_tag_ref ) < (unsigned long )(1 << 9)) {
    {
#line 293
    tmp = __rcralloc_small0(r, sizeof(struct AST_tag_ref ));
#line 293
    tmp___1 = tmp;
    }
  } else {
    {
#line 293
    tmp___0 = typed_ralloc(r, sizeof(struct AST_tag_ref ), 0);
#line 293
    tmp___1 = tmp___0;
    }
  }
#line 293
  obj = (tag_ref )tmp___1;
#line 295
  obj->kind = (AST_kind )168;
#line 296
  obj->location = location___0;
#line 297
  obj->word1 = word1;
#line 298
  obj->attributes = attributes;
#line 299
  obj->fields = fields;
#line 300
  obj->defined = defined;
#line 302
  return (obj);
}
}
#line 305 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
struct_ref new_struct_ref(region r , location location___0 , word word1 , attribute attributes ,
                          declaration fields , bool defined ) 
{ 
  struct_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 307
  if (sizeof(struct AST_struct_ref ) < (unsigned long )(1 << 9)) {
    {
#line 307
    tmp = __rcralloc_small0(r, sizeof(struct AST_struct_ref ));
#line 307
    tmp___1 = tmp;
    }
  } else {
    {
#line 307
    tmp___0 = typed_ralloc(r, sizeof(struct AST_struct_ref ), 0);
#line 307
    tmp___1 = tmp___0;
    }
  }
#line 307
  obj = (struct_ref )tmp___1;
#line 309
  obj->kind = (AST_kind )169;
#line 310
  obj->location = location___0;
#line 311
  obj->word1 = word1;
#line 312
  obj->attributes = attributes;
#line 313
  obj->fields = fields;
#line 314
  obj->defined = defined;
#line 316
  return (obj);
}
}
#line 319 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
union_ref new_union_ref(region r , location location___0 , word word1 , attribute attributes ,
                        declaration fields , bool defined ) 
{ 
  union_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 321
  if (sizeof(struct AST_union_ref ) < (unsigned long )(1 << 9)) {
    {
#line 321
    tmp = __rcralloc_small0(r, sizeof(struct AST_union_ref ));
#line 321
    tmp___1 = tmp;
    }
  } else {
    {
#line 321
    tmp___0 = typed_ralloc(r, sizeof(struct AST_union_ref ), 0);
#line 321
    tmp___1 = tmp___0;
    }
  }
#line 321
  obj = (union_ref )tmp___1;
#line 323
  obj->kind = (AST_kind )171;
#line 324
  obj->location = location___0;
#line 325
  obj->word1 = word1;
#line 326
  obj->attributes = attributes;
#line 327
  obj->fields = fields;
#line 328
  obj->defined = defined;
#line 330
  return (obj);
}
}
#line 333 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
nested_declarator new_nested_declarator(region r , location location___0 , declarator declarator___0 ) 
{ 
  nested_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 335
  if (sizeof(struct AST_nested_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 335
    tmp = __rcralloc_small0(r, sizeof(struct AST_nested_declarator ));
#line 335
    tmp___1 = tmp;
    }
  } else {
    {
#line 335
    tmp___0 = typed_ralloc(r, sizeof(struct AST_nested_declarator ), 0);
#line 335
    tmp___1 = tmp___0;
    }
  }
#line 335
  obj = (nested_declarator )tmp___1;
#line 337
  obj->kind = (AST_kind )176;
#line 338
  obj->location = location___0;
#line 339
  obj->declarator = declarator___0;
#line 341
  return (obj);
}
}
#line 344 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
function_declarator new_function_declarator(region r , location location___0 , declarator declarator___0 ,
                                            declaration parms , declaration gparms ,
                                            type_element qualifiers , environment env___0 ) 
{ 
  function_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 346
  if (sizeof(struct AST_function_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 346
    tmp = __rcralloc_small0(r, sizeof(struct AST_function_declarator ));
#line 346
    tmp___1 = tmp;
    }
  } else {
    {
#line 346
    tmp___0 = typed_ralloc(r, sizeof(struct AST_function_declarator ), 0);
#line 346
    tmp___1 = tmp___0;
    }
  }
#line 346
  obj = (function_declarator )tmp___1;
#line 348
  obj->kind = (AST_kind )177;
#line 349
  obj->location = location___0;
#line 350
  obj->declarator = declarator___0;
#line 351
  obj->parms = parms;
#line 352
  obj->gparms = gparms;
#line 353
  obj->qualifiers = qualifiers;
#line 354
  obj->env = env___0;
#line 356
  return (obj);
}
}
#line 359 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
pointer_declarator new_pointer_declarator(region r , location location___0 , declarator declarator___0 ) 
{ 
  pointer_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 361
  if (sizeof(struct AST_pointer_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 361
    tmp = __rcralloc_small0(r, sizeof(struct AST_pointer_declarator ));
#line 361
    tmp___1 = tmp;
    }
  } else {
    {
#line 361
    tmp___0 = typed_ralloc(r, sizeof(struct AST_pointer_declarator ), 0);
#line 361
    tmp___1 = tmp___0;
    }
  }
#line 361
  obj = (pointer_declarator )tmp___1;
#line 363
  obj->kind = (AST_kind )178;
#line 364
  obj->location = location___0;
#line 365
  obj->declarator = declarator___0;
#line 367
  return (obj);
}
}
#line 370 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
qualified_declarator new_qualified_declarator(region r , location location___0 , declarator declarator___0 ,
                                              type_element modifiers ) 
{ 
  qualified_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 372
  if (sizeof(struct AST_qualified_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 372
    tmp = __rcralloc_small0(r, sizeof(struct AST_qualified_declarator ));
#line 372
    tmp___1 = tmp;
    }
  } else {
    {
#line 372
    tmp___0 = typed_ralloc(r, sizeof(struct AST_qualified_declarator ), 0);
#line 372
    tmp___1 = tmp___0;
    }
  }
#line 372
  obj = (qualified_declarator )tmp___1;
#line 374
  obj->kind = (AST_kind )179;
#line 375
  obj->location = location___0;
#line 376
  obj->declarator = declarator___0;
#line 377
  obj->modifiers = modifiers;
#line 379
  return (obj);
}
}
#line 382 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
array_declarator new_array_declarator(region r , location location___0 , declarator declarator___0 ,
                                      expression arg1 ) 
{ 
  array_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 384
  if (sizeof(struct AST_array_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 384
    tmp = __rcralloc_small0(r, sizeof(struct AST_array_declarator ));
#line 384
    tmp___1 = tmp;
    }
  } else {
    {
#line 384
    tmp___0 = typed_ralloc(r, sizeof(struct AST_array_declarator ), 0);
#line 384
    tmp___1 = tmp___0;
    }
  }
#line 384
  obj = (array_declarator )tmp___1;
#line 386
  obj->kind = (AST_kind )180;
#line 387
  obj->location = location___0;
#line 388
  obj->declarator = declarator___0;
#line 389
  obj->arg1 = arg1;
#line 391
  return (obj);
}
}
#line 394 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
identifier_declarator new_identifier_declarator(region r , location location___0 ,
                                                cstring cstring___0 ) 
{ 
  identifier_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 396
  if (sizeof(struct AST_identifier_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 396
    tmp = __rcralloc_small0(r, sizeof(struct AST_identifier_declarator ));
#line 396
    tmp___1 = tmp;
    }
  } else {
    {
#line 396
    tmp___0 = typed_ralloc(r, sizeof(struct AST_identifier_declarator ), 0);
#line 396
    tmp___1 = tmp___0;
    }
  }
#line 396
  obj = (identifier_declarator )tmp___1;
#line 398
  obj->kind = (AST_kind )182;
#line 399
  obj->location = location___0;
#line 400
  obj->cstring = cstring___0;
#line 402
  return (obj);
}
}
#line 405 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
asm_stmt new_asm_stmt(region r , location location___0 , expression arg1 , asm_operand asm_operands1 ,
                      asm_operand asm_operands2 , string asm_clobbers , type_element qualifiers ) 
{ 
  asm_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 407
  if (sizeof(struct AST_asm_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 407
    tmp = __rcralloc_small0(r, sizeof(struct AST_asm_stmt ));
#line 407
    tmp___1 = tmp;
    }
  } else {
    {
#line 407
    tmp___0 = typed_ralloc(r, sizeof(struct AST_asm_stmt ), 0);
#line 407
    tmp___1 = tmp___0;
    }
  }
#line 407
  obj = (asm_stmt )tmp___1;
#line 409
  obj->kind = (AST_kind )66;
#line 410
  obj->location = location___0;
#line 411
  obj->isatomic = (atomic_t )2;
#line 412
  obj->arg1 = arg1;
#line 413
  obj->asm_operands1 = asm_operands1;
#line 414
  obj->asm_operands2 = asm_operands2;
#line 415
  obj->asm_clobbers = asm_clobbers;
#line 416
  obj->qualifiers = qualifiers;
#line 418
  return (obj);
}
}
#line 421 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
compound_stmt new_compound_stmt(region r , location location___0 , id_label id_labels ,
                                declaration decls , statement stmts , environment env___0 ) 
{ 
  compound_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 423
  if (sizeof(struct AST_compound_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 423
    tmp = __rcralloc_small0(r, sizeof(struct AST_compound_stmt ));
#line 423
    tmp___1 = tmp;
    }
  } else {
    {
#line 423
    tmp___0 = typed_ralloc(r, sizeof(struct AST_compound_stmt ), 0);
#line 423
    tmp___1 = tmp___0;
    }
  }
#line 423
  obj = (compound_stmt )tmp___1;
#line 425
  obj->kind = (AST_kind )67;
#line 426
  obj->location = location___0;
#line 427
  obj->isatomic = (atomic_t )2;
#line 428
  obj->id_labels = id_labels;
#line 429
  obj->decls = decls;
#line 430
  obj->stmts = stmts;
#line 431
  obj->env = env___0;
#line 433
  return (obj);
}
}
#line 436 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
if_stmt new_if_stmt(region r , location location___0 , expression condition , statement stmt1 ,
                    statement stmt2 ) 
{ 
  if_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 438
  if (sizeof(struct AST_if_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 438
    tmp = __rcralloc_small0(r, sizeof(struct AST_if_stmt ));
#line 438
    tmp___1 = tmp;
    }
  } else {
    {
#line 438
    tmp___0 = typed_ralloc(r, sizeof(struct AST_if_stmt ), 0);
#line 438
    tmp___1 = tmp___0;
    }
  }
#line 438
  obj = (if_stmt )tmp___1;
#line 440
  obj->kind = (AST_kind )68;
#line 441
  obj->location = location___0;
#line 442
  obj->isatomic = (atomic_t )2;
#line 443
  obj->condition = condition;
#line 444
  obj->stmt1 = stmt1;
#line 445
  obj->stmt2 = stmt2;
#line 447
  return (obj);
}
}
#line 450 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
labeled_stmt new_labeled_stmt(region r , location location___0 , label label___0 ,
                              statement stmt ) 
{ 
  labeled_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 452
  if (sizeof(struct AST_labeled_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 452
    tmp = __rcralloc_small0(r, sizeof(struct AST_labeled_stmt ));
#line 452
    tmp___1 = tmp;
    }
  } else {
    {
#line 452
    tmp___0 = typed_ralloc(r, sizeof(struct AST_labeled_stmt ), 0);
#line 452
    tmp___1 = tmp___0;
    }
  }
#line 452
  obj = (labeled_stmt )tmp___1;
#line 454
  obj->kind = (AST_kind )69;
#line 455
  obj->location = location___0;
#line 456
  obj->isatomic = (atomic_t )2;
#line 457
  obj->label = label___0;
#line 458
  obj->stmt = stmt;
#line 460
  return (obj);
}
}
#line 463 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
expression_stmt new_expression_stmt(region r , location location___0 , expression arg1 ) 
{ 
  expression_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 465
  if (sizeof(struct AST_expression_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 465
    tmp = __rcralloc_small0(r, sizeof(struct AST_expression_stmt ));
#line 465
    tmp___1 = tmp;
    }
  } else {
    {
#line 465
    tmp___0 = typed_ralloc(r, sizeof(struct AST_expression_stmt ), 0);
#line 465
    tmp___1 = tmp___0;
    }
  }
#line 465
  obj = (expression_stmt )tmp___1;
#line 467
  obj->kind = (AST_kind )70;
#line 468
  obj->location = location___0;
#line 469
  obj->isatomic = (atomic_t )2;
#line 470
  obj->arg1 = arg1;
#line 472
  return (obj);
}
}
#line 475 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
conditional_stmt new_conditional_stmt(region r , location location___0 , expression condition ,
                                      statement stmt ) 
{ 
  conditional_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 477
  if (sizeof(struct AST_conditional_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 477
    tmp = __rcralloc_small0(r, sizeof(struct AST_conditional_stmt ));
#line 477
    tmp___1 = tmp;
    }
  } else {
    {
#line 477
    tmp___0 = typed_ralloc(r, sizeof(struct AST_conditional_stmt ), 0);
#line 477
    tmp___1 = tmp___0;
    }
  }
#line 477
  obj = (conditional_stmt )tmp___1;
#line 479
  obj->kind = (AST_kind )71;
#line 480
  obj->location = location___0;
#line 481
  obj->isatomic = (atomic_t )2;
#line 482
  obj->condition = condition;
#line 483
  obj->stmt = stmt;
#line 485
  return (obj);
}
}
#line 488 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
switch_stmt new_switch_stmt(region r , location location___0 , expression condition ,
                            statement stmt ) 
{ 
  switch_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 490
  if (sizeof(struct AST_switch_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 490
    tmp = __rcralloc_small0(r, sizeof(struct AST_switch_stmt ));
#line 490
    tmp___1 = tmp;
    }
  } else {
    {
#line 490
    tmp___0 = typed_ralloc(r, sizeof(struct AST_switch_stmt ), 0);
#line 490
    tmp___1 = tmp___0;
    }
  }
#line 490
  obj = (switch_stmt )tmp___1;
#line 492
  obj->kind = (AST_kind )72;
#line 493
  obj->location = location___0;
#line 494
  obj->isatomic = (atomic_t )2;
#line 495
  obj->condition = condition;
#line 496
  obj->stmt = stmt;
#line 498
  return (obj);
}
}
#line 501 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
for_stmt new_for_stmt(region r , location location___0 , expression arg1 , expression arg2 ,
                      expression arg3 , statement stmt ) 
{ 
  for_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 503
  if (sizeof(struct AST_for_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 503
    tmp = __rcralloc_small0(r, sizeof(struct AST_for_stmt ));
#line 503
    tmp___1 = tmp;
    }
  } else {
    {
#line 503
    tmp___0 = typed_ralloc(r, sizeof(struct AST_for_stmt ), 0);
#line 503
    tmp___1 = tmp___0;
    }
  }
#line 503
  obj = (for_stmt )tmp___1;
#line 505
  obj->kind = (AST_kind )75;
#line 506
  obj->location = location___0;
#line 507
  obj->isatomic = (atomic_t )2;
#line 508
  obj->arg1 = arg1;
#line 509
  obj->arg2 = arg2;
#line 510
  obj->arg3 = arg3;
#line 511
  obj->stmt = stmt;
#line 513
  return (obj);
}
}
#line 516 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
break_stmt new_break_stmt(region r , location location___0 ) 
{ 
  break_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 518
  if (sizeof(struct AST_break_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 518
    tmp = __rcralloc_small0(r, sizeof(struct AST_break_stmt ));
#line 518
    tmp___1 = tmp;
    }
  } else {
    {
#line 518
    tmp___0 = typed_ralloc(r, sizeof(struct AST_break_stmt ), 0);
#line 518
    tmp___1 = tmp___0;
    }
  }
#line 518
  obj = (break_stmt )tmp___1;
#line 520
  obj->kind = (AST_kind )76;
#line 521
  obj->location = location___0;
#line 522
  obj->isatomic = (atomic_t )2;
#line 524
  return (obj);
}
}
#line 527 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
continue_stmt new_continue_stmt(region r , location location___0 ) 
{ 
  continue_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 529
  if (sizeof(struct AST_continue_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 529
    tmp = __rcralloc_small0(r, sizeof(struct AST_continue_stmt ));
#line 529
    tmp___1 = tmp;
    }
  } else {
    {
#line 529
    tmp___0 = typed_ralloc(r, sizeof(struct AST_continue_stmt ), 0);
#line 529
    tmp___1 = tmp___0;
    }
  }
#line 529
  obj = (continue_stmt )tmp___1;
#line 531
  obj->kind = (AST_kind )77;
#line 532
  obj->location = location___0;
#line 533
  obj->isatomic = (atomic_t )2;
#line 535
  return (obj);
}
}
#line 538 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
return_stmt new_return_stmt(region r , location location___0 , expression arg1 ) 
{ 
  return_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 540
  if (sizeof(struct AST_return_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 540
    tmp = __rcralloc_small0(r, sizeof(struct AST_return_stmt ));
#line 540
    tmp___1 = tmp;
    }
  } else {
    {
#line 540
    tmp___0 = typed_ralloc(r, sizeof(struct AST_return_stmt ), 0);
#line 540
    tmp___1 = tmp___0;
    }
  }
#line 540
  obj = (return_stmt )tmp___1;
#line 542
  obj->kind = (AST_kind )78;
#line 543
  obj->location = location___0;
#line 544
  obj->isatomic = (atomic_t )2;
#line 545
  obj->arg1 = arg1;
#line 547
  return (obj);
}
}
#line 550 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
goto_stmt new_goto_stmt(region r , location location___0 , id_label id_label___0 ) 
{ 
  goto_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 552
  if (sizeof(struct AST_goto_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 552
    tmp = __rcralloc_small0(r, sizeof(struct AST_goto_stmt ));
#line 552
    tmp___1 = tmp;
    }
  } else {
    {
#line 552
    tmp___0 = typed_ralloc(r, sizeof(struct AST_goto_stmt ), 0);
#line 552
    tmp___1 = tmp___0;
    }
  }
#line 552
  obj = (goto_stmt )tmp___1;
#line 554
  obj->kind = (AST_kind )79;
#line 555
  obj->location = location___0;
#line 556
  obj->isatomic = (atomic_t )2;
#line 557
  obj->id_label = id_label___0;
#line 559
  return (obj);
}
}
#line 562 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
computed_goto_stmt new_computed_goto_stmt(region r , location location___0 , expression arg1 ) 
{ 
  computed_goto_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 564
  if (sizeof(struct AST_computed_goto_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 564
    tmp = __rcralloc_small0(r, sizeof(struct AST_computed_goto_stmt ));
#line 564
    tmp___1 = tmp;
    }
  } else {
    {
#line 564
    tmp___0 = typed_ralloc(r, sizeof(struct AST_computed_goto_stmt ), 0);
#line 564
    tmp___1 = tmp___0;
    }
  }
#line 564
  obj = (computed_goto_stmt )tmp___1;
#line 566
  obj->kind = (AST_kind )80;
#line 567
  obj->location = location___0;
#line 568
  obj->isatomic = (atomic_t )2;
#line 569
  obj->arg1 = arg1;
#line 571
  return (obj);
}
}
#line 574 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
empty_stmt new_empty_stmt(region r , location location___0 ) 
{ 
  empty_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 576
  if (sizeof(struct AST_empty_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 576
    tmp = __rcralloc_small0(r, sizeof(struct AST_empty_stmt ));
#line 576
    tmp___1 = tmp;
    }
  } else {
    {
#line 576
    tmp___0 = typed_ralloc(r, sizeof(struct AST_empty_stmt ), 0);
#line 576
    tmp___1 = tmp___0;
    }
  }
#line 576
  obj = (empty_stmt )tmp___1;
#line 578
  obj->kind = (AST_kind )81;
#line 579
  obj->location = location___0;
#line 580
  obj->isatomic = (atomic_t )2;
#line 582
  return (obj);
}
}
#line 585 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
unary new_unary(region r , location location___0 , expression arg1 ) 
{ 
  unary obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 587
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 587
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 587
    tmp___1 = tmp;
    }
  } else {
    {
#line 587
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 587
    tmp___1 = tmp___0;
    }
  }
#line 587
  obj = (unary )tmp___1;
#line 589
  obj->kind = (AST_kind )85;
#line 590
  obj->location = location___0;
#line 591
  obj->isatomic = (atomic_t )2;
#line 592
  obj->arg1 = arg1;
#line 594
  return (obj);
}
}
#line 597 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
binary new_binary(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  binary obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 599
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 599
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 599
    tmp___1 = tmp;
    }
  } else {
    {
#line 599
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 599
    tmp___1 = tmp___0;
    }
  }
#line 599
  obj = (binary )tmp___1;
#line 601
  obj->kind = (AST_kind )107;
#line 602
  obj->location = location___0;
#line 603
  obj->isatomic = (atomic_t )2;
#line 604
  obj->arg1 = arg1;
#line 605
  obj->arg2 = arg2;
#line 607
  return (obj);
}
}
#line 610 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
comma new_comma(region r , location location___0 , expression arg1 ) 
{ 
  comma obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 612
  if (sizeof(struct AST_comma ) < (unsigned long )(1 << 9)) {
    {
#line 612
    tmp = __rcralloc_small0(r, sizeof(struct AST_comma ));
#line 612
    tmp___1 = tmp;
    }
  } else {
    {
#line 612
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comma ), 0);
#line 612
    tmp___1 = tmp___0;
    }
  }
#line 612
  obj = (comma )tmp___1;
#line 614
  obj->kind = (AST_kind )140;
#line 615
  obj->location = location___0;
#line 616
  obj->isatomic = (atomic_t )2;
#line 617
  obj->arg1 = arg1;
#line 619
  return (obj);
}
}
#line 622 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
sizeof_type new_sizeof_type(region r , location location___0 , asttype asttype___0 ) 
{ 
  sizeof_type obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 624
  if (sizeof(struct AST_sizeof_type ) < (unsigned long )(1 << 9)) {
    {
#line 624
    tmp = __rcralloc_small0(r, sizeof(struct AST_sizeof_type ));
#line 624
    tmp___1 = tmp;
    }
  } else {
    {
#line 624
    tmp___0 = typed_ralloc(r, sizeof(struct AST_sizeof_type ), 0);
#line 624
    tmp___1 = tmp___0;
    }
  }
#line 624
  obj = (sizeof_type )tmp___1;
#line 626
  obj->kind = (AST_kind )141;
#line 627
  obj->location = location___0;
#line 628
  obj->isatomic = (atomic_t )2;
#line 629
  obj->asttype = asttype___0;
#line 631
  return (obj);
}
}
#line 634 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
alignof_type new_alignof_type(region r , location location___0 , asttype asttype___0 ) 
{ 
  alignof_type obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 636
  if (sizeof(struct AST_alignof_type ) < (unsigned long )(1 << 9)) {
    {
#line 636
    tmp = __rcralloc_small0(r, sizeof(struct AST_alignof_type ));
#line 636
    tmp___1 = tmp;
    }
  } else {
    {
#line 636
    tmp___0 = typed_ralloc(r, sizeof(struct AST_alignof_type ), 0);
#line 636
    tmp___1 = tmp___0;
    }
  }
#line 636
  obj = (alignof_type )tmp___1;
#line 638
  obj->kind = (AST_kind )142;
#line 639
  obj->location = location___0;
#line 640
  obj->isatomic = (atomic_t )2;
#line 641
  obj->asttype = asttype___0;
#line 643
  return (obj);
}
}
#line 646 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
label_address new_label_address(region r , location location___0 , id_label id_label___0 ) 
{ 
  label_address obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 648
  if (sizeof(struct AST_label_address ) < (unsigned long )(1 << 9)) {
    {
#line 648
    tmp = __rcralloc_small0(r, sizeof(struct AST_label_address ));
#line 648
    tmp___1 = tmp;
    }
  } else {
    {
#line 648
    tmp___0 = typed_ralloc(r, sizeof(struct AST_label_address ), 0);
#line 648
    tmp___1 = tmp___0;
    }
  }
#line 648
  obj = (label_address )tmp___1;
#line 650
  obj->kind = (AST_kind )143;
#line 651
  obj->location = location___0;
#line 652
  obj->isatomic = (atomic_t )2;
#line 653
  obj->id_label = id_label___0;
#line 655
  return (obj);
}
}
#line 658 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
cast new_cast(region r , location location___0 , expression arg1 , asttype asttype___0 ) 
{ 
  cast obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 660
  if (sizeof(struct AST_cast ) < (unsigned long )(1 << 9)) {
    {
#line 660
    tmp = __rcralloc_small0(r, sizeof(struct AST_cast ));
#line 660
    tmp___1 = tmp;
    }
  } else {
    {
#line 660
    tmp___0 = typed_ralloc(r, sizeof(struct AST_cast ), 0);
#line 660
    tmp___1 = tmp___0;
    }
  }
#line 660
  obj = (cast )tmp___1;
#line 662
  obj->kind = (AST_kind )86;
#line 663
  obj->location = location___0;
#line 664
  obj->isatomic = (atomic_t )2;
#line 665
  obj->arg1 = arg1;
#line 666
  obj->asttype = asttype___0;
#line 668
  return (obj);
}
}
#line 671 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
cast_list new_cast_list(region r , location location___0 , asttype asttype___0 , expression init_expr ) 
{ 
  cast_list obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 673
  if (sizeof(struct AST_cast_list ) < (unsigned long )(1 << 9)) {
    {
#line 673
    tmp = __rcralloc_small0(r, sizeof(struct AST_cast_list ));
#line 673
    tmp___1 = tmp;
    }
  } else {
    {
#line 673
    tmp___0 = typed_ralloc(r, sizeof(struct AST_cast_list ), 0);
#line 673
    tmp___1 = tmp___0;
    }
  }
#line 673
  obj = (cast_list )tmp___1;
#line 675
  obj->kind = (AST_kind )144;
#line 676
  obj->location = location___0;
#line 677
  obj->isatomic = (atomic_t )2;
#line 678
  obj->asttype = asttype___0;
#line 679
  obj->init_expr = init_expr;
#line 681
  return (obj);
}
}
#line 684 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
conditional new_conditional(region r , location location___0 , expression condition ,
                            expression arg1 , expression arg2 ) 
{ 
  conditional obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 686
  if (sizeof(struct AST_conditional ) < (unsigned long )(1 << 9)) {
    {
#line 686
    tmp = __rcralloc_small0(r, sizeof(struct AST_conditional ));
#line 686
    tmp___1 = tmp;
    }
  } else {
    {
#line 686
    tmp___0 = typed_ralloc(r, sizeof(struct AST_conditional ), 0);
#line 686
    tmp___1 = tmp___0;
    }
  }
#line 686
  obj = (conditional )tmp___1;
#line 688
  obj->kind = (AST_kind )145;
#line 689
  obj->location = location___0;
#line 690
  obj->isatomic = (atomic_t )2;
#line 691
  obj->condition = condition;
#line 692
  obj->arg1 = arg1;
#line 693
  obj->arg2 = arg2;
#line 695
  return (obj);
}
}
#line 698 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
identifier new_identifier(region r , location location___0 , cstring cstring___0 ,
                          data_declaration ddecl ) 
{ 
  identifier obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 700
  if (sizeof(struct AST_identifier ) < (unsigned long )(1 << 9)) {
    {
#line 700
    tmp = __rcralloc_small0(r, sizeof(struct AST_identifier ));
#line 700
    tmp___1 = tmp;
    }
  } else {
    {
#line 700
    tmp___0 = typed_ralloc(r, sizeof(struct AST_identifier ), 0);
#line 700
    tmp___1 = tmp___0;
    }
  }
#line 700
  obj = (identifier )tmp___1;
#line 702
  obj->kind = (AST_kind )146;
#line 703
  obj->location = location___0;
#line 704
  obj->isatomic = (atomic_t )2;
#line 705
  obj->cstring = cstring___0;
#line 706
  obj->ddecl = ddecl;
#line 708
  return (obj);
}
}
#line 711 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
compound_expr new_compound_expr(region r , location location___0 , statement stmt ) 
{ 
  compound_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 713
  if (sizeof(struct AST_compound_expr ) < (unsigned long )(1 << 9)) {
    {
#line 713
    tmp = __rcralloc_small0(r, sizeof(struct AST_compound_expr ));
#line 713
    tmp___1 = tmp;
    }
  } else {
    {
#line 713
    tmp___0 = typed_ralloc(r, sizeof(struct AST_compound_expr ), 0);
#line 713
    tmp___1 = tmp___0;
    }
  }
#line 713
  obj = (compound_expr )tmp___1;
#line 715
  obj->kind = (AST_kind )147;
#line 716
  obj->location = location___0;
#line 717
  obj->isatomic = (atomic_t )2;
#line 718
  obj->stmt = stmt;
#line 720
  return (obj);
}
}
#line 723 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
function_call new_function_call(region r , location location___0 , expression arg1 ,
                                expression args , asttype va_arg_call , nesc_call_kind call_kind ) 
{ 
  function_call obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 725
  if (sizeof(struct AST_function_call ) < (unsigned long )(1 << 9)) {
    {
#line 725
    tmp = __rcralloc_small0(r, sizeof(struct AST_function_call ));
#line 725
    tmp___1 = tmp;
    }
  } else {
    {
#line 725
    tmp___0 = typed_ralloc(r, sizeof(struct AST_function_call ), 0);
#line 725
    tmp___1 = tmp___0;
    }
  }
#line 725
  obj = (function_call )tmp___1;
#line 727
  obj->kind = (AST_kind )148;
#line 728
  obj->location = location___0;
#line 729
  obj->isatomic = (atomic_t )2;
#line 730
  obj->arg1 = arg1;
#line 731
  obj->args = args;
#line 732
  obj->va_arg_call = va_arg_call;
#line 733
  obj->call_kind = call_kind;
#line 735
  return (obj);
}
}
#line 738 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
field_ref new_field_ref(region r , location location___0 , expression arg1 , cstring cstring___0 ) 
{ 
  field_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 740
  if (sizeof(struct AST_field_ref ) < (unsigned long )(1 << 9)) {
    {
#line 740
    tmp = __rcralloc_small0(r, sizeof(struct AST_field_ref ));
#line 740
    tmp___1 = tmp;
    }
  } else {
    {
#line 740
    tmp___0 = typed_ralloc(r, sizeof(struct AST_field_ref ), 0);
#line 740
    tmp___1 = tmp___0;
    }
  }
#line 740
  obj = (field_ref )tmp___1;
#line 742
  obj->kind = (AST_kind )87;
#line 743
  obj->location = location___0;
#line 744
  obj->isatomic = (atomic_t )2;
#line 745
  obj->arg1 = arg1;
#line 746
  obj->cstring = cstring___0;
#line 748
  return (obj);
}
}
#line 751 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
increment new_increment(region r , location location___0 , expression arg1 ) 
{ 
  increment obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 753
  if (sizeof(struct AST_increment ) < (unsigned long )(1 << 9)) {
    {
#line 753
    tmp = __rcralloc_small0(r, sizeof(struct AST_increment ));
#line 753
    tmp___1 = tmp;
    }
  } else {
    {
#line 753
    tmp___0 = typed_ralloc(r, sizeof(struct AST_increment ), 0);
#line 753
    tmp___1 = tmp___0;
    }
  }
#line 753
  obj = (increment )tmp___1;
#line 755
  obj->kind = (AST_kind )88;
#line 756
  obj->location = location___0;
#line 757
  obj->isatomic = (atomic_t )2;
#line 758
  obj->arg1 = arg1;
#line 760
  return (obj);
}
}
#line 763 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
comparison new_comparison(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  comparison obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 765
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 765
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 765
    tmp___1 = tmp;
    }
  } else {
    {
#line 765
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 765
    tmp___1 = tmp___0;
    }
  }
#line 765
  obj = (comparison )tmp___1;
#line 767
  obj->kind = (AST_kind )108;
#line 768
  obj->location = location___0;
#line 769
  obj->isatomic = (atomic_t )2;
#line 770
  obj->arg1 = arg1;
#line 771
  obj->arg2 = arg2;
#line 773
  return (obj);
}
}
#line 776 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
assignment new_assignment(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  assignment obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 778
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 778
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 778
    tmp___1 = tmp;
    }
  } else {
    {
#line 778
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 778
    tmp___1 = tmp___0;
    }
  }
#line 778
  obj = (assignment )tmp___1;
#line 780
  obj->kind = (AST_kind )115;
#line 781
  obj->location = location___0;
#line 782
  obj->isatomic = (atomic_t )2;
#line 783
  obj->arg1 = arg1;
#line 784
  obj->arg2 = arg2;
#line 786
  return (obj);
}
}
#line 789 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
init_list new_init_list(region r , location location___0 , expression args ) 
{ 
  init_list obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 791
  if (sizeof(struct AST_init_list ) < (unsigned long )(1 << 9)) {
    {
#line 791
    tmp = __rcralloc_small0(r, sizeof(struct AST_init_list ));
#line 791
    tmp___1 = tmp;
    }
  } else {
    {
#line 791
    tmp___0 = typed_ralloc(r, sizeof(struct AST_init_list ), 0);
#line 791
    tmp___1 = tmp___0;
    }
  }
#line 791
  obj = (init_list )tmp___1;
#line 793
  obj->kind = (AST_kind )149;
#line 794
  obj->location = location___0;
#line 795
  obj->isatomic = (atomic_t )2;
#line 796
  obj->args = args;
#line 798
  return (obj);
}
}
#line 801 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
init_specific new_init_specific(region r , location location___0 , designator designator___0 ,
                                expression init_expr ) 
{ 
  init_specific obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 803
  if (sizeof(struct AST_init_specific ) < (unsigned long )(1 << 9)) {
    {
#line 803
    tmp = __rcralloc_small0(r, sizeof(struct AST_init_specific ));
#line 803
    tmp___1 = tmp;
    }
  } else {
    {
#line 803
    tmp___0 = typed_ralloc(r, sizeof(struct AST_init_specific ), 0);
#line 803
    tmp___1 = tmp___0;
    }
  }
#line 803
  obj = (init_specific )tmp___1;
#line 805
  obj->kind = (AST_kind )150;
#line 806
  obj->location = location___0;
#line 807
  obj->isatomic = (atomic_t )2;
#line 808
  obj->designator = designator___0;
#line 809
  obj->init_expr = init_expr;
#line 811
  return (obj);
}
}
#line 814 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
designator new_designator(region r , location location___0 ) 
{ 
  designator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 816
  if (sizeof(struct AST_designator ) < (unsigned long )(1 << 9)) {
    {
#line 816
    tmp = __rcralloc_small0(r, sizeof(struct AST_designator ));
#line 816
    tmp___1 = tmp;
    }
  } else {
    {
#line 816
    tmp___0 = typed_ralloc(r, sizeof(struct AST_designator ), 0);
#line 816
    tmp___1 = tmp___0;
    }
  }
#line 816
  obj = (designator )tmp___1;
#line 818
  obj->kind = (AST_kind )189;
#line 819
  obj->location = location___0;
#line 821
  return (obj);
}
}
#line 824 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
designate_field new_designate_field(region r , location location___0 , cstring cstring___0 ) 
{ 
  designate_field obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 826
  if (sizeof(struct AST_designate_field ) < (unsigned long )(1 << 9)) {
    {
#line 826
    tmp = __rcralloc_small0(r, sizeof(struct AST_designate_field ));
#line 826
    tmp___1 = tmp;
    }
  } else {
    {
#line 826
    tmp___0 = typed_ralloc(r, sizeof(struct AST_designate_field ), 0);
#line 826
    tmp___1 = tmp___0;
    }
  }
#line 826
  obj = (designate_field )tmp___1;
#line 828
  obj->kind = (AST_kind )190;
#line 829
  obj->location = location___0;
#line 830
  obj->cstring = cstring___0;
#line 832
  return (obj);
}
}
#line 835 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
designate_index new_designate_index(region r , location location___0 , expression arg1 ,
                                    expression arg2 ) 
{ 
  designate_index obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 837
  if (sizeof(struct AST_designate_index ) < (unsigned long )(1 << 9)) {
    {
#line 837
    tmp = __rcralloc_small0(r, sizeof(struct AST_designate_index ));
#line 837
    tmp___1 = tmp;
    }
  } else {
    {
#line 837
    tmp___0 = typed_ralloc(r, sizeof(struct AST_designate_index ), 0);
#line 837
    tmp___1 = tmp___0;
    }
  }
#line 837
  obj = (designate_index )tmp___1;
#line 839
  obj->kind = (AST_kind )191;
#line 840
  obj->location = location___0;
#line 841
  obj->arg1 = arg1;
#line 842
  obj->arg2 = arg2;
#line 844
  return (obj);
}
}
#line 847 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
lexical_cst new_lexical_cst(region r , location location___0 , cstring cstring___0 ) 
{ 
  lexical_cst obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 849
  if (sizeof(struct AST_lexical_cst ) < (unsigned long )(1 << 9)) {
    {
#line 849
    tmp = __rcralloc_small0(r, sizeof(struct AST_lexical_cst ));
#line 849
    tmp___1 = tmp;
    }
  } else {
    {
#line 849
    tmp___0 = typed_ralloc(r, sizeof(struct AST_lexical_cst ), 0);
#line 849
    tmp___1 = tmp___0;
    }
  }
#line 849
  obj = (lexical_cst )tmp___1;
#line 851
  obj->kind = (AST_kind )151;
#line 852
  obj->location = location___0;
#line 853
  obj->isatomic = (atomic_t )2;
#line 854
  obj->cstring = cstring___0;
#line 856
  return (obj);
}
}
#line 859 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
string_cst new_string_cst(region r , location location___0 , cstring cstring___0 ) 
{ 
  string_cst obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 861
  if (sizeof(struct AST_string_cst ) < (unsigned long )(1 << 9)) {
    {
#line 861
    tmp = __rcralloc_small0(r, sizeof(struct AST_string_cst ));
#line 861
    tmp___1 = tmp;
    }
  } else {
    {
#line 861
    tmp___0 = typed_ralloc(r, sizeof(struct AST_string_cst ), 0);
#line 861
    tmp___1 = tmp___0;
    }
  }
#line 861
  obj = (string_cst )tmp___1;
#line 863
  obj->kind = (AST_kind )152;
#line 864
  obj->location = location___0;
#line 865
  obj->isatomic = (atomic_t )2;
#line 866
  obj->cstring = cstring___0;
#line 868
  return (obj);
}
}
#line 871 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
string new_string(region r , location location___0 , string_cst strings , data_declaration ddecl ) 
{ 
  string obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 873
  if (sizeof(struct AST_string ) < (unsigned long )(1 << 9)) {
    {
#line 873
    tmp = __rcralloc_small0(r, sizeof(struct AST_string ));
#line 873
    tmp___1 = tmp;
    }
  } else {
    {
#line 873
    tmp___0 = typed_ralloc(r, sizeof(struct AST_string ), 0);
#line 873
    tmp___1 = tmp___0;
    }
  }
#line 873
  obj = (string )tmp___1;
#line 875
  obj->kind = (AST_kind )153;
#line 876
  obj->location = location___0;
#line 877
  obj->isatomic = (atomic_t )2;
#line 878
  obj->strings = strings;
#line 879
  obj->ddecl = ddecl;
#line 881
  return (obj);
}
}
#line 884 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
id_label new_id_label(region r , location location___0 , cstring cstring___0 ) 
{ 
  id_label obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 886
  if (sizeof(struct AST_id_label ) < (unsigned long )(1 << 9)) {
    {
#line 886
    tmp = __rcralloc_small0(r, sizeof(struct AST_id_label ));
#line 886
    tmp___1 = tmp;
    }
  } else {
    {
#line 886
    tmp___0 = typed_ralloc(r, sizeof(struct AST_id_label ), 0);
#line 886
    tmp___1 = tmp___0;
    }
  }
#line 886
  obj = (id_label )tmp___1;
#line 888
  obj->kind = (AST_kind )185;
#line 889
  obj->location = location___0;
#line 890
  obj->cstring = cstring___0;
#line 892
  return (obj);
}
}
#line 895 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
case_label new_case_label(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  case_label obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 897
  if (sizeof(struct AST_case_label ) < (unsigned long )(1 << 9)) {
    {
#line 897
    tmp = __rcralloc_small0(r, sizeof(struct AST_case_label ));
#line 897
    tmp___1 = tmp;
    }
  } else {
    {
#line 897
    tmp___0 = typed_ralloc(r, sizeof(struct AST_case_label ), 0);
#line 897
    tmp___1 = tmp___0;
    }
  }
#line 897
  obj = (case_label )tmp___1;
#line 899
  obj->kind = (AST_kind )186;
#line 900
  obj->location = location___0;
#line 901
  obj->arg1 = arg1;
#line 902
  obj->arg2 = arg2;
#line 904
  return (obj);
}
}
#line 907 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
default_label new_default_label(region r , location location___0 ) 
{ 
  default_label obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 909
  if (sizeof(struct AST_default_label ) < (unsigned long )(1 << 9)) {
    {
#line 909
    tmp = __rcralloc_small0(r, sizeof(struct AST_default_label ));
#line 909
    tmp___1 = tmp;
    }
  } else {
    {
#line 909
    tmp___0 = typed_ralloc(r, sizeof(struct AST_default_label ), 0);
#line 909
    tmp___1 = tmp___0;
    }
  }
#line 909
  obj = (default_label )tmp___1;
#line 911
  obj->kind = (AST_kind )187;
#line 912
  obj->location = location___0;
#line 914
  return (obj);
}
}
#line 917 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
word new_word(region r , location location___0 , cstring cstring___0 ) 
{ 
  word obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 919
  if (sizeof(struct AST_word ) < (unsigned long )(1 << 9)) {
    {
#line 919
    tmp = __rcralloc_small0(r, sizeof(struct AST_word ));
#line 919
    tmp___1 = tmp;
    }
  } else {
    {
#line 919
    tmp___0 = typed_ralloc(r, sizeof(struct AST_word ), 0);
#line 919
    tmp___1 = tmp___0;
    }
  }
#line 919
  obj = (word )tmp___1;
#line 921
  obj->kind = (AST_kind )192;
#line 922
  obj->location = location___0;
#line 923
  obj->cstring = cstring___0;
#line 925
  return (obj);
}
}
#line 928 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
asm_operand new_asm_operand(region r , location location___0 , word word1 , string string___0 ,
                            expression arg1 ) 
{ 
  asm_operand obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 930
  if (sizeof(struct AST_asm_operand ) < (unsigned long )(1 << 9)) {
    {
#line 930
    tmp = __rcralloc_small0(r, sizeof(struct AST_asm_operand ));
#line 930
    tmp___1 = tmp;
    }
  } else {
    {
#line 930
    tmp___0 = typed_ralloc(r, sizeof(struct AST_asm_operand ), 0);
#line 930
    tmp___1 = tmp___0;
    }
  }
#line 930
  obj = (asm_operand )tmp___1;
#line 932
  obj->kind = (AST_kind )193;
#line 933
  obj->location = location___0;
#line 934
  obj->word1 = word1;
#line 935
  obj->string = string___0;
#line 936
  obj->arg1 = arg1;
#line 938
  return (obj);
}
}
#line 941 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
nesc_decl new_nesc_decl(region r , location location___0 , word word1 , attribute attributes ) 
{ 
  nesc_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 943
  if (sizeof(struct AST_nesc_decl ) < (unsigned long )(1 << 9)) {
    {
#line 943
    tmp = __rcralloc_small0(r, sizeof(struct AST_nesc_decl ));
#line 943
    tmp___1 = tmp;
    }
  } else {
    {
#line 943
    tmp___0 = typed_ralloc(r, sizeof(struct AST_nesc_decl ), 0);
#line 943
    tmp___1 = tmp___0;
    }
  }
#line 943
  obj = (nesc_decl )tmp___1;
#line 945
  obj->kind = (AST_kind )54;
#line 946
  obj->location = location___0;
#line 947
  obj->word1 = word1;
#line 948
  obj->attributes = attributes;
#line 950
  return (obj);
}
}
#line 953 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
interface new_interface(region r , location location___0 , word word1 , attribute attributes ,
                        declaration decls ) 
{ 
  interface obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 955
  if (sizeof(struct AST_interface ) < (unsigned long )(1 << 9)) {
    {
#line 955
    tmp = __rcralloc_small0(r, sizeof(struct AST_interface ));
#line 955
    tmp___1 = tmp;
    }
  } else {
    {
#line 955
    tmp___0 = typed_ralloc(r, sizeof(struct AST_interface ), 0);
#line 955
    tmp___1 = tmp___0;
    }
  }
#line 955
  obj = (interface )tmp___1;
#line 957
  obj->kind = (AST_kind )55;
#line 958
  obj->location = location___0;
#line 959
  obj->word1 = word1;
#line 960
  obj->attributes = attributes;
#line 961
  obj->decls = decls;
#line 963
  return (obj);
}
}
#line 966 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
component new_component(region r , location location___0 , word word1 , attribute attributes ,
                        bool abstract , declaration parms , declaration decls , implementation implementation___0 ) 
{ 
  component obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 968
  if (sizeof(struct AST_component ) < (unsigned long )(1 << 9)) {
    {
#line 968
    tmp = __rcralloc_small0(r, sizeof(struct AST_component ));
#line 968
    tmp___1 = tmp;
    }
  } else {
    {
#line 968
    tmp___0 = typed_ralloc(r, sizeof(struct AST_component ), 0);
#line 968
    tmp___1 = tmp___0;
    }
  }
#line 968
  obj = (component )tmp___1;
#line 970
  obj->kind = (AST_kind )56;
#line 971
  obj->location = location___0;
#line 972
  obj->word1 = word1;
#line 973
  obj->attributes = attributes;
#line 974
  obj->abstract = abstract;
#line 975
  obj->parms = parms;
#line 976
  obj->decls = decls;
#line 977
  obj->implementation = implementation___0;
#line 979
  return (obj);
}
}
#line 982 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
implementation new_implementation(region r , location location___0 , environment ienv ) 
{ 
  implementation obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 984
  if (sizeof(struct AST_implementation ) < (unsigned long )(1 << 9)) {
    {
#line 984
    tmp = __rcralloc_small0(r, sizeof(struct AST_implementation ));
#line 984
    tmp___1 = tmp;
    }
  } else {
    {
#line 984
    tmp___0 = typed_ralloc(r, sizeof(struct AST_implementation ), 0);
#line 984
    tmp___1 = tmp___0;
    }
  }
#line 984
  obj = (implementation )tmp___1;
#line 986
  obj->kind = (AST_kind )194;
#line 987
  obj->location = location___0;
#line 988
  obj->ienv = ienv;
#line 990
  return (obj);
}
}
#line 993 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
configuration new_configuration(region r , location location___0 , environment ienv ,
                                declaration decls ) 
{ 
  configuration obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 995
  if (sizeof(struct AST_configuration ) < (unsigned long )(1 << 9)) {
    {
#line 995
    tmp = __rcralloc_small0(r, sizeof(struct AST_configuration ));
#line 995
    tmp___1 = tmp;
    }
  } else {
    {
#line 995
    tmp___0 = typed_ralloc(r, sizeof(struct AST_configuration ), 0);
#line 995
    tmp___1 = tmp___0;
    }
  }
#line 995
  obj = (configuration )tmp___1;
#line 997
  obj->kind = (AST_kind )195;
#line 998
  obj->location = location___0;
#line 999
  obj->ienv = ienv;
#line 1000
  obj->decls = decls;
#line 1002
  return (obj);
}
}
#line 1005 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
module new_module(region r , location location___0 , environment ienv , declaration decls ) 
{ 
  module obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1007
  if (sizeof(struct AST_module ) < (unsigned long )(1 << 9)) {
    {
#line 1007
    tmp = __rcralloc_small0(r, sizeof(struct AST_module ));
#line 1007
    tmp___1 = tmp;
    }
  } else {
    {
#line 1007
    tmp___0 = typed_ralloc(r, sizeof(struct AST_module ), 0);
#line 1007
    tmp___1 = tmp___0;
    }
  }
#line 1007
  obj = (module )tmp___1;
#line 1009
  obj->kind = (AST_kind )196;
#line 1010
  obj->location = location___0;
#line 1011
  obj->ienv = ienv;
#line 1012
  obj->decls = decls;
#line 1014
  return (obj);
}
}
#line 1017 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
binary_component new_binary_component(region r , location location___0 , environment ienv ) 
{ 
  binary_component obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1019
  if (sizeof(struct AST_binary_component ) < (unsigned long )(1 << 9)) {
    {
#line 1019
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary_component ));
#line 1019
    tmp___1 = tmp;
    }
  } else {
    {
#line 1019
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary_component ), 0);
#line 1019
    tmp___1 = tmp___0;
    }
  }
#line 1019
  obj = (binary_component )tmp___1;
#line 1021
  obj->kind = (AST_kind )197;
#line 1022
  obj->location = location___0;
#line 1023
  obj->ienv = ienv;
#line 1025
  return (obj);
}
}
#line 1028 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
rp_interface new_rp_interface(region r , location location___0 , bool required , declaration decls ) 
{ 
  rp_interface obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1030
  if (sizeof(struct AST_rp_interface ) < (unsigned long )(1 << 9)) {
    {
#line 1030
    tmp = __rcralloc_small0(r, sizeof(struct AST_rp_interface ));
#line 1030
    tmp___1 = tmp;
    }
  } else {
    {
#line 1030
    tmp___0 = typed_ralloc(r, sizeof(struct AST_rp_interface ), 0);
#line 1030
    tmp___1 = tmp___0;
    }
  }
#line 1030
  obj = (rp_interface )tmp___1;
#line 1032
  obj->kind = (AST_kind )57;
#line 1033
  obj->location = location___0;
#line 1034
  obj->required = required;
#line 1035
  obj->decls = decls;
#line 1037
  return (obj);
}
}
#line 1040 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
interface_ref new_interface_ref(region r , location location___0 , word word1 , expression args ,
                                word word2 , declaration gparms , attribute attributes ,
                                data_declaration ddecl ) 
{ 
  interface_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1042
  if (sizeof(struct AST_interface_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1042
    tmp = __rcralloc_small0(r, sizeof(struct AST_interface_ref ));
#line 1042
    tmp___1 = tmp;
    }
  } else {
    {
#line 1042
    tmp___0 = typed_ralloc(r, sizeof(struct AST_interface_ref ), 0);
#line 1042
    tmp___1 = tmp___0;
    }
  }
#line 1042
  obj = (interface_ref )tmp___1;
#line 1044
  obj->kind = (AST_kind )58;
#line 1045
  obj->location = location___0;
#line 1046
  obj->word1 = word1;
#line 1047
  obj->args = args;
#line 1048
  obj->word2 = word2;
#line 1049
  obj->gparms = gparms;
#line 1050
  obj->attributes = attributes;
#line 1051
  obj->ddecl = ddecl;
#line 1053
  return (obj);
}
}
#line 1056 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
component_ref new_component_ref(region r , location location___0 , word word1 , word word2 ,
                                bool abstract , expression args ) 
{ 
  component_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1058
  if (sizeof(struct AST_component_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1058
    tmp = __rcralloc_small0(r, sizeof(struct AST_component_ref ));
#line 1058
    tmp___1 = tmp;
    }
  } else {
    {
#line 1058
    tmp___0 = typed_ralloc(r, sizeof(struct AST_component_ref ), 0);
#line 1058
    tmp___1 = tmp___0;
    }
  }
#line 1058
  obj = (component_ref )tmp___1;
#line 1060
  obj->kind = (AST_kind )59;
#line 1061
  obj->location = location___0;
#line 1062
  obj->word1 = word1;
#line 1063
  obj->word2 = word2;
#line 1064
  obj->abstract = abstract;
#line 1065
  obj->args = args;
#line 1067
  return (obj);
}
}
#line 1070 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
connection new_connection(region r , location location___0 , endpoint ep1 , endpoint ep2 ) 
{ 
  connection obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1072
  if (sizeof(struct AST_connection ) < (unsigned long )(1 << 9)) {
    {
#line 1072
    tmp = __rcralloc_small0(r, sizeof(struct AST_connection ));
#line 1072
    tmp___1 = tmp;
    }
  } else {
    {
#line 1072
    tmp___0 = typed_ralloc(r, sizeof(struct AST_connection ), 0);
#line 1072
    tmp___1 = tmp___0;
    }
  }
#line 1072
  obj = (connection )tmp___1;
#line 1074
  obj->kind = (AST_kind )60;
#line 1075
  obj->location = location___0;
#line 1076
  obj->ep1 = ep1;
#line 1077
  obj->ep2 = ep2;
#line 1079
  return (obj);
}
}
#line 1082 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
endpoint new_endpoint(region r , location location___0 , parameterised_identifier ids ) 
{ 
  endpoint obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1084
  if (sizeof(struct AST_endpoint ) < (unsigned long )(1 << 9)) {
    {
#line 1084
    tmp = __rcralloc_small0(r, sizeof(struct AST_endpoint ));
#line 1084
    tmp___1 = tmp;
    }
  } else {
    {
#line 1084
    tmp___0 = typed_ralloc(r, sizeof(struct AST_endpoint ), 0);
#line 1084
    tmp___1 = tmp___0;
    }
  }
#line 1084
  obj = (endpoint )tmp___1;
#line 1086
  obj->kind = (AST_kind )198;
#line 1087
  obj->location = location___0;
#line 1088
  obj->ids = ids;
#line 1090
  return (obj);
}
}
#line 1093 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
parameterised_identifier new_parameterised_identifier(region r , location location___0 ,
                                                      word word1 , expression args ) 
{ 
  parameterised_identifier obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1095
  if (sizeof(struct AST_parameterised_identifier ) < (unsigned long )(1 << 9)) {
    {
#line 1095
    tmp = __rcralloc_small0(r, sizeof(struct AST_parameterised_identifier ));
#line 1095
    tmp___1 = tmp;
    }
  } else {
    {
#line 1095
    tmp___0 = typed_ralloc(r, sizeof(struct AST_parameterised_identifier ), 0);
#line 1095
    tmp___1 = tmp___0;
    }
  }
#line 1095
  obj = (parameterised_identifier )tmp___1;
#line 1097
  obj->kind = (AST_kind )199;
#line 1098
  obj->location = location___0;
#line 1099
  obj->word1 = word1;
#line 1100
  obj->args = args;
#line 1102
  return (obj);
}
}
#line 1105 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
generic_declarator new_generic_declarator(region r , location location___0 , declarator declarator___0 ,
                                          declaration parms ) 
{ 
  generic_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1107
  if (sizeof(struct AST_generic_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 1107
    tmp = __rcralloc_small0(r, sizeof(struct AST_generic_declarator ));
#line 1107
    tmp___1 = tmp;
    }
  } else {
    {
#line 1107
    tmp___0 = typed_ralloc(r, sizeof(struct AST_generic_declarator ), 0);
#line 1107
    tmp___1 = tmp___0;
    }
  }
#line 1107
  obj = (generic_declarator )tmp___1;
#line 1109
  obj->kind = (AST_kind )183;
#line 1110
  obj->location = location___0;
#line 1111
  obj->declarator = declarator___0;
#line 1112
  obj->parms = parms;
#line 1114
  return (obj);
}
}
#line 1117 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
generic_call new_generic_call(region r , location location___0 , expression arg1 ,
                              expression args ) 
{ 
  generic_call obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1119
  if (sizeof(struct AST_generic_call ) < (unsigned long )(1 << 9)) {
    {
#line 1119
    tmp = __rcralloc_small0(r, sizeof(struct AST_generic_call ));
#line 1119
    tmp___1 = tmp;
    }
  } else {
    {
#line 1119
    tmp___0 = typed_ralloc(r, sizeof(struct AST_generic_call ), 0);
#line 1119
    tmp___1 = tmp___0;
    }
  }
#line 1119
  obj = (generic_call )tmp___1;
#line 1121
  obj->kind = (AST_kind )154;
#line 1122
  obj->location = location___0;
#line 1123
  obj->isatomic = (atomic_t )2;
#line 1124
  obj->arg1 = arg1;
#line 1125
  obj->args = args;
#line 1127
  return (obj);
}
}
#line 1130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
interface_ref_declarator new_interface_ref_declarator(region r , location location___0 ,
                                                      declarator declarator___0 ,
                                                      word word1 ) 
{ 
  interface_ref_declarator obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1132
  if (sizeof(struct AST_interface_ref_declarator ) < (unsigned long )(1 << 9)) {
    {
#line 1132
    tmp = __rcralloc_small0(r, sizeof(struct AST_interface_ref_declarator ));
#line 1132
    tmp___1 = tmp;
    }
  } else {
    {
#line 1132
    tmp___0 = typed_ralloc(r, sizeof(struct AST_interface_ref_declarator ), 0);
#line 1132
    tmp___1 = tmp___0;
    }
  }
#line 1132
  obj = (interface_ref_declarator )tmp___1;
#line 1134
  obj->kind = (AST_kind )181;
#line 1135
  obj->location = location___0;
#line 1136
  obj->declarator = declarator___0;
#line 1137
  obj->word1 = word1;
#line 1139
  return (obj);
}
}
#line 1142 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
interface_deref new_interface_deref(region r , location location___0 , expression arg1 ,
                                    cstring cstring___0 , data_declaration ddecl ) 
{ 
  interface_deref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1144
  if (sizeof(struct AST_interface_deref ) < (unsigned long )(1 << 9)) {
    {
#line 1144
    tmp = __rcralloc_small0(r, sizeof(struct AST_interface_deref ));
#line 1144
    tmp___1 = tmp;
    }
  } else {
    {
#line 1144
    tmp___0 = typed_ralloc(r, sizeof(struct AST_interface_deref ), 0);
#line 1144
    tmp___1 = tmp___0;
    }
  }
#line 1144
  obj = (interface_deref )tmp___1;
#line 1146
  obj->kind = (AST_kind )93;
#line 1147
  obj->location = location___0;
#line 1148
  obj->isatomic = (atomic_t )2;
#line 1149
  obj->arg1 = arg1;
#line 1150
  obj->cstring = cstring___0;
#line 1151
  obj->ddecl = ddecl;
#line 1153
  return (obj);
}
}
#line 1156 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
component_deref new_component_deref(region r , location location___0 , expression arg1 ,
                                    cstring cstring___0 , data_declaration ddecl ) 
{ 
  component_deref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1158
  if (sizeof(struct AST_component_deref ) < (unsigned long )(1 << 9)) {
    {
#line 1158
    tmp = __rcralloc_small0(r, sizeof(struct AST_component_deref ));
#line 1158
    tmp___1 = tmp;
    }
  } else {
    {
#line 1158
    tmp___0 = typed_ralloc(r, sizeof(struct AST_component_deref ), 0);
#line 1158
    tmp___1 = tmp___0;
    }
  }
#line 1158
  obj = (component_deref )tmp___1;
#line 1160
  obj->kind = (AST_kind )94;
#line 1161
  obj->location = location___0;
#line 1162
  obj->isatomic = (atomic_t )2;
#line 1163
  obj->arg1 = arg1;
#line 1164
  obj->cstring = cstring___0;
#line 1165
  obj->ddecl = ddecl;
#line 1167
  return (obj);
}
}
#line 1170 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
component_typeref new_component_typeref(region r , location location___0 , data_declaration ddecl ,
                                        cstring cstring___0 ) 
{ 
  component_typeref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1172
  if (sizeof(struct AST_component_typeref ) < (unsigned long )(1 << 9)) {
    {
#line 1172
    tmp = __rcralloc_small0(r, sizeof(struct AST_component_typeref ));
#line 1172
    tmp___1 = tmp;
    }
  } else {
    {
#line 1172
    tmp___0 = typed_ralloc(r, sizeof(struct AST_component_typeref ), 0);
#line 1172
    tmp___1 = tmp___0;
    }
  }
#line 1172
  obj = (component_typeref )tmp___1;
#line 1174
  obj->kind = (AST_kind )159;
#line 1175
  obj->location = location___0;
#line 1176
  obj->ddecl = ddecl;
#line 1177
  obj->cstring = cstring___0;
#line 1179
  return (obj);
}
}
#line 1182 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
atomic_stmt new_atomic_stmt(region r , location location___0 , statement stmt ) 
{ 
  atomic_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1184
  if (sizeof(struct AST_atomic_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 1184
    tmp = __rcralloc_small0(r, sizeof(struct AST_atomic_stmt ));
#line 1184
    tmp___1 = tmp;
    }
  } else {
    {
#line 1184
    tmp___0 = typed_ralloc(r, sizeof(struct AST_atomic_stmt ), 0);
#line 1184
    tmp___1 = tmp___0;
    }
  }
#line 1184
  obj = (atomic_stmt )tmp___1;
#line 1186
  obj->kind = (AST_kind )82;
#line 1187
  obj->location = location___0;
#line 1188
  obj->isatomic = (atomic_t )2;
#line 1189
  obj->stmt = stmt;
#line 1191
  return (obj);
}
}
#line 1194 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
nesc_attribute new_nesc_attribute(region r , location location___0 , word word1 ,
                                  expression arg1 ) 
{ 
  nesc_attribute obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1196
  if (sizeof(struct AST_nesc_attribute ) < (unsigned long )(1 << 9)) {
    {
#line 1196
    tmp = __rcralloc_small0(r, sizeof(struct AST_nesc_attribute ));
#line 1196
    tmp___1 = tmp;
    }
  } else {
    {
#line 1196
    tmp___0 = typed_ralloc(r, sizeof(struct AST_nesc_attribute ), 0);
#line 1196
    tmp___1 = tmp___0;
    }
  }
#line 1196
  obj = (nesc_attribute )tmp___1;
#line 1198
  obj->kind = (AST_kind )165;
#line 1199
  obj->location = location___0;
#line 1200
  obj->word1 = word1;
#line 1201
  obj->arg1 = arg1;
#line 1203
  return (obj);
}
}
#line 1206 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
type_parm_decl new_type_parm_decl(region r , location location___0 , cstring cstring___0 ,
                                  data_declaration ddecl ) 
{ 
  type_parm_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1208
  if (sizeof(struct AST_type_parm_decl ) < (unsigned long )(1 << 9)) {
    {
#line 1208
    tmp = __rcralloc_small0(r, sizeof(struct AST_type_parm_decl ));
#line 1208
    tmp___1 = tmp;
    }
  } else {
    {
#line 1208
    tmp___0 = typed_ralloc(r, sizeof(struct AST_type_parm_decl ), 0);
#line 1208
    tmp___1 = tmp___0;
    }
  }
#line 1208
  obj = (type_parm_decl )tmp___1;
#line 1210
  obj->kind = (AST_kind )63;
#line 1211
  obj->location = location___0;
#line 1212
  obj->cstring = cstring___0;
#line 1213
  obj->ddecl = ddecl;
#line 1215
  return (obj);
}
}
#line 1218 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
type_argument new_type_argument(region r , location location___0 , asttype asttype___0 ) 
{ 
  type_argument obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1220
  if (sizeof(struct AST_type_argument ) < (unsigned long )(1 << 9)) {
    {
#line 1220
    tmp = __rcralloc_small0(r, sizeof(struct AST_type_argument ));
#line 1220
    tmp___1 = tmp;
    }
  } else {
    {
#line 1220
    tmp___0 = typed_ralloc(r, sizeof(struct AST_type_argument ), 0);
#line 1220
    tmp___1 = tmp___0;
    }
  }
#line 1220
  obj = (type_argument )tmp___1;
#line 1222
  obj->kind = (AST_kind )155;
#line 1223
  obj->location = location___0;
#line 1224
  obj->isatomic = (atomic_t )2;
#line 1225
  obj->asttype = asttype___0;
#line 1227
  return (obj);
}
}
#line 1230 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
error_decl new_error_decl(region r , location location___0 ) 
{ 
  error_decl obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1232
  if (sizeof(struct AST_declaration ) < (unsigned long )(1 << 9)) {
    {
#line 1232
    tmp = __rcralloc_small0(r, sizeof(struct AST_declaration ));
#line 1232
    tmp___1 = tmp;
    }
  } else {
    {
#line 1232
    tmp___0 = typed_ralloc(r, sizeof(struct AST_declaration ), 0);
#line 1232
    tmp___1 = tmp___0;
    }
  }
#line 1232
  obj = (error_decl )tmp___1;
#line 1234
  obj->kind = (AST_kind )64;
#line 1235
  obj->location = location___0;
#line 1237
  return (obj);
}
}
#line 1240 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
attribute_ref new_attribute_ref(region r , location location___0 , word word1 , attribute attributes ,
                                declaration fields , bool defined ) 
{ 
  attribute_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1242
  if (sizeof(struct AST_tag_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1242
    tmp = __rcralloc_small0(r, sizeof(struct AST_tag_ref ));
#line 1242
    tmp___1 = tmp;
    }
  } else {
    {
#line 1242
    tmp___0 = typed_ralloc(r, sizeof(struct AST_tag_ref ), 0);
#line 1242
    tmp___1 = tmp___0;
    }
  }
#line 1242
  obj = (attribute_ref )tmp___1;
#line 1244
  obj->kind = (AST_kind )173;
#line 1245
  obj->location = location___0;
#line 1246
  obj->word1 = word1;
#line 1247
  obj->attributes = attributes;
#line 1248
  obj->fields = fields;
#line 1249
  obj->defined = defined;
#line 1251
  return (obj);
}
}
#line 1254 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
enum_ref new_enum_ref(region r , location location___0 , word word1 , attribute attributes ,
                      declaration fields , bool defined ) 
{ 
  enum_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1256
  if (sizeof(struct AST_tag_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1256
    tmp = __rcralloc_small0(r, sizeof(struct AST_tag_ref ));
#line 1256
    tmp___1 = tmp;
    }
  } else {
    {
#line 1256
    tmp___0 = typed_ralloc(r, sizeof(struct AST_tag_ref ), 0);
#line 1256
    tmp___1 = tmp___0;
    }
  }
#line 1256
  obj = (enum_ref )tmp___1;
#line 1258
  obj->kind = (AST_kind )174;
#line 1259
  obj->location = location___0;
#line 1260
  obj->word1 = word1;
#line 1261
  obj->attributes = attributes;
#line 1262
  obj->fields = fields;
#line 1263
  obj->defined = defined;
#line 1265
  return (obj);
}
}
#line 1268 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
error_stmt new_error_stmt(region r , location location___0 ) 
{ 
  error_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1270
  if (sizeof(struct AST_statement ) < (unsigned long )(1 << 9)) {
    {
#line 1270
    tmp = __rcralloc_small0(r, sizeof(struct AST_statement ));
#line 1270
    tmp___1 = tmp;
    }
  } else {
    {
#line 1270
    tmp___0 = typed_ralloc(r, sizeof(struct AST_statement ), 0);
#line 1270
    tmp___1 = tmp___0;
    }
  }
#line 1270
  obj = (error_stmt )tmp___1;
#line 1272
  obj->kind = (AST_kind )83;
#line 1273
  obj->location = location___0;
#line 1274
  obj->isatomic = (atomic_t )2;
#line 1276
  return (obj);
}
}
#line 1279 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
while_stmt new_while_stmt(region r , location location___0 , expression condition ,
                          statement stmt ) 
{ 
  while_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1281
  if (sizeof(struct AST_conditional_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 1281
    tmp = __rcralloc_small0(r, sizeof(struct AST_conditional_stmt ));
#line 1281
    tmp___1 = tmp;
    }
  } else {
    {
#line 1281
    tmp___0 = typed_ralloc(r, sizeof(struct AST_conditional_stmt ), 0);
#line 1281
    tmp___1 = tmp___0;
    }
  }
#line 1281
  obj = (while_stmt )tmp___1;
#line 1283
  obj->kind = (AST_kind )73;
#line 1284
  obj->location = location___0;
#line 1285
  obj->isatomic = (atomic_t )2;
#line 1286
  obj->condition = condition;
#line 1287
  obj->stmt = stmt;
#line 1289
  return (obj);
}
}
#line 1292 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
dowhile_stmt new_dowhile_stmt(region r , location location___0 , expression condition ,
                              statement stmt ) 
{ 
  dowhile_stmt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1294
  if (sizeof(struct AST_conditional_stmt ) < (unsigned long )(1 << 9)) {
    {
#line 1294
    tmp = __rcralloc_small0(r, sizeof(struct AST_conditional_stmt ));
#line 1294
    tmp___1 = tmp;
    }
  } else {
    {
#line 1294
    tmp___0 = typed_ralloc(r, sizeof(struct AST_conditional_stmt ), 0);
#line 1294
    tmp___1 = tmp___0;
    }
  }
#line 1294
  obj = (dowhile_stmt )tmp___1;
#line 1296
  obj->kind = (AST_kind )74;
#line 1297
  obj->location = location___0;
#line 1298
  obj->isatomic = (atomic_t )2;
#line 1299
  obj->condition = condition;
#line 1300
  obj->stmt = stmt;
#line 1302
  return (obj);
}
}
#line 1305 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
error_expr new_error_expr(region r , location location___0 ) 
{ 
  error_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1307
  if (sizeof(struct AST_expression ) < (unsigned long )(1 << 9)) {
    {
#line 1307
    tmp = __rcralloc_small0(r, sizeof(struct AST_expression ));
#line 1307
    tmp___1 = tmp;
    }
  } else {
    {
#line 1307
    tmp___0 = typed_ralloc(r, sizeof(struct AST_expression ), 0);
#line 1307
    tmp___1 = tmp___0;
    }
  }
#line 1307
  obj = (error_expr )tmp___1;
#line 1309
  obj->kind = (AST_kind )156;
#line 1310
  obj->location = location___0;
#line 1311
  obj->isatomic = (atomic_t )2;
#line 1313
  return (obj);
}
}
#line 1316 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
array_ref new_array_ref(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  array_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1318
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1318
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1318
    tmp___1 = tmp;
    }
  } else {
    {
#line 1318
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1318
    tmp___1 = tmp___0;
    }
  }
#line 1318
  obj = (array_ref )tmp___1;
#line 1320
  obj->kind = (AST_kind )127;
#line 1321
  obj->location = location___0;
#line 1322
  obj->isatomic = (atomic_t )2;
#line 1323
  obj->arg1 = arg1;
#line 1324
  obj->arg2 = arg2;
#line 1326
  return (obj);
}
}
#line 1329 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
dereference new_dereference(region r , location location___0 , expression arg1 ) 
{ 
  dereference obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1331
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1331
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1331
    tmp___1 = tmp;
    }
  } else {
    {
#line 1331
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1331
    tmp___1 = tmp___0;
    }
  }
#line 1331
  obj = (dereference )tmp___1;
#line 1333
  obj->kind = (AST_kind )95;
#line 1334
  obj->location = location___0;
#line 1335
  obj->isatomic = (atomic_t )2;
#line 1336
  obj->arg1 = arg1;
#line 1338
  return (obj);
}
}
#line 1341 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
extension_expr new_extension_expr(region r , location location___0 , expression arg1 ) 
{ 
  extension_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1343
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1343
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1343
    tmp___1 = tmp;
    }
  } else {
    {
#line 1343
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1343
    tmp___1 = tmp___0;
    }
  }
#line 1343
  obj = (extension_expr )tmp___1;
#line 1345
  obj->kind = (AST_kind )96;
#line 1346
  obj->location = location___0;
#line 1347
  obj->isatomic = (atomic_t )2;
#line 1348
  obj->arg1 = arg1;
#line 1350
  return (obj);
}
}
#line 1353 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
sizeof_expr new_sizeof_expr(region r , location location___0 , expression arg1 ) 
{ 
  sizeof_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1355
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1355
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1355
    tmp___1 = tmp;
    }
  } else {
    {
#line 1355
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1355
    tmp___1 = tmp___0;
    }
  }
#line 1355
  obj = (sizeof_expr )tmp___1;
#line 1357
  obj->kind = (AST_kind )97;
#line 1358
  obj->location = location___0;
#line 1359
  obj->isatomic = (atomic_t )2;
#line 1360
  obj->arg1 = arg1;
#line 1362
  return (obj);
}
}
#line 1365 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
alignof_expr new_alignof_expr(region r , location location___0 , expression arg1 ) 
{ 
  alignof_expr obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1367
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1367
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1367
    tmp___1 = tmp;
    }
  } else {
    {
#line 1367
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1367
    tmp___1 = tmp___0;
    }
  }
#line 1367
  obj = (alignof_expr )tmp___1;
#line 1369
  obj->kind = (AST_kind )98;
#line 1370
  obj->location = location___0;
#line 1371
  obj->isatomic = (atomic_t )2;
#line 1372
  obj->arg1 = arg1;
#line 1374
  return (obj);
}
}
#line 1377 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
realpart new_realpart(region r , location location___0 , expression arg1 ) 
{ 
  realpart obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1379
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1379
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1379
    tmp___1 = tmp;
    }
  } else {
    {
#line 1379
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1379
    tmp___1 = tmp___0;
    }
  }
#line 1379
  obj = (realpart )tmp___1;
#line 1381
  obj->kind = (AST_kind )99;
#line 1382
  obj->location = location___0;
#line 1383
  obj->isatomic = (atomic_t )2;
#line 1384
  obj->arg1 = arg1;
#line 1386
  return (obj);
}
}
#line 1389 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
imagpart new_imagpart(region r , location location___0 , expression arg1 ) 
{ 
  imagpart obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1391
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1391
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1391
    tmp___1 = tmp;
    }
  } else {
    {
#line 1391
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1391
    tmp___1 = tmp___0;
    }
  }
#line 1391
  obj = (imagpart )tmp___1;
#line 1393
  obj->kind = (AST_kind )100;
#line 1394
  obj->location = location___0;
#line 1395
  obj->isatomic = (atomic_t )2;
#line 1396
  obj->arg1 = arg1;
#line 1398
  return (obj);
}
}
#line 1401 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
address_of new_address_of(region r , location location___0 , expression arg1 ) 
{ 
  address_of obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1403
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1403
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1403
    tmp___1 = tmp;
    }
  } else {
    {
#line 1403
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1403
    tmp___1 = tmp___0;
    }
  }
#line 1403
  obj = (address_of )tmp___1;
#line 1405
  obj->kind = (AST_kind )101;
#line 1406
  obj->location = location___0;
#line 1407
  obj->isatomic = (atomic_t )2;
#line 1408
  obj->arg1 = arg1;
#line 1410
  return (obj);
}
}
#line 1413 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
unary_minus new_unary_minus(region r , location location___0 , expression arg1 ) 
{ 
  unary_minus obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1415
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1415
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1415
    tmp___1 = tmp;
    }
  } else {
    {
#line 1415
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1415
    tmp___1 = tmp___0;
    }
  }
#line 1415
  obj = (unary_minus )tmp___1;
#line 1417
  obj->kind = (AST_kind )102;
#line 1418
  obj->location = location___0;
#line 1419
  obj->isatomic = (atomic_t )2;
#line 1420
  obj->arg1 = arg1;
#line 1422
  return (obj);
}
}
#line 1425 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
unary_plus new_unary_plus(region r , location location___0 , expression arg1 ) 
{ 
  unary_plus obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1427
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1427
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1427
    tmp___1 = tmp;
    }
  } else {
    {
#line 1427
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1427
    tmp___1 = tmp___0;
    }
  }
#line 1427
  obj = (unary_plus )tmp___1;
#line 1429
  obj->kind = (AST_kind )103;
#line 1430
  obj->location = location___0;
#line 1431
  obj->isatomic = (atomic_t )2;
#line 1432
  obj->arg1 = arg1;
#line 1434
  return (obj);
}
}
#line 1437 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
conjugate new_conjugate(region r , location location___0 , expression arg1 ) 
{ 
  conjugate obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1439
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1439
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1439
    tmp___1 = tmp;
    }
  } else {
    {
#line 1439
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1439
    tmp___1 = tmp___0;
    }
  }
#line 1439
  obj = (conjugate )tmp___1;
#line 1441
  obj->kind = (AST_kind )104;
#line 1442
  obj->location = location___0;
#line 1443
  obj->isatomic = (atomic_t )2;
#line 1444
  obj->arg1 = arg1;
#line 1446
  return (obj);
}
}
#line 1449 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitnot new_bitnot(region r , location location___0 , expression arg1 ) 
{ 
  bitnot obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1451
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1451
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1451
    tmp___1 = tmp;
    }
  } else {
    {
#line 1451
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1451
    tmp___1 = tmp___0;
    }
  }
#line 1451
  obj = (bitnot )tmp___1;
#line 1453
  obj->kind = (AST_kind )105;
#line 1454
  obj->location = location___0;
#line 1455
  obj->isatomic = (atomic_t )2;
#line 1456
  obj->arg1 = arg1;
#line 1458
  return (obj);
}
}
#line 1461 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
not new_not(region r , location location___0 , expression arg1 ) 
{ 
  not obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1463
  if (sizeof(struct AST_unary ) < (unsigned long )(1 << 9)) {
    {
#line 1463
    tmp = __rcralloc_small0(r, sizeof(struct AST_unary ));
#line 1463
    tmp___1 = tmp;
    }
  } else {
    {
#line 1463
    tmp___0 = typed_ralloc(r, sizeof(struct AST_unary ), 0);
#line 1463
    tmp___1 = tmp___0;
    }
  }
#line 1463
  obj = (not )tmp___1;
#line 1465
  obj->kind = (AST_kind )106;
#line 1466
  obj->location = location___0;
#line 1467
  obj->isatomic = (atomic_t )2;
#line 1468
  obj->arg1 = arg1;
#line 1470
  return (obj);
}
}
#line 1473 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
preincrement new_preincrement(region r , location location___0 , expression arg1 ) 
{ 
  preincrement obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1475
  if (sizeof(struct AST_increment ) < (unsigned long )(1 << 9)) {
    {
#line 1475
    tmp = __rcralloc_small0(r, sizeof(struct AST_increment ));
#line 1475
    tmp___1 = tmp;
    }
  } else {
    {
#line 1475
    tmp___0 = typed_ralloc(r, sizeof(struct AST_increment ), 0);
#line 1475
    tmp___1 = tmp___0;
    }
  }
#line 1475
  obj = (preincrement )tmp___1;
#line 1477
  obj->kind = (AST_kind )89;
#line 1478
  obj->location = location___0;
#line 1479
  obj->isatomic = (atomic_t )2;
#line 1480
  obj->arg1 = arg1;
#line 1482
  return (obj);
}
}
#line 1485 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
predecrement new_predecrement(region r , location location___0 , expression arg1 ) 
{ 
  predecrement obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1487
  if (sizeof(struct AST_increment ) < (unsigned long )(1 << 9)) {
    {
#line 1487
    tmp = __rcralloc_small0(r, sizeof(struct AST_increment ));
#line 1487
    tmp___1 = tmp;
    }
  } else {
    {
#line 1487
    tmp___0 = typed_ralloc(r, sizeof(struct AST_increment ), 0);
#line 1487
    tmp___1 = tmp___0;
    }
  }
#line 1487
  obj = (predecrement )tmp___1;
#line 1489
  obj->kind = (AST_kind )90;
#line 1490
  obj->location = location___0;
#line 1491
  obj->isatomic = (atomic_t )2;
#line 1492
  obj->arg1 = arg1;
#line 1494
  return (obj);
}
}
#line 1497 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
postincrement new_postincrement(region r , location location___0 , expression arg1 ) 
{ 
  postincrement obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1499
  if (sizeof(struct AST_increment ) < (unsigned long )(1 << 9)) {
    {
#line 1499
    tmp = __rcralloc_small0(r, sizeof(struct AST_increment ));
#line 1499
    tmp___1 = tmp;
    }
  } else {
    {
#line 1499
    tmp___0 = typed_ralloc(r, sizeof(struct AST_increment ), 0);
#line 1499
    tmp___1 = tmp___0;
    }
  }
#line 1499
  obj = (postincrement )tmp___1;
#line 1501
  obj->kind = (AST_kind )91;
#line 1502
  obj->location = location___0;
#line 1503
  obj->isatomic = (atomic_t )2;
#line 1504
  obj->arg1 = arg1;
#line 1506
  return (obj);
}
}
#line 1509 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
postdecrement new_postdecrement(region r , location location___0 , expression arg1 ) 
{ 
  postdecrement obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1511
  if (sizeof(struct AST_increment ) < (unsigned long )(1 << 9)) {
    {
#line 1511
    tmp = __rcralloc_small0(r, sizeof(struct AST_increment ));
#line 1511
    tmp___1 = tmp;
    }
  } else {
    {
#line 1511
    tmp___0 = typed_ralloc(r, sizeof(struct AST_increment ), 0);
#line 1511
    tmp___1 = tmp___0;
    }
  }
#line 1511
  obj = (postdecrement )tmp___1;
#line 1513
  obj->kind = (AST_kind )92;
#line 1514
  obj->location = location___0;
#line 1515
  obj->isatomic = (atomic_t )2;
#line 1516
  obj->arg1 = arg1;
#line 1518
  return (obj);
}
}
#line 1521 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
plus new_plus(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  plus obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1523
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1523
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1523
    tmp___1 = tmp;
    }
  } else {
    {
#line 1523
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1523
    tmp___1 = tmp___0;
    }
  }
#line 1523
  obj = (plus )tmp___1;
#line 1525
  obj->kind = (AST_kind )128;
#line 1526
  obj->location = location___0;
#line 1527
  obj->isatomic = (atomic_t )2;
#line 1528
  obj->arg1 = arg1;
#line 1529
  obj->arg2 = arg2;
#line 1531
  return (obj);
}
}
#line 1534 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
minus new_minus(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  minus obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1536
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1536
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1536
    tmp___1 = tmp;
    }
  } else {
    {
#line 1536
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1536
    tmp___1 = tmp___0;
    }
  }
#line 1536
  obj = (minus )tmp___1;
#line 1538
  obj->kind = (AST_kind )129;
#line 1539
  obj->location = location___0;
#line 1540
  obj->isatomic = (atomic_t )2;
#line 1541
  obj->arg1 = arg1;
#line 1542
  obj->arg2 = arg2;
#line 1544
  return (obj);
}
}
#line 1547 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
times new_times(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  times obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1549
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1549
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1549
    tmp___1 = tmp;
    }
  } else {
    {
#line 1549
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1549
    tmp___1 = tmp___0;
    }
  }
#line 1549
  obj = (times )tmp___1;
#line 1551
  obj->kind = (AST_kind )130;
#line 1552
  obj->location = location___0;
#line 1553
  obj->isatomic = (atomic_t )2;
#line 1554
  obj->arg1 = arg1;
#line 1555
  obj->arg2 = arg2;
#line 1557
  return (obj);
}
}
#line 1560 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
divide new_divide(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  divide obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1562
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1562
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1562
    tmp___1 = tmp;
    }
  } else {
    {
#line 1562
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1562
    tmp___1 = tmp___0;
    }
  }
#line 1562
  obj = (divide )tmp___1;
#line 1564
  obj->kind = (AST_kind )131;
#line 1565
  obj->location = location___0;
#line 1566
  obj->isatomic = (atomic_t )2;
#line 1567
  obj->arg1 = arg1;
#line 1568
  obj->arg2 = arg2;
#line 1570
  return (obj);
}
}
#line 1573 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
modulo new_modulo(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  modulo obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1575
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1575
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1575
    tmp___1 = tmp;
    }
  } else {
    {
#line 1575
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1575
    tmp___1 = tmp___0;
    }
  }
#line 1575
  obj = (modulo )tmp___1;
#line 1577
  obj->kind = (AST_kind )132;
#line 1578
  obj->location = location___0;
#line 1579
  obj->isatomic = (atomic_t )2;
#line 1580
  obj->arg1 = arg1;
#line 1581
  obj->arg2 = arg2;
#line 1583
  return (obj);
}
}
#line 1586 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
lshift new_lshift(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  lshift obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1588
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1588
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1588
    tmp___1 = tmp;
    }
  } else {
    {
#line 1588
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1588
    tmp___1 = tmp___0;
    }
  }
#line 1588
  obj = (lshift )tmp___1;
#line 1590
  obj->kind = (AST_kind )133;
#line 1591
  obj->location = location___0;
#line 1592
  obj->isatomic = (atomic_t )2;
#line 1593
  obj->arg1 = arg1;
#line 1594
  obj->arg2 = arg2;
#line 1596
  return (obj);
}
}
#line 1599 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
rshift new_rshift(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  rshift obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1601
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1601
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1601
    tmp___1 = tmp;
    }
  } else {
    {
#line 1601
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1601
    tmp___1 = tmp___0;
    }
  }
#line 1601
  obj = (rshift )tmp___1;
#line 1603
  obj->kind = (AST_kind )134;
#line 1604
  obj->location = location___0;
#line 1605
  obj->isatomic = (atomic_t )2;
#line 1606
  obj->arg1 = arg1;
#line 1607
  obj->arg2 = arg2;
#line 1609
  return (obj);
}
}
#line 1612 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
leq new_leq(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  leq obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1614
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1614
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1614
    tmp___1 = tmp;
    }
  } else {
    {
#line 1614
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1614
    tmp___1 = tmp___0;
    }
  }
#line 1614
  obj = (leq )tmp___1;
#line 1616
  obj->kind = (AST_kind )109;
#line 1617
  obj->location = location___0;
#line 1618
  obj->isatomic = (atomic_t )2;
#line 1619
  obj->arg1 = arg1;
#line 1620
  obj->arg2 = arg2;
#line 1622
  return (obj);
}
}
#line 1625 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
geq new_geq(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  geq obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1627
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1627
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1627
    tmp___1 = tmp;
    }
  } else {
    {
#line 1627
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1627
    tmp___1 = tmp___0;
    }
  }
#line 1627
  obj = (geq )tmp___1;
#line 1629
  obj->kind = (AST_kind )110;
#line 1630
  obj->location = location___0;
#line 1631
  obj->isatomic = (atomic_t )2;
#line 1632
  obj->arg1 = arg1;
#line 1633
  obj->arg2 = arg2;
#line 1635
  return (obj);
}
}
#line 1638 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
lt new_lt(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  lt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1640
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1640
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1640
    tmp___1 = tmp;
    }
  } else {
    {
#line 1640
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1640
    tmp___1 = tmp___0;
    }
  }
#line 1640
  obj = (lt )tmp___1;
#line 1642
  obj->kind = (AST_kind )111;
#line 1643
  obj->location = location___0;
#line 1644
  obj->isatomic = (atomic_t )2;
#line 1645
  obj->arg1 = arg1;
#line 1646
  obj->arg2 = arg2;
#line 1648
  return (obj);
}
}
#line 1651 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
gt new_gt(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  gt obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1653
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1653
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1653
    tmp___1 = tmp;
    }
  } else {
    {
#line 1653
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1653
    tmp___1 = tmp___0;
    }
  }
#line 1653
  obj = (gt )tmp___1;
#line 1655
  obj->kind = (AST_kind )112;
#line 1656
  obj->location = location___0;
#line 1657
  obj->isatomic = (atomic_t )2;
#line 1658
  obj->arg1 = arg1;
#line 1659
  obj->arg2 = arg2;
#line 1661
  return (obj);
}
}
#line 1664 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
eq new_eq(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  eq obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1666
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1666
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1666
    tmp___1 = tmp;
    }
  } else {
    {
#line 1666
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1666
    tmp___1 = tmp___0;
    }
  }
#line 1666
  obj = (eq )tmp___1;
#line 1668
  obj->kind = (AST_kind )113;
#line 1669
  obj->location = location___0;
#line 1670
  obj->isatomic = (atomic_t )2;
#line 1671
  obj->arg1 = arg1;
#line 1672
  obj->arg2 = arg2;
#line 1674
  return (obj);
}
}
#line 1677 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
ne new_ne(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  ne obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1679
  if (sizeof(struct AST_comparison ) < (unsigned long )(1 << 9)) {
    {
#line 1679
    tmp = __rcralloc_small0(r, sizeof(struct AST_comparison ));
#line 1679
    tmp___1 = tmp;
    }
  } else {
    {
#line 1679
    tmp___0 = typed_ralloc(r, sizeof(struct AST_comparison ), 0);
#line 1679
    tmp___1 = tmp___0;
    }
  }
#line 1679
  obj = (ne )tmp___1;
#line 1681
  obj->kind = (AST_kind )114;
#line 1682
  obj->location = location___0;
#line 1683
  obj->isatomic = (atomic_t )2;
#line 1684
  obj->arg1 = arg1;
#line 1685
  obj->arg2 = arg2;
#line 1687
  return (obj);
}
}
#line 1690 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitand new_bitand(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  bitand obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1692
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1692
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1692
    tmp___1 = tmp;
    }
  } else {
    {
#line 1692
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1692
    tmp___1 = tmp___0;
    }
  }
#line 1692
  obj = (bitand )tmp___1;
#line 1694
  obj->kind = (AST_kind )135;
#line 1695
  obj->location = location___0;
#line 1696
  obj->isatomic = (atomic_t )2;
#line 1697
  obj->arg1 = arg1;
#line 1698
  obj->arg2 = arg2;
#line 1700
  return (obj);
}
}
#line 1703 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitor new_bitor(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  bitor obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1705
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1705
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1705
    tmp___1 = tmp;
    }
  } else {
    {
#line 1705
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1705
    tmp___1 = tmp___0;
    }
  }
#line 1705
  obj = (bitor )tmp___1;
#line 1707
  obj->kind = (AST_kind )136;
#line 1708
  obj->location = location___0;
#line 1709
  obj->isatomic = (atomic_t )2;
#line 1710
  obj->arg1 = arg1;
#line 1711
  obj->arg2 = arg2;
#line 1713
  return (obj);
}
}
#line 1716 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitxor new_bitxor(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  bitxor obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1718
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1718
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1718
    tmp___1 = tmp;
    }
  } else {
    {
#line 1718
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1718
    tmp___1 = tmp___0;
    }
  }
#line 1718
  obj = (bitxor )tmp___1;
#line 1720
  obj->kind = (AST_kind )137;
#line 1721
  obj->location = location___0;
#line 1722
  obj->isatomic = (atomic_t )2;
#line 1723
  obj->arg1 = arg1;
#line 1724
  obj->arg2 = arg2;
#line 1726
  return (obj);
}
}
#line 1729 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
andand new_andand(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  andand obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1731
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1731
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1731
    tmp___1 = tmp;
    }
  } else {
    {
#line 1731
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1731
    tmp___1 = tmp___0;
    }
  }
#line 1731
  obj = (andand )tmp___1;
#line 1733
  obj->kind = (AST_kind )138;
#line 1734
  obj->location = location___0;
#line 1735
  obj->isatomic = (atomic_t )2;
#line 1736
  obj->arg1 = arg1;
#line 1737
  obj->arg2 = arg2;
#line 1739
  return (obj);
}
}
#line 1742 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
oror new_oror(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  oror obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1744
  if (sizeof(struct AST_binary ) < (unsigned long )(1 << 9)) {
    {
#line 1744
    tmp = __rcralloc_small0(r, sizeof(struct AST_binary ));
#line 1744
    tmp___1 = tmp;
    }
  } else {
    {
#line 1744
    tmp___0 = typed_ralloc(r, sizeof(struct AST_binary ), 0);
#line 1744
    tmp___1 = tmp___0;
    }
  }
#line 1744
  obj = (oror )tmp___1;
#line 1746
  obj->kind = (AST_kind )139;
#line 1747
  obj->location = location___0;
#line 1748
  obj->isatomic = (atomic_t )2;
#line 1749
  obj->arg1 = arg1;
#line 1750
  obj->arg2 = arg2;
#line 1752
  return (obj);
}
}
#line 1755 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
assign new_assign(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1757
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1757
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1757
    tmp___1 = tmp;
    }
  } else {
    {
#line 1757
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1757
    tmp___1 = tmp___0;
    }
  }
#line 1757
  obj = (assign )tmp___1;
#line 1759
  obj->kind = (AST_kind )116;
#line 1760
  obj->location = location___0;
#line 1761
  obj->isatomic = (atomic_t )2;
#line 1762
  obj->arg1 = arg1;
#line 1763
  obj->arg2 = arg2;
#line 1765
  return (obj);
}
}
#line 1768 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
plus_assign new_plus_assign(region r , location location___0 , expression arg1 , expression arg2 ) 
{ 
  plus_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1770
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1770
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1770
    tmp___1 = tmp;
    }
  } else {
    {
#line 1770
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1770
    tmp___1 = tmp___0;
    }
  }
#line 1770
  obj = (plus_assign )tmp___1;
#line 1772
  obj->kind = (AST_kind )117;
#line 1773
  obj->location = location___0;
#line 1774
  obj->isatomic = (atomic_t )2;
#line 1775
  obj->arg1 = arg1;
#line 1776
  obj->arg2 = arg2;
#line 1778
  return (obj);
}
}
#line 1781 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
minus_assign new_minus_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) 
{ 
  minus_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1783
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1783
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1783
    tmp___1 = tmp;
    }
  } else {
    {
#line 1783
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1783
    tmp___1 = tmp___0;
    }
  }
#line 1783
  obj = (minus_assign )tmp___1;
#line 1785
  obj->kind = (AST_kind )118;
#line 1786
  obj->location = location___0;
#line 1787
  obj->isatomic = (atomic_t )2;
#line 1788
  obj->arg1 = arg1;
#line 1789
  obj->arg2 = arg2;
#line 1791
  return (obj);
}
}
#line 1794 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
times_assign new_times_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) 
{ 
  times_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1796
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1796
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1796
    tmp___1 = tmp;
    }
  } else {
    {
#line 1796
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1796
    tmp___1 = tmp___0;
    }
  }
#line 1796
  obj = (times_assign )tmp___1;
#line 1798
  obj->kind = (AST_kind )119;
#line 1799
  obj->location = location___0;
#line 1800
  obj->isatomic = (atomic_t )2;
#line 1801
  obj->arg1 = arg1;
#line 1802
  obj->arg2 = arg2;
#line 1804
  return (obj);
}
}
#line 1807 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
divide_assign new_divide_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  divide_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1809
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1809
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1809
    tmp___1 = tmp;
    }
  } else {
    {
#line 1809
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1809
    tmp___1 = tmp___0;
    }
  }
#line 1809
  obj = (divide_assign )tmp___1;
#line 1811
  obj->kind = (AST_kind )120;
#line 1812
  obj->location = location___0;
#line 1813
  obj->isatomic = (atomic_t )2;
#line 1814
  obj->arg1 = arg1;
#line 1815
  obj->arg2 = arg2;
#line 1817
  return (obj);
}
}
#line 1820 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
modulo_assign new_modulo_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  modulo_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1822
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1822
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1822
    tmp___1 = tmp;
    }
  } else {
    {
#line 1822
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1822
    tmp___1 = tmp___0;
    }
  }
#line 1822
  obj = (modulo_assign )tmp___1;
#line 1824
  obj->kind = (AST_kind )121;
#line 1825
  obj->location = location___0;
#line 1826
  obj->isatomic = (atomic_t )2;
#line 1827
  obj->arg1 = arg1;
#line 1828
  obj->arg2 = arg2;
#line 1830
  return (obj);
}
}
#line 1833 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
lshift_assign new_lshift_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  lshift_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1835
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1835
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1835
    tmp___1 = tmp;
    }
  } else {
    {
#line 1835
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1835
    tmp___1 = tmp___0;
    }
  }
#line 1835
  obj = (lshift_assign )tmp___1;
#line 1837
  obj->kind = (AST_kind )122;
#line 1838
  obj->location = location___0;
#line 1839
  obj->isatomic = (atomic_t )2;
#line 1840
  obj->arg1 = arg1;
#line 1841
  obj->arg2 = arg2;
#line 1843
  return (obj);
}
}
#line 1846 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
rshift_assign new_rshift_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  rshift_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1848
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1848
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1848
    tmp___1 = tmp;
    }
  } else {
    {
#line 1848
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1848
    tmp___1 = tmp___0;
    }
  }
#line 1848
  obj = (rshift_assign )tmp___1;
#line 1850
  obj->kind = (AST_kind )123;
#line 1851
  obj->location = location___0;
#line 1852
  obj->isatomic = (atomic_t )2;
#line 1853
  obj->arg1 = arg1;
#line 1854
  obj->arg2 = arg2;
#line 1856
  return (obj);
}
}
#line 1859 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitand_assign new_bitand_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  bitand_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1861
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1861
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1861
    tmp___1 = tmp;
    }
  } else {
    {
#line 1861
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1861
    tmp___1 = tmp___0;
    }
  }
#line 1861
  obj = (bitand_assign )tmp___1;
#line 1863
  obj->kind = (AST_kind )124;
#line 1864
  obj->location = location___0;
#line 1865
  obj->isatomic = (atomic_t )2;
#line 1866
  obj->arg1 = arg1;
#line 1867
  obj->arg2 = arg2;
#line 1869
  return (obj);
}
}
#line 1872 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitor_assign new_bitor_assign(region r , location location___0 , expression arg1 ,
                              expression arg2 ) 
{ 
  bitor_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1874
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1874
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1874
    tmp___1 = tmp;
    }
  } else {
    {
#line 1874
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1874
    tmp___1 = tmp___0;
    }
  }
#line 1874
  obj = (bitor_assign )tmp___1;
#line 1876
  obj->kind = (AST_kind )125;
#line 1877
  obj->location = location___0;
#line 1878
  obj->isatomic = (atomic_t )2;
#line 1879
  obj->arg1 = arg1;
#line 1880
  obj->arg2 = arg2;
#line 1882
  return (obj);
}
}
#line 1885 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
bitxor_assign new_bitxor_assign(region r , location location___0 , expression arg1 ,
                                expression arg2 ) 
{ 
  bitxor_assign obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1887
  if (sizeof(struct AST_assignment ) < (unsigned long )(1 << 9)) {
    {
#line 1887
    tmp = __rcralloc_small0(r, sizeof(struct AST_assignment ));
#line 1887
    tmp___1 = tmp;
    }
  } else {
    {
#line 1887
    tmp___0 = typed_ralloc(r, sizeof(struct AST_assignment ), 0);
#line 1887
    tmp___1 = tmp___0;
    }
  }
#line 1887
  obj = (bitxor_assign )tmp___1;
#line 1889
  obj->kind = (AST_kind )126;
#line 1890
  obj->location = location___0;
#line 1891
  obj->isatomic = (atomic_t )2;
#line 1892
  obj->arg1 = arg1;
#line 1893
  obj->arg2 = arg2;
#line 1895
  return (obj);
}
}
#line 1898 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
rp_connection new_rp_connection(region r , location location___0 , endpoint ep1 ,
                                endpoint ep2 ) 
{ 
  rp_connection obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1900
  if (sizeof(struct AST_connection ) < (unsigned long )(1 << 9)) {
    {
#line 1900
    tmp = __rcralloc_small0(r, sizeof(struct AST_connection ));
#line 1900
    tmp___1 = tmp;
    }
  } else {
    {
#line 1900
    tmp___0 = typed_ralloc(r, sizeof(struct AST_connection ), 0);
#line 1900
    tmp___1 = tmp___0;
    }
  }
#line 1900
  obj = (rp_connection )tmp___1;
#line 1902
  obj->kind = (AST_kind )61;
#line 1903
  obj->location = location___0;
#line 1904
  obj->ep1 = ep1;
#line 1905
  obj->ep2 = ep2;
#line 1907
  return (obj);
}
}
#line 1910 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
eq_connection new_eq_connection(region r , location location___0 , endpoint ep1 ,
                                endpoint ep2 ) 
{ 
  eq_connection obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1912
  if (sizeof(struct AST_connection ) < (unsigned long )(1 << 9)) {
    {
#line 1912
    tmp = __rcralloc_small0(r, sizeof(struct AST_connection ));
#line 1912
    tmp___1 = tmp;
    }
  } else {
    {
#line 1912
    tmp___0 = typed_ralloc(r, sizeof(struct AST_connection ), 0);
#line 1912
    tmp___1 = tmp___0;
    }
  }
#line 1912
  obj = (eq_connection )tmp___1;
#line 1914
  obj->kind = (AST_kind )62;
#line 1915
  obj->location = location___0;
#line 1916
  obj->ep1 = ep1;
#line 1917
  obj->ep2 = ep2;
#line 1919
  return (obj);
}
}
#line 1922 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
nx_struct_ref new_nx_struct_ref(region r , location location___0 , word word1 , attribute attributes ,
                                declaration fields , bool defined ) 
{ 
  nx_struct_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1924
  if (sizeof(struct AST_struct_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1924
    tmp = __rcralloc_small0(r, sizeof(struct AST_struct_ref ));
#line 1924
    tmp___1 = tmp;
    }
  } else {
    {
#line 1924
    tmp___0 = typed_ralloc(r, sizeof(struct AST_struct_ref ), 0);
#line 1924
    tmp___1 = tmp___0;
    }
  }
#line 1924
  obj = (nx_struct_ref )tmp___1;
#line 1926
  obj->kind = (AST_kind )170;
#line 1927
  obj->location = location___0;
#line 1928
  obj->word1 = word1;
#line 1929
  obj->attributes = attributes;
#line 1930
  obj->fields = fields;
#line 1931
  obj->defined = defined;
#line 1933
  return (obj);
}
}
#line 1936 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
nx_union_ref new_nx_union_ref(region r , location location___0 , word word1 , attribute attributes ,
                              declaration fields , bool defined ) 
{ 
  nx_union_ref obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1938
  if (sizeof(struct AST_union_ref ) < (unsigned long )(1 << 9)) {
    {
#line 1938
    tmp = __rcralloc_small0(r, sizeof(struct AST_union_ref ));
#line 1938
    tmp___1 = tmp;
    }
  } else {
    {
#line 1938
    tmp___0 = typed_ralloc(r, sizeof(struct AST_union_ref ), 0);
#line 1938
    tmp___1 = tmp___0;
    }
  }
#line 1938
  obj = (nx_union_ref )tmp___1;
#line 1940
  obj->kind = (AST_kind )172;
#line 1941
  obj->location = location___0;
#line 1942
  obj->word1 = word1;
#line 1943
  obj->attributes = attributes;
#line 1944
  obj->fields = fields;
#line 1945
  obj->defined = defined;
#line 1947
  return (obj);
}
}
#line 1950 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
target_attribute new_target_attribute(region r , location location___0 , word word1 ,
                                      expression args ) 
{ 
  target_attribute obj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1952
  if (sizeof(struct AST_gcc_attribute ) < (unsigned long )(1 << 9)) {
    {
#line 1952
    tmp = __rcralloc_small0(r, sizeof(struct AST_gcc_attribute ));
#line 1952
    tmp___1 = tmp;
    }
  } else {
    {
#line 1952
    tmp___0 = typed_ralloc(r, sizeof(struct AST_gcc_attribute ), 0);
#line 1952
    tmp___1 = tmp___0;
    }
  }
#line 1952
  obj = (target_attribute )tmp___1;
#line 1954
  obj->kind = (AST_kind )164;
#line 1955
  obj->location = location___0;
#line 1956
  obj->word1 = word1;
#line 1957
  obj->args = args;
#line 1959
  return (obj);
}
}
#line 1964 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
AST_kind AST_parent_kind[158]  = 
#line 1964
  {      (AST_kind )0,      (AST_kind )42,      (AST_kind )43,      (AST_kind )43, 
        (AST_kind )43,      (AST_kind )43,      (AST_kind )43,      (AST_kind )43, 
        (AST_kind )43,      (AST_kind )43,      (AST_kind )43,      (AST_kind )43, 
        (AST_kind )43,      (AST_kind )54,      (AST_kind )54,      (AST_kind )43, 
        (AST_kind )43,      (AST_kind )43,      (AST_kind )43,      (AST_kind )60, 
        (AST_kind )60,      (AST_kind )43,      (AST_kind )43,      (AST_kind )42, 
        (AST_kind )65,      (AST_kind )65,      (AST_kind )65,      (AST_kind )65, 
        (AST_kind )65,      (AST_kind )65,      (AST_kind )71,      (AST_kind )71, 
        (AST_kind )71,      (AST_kind )65,      (AST_kind )65,      (AST_kind )65, 
        (AST_kind )65,      (AST_kind )65,      (AST_kind )65,      (AST_kind )65, 
        (AST_kind )65,      (AST_kind )65,      (AST_kind )42,      (AST_kind )84, 
        (AST_kind )85,      (AST_kind )85,      (AST_kind )85,      (AST_kind )88, 
        (AST_kind )88,      (AST_kind )88,      (AST_kind )88,      (AST_kind )85, 
        (AST_kind )85,      (AST_kind )85,      (AST_kind )85,      (AST_kind )85, 
        (AST_kind )85,      (AST_kind )85,      (AST_kind )85,      (AST_kind )85, 
        (AST_kind )85,      (AST_kind )85,      (AST_kind )85,      (AST_kind )85, 
        (AST_kind )85,      (AST_kind )84,      (AST_kind )107,      (AST_kind )108, 
        (AST_kind )108,      (AST_kind )108,      (AST_kind )108,      (AST_kind )108, 
        (AST_kind )108,      (AST_kind )107,      (AST_kind )115,      (AST_kind )115, 
        (AST_kind )115,      (AST_kind )115,      (AST_kind )115,      (AST_kind )115, 
        (AST_kind )115,      (AST_kind )115,      (AST_kind )115,      (AST_kind )115, 
        (AST_kind )115,      (AST_kind )107,      (AST_kind )107,      (AST_kind )107, 
        (AST_kind )107,      (AST_kind )107,      (AST_kind )107,      (AST_kind )107, 
        (AST_kind )107,      (AST_kind )107,      (AST_kind )107,      (AST_kind )107, 
        (AST_kind )107,      (AST_kind )107,      (AST_kind )84,      (AST_kind )84, 
        (AST_kind )84,      (AST_kind )84,      (AST_kind )84,      (AST_kind )84, 
        (AST_kind )84,      (AST_kind )84,      (AST_kind )84,      (AST_kind )84, 
        (AST_kind )84,      (AST_kind )84,      (AST_kind )151,      (AST_kind )84, 
        (AST_kind )84,      (AST_kind )84,      (AST_kind )84,      (AST_kind )42, 
        (AST_kind )157,      (AST_kind )158,      (AST_kind )157,      (AST_kind )157, 
        (AST_kind )157,      (AST_kind )162,      (AST_kind )163,      (AST_kind )162, 
        (AST_kind )157,      (AST_kind )157,      (AST_kind )157,      (AST_kind )168, 
        (AST_kind )169,      (AST_kind )168,      (AST_kind )171,      (AST_kind )168, 
        (AST_kind )168,      (AST_kind )42,      (AST_kind )175,      (AST_kind )176, 
        (AST_kind )176,      (AST_kind )176,      (AST_kind )176,      (AST_kind )176, 
        (AST_kind )175,      (AST_kind )175,      (AST_kind )42,      (AST_kind )184, 
        (AST_kind )184,      (AST_kind )184,      (AST_kind )42,      (AST_kind )42, 
        (AST_kind )189,      (AST_kind )189,      (AST_kind )42,      (AST_kind )42, 
        (AST_kind )42,      (AST_kind )194,      (AST_kind )194,      (AST_kind )194, 
        (AST_kind )42,      (AST_kind )42};
#line 2125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
AST_kind AST_post_kind[158]  = 
#line 2125
  {      (AST_kind )199,      (AST_kind )64,      (AST_kind )44,      (AST_kind )45, 
        (AST_kind )46,      (AST_kind )47,      (AST_kind )48,      (AST_kind )49, 
        (AST_kind )50,      (AST_kind )51,      (AST_kind )52,      (AST_kind )53, 
        (AST_kind )56,      (AST_kind )55,      (AST_kind )56,      (AST_kind )57, 
        (AST_kind )58,      (AST_kind )59,      (AST_kind )62,      (AST_kind )61, 
        (AST_kind )62,      (AST_kind )63,      (AST_kind )64,      (AST_kind )83, 
        (AST_kind )66,      (AST_kind )67,      (AST_kind )68,      (AST_kind )69, 
        (AST_kind )70,      (AST_kind )74,      (AST_kind )72,      (AST_kind )73, 
        (AST_kind )74,      (AST_kind )75,      (AST_kind )76,      (AST_kind )77, 
        (AST_kind )78,      (AST_kind )79,      (AST_kind )80,      (AST_kind )81, 
        (AST_kind )82,      (AST_kind )83,      (AST_kind )156,      (AST_kind )106, 
        (AST_kind )86,      (AST_kind )87,      (AST_kind )92,      (AST_kind )89, 
        (AST_kind )90,      (AST_kind )91,      (AST_kind )92,      (AST_kind )93, 
        (AST_kind )94,      (AST_kind )95,      (AST_kind )96,      (AST_kind )97, 
        (AST_kind )98,      (AST_kind )99,      (AST_kind )100,      (AST_kind )101, 
        (AST_kind )102,      (AST_kind )103,      (AST_kind )104,      (AST_kind )105, 
        (AST_kind )106,      (AST_kind )139,      (AST_kind )114,      (AST_kind )109, 
        (AST_kind )110,      (AST_kind )111,      (AST_kind )112,      (AST_kind )113, 
        (AST_kind )114,      (AST_kind )126,      (AST_kind )116,      (AST_kind )117, 
        (AST_kind )118,      (AST_kind )119,      (AST_kind )120,      (AST_kind )121, 
        (AST_kind )122,      (AST_kind )123,      (AST_kind )124,      (AST_kind )125, 
        (AST_kind )126,      (AST_kind )127,      (AST_kind )128,      (AST_kind )129, 
        (AST_kind )130,      (AST_kind )131,      (AST_kind )132,      (AST_kind )133, 
        (AST_kind )134,      (AST_kind )135,      (AST_kind )136,      (AST_kind )137, 
        (AST_kind )138,      (AST_kind )139,      (AST_kind )140,      (AST_kind )141, 
        (AST_kind )142,      (AST_kind )143,      (AST_kind )144,      (AST_kind )145, 
        (AST_kind )146,      (AST_kind )147,      (AST_kind )148,      (AST_kind )149, 
        (AST_kind )150,      (AST_kind )152,      (AST_kind )152,      (AST_kind )153, 
        (AST_kind )154,      (AST_kind )155,      (AST_kind )156,      (AST_kind )174, 
        (AST_kind )159,      (AST_kind )159,      (AST_kind )160,      (AST_kind )161, 
        (AST_kind )165,      (AST_kind )164,      (AST_kind )164,      (AST_kind )165, 
        (AST_kind )166,      (AST_kind )167,      (AST_kind )174,      (AST_kind )170, 
        (AST_kind )170,      (AST_kind )172,      (AST_kind )172,      (AST_kind )173, 
        (AST_kind )174,      (AST_kind )183,      (AST_kind )181,      (AST_kind )177, 
        (AST_kind )178,      (AST_kind )179,      (AST_kind )180,      (AST_kind )181, 
        (AST_kind )182,      (AST_kind )183,      (AST_kind )187,      (AST_kind )185, 
        (AST_kind )186,      (AST_kind )187,      (AST_kind )188,      (AST_kind )191, 
        (AST_kind )190,      (AST_kind )191,      (AST_kind )192,      (AST_kind )193, 
        (AST_kind )197,      (AST_kind )195,      (AST_kind )196,      (AST_kind )197, 
        (AST_kind )198,      (AST_kind )199};
#line 2286 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
size_t AST_sizeof[158]  = 
#line 2286
  {      sizeof(struct AST_node ),      sizeof(struct AST_declaration ),      sizeof(struct AST_asm_decl ),      sizeof(struct AST_data_decl ), 
        sizeof(struct AST_extension_decl ),      sizeof(struct AST_ellipsis_decl ),      sizeof(struct AST_enumerator ),      sizeof(struct AST_oldidentifier_decl ), 
        sizeof(struct AST_function_decl ),      sizeof(struct AST_implicit_decl ),      sizeof(struct AST_variable_decl ),      sizeof(struct AST_field_decl ), 
        sizeof(struct AST_nesc_decl ),      sizeof(struct AST_interface ),      sizeof(struct AST_component ),      sizeof(struct AST_rp_interface ), 
        sizeof(struct AST_interface_ref ),      sizeof(struct AST_component_ref ),      sizeof(struct AST_connection ),      sizeof(struct AST_connection ), 
        sizeof(struct AST_connection ),      sizeof(struct AST_type_parm_decl ),      sizeof(struct AST_declaration ),      sizeof(struct AST_statement ), 
        sizeof(struct AST_asm_stmt ),      sizeof(struct AST_compound_stmt ),      sizeof(struct AST_if_stmt ),      sizeof(struct AST_labeled_stmt ), 
        sizeof(struct AST_expression_stmt ),      sizeof(struct AST_conditional_stmt ),      sizeof(struct AST_switch_stmt ),      sizeof(struct AST_conditional_stmt ), 
        sizeof(struct AST_conditional_stmt ),      sizeof(struct AST_for_stmt ),      sizeof(struct AST_break_stmt ),      sizeof(struct AST_continue_stmt ), 
        sizeof(struct AST_return_stmt ),      sizeof(struct AST_goto_stmt ),      sizeof(struct AST_computed_goto_stmt ),      sizeof(struct AST_empty_stmt ), 
        sizeof(struct AST_atomic_stmt ),      sizeof(struct AST_statement ),      sizeof(struct AST_expression ),      sizeof(struct AST_unary ), 
        sizeof(struct AST_cast ),      sizeof(struct AST_field_ref ),      sizeof(struct AST_increment ),      sizeof(struct AST_increment ), 
        sizeof(struct AST_increment ),      sizeof(struct AST_increment ),      sizeof(struct AST_increment ),      sizeof(struct AST_interface_deref ), 
        sizeof(struct AST_component_deref ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ), 
        sizeof(struct AST_unary ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ), 
        sizeof(struct AST_unary ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ),      sizeof(struct AST_unary ), 
        sizeof(struct AST_unary ),      sizeof(struct AST_binary ),      sizeof(struct AST_comparison ),      sizeof(struct AST_comparison ), 
        sizeof(struct AST_comparison ),      sizeof(struct AST_comparison ),      sizeof(struct AST_comparison ),      sizeof(struct AST_comparison ), 
        sizeof(struct AST_comparison ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ), 
        sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ), 
        sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ),      sizeof(struct AST_assignment ), 
        sizeof(struct AST_assignment ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ), 
        sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ), 
        sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_binary ), 
        sizeof(struct AST_binary ),      sizeof(struct AST_binary ),      sizeof(struct AST_comma ),      sizeof(struct AST_sizeof_type ), 
        sizeof(struct AST_alignof_type ),      sizeof(struct AST_label_address ),      sizeof(struct AST_cast_list ),      sizeof(struct AST_conditional ), 
        sizeof(struct AST_identifier ),      sizeof(struct AST_compound_expr ),      sizeof(struct AST_function_call ),      sizeof(struct AST_init_list ), 
        sizeof(struct AST_init_specific ),      sizeof(struct AST_lexical_cst ),      sizeof(struct AST_string_cst ),      sizeof(struct AST_string ), 
        sizeof(struct AST_generic_call ),      sizeof(struct AST_type_argument ),      sizeof(struct AST_expression ),      sizeof(struct AST_type_element ), 
        sizeof(struct AST_typename ),      sizeof(struct AST_component_typeref ),      sizeof(struct AST_typeof_expr ),      sizeof(struct AST_typeof_type ), 
        sizeof(struct AST_attribute ),      sizeof(struct AST_gcc_attribute ),      sizeof(struct AST_gcc_attribute ),      sizeof(struct AST_nesc_attribute ), 
        sizeof(struct AST_rid ),      sizeof(struct AST_qualifier ),      sizeof(struct AST_tag_ref ),      sizeof(struct AST_struct_ref ), 
        sizeof(struct AST_struct_ref ),      sizeof(struct AST_union_ref ),      sizeof(struct AST_union_ref ),      sizeof(struct AST_tag_ref ), 
        sizeof(struct AST_tag_ref ),      sizeof(struct AST_declarator ),      sizeof(struct AST_nested_declarator ),      sizeof(struct AST_function_declarator ), 
        sizeof(struct AST_pointer_declarator ),      sizeof(struct AST_qualified_declarator ),      sizeof(struct AST_array_declarator ),      sizeof(struct AST_interface_ref_declarator ), 
        sizeof(struct AST_identifier_declarator ),      sizeof(struct AST_generic_declarator ),      sizeof(struct AST_label ),      sizeof(struct AST_id_label ), 
        sizeof(struct AST_case_label ),      sizeof(struct AST_default_label ),      sizeof(struct AST_asttype ),      sizeof(struct AST_designator ), 
        sizeof(struct AST_designate_field ),      sizeof(struct AST_designate_index ),      sizeof(struct AST_word ),      sizeof(struct AST_asm_operand ), 
        sizeof(struct AST_implementation ),      sizeof(struct AST_configuration ),      sizeof(struct AST_module ),      sizeof(struct AST_binary_component ), 
        sizeof(struct AST_endpoint ),      sizeof(struct AST_parameterised_identifier )};
#line 2447 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_types.c"
type_t AST_typeof[158]  = 
#line 2447
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
node AST_node_last(node l ) 
{ 


  {
#line 5
  if (! l) {
#line 5
    return ((node )((void *)0));
  }
  {
#line 6
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6
    if (! l->next) {
#line 6
      goto while_break;
    }
#line 6
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 7
  return (l);
}
}
#line 10 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
node AST_node_chain(node l1 , node l2 ) 
{ 
  node tmp ;

  {
#line 11
  if (! l1) {
#line 11
    return (l2);
  }
  {
#line 12
  tmp = AST_node_last(l1);
#line 12
  tmp->next = l2;
  }
#line 13
  return (l1);
}
}
#line 16 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
int AST_node_length(node l ) 
{ 
  int len ;

  {
#line 17
  len = 0;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! l) {
#line 19
      goto while_break;
    }
#line 21
    l = l->next;
#line 22
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (len);
}
}
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
node AST_node_reverse(node l ) 
{ 
  node last ;
  node next ;

  {
#line 28
  last = (node )((void *)0);
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! l) {
#line 33
      return (last);
    }
#line 34
    next = l->next;
#line 35
    l->next = last;
#line 36
    last = l;
#line 37
    l = next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
node node_chain(node l1 , node l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 42
  tEmPcast___0 = (AST_generic )l2;
#line 42
  if (tEmPcast___0) {
#line 42
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 42
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 42
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      42U, "node_chain");
        }
      }
    } else {
      {
#line 42
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    42U, "node_chain");
      }
    }
  }
#line 42
  tEmPcast___1 = (AST_generic )l1;
#line 42
  if (tEmPcast___1) {
#line 42
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 42
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 42
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      42U, "node_chain");
        }
      }
    } else {
      {
#line 42
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    42U, "node_chain");
      }
    }
  }
  {
#line 42
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 42
  tEmPcast = (AST_generic )tmp;
  }
#line 42
  if (tEmPcast) {
#line 42
    if ((unsigned int )tEmPcast->kind >= 42U) {
#line 42
      if (! ((unsigned int )tEmPcast->kind <= 199U)) {
        {
#line 42
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      42U, "node_chain");
        }
      }
    } else {
      {
#line 42
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    42U, "node_chain");
      }
    }
  }
#line 42
  return ((node )tEmPcast);
}
}
#line 44 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
declaration declaration_chain(declaration l1 , declaration l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 45
  tEmPcast___0 = (AST_generic )l2;
#line 45
  if (tEmPcast___0) {
#line 45
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 45
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 45
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      45U, "declaration_chain");
        }
      }
    } else {
      {
#line 45
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    45U, "declaration_chain");
      }
    }
  }
#line 45
  tEmPcast___1 = (AST_generic )l1;
#line 45
  if (tEmPcast___1) {
#line 45
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 45
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 45
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      45U, "declaration_chain");
        }
      }
    } else {
      {
#line 45
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    45U, "declaration_chain");
      }
    }
  }
  {
#line 45
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 45
  tEmPcast = (AST_generic )tmp;
  }
#line 45
  if (tEmPcast) {
#line 45
    if ((unsigned int )tEmPcast->kind >= 43U) {
#line 45
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 45
        __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      45U, "declaration_chain");
        }
      }
    } else {
      {
#line 45
      __assert_fail("((tEmPcast)->kind >= kind_declaration && (tEmPcast)->kind <= postkind_declaration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    45U, "declaration_chain");
      }
    }
  }
#line 45
  return ((declaration )tEmPcast);
}
}
#line 47 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
statement statement_chain(statement l1 , statement l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 48
  tEmPcast___0 = (AST_generic )l2;
#line 48
  if (tEmPcast___0) {
#line 48
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 48
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 48
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      48U, "statement_chain");
        }
      }
    } else {
      {
#line 48
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    48U, "statement_chain");
      }
    }
  }
#line 48
  tEmPcast___1 = (AST_generic )l1;
#line 48
  if (tEmPcast___1) {
#line 48
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 48
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 48
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      48U, "statement_chain");
        }
      }
    } else {
      {
#line 48
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    48U, "statement_chain");
      }
    }
  }
  {
#line 48
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 48
  tEmPcast = (AST_generic )tmp;
  }
#line 48
  if (tEmPcast) {
#line 48
    if ((unsigned int )tEmPcast->kind >= 65U) {
#line 48
      if (! ((unsigned int )tEmPcast->kind <= 83U)) {
        {
#line 48
        __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      48U, "statement_chain");
        }
      }
    } else {
      {
#line 48
      __assert_fail("((tEmPcast)->kind >= kind_statement && (tEmPcast)->kind <= postkind_statement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    48U, "statement_chain");
      }
    }
  }
#line 48
  return ((statement )tEmPcast);
}
}
#line 50 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
expression expression_chain(expression l1 , expression l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 51
  tEmPcast___0 = (AST_generic )l2;
#line 51
  if (tEmPcast___0) {
#line 51
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 51
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 51
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      51U, "expression_chain");
        }
      }
    } else {
      {
#line 51
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    51U, "expression_chain");
      }
    }
  }
#line 51
  tEmPcast___1 = (AST_generic )l1;
#line 51
  if (tEmPcast___1) {
#line 51
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 51
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 51
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      51U, "expression_chain");
        }
      }
    } else {
      {
#line 51
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    51U, "expression_chain");
      }
    }
  }
  {
#line 51
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 51
  tEmPcast = (AST_generic )tmp;
  }
#line 51
  if (tEmPcast) {
#line 51
    if ((unsigned int )tEmPcast->kind >= 84U) {
#line 51
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 51
        __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      51U, "expression_chain");
        }
      }
    } else {
      {
#line 51
      __assert_fail("((tEmPcast)->kind >= kind_expression && (tEmPcast)->kind <= postkind_expression)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    51U, "expression_chain");
      }
    }
  }
#line 51
  return ((expression )tEmPcast);
}
}
#line 53 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
type_element type_element_chain(type_element l1 , type_element l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 54
  tEmPcast___0 = (AST_generic )l2;
#line 54
  if (tEmPcast___0) {
#line 54
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 54
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 54
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      54U, "type_element_chain");
        }
      }
    } else {
      {
#line 54
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    54U, "type_element_chain");
      }
    }
  }
#line 54
  tEmPcast___1 = (AST_generic )l1;
#line 54
  if (tEmPcast___1) {
#line 54
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 54
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 54
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      54U, "type_element_chain");
        }
      }
    } else {
      {
#line 54
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    54U, "type_element_chain");
      }
    }
  }
  {
#line 54
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 54
  tEmPcast = (AST_generic )tmp;
  }
#line 54
  if (tEmPcast) {
#line 54
    if ((unsigned int )tEmPcast->kind >= 157U) {
#line 54
      if (! ((unsigned int )tEmPcast->kind <= 174U)) {
        {
#line 54
        __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      54U, "type_element_chain");
        }
      }
    } else {
      {
#line 54
      __assert_fail("((tEmPcast)->kind >= kind_type_element && (tEmPcast)->kind <= postkind_type_element)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    54U, "type_element_chain");
      }
    }
  }
#line 54
  return ((type_element )tEmPcast);
}
}
#line 56 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
declarator declarator_chain(declarator l1 , declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 57
  tEmPcast___0 = (AST_generic )l2;
#line 57
  if (tEmPcast___0) {
#line 57
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 57
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 57
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      57U, "declarator_chain");
        }
      }
    } else {
      {
#line 57
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    57U, "declarator_chain");
      }
    }
  }
#line 57
  tEmPcast___1 = (AST_generic )l1;
#line 57
  if (tEmPcast___1) {
#line 57
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 57
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 57
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      57U, "declarator_chain");
        }
      }
    } else {
      {
#line 57
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    57U, "declarator_chain");
      }
    }
  }
  {
#line 57
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 57
  tEmPcast = (AST_generic )tmp;
  }
#line 57
  if (tEmPcast) {
#line 57
    if ((unsigned int )tEmPcast->kind >= 175U) {
#line 57
      if (! ((unsigned int )tEmPcast->kind <= 183U)) {
        {
#line 57
        __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      57U, "declarator_chain");
        }
      }
    } else {
      {
#line 57
      __assert_fail("((tEmPcast)->kind >= kind_declarator && (tEmPcast)->kind <= postkind_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    57U, "declarator_chain");
      }
    }
  }
#line 57
  return ((declarator )tEmPcast);
}
}
#line 59 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
label label_chain(label l1 , label l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 60
  tEmPcast___0 = (AST_generic )l2;
#line 60
  if (tEmPcast___0) {
#line 60
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 60
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 60
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      60U, "label_chain");
        }
      }
    } else {
      {
#line 60
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    60U, "label_chain");
      }
    }
  }
#line 60
  tEmPcast___1 = (AST_generic )l1;
#line 60
  if (tEmPcast___1) {
#line 60
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 60
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 60
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      60U, "label_chain");
        }
      }
    } else {
      {
#line 60
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    60U, "label_chain");
      }
    }
  }
  {
#line 60
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 60
  tEmPcast = (AST_generic )tmp;
  }
#line 60
  if (tEmPcast) {
#line 60
    if ((unsigned int )tEmPcast->kind >= 184U) {
#line 60
      if (! ((unsigned int )tEmPcast->kind <= 187U)) {
        {
#line 60
        __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      60U, "label_chain");
        }
      }
    } else {
      {
#line 60
      __assert_fail("((tEmPcast)->kind >= kind_label && (tEmPcast)->kind <= postkind_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    60U, "label_chain");
      }
    }
  }
#line 60
  return ((label )tEmPcast);
}
}
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
asm_decl asm_decl_chain(asm_decl l1 , asm_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 63
  tEmPcast___0 = (AST_generic )l2;
#line 63
  if (tEmPcast___0) {
#line 63
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 63
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 63
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      63U, "asm_decl_chain");
        }
      }
    } else {
      {
#line 63
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    63U, "asm_decl_chain");
      }
    }
  }
#line 63
  tEmPcast___1 = (AST_generic )l1;
#line 63
  if (tEmPcast___1) {
#line 63
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 63
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 63
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      63U, "asm_decl_chain");
        }
      }
    } else {
      {
#line 63
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    63U, "asm_decl_chain");
      }
    }
  }
  {
#line 63
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 63
  tEmPcast = (AST_generic )tmp;
  }
#line 63
  if (tEmPcast) {
#line 63
    if ((unsigned int )tEmPcast->kind >= 44U) {
#line 63
      if (! ((unsigned int )tEmPcast->kind <= 44U)) {
        {
#line 63
        __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      63U, "asm_decl_chain");
        }
      }
    } else {
      {
#line 63
      __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    63U, "asm_decl_chain");
      }
    }
  }
#line 63
  return ((asm_decl )tEmPcast);
}
}
#line 65 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
data_decl data_decl_chain(data_decl l1 , data_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 66
  tEmPcast___0 = (AST_generic )l2;
#line 66
  if (tEmPcast___0) {
#line 66
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 66
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 66
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      66U, "data_decl_chain");
        }
      }
    } else {
      {
#line 66
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    66U, "data_decl_chain");
      }
    }
  }
#line 66
  tEmPcast___1 = (AST_generic )l1;
#line 66
  if (tEmPcast___1) {
#line 66
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 66
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 66
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      66U, "data_decl_chain");
        }
      }
    } else {
      {
#line 66
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    66U, "data_decl_chain");
      }
    }
  }
  {
#line 66
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 66
  tEmPcast = (AST_generic )tmp;
  }
#line 66
  if (tEmPcast) {
#line 66
    if ((unsigned int )tEmPcast->kind >= 45U) {
#line 66
      if (! ((unsigned int )tEmPcast->kind <= 45U)) {
        {
#line 66
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      66U, "data_decl_chain");
        }
      }
    } else {
      {
#line 66
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    66U, "data_decl_chain");
      }
    }
  }
#line 66
  return ((data_decl )tEmPcast);
}
}
#line 68 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
extension_decl extension_decl_chain(extension_decl l1 , extension_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 69
  tEmPcast___0 = (AST_generic )l2;
#line 69
  if (tEmPcast___0) {
#line 69
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 69
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 69
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      69U, "extension_decl_chain");
        }
      }
    } else {
      {
#line 69
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    69U, "extension_decl_chain");
      }
    }
  }
#line 69
  tEmPcast___1 = (AST_generic )l1;
#line 69
  if (tEmPcast___1) {
#line 69
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 69
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 69
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      69U, "extension_decl_chain");
        }
      }
    } else {
      {
#line 69
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    69U, "extension_decl_chain");
      }
    }
  }
  {
#line 69
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 69
  tEmPcast = (AST_generic )tmp;
  }
#line 69
  if (tEmPcast) {
#line 69
    if ((unsigned int )tEmPcast->kind >= 46U) {
#line 69
      if (! ((unsigned int )tEmPcast->kind <= 46U)) {
        {
#line 69
        __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      69U, "extension_decl_chain");
        }
      }
    } else {
      {
#line 69
      __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    69U, "extension_decl_chain");
      }
    }
  }
#line 69
  return ((extension_decl )tEmPcast);
}
}
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
ellipsis_decl ellipsis_decl_chain(ellipsis_decl l1 , ellipsis_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 72
  tEmPcast___0 = (AST_generic )l2;
#line 72
  if (tEmPcast___0) {
#line 72
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 72
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 72
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      72U, "ellipsis_decl_chain");
        }
      }
    } else {
      {
#line 72
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    72U, "ellipsis_decl_chain");
      }
    }
  }
#line 72
  tEmPcast___1 = (AST_generic )l1;
#line 72
  if (tEmPcast___1) {
#line 72
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 72
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 72
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      72U, "ellipsis_decl_chain");
        }
      }
    } else {
      {
#line 72
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    72U, "ellipsis_decl_chain");
      }
    }
  }
  {
#line 72
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 72
  tEmPcast = (AST_generic )tmp;
  }
#line 72
  if (tEmPcast) {
#line 72
    if ((unsigned int )tEmPcast->kind >= 47U) {
#line 72
      if (! ((unsigned int )tEmPcast->kind <= 47U)) {
        {
#line 72
        __assert_fail("((tEmPcast)->kind >= kind_ellipsis_decl && (tEmPcast)->kind <= postkind_ellipsis_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      72U, "ellipsis_decl_chain");
        }
      }
    } else {
      {
#line 72
      __assert_fail("((tEmPcast)->kind >= kind_ellipsis_decl && (tEmPcast)->kind <= postkind_ellipsis_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    72U, "ellipsis_decl_chain");
      }
    }
  }
#line 72
  return ((ellipsis_decl )tEmPcast);
}
}
#line 74 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
enumerator enumerator_chain(enumerator l1 , enumerator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 75
  tEmPcast___0 = (AST_generic )l2;
#line 75
  if (tEmPcast___0) {
#line 75
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 75
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 75
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      75U, "enumerator_chain");
        }
      }
    } else {
      {
#line 75
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    75U, "enumerator_chain");
      }
    }
  }
#line 75
  tEmPcast___1 = (AST_generic )l1;
#line 75
  if (tEmPcast___1) {
#line 75
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 75
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 75
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      75U, "enumerator_chain");
        }
      }
    } else {
      {
#line 75
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    75U, "enumerator_chain");
      }
    }
  }
  {
#line 75
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 75
  tEmPcast = (AST_generic )tmp;
  }
#line 75
  if (tEmPcast) {
#line 75
    if ((unsigned int )tEmPcast->kind >= 48U) {
#line 75
      if (! ((unsigned int )tEmPcast->kind <= 48U)) {
        {
#line 75
        __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      75U, "enumerator_chain");
        }
      }
    } else {
      {
#line 75
      __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    75U, "enumerator_chain");
      }
    }
  }
#line 75
  return ((enumerator )tEmPcast);
}
}
#line 77 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
oldidentifier_decl oldidentifier_decl_chain(oldidentifier_decl l1 , oldidentifier_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 78
  tEmPcast___0 = (AST_generic )l2;
#line 78
  if (tEmPcast___0) {
#line 78
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 78
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 78
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      78U, "oldidentifier_decl_chain");
        }
      }
    } else {
      {
#line 78
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    78U, "oldidentifier_decl_chain");
      }
    }
  }
#line 78
  tEmPcast___1 = (AST_generic )l1;
#line 78
  if (tEmPcast___1) {
#line 78
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 78
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 78
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      78U, "oldidentifier_decl_chain");
        }
      }
    } else {
      {
#line 78
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    78U, "oldidentifier_decl_chain");
      }
    }
  }
  {
#line 78
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 78
  tEmPcast = (AST_generic )tmp;
  }
#line 78
  if (tEmPcast) {
#line 78
    if ((unsigned int )tEmPcast->kind >= 49U) {
#line 78
      if (! ((unsigned int )tEmPcast->kind <= 49U)) {
        {
#line 78
        __assert_fail("((tEmPcast)->kind >= kind_oldidentifier_decl && (tEmPcast)->kind <= postkind_oldidentifier_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      78U, "oldidentifier_decl_chain");
        }
      }
    } else {
      {
#line 78
      __assert_fail("((tEmPcast)->kind >= kind_oldidentifier_decl && (tEmPcast)->kind <= postkind_oldidentifier_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    78U, "oldidentifier_decl_chain");
      }
    }
  }
#line 78
  return ((oldidentifier_decl )tEmPcast);
}
}
#line 80 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
function_decl function_decl_chain(function_decl l1 , function_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 81
  tEmPcast___0 = (AST_generic )l2;
#line 81
  if (tEmPcast___0) {
#line 81
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 81
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 81
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      81U, "function_decl_chain");
        }
      }
    } else {
      {
#line 81
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    81U, "function_decl_chain");
      }
    }
  }
#line 81
  tEmPcast___1 = (AST_generic )l1;
#line 81
  if (tEmPcast___1) {
#line 81
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 81
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 81
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      81U, "function_decl_chain");
        }
      }
    } else {
      {
#line 81
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    81U, "function_decl_chain");
      }
    }
  }
  {
#line 81
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 81
  tEmPcast = (AST_generic )tmp;
  }
#line 81
  if (tEmPcast) {
#line 81
    if ((unsigned int )tEmPcast->kind >= 50U) {
#line 81
      if (! ((unsigned int )tEmPcast->kind <= 50U)) {
        {
#line 81
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      81U, "function_decl_chain");
        }
      }
    } else {
      {
#line 81
      __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    81U, "function_decl_chain");
      }
    }
  }
#line 81
  return ((function_decl )tEmPcast);
}
}
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
implicit_decl implicit_decl_chain(implicit_decl l1 , implicit_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 84
  tEmPcast___0 = (AST_generic )l2;
#line 84
  if (tEmPcast___0) {
#line 84
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 84
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 84
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      84U, "implicit_decl_chain");
        }
      }
    } else {
      {
#line 84
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    84U, "implicit_decl_chain");
      }
    }
  }
#line 84
  tEmPcast___1 = (AST_generic )l1;
#line 84
  if (tEmPcast___1) {
#line 84
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 84
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 84
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      84U, "implicit_decl_chain");
        }
      }
    } else {
      {
#line 84
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    84U, "implicit_decl_chain");
      }
    }
  }
  {
#line 84
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 84
  tEmPcast = (AST_generic )tmp;
  }
#line 84
  if (tEmPcast) {
#line 84
    if ((unsigned int )tEmPcast->kind >= 51U) {
#line 84
      if (! ((unsigned int )tEmPcast->kind <= 51U)) {
        {
#line 84
        __assert_fail("((tEmPcast)->kind >= kind_implicit_decl && (tEmPcast)->kind <= postkind_implicit_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      84U, "implicit_decl_chain");
        }
      }
    } else {
      {
#line 84
      __assert_fail("((tEmPcast)->kind >= kind_implicit_decl && (tEmPcast)->kind <= postkind_implicit_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    84U, "implicit_decl_chain");
      }
    }
  }
#line 84
  return ((implicit_decl )tEmPcast);
}
}
#line 86 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
variable_decl variable_decl_chain(variable_decl l1 , variable_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 87
  tEmPcast___0 = (AST_generic )l2;
#line 87
  if (tEmPcast___0) {
#line 87
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 87
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 87
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      87U, "variable_decl_chain");
        }
      }
    } else {
      {
#line 87
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    87U, "variable_decl_chain");
      }
    }
  }
#line 87
  tEmPcast___1 = (AST_generic )l1;
#line 87
  if (tEmPcast___1) {
#line 87
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 87
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 87
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      87U, "variable_decl_chain");
        }
      }
    } else {
      {
#line 87
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    87U, "variable_decl_chain");
      }
    }
  }
  {
#line 87
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 87
  tEmPcast = (AST_generic )tmp;
  }
#line 87
  if (tEmPcast) {
#line 87
    if ((unsigned int )tEmPcast->kind >= 52U) {
#line 87
      if (! ((unsigned int )tEmPcast->kind <= 52U)) {
        {
#line 87
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      87U, "variable_decl_chain");
        }
      }
    } else {
      {
#line 87
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    87U, "variable_decl_chain");
      }
    }
  }
#line 87
  return ((variable_decl )tEmPcast);
}
}
#line 89 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
field_decl field_decl_chain(field_decl l1 , field_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 90
  tEmPcast___0 = (AST_generic )l2;
#line 90
  if (tEmPcast___0) {
#line 90
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 90
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 90
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      90U, "field_decl_chain");
        }
      }
    } else {
      {
#line 90
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    90U, "field_decl_chain");
      }
    }
  }
#line 90
  tEmPcast___1 = (AST_generic )l1;
#line 90
  if (tEmPcast___1) {
#line 90
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 90
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 90
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      90U, "field_decl_chain");
        }
      }
    } else {
      {
#line 90
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    90U, "field_decl_chain");
      }
    }
  }
  {
#line 90
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 90
  tEmPcast = (AST_generic )tmp;
  }
#line 90
  if (tEmPcast) {
#line 90
    if ((unsigned int )tEmPcast->kind >= 53U) {
#line 90
      if (! ((unsigned int )tEmPcast->kind <= 53U)) {
        {
#line 90
        __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      90U, "field_decl_chain");
        }
      }
    } else {
      {
#line 90
      __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    90U, "field_decl_chain");
      }
    }
  }
#line 90
  return ((field_decl )tEmPcast);
}
}
#line 92 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
asttype asttype_chain(asttype l1 , asttype l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 93
  tEmPcast___0 = (AST_generic )l2;
#line 93
  if (tEmPcast___0) {
#line 93
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 93
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 93
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      93U, "asttype_chain");
        }
      }
    } else {
      {
#line 93
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    93U, "asttype_chain");
      }
    }
  }
#line 93
  tEmPcast___1 = (AST_generic )l1;
#line 93
  if (tEmPcast___1) {
#line 93
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 93
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 93
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      93U, "asttype_chain");
        }
      }
    } else {
      {
#line 93
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    93U, "asttype_chain");
      }
    }
  }
  {
#line 93
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 93
  tEmPcast = (AST_generic )tmp;
  }
#line 93
  if (tEmPcast) {
#line 93
    if ((unsigned int )tEmPcast->kind >= 188U) {
#line 93
      if (! ((unsigned int )tEmPcast->kind <= 188U)) {
        {
#line 93
        __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      93U, "asttype_chain");
        }
      }
    } else {
      {
#line 93
      __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    93U, "asttype_chain");
      }
    }
  }
#line 93
  return ((asttype )tEmPcast);
}
}
#line 95 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
typename typename_chain(typename l1 , typename l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 96
  tEmPcast___0 = (AST_generic )l2;
#line 96
  if (tEmPcast___0) {
#line 96
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 96
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 96
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      96U, "typename_chain");
        }
      }
    } else {
      {
#line 96
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    96U, "typename_chain");
      }
    }
  }
#line 96
  tEmPcast___1 = (AST_generic )l1;
#line 96
  if (tEmPcast___1) {
#line 96
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 96
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 96
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      96U, "typename_chain");
        }
      }
    } else {
      {
#line 96
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    96U, "typename_chain");
      }
    }
  }
  {
#line 96
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 96
  tEmPcast = (AST_generic )tmp;
  }
#line 96
  if (tEmPcast) {
#line 96
    if ((unsigned int )tEmPcast->kind >= 158U) {
#line 96
      if (! ((unsigned int )tEmPcast->kind <= 159U)) {
        {
#line 96
        __assert_fail("((tEmPcast)->kind >= kind_typename && (tEmPcast)->kind <= postkind_typename)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      96U, "typename_chain");
        }
      }
    } else {
      {
#line 96
      __assert_fail("((tEmPcast)->kind >= kind_typename && (tEmPcast)->kind <= postkind_typename)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    96U, "typename_chain");
      }
    }
  }
#line 96
  return ((typename )tEmPcast);
}
}
#line 98 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
typeof_expr typeof_expr_chain(typeof_expr l1 , typeof_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 99
  tEmPcast___0 = (AST_generic )l2;
#line 99
  if (tEmPcast___0) {
#line 99
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 99
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 99
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      99U, "typeof_expr_chain");
        }
      }
    } else {
      {
#line 99
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    99U, "typeof_expr_chain");
      }
    }
  }
#line 99
  tEmPcast___1 = (AST_generic )l1;
#line 99
  if (tEmPcast___1) {
#line 99
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 99
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 99
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      99U, "typeof_expr_chain");
        }
      }
    } else {
      {
#line 99
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    99U, "typeof_expr_chain");
      }
    }
  }
  {
#line 99
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 99
  tEmPcast = (AST_generic )tmp;
  }
#line 99
  if (tEmPcast) {
#line 99
    if ((unsigned int )tEmPcast->kind >= 160U) {
#line 99
      if (! ((unsigned int )tEmPcast->kind <= 160U)) {
        {
#line 99
        __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      99U, "typeof_expr_chain");
        }
      }
    } else {
      {
#line 99
      __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    99U, "typeof_expr_chain");
      }
    }
  }
#line 99
  return ((typeof_expr )tEmPcast);
}
}
#line 101 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
typeof_type typeof_type_chain(typeof_type l1 , typeof_type l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 102
  tEmPcast___0 = (AST_generic )l2;
#line 102
  if (tEmPcast___0) {
#line 102
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 102
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 102
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      102U, "typeof_type_chain");
        }
      }
    } else {
      {
#line 102
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    102U, "typeof_type_chain");
      }
    }
  }
#line 102
  tEmPcast___1 = (AST_generic )l1;
#line 102
  if (tEmPcast___1) {
#line 102
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 102
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 102
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      102U, "typeof_type_chain");
        }
      }
    } else {
      {
#line 102
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    102U, "typeof_type_chain");
      }
    }
  }
  {
#line 102
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 102
  tEmPcast = (AST_generic )tmp;
  }
#line 102
  if (tEmPcast) {
#line 102
    if ((unsigned int )tEmPcast->kind >= 161U) {
#line 102
      if (! ((unsigned int )tEmPcast->kind <= 161U)) {
        {
#line 102
        __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      102U, "typeof_type_chain");
        }
      }
    } else {
      {
#line 102
      __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    102U, "typeof_type_chain");
      }
    }
  }
#line 102
  return ((typeof_type )tEmPcast);
}
}
#line 104 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
attribute attribute_chain(attribute l1 , attribute l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 105
  tEmPcast___0 = (AST_generic )l2;
#line 105
  if (tEmPcast___0) {
#line 105
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 105
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 105
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      105U, "attribute_chain");
        }
      }
    } else {
      {
#line 105
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    105U, "attribute_chain");
      }
    }
  }
#line 105
  tEmPcast___1 = (AST_generic )l1;
#line 105
  if (tEmPcast___1) {
#line 105
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 105
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 105
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      105U, "attribute_chain");
        }
      }
    } else {
      {
#line 105
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    105U, "attribute_chain");
      }
    }
  }
  {
#line 105
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 105
  tEmPcast = (AST_generic )tmp;
  }
#line 105
  if (tEmPcast) {
#line 105
    if ((unsigned int )tEmPcast->kind >= 162U) {
#line 105
      if (! ((unsigned int )tEmPcast->kind <= 165U)) {
        {
#line 105
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      105U, "attribute_chain");
        }
      }
    } else {
      {
#line 105
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    105U, "attribute_chain");
      }
    }
  }
#line 105
  return ((attribute )tEmPcast);
}
}
#line 107 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
gcc_attribute gcc_attribute_chain(gcc_attribute l1 , gcc_attribute l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 108
  tEmPcast___0 = (AST_generic )l2;
#line 108
  if (tEmPcast___0) {
#line 108
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 108
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 108
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      108U, "gcc_attribute_chain");
        }
      }
    } else {
      {
#line 108
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    108U, "gcc_attribute_chain");
      }
    }
  }
#line 108
  tEmPcast___1 = (AST_generic )l1;
#line 108
  if (tEmPcast___1) {
#line 108
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 108
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 108
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      108U, "gcc_attribute_chain");
        }
      }
    } else {
      {
#line 108
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    108U, "gcc_attribute_chain");
      }
    }
  }
  {
#line 108
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 108
  tEmPcast = (AST_generic )tmp;
  }
#line 108
  if (tEmPcast) {
#line 108
    if ((unsigned int )tEmPcast->kind >= 163U) {
#line 108
      if (! ((unsigned int )tEmPcast->kind <= 164U)) {
        {
#line 108
        __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      108U, "gcc_attribute_chain");
        }
      }
    } else {
      {
#line 108
      __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    108U, "gcc_attribute_chain");
      }
    }
  }
#line 108
  return ((gcc_attribute )tEmPcast);
}
}
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
rid rid_chain(rid l1 , rid l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 111
  tEmPcast___0 = (AST_generic )l2;
#line 111
  if (tEmPcast___0) {
#line 111
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 111
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 111
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      111U, "rid_chain");
        }
      }
    } else {
      {
#line 111
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    111U, "rid_chain");
      }
    }
  }
#line 111
  tEmPcast___1 = (AST_generic )l1;
#line 111
  if (tEmPcast___1) {
#line 111
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 111
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 111
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      111U, "rid_chain");
        }
      }
    } else {
      {
#line 111
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    111U, "rid_chain");
      }
    }
  }
  {
#line 111
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 111
  tEmPcast = (AST_generic )tmp;
  }
#line 111
  if (tEmPcast) {
#line 111
    if ((unsigned int )tEmPcast->kind >= 166U) {
#line 111
      if (! ((unsigned int )tEmPcast->kind <= 166U)) {
        {
#line 111
        __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      111U, "rid_chain");
        }
      }
    } else {
      {
#line 111
      __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    111U, "rid_chain");
      }
    }
  }
#line 111
  return ((rid )tEmPcast);
}
}
#line 113 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
qualifier qualifier_chain(qualifier l1 , qualifier l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 114
  tEmPcast___0 = (AST_generic )l2;
#line 114
  if (tEmPcast___0) {
#line 114
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 114
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 114
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      114U, "qualifier_chain");
        }
      }
    } else {
      {
#line 114
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    114U, "qualifier_chain");
      }
    }
  }
#line 114
  tEmPcast___1 = (AST_generic )l1;
#line 114
  if (tEmPcast___1) {
#line 114
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 114
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 114
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      114U, "qualifier_chain");
        }
      }
    } else {
      {
#line 114
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    114U, "qualifier_chain");
      }
    }
  }
  {
#line 114
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 114
  tEmPcast = (AST_generic )tmp;
  }
#line 114
  if (tEmPcast) {
#line 114
    if ((unsigned int )tEmPcast->kind >= 167U) {
#line 114
      if (! ((unsigned int )tEmPcast->kind <= 167U)) {
        {
#line 114
        __assert_fail("((tEmPcast)->kind >= kind_qualifier && (tEmPcast)->kind <= postkind_qualifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      114U, "qualifier_chain");
        }
      }
    } else {
      {
#line 114
      __assert_fail("((tEmPcast)->kind >= kind_qualifier && (tEmPcast)->kind <= postkind_qualifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    114U, "qualifier_chain");
      }
    }
  }
#line 114
  return ((qualifier )tEmPcast);
}
}
#line 116 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
tag_ref tag_ref_chain(tag_ref l1 , tag_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 117
  tEmPcast___0 = (AST_generic )l2;
#line 117
  if (tEmPcast___0) {
#line 117
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 117
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 117
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      117U, "tag_ref_chain");
        }
      }
    } else {
      {
#line 117
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    117U, "tag_ref_chain");
      }
    }
  }
#line 117
  tEmPcast___1 = (AST_generic )l1;
#line 117
  if (tEmPcast___1) {
#line 117
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 117
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 117
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      117U, "tag_ref_chain");
        }
      }
    } else {
      {
#line 117
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    117U, "tag_ref_chain");
      }
    }
  }
  {
#line 117
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 117
  tEmPcast = (AST_generic )tmp;
  }
#line 117
  if (tEmPcast) {
#line 117
    if ((unsigned int )tEmPcast->kind >= 168U) {
#line 117
      if (! ((unsigned int )tEmPcast->kind <= 174U)) {
        {
#line 117
        __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      117U, "tag_ref_chain");
        }
      }
    } else {
      {
#line 117
      __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    117U, "tag_ref_chain");
      }
    }
  }
#line 117
  return ((tag_ref )tEmPcast);
}
}
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
struct_ref struct_ref_chain(struct_ref l1 , struct_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 120
  tEmPcast___0 = (AST_generic )l2;
#line 120
  if (tEmPcast___0) {
#line 120
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 120
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 120
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      120U, "struct_ref_chain");
        }
      }
    } else {
      {
#line 120
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    120U, "struct_ref_chain");
      }
    }
  }
#line 120
  tEmPcast___1 = (AST_generic )l1;
#line 120
  if (tEmPcast___1) {
#line 120
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 120
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 120
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      120U, "struct_ref_chain");
        }
      }
    } else {
      {
#line 120
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    120U, "struct_ref_chain");
      }
    }
  }
  {
#line 120
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 120
  tEmPcast = (AST_generic )tmp;
  }
#line 120
  if (tEmPcast) {
#line 120
    if ((unsigned int )tEmPcast->kind >= 169U) {
#line 120
      if (! ((unsigned int )tEmPcast->kind <= 170U)) {
        {
#line 120
        __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      120U, "struct_ref_chain");
        }
      }
    } else {
      {
#line 120
      __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    120U, "struct_ref_chain");
      }
    }
  }
#line 120
  return ((struct_ref )tEmPcast);
}
}
#line 122 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
union_ref union_ref_chain(union_ref l1 , union_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 123
  tEmPcast___0 = (AST_generic )l2;
#line 123
  if (tEmPcast___0) {
#line 123
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 123
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 123
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      123U, "union_ref_chain");
        }
      }
    } else {
      {
#line 123
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    123U, "union_ref_chain");
      }
    }
  }
#line 123
  tEmPcast___1 = (AST_generic )l1;
#line 123
  if (tEmPcast___1) {
#line 123
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 123
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 123
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      123U, "union_ref_chain");
        }
      }
    } else {
      {
#line 123
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    123U, "union_ref_chain");
      }
    }
  }
  {
#line 123
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 123
  tEmPcast = (AST_generic )tmp;
  }
#line 123
  if (tEmPcast) {
#line 123
    if ((unsigned int )tEmPcast->kind >= 171U) {
#line 123
      if (! ((unsigned int )tEmPcast->kind <= 172U)) {
        {
#line 123
        __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      123U, "union_ref_chain");
        }
      }
    } else {
      {
#line 123
      __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    123U, "union_ref_chain");
      }
    }
  }
#line 123
  return ((union_ref )tEmPcast);
}
}
#line 125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
nested_declarator nested_declarator_chain(nested_declarator l1 , nested_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 126
  tEmPcast___0 = (AST_generic )l2;
#line 126
  if (tEmPcast___0) {
#line 126
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 126
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 126
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      126U, "nested_declarator_chain");
        }
      }
    } else {
      {
#line 126
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    126U, "nested_declarator_chain");
      }
    }
  }
#line 126
  tEmPcast___1 = (AST_generic )l1;
#line 126
  if (tEmPcast___1) {
#line 126
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 126
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 126
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      126U, "nested_declarator_chain");
        }
      }
    } else {
      {
#line 126
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    126U, "nested_declarator_chain");
      }
    }
  }
  {
#line 126
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 126
  tEmPcast = (AST_generic )tmp;
  }
#line 126
  if (tEmPcast) {
#line 126
    if ((unsigned int )tEmPcast->kind >= 176U) {
#line 126
      if (! ((unsigned int )tEmPcast->kind <= 181U)) {
        {
#line 126
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      126U, "nested_declarator_chain");
        }
      }
    } else {
      {
#line 126
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    126U, "nested_declarator_chain");
      }
    }
  }
#line 126
  return ((nested_declarator )tEmPcast);
}
}
#line 128 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
function_declarator function_declarator_chain(function_declarator l1 , function_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 129
  tEmPcast___0 = (AST_generic )l2;
#line 129
  if (tEmPcast___0) {
#line 129
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 129
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 129
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      129U, "function_declarator_chain");
        }
      }
    } else {
      {
#line 129
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    129U, "function_declarator_chain");
      }
    }
  }
#line 129
  tEmPcast___1 = (AST_generic )l1;
#line 129
  if (tEmPcast___1) {
#line 129
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 129
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 129
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      129U, "function_declarator_chain");
        }
      }
    } else {
      {
#line 129
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    129U, "function_declarator_chain");
      }
    }
  }
  {
#line 129
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 129
  tEmPcast = (AST_generic )tmp;
  }
#line 129
  if (tEmPcast) {
#line 129
    if ((unsigned int )tEmPcast->kind >= 177U) {
#line 129
      if (! ((unsigned int )tEmPcast->kind <= 177U)) {
        {
#line 129
        __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      129U, "function_declarator_chain");
        }
      }
    } else {
      {
#line 129
      __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    129U, "function_declarator_chain");
      }
    }
  }
#line 129
  return ((function_declarator )tEmPcast);
}
}
#line 131 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
pointer_declarator pointer_declarator_chain(pointer_declarator l1 , pointer_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 132
  tEmPcast___0 = (AST_generic )l2;
#line 132
  if (tEmPcast___0) {
#line 132
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 132
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 132
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      132U, "pointer_declarator_chain");
        }
      }
    } else {
      {
#line 132
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    132U, "pointer_declarator_chain");
      }
    }
  }
#line 132
  tEmPcast___1 = (AST_generic )l1;
#line 132
  if (tEmPcast___1) {
#line 132
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 132
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 132
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      132U, "pointer_declarator_chain");
        }
      }
    } else {
      {
#line 132
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    132U, "pointer_declarator_chain");
      }
    }
  }
  {
#line 132
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 132
  tEmPcast = (AST_generic )tmp;
  }
#line 132
  if (tEmPcast) {
#line 132
    if ((unsigned int )tEmPcast->kind >= 178U) {
#line 132
      if (! ((unsigned int )tEmPcast->kind <= 178U)) {
        {
#line 132
        __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      132U, "pointer_declarator_chain");
        }
      }
    } else {
      {
#line 132
      __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    132U, "pointer_declarator_chain");
      }
    }
  }
#line 132
  return ((pointer_declarator )tEmPcast);
}
}
#line 134 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
qualified_declarator qualified_declarator_chain(qualified_declarator l1 , qualified_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 135
  tEmPcast___0 = (AST_generic )l2;
#line 135
  if (tEmPcast___0) {
#line 135
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 135
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 135
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      135U, "qualified_declarator_chain");
        }
      }
    } else {
      {
#line 135
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    135U, "qualified_declarator_chain");
      }
    }
  }
#line 135
  tEmPcast___1 = (AST_generic )l1;
#line 135
  if (tEmPcast___1) {
#line 135
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 135
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 135
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      135U, "qualified_declarator_chain");
        }
      }
    } else {
      {
#line 135
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    135U, "qualified_declarator_chain");
      }
    }
  }
  {
#line 135
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 135
  tEmPcast = (AST_generic )tmp;
  }
#line 135
  if (tEmPcast) {
#line 135
    if ((unsigned int )tEmPcast->kind >= 179U) {
#line 135
      if (! ((unsigned int )tEmPcast->kind <= 179U)) {
        {
#line 135
        __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      135U, "qualified_declarator_chain");
        }
      }
    } else {
      {
#line 135
      __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    135U, "qualified_declarator_chain");
      }
    }
  }
#line 135
  return ((qualified_declarator )tEmPcast);
}
}
#line 137 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
array_declarator array_declarator_chain(array_declarator l1 , array_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 138
  tEmPcast___0 = (AST_generic )l2;
#line 138
  if (tEmPcast___0) {
#line 138
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 138
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 138
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      138U, "array_declarator_chain");
        }
      }
    } else {
      {
#line 138
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    138U, "array_declarator_chain");
      }
    }
  }
#line 138
  tEmPcast___1 = (AST_generic )l1;
#line 138
  if (tEmPcast___1) {
#line 138
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 138
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 138
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      138U, "array_declarator_chain");
        }
      }
    } else {
      {
#line 138
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    138U, "array_declarator_chain");
      }
    }
  }
  {
#line 138
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 138
  tEmPcast = (AST_generic )tmp;
  }
#line 138
  if (tEmPcast) {
#line 138
    if ((unsigned int )tEmPcast->kind >= 180U) {
#line 138
      if (! ((unsigned int )tEmPcast->kind <= 180U)) {
        {
#line 138
        __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      138U, "array_declarator_chain");
        }
      }
    } else {
      {
#line 138
      __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    138U, "array_declarator_chain");
      }
    }
  }
#line 138
  return ((array_declarator )tEmPcast);
}
}
#line 140 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
identifier_declarator identifier_declarator_chain(identifier_declarator l1 , identifier_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 141
  tEmPcast___0 = (AST_generic )l2;
#line 141
  if (tEmPcast___0) {
#line 141
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 141
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      141U, "identifier_declarator_chain");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    141U, "identifier_declarator_chain");
      }
    }
  }
#line 141
  tEmPcast___1 = (AST_generic )l1;
#line 141
  if (tEmPcast___1) {
#line 141
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 141
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      141U, "identifier_declarator_chain");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    141U, "identifier_declarator_chain");
      }
    }
  }
  {
#line 141
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 141
  tEmPcast = (AST_generic )tmp;
  }
#line 141
  if (tEmPcast) {
#line 141
    if ((unsigned int )tEmPcast->kind >= 182U) {
#line 141
      if (! ((unsigned int )tEmPcast->kind <= 182U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      141U, "identifier_declarator_chain");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    141U, "identifier_declarator_chain");
      }
    }
  }
#line 141
  return ((identifier_declarator )tEmPcast);
}
}
#line 143 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
asm_stmt asm_stmt_chain(asm_stmt l1 , asm_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 144
  tEmPcast___0 = (AST_generic )l2;
#line 144
  if (tEmPcast___0) {
#line 144
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 144
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 144
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      144U, "asm_stmt_chain");
        }
      }
    } else {
      {
#line 144
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    144U, "asm_stmt_chain");
      }
    }
  }
#line 144
  tEmPcast___1 = (AST_generic )l1;
#line 144
  if (tEmPcast___1) {
#line 144
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 144
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 144
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      144U, "asm_stmt_chain");
        }
      }
    } else {
      {
#line 144
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    144U, "asm_stmt_chain");
      }
    }
  }
  {
#line 144
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 144
  tEmPcast = (AST_generic )tmp;
  }
#line 144
  if (tEmPcast) {
#line 144
    if ((unsigned int )tEmPcast->kind >= 66U) {
#line 144
      if (! ((unsigned int )tEmPcast->kind <= 66U)) {
        {
#line 144
        __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      144U, "asm_stmt_chain");
        }
      }
    } else {
      {
#line 144
      __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    144U, "asm_stmt_chain");
      }
    }
  }
#line 144
  return ((asm_stmt )tEmPcast);
}
}
#line 146 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
compound_stmt compound_stmt_chain(compound_stmt l1 , compound_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 147
  tEmPcast___0 = (AST_generic )l2;
#line 147
  if (tEmPcast___0) {
#line 147
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 147
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 147
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      147U, "compound_stmt_chain");
        }
      }
    } else {
      {
#line 147
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    147U, "compound_stmt_chain");
      }
    }
  }
#line 147
  tEmPcast___1 = (AST_generic )l1;
#line 147
  if (tEmPcast___1) {
#line 147
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 147
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 147
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      147U, "compound_stmt_chain");
        }
      }
    } else {
      {
#line 147
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    147U, "compound_stmt_chain");
      }
    }
  }
  {
#line 147
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 147
  tEmPcast = (AST_generic )tmp;
  }
#line 147
  if (tEmPcast) {
#line 147
    if ((unsigned int )tEmPcast->kind >= 67U) {
#line 147
      if (! ((unsigned int )tEmPcast->kind <= 67U)) {
        {
#line 147
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      147U, "compound_stmt_chain");
        }
      }
    } else {
      {
#line 147
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    147U, "compound_stmt_chain");
      }
    }
  }
#line 147
  return ((compound_stmt )tEmPcast);
}
}
#line 149 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
if_stmt if_stmt_chain(if_stmt l1 , if_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 150
  tEmPcast___0 = (AST_generic )l2;
#line 150
  if (tEmPcast___0) {
#line 150
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 150
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 150
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      150U, "if_stmt_chain");
        }
      }
    } else {
      {
#line 150
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    150U, "if_stmt_chain");
      }
    }
  }
#line 150
  tEmPcast___1 = (AST_generic )l1;
#line 150
  if (tEmPcast___1) {
#line 150
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 150
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 150
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      150U, "if_stmt_chain");
        }
      }
    } else {
      {
#line 150
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    150U, "if_stmt_chain");
      }
    }
  }
  {
#line 150
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 150
  tEmPcast = (AST_generic )tmp;
  }
#line 150
  if (tEmPcast) {
#line 150
    if ((unsigned int )tEmPcast->kind >= 68U) {
#line 150
      if (! ((unsigned int )tEmPcast->kind <= 68U)) {
        {
#line 150
        __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      150U, "if_stmt_chain");
        }
      }
    } else {
      {
#line 150
      __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    150U, "if_stmt_chain");
      }
    }
  }
#line 150
  return ((if_stmt )tEmPcast);
}
}
#line 152 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
labeled_stmt labeled_stmt_chain(labeled_stmt l1 , labeled_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 153
  tEmPcast___0 = (AST_generic )l2;
#line 153
  if (tEmPcast___0) {
#line 153
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 153
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 153
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      153U, "labeled_stmt_chain");
        }
      }
    } else {
      {
#line 153
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    153U, "labeled_stmt_chain");
      }
    }
  }
#line 153
  tEmPcast___1 = (AST_generic )l1;
#line 153
  if (tEmPcast___1) {
#line 153
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 153
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 153
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      153U, "labeled_stmt_chain");
        }
      }
    } else {
      {
#line 153
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    153U, "labeled_stmt_chain");
      }
    }
  }
  {
#line 153
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 153
  tEmPcast = (AST_generic )tmp;
  }
#line 153
  if (tEmPcast) {
#line 153
    if ((unsigned int )tEmPcast->kind >= 69U) {
#line 153
      if (! ((unsigned int )tEmPcast->kind <= 69U)) {
        {
#line 153
        __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      153U, "labeled_stmt_chain");
        }
      }
    } else {
      {
#line 153
      __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    153U, "labeled_stmt_chain");
      }
    }
  }
#line 153
  return ((labeled_stmt )tEmPcast);
}
}
#line 155 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
expression_stmt expression_stmt_chain(expression_stmt l1 , expression_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 156
  tEmPcast___0 = (AST_generic )l2;
#line 156
  if (tEmPcast___0) {
#line 156
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 156
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 156
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      156U, "expression_stmt_chain");
        }
      }
    } else {
      {
#line 156
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    156U, "expression_stmt_chain");
      }
    }
  }
#line 156
  tEmPcast___1 = (AST_generic )l1;
#line 156
  if (tEmPcast___1) {
#line 156
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 156
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 156
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      156U, "expression_stmt_chain");
        }
      }
    } else {
      {
#line 156
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    156U, "expression_stmt_chain");
      }
    }
  }
  {
#line 156
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 156
  tEmPcast = (AST_generic )tmp;
  }
#line 156
  if (tEmPcast) {
#line 156
    if ((unsigned int )tEmPcast->kind >= 70U) {
#line 156
      if (! ((unsigned int )tEmPcast->kind <= 70U)) {
        {
#line 156
        __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      156U, "expression_stmt_chain");
        }
      }
    } else {
      {
#line 156
      __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    156U, "expression_stmt_chain");
      }
    }
  }
#line 156
  return ((expression_stmt )tEmPcast);
}
}
#line 158 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
conditional_stmt conditional_stmt_chain(conditional_stmt l1 , conditional_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 159
  tEmPcast___0 = (AST_generic )l2;
#line 159
  if (tEmPcast___0) {
#line 159
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 159
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 159
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      159U, "conditional_stmt_chain");
        }
      }
    } else {
      {
#line 159
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    159U, "conditional_stmt_chain");
      }
    }
  }
#line 159
  tEmPcast___1 = (AST_generic )l1;
#line 159
  if (tEmPcast___1) {
#line 159
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 159
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 159
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      159U, "conditional_stmt_chain");
        }
      }
    } else {
      {
#line 159
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    159U, "conditional_stmt_chain");
      }
    }
  }
  {
#line 159
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 159
  tEmPcast = (AST_generic )tmp;
  }
#line 159
  if (tEmPcast) {
#line 159
    if ((unsigned int )tEmPcast->kind >= 71U) {
#line 159
      if (! ((unsigned int )tEmPcast->kind <= 74U)) {
        {
#line 159
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      159U, "conditional_stmt_chain");
        }
      }
    } else {
      {
#line 159
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    159U, "conditional_stmt_chain");
      }
    }
  }
#line 159
  return ((conditional_stmt )tEmPcast);
}
}
#line 161 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
switch_stmt switch_stmt_chain(switch_stmt l1 , switch_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 162
  tEmPcast___0 = (AST_generic )l2;
#line 162
  if (tEmPcast___0) {
#line 162
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 162
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 162
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      162U, "switch_stmt_chain");
        }
      }
    } else {
      {
#line 162
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    162U, "switch_stmt_chain");
      }
    }
  }
#line 162
  tEmPcast___1 = (AST_generic )l1;
#line 162
  if (tEmPcast___1) {
#line 162
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 162
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 162
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      162U, "switch_stmt_chain");
        }
      }
    } else {
      {
#line 162
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    162U, "switch_stmt_chain");
      }
    }
  }
  {
#line 162
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 162
  tEmPcast = (AST_generic )tmp;
  }
#line 162
  if (tEmPcast) {
#line 162
    if ((unsigned int )tEmPcast->kind >= 72U) {
#line 162
      if (! ((unsigned int )tEmPcast->kind <= 72U)) {
        {
#line 162
        __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      162U, "switch_stmt_chain");
        }
      }
    } else {
      {
#line 162
      __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    162U, "switch_stmt_chain");
      }
    }
  }
#line 162
  return ((switch_stmt )tEmPcast);
}
}
#line 164 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
for_stmt for_stmt_chain(for_stmt l1 , for_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 165
  tEmPcast___0 = (AST_generic )l2;
#line 165
  if (tEmPcast___0) {
#line 165
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 165
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 165
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      165U, "for_stmt_chain");
        }
      }
    } else {
      {
#line 165
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    165U, "for_stmt_chain");
      }
    }
  }
#line 165
  tEmPcast___1 = (AST_generic )l1;
#line 165
  if (tEmPcast___1) {
#line 165
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 165
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 165
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      165U, "for_stmt_chain");
        }
      }
    } else {
      {
#line 165
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    165U, "for_stmt_chain");
      }
    }
  }
  {
#line 165
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 165
  tEmPcast = (AST_generic )tmp;
  }
#line 165
  if (tEmPcast) {
#line 165
    if ((unsigned int )tEmPcast->kind >= 75U) {
#line 165
      if (! ((unsigned int )tEmPcast->kind <= 75U)) {
        {
#line 165
        __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      165U, "for_stmt_chain");
        }
      }
    } else {
      {
#line 165
      __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    165U, "for_stmt_chain");
      }
    }
  }
#line 165
  return ((for_stmt )tEmPcast);
}
}
#line 167 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
break_stmt break_stmt_chain(break_stmt l1 , break_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 168
  tEmPcast___0 = (AST_generic )l2;
#line 168
  if (tEmPcast___0) {
#line 168
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 168
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 168
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      168U, "break_stmt_chain");
        }
      }
    } else {
      {
#line 168
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    168U, "break_stmt_chain");
      }
    }
  }
#line 168
  tEmPcast___1 = (AST_generic )l1;
#line 168
  if (tEmPcast___1) {
#line 168
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 168
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 168
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      168U, "break_stmt_chain");
        }
      }
    } else {
      {
#line 168
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    168U, "break_stmt_chain");
      }
    }
  }
  {
#line 168
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 168
  tEmPcast = (AST_generic )tmp;
  }
#line 168
  if (tEmPcast) {
#line 168
    if ((unsigned int )tEmPcast->kind >= 76U) {
#line 168
      if (! ((unsigned int )tEmPcast->kind <= 76U)) {
        {
#line 168
        __assert_fail("((tEmPcast)->kind >= kind_break_stmt && (tEmPcast)->kind <= postkind_break_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      168U, "break_stmt_chain");
        }
      }
    } else {
      {
#line 168
      __assert_fail("((tEmPcast)->kind >= kind_break_stmt && (tEmPcast)->kind <= postkind_break_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    168U, "break_stmt_chain");
      }
    }
  }
#line 168
  return ((break_stmt )tEmPcast);
}
}
#line 170 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
continue_stmt continue_stmt_chain(continue_stmt l1 , continue_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 171
  tEmPcast___0 = (AST_generic )l2;
#line 171
  if (tEmPcast___0) {
#line 171
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 171
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 171
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      171U, "continue_stmt_chain");
        }
      }
    } else {
      {
#line 171
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    171U, "continue_stmt_chain");
      }
    }
  }
#line 171
  tEmPcast___1 = (AST_generic )l1;
#line 171
  if (tEmPcast___1) {
#line 171
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 171
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 171
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      171U, "continue_stmt_chain");
        }
      }
    } else {
      {
#line 171
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    171U, "continue_stmt_chain");
      }
    }
  }
  {
#line 171
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 171
  tEmPcast = (AST_generic )tmp;
  }
#line 171
  if (tEmPcast) {
#line 171
    if ((unsigned int )tEmPcast->kind >= 77U) {
#line 171
      if (! ((unsigned int )tEmPcast->kind <= 77U)) {
        {
#line 171
        __assert_fail("((tEmPcast)->kind >= kind_continue_stmt && (tEmPcast)->kind <= postkind_continue_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      171U, "continue_stmt_chain");
        }
      }
    } else {
      {
#line 171
      __assert_fail("((tEmPcast)->kind >= kind_continue_stmt && (tEmPcast)->kind <= postkind_continue_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    171U, "continue_stmt_chain");
      }
    }
  }
#line 171
  return ((continue_stmt )tEmPcast);
}
}
#line 173 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
return_stmt return_stmt_chain(return_stmt l1 , return_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 174
  tEmPcast___0 = (AST_generic )l2;
#line 174
  if (tEmPcast___0) {
#line 174
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 174
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 174
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      174U, "return_stmt_chain");
        }
      }
    } else {
      {
#line 174
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    174U, "return_stmt_chain");
      }
    }
  }
#line 174
  tEmPcast___1 = (AST_generic )l1;
#line 174
  if (tEmPcast___1) {
#line 174
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 174
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 174
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      174U, "return_stmt_chain");
        }
      }
    } else {
      {
#line 174
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    174U, "return_stmt_chain");
      }
    }
  }
  {
#line 174
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 174
  tEmPcast = (AST_generic )tmp;
  }
#line 174
  if (tEmPcast) {
#line 174
    if ((unsigned int )tEmPcast->kind >= 78U) {
#line 174
      if (! ((unsigned int )tEmPcast->kind <= 78U)) {
        {
#line 174
        __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      174U, "return_stmt_chain");
        }
      }
    } else {
      {
#line 174
      __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    174U, "return_stmt_chain");
      }
    }
  }
#line 174
  return ((return_stmt )tEmPcast);
}
}
#line 176 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
goto_stmt goto_stmt_chain(goto_stmt l1 , goto_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 177
  tEmPcast___0 = (AST_generic )l2;
#line 177
  if (tEmPcast___0) {
#line 177
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 177
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 177
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      177U, "goto_stmt_chain");
        }
      }
    } else {
      {
#line 177
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    177U, "goto_stmt_chain");
      }
    }
  }
#line 177
  tEmPcast___1 = (AST_generic )l1;
#line 177
  if (tEmPcast___1) {
#line 177
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 177
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 177
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      177U, "goto_stmt_chain");
        }
      }
    } else {
      {
#line 177
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    177U, "goto_stmt_chain");
      }
    }
  }
  {
#line 177
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 177
  tEmPcast = (AST_generic )tmp;
  }
#line 177
  if (tEmPcast) {
#line 177
    if ((unsigned int )tEmPcast->kind >= 79U) {
#line 177
      if (! ((unsigned int )tEmPcast->kind <= 79U)) {
        {
#line 177
        __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      177U, "goto_stmt_chain");
        }
      }
    } else {
      {
#line 177
      __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    177U, "goto_stmt_chain");
      }
    }
  }
#line 177
  return ((goto_stmt )tEmPcast);
}
}
#line 179 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
computed_goto_stmt computed_goto_stmt_chain(computed_goto_stmt l1 , computed_goto_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 180
  tEmPcast___0 = (AST_generic )l2;
#line 180
  if (tEmPcast___0) {
#line 180
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 180
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 180
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      180U, "computed_goto_stmt_chain");
        }
      }
    } else {
      {
#line 180
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    180U, "computed_goto_stmt_chain");
      }
    }
  }
#line 180
  tEmPcast___1 = (AST_generic )l1;
#line 180
  if (tEmPcast___1) {
#line 180
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 180
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 180
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      180U, "computed_goto_stmt_chain");
        }
      }
    } else {
      {
#line 180
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    180U, "computed_goto_stmt_chain");
      }
    }
  }
  {
#line 180
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 180
  tEmPcast = (AST_generic )tmp;
  }
#line 180
  if (tEmPcast) {
#line 180
    if ((unsigned int )tEmPcast->kind >= 80U) {
#line 180
      if (! ((unsigned int )tEmPcast->kind <= 80U)) {
        {
#line 180
        __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      180U, "computed_goto_stmt_chain");
        }
      }
    } else {
      {
#line 180
      __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    180U, "computed_goto_stmt_chain");
      }
    }
  }
#line 180
  return ((computed_goto_stmt )tEmPcast);
}
}
#line 182 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
empty_stmt empty_stmt_chain(empty_stmt l1 , empty_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 183
  tEmPcast___0 = (AST_generic )l2;
#line 183
  if (tEmPcast___0) {
#line 183
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 183
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 183
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      183U, "empty_stmt_chain");
        }
      }
    } else {
      {
#line 183
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    183U, "empty_stmt_chain");
      }
    }
  }
#line 183
  tEmPcast___1 = (AST_generic )l1;
#line 183
  if (tEmPcast___1) {
#line 183
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 183
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 183
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      183U, "empty_stmt_chain");
        }
      }
    } else {
      {
#line 183
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    183U, "empty_stmt_chain");
      }
    }
  }
  {
#line 183
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 183
  tEmPcast = (AST_generic )tmp;
  }
#line 183
  if (tEmPcast) {
#line 183
    if ((unsigned int )tEmPcast->kind >= 81U) {
#line 183
      if (! ((unsigned int )tEmPcast->kind <= 81U)) {
        {
#line 183
        __assert_fail("((tEmPcast)->kind >= kind_empty_stmt && (tEmPcast)->kind <= postkind_empty_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      183U, "empty_stmt_chain");
        }
      }
    } else {
      {
#line 183
      __assert_fail("((tEmPcast)->kind >= kind_empty_stmt && (tEmPcast)->kind <= postkind_empty_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    183U, "empty_stmt_chain");
      }
    }
  }
#line 183
  return ((empty_stmt )tEmPcast);
}
}
#line 185 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
unary unary_chain(unary l1 , unary l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 186
  tEmPcast___0 = (AST_generic )l2;
#line 186
  if (tEmPcast___0) {
#line 186
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 186
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 186
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      186U, "unary_chain");
        }
      }
    } else {
      {
#line 186
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    186U, "unary_chain");
      }
    }
  }
#line 186
  tEmPcast___1 = (AST_generic )l1;
#line 186
  if (tEmPcast___1) {
#line 186
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 186
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 186
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      186U, "unary_chain");
        }
      }
    } else {
      {
#line 186
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    186U, "unary_chain");
      }
    }
  }
  {
#line 186
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 186
  tEmPcast = (AST_generic )tmp;
  }
#line 186
  if (tEmPcast) {
#line 186
    if ((unsigned int )tEmPcast->kind >= 85U) {
#line 186
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 186
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      186U, "unary_chain");
        }
      }
    } else {
      {
#line 186
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    186U, "unary_chain");
      }
    }
  }
#line 186
  return ((unary )tEmPcast);
}
}
#line 188 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
binary binary_chain(binary l1 , binary l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 189
  tEmPcast___0 = (AST_generic )l2;
#line 189
  if (tEmPcast___0) {
#line 189
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 189
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 189
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      189U, "binary_chain");
        }
      }
    } else {
      {
#line 189
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    189U, "binary_chain");
      }
    }
  }
#line 189
  tEmPcast___1 = (AST_generic )l1;
#line 189
  if (tEmPcast___1) {
#line 189
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 189
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 189
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      189U, "binary_chain");
        }
      }
    } else {
      {
#line 189
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    189U, "binary_chain");
      }
    }
  }
  {
#line 189
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 189
  tEmPcast = (AST_generic )tmp;
  }
#line 189
  if (tEmPcast) {
#line 189
    if ((unsigned int )tEmPcast->kind >= 107U) {
#line 189
      if (! ((unsigned int )tEmPcast->kind <= 139U)) {
        {
#line 189
        __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      189U, "binary_chain");
        }
      }
    } else {
      {
#line 189
      __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    189U, "binary_chain");
      }
    }
  }
#line 189
  return ((binary )tEmPcast);
}
}
#line 191 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
comma comma_chain(comma l1 , comma l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 192
  tEmPcast___0 = (AST_generic )l2;
#line 192
  if (tEmPcast___0) {
#line 192
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 192
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 192
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      192U, "comma_chain");
        }
      }
    } else {
      {
#line 192
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    192U, "comma_chain");
      }
    }
  }
#line 192
  tEmPcast___1 = (AST_generic )l1;
#line 192
  if (tEmPcast___1) {
#line 192
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 192
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 192
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      192U, "comma_chain");
        }
      }
    } else {
      {
#line 192
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    192U, "comma_chain");
      }
    }
  }
  {
#line 192
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 192
  tEmPcast = (AST_generic )tmp;
  }
#line 192
  if (tEmPcast) {
#line 192
    if ((unsigned int )tEmPcast->kind >= 140U) {
#line 192
      if (! ((unsigned int )tEmPcast->kind <= 140U)) {
        {
#line 192
        __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      192U, "comma_chain");
        }
      }
    } else {
      {
#line 192
      __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    192U, "comma_chain");
      }
    }
  }
#line 192
  return ((comma )tEmPcast);
}
}
#line 194 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
sizeof_type sizeof_type_chain(sizeof_type l1 , sizeof_type l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 195
  tEmPcast___0 = (AST_generic )l2;
#line 195
  if (tEmPcast___0) {
#line 195
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 195
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 195
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      195U, "sizeof_type_chain");
        }
      }
    } else {
      {
#line 195
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    195U, "sizeof_type_chain");
      }
    }
  }
#line 195
  tEmPcast___1 = (AST_generic )l1;
#line 195
  if (tEmPcast___1) {
#line 195
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 195
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 195
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      195U, "sizeof_type_chain");
        }
      }
    } else {
      {
#line 195
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    195U, "sizeof_type_chain");
      }
    }
  }
  {
#line 195
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 195
  tEmPcast = (AST_generic )tmp;
  }
#line 195
  if (tEmPcast) {
#line 195
    if ((unsigned int )tEmPcast->kind >= 141U) {
#line 195
      if (! ((unsigned int )tEmPcast->kind <= 141U)) {
        {
#line 195
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      195U, "sizeof_type_chain");
        }
      }
    } else {
      {
#line 195
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    195U, "sizeof_type_chain");
      }
    }
  }
#line 195
  return ((sizeof_type )tEmPcast);
}
}
#line 197 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
alignof_type alignof_type_chain(alignof_type l1 , alignof_type l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 198
  tEmPcast___0 = (AST_generic )l2;
#line 198
  if (tEmPcast___0) {
#line 198
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 198
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 198
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      198U, "alignof_type_chain");
        }
      }
    } else {
      {
#line 198
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    198U, "alignof_type_chain");
      }
    }
  }
#line 198
  tEmPcast___1 = (AST_generic )l1;
#line 198
  if (tEmPcast___1) {
#line 198
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 198
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 198
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      198U, "alignof_type_chain");
        }
      }
    } else {
      {
#line 198
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    198U, "alignof_type_chain");
      }
    }
  }
  {
#line 198
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 198
  tEmPcast = (AST_generic )tmp;
  }
#line 198
  if (tEmPcast) {
#line 198
    if ((unsigned int )tEmPcast->kind >= 142U) {
#line 198
      if (! ((unsigned int )tEmPcast->kind <= 142U)) {
        {
#line 198
        __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      198U, "alignof_type_chain");
        }
      }
    } else {
      {
#line 198
      __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    198U, "alignof_type_chain");
      }
    }
  }
#line 198
  return ((alignof_type )tEmPcast);
}
}
#line 200 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
label_address label_address_chain(label_address l1 , label_address l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 201
  tEmPcast___0 = (AST_generic )l2;
#line 201
  if (tEmPcast___0) {
#line 201
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 201
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 201
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      201U, "label_address_chain");
        }
      }
    } else {
      {
#line 201
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    201U, "label_address_chain");
      }
    }
  }
#line 201
  tEmPcast___1 = (AST_generic )l1;
#line 201
  if (tEmPcast___1) {
#line 201
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 201
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 201
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      201U, "label_address_chain");
        }
      }
    } else {
      {
#line 201
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    201U, "label_address_chain");
      }
    }
  }
  {
#line 201
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 201
  tEmPcast = (AST_generic )tmp;
  }
#line 201
  if (tEmPcast) {
#line 201
    if ((unsigned int )tEmPcast->kind >= 143U) {
#line 201
      if (! ((unsigned int )tEmPcast->kind <= 143U)) {
        {
#line 201
        __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      201U, "label_address_chain");
        }
      }
    } else {
      {
#line 201
      __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    201U, "label_address_chain");
      }
    }
  }
#line 201
  return ((label_address )tEmPcast);
}
}
#line 203 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
cast cast_chain(cast l1 , cast l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 204
  tEmPcast___0 = (AST_generic )l2;
#line 204
  if (tEmPcast___0) {
#line 204
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 204
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 204
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      204U, "cast_chain");
        }
      }
    } else {
      {
#line 204
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    204U, "cast_chain");
      }
    }
  }
#line 204
  tEmPcast___1 = (AST_generic )l1;
#line 204
  if (tEmPcast___1) {
#line 204
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 204
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 204
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      204U, "cast_chain");
        }
      }
    } else {
      {
#line 204
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    204U, "cast_chain");
      }
    }
  }
  {
#line 204
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 204
  tEmPcast = (AST_generic )tmp;
  }
#line 204
  if (tEmPcast) {
#line 204
    if ((unsigned int )tEmPcast->kind >= 86U) {
#line 204
      if (! ((unsigned int )tEmPcast->kind <= 86U)) {
        {
#line 204
        __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      204U, "cast_chain");
        }
      }
    } else {
      {
#line 204
      __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    204U, "cast_chain");
      }
    }
  }
#line 204
  return ((cast )tEmPcast);
}
}
#line 206 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
cast_list cast_list_chain(cast_list l1 , cast_list l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 207
  tEmPcast___0 = (AST_generic )l2;
#line 207
  if (tEmPcast___0) {
#line 207
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 207
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 207
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      207U, "cast_list_chain");
        }
      }
    } else {
      {
#line 207
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    207U, "cast_list_chain");
      }
    }
  }
#line 207
  tEmPcast___1 = (AST_generic )l1;
#line 207
  if (tEmPcast___1) {
#line 207
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 207
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 207
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      207U, "cast_list_chain");
        }
      }
    } else {
      {
#line 207
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    207U, "cast_list_chain");
      }
    }
  }
  {
#line 207
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 207
  tEmPcast = (AST_generic )tmp;
  }
#line 207
  if (tEmPcast) {
#line 207
    if ((unsigned int )tEmPcast->kind >= 144U) {
#line 207
      if (! ((unsigned int )tEmPcast->kind <= 144U)) {
        {
#line 207
        __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      207U, "cast_list_chain");
        }
      }
    } else {
      {
#line 207
      __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    207U, "cast_list_chain");
      }
    }
  }
#line 207
  return ((cast_list )tEmPcast);
}
}
#line 209 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
conditional conditional_chain(conditional l1 , conditional l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 210
  tEmPcast___0 = (AST_generic )l2;
#line 210
  if (tEmPcast___0) {
#line 210
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 210
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 210
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      210U, "conditional_chain");
        }
      }
    } else {
      {
#line 210
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    210U, "conditional_chain");
      }
    }
  }
#line 210
  tEmPcast___1 = (AST_generic )l1;
#line 210
  if (tEmPcast___1) {
#line 210
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 210
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 210
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      210U, "conditional_chain");
        }
      }
    } else {
      {
#line 210
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    210U, "conditional_chain");
      }
    }
  }
  {
#line 210
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 210
  tEmPcast = (AST_generic )tmp;
  }
#line 210
  if (tEmPcast) {
#line 210
    if ((unsigned int )tEmPcast->kind >= 145U) {
#line 210
      if (! ((unsigned int )tEmPcast->kind <= 145U)) {
        {
#line 210
        __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      210U, "conditional_chain");
        }
      }
    } else {
      {
#line 210
      __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    210U, "conditional_chain");
      }
    }
  }
#line 210
  return ((conditional )tEmPcast);
}
}
#line 212 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
identifier identifier_chain(identifier l1 , identifier l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 213
  tEmPcast___0 = (AST_generic )l2;
#line 213
  if (tEmPcast___0) {
#line 213
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 213
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 213
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      213U, "identifier_chain");
        }
      }
    } else {
      {
#line 213
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    213U, "identifier_chain");
      }
    }
  }
#line 213
  tEmPcast___1 = (AST_generic )l1;
#line 213
  if (tEmPcast___1) {
#line 213
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 213
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 213
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      213U, "identifier_chain");
        }
      }
    } else {
      {
#line 213
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    213U, "identifier_chain");
      }
    }
  }
  {
#line 213
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 213
  tEmPcast = (AST_generic )tmp;
  }
#line 213
  if (tEmPcast) {
#line 213
    if ((unsigned int )tEmPcast->kind >= 146U) {
#line 213
      if (! ((unsigned int )tEmPcast->kind <= 146U)) {
        {
#line 213
        __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      213U, "identifier_chain");
        }
      }
    } else {
      {
#line 213
      __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    213U, "identifier_chain");
      }
    }
  }
#line 213
  return ((identifier )tEmPcast);
}
}
#line 215 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
compound_expr compound_expr_chain(compound_expr l1 , compound_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 216
  tEmPcast___0 = (AST_generic )l2;
#line 216
  if (tEmPcast___0) {
#line 216
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 216
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 216
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      216U, "compound_expr_chain");
        }
      }
    } else {
      {
#line 216
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    216U, "compound_expr_chain");
      }
    }
  }
#line 216
  tEmPcast___1 = (AST_generic )l1;
#line 216
  if (tEmPcast___1) {
#line 216
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 216
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 216
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      216U, "compound_expr_chain");
        }
      }
    } else {
      {
#line 216
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    216U, "compound_expr_chain");
      }
    }
  }
  {
#line 216
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 216
  tEmPcast = (AST_generic )tmp;
  }
#line 216
  if (tEmPcast) {
#line 216
    if ((unsigned int )tEmPcast->kind >= 147U) {
#line 216
      if (! ((unsigned int )tEmPcast->kind <= 147U)) {
        {
#line 216
        __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      216U, "compound_expr_chain");
        }
      }
    } else {
      {
#line 216
      __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    216U, "compound_expr_chain");
      }
    }
  }
#line 216
  return ((compound_expr )tEmPcast);
}
}
#line 218 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
function_call function_call_chain(function_call l1 , function_call l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 219
  tEmPcast___0 = (AST_generic )l2;
#line 219
  if (tEmPcast___0) {
#line 219
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 219
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 219
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      219U, "function_call_chain");
        }
      }
    } else {
      {
#line 219
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    219U, "function_call_chain");
      }
    }
  }
#line 219
  tEmPcast___1 = (AST_generic )l1;
#line 219
  if (tEmPcast___1) {
#line 219
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 219
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 219
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      219U, "function_call_chain");
        }
      }
    } else {
      {
#line 219
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    219U, "function_call_chain");
      }
    }
  }
  {
#line 219
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 219
  tEmPcast = (AST_generic )tmp;
  }
#line 219
  if (tEmPcast) {
#line 219
    if ((unsigned int )tEmPcast->kind >= 148U) {
#line 219
      if (! ((unsigned int )tEmPcast->kind <= 148U)) {
        {
#line 219
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      219U, "function_call_chain");
        }
      }
    } else {
      {
#line 219
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    219U, "function_call_chain");
      }
    }
  }
#line 219
  return ((function_call )tEmPcast);
}
}
#line 221 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
field_ref field_ref_chain(field_ref l1 , field_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 222
  tEmPcast___0 = (AST_generic )l2;
#line 222
  if (tEmPcast___0) {
#line 222
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 222
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 222
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      222U, "field_ref_chain");
        }
      }
    } else {
      {
#line 222
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    222U, "field_ref_chain");
      }
    }
  }
#line 222
  tEmPcast___1 = (AST_generic )l1;
#line 222
  if (tEmPcast___1) {
#line 222
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 222
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 222
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      222U, "field_ref_chain");
        }
      }
    } else {
      {
#line 222
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    222U, "field_ref_chain");
      }
    }
  }
  {
#line 222
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 222
  tEmPcast = (AST_generic )tmp;
  }
#line 222
  if (tEmPcast) {
#line 222
    if ((unsigned int )tEmPcast->kind >= 87U) {
#line 222
      if (! ((unsigned int )tEmPcast->kind <= 87U)) {
        {
#line 222
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      222U, "field_ref_chain");
        }
      }
    } else {
      {
#line 222
      __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    222U, "field_ref_chain");
      }
    }
  }
#line 222
  return ((field_ref )tEmPcast);
}
}
#line 224 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
increment increment_chain(increment l1 , increment l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 225
  tEmPcast___0 = (AST_generic )l2;
#line 225
  if (tEmPcast___0) {
#line 225
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 225
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 225
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      225U, "increment_chain");
        }
      }
    } else {
      {
#line 225
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    225U, "increment_chain");
      }
    }
  }
#line 225
  tEmPcast___1 = (AST_generic )l1;
#line 225
  if (tEmPcast___1) {
#line 225
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 225
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 225
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      225U, "increment_chain");
        }
      }
    } else {
      {
#line 225
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    225U, "increment_chain");
      }
    }
  }
  {
#line 225
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 225
  tEmPcast = (AST_generic )tmp;
  }
#line 225
  if (tEmPcast) {
#line 225
    if ((unsigned int )tEmPcast->kind >= 88U) {
#line 225
      if (! ((unsigned int )tEmPcast->kind <= 92U)) {
        {
#line 225
        __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      225U, "increment_chain");
        }
      }
    } else {
      {
#line 225
      __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    225U, "increment_chain");
      }
    }
  }
#line 225
  return ((increment )tEmPcast);
}
}
#line 227 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
comparison comparison_chain(comparison l1 , comparison l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 228
  tEmPcast___0 = (AST_generic )l2;
#line 228
  if (tEmPcast___0) {
#line 228
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 228
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 228
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      228U, "comparison_chain");
        }
      }
    } else {
      {
#line 228
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    228U, "comparison_chain");
      }
    }
  }
#line 228
  tEmPcast___1 = (AST_generic )l1;
#line 228
  if (tEmPcast___1) {
#line 228
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 228
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 228
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      228U, "comparison_chain");
        }
      }
    } else {
      {
#line 228
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    228U, "comparison_chain");
      }
    }
  }
  {
#line 228
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 228
  tEmPcast = (AST_generic )tmp;
  }
#line 228
  if (tEmPcast) {
#line 228
    if ((unsigned int )tEmPcast->kind >= 108U) {
#line 228
      if (! ((unsigned int )tEmPcast->kind <= 114U)) {
        {
#line 228
        __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      228U, "comparison_chain");
        }
      }
    } else {
      {
#line 228
      __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    228U, "comparison_chain");
      }
    }
  }
#line 228
  return ((comparison )tEmPcast);
}
}
#line 230 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
assignment assignment_chain(assignment l1 , assignment l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 231
  tEmPcast___0 = (AST_generic )l2;
#line 231
  if (tEmPcast___0) {
#line 231
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 231
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 231
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      231U, "assignment_chain");
        }
      }
    } else {
      {
#line 231
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    231U, "assignment_chain");
      }
    }
  }
#line 231
  tEmPcast___1 = (AST_generic )l1;
#line 231
  if (tEmPcast___1) {
#line 231
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 231
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 231
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      231U, "assignment_chain");
        }
      }
    } else {
      {
#line 231
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    231U, "assignment_chain");
      }
    }
  }
  {
#line 231
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 231
  tEmPcast = (AST_generic )tmp;
  }
#line 231
  if (tEmPcast) {
#line 231
    if ((unsigned int )tEmPcast->kind >= 115U) {
#line 231
      if (! ((unsigned int )tEmPcast->kind <= 126U)) {
        {
#line 231
        __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      231U, "assignment_chain");
        }
      }
    } else {
      {
#line 231
      __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    231U, "assignment_chain");
      }
    }
  }
#line 231
  return ((assignment )tEmPcast);
}
}
#line 233 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
init_list init_list_chain(init_list l1 , init_list l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 234
  tEmPcast___0 = (AST_generic )l2;
#line 234
  if (tEmPcast___0) {
#line 234
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 234
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      234U, "init_list_chain");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    234U, "init_list_chain");
      }
    }
  }
#line 234
  tEmPcast___1 = (AST_generic )l1;
#line 234
  if (tEmPcast___1) {
#line 234
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 234
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      234U, "init_list_chain");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    234U, "init_list_chain");
      }
    }
  }
  {
#line 234
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 234
  tEmPcast = (AST_generic )tmp;
  }
#line 234
  if (tEmPcast) {
#line 234
    if ((unsigned int )tEmPcast->kind >= 149U) {
#line 234
      if (! ((unsigned int )tEmPcast->kind <= 149U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      234U, "init_list_chain");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    234U, "init_list_chain");
      }
    }
  }
#line 234
  return ((init_list )tEmPcast);
}
}
#line 236 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
init_specific init_specific_chain(init_specific l1 , init_specific l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 237
  tEmPcast___0 = (AST_generic )l2;
#line 237
  if (tEmPcast___0) {
#line 237
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 237
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 237
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      237U, "init_specific_chain");
        }
      }
    } else {
      {
#line 237
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    237U, "init_specific_chain");
      }
    }
  }
#line 237
  tEmPcast___1 = (AST_generic )l1;
#line 237
  if (tEmPcast___1) {
#line 237
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 237
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 237
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      237U, "init_specific_chain");
        }
      }
    } else {
      {
#line 237
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    237U, "init_specific_chain");
      }
    }
  }
  {
#line 237
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 237
  tEmPcast = (AST_generic )tmp;
  }
#line 237
  if (tEmPcast) {
#line 237
    if ((unsigned int )tEmPcast->kind >= 150U) {
#line 237
      if (! ((unsigned int )tEmPcast->kind <= 150U)) {
        {
#line 237
        __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      237U, "init_specific_chain");
        }
      }
    } else {
      {
#line 237
      __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    237U, "init_specific_chain");
      }
    }
  }
#line 237
  return ((init_specific )tEmPcast);
}
}
#line 239 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
designator designator_chain(designator l1 , designator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 240
  tEmPcast___0 = (AST_generic )l2;
#line 240
  if (tEmPcast___0) {
#line 240
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 240
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 240
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      240U, "designator_chain");
        }
      }
    } else {
      {
#line 240
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    240U, "designator_chain");
      }
    }
  }
#line 240
  tEmPcast___1 = (AST_generic )l1;
#line 240
  if (tEmPcast___1) {
#line 240
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 240
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 240
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      240U, "designator_chain");
        }
      }
    } else {
      {
#line 240
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    240U, "designator_chain");
      }
    }
  }
  {
#line 240
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 240
  tEmPcast = (AST_generic )tmp;
  }
#line 240
  if (tEmPcast) {
#line 240
    if ((unsigned int )tEmPcast->kind >= 189U) {
#line 240
      if (! ((unsigned int )tEmPcast->kind <= 191U)) {
        {
#line 240
        __assert_fail("((tEmPcast)->kind >= kind_designator && (tEmPcast)->kind <= postkind_designator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      240U, "designator_chain");
        }
      }
    } else {
      {
#line 240
      __assert_fail("((tEmPcast)->kind >= kind_designator && (tEmPcast)->kind <= postkind_designator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    240U, "designator_chain");
      }
    }
  }
#line 240
  return ((designator )tEmPcast);
}
}
#line 242 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
designate_field designate_field_chain(designate_field l1 , designate_field l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 243
  tEmPcast___0 = (AST_generic )l2;
#line 243
  if (tEmPcast___0) {
#line 243
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 243
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 243
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      243U, "designate_field_chain");
        }
      }
    } else {
      {
#line 243
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    243U, "designate_field_chain");
      }
    }
  }
#line 243
  tEmPcast___1 = (AST_generic )l1;
#line 243
  if (tEmPcast___1) {
#line 243
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 243
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 243
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      243U, "designate_field_chain");
        }
      }
    } else {
      {
#line 243
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    243U, "designate_field_chain");
      }
    }
  }
  {
#line 243
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 243
  tEmPcast = (AST_generic )tmp;
  }
#line 243
  if (tEmPcast) {
#line 243
    if ((unsigned int )tEmPcast->kind >= 190U) {
#line 243
      if (! ((unsigned int )tEmPcast->kind <= 190U)) {
        {
#line 243
        __assert_fail("((tEmPcast)->kind >= kind_designate_field && (tEmPcast)->kind <= postkind_designate_field)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      243U, "designate_field_chain");
        }
      }
    } else {
      {
#line 243
      __assert_fail("((tEmPcast)->kind >= kind_designate_field && (tEmPcast)->kind <= postkind_designate_field)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    243U, "designate_field_chain");
      }
    }
  }
#line 243
  return ((designate_field )tEmPcast);
}
}
#line 245 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
designate_index designate_index_chain(designate_index l1 , designate_index l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 246
  tEmPcast___0 = (AST_generic )l2;
#line 246
  if (tEmPcast___0) {
#line 246
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 246
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 246
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      246U, "designate_index_chain");
        }
      }
    } else {
      {
#line 246
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    246U, "designate_index_chain");
      }
    }
  }
#line 246
  tEmPcast___1 = (AST_generic )l1;
#line 246
  if (tEmPcast___1) {
#line 246
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 246
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 246
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      246U, "designate_index_chain");
        }
      }
    } else {
      {
#line 246
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    246U, "designate_index_chain");
      }
    }
  }
  {
#line 246
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 246
  tEmPcast = (AST_generic )tmp;
  }
#line 246
  if (tEmPcast) {
#line 246
    if ((unsigned int )tEmPcast->kind >= 191U) {
#line 246
      if (! ((unsigned int )tEmPcast->kind <= 191U)) {
        {
#line 246
        __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      246U, "designate_index_chain");
        }
      }
    } else {
      {
#line 246
      __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    246U, "designate_index_chain");
      }
    }
  }
#line 246
  return ((designate_index )tEmPcast);
}
}
#line 248 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
lexical_cst lexical_cst_chain(lexical_cst l1 , lexical_cst l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 249
  tEmPcast___0 = (AST_generic )l2;
#line 249
  if (tEmPcast___0) {
#line 249
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 249
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 249
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      249U, "lexical_cst_chain");
        }
      }
    } else {
      {
#line 249
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    249U, "lexical_cst_chain");
      }
    }
  }
#line 249
  tEmPcast___1 = (AST_generic )l1;
#line 249
  if (tEmPcast___1) {
#line 249
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 249
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 249
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      249U, "lexical_cst_chain");
        }
      }
    } else {
      {
#line 249
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    249U, "lexical_cst_chain");
      }
    }
  }
  {
#line 249
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 249
  tEmPcast = (AST_generic )tmp;
  }
#line 249
  if (tEmPcast) {
#line 249
    if ((unsigned int )tEmPcast->kind >= 151U) {
#line 249
      if (! ((unsigned int )tEmPcast->kind <= 152U)) {
        {
#line 249
        __assert_fail("((tEmPcast)->kind >= kind_lexical_cst && (tEmPcast)->kind <= postkind_lexical_cst)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      249U, "lexical_cst_chain");
        }
      }
    } else {
      {
#line 249
      __assert_fail("((tEmPcast)->kind >= kind_lexical_cst && (tEmPcast)->kind <= postkind_lexical_cst)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    249U, "lexical_cst_chain");
      }
    }
  }
#line 249
  return ((lexical_cst )tEmPcast);
}
}
#line 251 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
string_cst string_cst_chain(string_cst l1 , string_cst l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 252
  tEmPcast___0 = (AST_generic )l2;
#line 252
  if (tEmPcast___0) {
#line 252
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 252
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 252
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      252U, "string_cst_chain");
        }
      }
    } else {
      {
#line 252
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    252U, "string_cst_chain");
      }
    }
  }
#line 252
  tEmPcast___1 = (AST_generic )l1;
#line 252
  if (tEmPcast___1) {
#line 252
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 252
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 252
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      252U, "string_cst_chain");
        }
      }
    } else {
      {
#line 252
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    252U, "string_cst_chain");
      }
    }
  }
  {
#line 252
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 252
  tEmPcast = (AST_generic )tmp;
  }
#line 252
  if (tEmPcast) {
#line 252
    if ((unsigned int )tEmPcast->kind >= 152U) {
#line 252
      if (! ((unsigned int )tEmPcast->kind <= 152U)) {
        {
#line 252
        __assert_fail("((tEmPcast)->kind >= kind_string_cst && (tEmPcast)->kind <= postkind_string_cst)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      252U, "string_cst_chain");
        }
      }
    } else {
      {
#line 252
      __assert_fail("((tEmPcast)->kind >= kind_string_cst && (tEmPcast)->kind <= postkind_string_cst)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    252U, "string_cst_chain");
      }
    }
  }
#line 252
  return ((string_cst )tEmPcast);
}
}
#line 254 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
string string_chain(string l1 , string l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 255
  tEmPcast___0 = (AST_generic )l2;
#line 255
  if (tEmPcast___0) {
#line 255
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 255
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 255
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      255U, "string_chain");
        }
      }
    } else {
      {
#line 255
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    255U, "string_chain");
      }
    }
  }
#line 255
  tEmPcast___1 = (AST_generic )l1;
#line 255
  if (tEmPcast___1) {
#line 255
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 255
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 255
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      255U, "string_chain");
        }
      }
    } else {
      {
#line 255
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    255U, "string_chain");
      }
    }
  }
  {
#line 255
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 255
  tEmPcast = (AST_generic )tmp;
  }
#line 255
  if (tEmPcast) {
#line 255
    if ((unsigned int )tEmPcast->kind >= 153U) {
#line 255
      if (! ((unsigned int )tEmPcast->kind <= 153U)) {
        {
#line 255
        __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      255U, "string_chain");
        }
      }
    } else {
      {
#line 255
      __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    255U, "string_chain");
      }
    }
  }
#line 255
  return ((string )tEmPcast);
}
}
#line 257 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
id_label id_label_chain(id_label l1 , id_label l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 258
  tEmPcast___0 = (AST_generic )l2;
#line 258
  if (tEmPcast___0) {
#line 258
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 258
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 258
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      258U, "id_label_chain");
        }
      }
    } else {
      {
#line 258
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    258U, "id_label_chain");
      }
    }
  }
#line 258
  tEmPcast___1 = (AST_generic )l1;
#line 258
  if (tEmPcast___1) {
#line 258
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 258
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 258
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      258U, "id_label_chain");
        }
      }
    } else {
      {
#line 258
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    258U, "id_label_chain");
      }
    }
  }
  {
#line 258
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 258
  tEmPcast = (AST_generic )tmp;
  }
#line 258
  if (tEmPcast) {
#line 258
    if ((unsigned int )tEmPcast->kind >= 185U) {
#line 258
      if (! ((unsigned int )tEmPcast->kind <= 185U)) {
        {
#line 258
        __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      258U, "id_label_chain");
        }
      }
    } else {
      {
#line 258
      __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    258U, "id_label_chain");
      }
    }
  }
#line 258
  return ((id_label )tEmPcast);
}
}
#line 260 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
case_label case_label_chain(case_label l1 , case_label l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 261
  tEmPcast___0 = (AST_generic )l2;
#line 261
  if (tEmPcast___0) {
#line 261
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 261
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 261
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      261U, "case_label_chain");
        }
      }
    } else {
      {
#line 261
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    261U, "case_label_chain");
      }
    }
  }
#line 261
  tEmPcast___1 = (AST_generic )l1;
#line 261
  if (tEmPcast___1) {
#line 261
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 261
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 261
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      261U, "case_label_chain");
        }
      }
    } else {
      {
#line 261
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    261U, "case_label_chain");
      }
    }
  }
  {
#line 261
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 261
  tEmPcast = (AST_generic )tmp;
  }
#line 261
  if (tEmPcast) {
#line 261
    if ((unsigned int )tEmPcast->kind >= 186U) {
#line 261
      if (! ((unsigned int )tEmPcast->kind <= 186U)) {
        {
#line 261
        __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      261U, "case_label_chain");
        }
      }
    } else {
      {
#line 261
      __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    261U, "case_label_chain");
      }
    }
  }
#line 261
  return ((case_label )tEmPcast);
}
}
#line 263 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
default_label default_label_chain(default_label l1 , default_label l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 264
  tEmPcast___0 = (AST_generic )l2;
#line 264
  if (tEmPcast___0) {
#line 264
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 264
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 264
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      264U, "default_label_chain");
        }
      }
    } else {
      {
#line 264
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    264U, "default_label_chain");
      }
    }
  }
#line 264
  tEmPcast___1 = (AST_generic )l1;
#line 264
  if (tEmPcast___1) {
#line 264
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 264
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 264
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      264U, "default_label_chain");
        }
      }
    } else {
      {
#line 264
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    264U, "default_label_chain");
      }
    }
  }
  {
#line 264
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 264
  tEmPcast = (AST_generic )tmp;
  }
#line 264
  if (tEmPcast) {
#line 264
    if ((unsigned int )tEmPcast->kind >= 187U) {
#line 264
      if (! ((unsigned int )tEmPcast->kind <= 187U)) {
        {
#line 264
        __assert_fail("((tEmPcast)->kind >= kind_default_label && (tEmPcast)->kind <= postkind_default_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      264U, "default_label_chain");
        }
      }
    } else {
      {
#line 264
      __assert_fail("((tEmPcast)->kind >= kind_default_label && (tEmPcast)->kind <= postkind_default_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    264U, "default_label_chain");
      }
    }
  }
#line 264
  return ((default_label )tEmPcast);
}
}
#line 266 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
word word_chain(word l1 , word l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 267
  tEmPcast___0 = (AST_generic )l2;
#line 267
  if (tEmPcast___0) {
#line 267
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 267
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 267
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      267U, "word_chain");
        }
      }
    } else {
      {
#line 267
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    267U, "word_chain");
      }
    }
  }
#line 267
  tEmPcast___1 = (AST_generic )l1;
#line 267
  if (tEmPcast___1) {
#line 267
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 267
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 267
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      267U, "word_chain");
        }
      }
    } else {
      {
#line 267
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    267U, "word_chain");
      }
    }
  }
  {
#line 267
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 267
  tEmPcast = (AST_generic )tmp;
  }
#line 267
  if (tEmPcast) {
#line 267
    if ((unsigned int )tEmPcast->kind >= 192U) {
#line 267
      if (! ((unsigned int )tEmPcast->kind <= 192U)) {
        {
#line 267
        __assert_fail("((tEmPcast)->kind >= kind_word && (tEmPcast)->kind <= postkind_word)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      267U, "word_chain");
        }
      }
    } else {
      {
#line 267
      __assert_fail("((tEmPcast)->kind >= kind_word && (tEmPcast)->kind <= postkind_word)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    267U, "word_chain");
      }
    }
  }
#line 267
  return ((word )tEmPcast);
}
}
#line 269 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
asm_operand asm_operand_chain(asm_operand l1 , asm_operand l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 270
  tEmPcast___0 = (AST_generic )l2;
#line 270
  if (tEmPcast___0) {
#line 270
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 270
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 270
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      270U, "asm_operand_chain");
        }
      }
    } else {
      {
#line 270
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    270U, "asm_operand_chain");
      }
    }
  }
#line 270
  tEmPcast___1 = (AST_generic )l1;
#line 270
  if (tEmPcast___1) {
#line 270
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 270
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 270
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      270U, "asm_operand_chain");
        }
      }
    } else {
      {
#line 270
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    270U, "asm_operand_chain");
      }
    }
  }
  {
#line 270
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 270
  tEmPcast = (AST_generic )tmp;
  }
#line 270
  if (tEmPcast) {
#line 270
    if ((unsigned int )tEmPcast->kind >= 193U) {
#line 270
      if (! ((unsigned int )tEmPcast->kind <= 193U)) {
        {
#line 270
        __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      270U, "asm_operand_chain");
        }
      }
    } else {
      {
#line 270
      __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    270U, "asm_operand_chain");
      }
    }
  }
#line 270
  return ((asm_operand )tEmPcast);
}
}
#line 272 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
nesc_decl nesc_decl_chain(nesc_decl l1 , nesc_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 273
  tEmPcast___0 = (AST_generic )l2;
#line 273
  if (tEmPcast___0) {
#line 273
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 273
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 273
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      273U, "nesc_decl_chain");
        }
      }
    } else {
      {
#line 273
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    273U, "nesc_decl_chain");
      }
    }
  }
#line 273
  tEmPcast___1 = (AST_generic )l1;
#line 273
  if (tEmPcast___1) {
#line 273
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 273
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 273
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      273U, "nesc_decl_chain");
        }
      }
    } else {
      {
#line 273
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    273U, "nesc_decl_chain");
      }
    }
  }
  {
#line 273
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 273
  tEmPcast = (AST_generic )tmp;
  }
#line 273
  if (tEmPcast) {
#line 273
    if ((unsigned int )tEmPcast->kind >= 54U) {
#line 273
      if (! ((unsigned int )tEmPcast->kind <= 56U)) {
        {
#line 273
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      273U, "nesc_decl_chain");
        }
      }
    } else {
      {
#line 273
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    273U, "nesc_decl_chain");
      }
    }
  }
#line 273
  return ((nesc_decl )tEmPcast);
}
}
#line 275 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
interface interface_chain(interface l1 , interface l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 276
  tEmPcast___0 = (AST_generic )l2;
#line 276
  if (tEmPcast___0) {
#line 276
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 276
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      276U, "interface_chain");
        }
      }
    } else {
      {
#line 276
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    276U, "interface_chain");
      }
    }
  }
#line 276
  tEmPcast___1 = (AST_generic )l1;
#line 276
  if (tEmPcast___1) {
#line 276
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 276
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      276U, "interface_chain");
        }
      }
    } else {
      {
#line 276
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    276U, "interface_chain");
      }
    }
  }
  {
#line 276
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 276
  tEmPcast = (AST_generic )tmp;
  }
#line 276
  if (tEmPcast) {
#line 276
    if ((unsigned int )tEmPcast->kind >= 55U) {
#line 276
      if (! ((unsigned int )tEmPcast->kind <= 55U)) {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      276U, "interface_chain");
        }
      }
    } else {
      {
#line 276
      __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    276U, "interface_chain");
      }
    }
  }
#line 276
  return ((interface )tEmPcast);
}
}
#line 278 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
component component_chain(component l1 , component l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 279
  tEmPcast___0 = (AST_generic )l2;
#line 279
  if (tEmPcast___0) {
#line 279
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 279
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 279
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      279U, "component_chain");
        }
      }
    } else {
      {
#line 279
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    279U, "component_chain");
      }
    }
  }
#line 279
  tEmPcast___1 = (AST_generic )l1;
#line 279
  if (tEmPcast___1) {
#line 279
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 279
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 279
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      279U, "component_chain");
        }
      }
    } else {
      {
#line 279
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    279U, "component_chain");
      }
    }
  }
  {
#line 279
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 279
  tEmPcast = (AST_generic )tmp;
  }
#line 279
  if (tEmPcast) {
#line 279
    if ((unsigned int )tEmPcast->kind >= 56U) {
#line 279
      if (! ((unsigned int )tEmPcast->kind <= 56U)) {
        {
#line 279
        __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      279U, "component_chain");
        }
      }
    } else {
      {
#line 279
      __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    279U, "component_chain");
      }
    }
  }
#line 279
  return ((component )tEmPcast);
}
}
#line 281 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
implementation implementation_chain(implementation l1 , implementation l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 282
  tEmPcast___0 = (AST_generic )l2;
#line 282
  if (tEmPcast___0) {
#line 282
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 282
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 282
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      282U, "implementation_chain");
        }
      }
    } else {
      {
#line 282
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    282U, "implementation_chain");
      }
    }
  }
#line 282
  tEmPcast___1 = (AST_generic )l1;
#line 282
  if (tEmPcast___1) {
#line 282
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 282
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 282
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      282U, "implementation_chain");
        }
      }
    } else {
      {
#line 282
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    282U, "implementation_chain");
      }
    }
  }
  {
#line 282
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 282
  tEmPcast = (AST_generic )tmp;
  }
#line 282
  if (tEmPcast) {
#line 282
    if ((unsigned int )tEmPcast->kind >= 194U) {
#line 282
      if (! ((unsigned int )tEmPcast->kind <= 197U)) {
        {
#line 282
        __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      282U, "implementation_chain");
        }
      }
    } else {
      {
#line 282
      __assert_fail("((tEmPcast)->kind >= kind_implementation && (tEmPcast)->kind <= postkind_implementation)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    282U, "implementation_chain");
      }
    }
  }
#line 282
  return ((implementation )tEmPcast);
}
}
#line 284 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
configuration configuration_chain(configuration l1 , configuration l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 285
  tEmPcast___0 = (AST_generic )l2;
#line 285
  if (tEmPcast___0) {
#line 285
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 285
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 285
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      285U, "configuration_chain");
        }
      }
    } else {
      {
#line 285
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    285U, "configuration_chain");
      }
    }
  }
#line 285
  tEmPcast___1 = (AST_generic )l1;
#line 285
  if (tEmPcast___1) {
#line 285
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 285
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 285
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      285U, "configuration_chain");
        }
      }
    } else {
      {
#line 285
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    285U, "configuration_chain");
      }
    }
  }
  {
#line 285
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 285
  tEmPcast = (AST_generic )tmp;
  }
#line 285
  if (tEmPcast) {
#line 285
    if ((unsigned int )tEmPcast->kind >= 195U) {
#line 285
      if (! ((unsigned int )tEmPcast->kind <= 195U)) {
        {
#line 285
        __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      285U, "configuration_chain");
        }
      }
    } else {
      {
#line 285
      __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    285U, "configuration_chain");
      }
    }
  }
#line 285
  return ((configuration )tEmPcast);
}
}
#line 287 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
module module_chain(module l1 , module l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 288
  tEmPcast___0 = (AST_generic )l2;
#line 288
  if (tEmPcast___0) {
#line 288
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 288
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 288
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      288U, "module_chain");
        }
      }
    } else {
      {
#line 288
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    288U, "module_chain");
      }
    }
  }
#line 288
  tEmPcast___1 = (AST_generic )l1;
#line 288
  if (tEmPcast___1) {
#line 288
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 288
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 288
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      288U, "module_chain");
        }
      }
    } else {
      {
#line 288
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    288U, "module_chain");
      }
    }
  }
  {
#line 288
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 288
  tEmPcast = (AST_generic )tmp;
  }
#line 288
  if (tEmPcast) {
#line 288
    if ((unsigned int )tEmPcast->kind >= 196U) {
#line 288
      if (! ((unsigned int )tEmPcast->kind <= 196U)) {
        {
#line 288
        __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      288U, "module_chain");
        }
      }
    } else {
      {
#line 288
      __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    288U, "module_chain");
      }
    }
  }
#line 288
  return ((module )tEmPcast);
}
}
#line 290 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
binary_component binary_component_chain(binary_component l1 , binary_component l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 291
  tEmPcast___0 = (AST_generic )l2;
#line 291
  if (tEmPcast___0) {
#line 291
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 291
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 291
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      291U, "binary_component_chain");
        }
      }
    } else {
      {
#line 291
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    291U, "binary_component_chain");
      }
    }
  }
#line 291
  tEmPcast___1 = (AST_generic )l1;
#line 291
  if (tEmPcast___1) {
#line 291
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 291
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 291
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      291U, "binary_component_chain");
        }
      }
    } else {
      {
#line 291
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    291U, "binary_component_chain");
      }
    }
  }
  {
#line 291
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 291
  tEmPcast = (AST_generic )tmp;
  }
#line 291
  if (tEmPcast) {
#line 291
    if ((unsigned int )tEmPcast->kind >= 197U) {
#line 291
      if (! ((unsigned int )tEmPcast->kind <= 197U)) {
        {
#line 291
        __assert_fail("((tEmPcast)->kind >= kind_binary_component && (tEmPcast)->kind <= postkind_binary_component)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      291U, "binary_component_chain");
        }
      }
    } else {
      {
#line 291
      __assert_fail("((tEmPcast)->kind >= kind_binary_component && (tEmPcast)->kind <= postkind_binary_component)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    291U, "binary_component_chain");
      }
    }
  }
#line 291
  return ((binary_component )tEmPcast);
}
}
#line 293 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
rp_interface rp_interface_chain(rp_interface l1 , rp_interface l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 294
  tEmPcast___0 = (AST_generic )l2;
#line 294
  if (tEmPcast___0) {
#line 294
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 294
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 294
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      294U, "rp_interface_chain");
        }
      }
    } else {
      {
#line 294
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    294U, "rp_interface_chain");
      }
    }
  }
#line 294
  tEmPcast___1 = (AST_generic )l1;
#line 294
  if (tEmPcast___1) {
#line 294
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 294
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 294
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      294U, "rp_interface_chain");
        }
      }
    } else {
      {
#line 294
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    294U, "rp_interface_chain");
      }
    }
  }
  {
#line 294
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 294
  tEmPcast = (AST_generic )tmp;
  }
#line 294
  if (tEmPcast) {
#line 294
    if ((unsigned int )tEmPcast->kind >= 57U) {
#line 294
      if (! ((unsigned int )tEmPcast->kind <= 57U)) {
        {
#line 294
        __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      294U, "rp_interface_chain");
        }
      }
    } else {
      {
#line 294
      __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    294U, "rp_interface_chain");
      }
    }
  }
#line 294
  return ((rp_interface )tEmPcast);
}
}
#line 296 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
interface_ref interface_ref_chain(interface_ref l1 , interface_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 297
  tEmPcast___0 = (AST_generic )l2;
#line 297
  if (tEmPcast___0) {
#line 297
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 297
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 297
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      297U, "interface_ref_chain");
        }
      }
    } else {
      {
#line 297
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    297U, "interface_ref_chain");
      }
    }
  }
#line 297
  tEmPcast___1 = (AST_generic )l1;
#line 297
  if (tEmPcast___1) {
#line 297
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 297
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 297
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      297U, "interface_ref_chain");
        }
      }
    } else {
      {
#line 297
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    297U, "interface_ref_chain");
      }
    }
  }
  {
#line 297
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 297
  tEmPcast = (AST_generic )tmp;
  }
#line 297
  if (tEmPcast) {
#line 297
    if ((unsigned int )tEmPcast->kind >= 58U) {
#line 297
      if (! ((unsigned int )tEmPcast->kind <= 58U)) {
        {
#line 297
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      297U, "interface_ref_chain");
        }
      }
    } else {
      {
#line 297
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    297U, "interface_ref_chain");
      }
    }
  }
#line 297
  return ((interface_ref )tEmPcast);
}
}
#line 299 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
component_ref component_ref_chain(component_ref l1 , component_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 300
  tEmPcast___0 = (AST_generic )l2;
#line 300
  if (tEmPcast___0) {
#line 300
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 300
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 300
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      300U, "component_ref_chain");
        }
      }
    } else {
      {
#line 300
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    300U, "component_ref_chain");
      }
    }
  }
#line 300
  tEmPcast___1 = (AST_generic )l1;
#line 300
  if (tEmPcast___1) {
#line 300
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 300
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 300
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      300U, "component_ref_chain");
        }
      }
    } else {
      {
#line 300
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    300U, "component_ref_chain");
      }
    }
  }
  {
#line 300
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 300
  tEmPcast = (AST_generic )tmp;
  }
#line 300
  if (tEmPcast) {
#line 300
    if ((unsigned int )tEmPcast->kind >= 59U) {
#line 300
      if (! ((unsigned int )tEmPcast->kind <= 59U)) {
        {
#line 300
        __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      300U, "component_ref_chain");
        }
      }
    } else {
      {
#line 300
      __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    300U, "component_ref_chain");
      }
    }
  }
#line 300
  return ((component_ref )tEmPcast);
}
}
#line 302 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
connection connection_chain(connection l1 , connection l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 303
  tEmPcast___0 = (AST_generic )l2;
#line 303
  if (tEmPcast___0) {
#line 303
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 303
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 303
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      303U, "connection_chain");
        }
      }
    } else {
      {
#line 303
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    303U, "connection_chain");
      }
    }
  }
#line 303
  tEmPcast___1 = (AST_generic )l1;
#line 303
  if (tEmPcast___1) {
#line 303
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 303
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 303
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      303U, "connection_chain");
        }
      }
    } else {
      {
#line 303
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    303U, "connection_chain");
      }
    }
  }
  {
#line 303
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 303
  tEmPcast = (AST_generic )tmp;
  }
#line 303
  if (tEmPcast) {
#line 303
    if ((unsigned int )tEmPcast->kind >= 60U) {
#line 303
      if (! ((unsigned int )tEmPcast->kind <= 62U)) {
        {
#line 303
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      303U, "connection_chain");
        }
      }
    } else {
      {
#line 303
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    303U, "connection_chain");
      }
    }
  }
#line 303
  return ((connection )tEmPcast);
}
}
#line 305 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
endpoint endpoint_chain(endpoint l1 , endpoint l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 306
  tEmPcast___0 = (AST_generic )l2;
#line 306
  if (tEmPcast___0) {
#line 306
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 306
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 306
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      306U, "endpoint_chain");
        }
      }
    } else {
      {
#line 306
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    306U, "endpoint_chain");
      }
    }
  }
#line 306
  tEmPcast___1 = (AST_generic )l1;
#line 306
  if (tEmPcast___1) {
#line 306
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 306
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 306
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      306U, "endpoint_chain");
        }
      }
    } else {
      {
#line 306
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    306U, "endpoint_chain");
      }
    }
  }
  {
#line 306
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 306
  tEmPcast = (AST_generic )tmp;
  }
#line 306
  if (tEmPcast) {
#line 306
    if ((unsigned int )tEmPcast->kind >= 198U) {
#line 306
      if (! ((unsigned int )tEmPcast->kind <= 198U)) {
        {
#line 306
        __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      306U, "endpoint_chain");
        }
      }
    } else {
      {
#line 306
      __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    306U, "endpoint_chain");
      }
    }
  }
#line 306
  return ((endpoint )tEmPcast);
}
}
#line 308 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
parameterised_identifier parameterised_identifier_chain(parameterised_identifier l1 ,
                                                        parameterised_identifier l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 309
  tEmPcast___0 = (AST_generic )l2;
#line 309
  if (tEmPcast___0) {
#line 309
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 309
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 309
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      309U, "parameterised_identifier_chain");
        }
      }
    } else {
      {
#line 309
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    309U, "parameterised_identifier_chain");
      }
    }
  }
#line 309
  tEmPcast___1 = (AST_generic )l1;
#line 309
  if (tEmPcast___1) {
#line 309
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 309
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 309
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      309U, "parameterised_identifier_chain");
        }
      }
    } else {
      {
#line 309
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    309U, "parameterised_identifier_chain");
      }
    }
  }
  {
#line 309
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 309
  tEmPcast = (AST_generic )tmp;
  }
#line 309
  if (tEmPcast) {
#line 309
    if ((unsigned int )tEmPcast->kind >= 199U) {
#line 309
      if (! ((unsigned int )tEmPcast->kind <= 199U)) {
        {
#line 309
        __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      309U, "parameterised_identifier_chain");
        }
      }
    } else {
      {
#line 309
      __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    309U, "parameterised_identifier_chain");
      }
    }
  }
#line 309
  return ((parameterised_identifier )tEmPcast);
}
}
#line 311 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
generic_declarator generic_declarator_chain(generic_declarator l1 , generic_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 312
  tEmPcast___0 = (AST_generic )l2;
#line 312
  if (tEmPcast___0) {
#line 312
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 312
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      312U, "generic_declarator_chain");
        }
      }
    } else {
      {
#line 312
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    312U, "generic_declarator_chain");
      }
    }
  }
#line 312
  tEmPcast___1 = (AST_generic )l1;
#line 312
  if (tEmPcast___1) {
#line 312
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 312
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      312U, "generic_declarator_chain");
        }
      }
    } else {
      {
#line 312
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    312U, "generic_declarator_chain");
      }
    }
  }
  {
#line 312
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 312
  tEmPcast = (AST_generic )tmp;
  }
#line 312
  if (tEmPcast) {
#line 312
    if ((unsigned int )tEmPcast->kind >= 183U) {
#line 312
      if (! ((unsigned int )tEmPcast->kind <= 183U)) {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      312U, "generic_declarator_chain");
        }
      }
    } else {
      {
#line 312
      __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    312U, "generic_declarator_chain");
      }
    }
  }
#line 312
  return ((generic_declarator )tEmPcast);
}
}
#line 314 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
generic_call generic_call_chain(generic_call l1 , generic_call l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 315
  tEmPcast___0 = (AST_generic )l2;
#line 315
  if (tEmPcast___0) {
#line 315
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 315
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 315
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      315U, "generic_call_chain");
        }
      }
    } else {
      {
#line 315
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    315U, "generic_call_chain");
      }
    }
  }
#line 315
  tEmPcast___1 = (AST_generic )l1;
#line 315
  if (tEmPcast___1) {
#line 315
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 315
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 315
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      315U, "generic_call_chain");
        }
      }
    } else {
      {
#line 315
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    315U, "generic_call_chain");
      }
    }
  }
  {
#line 315
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 315
  tEmPcast = (AST_generic )tmp;
  }
#line 315
  if (tEmPcast) {
#line 315
    if ((unsigned int )tEmPcast->kind >= 154U) {
#line 315
      if (! ((unsigned int )tEmPcast->kind <= 154U)) {
        {
#line 315
        __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      315U, "generic_call_chain");
        }
      }
    } else {
      {
#line 315
      __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    315U, "generic_call_chain");
      }
    }
  }
#line 315
  return ((generic_call )tEmPcast);
}
}
#line 317 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
interface_ref_declarator interface_ref_declarator_chain(interface_ref_declarator l1 ,
                                                        interface_ref_declarator l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 318
  tEmPcast___0 = (AST_generic )l2;
#line 318
  if (tEmPcast___0) {
#line 318
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 318
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 318
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      318U, "interface_ref_declarator_chain");
        }
      }
    } else {
      {
#line 318
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    318U, "interface_ref_declarator_chain");
      }
    }
  }
#line 318
  tEmPcast___1 = (AST_generic )l1;
#line 318
  if (tEmPcast___1) {
#line 318
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 318
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 318
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      318U, "interface_ref_declarator_chain");
        }
      }
    } else {
      {
#line 318
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    318U, "interface_ref_declarator_chain");
      }
    }
  }
  {
#line 318
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 318
  tEmPcast = (AST_generic )tmp;
  }
#line 318
  if (tEmPcast) {
#line 318
    if ((unsigned int )tEmPcast->kind >= 181U) {
#line 318
      if (! ((unsigned int )tEmPcast->kind <= 181U)) {
        {
#line 318
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      318U, "interface_ref_declarator_chain");
        }
      }
    } else {
      {
#line 318
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    318U, "interface_ref_declarator_chain");
      }
    }
  }
#line 318
  return ((interface_ref_declarator )tEmPcast);
}
}
#line 320 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
interface_deref interface_deref_chain(interface_deref l1 , interface_deref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 321
  tEmPcast___0 = (AST_generic )l2;
#line 321
  if (tEmPcast___0) {
#line 321
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 321
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 321
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      321U, "interface_deref_chain");
        }
      }
    } else {
      {
#line 321
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    321U, "interface_deref_chain");
      }
    }
  }
#line 321
  tEmPcast___1 = (AST_generic )l1;
#line 321
  if (tEmPcast___1) {
#line 321
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 321
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 321
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      321U, "interface_deref_chain");
        }
      }
    } else {
      {
#line 321
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    321U, "interface_deref_chain");
      }
    }
  }
  {
#line 321
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 321
  tEmPcast = (AST_generic )tmp;
  }
#line 321
  if (tEmPcast) {
#line 321
    if ((unsigned int )tEmPcast->kind >= 93U) {
#line 321
      if (! ((unsigned int )tEmPcast->kind <= 93U)) {
        {
#line 321
        __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      321U, "interface_deref_chain");
        }
      }
    } else {
      {
#line 321
      __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    321U, "interface_deref_chain");
      }
    }
  }
#line 321
  return ((interface_deref )tEmPcast);
}
}
#line 323 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
component_deref component_deref_chain(component_deref l1 , component_deref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 324
  tEmPcast___0 = (AST_generic )l2;
#line 324
  if (tEmPcast___0) {
#line 324
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 324
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 324
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      324U, "component_deref_chain");
        }
      }
    } else {
      {
#line 324
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    324U, "component_deref_chain");
      }
    }
  }
#line 324
  tEmPcast___1 = (AST_generic )l1;
#line 324
  if (tEmPcast___1) {
#line 324
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 324
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 324
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      324U, "component_deref_chain");
        }
      }
    } else {
      {
#line 324
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    324U, "component_deref_chain");
      }
    }
  }
  {
#line 324
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 324
  tEmPcast = (AST_generic )tmp;
  }
#line 324
  if (tEmPcast) {
#line 324
    if ((unsigned int )tEmPcast->kind >= 94U) {
#line 324
      if (! ((unsigned int )tEmPcast->kind <= 94U)) {
        {
#line 324
        __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      324U, "component_deref_chain");
        }
      }
    } else {
      {
#line 324
      __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    324U, "component_deref_chain");
      }
    }
  }
#line 324
  return ((component_deref )tEmPcast);
}
}
#line 326 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
component_typeref component_typeref_chain(component_typeref l1 , component_typeref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 327
  tEmPcast___0 = (AST_generic )l2;
#line 327
  if (tEmPcast___0) {
#line 327
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 327
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 327
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      327U, "component_typeref_chain");
        }
      }
    } else {
      {
#line 327
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    327U, "component_typeref_chain");
      }
    }
  }
#line 327
  tEmPcast___1 = (AST_generic )l1;
#line 327
  if (tEmPcast___1) {
#line 327
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 327
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 327
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      327U, "component_typeref_chain");
        }
      }
    } else {
      {
#line 327
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    327U, "component_typeref_chain");
      }
    }
  }
  {
#line 327
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 327
  tEmPcast = (AST_generic )tmp;
  }
#line 327
  if (tEmPcast) {
#line 327
    if ((unsigned int )tEmPcast->kind >= 159U) {
#line 327
      if (! ((unsigned int )tEmPcast->kind <= 159U)) {
        {
#line 327
        __assert_fail("((tEmPcast)->kind >= kind_component_typeref && (tEmPcast)->kind <= postkind_component_typeref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      327U, "component_typeref_chain");
        }
      }
    } else {
      {
#line 327
      __assert_fail("((tEmPcast)->kind >= kind_component_typeref && (tEmPcast)->kind <= postkind_component_typeref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    327U, "component_typeref_chain");
      }
    }
  }
#line 327
  return ((component_typeref )tEmPcast);
}
}
#line 329 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
atomic_stmt atomic_stmt_chain(atomic_stmt l1 , atomic_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 330
  tEmPcast___0 = (AST_generic )l2;
#line 330
  if (tEmPcast___0) {
#line 330
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 330
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 330
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      330U, "atomic_stmt_chain");
        }
      }
    } else {
      {
#line 330
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    330U, "atomic_stmt_chain");
      }
    }
  }
#line 330
  tEmPcast___1 = (AST_generic )l1;
#line 330
  if (tEmPcast___1) {
#line 330
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 330
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 330
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      330U, "atomic_stmt_chain");
        }
      }
    } else {
      {
#line 330
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    330U, "atomic_stmt_chain");
      }
    }
  }
  {
#line 330
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 330
  tEmPcast = (AST_generic )tmp;
  }
#line 330
  if (tEmPcast) {
#line 330
    if ((unsigned int )tEmPcast->kind >= 82U) {
#line 330
      if (! ((unsigned int )tEmPcast->kind <= 82U)) {
        {
#line 330
        __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      330U, "atomic_stmt_chain");
        }
      }
    } else {
      {
#line 330
      __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    330U, "atomic_stmt_chain");
      }
    }
  }
#line 330
  return ((atomic_stmt )tEmPcast);
}
}
#line 332 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
nesc_attribute nesc_attribute_chain(nesc_attribute l1 , nesc_attribute l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 333
  tEmPcast___0 = (AST_generic )l2;
#line 333
  if (tEmPcast___0) {
#line 333
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 333
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 333
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      333U, "nesc_attribute_chain");
        }
      }
    } else {
      {
#line 333
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    333U, "nesc_attribute_chain");
      }
    }
  }
#line 333
  tEmPcast___1 = (AST_generic )l1;
#line 333
  if (tEmPcast___1) {
#line 333
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 333
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 333
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      333U, "nesc_attribute_chain");
        }
      }
    } else {
      {
#line 333
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    333U, "nesc_attribute_chain");
      }
    }
  }
  {
#line 333
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 333
  tEmPcast = (AST_generic )tmp;
  }
#line 333
  if (tEmPcast) {
#line 333
    if ((unsigned int )tEmPcast->kind >= 165U) {
#line 333
      if (! ((unsigned int )tEmPcast->kind <= 165U)) {
        {
#line 333
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      333U, "nesc_attribute_chain");
        }
      }
    } else {
      {
#line 333
      __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    333U, "nesc_attribute_chain");
      }
    }
  }
#line 333
  return ((nesc_attribute )tEmPcast);
}
}
#line 335 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
type_parm_decl type_parm_decl_chain(type_parm_decl l1 , type_parm_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 336
  tEmPcast___0 = (AST_generic )l2;
#line 336
  if (tEmPcast___0) {
#line 336
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 336
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 336
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      336U, "type_parm_decl_chain");
        }
      }
    } else {
      {
#line 336
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    336U, "type_parm_decl_chain");
      }
    }
  }
#line 336
  tEmPcast___1 = (AST_generic )l1;
#line 336
  if (tEmPcast___1) {
#line 336
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 336
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 336
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      336U, "type_parm_decl_chain");
        }
      }
    } else {
      {
#line 336
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    336U, "type_parm_decl_chain");
      }
    }
  }
  {
#line 336
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 336
  tEmPcast = (AST_generic )tmp;
  }
#line 336
  if (tEmPcast) {
#line 336
    if ((unsigned int )tEmPcast->kind >= 63U) {
#line 336
      if (! ((unsigned int )tEmPcast->kind <= 63U)) {
        {
#line 336
        __assert_fail("((tEmPcast)->kind >= kind_type_parm_decl && (tEmPcast)->kind <= postkind_type_parm_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      336U, "type_parm_decl_chain");
        }
      }
    } else {
      {
#line 336
      __assert_fail("((tEmPcast)->kind >= kind_type_parm_decl && (tEmPcast)->kind <= postkind_type_parm_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    336U, "type_parm_decl_chain");
      }
    }
  }
#line 336
  return ((type_parm_decl )tEmPcast);
}
}
#line 338 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
type_argument type_argument_chain(type_argument l1 , type_argument l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 339
  tEmPcast___0 = (AST_generic )l2;
#line 339
  if (tEmPcast___0) {
#line 339
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 339
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 339
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      339U, "type_argument_chain");
        }
      }
    } else {
      {
#line 339
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    339U, "type_argument_chain");
      }
    }
  }
#line 339
  tEmPcast___1 = (AST_generic )l1;
#line 339
  if (tEmPcast___1) {
#line 339
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 339
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 339
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      339U, "type_argument_chain");
        }
      }
    } else {
      {
#line 339
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    339U, "type_argument_chain");
      }
    }
  }
  {
#line 339
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 339
  tEmPcast = (AST_generic )tmp;
  }
#line 339
  if (tEmPcast) {
#line 339
    if ((unsigned int )tEmPcast->kind >= 155U) {
#line 339
      if (! ((unsigned int )tEmPcast->kind <= 155U)) {
        {
#line 339
        __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      339U, "type_argument_chain");
        }
      }
    } else {
      {
#line 339
      __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    339U, "type_argument_chain");
      }
    }
  }
#line 339
  return ((type_argument )tEmPcast);
}
}
#line 341 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
error_decl error_decl_chain(error_decl l1 , error_decl l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 342
  tEmPcast___0 = (AST_generic )l2;
#line 342
  if (tEmPcast___0) {
#line 342
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 342
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 342
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      342U, "error_decl_chain");
        }
      }
    } else {
      {
#line 342
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    342U, "error_decl_chain");
      }
    }
  }
#line 342
  tEmPcast___1 = (AST_generic )l1;
#line 342
  if (tEmPcast___1) {
#line 342
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 342
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 342
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      342U, "error_decl_chain");
        }
      }
    } else {
      {
#line 342
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    342U, "error_decl_chain");
      }
    }
  }
  {
#line 342
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 342
  tEmPcast = (AST_generic )tmp;
  }
#line 342
  if (tEmPcast) {
#line 342
    if ((unsigned int )tEmPcast->kind >= 64U) {
#line 342
      if (! ((unsigned int )tEmPcast->kind <= 64U)) {
        {
#line 342
        __assert_fail("((tEmPcast)->kind >= kind_error_decl && (tEmPcast)->kind <= postkind_error_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      342U, "error_decl_chain");
        }
      }
    } else {
      {
#line 342
      __assert_fail("((tEmPcast)->kind >= kind_error_decl && (tEmPcast)->kind <= postkind_error_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    342U, "error_decl_chain");
      }
    }
  }
#line 342
  return ((error_decl )tEmPcast);
}
}
#line 344 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
attribute_ref attribute_ref_chain(attribute_ref l1 , attribute_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 345
  tEmPcast___0 = (AST_generic )l2;
#line 345
  if (tEmPcast___0) {
#line 345
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 345
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 345
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      345U, "attribute_ref_chain");
        }
      }
    } else {
      {
#line 345
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    345U, "attribute_ref_chain");
      }
    }
  }
#line 345
  tEmPcast___1 = (AST_generic )l1;
#line 345
  if (tEmPcast___1) {
#line 345
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 345
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 345
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      345U, "attribute_ref_chain");
        }
      }
    } else {
      {
#line 345
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    345U, "attribute_ref_chain");
      }
    }
  }
  {
#line 345
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 345
  tEmPcast = (AST_generic )tmp;
  }
#line 345
  if (tEmPcast) {
#line 345
    if ((unsigned int )tEmPcast->kind >= 173U) {
#line 345
      if (! ((unsigned int )tEmPcast->kind <= 173U)) {
        {
#line 345
        __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      345U, "attribute_ref_chain");
        }
      }
    } else {
      {
#line 345
      __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    345U, "attribute_ref_chain");
      }
    }
  }
#line 345
  return ((attribute_ref )tEmPcast);
}
}
#line 347 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
enum_ref enum_ref_chain(enum_ref l1 , enum_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 348
  tEmPcast___0 = (AST_generic )l2;
#line 348
  if (tEmPcast___0) {
#line 348
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 348
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 348
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      348U, "enum_ref_chain");
        }
      }
    } else {
      {
#line 348
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    348U, "enum_ref_chain");
      }
    }
  }
#line 348
  tEmPcast___1 = (AST_generic )l1;
#line 348
  if (tEmPcast___1) {
#line 348
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 348
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 348
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      348U, "enum_ref_chain");
        }
      }
    } else {
      {
#line 348
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    348U, "enum_ref_chain");
      }
    }
  }
  {
#line 348
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 348
  tEmPcast = (AST_generic )tmp;
  }
#line 348
  if (tEmPcast) {
#line 348
    if ((unsigned int )tEmPcast->kind >= 174U) {
#line 348
      if (! ((unsigned int )tEmPcast->kind <= 174U)) {
        {
#line 348
        __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      348U, "enum_ref_chain");
        }
      }
    } else {
      {
#line 348
      __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    348U, "enum_ref_chain");
      }
    }
  }
#line 348
  return ((enum_ref )tEmPcast);
}
}
#line 350 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
error_stmt error_stmt_chain(error_stmt l1 , error_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 351
  tEmPcast___0 = (AST_generic )l2;
#line 351
  if (tEmPcast___0) {
#line 351
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 351
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 351
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      351U, "error_stmt_chain");
        }
      }
    } else {
      {
#line 351
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    351U, "error_stmt_chain");
      }
    }
  }
#line 351
  tEmPcast___1 = (AST_generic )l1;
#line 351
  if (tEmPcast___1) {
#line 351
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 351
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 351
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      351U, "error_stmt_chain");
        }
      }
    } else {
      {
#line 351
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    351U, "error_stmt_chain");
      }
    }
  }
  {
#line 351
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 351
  tEmPcast = (AST_generic )tmp;
  }
#line 351
  if (tEmPcast) {
#line 351
    if ((unsigned int )tEmPcast->kind >= 83U) {
#line 351
      if (! ((unsigned int )tEmPcast->kind <= 83U)) {
        {
#line 351
        __assert_fail("((tEmPcast)->kind >= kind_error_stmt && (tEmPcast)->kind <= postkind_error_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      351U, "error_stmt_chain");
        }
      }
    } else {
      {
#line 351
      __assert_fail("((tEmPcast)->kind >= kind_error_stmt && (tEmPcast)->kind <= postkind_error_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    351U, "error_stmt_chain");
      }
    }
  }
#line 351
  return ((error_stmt )tEmPcast);
}
}
#line 353 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
while_stmt while_stmt_chain(while_stmt l1 , while_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 354
  tEmPcast___0 = (AST_generic )l2;
#line 354
  if (tEmPcast___0) {
#line 354
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 354
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 354
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      354U, "while_stmt_chain");
        }
      }
    } else {
      {
#line 354
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    354U, "while_stmt_chain");
      }
    }
  }
#line 354
  tEmPcast___1 = (AST_generic )l1;
#line 354
  if (tEmPcast___1) {
#line 354
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 354
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 354
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      354U, "while_stmt_chain");
        }
      }
    } else {
      {
#line 354
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    354U, "while_stmt_chain");
      }
    }
  }
  {
#line 354
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 354
  tEmPcast = (AST_generic )tmp;
  }
#line 354
  if (tEmPcast) {
#line 354
    if ((unsigned int )tEmPcast->kind >= 73U) {
#line 354
      if (! ((unsigned int )tEmPcast->kind <= 73U)) {
        {
#line 354
        __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      354U, "while_stmt_chain");
        }
      }
    } else {
      {
#line 354
      __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    354U, "while_stmt_chain");
      }
    }
  }
#line 354
  return ((while_stmt )tEmPcast);
}
}
#line 356 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
dowhile_stmt dowhile_stmt_chain(dowhile_stmt l1 , dowhile_stmt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 357
  tEmPcast___0 = (AST_generic )l2;
#line 357
  if (tEmPcast___0) {
#line 357
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 357
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 357
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      357U, "dowhile_stmt_chain");
        }
      }
    } else {
      {
#line 357
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    357U, "dowhile_stmt_chain");
      }
    }
  }
#line 357
  tEmPcast___1 = (AST_generic )l1;
#line 357
  if (tEmPcast___1) {
#line 357
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 357
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 357
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      357U, "dowhile_stmt_chain");
        }
      }
    } else {
      {
#line 357
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    357U, "dowhile_stmt_chain");
      }
    }
  }
  {
#line 357
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 357
  tEmPcast = (AST_generic )tmp;
  }
#line 357
  if (tEmPcast) {
#line 357
    if ((unsigned int )tEmPcast->kind >= 74U) {
#line 357
      if (! ((unsigned int )tEmPcast->kind <= 74U)) {
        {
#line 357
        __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      357U, "dowhile_stmt_chain");
        }
      }
    } else {
      {
#line 357
      __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    357U, "dowhile_stmt_chain");
      }
    }
  }
#line 357
  return ((dowhile_stmt )tEmPcast);
}
}
#line 359 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
error_expr error_expr_chain(error_expr l1 , error_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 360
  tEmPcast___0 = (AST_generic )l2;
#line 360
  if (tEmPcast___0) {
#line 360
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 360
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 360
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      360U, "error_expr_chain");
        }
      }
    } else {
      {
#line 360
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    360U, "error_expr_chain");
      }
    }
  }
#line 360
  tEmPcast___1 = (AST_generic )l1;
#line 360
  if (tEmPcast___1) {
#line 360
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 360
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 360
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      360U, "error_expr_chain");
        }
      }
    } else {
      {
#line 360
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    360U, "error_expr_chain");
      }
    }
  }
  {
#line 360
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 360
  tEmPcast = (AST_generic )tmp;
  }
#line 360
  if (tEmPcast) {
#line 360
    if ((unsigned int )tEmPcast->kind >= 156U) {
#line 360
      if (! ((unsigned int )tEmPcast->kind <= 156U)) {
        {
#line 360
        __assert_fail("((tEmPcast)->kind >= kind_error_expr && (tEmPcast)->kind <= postkind_error_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      360U, "error_expr_chain");
        }
      }
    } else {
      {
#line 360
      __assert_fail("((tEmPcast)->kind >= kind_error_expr && (tEmPcast)->kind <= postkind_error_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    360U, "error_expr_chain");
      }
    }
  }
#line 360
  return ((error_expr )tEmPcast);
}
}
#line 362 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
array_ref array_ref_chain(array_ref l1 , array_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 363
  tEmPcast___0 = (AST_generic )l2;
#line 363
  if (tEmPcast___0) {
#line 363
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 363
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 363
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      363U, "array_ref_chain");
        }
      }
    } else {
      {
#line 363
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    363U, "array_ref_chain");
      }
    }
  }
#line 363
  tEmPcast___1 = (AST_generic )l1;
#line 363
  if (tEmPcast___1) {
#line 363
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 363
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 363
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      363U, "array_ref_chain");
        }
      }
    } else {
      {
#line 363
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    363U, "array_ref_chain");
      }
    }
  }
  {
#line 363
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 363
  tEmPcast = (AST_generic )tmp;
  }
#line 363
  if (tEmPcast) {
#line 363
    if ((unsigned int )tEmPcast->kind >= 127U) {
#line 363
      if (! ((unsigned int )tEmPcast->kind <= 127U)) {
        {
#line 363
        __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      363U, "array_ref_chain");
        }
      }
    } else {
      {
#line 363
      __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    363U, "array_ref_chain");
      }
    }
  }
#line 363
  return ((array_ref )tEmPcast);
}
}
#line 365 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
dereference dereference_chain(dereference l1 , dereference l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 366
  tEmPcast___0 = (AST_generic )l2;
#line 366
  if (tEmPcast___0) {
#line 366
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 366
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 366
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      366U, "dereference_chain");
        }
      }
    } else {
      {
#line 366
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    366U, "dereference_chain");
      }
    }
  }
#line 366
  tEmPcast___1 = (AST_generic )l1;
#line 366
  if (tEmPcast___1) {
#line 366
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 366
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 366
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      366U, "dereference_chain");
        }
      }
    } else {
      {
#line 366
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    366U, "dereference_chain");
      }
    }
  }
  {
#line 366
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 366
  tEmPcast = (AST_generic )tmp;
  }
#line 366
  if (tEmPcast) {
#line 366
    if ((unsigned int )tEmPcast->kind >= 95U) {
#line 366
      if (! ((unsigned int )tEmPcast->kind <= 95U)) {
        {
#line 366
        __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      366U, "dereference_chain");
        }
      }
    } else {
      {
#line 366
      __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    366U, "dereference_chain");
      }
    }
  }
#line 366
  return ((dereference )tEmPcast);
}
}
#line 368 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
extension_expr extension_expr_chain(extension_expr l1 , extension_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 369
  tEmPcast___0 = (AST_generic )l2;
#line 369
  if (tEmPcast___0) {
#line 369
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 369
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 369
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      369U, "extension_expr_chain");
        }
      }
    } else {
      {
#line 369
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    369U, "extension_expr_chain");
      }
    }
  }
#line 369
  tEmPcast___1 = (AST_generic )l1;
#line 369
  if (tEmPcast___1) {
#line 369
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 369
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 369
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      369U, "extension_expr_chain");
        }
      }
    } else {
      {
#line 369
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    369U, "extension_expr_chain");
      }
    }
  }
  {
#line 369
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 369
  tEmPcast = (AST_generic )tmp;
  }
#line 369
  if (tEmPcast) {
#line 369
    if ((unsigned int )tEmPcast->kind >= 96U) {
#line 369
      if (! ((unsigned int )tEmPcast->kind <= 96U)) {
        {
#line 369
        __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      369U, "extension_expr_chain");
        }
      }
    } else {
      {
#line 369
      __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    369U, "extension_expr_chain");
      }
    }
  }
#line 369
  return ((extension_expr )tEmPcast);
}
}
#line 371 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
sizeof_expr sizeof_expr_chain(sizeof_expr l1 , sizeof_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 372
  tEmPcast___0 = (AST_generic )l2;
#line 372
  if (tEmPcast___0) {
#line 372
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 372
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 372
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      372U, "sizeof_expr_chain");
        }
      }
    } else {
      {
#line 372
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    372U, "sizeof_expr_chain");
      }
    }
  }
#line 372
  tEmPcast___1 = (AST_generic )l1;
#line 372
  if (tEmPcast___1) {
#line 372
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 372
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 372
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      372U, "sizeof_expr_chain");
        }
      }
    } else {
      {
#line 372
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    372U, "sizeof_expr_chain");
      }
    }
  }
  {
#line 372
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 372
  tEmPcast = (AST_generic )tmp;
  }
#line 372
  if (tEmPcast) {
#line 372
    if ((unsigned int )tEmPcast->kind >= 97U) {
#line 372
      if (! ((unsigned int )tEmPcast->kind <= 97U)) {
        {
#line 372
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      372U, "sizeof_expr_chain");
        }
      }
    } else {
      {
#line 372
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    372U, "sizeof_expr_chain");
      }
    }
  }
#line 372
  return ((sizeof_expr )tEmPcast);
}
}
#line 374 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
alignof_expr alignof_expr_chain(alignof_expr l1 , alignof_expr l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 375
  tEmPcast___0 = (AST_generic )l2;
#line 375
  if (tEmPcast___0) {
#line 375
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 375
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      375U, "alignof_expr_chain");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    375U, "alignof_expr_chain");
      }
    }
  }
#line 375
  tEmPcast___1 = (AST_generic )l1;
#line 375
  if (tEmPcast___1) {
#line 375
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 375
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      375U, "alignof_expr_chain");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    375U, "alignof_expr_chain");
      }
    }
  }
  {
#line 375
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 375
  tEmPcast = (AST_generic )tmp;
  }
#line 375
  if (tEmPcast) {
#line 375
    if ((unsigned int )tEmPcast->kind >= 98U) {
#line 375
      if (! ((unsigned int )tEmPcast->kind <= 98U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      375U, "alignof_expr_chain");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    375U, "alignof_expr_chain");
      }
    }
  }
#line 375
  return ((alignof_expr )tEmPcast);
}
}
#line 377 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
realpart realpart_chain(realpart l1 , realpart l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 378
  tEmPcast___0 = (AST_generic )l2;
#line 378
  if (tEmPcast___0) {
#line 378
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 378
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 378
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      378U, "realpart_chain");
        }
      }
    } else {
      {
#line 378
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    378U, "realpart_chain");
      }
    }
  }
#line 378
  tEmPcast___1 = (AST_generic )l1;
#line 378
  if (tEmPcast___1) {
#line 378
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 378
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 378
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      378U, "realpart_chain");
        }
      }
    } else {
      {
#line 378
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    378U, "realpart_chain");
      }
    }
  }
  {
#line 378
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 378
  tEmPcast = (AST_generic )tmp;
  }
#line 378
  if (tEmPcast) {
#line 378
    if ((unsigned int )tEmPcast->kind >= 99U) {
#line 378
      if (! ((unsigned int )tEmPcast->kind <= 99U)) {
        {
#line 378
        __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      378U, "realpart_chain");
        }
      }
    } else {
      {
#line 378
      __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    378U, "realpart_chain");
      }
    }
  }
#line 378
  return ((realpart )tEmPcast);
}
}
#line 380 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
imagpart imagpart_chain(imagpart l1 , imagpart l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 381
  tEmPcast___0 = (AST_generic )l2;
#line 381
  if (tEmPcast___0) {
#line 381
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 381
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 381
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      381U, "imagpart_chain");
        }
      }
    } else {
      {
#line 381
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    381U, "imagpart_chain");
      }
    }
  }
#line 381
  tEmPcast___1 = (AST_generic )l1;
#line 381
  if (tEmPcast___1) {
#line 381
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 381
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 381
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      381U, "imagpart_chain");
        }
      }
    } else {
      {
#line 381
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    381U, "imagpart_chain");
      }
    }
  }
  {
#line 381
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 381
  tEmPcast = (AST_generic )tmp;
  }
#line 381
  if (tEmPcast) {
#line 381
    if ((unsigned int )tEmPcast->kind >= 100U) {
#line 381
      if (! ((unsigned int )tEmPcast->kind <= 100U)) {
        {
#line 381
        __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      381U, "imagpart_chain");
        }
      }
    } else {
      {
#line 381
      __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    381U, "imagpart_chain");
      }
    }
  }
#line 381
  return ((imagpart )tEmPcast);
}
}
#line 383 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
address_of address_of_chain(address_of l1 , address_of l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 384
  tEmPcast___0 = (AST_generic )l2;
#line 384
  if (tEmPcast___0) {
#line 384
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 384
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 384
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      384U, "address_of_chain");
        }
      }
    } else {
      {
#line 384
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    384U, "address_of_chain");
      }
    }
  }
#line 384
  tEmPcast___1 = (AST_generic )l1;
#line 384
  if (tEmPcast___1) {
#line 384
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 384
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 384
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      384U, "address_of_chain");
        }
      }
    } else {
      {
#line 384
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    384U, "address_of_chain");
      }
    }
  }
  {
#line 384
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 384
  tEmPcast = (AST_generic )tmp;
  }
#line 384
  if (tEmPcast) {
#line 384
    if ((unsigned int )tEmPcast->kind >= 101U) {
#line 384
      if (! ((unsigned int )tEmPcast->kind <= 101U)) {
        {
#line 384
        __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      384U, "address_of_chain");
        }
      }
    } else {
      {
#line 384
      __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    384U, "address_of_chain");
      }
    }
  }
#line 384
  return ((address_of )tEmPcast);
}
}
#line 386 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
unary_minus unary_minus_chain(unary_minus l1 , unary_minus l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 387
  tEmPcast___0 = (AST_generic )l2;
#line 387
  if (tEmPcast___0) {
#line 387
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 387
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 387
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      387U, "unary_minus_chain");
        }
      }
    } else {
      {
#line 387
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    387U, "unary_minus_chain");
      }
    }
  }
#line 387
  tEmPcast___1 = (AST_generic )l1;
#line 387
  if (tEmPcast___1) {
#line 387
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 387
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 387
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      387U, "unary_minus_chain");
        }
      }
    } else {
      {
#line 387
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    387U, "unary_minus_chain");
      }
    }
  }
  {
#line 387
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 387
  tEmPcast = (AST_generic )tmp;
  }
#line 387
  if (tEmPcast) {
#line 387
    if ((unsigned int )tEmPcast->kind >= 102U) {
#line 387
      if (! ((unsigned int )tEmPcast->kind <= 102U)) {
        {
#line 387
        __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      387U, "unary_minus_chain");
        }
      }
    } else {
      {
#line 387
      __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    387U, "unary_minus_chain");
      }
    }
  }
#line 387
  return ((unary_minus )tEmPcast);
}
}
#line 389 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
unary_plus unary_plus_chain(unary_plus l1 , unary_plus l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 390
  tEmPcast___0 = (AST_generic )l2;
#line 390
  if (tEmPcast___0) {
#line 390
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 390
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 390
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      390U, "unary_plus_chain");
        }
      }
    } else {
      {
#line 390
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    390U, "unary_plus_chain");
      }
    }
  }
#line 390
  tEmPcast___1 = (AST_generic )l1;
#line 390
  if (tEmPcast___1) {
#line 390
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 390
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 390
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      390U, "unary_plus_chain");
        }
      }
    } else {
      {
#line 390
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    390U, "unary_plus_chain");
      }
    }
  }
  {
#line 390
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 390
  tEmPcast = (AST_generic )tmp;
  }
#line 390
  if (tEmPcast) {
#line 390
    if ((unsigned int )tEmPcast->kind >= 103U) {
#line 390
      if (! ((unsigned int )tEmPcast->kind <= 103U)) {
        {
#line 390
        __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      390U, "unary_plus_chain");
        }
      }
    } else {
      {
#line 390
      __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    390U, "unary_plus_chain");
      }
    }
  }
#line 390
  return ((unary_plus )tEmPcast);
}
}
#line 392 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
conjugate conjugate_chain(conjugate l1 , conjugate l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 393
  tEmPcast___0 = (AST_generic )l2;
#line 393
  if (tEmPcast___0) {
#line 393
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 393
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 393
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      393U, "conjugate_chain");
        }
      }
    } else {
      {
#line 393
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    393U, "conjugate_chain");
      }
    }
  }
#line 393
  tEmPcast___1 = (AST_generic )l1;
#line 393
  if (tEmPcast___1) {
#line 393
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 393
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 393
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      393U, "conjugate_chain");
        }
      }
    } else {
      {
#line 393
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    393U, "conjugate_chain");
      }
    }
  }
  {
#line 393
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 393
  tEmPcast = (AST_generic )tmp;
  }
#line 393
  if (tEmPcast) {
#line 393
    if ((unsigned int )tEmPcast->kind >= 104U) {
#line 393
      if (! ((unsigned int )tEmPcast->kind <= 104U)) {
        {
#line 393
        __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      393U, "conjugate_chain");
        }
      }
    } else {
      {
#line 393
      __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    393U, "conjugate_chain");
      }
    }
  }
#line 393
  return ((conjugate )tEmPcast);
}
}
#line 395 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitnot bitnot_chain(bitnot l1 , bitnot l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 396
  tEmPcast___0 = (AST_generic )l2;
#line 396
  if (tEmPcast___0) {
#line 396
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 396
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 396
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      396U, "bitnot_chain");
        }
      }
    } else {
      {
#line 396
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    396U, "bitnot_chain");
      }
    }
  }
#line 396
  tEmPcast___1 = (AST_generic )l1;
#line 396
  if (tEmPcast___1) {
#line 396
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 396
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 396
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      396U, "bitnot_chain");
        }
      }
    } else {
      {
#line 396
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    396U, "bitnot_chain");
      }
    }
  }
  {
#line 396
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 396
  tEmPcast = (AST_generic )tmp;
  }
#line 396
  if (tEmPcast) {
#line 396
    if ((unsigned int )tEmPcast->kind >= 105U) {
#line 396
      if (! ((unsigned int )tEmPcast->kind <= 105U)) {
        {
#line 396
        __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      396U, "bitnot_chain");
        }
      }
    } else {
      {
#line 396
      __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    396U, "bitnot_chain");
      }
    }
  }
#line 396
  return ((bitnot )tEmPcast);
}
}
#line 398 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
not not_chain(not l1 , not l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 399
  tEmPcast___0 = (AST_generic )l2;
#line 399
  if (tEmPcast___0) {
#line 399
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 399
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 399
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      399U, "not_chain");
        }
      }
    } else {
      {
#line 399
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    399U, "not_chain");
      }
    }
  }
#line 399
  tEmPcast___1 = (AST_generic )l1;
#line 399
  if (tEmPcast___1) {
#line 399
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 399
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 399
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      399U, "not_chain");
        }
      }
    } else {
      {
#line 399
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    399U, "not_chain");
      }
    }
  }
  {
#line 399
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 399
  tEmPcast = (AST_generic )tmp;
  }
#line 399
  if (tEmPcast) {
#line 399
    if ((unsigned int )tEmPcast->kind >= 106U) {
#line 399
      if (! ((unsigned int )tEmPcast->kind <= 106U)) {
        {
#line 399
        __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      399U, "not_chain");
        }
      }
    } else {
      {
#line 399
      __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    399U, "not_chain");
      }
    }
  }
#line 399
  return ((not )tEmPcast);
}
}
#line 401 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
preincrement preincrement_chain(preincrement l1 , preincrement l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 402
  tEmPcast___0 = (AST_generic )l2;
#line 402
  if (tEmPcast___0) {
#line 402
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 402
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 402
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      402U, "preincrement_chain");
        }
      }
    } else {
      {
#line 402
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    402U, "preincrement_chain");
      }
    }
  }
#line 402
  tEmPcast___1 = (AST_generic )l1;
#line 402
  if (tEmPcast___1) {
#line 402
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 402
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 402
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      402U, "preincrement_chain");
        }
      }
    } else {
      {
#line 402
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    402U, "preincrement_chain");
      }
    }
  }
  {
#line 402
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 402
  tEmPcast = (AST_generic )tmp;
  }
#line 402
  if (tEmPcast) {
#line 402
    if ((unsigned int )tEmPcast->kind >= 89U) {
#line 402
      if (! ((unsigned int )tEmPcast->kind <= 89U)) {
        {
#line 402
        __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      402U, "preincrement_chain");
        }
      }
    } else {
      {
#line 402
      __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    402U, "preincrement_chain");
      }
    }
  }
#line 402
  return ((preincrement )tEmPcast);
}
}
#line 404 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
predecrement predecrement_chain(predecrement l1 , predecrement l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 405
  tEmPcast___0 = (AST_generic )l2;
#line 405
  if (tEmPcast___0) {
#line 405
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 405
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 405
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      405U, "predecrement_chain");
        }
      }
    } else {
      {
#line 405
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    405U, "predecrement_chain");
      }
    }
  }
#line 405
  tEmPcast___1 = (AST_generic )l1;
#line 405
  if (tEmPcast___1) {
#line 405
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 405
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 405
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      405U, "predecrement_chain");
        }
      }
    } else {
      {
#line 405
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    405U, "predecrement_chain");
      }
    }
  }
  {
#line 405
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 405
  tEmPcast = (AST_generic )tmp;
  }
#line 405
  if (tEmPcast) {
#line 405
    if ((unsigned int )tEmPcast->kind >= 90U) {
#line 405
      if (! ((unsigned int )tEmPcast->kind <= 90U)) {
        {
#line 405
        __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      405U, "predecrement_chain");
        }
      }
    } else {
      {
#line 405
      __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    405U, "predecrement_chain");
      }
    }
  }
#line 405
  return ((predecrement )tEmPcast);
}
}
#line 407 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
postincrement postincrement_chain(postincrement l1 , postincrement l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 408
  tEmPcast___0 = (AST_generic )l2;
#line 408
  if (tEmPcast___0) {
#line 408
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 408
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 408
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      408U, "postincrement_chain");
        }
      }
    } else {
      {
#line 408
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    408U, "postincrement_chain");
      }
    }
  }
#line 408
  tEmPcast___1 = (AST_generic )l1;
#line 408
  if (tEmPcast___1) {
#line 408
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 408
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 408
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      408U, "postincrement_chain");
        }
      }
    } else {
      {
#line 408
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    408U, "postincrement_chain");
      }
    }
  }
  {
#line 408
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 408
  tEmPcast = (AST_generic )tmp;
  }
#line 408
  if (tEmPcast) {
#line 408
    if ((unsigned int )tEmPcast->kind >= 91U) {
#line 408
      if (! ((unsigned int )tEmPcast->kind <= 91U)) {
        {
#line 408
        __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      408U, "postincrement_chain");
        }
      }
    } else {
      {
#line 408
      __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    408U, "postincrement_chain");
      }
    }
  }
#line 408
  return ((postincrement )tEmPcast);
}
}
#line 410 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
postdecrement postdecrement_chain(postdecrement l1 , postdecrement l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 411
  tEmPcast___0 = (AST_generic )l2;
#line 411
  if (tEmPcast___0) {
#line 411
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 411
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 411
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      411U, "postdecrement_chain");
        }
      }
    } else {
      {
#line 411
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    411U, "postdecrement_chain");
      }
    }
  }
#line 411
  tEmPcast___1 = (AST_generic )l1;
#line 411
  if (tEmPcast___1) {
#line 411
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 411
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 411
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      411U, "postdecrement_chain");
        }
      }
    } else {
      {
#line 411
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    411U, "postdecrement_chain");
      }
    }
  }
  {
#line 411
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 411
  tEmPcast = (AST_generic )tmp;
  }
#line 411
  if (tEmPcast) {
#line 411
    if ((unsigned int )tEmPcast->kind >= 92U) {
#line 411
      if (! ((unsigned int )tEmPcast->kind <= 92U)) {
        {
#line 411
        __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      411U, "postdecrement_chain");
        }
      }
    } else {
      {
#line 411
      __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    411U, "postdecrement_chain");
      }
    }
  }
#line 411
  return ((postdecrement )tEmPcast);
}
}
#line 413 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
plus plus_chain(plus l1 , plus l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 414
  tEmPcast___0 = (AST_generic )l2;
#line 414
  if (tEmPcast___0) {
#line 414
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 414
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 414
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      414U, "plus_chain");
        }
      }
    } else {
      {
#line 414
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    414U, "plus_chain");
      }
    }
  }
#line 414
  tEmPcast___1 = (AST_generic )l1;
#line 414
  if (tEmPcast___1) {
#line 414
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 414
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 414
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      414U, "plus_chain");
        }
      }
    } else {
      {
#line 414
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    414U, "plus_chain");
      }
    }
  }
  {
#line 414
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 414
  tEmPcast = (AST_generic )tmp;
  }
#line 414
  if (tEmPcast) {
#line 414
    if ((unsigned int )tEmPcast->kind >= 128U) {
#line 414
      if (! ((unsigned int )tEmPcast->kind <= 128U)) {
        {
#line 414
        __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      414U, "plus_chain");
        }
      }
    } else {
      {
#line 414
      __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    414U, "plus_chain");
      }
    }
  }
#line 414
  return ((plus )tEmPcast);
}
}
#line 416 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
minus minus_chain(minus l1 , minus l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 417
  tEmPcast___0 = (AST_generic )l2;
#line 417
  if (tEmPcast___0) {
#line 417
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 417
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 417
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      417U, "minus_chain");
        }
      }
    } else {
      {
#line 417
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    417U, "minus_chain");
      }
    }
  }
#line 417
  tEmPcast___1 = (AST_generic )l1;
#line 417
  if (tEmPcast___1) {
#line 417
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 417
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 417
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      417U, "minus_chain");
        }
      }
    } else {
      {
#line 417
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    417U, "minus_chain");
      }
    }
  }
  {
#line 417
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 417
  tEmPcast = (AST_generic )tmp;
  }
#line 417
  if (tEmPcast) {
#line 417
    if ((unsigned int )tEmPcast->kind >= 129U) {
#line 417
      if (! ((unsigned int )tEmPcast->kind <= 129U)) {
        {
#line 417
        __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      417U, "minus_chain");
        }
      }
    } else {
      {
#line 417
      __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    417U, "minus_chain");
      }
    }
  }
#line 417
  return ((minus )tEmPcast);
}
}
#line 419 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
times times_chain(times l1 , times l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 420
  tEmPcast___0 = (AST_generic )l2;
#line 420
  if (tEmPcast___0) {
#line 420
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 420
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 420
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      420U, "times_chain");
        }
      }
    } else {
      {
#line 420
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    420U, "times_chain");
      }
    }
  }
#line 420
  tEmPcast___1 = (AST_generic )l1;
#line 420
  if (tEmPcast___1) {
#line 420
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 420
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 420
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      420U, "times_chain");
        }
      }
    } else {
      {
#line 420
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    420U, "times_chain");
      }
    }
  }
  {
#line 420
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 420
  tEmPcast = (AST_generic )tmp;
  }
#line 420
  if (tEmPcast) {
#line 420
    if ((unsigned int )tEmPcast->kind >= 130U) {
#line 420
      if (! ((unsigned int )tEmPcast->kind <= 130U)) {
        {
#line 420
        __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      420U, "times_chain");
        }
      }
    } else {
      {
#line 420
      __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    420U, "times_chain");
      }
    }
  }
#line 420
  return ((times )tEmPcast);
}
}
#line 422 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
divide divide_chain(divide l1 , divide l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 423
  tEmPcast___0 = (AST_generic )l2;
#line 423
  if (tEmPcast___0) {
#line 423
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 423
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 423
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      423U, "divide_chain");
        }
      }
    } else {
      {
#line 423
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    423U, "divide_chain");
      }
    }
  }
#line 423
  tEmPcast___1 = (AST_generic )l1;
#line 423
  if (tEmPcast___1) {
#line 423
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 423
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 423
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      423U, "divide_chain");
        }
      }
    } else {
      {
#line 423
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    423U, "divide_chain");
      }
    }
  }
  {
#line 423
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 423
  tEmPcast = (AST_generic )tmp;
  }
#line 423
  if (tEmPcast) {
#line 423
    if ((unsigned int )tEmPcast->kind >= 131U) {
#line 423
      if (! ((unsigned int )tEmPcast->kind <= 131U)) {
        {
#line 423
        __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      423U, "divide_chain");
        }
      }
    } else {
      {
#line 423
      __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    423U, "divide_chain");
      }
    }
  }
#line 423
  return ((divide )tEmPcast);
}
}
#line 425 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
modulo modulo_chain(modulo l1 , modulo l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 426
  tEmPcast___0 = (AST_generic )l2;
#line 426
  if (tEmPcast___0) {
#line 426
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 426
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 426
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      426U, "modulo_chain");
        }
      }
    } else {
      {
#line 426
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    426U, "modulo_chain");
      }
    }
  }
#line 426
  tEmPcast___1 = (AST_generic )l1;
#line 426
  if (tEmPcast___1) {
#line 426
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 426
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 426
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      426U, "modulo_chain");
        }
      }
    } else {
      {
#line 426
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    426U, "modulo_chain");
      }
    }
  }
  {
#line 426
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 426
  tEmPcast = (AST_generic )tmp;
  }
#line 426
  if (tEmPcast) {
#line 426
    if ((unsigned int )tEmPcast->kind >= 132U) {
#line 426
      if (! ((unsigned int )tEmPcast->kind <= 132U)) {
        {
#line 426
        __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      426U, "modulo_chain");
        }
      }
    } else {
      {
#line 426
      __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    426U, "modulo_chain");
      }
    }
  }
#line 426
  return ((modulo )tEmPcast);
}
}
#line 428 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
lshift lshift_chain(lshift l1 , lshift l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 429
  tEmPcast___0 = (AST_generic )l2;
#line 429
  if (tEmPcast___0) {
#line 429
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 429
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 429
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      429U, "lshift_chain");
        }
      }
    } else {
      {
#line 429
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    429U, "lshift_chain");
      }
    }
  }
#line 429
  tEmPcast___1 = (AST_generic )l1;
#line 429
  if (tEmPcast___1) {
#line 429
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 429
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 429
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      429U, "lshift_chain");
        }
      }
    } else {
      {
#line 429
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    429U, "lshift_chain");
      }
    }
  }
  {
#line 429
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 429
  tEmPcast = (AST_generic )tmp;
  }
#line 429
  if (tEmPcast) {
#line 429
    if ((unsigned int )tEmPcast->kind >= 133U) {
#line 429
      if (! ((unsigned int )tEmPcast->kind <= 133U)) {
        {
#line 429
        __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      429U, "lshift_chain");
        }
      }
    } else {
      {
#line 429
      __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    429U, "lshift_chain");
      }
    }
  }
#line 429
  return ((lshift )tEmPcast);
}
}
#line 431 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
rshift rshift_chain(rshift l1 , rshift l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 432
  tEmPcast___0 = (AST_generic )l2;
#line 432
  if (tEmPcast___0) {
#line 432
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 432
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 432
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      432U, "rshift_chain");
        }
      }
    } else {
      {
#line 432
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    432U, "rshift_chain");
      }
    }
  }
#line 432
  tEmPcast___1 = (AST_generic )l1;
#line 432
  if (tEmPcast___1) {
#line 432
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 432
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 432
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      432U, "rshift_chain");
        }
      }
    } else {
      {
#line 432
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    432U, "rshift_chain");
      }
    }
  }
  {
#line 432
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 432
  tEmPcast = (AST_generic )tmp;
  }
#line 432
  if (tEmPcast) {
#line 432
    if ((unsigned int )tEmPcast->kind >= 134U) {
#line 432
      if (! ((unsigned int )tEmPcast->kind <= 134U)) {
        {
#line 432
        __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      432U, "rshift_chain");
        }
      }
    } else {
      {
#line 432
      __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    432U, "rshift_chain");
      }
    }
  }
#line 432
  return ((rshift )tEmPcast);
}
}
#line 434 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
leq leq_chain(leq l1 , leq l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 435
  tEmPcast___0 = (AST_generic )l2;
#line 435
  if (tEmPcast___0) {
#line 435
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 435
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 435
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      435U, "leq_chain");
        }
      }
    } else {
      {
#line 435
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    435U, "leq_chain");
      }
    }
  }
#line 435
  tEmPcast___1 = (AST_generic )l1;
#line 435
  if (tEmPcast___1) {
#line 435
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 435
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 435
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      435U, "leq_chain");
        }
      }
    } else {
      {
#line 435
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    435U, "leq_chain");
      }
    }
  }
  {
#line 435
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 435
  tEmPcast = (AST_generic )tmp;
  }
#line 435
  if (tEmPcast) {
#line 435
    if ((unsigned int )tEmPcast->kind >= 109U) {
#line 435
      if (! ((unsigned int )tEmPcast->kind <= 109U)) {
        {
#line 435
        __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      435U, "leq_chain");
        }
      }
    } else {
      {
#line 435
      __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    435U, "leq_chain");
      }
    }
  }
#line 435
  return ((leq )tEmPcast);
}
}
#line 437 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
geq geq_chain(geq l1 , geq l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 438
  tEmPcast___0 = (AST_generic )l2;
#line 438
  if (tEmPcast___0) {
#line 438
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 438
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 438
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      438U, "geq_chain");
        }
      }
    } else {
      {
#line 438
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    438U, "geq_chain");
      }
    }
  }
#line 438
  tEmPcast___1 = (AST_generic )l1;
#line 438
  if (tEmPcast___1) {
#line 438
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 438
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 438
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      438U, "geq_chain");
        }
      }
    } else {
      {
#line 438
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    438U, "geq_chain");
      }
    }
  }
  {
#line 438
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 438
  tEmPcast = (AST_generic )tmp;
  }
#line 438
  if (tEmPcast) {
#line 438
    if ((unsigned int )tEmPcast->kind >= 110U) {
#line 438
      if (! ((unsigned int )tEmPcast->kind <= 110U)) {
        {
#line 438
        __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      438U, "geq_chain");
        }
      }
    } else {
      {
#line 438
      __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    438U, "geq_chain");
      }
    }
  }
#line 438
  return ((geq )tEmPcast);
}
}
#line 440 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
lt lt_chain(lt l1 , lt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 441
  tEmPcast___0 = (AST_generic )l2;
#line 441
  if (tEmPcast___0) {
#line 441
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 441
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 441
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      441U, "lt_chain");
        }
      }
    } else {
      {
#line 441
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    441U, "lt_chain");
      }
    }
  }
#line 441
  tEmPcast___1 = (AST_generic )l1;
#line 441
  if (tEmPcast___1) {
#line 441
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 441
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 441
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      441U, "lt_chain");
        }
      }
    } else {
      {
#line 441
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    441U, "lt_chain");
      }
    }
  }
  {
#line 441
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 441
  tEmPcast = (AST_generic )tmp;
  }
#line 441
  if (tEmPcast) {
#line 441
    if ((unsigned int )tEmPcast->kind >= 111U) {
#line 441
      if (! ((unsigned int )tEmPcast->kind <= 111U)) {
        {
#line 441
        __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      441U, "lt_chain");
        }
      }
    } else {
      {
#line 441
      __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    441U, "lt_chain");
      }
    }
  }
#line 441
  return ((lt )tEmPcast);
}
}
#line 443 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
gt gt_chain(gt l1 , gt l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 444
  tEmPcast___0 = (AST_generic )l2;
#line 444
  if (tEmPcast___0) {
#line 444
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 444
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 444
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      444U, "gt_chain");
        }
      }
    } else {
      {
#line 444
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    444U, "gt_chain");
      }
    }
  }
#line 444
  tEmPcast___1 = (AST_generic )l1;
#line 444
  if (tEmPcast___1) {
#line 444
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 444
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 444
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      444U, "gt_chain");
        }
      }
    } else {
      {
#line 444
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    444U, "gt_chain");
      }
    }
  }
  {
#line 444
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 444
  tEmPcast = (AST_generic )tmp;
  }
#line 444
  if (tEmPcast) {
#line 444
    if ((unsigned int )tEmPcast->kind >= 112U) {
#line 444
      if (! ((unsigned int )tEmPcast->kind <= 112U)) {
        {
#line 444
        __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      444U, "gt_chain");
        }
      }
    } else {
      {
#line 444
      __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    444U, "gt_chain");
      }
    }
  }
#line 444
  return ((gt )tEmPcast);
}
}
#line 446 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
eq eq_chain(eq l1 , eq l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 447
  tEmPcast___0 = (AST_generic )l2;
#line 447
  if (tEmPcast___0) {
#line 447
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 447
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 447
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      447U, "eq_chain");
        }
      }
    } else {
      {
#line 447
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    447U, "eq_chain");
      }
    }
  }
#line 447
  tEmPcast___1 = (AST_generic )l1;
#line 447
  if (tEmPcast___1) {
#line 447
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 447
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 447
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      447U, "eq_chain");
        }
      }
    } else {
      {
#line 447
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    447U, "eq_chain");
      }
    }
  }
  {
#line 447
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 447
  tEmPcast = (AST_generic )tmp;
  }
#line 447
  if (tEmPcast) {
#line 447
    if ((unsigned int )tEmPcast->kind >= 113U) {
#line 447
      if (! ((unsigned int )tEmPcast->kind <= 113U)) {
        {
#line 447
        __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      447U, "eq_chain");
        }
      }
    } else {
      {
#line 447
      __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    447U, "eq_chain");
      }
    }
  }
#line 447
  return ((eq )tEmPcast);
}
}
#line 449 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
ne ne_chain(ne l1 , ne l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 450
  tEmPcast___0 = (AST_generic )l2;
#line 450
  if (tEmPcast___0) {
#line 450
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 450
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 450
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      450U, "ne_chain");
        }
      }
    } else {
      {
#line 450
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    450U, "ne_chain");
      }
    }
  }
#line 450
  tEmPcast___1 = (AST_generic )l1;
#line 450
  if (tEmPcast___1) {
#line 450
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 450
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 450
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      450U, "ne_chain");
        }
      }
    } else {
      {
#line 450
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    450U, "ne_chain");
      }
    }
  }
  {
#line 450
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 450
  tEmPcast = (AST_generic )tmp;
  }
#line 450
  if (tEmPcast) {
#line 450
    if ((unsigned int )tEmPcast->kind >= 114U) {
#line 450
      if (! ((unsigned int )tEmPcast->kind <= 114U)) {
        {
#line 450
        __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      450U, "ne_chain");
        }
      }
    } else {
      {
#line 450
      __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    450U, "ne_chain");
      }
    }
  }
#line 450
  return ((ne )tEmPcast);
}
}
#line 452 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitand bitand_chain(bitand l1 , bitand l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 453
  tEmPcast___0 = (AST_generic )l2;
#line 453
  if (tEmPcast___0) {
#line 453
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 453
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 453
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      453U, "bitand_chain");
        }
      }
    } else {
      {
#line 453
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    453U, "bitand_chain");
      }
    }
  }
#line 453
  tEmPcast___1 = (AST_generic )l1;
#line 453
  if (tEmPcast___1) {
#line 453
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 453
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 453
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      453U, "bitand_chain");
        }
      }
    } else {
      {
#line 453
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    453U, "bitand_chain");
      }
    }
  }
  {
#line 453
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 453
  tEmPcast = (AST_generic )tmp;
  }
#line 453
  if (tEmPcast) {
#line 453
    if ((unsigned int )tEmPcast->kind >= 135U) {
#line 453
      if (! ((unsigned int )tEmPcast->kind <= 135U)) {
        {
#line 453
        __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      453U, "bitand_chain");
        }
      }
    } else {
      {
#line 453
      __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    453U, "bitand_chain");
      }
    }
  }
#line 453
  return ((bitand )tEmPcast);
}
}
#line 455 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitor bitor_chain(bitor l1 , bitor l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 456
  tEmPcast___0 = (AST_generic )l2;
#line 456
  if (tEmPcast___0) {
#line 456
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 456
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 456
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      456U, "bitor_chain");
        }
      }
    } else {
      {
#line 456
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    456U, "bitor_chain");
      }
    }
  }
#line 456
  tEmPcast___1 = (AST_generic )l1;
#line 456
  if (tEmPcast___1) {
#line 456
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 456
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 456
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      456U, "bitor_chain");
        }
      }
    } else {
      {
#line 456
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    456U, "bitor_chain");
      }
    }
  }
  {
#line 456
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 456
  tEmPcast = (AST_generic )tmp;
  }
#line 456
  if (tEmPcast) {
#line 456
    if ((unsigned int )tEmPcast->kind >= 136U) {
#line 456
      if (! ((unsigned int )tEmPcast->kind <= 136U)) {
        {
#line 456
        __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      456U, "bitor_chain");
        }
      }
    } else {
      {
#line 456
      __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    456U, "bitor_chain");
      }
    }
  }
#line 456
  return ((bitor )tEmPcast);
}
}
#line 458 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitxor bitxor_chain(bitxor l1 , bitxor l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 459
  tEmPcast___0 = (AST_generic )l2;
#line 459
  if (tEmPcast___0) {
#line 459
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 459
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 459
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      459U, "bitxor_chain");
        }
      }
    } else {
      {
#line 459
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    459U, "bitxor_chain");
      }
    }
  }
#line 459
  tEmPcast___1 = (AST_generic )l1;
#line 459
  if (tEmPcast___1) {
#line 459
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 459
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 459
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      459U, "bitxor_chain");
        }
      }
    } else {
      {
#line 459
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    459U, "bitxor_chain");
      }
    }
  }
  {
#line 459
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 459
  tEmPcast = (AST_generic )tmp;
  }
#line 459
  if (tEmPcast) {
#line 459
    if ((unsigned int )tEmPcast->kind >= 137U) {
#line 459
      if (! ((unsigned int )tEmPcast->kind <= 137U)) {
        {
#line 459
        __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      459U, "bitxor_chain");
        }
      }
    } else {
      {
#line 459
      __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    459U, "bitxor_chain");
      }
    }
  }
#line 459
  return ((bitxor )tEmPcast);
}
}
#line 461 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
andand andand_chain(andand l1 , andand l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 462
  tEmPcast___0 = (AST_generic )l2;
#line 462
  if (tEmPcast___0) {
#line 462
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 462
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 462
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      462U, "andand_chain");
        }
      }
    } else {
      {
#line 462
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    462U, "andand_chain");
      }
    }
  }
#line 462
  tEmPcast___1 = (AST_generic )l1;
#line 462
  if (tEmPcast___1) {
#line 462
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 462
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 462
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      462U, "andand_chain");
        }
      }
    } else {
      {
#line 462
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    462U, "andand_chain");
      }
    }
  }
  {
#line 462
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 462
  tEmPcast = (AST_generic )tmp;
  }
#line 462
  if (tEmPcast) {
#line 462
    if ((unsigned int )tEmPcast->kind >= 138U) {
#line 462
      if (! ((unsigned int )tEmPcast->kind <= 138U)) {
        {
#line 462
        __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      462U, "andand_chain");
        }
      }
    } else {
      {
#line 462
      __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    462U, "andand_chain");
      }
    }
  }
#line 462
  return ((andand )tEmPcast);
}
}
#line 464 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
oror oror_chain(oror l1 , oror l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 465
  tEmPcast___0 = (AST_generic )l2;
#line 465
  if (tEmPcast___0) {
#line 465
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 465
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 465
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      465U, "oror_chain");
        }
      }
    } else {
      {
#line 465
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    465U, "oror_chain");
      }
    }
  }
#line 465
  tEmPcast___1 = (AST_generic )l1;
#line 465
  if (tEmPcast___1) {
#line 465
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 465
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 465
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      465U, "oror_chain");
        }
      }
    } else {
      {
#line 465
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    465U, "oror_chain");
      }
    }
  }
  {
#line 465
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 465
  tEmPcast = (AST_generic )tmp;
  }
#line 465
  if (tEmPcast) {
#line 465
    if ((unsigned int )tEmPcast->kind >= 139U) {
#line 465
      if (! ((unsigned int )tEmPcast->kind <= 139U)) {
        {
#line 465
        __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      465U, "oror_chain");
        }
      }
    } else {
      {
#line 465
      __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    465U, "oror_chain");
      }
    }
  }
#line 465
  return ((oror )tEmPcast);
}
}
#line 467 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
assign assign_chain(assign l1 , assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 468
  tEmPcast___0 = (AST_generic )l2;
#line 468
  if (tEmPcast___0) {
#line 468
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 468
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      468U, "assign_chain");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    468U, "assign_chain");
      }
    }
  }
#line 468
  tEmPcast___1 = (AST_generic )l1;
#line 468
  if (tEmPcast___1) {
#line 468
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 468
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      468U, "assign_chain");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    468U, "assign_chain");
      }
    }
  }
  {
#line 468
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 468
  tEmPcast = (AST_generic )tmp;
  }
#line 468
  if (tEmPcast) {
#line 468
    if ((unsigned int )tEmPcast->kind >= 116U) {
#line 468
      if (! ((unsigned int )tEmPcast->kind <= 116U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      468U, "assign_chain");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    468U, "assign_chain");
      }
    }
  }
#line 468
  return ((assign )tEmPcast);
}
}
#line 470 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
plus_assign plus_assign_chain(plus_assign l1 , plus_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 471
  tEmPcast___0 = (AST_generic )l2;
#line 471
  if (tEmPcast___0) {
#line 471
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 471
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 471
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      471U, "plus_assign_chain");
        }
      }
    } else {
      {
#line 471
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    471U, "plus_assign_chain");
      }
    }
  }
#line 471
  tEmPcast___1 = (AST_generic )l1;
#line 471
  if (tEmPcast___1) {
#line 471
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 471
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 471
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      471U, "plus_assign_chain");
        }
      }
    } else {
      {
#line 471
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    471U, "plus_assign_chain");
      }
    }
  }
  {
#line 471
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 471
  tEmPcast = (AST_generic )tmp;
  }
#line 471
  if (tEmPcast) {
#line 471
    if ((unsigned int )tEmPcast->kind >= 117U) {
#line 471
      if (! ((unsigned int )tEmPcast->kind <= 117U)) {
        {
#line 471
        __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      471U, "plus_assign_chain");
        }
      }
    } else {
      {
#line 471
      __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    471U, "plus_assign_chain");
      }
    }
  }
#line 471
  return ((plus_assign )tEmPcast);
}
}
#line 473 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
minus_assign minus_assign_chain(minus_assign l1 , minus_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 474
  tEmPcast___0 = (AST_generic )l2;
#line 474
  if (tEmPcast___0) {
#line 474
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 474
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 474
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      474U, "minus_assign_chain");
        }
      }
    } else {
      {
#line 474
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    474U, "minus_assign_chain");
      }
    }
  }
#line 474
  tEmPcast___1 = (AST_generic )l1;
#line 474
  if (tEmPcast___1) {
#line 474
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 474
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 474
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      474U, "minus_assign_chain");
        }
      }
    } else {
      {
#line 474
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    474U, "minus_assign_chain");
      }
    }
  }
  {
#line 474
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 474
  tEmPcast = (AST_generic )tmp;
  }
#line 474
  if (tEmPcast) {
#line 474
    if ((unsigned int )tEmPcast->kind >= 118U) {
#line 474
      if (! ((unsigned int )tEmPcast->kind <= 118U)) {
        {
#line 474
        __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      474U, "minus_assign_chain");
        }
      }
    } else {
      {
#line 474
      __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    474U, "minus_assign_chain");
      }
    }
  }
#line 474
  return ((minus_assign )tEmPcast);
}
}
#line 476 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
times_assign times_assign_chain(times_assign l1 , times_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 477
  tEmPcast___0 = (AST_generic )l2;
#line 477
  if (tEmPcast___0) {
#line 477
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 477
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 477
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      477U, "times_assign_chain");
        }
      }
    } else {
      {
#line 477
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    477U, "times_assign_chain");
      }
    }
  }
#line 477
  tEmPcast___1 = (AST_generic )l1;
#line 477
  if (tEmPcast___1) {
#line 477
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 477
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 477
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      477U, "times_assign_chain");
        }
      }
    } else {
      {
#line 477
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    477U, "times_assign_chain");
      }
    }
  }
  {
#line 477
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 477
  tEmPcast = (AST_generic )tmp;
  }
#line 477
  if (tEmPcast) {
#line 477
    if ((unsigned int )tEmPcast->kind >= 119U) {
#line 477
      if (! ((unsigned int )tEmPcast->kind <= 119U)) {
        {
#line 477
        __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      477U, "times_assign_chain");
        }
      }
    } else {
      {
#line 477
      __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    477U, "times_assign_chain");
      }
    }
  }
#line 477
  return ((times_assign )tEmPcast);
}
}
#line 479 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
divide_assign divide_assign_chain(divide_assign l1 , divide_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 480
  tEmPcast___0 = (AST_generic )l2;
#line 480
  if (tEmPcast___0) {
#line 480
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 480
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 480
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      480U, "divide_assign_chain");
        }
      }
    } else {
      {
#line 480
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    480U, "divide_assign_chain");
      }
    }
  }
#line 480
  tEmPcast___1 = (AST_generic )l1;
#line 480
  if (tEmPcast___1) {
#line 480
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 480
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 480
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      480U, "divide_assign_chain");
        }
      }
    } else {
      {
#line 480
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    480U, "divide_assign_chain");
      }
    }
  }
  {
#line 480
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 480
  tEmPcast = (AST_generic )tmp;
  }
#line 480
  if (tEmPcast) {
#line 480
    if ((unsigned int )tEmPcast->kind >= 120U) {
#line 480
      if (! ((unsigned int )tEmPcast->kind <= 120U)) {
        {
#line 480
        __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      480U, "divide_assign_chain");
        }
      }
    } else {
      {
#line 480
      __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    480U, "divide_assign_chain");
      }
    }
  }
#line 480
  return ((divide_assign )tEmPcast);
}
}
#line 482 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
modulo_assign modulo_assign_chain(modulo_assign l1 , modulo_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 483
  tEmPcast___0 = (AST_generic )l2;
#line 483
  if (tEmPcast___0) {
#line 483
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 483
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 483
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      483U, "modulo_assign_chain");
        }
      }
    } else {
      {
#line 483
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    483U, "modulo_assign_chain");
      }
    }
  }
#line 483
  tEmPcast___1 = (AST_generic )l1;
#line 483
  if (tEmPcast___1) {
#line 483
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 483
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 483
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      483U, "modulo_assign_chain");
        }
      }
    } else {
      {
#line 483
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    483U, "modulo_assign_chain");
      }
    }
  }
  {
#line 483
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 483
  tEmPcast = (AST_generic )tmp;
  }
#line 483
  if (tEmPcast) {
#line 483
    if ((unsigned int )tEmPcast->kind >= 121U) {
#line 483
      if (! ((unsigned int )tEmPcast->kind <= 121U)) {
        {
#line 483
        __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      483U, "modulo_assign_chain");
        }
      }
    } else {
      {
#line 483
      __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    483U, "modulo_assign_chain");
      }
    }
  }
#line 483
  return ((modulo_assign )tEmPcast);
}
}
#line 485 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
lshift_assign lshift_assign_chain(lshift_assign l1 , lshift_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 486
  tEmPcast___0 = (AST_generic )l2;
#line 486
  if (tEmPcast___0) {
#line 486
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 486
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 486
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      486U, "lshift_assign_chain");
        }
      }
    } else {
      {
#line 486
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    486U, "lshift_assign_chain");
      }
    }
  }
#line 486
  tEmPcast___1 = (AST_generic )l1;
#line 486
  if (tEmPcast___1) {
#line 486
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 486
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 486
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      486U, "lshift_assign_chain");
        }
      }
    } else {
      {
#line 486
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    486U, "lshift_assign_chain");
      }
    }
  }
  {
#line 486
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 486
  tEmPcast = (AST_generic )tmp;
  }
#line 486
  if (tEmPcast) {
#line 486
    if ((unsigned int )tEmPcast->kind >= 122U) {
#line 486
      if (! ((unsigned int )tEmPcast->kind <= 122U)) {
        {
#line 486
        __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      486U, "lshift_assign_chain");
        }
      }
    } else {
      {
#line 486
      __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    486U, "lshift_assign_chain");
      }
    }
  }
#line 486
  return ((lshift_assign )tEmPcast);
}
}
#line 488 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
rshift_assign rshift_assign_chain(rshift_assign l1 , rshift_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 489
  tEmPcast___0 = (AST_generic )l2;
#line 489
  if (tEmPcast___0) {
#line 489
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 489
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 489
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      489U, "rshift_assign_chain");
        }
      }
    } else {
      {
#line 489
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    489U, "rshift_assign_chain");
      }
    }
  }
#line 489
  tEmPcast___1 = (AST_generic )l1;
#line 489
  if (tEmPcast___1) {
#line 489
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 489
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 489
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      489U, "rshift_assign_chain");
        }
      }
    } else {
      {
#line 489
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    489U, "rshift_assign_chain");
      }
    }
  }
  {
#line 489
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 489
  tEmPcast = (AST_generic )tmp;
  }
#line 489
  if (tEmPcast) {
#line 489
    if ((unsigned int )tEmPcast->kind >= 123U) {
#line 489
      if (! ((unsigned int )tEmPcast->kind <= 123U)) {
        {
#line 489
        __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      489U, "rshift_assign_chain");
        }
      }
    } else {
      {
#line 489
      __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    489U, "rshift_assign_chain");
      }
    }
  }
#line 489
  return ((rshift_assign )tEmPcast);
}
}
#line 491 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitand_assign bitand_assign_chain(bitand_assign l1 , bitand_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 492
  tEmPcast___0 = (AST_generic )l2;
#line 492
  if (tEmPcast___0) {
#line 492
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 492
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 492
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      492U, "bitand_assign_chain");
        }
      }
    } else {
      {
#line 492
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    492U, "bitand_assign_chain");
      }
    }
  }
#line 492
  tEmPcast___1 = (AST_generic )l1;
#line 492
  if (tEmPcast___1) {
#line 492
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 492
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 492
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      492U, "bitand_assign_chain");
        }
      }
    } else {
      {
#line 492
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    492U, "bitand_assign_chain");
      }
    }
  }
  {
#line 492
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 492
  tEmPcast = (AST_generic )tmp;
  }
#line 492
  if (tEmPcast) {
#line 492
    if ((unsigned int )tEmPcast->kind >= 124U) {
#line 492
      if (! ((unsigned int )tEmPcast->kind <= 124U)) {
        {
#line 492
        __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      492U, "bitand_assign_chain");
        }
      }
    } else {
      {
#line 492
      __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    492U, "bitand_assign_chain");
      }
    }
  }
#line 492
  return ((bitand_assign )tEmPcast);
}
}
#line 494 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitor_assign bitor_assign_chain(bitor_assign l1 , bitor_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 495
  tEmPcast___0 = (AST_generic )l2;
#line 495
  if (tEmPcast___0) {
#line 495
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 495
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 495
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      495U, "bitor_assign_chain");
        }
      }
    } else {
      {
#line 495
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    495U, "bitor_assign_chain");
      }
    }
  }
#line 495
  tEmPcast___1 = (AST_generic )l1;
#line 495
  if (tEmPcast___1) {
#line 495
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 495
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 495
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      495U, "bitor_assign_chain");
        }
      }
    } else {
      {
#line 495
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    495U, "bitor_assign_chain");
      }
    }
  }
  {
#line 495
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 495
  tEmPcast = (AST_generic )tmp;
  }
#line 495
  if (tEmPcast) {
#line 495
    if ((unsigned int )tEmPcast->kind >= 125U) {
#line 495
      if (! ((unsigned int )tEmPcast->kind <= 125U)) {
        {
#line 495
        __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      495U, "bitor_assign_chain");
        }
      }
    } else {
      {
#line 495
      __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    495U, "bitor_assign_chain");
      }
    }
  }
#line 495
  return ((bitor_assign )tEmPcast);
}
}
#line 497 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
bitxor_assign bitxor_assign_chain(bitxor_assign l1 , bitxor_assign l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 498
  tEmPcast___0 = (AST_generic )l2;
#line 498
  if (tEmPcast___0) {
#line 498
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 498
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 498
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      498U, "bitxor_assign_chain");
        }
      }
    } else {
      {
#line 498
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    498U, "bitxor_assign_chain");
      }
    }
  }
#line 498
  tEmPcast___1 = (AST_generic )l1;
#line 498
  if (tEmPcast___1) {
#line 498
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 498
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 498
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      498U, "bitxor_assign_chain");
        }
      }
    } else {
      {
#line 498
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    498U, "bitxor_assign_chain");
      }
    }
  }
  {
#line 498
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 498
  tEmPcast = (AST_generic )tmp;
  }
#line 498
  if (tEmPcast) {
#line 498
    if ((unsigned int )tEmPcast->kind >= 126U) {
#line 498
      if (! ((unsigned int )tEmPcast->kind <= 126U)) {
        {
#line 498
        __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      498U, "bitxor_assign_chain");
        }
      }
    } else {
      {
#line 498
      __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    498U, "bitxor_assign_chain");
      }
    }
  }
#line 498
  return ((bitxor_assign )tEmPcast);
}
}
#line 500 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
rp_connection rp_connection_chain(rp_connection l1 , rp_connection l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 501
  tEmPcast___0 = (AST_generic )l2;
#line 501
  if (tEmPcast___0) {
#line 501
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 501
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 501
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      501U, "rp_connection_chain");
        }
      }
    } else {
      {
#line 501
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    501U, "rp_connection_chain");
      }
    }
  }
#line 501
  tEmPcast___1 = (AST_generic )l1;
#line 501
  if (tEmPcast___1) {
#line 501
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 501
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 501
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      501U, "rp_connection_chain");
        }
      }
    } else {
      {
#line 501
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    501U, "rp_connection_chain");
      }
    }
  }
  {
#line 501
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 501
  tEmPcast = (AST_generic )tmp;
  }
#line 501
  if (tEmPcast) {
#line 501
    if ((unsigned int )tEmPcast->kind >= 61U) {
#line 501
      if (! ((unsigned int )tEmPcast->kind <= 61U)) {
        {
#line 501
        __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      501U, "rp_connection_chain");
        }
      }
    } else {
      {
#line 501
      __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    501U, "rp_connection_chain");
      }
    }
  }
#line 501
  return ((rp_connection )tEmPcast);
}
}
#line 503 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
eq_connection eq_connection_chain(eq_connection l1 , eq_connection l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 504
  tEmPcast___0 = (AST_generic )l2;
#line 504
  if (tEmPcast___0) {
#line 504
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 504
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 504
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      504U, "eq_connection_chain");
        }
      }
    } else {
      {
#line 504
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    504U, "eq_connection_chain");
      }
    }
  }
#line 504
  tEmPcast___1 = (AST_generic )l1;
#line 504
  if (tEmPcast___1) {
#line 504
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 504
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 504
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      504U, "eq_connection_chain");
        }
      }
    } else {
      {
#line 504
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    504U, "eq_connection_chain");
      }
    }
  }
  {
#line 504
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 504
  tEmPcast = (AST_generic )tmp;
  }
#line 504
  if (tEmPcast) {
#line 504
    if ((unsigned int )tEmPcast->kind >= 62U) {
#line 504
      if (! ((unsigned int )tEmPcast->kind <= 62U)) {
        {
#line 504
        __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      504U, "eq_connection_chain");
        }
      }
    } else {
      {
#line 504
      __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    504U, "eq_connection_chain");
      }
    }
  }
#line 504
  return ((eq_connection )tEmPcast);
}
}
#line 506 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
nx_struct_ref nx_struct_ref_chain(nx_struct_ref l1 , nx_struct_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 507
  tEmPcast___0 = (AST_generic )l2;
#line 507
  if (tEmPcast___0) {
#line 507
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 507
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 507
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      507U, "nx_struct_ref_chain");
        }
      }
    } else {
      {
#line 507
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    507U, "nx_struct_ref_chain");
      }
    }
  }
#line 507
  tEmPcast___1 = (AST_generic )l1;
#line 507
  if (tEmPcast___1) {
#line 507
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 507
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 507
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      507U, "nx_struct_ref_chain");
        }
      }
    } else {
      {
#line 507
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    507U, "nx_struct_ref_chain");
      }
    }
  }
  {
#line 507
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 507
  tEmPcast = (AST_generic )tmp;
  }
#line 507
  if (tEmPcast) {
#line 507
    if ((unsigned int )tEmPcast->kind >= 170U) {
#line 507
      if (! ((unsigned int )tEmPcast->kind <= 170U)) {
        {
#line 507
        __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      507U, "nx_struct_ref_chain");
        }
      }
    } else {
      {
#line 507
      __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    507U, "nx_struct_ref_chain");
      }
    }
  }
#line 507
  return ((nx_struct_ref )tEmPcast);
}
}
#line 509 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
nx_union_ref nx_union_ref_chain(nx_union_ref l1 , nx_union_ref l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 510
  tEmPcast___0 = (AST_generic )l2;
#line 510
  if (tEmPcast___0) {
#line 510
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 510
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 510
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      510U, "nx_union_ref_chain");
        }
      }
    } else {
      {
#line 510
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    510U, "nx_union_ref_chain");
      }
    }
  }
#line 510
  tEmPcast___1 = (AST_generic )l1;
#line 510
  if (tEmPcast___1) {
#line 510
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 510
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 510
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      510U, "nx_union_ref_chain");
        }
      }
    } else {
      {
#line 510
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    510U, "nx_union_ref_chain");
      }
    }
  }
  {
#line 510
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 510
  tEmPcast = (AST_generic )tmp;
  }
#line 510
  if (tEmPcast) {
#line 510
    if ((unsigned int )tEmPcast->kind >= 172U) {
#line 510
      if (! ((unsigned int )tEmPcast->kind <= 172U)) {
        {
#line 510
        __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      510U, "nx_union_ref_chain");
        }
      }
    } else {
      {
#line 510
      __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    510U, "nx_union_ref_chain");
      }
    }
  }
#line 510
  return ((nx_union_ref )tEmPcast);
}
}
#line 512 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c"
target_attribute target_attribute_chain(target_attribute l1 , target_attribute l2 ) 
{ 
  AST_generic tEmPcast ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  node tmp ;

  {
#line 513
  tEmPcast___0 = (AST_generic )l2;
#line 513
  if (tEmPcast___0) {
#line 513
    if ((unsigned int )tEmPcast___0->kind >= 42U) {
#line 513
      if (! ((unsigned int )tEmPcast___0->kind <= 199U)) {
        {
#line 513
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      513U, "target_attribute_chain");
        }
      }
    } else {
      {
#line 513
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    513U, "target_attribute_chain");
      }
    }
  }
#line 513
  tEmPcast___1 = (AST_generic )l1;
#line 513
  if (tEmPcast___1) {
#line 513
    if ((unsigned int )tEmPcast___1->kind >= 42U) {
#line 513
      if (! ((unsigned int )tEmPcast___1->kind <= 199U)) {
        {
#line 513
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      513U, "target_attribute_chain");
        }
      }
    } else {
      {
#line 513
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    513U, "target_attribute_chain");
      }
    }
  }
  {
#line 513
  tmp = AST_node_chain((node )tEmPcast___1, (node )tEmPcast___0);
#line 513
  tEmPcast = (AST_generic )tmp;
  }
#line 513
  if (tEmPcast) {
#line 513
    if ((unsigned int )tEmPcast->kind >= 164U) {
#line 513
      if (! ((unsigned int )tEmPcast->kind <= 164U)) {
        {
#line 513
        __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                      513U, "target_attribute_chain");
        }
      }
    } else {
      {
#line 513
      __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_list_node.c",
                    513U, "target_attribute_chain");
      }
    }
  }
#line 513
  return ((target_attribute )tEmPcast);
}
}
#line 28 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
void insert_before(node *list , node before , node n ) 
{ 


  {
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ((unsigned long )*list != (unsigned long )before)) {
#line 30
      goto while_break;
    }
#line 31
    list = & (*list)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  *list = n;
#line 33
  n->next = before;
#line 34
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
unary newkind_unary(region r , AST_kind kind , location location___0 , expression arg1 ) 
{ 
  unary obj ;
  unary tmp ;

  {
  {
#line 39
  tmp = new_unary(r, location___0, arg1);
#line 39
  obj = tmp;
#line 41
  obj->kind = kind;
  }
#line 43
  return (obj);
}
}
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
binary newkind_binary(region r , AST_kind kind , location location___0 , expression arg1 ,
                      expression arg2 ) 
{ 
  binary obj ;
  AST_generic tEmPcast ;
  assign tmp ;

  {
#line 51
  if ((unsigned int )kind >= 115U) {
#line 51
    if ((unsigned int )kind <= 126U) {
      {
#line 52
      tmp = new_assign(r, location___0, arg1, arg2);
#line 52
      tEmPcast = (AST_generic )tmp;
      }
#line 52
      if (tEmPcast) {
#line 52
        if ((unsigned int )tEmPcast->kind >= 107U) {
#line 52
          if (! ((unsigned int )tEmPcast->kind <= 139U)) {
            {
#line 52
            __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 52U,
                          "newkind_binary");
            }
          }
        } else {
          {
#line 52
          __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 52U, "newkind_binary");
          }
        }
      }
#line 52
      obj = (binary )tEmPcast;
    } else {
      {
#line 54
      obj = new_binary(r, location___0, arg1, arg2);
      }
    }
  } else {
    {
#line 54
    obj = new_binary(r, location___0, arg1, arg2);
    }
  }
#line 56
  obj->kind = kind;
#line 58
  return (obj);
}
}
#line 61 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
tag_ref newkind_tag_ref(region r , AST_kind kind , location location___0 , word word1 ,
                        attribute attributes , declaration fields , bool defined ) 
{ 
  tag_ref obj ;
  tag_ref tmp ;

  {
  {
#line 63
  tmp = new_tag_ref(r, location___0, word1, attributes, fields, defined);
#line 63
  obj = tmp;
#line 65
  obj->kind = kind;
  }
#line 67
  return (obj);
}
}
#line 72 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void AST_set_parent(node *nptr , node parent ) 
{ 


  {
#line 74
  (*nptr)->parent = parent;
#line 75
  (*nptr)->parent_ptr = nptr;
#line 76
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
void set_parent(node *nptr , node parent ) 
{ 


  {
#line 80
  (*nptr)->parent = parent;
#line 81
  (*nptr)->parent_ptr = nptr;
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
void set_parent_list(node *list , node parent ) 
{ 


  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! *list) {
#line 86
      goto while_break;
    }
    {
#line 88
    set_parent(list, parent);
#line 89
    list = & (*list)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93
static void AST_set_parent_list(void *vnptr , node parent ) ;
#line 95 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void AST_set_parent1(node *nptr , node parent ) 
{ 
  node n ;
  asm_decl x ;
  AST_generic tEmPcast ;
  data_decl x___0 ;
  AST_generic tEmPcast___0 ;
  extension_decl x___1 ;
  AST_generic tEmPcast___1 ;
  enumerator x___2 ;
  AST_generic tEmPcast___2 ;
  function_decl x___3 ;
  AST_generic tEmPcast___3 ;
  variable_decl x___4 ;
  AST_generic tEmPcast___4 ;
  field_decl x___5 ;
  AST_generic tEmPcast___5 ;
  asttype x___6 ;
  AST_generic tEmPcast___6 ;
  typeof_expr x___7 ;
  AST_generic tEmPcast___7 ;
  typeof_type x___8 ;
  AST_generic tEmPcast___8 ;
  attribute x___9 ;
  AST_generic tEmPcast___9 ;
  gcc_attribute x___10 ;
  AST_generic tEmPcast___10 ;
  tag_ref x___11 ;
  AST_generic tEmPcast___11 ;
  struct_ref x___12 ;
  AST_generic tEmPcast___12 ;
  union_ref x___13 ;
  AST_generic tEmPcast___13 ;
  nested_declarator x___14 ;
  AST_generic tEmPcast___14 ;
  function_declarator x___15 ;
  AST_generic tEmPcast___15 ;
  pointer_declarator x___16 ;
  AST_generic tEmPcast___16 ;
  qualified_declarator x___17 ;
  AST_generic tEmPcast___17 ;
  array_declarator x___18 ;
  AST_generic tEmPcast___18 ;
  asm_stmt x___19 ;
  AST_generic tEmPcast___19 ;
  compound_stmt x___20 ;
  AST_generic tEmPcast___20 ;
  if_stmt x___21 ;
  AST_generic tEmPcast___21 ;
  labeled_stmt x___22 ;
  AST_generic tEmPcast___22 ;
  expression_stmt x___23 ;
  AST_generic tEmPcast___23 ;
  conditional_stmt x___24 ;
  AST_generic tEmPcast___24 ;
  switch_stmt x___25 ;
  AST_generic tEmPcast___25 ;
  for_stmt x___26 ;
  AST_generic tEmPcast___26 ;
  return_stmt x___27 ;
  AST_generic tEmPcast___27 ;
  goto_stmt x___28 ;
  AST_generic tEmPcast___28 ;
  computed_goto_stmt x___29 ;
  AST_generic tEmPcast___29 ;
  unary x___30 ;
  AST_generic tEmPcast___30 ;
  binary x___31 ;
  AST_generic tEmPcast___31 ;
  comma x___32 ;
  AST_generic tEmPcast___32 ;
  sizeof_type x___33 ;
  AST_generic tEmPcast___33 ;
  alignof_type x___34 ;
  AST_generic tEmPcast___34 ;
  label_address x___35 ;
  AST_generic tEmPcast___35 ;
  cast x___36 ;
  AST_generic tEmPcast___36 ;
  cast_list x___37 ;
  AST_generic tEmPcast___37 ;
  conditional x___38 ;
  AST_generic tEmPcast___38 ;
  compound_expr x___39 ;
  AST_generic tEmPcast___39 ;
  function_call x___40 ;
  AST_generic tEmPcast___40 ;
  field_ref x___41 ;
  AST_generic tEmPcast___41 ;
  increment x___42 ;
  AST_generic tEmPcast___42 ;
  comparison x___43 ;
  AST_generic tEmPcast___43 ;
  assignment x___44 ;
  AST_generic tEmPcast___44 ;
  init_list x___45 ;
  AST_generic tEmPcast___45 ;
  init_specific x___46 ;
  AST_generic tEmPcast___46 ;
  designate_index x___47 ;
  AST_generic tEmPcast___47 ;
  string x___48 ;
  AST_generic tEmPcast___48 ;
  case_label x___49 ;
  AST_generic tEmPcast___49 ;
  asm_operand x___50 ;
  AST_generic tEmPcast___50 ;
  nesc_decl x___51 ;
  AST_generic tEmPcast___51 ;
  interface x___52 ;
  AST_generic tEmPcast___52 ;
  component x___53 ;
  AST_generic tEmPcast___53 ;
  configuration x___54 ;
  AST_generic tEmPcast___54 ;
  module x___55 ;
  AST_generic tEmPcast___55 ;
  rp_interface x___56 ;
  AST_generic tEmPcast___56 ;
  interface_ref x___57 ;
  AST_generic tEmPcast___57 ;
  component_ref x___58 ;
  AST_generic tEmPcast___58 ;
  connection x___59 ;
  AST_generic tEmPcast___59 ;
  endpoint x___60 ;
  AST_generic tEmPcast___60 ;
  parameterised_identifier x___61 ;
  AST_generic tEmPcast___61 ;
  generic_declarator x___62 ;
  AST_generic tEmPcast___62 ;
  generic_call x___63 ;
  AST_generic tEmPcast___63 ;
  interface_ref_declarator x___64 ;
  AST_generic tEmPcast___64 ;
  interface_deref x___65 ;
  AST_generic tEmPcast___65 ;
  component_deref x___66 ;
  AST_generic tEmPcast___66 ;
  atomic_stmt x___67 ;
  AST_generic tEmPcast___67 ;
  nesc_attribute x___68 ;
  AST_generic tEmPcast___68 ;
  type_argument x___69 ;
  AST_generic tEmPcast___69 ;

  {
#line 97
  n = *nptr;
#line 99
  if (parent) {
    {
#line 100
    AST_set_parent(nptr, parent);
    }
  }
  {
#line 4
  if ((unsigned int )n->kind == 42U) {
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c"
    goto case_42;
  }
#line 5
  if ((unsigned int )n->kind == 64U) {
#line 5
    goto case_64;
  }
#line 5
  if ((unsigned int )n->kind == 43U) {
#line 5
    goto case_64;
  }
#line 6
  if ((unsigned int )n->kind == 83U) {
#line 6
    goto case_83;
  }
#line 6
  if ((unsigned int )n->kind == 65U) {
#line 6
    goto case_83;
  }
#line 7
  if ((unsigned int )n->kind == 156U) {
#line 7
    goto case_156;
  }
#line 7
  if ((unsigned int )n->kind == 84U) {
#line 7
    goto case_156;
  }
#line 8
  if ((unsigned int )n->kind == 157U) {
#line 8
    goto case_157;
  }
#line 9
  if ((unsigned int )n->kind == 175U) {
#line 9
    goto case_175;
  }
#line 10
  if ((unsigned int )n->kind == 184U) {
#line 10
    goto case_184;
  }
#line 11
  if ((unsigned int )n->kind == 44U) {
#line 11
    goto case_44;
  }
#line 17
  if ((unsigned int )n->kind == 45U) {
#line 17
    goto case_45;
  }
#line 24
  if ((unsigned int )n->kind == 46U) {
#line 24
    goto case_46;
  }
#line 30
  if ((unsigned int )n->kind == 47U) {
#line 30
    goto case_47;
  }
#line 31
  if ((unsigned int )n->kind == 48U) {
#line 31
    goto case_48;
  }
#line 37
  if ((unsigned int )n->kind == 49U) {
#line 37
    goto case_49;
  }
#line 38
  if ((unsigned int )n->kind == 50U) {
#line 38
    goto case_50;
  }
#line 47
  if ((unsigned int )n->kind == 51U) {
#line 47
    goto case_51;
  }
#line 48
  if ((unsigned int )n->kind == 52U) {
#line 48
    goto case_52;
  }
#line 57
  if ((unsigned int )n->kind == 53U) {
#line 57
    goto case_53;
  }
#line 65
  if ((unsigned int )n->kind == 188U) {
#line 65
    goto case_188;
  }
#line 72
  if ((unsigned int )n->kind == 158U) {
#line 72
    goto case_158;
  }
#line 73
  if ((unsigned int )n->kind == 160U) {
#line 73
    goto case_160;
  }
#line 79
  if ((unsigned int )n->kind == 161U) {
#line 79
    goto case_161;
  }
#line 85
  if ((unsigned int )n->kind == 162U) {
#line 85
    goto case_162;
  }
#line 91
  if ((unsigned int )n->kind == 164U) {
#line 91
    goto case_164;
  }
#line 91
  if ((unsigned int )n->kind == 163U) {
#line 91
    goto case_164;
  }
#line 98
  if ((unsigned int )n->kind == 166U) {
#line 98
    goto case_166;
  }
#line 99
  if ((unsigned int )n->kind == 167U) {
#line 99
    goto case_167;
  }
#line 100
  if ((unsigned int )n->kind == 173U) {
#line 100
    goto case_173;
  }
#line 100
  if ((unsigned int )n->kind == 174U) {
#line 100
    goto case_173;
  }
#line 100
  if ((unsigned int )n->kind == 168U) {
#line 100
    goto case_173;
  }
#line 108
  if ((unsigned int )n->kind == 170U) {
#line 108
    goto case_170;
  }
#line 108
  if ((unsigned int )n->kind == 169U) {
#line 108
    goto case_170;
  }
#line 116
  if ((unsigned int )n->kind == 172U) {
#line 116
    goto case_172;
  }
#line 116
  if ((unsigned int )n->kind == 171U) {
#line 116
    goto case_172;
  }
#line 124
  if ((unsigned int )n->kind == 176U) {
#line 124
    goto case_176;
  }
#line 130
  if ((unsigned int )n->kind == 177U) {
#line 130
    goto case_177;
  }
#line 140
  if ((unsigned int )n->kind == 178U) {
#line 140
    goto case_178;
  }
#line 146
  if ((unsigned int )n->kind == 179U) {
#line 146
    goto case_179;
  }
#line 153
  if ((unsigned int )n->kind == 180U) {
#line 153
    goto case_180;
  }
#line 160
  if ((unsigned int )n->kind == 182U) {
#line 160
    goto case_182;
  }
#line 161
  if ((unsigned int )n->kind == 66U) {
#line 161
    goto case_66;
  }
#line 171
  if ((unsigned int )n->kind == 67U) {
#line 171
    goto case_67;
  }
#line 179
  if ((unsigned int )n->kind == 68U) {
#line 179
    goto case_68;
  }
#line 187
  if ((unsigned int )n->kind == 69U) {
#line 187
    goto case_69;
  }
#line 194
  if ((unsigned int )n->kind == 70U) {
#line 194
    goto case_70;
  }
#line 200
  if ((unsigned int )n->kind == 73U) {
#line 200
    goto case_73;
  }
#line 200
  if ((unsigned int )n->kind == 74U) {
#line 200
    goto case_73;
  }
#line 200
  if ((unsigned int )n->kind == 71U) {
#line 200
    goto case_73;
  }
#line 207
  if ((unsigned int )n->kind == 72U) {
#line 207
    goto case_72;
  }
#line 214
  if ((unsigned int )n->kind == 75U) {
#line 214
    goto case_75;
  }
#line 223
  if ((unsigned int )n->kind == 76U) {
#line 223
    goto case_76;
  }
#line 224
  if ((unsigned int )n->kind == 77U) {
#line 224
    goto case_77;
  }
#line 225
  if ((unsigned int )n->kind == 78U) {
#line 225
    goto case_78;
  }
#line 231
  if ((unsigned int )n->kind == 79U) {
#line 231
    goto case_79;
  }
#line 237
  if ((unsigned int )n->kind == 80U) {
#line 237
    goto case_80;
  }
#line 243
  if ((unsigned int )n->kind == 81U) {
#line 243
    goto case_81;
  }
#line 244
  if ((unsigned int )n->kind == 95U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 96U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 97U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 98U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 99U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 100U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 101U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 102U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 103U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 104U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 105U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 106U) {
#line 244
    goto case_95;
  }
#line 244
  if ((unsigned int )n->kind == 85U) {
#line 244
    goto case_95;
  }
#line 250
  if ((unsigned int )n->kind == 127U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 128U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 129U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 130U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 131U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 132U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 133U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 134U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 135U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 136U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 137U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 138U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 139U) {
#line 250
    goto case_127;
  }
#line 250
  if ((unsigned int )n->kind == 107U) {
#line 250
    goto case_127;
  }
#line 257
  if ((unsigned int )n->kind == 140U) {
#line 257
    goto case_140;
  }
#line 263
  if ((unsigned int )n->kind == 141U) {
#line 263
    goto case_141;
  }
#line 269
  if ((unsigned int )n->kind == 142U) {
#line 269
    goto case_142;
  }
#line 275
  if ((unsigned int )n->kind == 143U) {
#line 275
    goto case_143;
  }
#line 281
  if ((unsigned int )n->kind == 86U) {
#line 281
    goto case_86;
  }
#line 288
  if ((unsigned int )n->kind == 144U) {
#line 288
    goto case_144;
  }
#line 295
  if ((unsigned int )n->kind == 145U) {
#line 295
    goto case_145;
  }
#line 303
  if ((unsigned int )n->kind == 146U) {
#line 303
    goto case_146;
  }
#line 304
  if ((unsigned int )n->kind == 147U) {
#line 304
    goto case_147;
  }
#line 310
  if ((unsigned int )n->kind == 148U) {
#line 310
    goto case_148;
  }
#line 317
  if ((unsigned int )n->kind == 87U) {
#line 317
    goto case_87;
  }
#line 323
  if ((unsigned int )n->kind == 89U) {
#line 323
    goto case_89;
  }
#line 323
  if ((unsigned int )n->kind == 90U) {
#line 323
    goto case_89;
  }
#line 323
  if ((unsigned int )n->kind == 91U) {
#line 323
    goto case_89;
  }
#line 323
  if ((unsigned int )n->kind == 92U) {
#line 323
    goto case_89;
  }
#line 323
  if ((unsigned int )n->kind == 88U) {
#line 323
    goto case_89;
  }
#line 329
  if ((unsigned int )n->kind == 109U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 110U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 111U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 112U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 113U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 114U) {
#line 329
    goto case_109;
  }
#line 329
  if ((unsigned int )n->kind == 108U) {
#line 329
    goto case_109;
  }
#line 336
  if ((unsigned int )n->kind == 116U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 117U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 118U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 119U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 120U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 121U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 122U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 123U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 124U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 125U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 126U) {
#line 336
    goto case_116;
  }
#line 336
  if ((unsigned int )n->kind == 115U) {
#line 336
    goto case_116;
  }
#line 343
  if ((unsigned int )n->kind == 149U) {
#line 343
    goto case_149;
  }
#line 349
  if ((unsigned int )n->kind == 150U) {
#line 349
    goto case_150;
  }
#line 356
  if ((unsigned int )n->kind == 189U) {
#line 356
    goto case_189;
  }
#line 357
  if ((unsigned int )n->kind == 190U) {
#line 357
    goto case_190;
  }
#line 358
  if ((unsigned int )n->kind == 191U) {
#line 358
    goto case_191;
  }
#line 365
  if ((unsigned int )n->kind == 151U) {
#line 365
    goto case_151;
  }
#line 366
  if ((unsigned int )n->kind == 152U) {
#line 366
    goto case_152;
  }
#line 367
  if ((unsigned int )n->kind == 153U) {
#line 367
    goto case_153;
  }
#line 373
  if ((unsigned int )n->kind == 185U) {
#line 373
    goto case_185;
  }
#line 374
  if ((unsigned int )n->kind == 186U) {
#line 374
    goto case_186;
  }
#line 381
  if ((unsigned int )n->kind == 187U) {
#line 381
    goto case_187;
  }
#line 382
  if ((unsigned int )n->kind == 192U) {
#line 382
    goto case_192;
  }
#line 383
  if ((unsigned int )n->kind == 193U) {
#line 383
    goto case_193;
  }
#line 391
  if ((unsigned int )n->kind == 54U) {
#line 391
    goto case_54;
  }
#line 398
  if ((unsigned int )n->kind == 55U) {
#line 398
    goto case_55;
  }
#line 406
  if ((unsigned int )n->kind == 56U) {
#line 406
    goto case_56;
  }
#line 416
  if ((unsigned int )n->kind == 194U) {
#line 416
    goto case_194;
  }
#line 417
  if ((unsigned int )n->kind == 195U) {
#line 417
    goto case_195;
  }
#line 423
  if ((unsigned int )n->kind == 196U) {
#line 423
    goto case_196;
  }
#line 429
  if ((unsigned int )n->kind == 197U) {
#line 429
    goto case_197;
  }
#line 430
  if ((unsigned int )n->kind == 57U) {
#line 430
    goto case_57;
  }
#line 436
  if ((unsigned int )n->kind == 58U) {
#line 436
    goto case_58;
  }
#line 446
  if ((unsigned int )n->kind == 59U) {
#line 446
    goto case_59;
  }
#line 454
  if ((unsigned int )n->kind == 61U) {
#line 454
    goto case_61;
  }
#line 454
  if ((unsigned int )n->kind == 62U) {
#line 454
    goto case_61;
  }
#line 454
  if ((unsigned int )n->kind == 60U) {
#line 454
    goto case_61;
  }
#line 461
  if ((unsigned int )n->kind == 198U) {
#line 461
    goto case_198;
  }
#line 467
  if ((unsigned int )n->kind == 199U) {
#line 467
    goto case_199;
  }
#line 474
  if ((unsigned int )n->kind == 183U) {
#line 474
    goto case_183;
  }
#line 481
  if ((unsigned int )n->kind == 154U) {
#line 481
    goto case_154;
  }
#line 488
  if ((unsigned int )n->kind == 181U) {
#line 488
    goto case_181;
  }
#line 495
  if ((unsigned int )n->kind == 93U) {
#line 495
    goto case_93;
  }
#line 501
  if ((unsigned int )n->kind == 94U) {
#line 501
    goto case_94;
  }
#line 507
  if ((unsigned int )n->kind == 159U) {
#line 507
    goto case_159;
  }
#line 508
  if ((unsigned int )n->kind == 82U) {
#line 508
    goto case_82;
  }
#line 514
  if ((unsigned int )n->kind == 165U) {
#line 514
    goto case_165;
  }
#line 521
  if ((unsigned int )n->kind == 63U) {
#line 521
    goto case_63;
  }
#line 522
  if ((unsigned int )n->kind == 155U) {
#line 522
    goto case_155;
  }
#line 114 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
  goto switch_default;
  case_42: /* CIL Label */ 
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c"
  goto switch_break;
  case_64: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 5
  goto switch_break;
  case_83: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 6
  goto switch_break;
  case_156: /* CIL Label */ 
  case_84: /* CIL Label */ 
#line 7
  goto switch_break;
  case_157: /* CIL Label */ 
#line 8
  goto switch_break;
  case_175: /* CIL Label */ 
#line 9
  goto switch_break;
  case_184: /* CIL Label */ 
#line 10
  goto switch_break;
  case_44: /* CIL Label */ 
#line 12
  tEmPcast = (AST_generic )n;
#line 12
  if (tEmPcast) {
#line 12
    if ((unsigned int )tEmPcast->kind >= 44U) {
#line 12
      if (! ((unsigned int )tEmPcast->kind <= 44U)) {
        {
#line 12
        __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 12U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 12
      __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 12U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 12
  x = (asm_decl )tEmPcast;
#line 14
  AST_set_parent_list((void *)(& x->asm_stmt), n);
  }
#line 15
  goto switch_break;
  case_45: /* CIL Label */ 
#line 18
  tEmPcast___0 = (AST_generic )n;
#line 18
  if (tEmPcast___0) {
#line 18
    if ((unsigned int )tEmPcast___0->kind >= 45U) {
#line 18
      if (! ((unsigned int )tEmPcast___0->kind <= 45U)) {
        {
#line 18
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 18U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 18
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 18U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 18
  x___0 = (data_decl )tEmPcast___0;
#line 20
  AST_set_parent_list((void *)(& x___0->modifiers), n);
#line 21
  AST_set_parent_list((void *)(& x___0->decls), n);
  }
#line 22
  goto switch_break;
  case_46: /* CIL Label */ 
#line 25
  tEmPcast___1 = (AST_generic )n;
#line 25
  if (tEmPcast___1) {
#line 25
    if ((unsigned int )tEmPcast___1->kind >= 46U) {
#line 25
      if (! ((unsigned int )tEmPcast___1->kind <= 46U)) {
        {
#line 25
        __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 25U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 25
      __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 25U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 25
  x___1 = (extension_decl )tEmPcast___1;
#line 27
  AST_set_parent_list((void *)(& x___1->decl), n);
  }
#line 28
  goto switch_break;
  case_47: /* CIL Label */ 
#line 30
  goto switch_break;
  case_48: /* CIL Label */ 
#line 32
  tEmPcast___2 = (AST_generic )n;
#line 32
  if (tEmPcast___2) {
#line 32
    if ((unsigned int )tEmPcast___2->kind >= 48U) {
#line 32
      if (! ((unsigned int )tEmPcast___2->kind <= 48U)) {
        {
#line 32
        __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 32U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 32
      __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 32U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 32
  x___2 = (enumerator )tEmPcast___2;
#line 34
  AST_set_parent_list((void *)(& x___2->arg1), n);
  }
#line 35
  goto switch_break;
  case_49: /* CIL Label */ 
#line 37
  goto switch_break;
  case_50: /* CIL Label */ 
#line 39
  tEmPcast___3 = (AST_generic )n;
#line 39
  if (tEmPcast___3) {
#line 39
    if ((unsigned int )tEmPcast___3->kind >= 50U) {
#line 39
      if (! ((unsigned int )tEmPcast___3->kind <= 50U)) {
        {
#line 39
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 39U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 39
      __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 39U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 39
  x___3 = (function_decl )tEmPcast___3;
#line 41
  AST_set_parent_list((void *)(& x___3->declarator), n);
#line 42
  AST_set_parent_list((void *)(& x___3->modifiers), n);
#line 43
  AST_set_parent_list((void *)(& x___3->attributes), n);
#line 44
  AST_set_parent_list((void *)(& x___3->stmt), n);
  }
#line 45
  goto switch_break;
  case_51: /* CIL Label */ 
#line 47
  goto switch_break;
  case_52: /* CIL Label */ 
#line 49
  tEmPcast___4 = (AST_generic )n;
#line 49
  if (tEmPcast___4) {
#line 49
    if ((unsigned int )tEmPcast___4->kind >= 52U) {
#line 49
      if (! ((unsigned int )tEmPcast___4->kind <= 52U)) {
        {
#line 49
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 49U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 49
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 49U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 49
  x___4 = (variable_decl )tEmPcast___4;
#line 51
  AST_set_parent_list((void *)(& x___4->declarator), n);
#line 52
  AST_set_parent_list((void *)(& x___4->attributes), n);
#line 53
  AST_set_parent_list((void *)(& x___4->arg1), n);
#line 54
  AST_set_parent_list((void *)(& x___4->asm_stmt), n);
  }
#line 55
  goto switch_break;
  case_53: /* CIL Label */ 
#line 58
  tEmPcast___5 = (AST_generic )n;
#line 58
  if (tEmPcast___5) {
#line 58
    if ((unsigned int )tEmPcast___5->kind >= 53U) {
#line 58
      if (! ((unsigned int )tEmPcast___5->kind <= 53U)) {
        {
#line 58
        __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 58U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 58
      __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 58U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 58
  x___5 = (field_decl )tEmPcast___5;
#line 60
  AST_set_parent_list((void *)(& x___5->declarator), n);
#line 61
  AST_set_parent_list((void *)(& x___5->attributes), n);
#line 62
  AST_set_parent_list((void *)(& x___5->arg1), n);
  }
#line 63
  goto switch_break;
  case_188: /* CIL Label */ 
#line 66
  tEmPcast___6 = (AST_generic )n;
#line 66
  if (tEmPcast___6) {
#line 66
    if ((unsigned int )tEmPcast___6->kind >= 188U) {
#line 66
      if (! ((unsigned int )tEmPcast___6->kind <= 188U)) {
        {
#line 66
        __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 66U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 66
      __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 66U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 66
  x___6 = (asttype )tEmPcast___6;
#line 68
  AST_set_parent_list((void *)(& x___6->declarator), n);
#line 69
  AST_set_parent_list((void *)(& x___6->qualifiers), n);
  }
#line 70
  goto switch_break;
  case_158: /* CIL Label */ 
#line 72
  goto switch_break;
  case_160: /* CIL Label */ 
#line 74
  tEmPcast___7 = (AST_generic )n;
#line 74
  if (tEmPcast___7) {
#line 74
    if ((unsigned int )tEmPcast___7->kind >= 160U) {
#line 74
      if (! ((unsigned int )tEmPcast___7->kind <= 160U)) {
        {
#line 74
        __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 74U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 74
      __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 74U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 74
  x___7 = (typeof_expr )tEmPcast___7;
#line 76
  AST_set_parent_list((void *)(& x___7->arg1), n);
  }
#line 77
  goto switch_break;
  case_161: /* CIL Label */ 
#line 80
  tEmPcast___8 = (AST_generic )n;
#line 80
  if (tEmPcast___8) {
#line 80
    if ((unsigned int )tEmPcast___8->kind >= 161U) {
#line 80
      if (! ((unsigned int )tEmPcast___8->kind <= 161U)) {
        {
#line 80
        __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 80U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 80
      __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 80U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 80
  x___8 = (typeof_type )tEmPcast___8;
#line 82
  AST_set_parent_list((void *)(& x___8->asttype), n);
  }
#line 83
  goto switch_break;
  case_162: /* CIL Label */ 
#line 86
  tEmPcast___9 = (AST_generic )n;
#line 86
  if (tEmPcast___9) {
#line 86
    if ((unsigned int )tEmPcast___9->kind >= 162U) {
#line 86
      if (! ((unsigned int )tEmPcast___9->kind <= 165U)) {
        {
#line 86
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 86U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 86
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 86U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 86
  x___9 = (attribute )tEmPcast___9;
#line 88
  AST_set_parent_list((void *)(& x___9->word1), n);
  }
#line 89
  goto switch_break;
  case_164: /* CIL Label */ 
  case_163: /* CIL Label */ 
#line 92
  tEmPcast___10 = (AST_generic )n;
#line 92
  if (tEmPcast___10) {
#line 92
    if ((unsigned int )tEmPcast___10->kind >= 163U) {
#line 92
      if (! ((unsigned int )tEmPcast___10->kind <= 164U)) {
        {
#line 92
        __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 92U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 92
      __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 92U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 92
  x___10 = (gcc_attribute )tEmPcast___10;
#line 94
  AST_set_parent_list((void *)(& x___10->word1), n);
#line 95
  AST_set_parent_list((void *)(& x___10->args), n);
  }
#line 96
  goto switch_break;
  case_166: /* CIL Label */ 
#line 98
  goto switch_break;
  case_167: /* CIL Label */ 
#line 99
  goto switch_break;
  case_173: /* CIL Label */ 
  case_174: /* CIL Label */ 
  case_168: /* CIL Label */ 
#line 101
  tEmPcast___11 = (AST_generic )n;
#line 101
  if (tEmPcast___11) {
#line 101
    if ((unsigned int )tEmPcast___11->kind >= 168U) {
#line 101
      if (! ((unsigned int )tEmPcast___11->kind <= 174U)) {
        {
#line 101
        __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 101U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 101
      __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 101U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 101
  x___11 = (tag_ref )tEmPcast___11;
#line 103
  AST_set_parent_list((void *)(& x___11->word1), n);
#line 104
  AST_set_parent_list((void *)(& x___11->attributes), n);
#line 105
  AST_set_parent_list((void *)(& x___11->fields), n);
  }
#line 106
  goto switch_break;
  case_170: /* CIL Label */ 
  case_169: /* CIL Label */ 
#line 109
  tEmPcast___12 = (AST_generic )n;
#line 109
  if (tEmPcast___12) {
#line 109
    if ((unsigned int )tEmPcast___12->kind >= 169U) {
#line 109
      if (! ((unsigned int )tEmPcast___12->kind <= 170U)) {
        {
#line 109
        __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 109U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 109
      __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 109U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 109
  x___12 = (struct_ref )tEmPcast___12;
#line 111
  AST_set_parent_list((void *)(& x___12->word1), n);
#line 112
  AST_set_parent_list((void *)(& x___12->attributes), n);
#line 113
  AST_set_parent_list((void *)(& x___12->fields), n);
  }
#line 114
  goto switch_break;
  case_172: /* CIL Label */ 
  case_171: /* CIL Label */ 
#line 117
  tEmPcast___13 = (AST_generic )n;
#line 117
  if (tEmPcast___13) {
#line 117
    if ((unsigned int )tEmPcast___13->kind >= 171U) {
#line 117
      if (! ((unsigned int )tEmPcast___13->kind <= 172U)) {
        {
#line 117
        __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 117U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 117
      __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 117U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 117
  x___13 = (union_ref )tEmPcast___13;
#line 119
  AST_set_parent_list((void *)(& x___13->word1), n);
#line 120
  AST_set_parent_list((void *)(& x___13->attributes), n);
#line 121
  AST_set_parent_list((void *)(& x___13->fields), n);
  }
#line 122
  goto switch_break;
  case_176: /* CIL Label */ 
#line 125
  tEmPcast___14 = (AST_generic )n;
#line 125
  if (tEmPcast___14) {
#line 125
    if ((unsigned int )tEmPcast___14->kind >= 176U) {
#line 125
      if (! ((unsigned int )tEmPcast___14->kind <= 181U)) {
        {
#line 125
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 125U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 125
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 125U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 125
  x___14 = (nested_declarator )tEmPcast___14;
#line 127
  AST_set_parent_list((void *)(& x___14->declarator), n);
  }
#line 128
  goto switch_break;
  case_177: /* CIL Label */ 
#line 131
  tEmPcast___15 = (AST_generic )n;
#line 131
  if (tEmPcast___15) {
#line 131
    if ((unsigned int )tEmPcast___15->kind >= 177U) {
#line 131
      if (! ((unsigned int )tEmPcast___15->kind <= 177U)) {
        {
#line 131
        __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 131U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 131
      __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 131U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 131
  x___15 = (function_declarator )tEmPcast___15;
#line 133
  AST_set_parent_list((void *)(& x___15->declarator), n);
#line 134
  AST_set_parent_list((void *)(& x___15->parms), n);
#line 135
  AST_set_parent_list((void *)(& x___15->gparms), n);
#line 136
  AST_set_parent_list((void *)(& x___15->qualifiers), n);
#line 137
  AST_set_parent_list((void *)(& x___15->return_type), n);
  }
#line 138
  goto switch_break;
  case_178: /* CIL Label */ 
#line 141
  tEmPcast___16 = (AST_generic )n;
#line 141
  if (tEmPcast___16) {
#line 141
    if ((unsigned int )tEmPcast___16->kind >= 178U) {
#line 141
      if (! ((unsigned int )tEmPcast___16->kind <= 178U)) {
        {
#line 141
        __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 141U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 141
      __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 141U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 141
  x___16 = (pointer_declarator )tEmPcast___16;
#line 143
  AST_set_parent_list((void *)(& x___16->declarator), n);
  }
#line 144
  goto switch_break;
  case_179: /* CIL Label */ 
#line 147
  tEmPcast___17 = (AST_generic )n;
#line 147
  if (tEmPcast___17) {
#line 147
    if ((unsigned int )tEmPcast___17->kind >= 179U) {
#line 147
      if (! ((unsigned int )tEmPcast___17->kind <= 179U)) {
        {
#line 147
        __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 147U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 147
      __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 147U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 147
  x___17 = (qualified_declarator )tEmPcast___17;
#line 149
  AST_set_parent_list((void *)(& x___17->declarator), n);
#line 150
  AST_set_parent_list((void *)(& x___17->modifiers), n);
  }
#line 151
  goto switch_break;
  case_180: /* CIL Label */ 
#line 154
  tEmPcast___18 = (AST_generic )n;
#line 154
  if (tEmPcast___18) {
#line 154
    if ((unsigned int )tEmPcast___18->kind >= 180U) {
#line 154
      if (! ((unsigned int )tEmPcast___18->kind <= 180U)) {
        {
#line 154
        __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 154U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 154
      __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 154U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 154
  x___18 = (array_declarator )tEmPcast___18;
#line 156
  AST_set_parent_list((void *)(& x___18->declarator), n);
#line 157
  AST_set_parent_list((void *)(& x___18->arg1), n);
  }
#line 158
  goto switch_break;
  case_182: /* CIL Label */ 
#line 160
  goto switch_break;
  case_66: /* CIL Label */ 
#line 162
  tEmPcast___19 = (AST_generic )n;
#line 162
  if (tEmPcast___19) {
#line 162
    if ((unsigned int )tEmPcast___19->kind >= 66U) {
#line 162
      if (! ((unsigned int )tEmPcast___19->kind <= 66U)) {
        {
#line 162
        __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 162U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 162
      __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 162U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 162
  x___19 = (asm_stmt )tEmPcast___19;
#line 164
  AST_set_parent_list((void *)(& x___19->arg1), n);
#line 165
  AST_set_parent_list((void *)(& x___19->asm_operands1), n);
#line 166
  AST_set_parent_list((void *)(& x___19->asm_operands2), n);
#line 167
  AST_set_parent_list((void *)(& x___19->asm_clobbers), n);
#line 168
  AST_set_parent_list((void *)(& x___19->qualifiers), n);
  }
#line 169
  goto switch_break;
  case_67: /* CIL Label */ 
#line 172
  tEmPcast___20 = (AST_generic )n;
#line 172
  if (tEmPcast___20) {
#line 172
    if ((unsigned int )tEmPcast___20->kind >= 67U) {
#line 172
      if (! ((unsigned int )tEmPcast___20->kind <= 67U)) {
        {
#line 172
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 172U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 172
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 172U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 172
  x___20 = (compound_stmt )tEmPcast___20;
#line 174
  AST_set_parent_list((void *)(& x___20->id_labels), n);
#line 175
  AST_set_parent_list((void *)(& x___20->decls), n);
#line 176
  AST_set_parent_list((void *)(& x___20->stmts), n);
  }
#line 177
  goto switch_break;
  case_68: /* CIL Label */ 
#line 180
  tEmPcast___21 = (AST_generic )n;
#line 180
  if (tEmPcast___21) {
#line 180
    if ((unsigned int )tEmPcast___21->kind >= 68U) {
#line 180
      if (! ((unsigned int )tEmPcast___21->kind <= 68U)) {
        {
#line 180
        __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 180U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 180
      __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 180U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 180
  x___21 = (if_stmt )tEmPcast___21;
#line 182
  AST_set_parent_list((void *)(& x___21->condition), n);
#line 183
  AST_set_parent_list((void *)(& x___21->stmt1), n);
#line 184
  AST_set_parent_list((void *)(& x___21->stmt2), n);
  }
#line 185
  goto switch_break;
  case_69: /* CIL Label */ 
#line 188
  tEmPcast___22 = (AST_generic )n;
#line 188
  if (tEmPcast___22) {
#line 188
    if ((unsigned int )tEmPcast___22->kind >= 69U) {
#line 188
      if (! ((unsigned int )tEmPcast___22->kind <= 69U)) {
        {
#line 188
        __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 188U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 188
      __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 188U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 188
  x___22 = (labeled_stmt )tEmPcast___22;
#line 190
  AST_set_parent_list((void *)(& x___22->label), n);
#line 191
  AST_set_parent_list((void *)(& x___22->stmt), n);
  }
#line 192
  goto switch_break;
  case_70: /* CIL Label */ 
#line 195
  tEmPcast___23 = (AST_generic )n;
#line 195
  if (tEmPcast___23) {
#line 195
    if ((unsigned int )tEmPcast___23->kind >= 70U) {
#line 195
      if (! ((unsigned int )tEmPcast___23->kind <= 70U)) {
        {
#line 195
        __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 195U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 195
      __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 195U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 195
  x___23 = (expression_stmt )tEmPcast___23;
#line 197
  AST_set_parent_list((void *)(& x___23->arg1), n);
  }
#line 198
  goto switch_break;
  case_73: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 201
  tEmPcast___24 = (AST_generic )n;
#line 201
  if (tEmPcast___24) {
#line 201
    if ((unsigned int )tEmPcast___24->kind >= 71U) {
#line 201
      if (! ((unsigned int )tEmPcast___24->kind <= 74U)) {
        {
#line 201
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 201U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 201
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 201U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 201
  x___24 = (conditional_stmt )tEmPcast___24;
#line 203
  AST_set_parent_list((void *)(& x___24->condition), n);
#line 204
  AST_set_parent_list((void *)(& x___24->stmt), n);
  }
#line 205
  goto switch_break;
  case_72: /* CIL Label */ 
#line 208
  tEmPcast___25 = (AST_generic )n;
#line 208
  if (tEmPcast___25) {
#line 208
    if ((unsigned int )tEmPcast___25->kind >= 72U) {
#line 208
      if (! ((unsigned int )tEmPcast___25->kind <= 72U)) {
        {
#line 208
        __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 208U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 208
      __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 208U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 208
  x___25 = (switch_stmt )tEmPcast___25;
#line 210
  AST_set_parent_list((void *)(& x___25->condition), n);
#line 211
  AST_set_parent_list((void *)(& x___25->stmt), n);
  }
#line 212
  goto switch_break;
  case_75: /* CIL Label */ 
#line 215
  tEmPcast___26 = (AST_generic )n;
#line 215
  if (tEmPcast___26) {
#line 215
    if ((unsigned int )tEmPcast___26->kind >= 75U) {
#line 215
      if (! ((unsigned int )tEmPcast___26->kind <= 75U)) {
        {
#line 215
        __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 215U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 215
      __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 215U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 215
  x___26 = (for_stmt )tEmPcast___26;
#line 217
  AST_set_parent_list((void *)(& x___26->arg1), n);
#line 218
  AST_set_parent_list((void *)(& x___26->arg2), n);
#line 219
  AST_set_parent_list((void *)(& x___26->arg3), n);
#line 220
  AST_set_parent_list((void *)(& x___26->stmt), n);
  }
#line 221
  goto switch_break;
  case_76: /* CIL Label */ 
#line 223
  goto switch_break;
  case_77: /* CIL Label */ 
#line 224
  goto switch_break;
  case_78: /* CIL Label */ 
#line 226
  tEmPcast___27 = (AST_generic )n;
#line 226
  if (tEmPcast___27) {
#line 226
    if ((unsigned int )tEmPcast___27->kind >= 78U) {
#line 226
      if (! ((unsigned int )tEmPcast___27->kind <= 78U)) {
        {
#line 226
        __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 226U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 226
      __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 226U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 226
  x___27 = (return_stmt )tEmPcast___27;
#line 228
  AST_set_parent_list((void *)(& x___27->arg1), n);
  }
#line 229
  goto switch_break;
  case_79: /* CIL Label */ 
#line 232
  tEmPcast___28 = (AST_generic )n;
#line 232
  if (tEmPcast___28) {
#line 232
    if ((unsigned int )tEmPcast___28->kind >= 79U) {
#line 232
      if (! ((unsigned int )tEmPcast___28->kind <= 79U)) {
        {
#line 232
        __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 232U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 232
      __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 232U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 232
  x___28 = (goto_stmt )tEmPcast___28;
#line 234
  AST_set_parent_list((void *)(& x___28->id_label), n);
  }
#line 235
  goto switch_break;
  case_80: /* CIL Label */ 
#line 238
  tEmPcast___29 = (AST_generic )n;
#line 238
  if (tEmPcast___29) {
#line 238
    if ((unsigned int )tEmPcast___29->kind >= 80U) {
#line 238
      if (! ((unsigned int )tEmPcast___29->kind <= 80U)) {
        {
#line 238
        __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 238U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 238
      __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 238U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 238
  x___29 = (computed_goto_stmt )tEmPcast___29;
#line 240
  AST_set_parent_list((void *)(& x___29->arg1), n);
  }
#line 241
  goto switch_break;
  case_81: /* CIL Label */ 
#line 243
  goto switch_break;
  case_95: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_85: /* CIL Label */ 
#line 245
  tEmPcast___30 = (AST_generic )n;
#line 245
  if (tEmPcast___30) {
#line 245
    if ((unsigned int )tEmPcast___30->kind >= 85U) {
#line 245
      if (! ((unsigned int )tEmPcast___30->kind <= 106U)) {
        {
#line 245
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 245U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 245
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 245U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 245
  x___30 = (unary )tEmPcast___30;
#line 247
  AST_set_parent_list((void *)(& x___30->arg1), n);
  }
#line 248
  goto switch_break;
  case_127: /* CIL Label */ 
  case_128: /* CIL Label */ 
  case_129: /* CIL Label */ 
  case_130: /* CIL Label */ 
  case_131: /* CIL Label */ 
  case_132: /* CIL Label */ 
  case_133: /* CIL Label */ 
  case_134: /* CIL Label */ 
  case_135: /* CIL Label */ 
  case_136: /* CIL Label */ 
  case_137: /* CIL Label */ 
  case_138: /* CIL Label */ 
  case_139: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 251
  tEmPcast___31 = (AST_generic )n;
#line 251
  if (tEmPcast___31) {
#line 251
    if ((unsigned int )tEmPcast___31->kind >= 107U) {
#line 251
      if (! ((unsigned int )tEmPcast___31->kind <= 139U)) {
        {
#line 251
        __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 251U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 251
      __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 251U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 251
  x___31 = (binary )tEmPcast___31;
#line 253
  AST_set_parent_list((void *)(& x___31->arg1), n);
#line 254
  AST_set_parent_list((void *)(& x___31->arg2), n);
  }
#line 255
  goto switch_break;
  case_140: /* CIL Label */ 
#line 258
  tEmPcast___32 = (AST_generic )n;
#line 258
  if (tEmPcast___32) {
#line 258
    if ((unsigned int )tEmPcast___32->kind >= 140U) {
#line 258
      if (! ((unsigned int )tEmPcast___32->kind <= 140U)) {
        {
#line 258
        __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 258U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 258
      __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 258U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 258
  x___32 = (comma )tEmPcast___32;
#line 260
  AST_set_parent_list((void *)(& x___32->arg1), n);
  }
#line 261
  goto switch_break;
  case_141: /* CIL Label */ 
#line 264
  tEmPcast___33 = (AST_generic )n;
#line 264
  if (tEmPcast___33) {
#line 264
    if ((unsigned int )tEmPcast___33->kind >= 141U) {
#line 264
      if (! ((unsigned int )tEmPcast___33->kind <= 141U)) {
        {
#line 264
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 264U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 264
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 264U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 264
  x___33 = (sizeof_type )tEmPcast___33;
#line 266
  AST_set_parent_list((void *)(& x___33->asttype), n);
  }
#line 267
  goto switch_break;
  case_142: /* CIL Label */ 
#line 270
  tEmPcast___34 = (AST_generic )n;
#line 270
  if (tEmPcast___34) {
#line 270
    if ((unsigned int )tEmPcast___34->kind >= 142U) {
#line 270
      if (! ((unsigned int )tEmPcast___34->kind <= 142U)) {
        {
#line 270
        __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 270U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 270
      __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 270U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 270
  x___34 = (alignof_type )tEmPcast___34;
#line 272
  AST_set_parent_list((void *)(& x___34->asttype), n);
  }
#line 273
  goto switch_break;
  case_143: /* CIL Label */ 
#line 276
  tEmPcast___35 = (AST_generic )n;
#line 276
  if (tEmPcast___35) {
#line 276
    if ((unsigned int )tEmPcast___35->kind >= 143U) {
#line 276
      if (! ((unsigned int )tEmPcast___35->kind <= 143U)) {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 276U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 276
      __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 276U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 276
  x___35 = (label_address )tEmPcast___35;
#line 278
  AST_set_parent_list((void *)(& x___35->id_label), n);
  }
#line 279
  goto switch_break;
  case_86: /* CIL Label */ 
#line 282
  tEmPcast___36 = (AST_generic )n;
#line 282
  if (tEmPcast___36) {
#line 282
    if ((unsigned int )tEmPcast___36->kind >= 86U) {
#line 282
      if (! ((unsigned int )tEmPcast___36->kind <= 86U)) {
        {
#line 282
        __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 282U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 282
      __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 282U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 282
  x___36 = (cast )tEmPcast___36;
#line 284
  AST_set_parent_list((void *)(& x___36->arg1), n);
#line 285
  AST_set_parent_list((void *)(& x___36->asttype), n);
  }
#line 286
  goto switch_break;
  case_144: /* CIL Label */ 
#line 289
  tEmPcast___37 = (AST_generic )n;
#line 289
  if (tEmPcast___37) {
#line 289
    if ((unsigned int )tEmPcast___37->kind >= 144U) {
#line 289
      if (! ((unsigned int )tEmPcast___37->kind <= 144U)) {
        {
#line 289
        __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 289U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 289
      __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 289U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 289
  x___37 = (cast_list )tEmPcast___37;
#line 291
  AST_set_parent_list((void *)(& x___37->asttype), n);
#line 292
  AST_set_parent_list((void *)(& x___37->init_expr), n);
  }
#line 293
  goto switch_break;
  case_145: /* CIL Label */ 
#line 296
  tEmPcast___38 = (AST_generic )n;
#line 296
  if (tEmPcast___38) {
#line 296
    if ((unsigned int )tEmPcast___38->kind >= 145U) {
#line 296
      if (! ((unsigned int )tEmPcast___38->kind <= 145U)) {
        {
#line 296
        __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 296U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 296
      __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 296U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 296
  x___38 = (conditional )tEmPcast___38;
#line 298
  AST_set_parent_list((void *)(& x___38->condition), n);
#line 299
  AST_set_parent_list((void *)(& x___38->arg1), n);
#line 300
  AST_set_parent_list((void *)(& x___38->arg2), n);
  }
#line 301
  goto switch_break;
  case_146: /* CIL Label */ 
#line 303
  goto switch_break;
  case_147: /* CIL Label */ 
#line 305
  tEmPcast___39 = (AST_generic )n;
#line 305
  if (tEmPcast___39) {
#line 305
    if ((unsigned int )tEmPcast___39->kind >= 147U) {
#line 305
      if (! ((unsigned int )tEmPcast___39->kind <= 147U)) {
        {
#line 305
        __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 305U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 305
      __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 305U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 305
  x___39 = (compound_expr )tEmPcast___39;
#line 307
  AST_set_parent_list((void *)(& x___39->stmt), n);
  }
#line 308
  goto switch_break;
  case_148: /* CIL Label */ 
#line 311
  tEmPcast___40 = (AST_generic )n;
#line 311
  if (tEmPcast___40) {
#line 311
    if ((unsigned int )tEmPcast___40->kind >= 148U) {
#line 311
      if (! ((unsigned int )tEmPcast___40->kind <= 148U)) {
        {
#line 311
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 311U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 311
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 311U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 311
  x___40 = (function_call )tEmPcast___40;
#line 313
  AST_set_parent_list((void *)(& x___40->arg1), n);
#line 314
  AST_set_parent_list((void *)(& x___40->args), n);
  }
#line 315
  goto switch_break;
  case_87: /* CIL Label */ 
#line 318
  tEmPcast___41 = (AST_generic )n;
#line 318
  if (tEmPcast___41) {
#line 318
    if ((unsigned int )tEmPcast___41->kind >= 87U) {
#line 318
      if (! ((unsigned int )tEmPcast___41->kind <= 87U)) {
        {
#line 318
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 318U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 318
      __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 318U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 318
  x___41 = (field_ref )tEmPcast___41;
#line 320
  AST_set_parent_list((void *)(& x___41->arg1), n);
  }
#line 321
  goto switch_break;
  case_89: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_88: /* CIL Label */ 
#line 324
  tEmPcast___42 = (AST_generic )n;
#line 324
  if (tEmPcast___42) {
#line 324
    if ((unsigned int )tEmPcast___42->kind >= 88U) {
#line 324
      if (! ((unsigned int )tEmPcast___42->kind <= 92U)) {
        {
#line 324
        __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 324U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 324
      __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 324U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 324
  x___42 = (increment )tEmPcast___42;
#line 326
  AST_set_parent_list((void *)(& x___42->arg1), n);
  }
#line 327
  goto switch_break;
  case_109: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 330
  tEmPcast___43 = (AST_generic )n;
#line 330
  if (tEmPcast___43) {
#line 330
    if ((unsigned int )tEmPcast___43->kind >= 108U) {
#line 330
      if (! ((unsigned int )tEmPcast___43->kind <= 114U)) {
        {
#line 330
        __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 330U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 330
      __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 330U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 330
  x___43 = (comparison )tEmPcast___43;
#line 332
  AST_set_parent_list((void *)(& x___43->arg1), n);
#line 333
  AST_set_parent_list((void *)(& x___43->arg2), n);
  }
#line 334
  goto switch_break;
  case_116: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 337
  tEmPcast___44 = (AST_generic )n;
#line 337
  if (tEmPcast___44) {
#line 337
    if ((unsigned int )tEmPcast___44->kind >= 115U) {
#line 337
      if (! ((unsigned int )tEmPcast___44->kind <= 126U)) {
        {
#line 337
        __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 337U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 337
      __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 337U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 337
  x___44 = (assignment )tEmPcast___44;
#line 339
  AST_set_parent_list((void *)(& x___44->arg1), n);
#line 340
  AST_set_parent_list((void *)(& x___44->arg2), n);
  }
#line 341
  goto switch_break;
  case_149: /* CIL Label */ 
#line 344
  tEmPcast___45 = (AST_generic )n;
#line 344
  if (tEmPcast___45) {
#line 344
    if ((unsigned int )tEmPcast___45->kind >= 149U) {
#line 344
      if (! ((unsigned int )tEmPcast___45->kind <= 149U)) {
        {
#line 344
        __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 344U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 344
      __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 344U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 344
  x___45 = (init_list )tEmPcast___45;
#line 346
  AST_set_parent_list((void *)(& x___45->args), n);
  }
#line 347
  goto switch_break;
  case_150: /* CIL Label */ 
#line 350
  tEmPcast___46 = (AST_generic )n;
#line 350
  if (tEmPcast___46) {
#line 350
    if ((unsigned int )tEmPcast___46->kind >= 150U) {
#line 350
      if (! ((unsigned int )tEmPcast___46->kind <= 150U)) {
        {
#line 350
        __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 350U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 350
      __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 350U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 350
  x___46 = (init_specific )tEmPcast___46;
#line 352
  AST_set_parent_list((void *)(& x___46->designator), n);
#line 353
  AST_set_parent_list((void *)(& x___46->init_expr), n);
  }
#line 354
  goto switch_break;
  case_189: /* CIL Label */ 
#line 356
  goto switch_break;
  case_190: /* CIL Label */ 
#line 357
  goto switch_break;
  case_191: /* CIL Label */ 
#line 359
  tEmPcast___47 = (AST_generic )n;
#line 359
  if (tEmPcast___47) {
#line 359
    if ((unsigned int )tEmPcast___47->kind >= 191U) {
#line 359
      if (! ((unsigned int )tEmPcast___47->kind <= 191U)) {
        {
#line 359
        __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 359U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 359
      __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 359U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 359
  x___47 = (designate_index )tEmPcast___47;
#line 361
  AST_set_parent_list((void *)(& x___47->arg1), n);
#line 362
  AST_set_parent_list((void *)(& x___47->arg2), n);
  }
#line 363
  goto switch_break;
  case_151: /* CIL Label */ 
#line 365
  goto switch_break;
  case_152: /* CIL Label */ 
#line 366
  goto switch_break;
  case_153: /* CIL Label */ 
#line 368
  tEmPcast___48 = (AST_generic )n;
#line 368
  if (tEmPcast___48) {
#line 368
    if ((unsigned int )tEmPcast___48->kind >= 153U) {
#line 368
      if (! ((unsigned int )tEmPcast___48->kind <= 153U)) {
        {
#line 368
        __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 368U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 368
      __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 368U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 368
  x___48 = (string )tEmPcast___48;
#line 370
  AST_set_parent_list((void *)(& x___48->strings), n);
  }
#line 371
  goto switch_break;
  case_185: /* CIL Label */ 
#line 373
  goto switch_break;
  case_186: /* CIL Label */ 
#line 375
  tEmPcast___49 = (AST_generic )n;
#line 375
  if (tEmPcast___49) {
#line 375
    if ((unsigned int )tEmPcast___49->kind >= 186U) {
#line 375
      if (! ((unsigned int )tEmPcast___49->kind <= 186U)) {
        {
#line 375
        __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 375U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 375
      __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 375U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 375
  x___49 = (case_label )tEmPcast___49;
#line 377
  AST_set_parent_list((void *)(& x___49->arg1), n);
#line 378
  AST_set_parent_list((void *)(& x___49->arg2), n);
  }
#line 379
  goto switch_break;
  case_187: /* CIL Label */ 
#line 381
  goto switch_break;
  case_192: /* CIL Label */ 
#line 382
  goto switch_break;
  case_193: /* CIL Label */ 
#line 384
  tEmPcast___50 = (AST_generic )n;
#line 384
  if (tEmPcast___50) {
#line 384
    if ((unsigned int )tEmPcast___50->kind >= 193U) {
#line 384
      if (! ((unsigned int )tEmPcast___50->kind <= 193U)) {
        {
#line 384
        __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 384U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 384
      __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 384U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 384
  x___50 = (asm_operand )tEmPcast___50;
#line 386
  AST_set_parent_list((void *)(& x___50->word1), n);
#line 387
  AST_set_parent_list((void *)(& x___50->string), n);
#line 388
  AST_set_parent_list((void *)(& x___50->arg1), n);
  }
#line 389
  goto switch_break;
  case_54: /* CIL Label */ 
#line 392
  tEmPcast___51 = (AST_generic )n;
#line 392
  if (tEmPcast___51) {
#line 392
    if ((unsigned int )tEmPcast___51->kind >= 54U) {
#line 392
      if (! ((unsigned int )tEmPcast___51->kind <= 56U)) {
        {
#line 392
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 392U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 392
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 392U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 392
  x___51 = (nesc_decl )tEmPcast___51;
#line 394
  AST_set_parent_list((void *)(& x___51->word1), n);
#line 395
  AST_set_parent_list((void *)(& x___51->attributes), n);
  }
#line 396
  goto switch_break;
  case_55: /* CIL Label */ 
#line 399
  tEmPcast___52 = (AST_generic )n;
#line 399
  if (tEmPcast___52) {
#line 399
    if ((unsigned int )tEmPcast___52->kind >= 55U) {
#line 399
      if (! ((unsigned int )tEmPcast___52->kind <= 55U)) {
        {
#line 399
        __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 399U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 399
      __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 399U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 399
  x___52 = (interface )tEmPcast___52;
#line 401
  AST_set_parent_list((void *)(& x___52->word1), n);
#line 402
  AST_set_parent_list((void *)(& x___52->attributes), n);
#line 403
  AST_set_parent_list((void *)(& x___52->decls), n);
  }
#line 404
  goto switch_break;
  case_56: /* CIL Label */ 
#line 407
  tEmPcast___53 = (AST_generic )n;
#line 407
  if (tEmPcast___53) {
#line 407
    if ((unsigned int )tEmPcast___53->kind >= 56U) {
#line 407
      if (! ((unsigned int )tEmPcast___53->kind <= 56U)) {
        {
#line 407
        __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 407U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 407
      __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 407U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 407
  x___53 = (component )tEmPcast___53;
#line 409
  AST_set_parent_list((void *)(& x___53->word1), n);
#line 410
  AST_set_parent_list((void *)(& x___53->attributes), n);
#line 411
  AST_set_parent_list((void *)(& x___53->parms), n);
#line 412
  AST_set_parent_list((void *)(& x___53->decls), n);
#line 413
  AST_set_parent_list((void *)(& x___53->implementation), n);
  }
#line 414
  goto switch_break;
  case_194: /* CIL Label */ 
#line 416
  goto switch_break;
  case_195: /* CIL Label */ 
#line 418
  tEmPcast___54 = (AST_generic )n;
#line 418
  if (tEmPcast___54) {
#line 418
    if ((unsigned int )tEmPcast___54->kind >= 195U) {
#line 418
      if (! ((unsigned int )tEmPcast___54->kind <= 195U)) {
        {
#line 418
        __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 418U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 418
      __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 418U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 418
  x___54 = (configuration )tEmPcast___54;
#line 420
  AST_set_parent_list((void *)(& x___54->decls), n);
  }
#line 421
  goto switch_break;
  case_196: /* CIL Label */ 
#line 424
  tEmPcast___55 = (AST_generic )n;
#line 424
  if (tEmPcast___55) {
#line 424
    if ((unsigned int )tEmPcast___55->kind >= 196U) {
#line 424
      if (! ((unsigned int )tEmPcast___55->kind <= 196U)) {
        {
#line 424
        __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 424U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 424
      __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 424U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 424
  x___55 = (module )tEmPcast___55;
#line 426
  AST_set_parent_list((void *)(& x___55->decls), n);
  }
#line 427
  goto switch_break;
  case_197: /* CIL Label */ 
#line 429
  goto switch_break;
  case_57: /* CIL Label */ 
#line 431
  tEmPcast___56 = (AST_generic )n;
#line 431
  if (tEmPcast___56) {
#line 431
    if ((unsigned int )tEmPcast___56->kind >= 57U) {
#line 431
      if (! ((unsigned int )tEmPcast___56->kind <= 57U)) {
        {
#line 431
        __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 431U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 431
      __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 431U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 431
  x___56 = (rp_interface )tEmPcast___56;
#line 433
  AST_set_parent_list((void *)(& x___56->decls), n);
  }
#line 434
  goto switch_break;
  case_58: /* CIL Label */ 
#line 437
  tEmPcast___57 = (AST_generic )n;
#line 437
  if (tEmPcast___57) {
#line 437
    if ((unsigned int )tEmPcast___57->kind >= 58U) {
#line 437
      if (! ((unsigned int )tEmPcast___57->kind <= 58U)) {
        {
#line 437
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 437U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 437
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 437U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 437
  x___57 = (interface_ref )tEmPcast___57;
#line 439
  AST_set_parent_list((void *)(& x___57->word1), n);
#line 440
  AST_set_parent_list((void *)(& x___57->args), n);
#line 441
  AST_set_parent_list((void *)(& x___57->word2), n);
#line 442
  AST_set_parent_list((void *)(& x___57->gparms), n);
#line 443
  AST_set_parent_list((void *)(& x___57->attributes), n);
  }
#line 444
  goto switch_break;
  case_59: /* CIL Label */ 
#line 447
  tEmPcast___58 = (AST_generic )n;
#line 447
  if (tEmPcast___58) {
#line 447
    if ((unsigned int )tEmPcast___58->kind >= 59U) {
#line 447
      if (! ((unsigned int )tEmPcast___58->kind <= 59U)) {
        {
#line 447
        __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 447U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 447
      __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 447U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 447
  x___58 = (component_ref )tEmPcast___58;
#line 449
  AST_set_parent_list((void *)(& x___58->word1), n);
#line 450
  AST_set_parent_list((void *)(& x___58->word2), n);
#line 451
  AST_set_parent_list((void *)(& x___58->args), n);
  }
#line 452
  goto switch_break;
  case_61: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
#line 455
  tEmPcast___59 = (AST_generic )n;
#line 455
  if (tEmPcast___59) {
#line 455
    if ((unsigned int )tEmPcast___59->kind >= 60U) {
#line 455
      if (! ((unsigned int )tEmPcast___59->kind <= 62U)) {
        {
#line 455
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 455U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 455
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 455U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 455
  x___59 = (connection )tEmPcast___59;
#line 457
  AST_set_parent_list((void *)(& x___59->ep1), n);
#line 458
  AST_set_parent_list((void *)(& x___59->ep2), n);
  }
#line 459
  goto switch_break;
  case_198: /* CIL Label */ 
#line 462
  tEmPcast___60 = (AST_generic )n;
#line 462
  if (tEmPcast___60) {
#line 462
    if ((unsigned int )tEmPcast___60->kind >= 198U) {
#line 462
      if (! ((unsigned int )tEmPcast___60->kind <= 198U)) {
        {
#line 462
        __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 462U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 462
      __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 462U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 462
  x___60 = (endpoint )tEmPcast___60;
#line 464
  AST_set_parent_list((void *)(& x___60->ids), n);
  }
#line 465
  goto switch_break;
  case_199: /* CIL Label */ 
#line 468
  tEmPcast___61 = (AST_generic )n;
#line 468
  if (tEmPcast___61) {
#line 468
    if ((unsigned int )tEmPcast___61->kind >= 199U) {
#line 468
      if (! ((unsigned int )tEmPcast___61->kind <= 199U)) {
        {
#line 468
        __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 468U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 468
      __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 468U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 468
  x___61 = (parameterised_identifier )tEmPcast___61;
#line 470
  AST_set_parent_list((void *)(& x___61->word1), n);
#line 471
  AST_set_parent_list((void *)(& x___61->args), n);
  }
#line 472
  goto switch_break;
  case_183: /* CIL Label */ 
#line 475
  tEmPcast___62 = (AST_generic )n;
#line 475
  if (tEmPcast___62) {
#line 475
    if ((unsigned int )tEmPcast___62->kind >= 183U) {
#line 475
      if (! ((unsigned int )tEmPcast___62->kind <= 183U)) {
        {
#line 475
        __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 475U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 475
      __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 475U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 475
  x___62 = (generic_declarator )tEmPcast___62;
#line 477
  AST_set_parent_list((void *)(& x___62->declarator), n);
#line 478
  AST_set_parent_list((void *)(& x___62->parms), n);
  }
#line 479
  goto switch_break;
  case_154: /* CIL Label */ 
#line 482
  tEmPcast___63 = (AST_generic )n;
#line 482
  if (tEmPcast___63) {
#line 482
    if ((unsigned int )tEmPcast___63->kind >= 154U) {
#line 482
      if (! ((unsigned int )tEmPcast___63->kind <= 154U)) {
        {
#line 482
        __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 482U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 482
      __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 482U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 482
  x___63 = (generic_call )tEmPcast___63;
#line 484
  AST_set_parent_list((void *)(& x___63->arg1), n);
#line 485
  AST_set_parent_list((void *)(& x___63->args), n);
  }
#line 486
  goto switch_break;
  case_181: /* CIL Label */ 
#line 489
  tEmPcast___64 = (AST_generic )n;
#line 489
  if (tEmPcast___64) {
#line 489
    if ((unsigned int )tEmPcast___64->kind >= 181U) {
#line 489
      if (! ((unsigned int )tEmPcast___64->kind <= 181U)) {
        {
#line 489
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 489U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 489
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 489U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 489
  x___64 = (interface_ref_declarator )tEmPcast___64;
#line 491
  AST_set_parent_list((void *)(& x___64->declarator), n);
#line 492
  AST_set_parent_list((void *)(& x___64->word1), n);
  }
#line 493
  goto switch_break;
  case_93: /* CIL Label */ 
#line 496
  tEmPcast___65 = (AST_generic )n;
#line 496
  if (tEmPcast___65) {
#line 496
    if ((unsigned int )tEmPcast___65->kind >= 93U) {
#line 496
      if (! ((unsigned int )tEmPcast___65->kind <= 93U)) {
        {
#line 496
        __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 496U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 496
      __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 496U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 496
  x___65 = (interface_deref )tEmPcast___65;
#line 498
  AST_set_parent_list((void *)(& x___65->arg1), n);
  }
#line 499
  goto switch_break;
  case_94: /* CIL Label */ 
#line 502
  tEmPcast___66 = (AST_generic )n;
#line 502
  if (tEmPcast___66) {
#line 502
    if ((unsigned int )tEmPcast___66->kind >= 94U) {
#line 502
      if (! ((unsigned int )tEmPcast___66->kind <= 94U)) {
        {
#line 502
        __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 502U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 502
      __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 502U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 502
  x___66 = (component_deref )tEmPcast___66;
#line 504
  AST_set_parent_list((void *)(& x___66->arg1), n);
  }
#line 505
  goto switch_break;
  case_159: /* CIL Label */ 
#line 507
  goto switch_break;
  case_82: /* CIL Label */ 
#line 509
  tEmPcast___67 = (AST_generic )n;
#line 509
  if (tEmPcast___67) {
#line 509
    if ((unsigned int )tEmPcast___67->kind >= 82U) {
#line 509
      if (! ((unsigned int )tEmPcast___67->kind <= 82U)) {
        {
#line 509
        __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 509U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 509
      __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 509U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 509
  x___67 = (atomic_stmt )tEmPcast___67;
#line 511
  AST_set_parent_list((void *)(& x___67->stmt), n);
  }
#line 512
  goto switch_break;
  case_165: /* CIL Label */ 
#line 515
  tEmPcast___68 = (AST_generic )n;
#line 515
  if (tEmPcast___68) {
#line 515
    if ((unsigned int )tEmPcast___68->kind >= 165U) {
#line 515
      if (! ((unsigned int )tEmPcast___68->kind <= 165U)) {
        {
#line 515
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 515U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 515
      __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 515U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 515
  x___68 = (nesc_attribute )tEmPcast___68;
#line 517
  AST_set_parent_list((void *)(& x___68->word1), n);
#line 518
  AST_set_parent_list((void *)(& x___68->arg1), n);
  }
#line 519
  goto switch_break;
  case_63: /* CIL Label */ 
#line 521
  goto switch_break;
  case_155: /* CIL Label */ 
#line 523
  tEmPcast___69 = (AST_generic )n;
#line 523
  if (tEmPcast___69) {
#line 523
    if ((unsigned int )tEmPcast___69->kind >= 155U) {
#line 523
      if (! ((unsigned int )tEmPcast___69->kind <= 155U)) {
        {
#line 523
        __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 523U,
                      "AST_set_parent1");
        }
      }
    } else {
      {
#line 523
      __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_parent.c", 523U,
                    "AST_set_parent1");
      }
    }
  }
  {
#line 523
  x___69 = (type_argument )tEmPcast___69;
#line 525
  AST_set_parent_list((void *)(& x___69->asttype), n);
  }
#line 526
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 115U, "AST_set_parent1");
  }
  switch_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void AST_set_parent_list(void *vnptr , node parent ) 
{ 
  node *nptr ;
  AST_generic *tEmPcast ;

  {
#line 121
  tEmPcast = (AST_generic *)vnptr;
#line 121
  if (tEmPcast) {
#line 121
    if (*tEmPcast) {
#line 121
      if ((unsigned int )(*tEmPcast)->kind >= 42U) {
#line 121
        if (! ((unsigned int )(*tEmPcast)->kind <= 199U)) {
          {
#line 121
          __assert_fail("((*tEmPcast)->kind >= kind_node && (*tEmPcast)->kind <= postkind_node)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 121U,
                        "AST_set_parent_list");
          }
        }
      } else {
        {
#line 121
        __assert_fail("((*tEmPcast)->kind >= kind_node && (*tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 121U, "AST_set_parent_list");
        }
      }
    }
  }
#line 121
  nptr = (node *)tEmPcast;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *nptr) {
#line 123
      goto while_break;
    }
    {
#line 125
    AST_set_parent1(nptr, parent);
#line 126
    nptr = & (*nptr)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
void AST_set_parents(node n ) 
{ 


  {
  {
#line 133
  AST_set_parent_list((void *)(& n), (node )((void *)0));
  }
#line 134
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
node AST_clone(region r , node n ) 
{ 
  int k ;
  node copy ;
  void *tmp ;

  {
  {
#line 138
  k = (int )((unsigned int )n->kind - 42U);
#line 142
  tmp = typed_ralloc(r, AST_sizeof[k], AST_typeof[k]);
#line 142
  copy = (node )tmp;
#line 143
  typed_rarraycopy((void *)copy, (void *)n, (size_t )1, AST_sizeof[k], AST_typeof[k]);
#line 144
  copy->parent = (node )((void *)0);
#line 145
  copy->parent_ptr = (node *)((void *)0);
  }
#line 147
  return (copy);
}
}
#line 150
static void AST_print_list(int indent , void *vn ) ;
#line 152 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void pindent(int by ) 
{ 
  int i ;

  {
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < by)) {
#line 156
      goto while_break;
    }
    {
#line 157
    putchar(' ');
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void AST_print1(int indent , node n ) 
{ 
  identifier x ;
  AST_generic tEmPcast ;
  lexical_cst x___0 ;
  AST_generic tEmPcast___0 ;
  string_cst x___1 ;
  AST_generic tEmPcast___1 ;
  id_label x___2 ;
  AST_generic tEmPcast___2 ;
  identifier_declarator x___3 ;
  AST_generic tEmPcast___3 ;
  word x___4 ;
  AST_generic tEmPcast___4 ;
  rid x___5 ;
  AST_generic tEmPcast___5 ;
  char *tmp ;
  asm_decl x___6 ;
  AST_generic tEmPcast___6 ;
  data_decl x___7 ;
  AST_generic tEmPcast___7 ;
  extension_decl x___8 ;
  AST_generic tEmPcast___8 ;
  enumerator x___9 ;
  AST_generic tEmPcast___9 ;
  function_decl x___10 ;
  AST_generic tEmPcast___10 ;
  variable_decl x___11 ;
  AST_generic tEmPcast___11 ;
  field_decl x___12 ;
  AST_generic tEmPcast___12 ;
  asttype x___13 ;
  AST_generic tEmPcast___13 ;
  typeof_expr x___14 ;
  AST_generic tEmPcast___14 ;
  typeof_type x___15 ;
  AST_generic tEmPcast___15 ;
  attribute x___16 ;
  AST_generic tEmPcast___16 ;
  gcc_attribute x___17 ;
  AST_generic tEmPcast___17 ;
  tag_ref x___18 ;
  AST_generic tEmPcast___18 ;
  struct_ref x___19 ;
  AST_generic tEmPcast___19 ;
  union_ref x___20 ;
  AST_generic tEmPcast___20 ;
  nested_declarator x___21 ;
  AST_generic tEmPcast___21 ;
  function_declarator x___22 ;
  AST_generic tEmPcast___22 ;
  pointer_declarator x___23 ;
  AST_generic tEmPcast___23 ;
  qualified_declarator x___24 ;
  AST_generic tEmPcast___24 ;
  array_declarator x___25 ;
  AST_generic tEmPcast___25 ;
  asm_stmt x___26 ;
  AST_generic tEmPcast___26 ;
  compound_stmt x___27 ;
  AST_generic tEmPcast___27 ;
  if_stmt x___28 ;
  AST_generic tEmPcast___28 ;
  labeled_stmt x___29 ;
  AST_generic tEmPcast___29 ;
  expression_stmt x___30 ;
  AST_generic tEmPcast___30 ;
  conditional_stmt x___31 ;
  AST_generic tEmPcast___31 ;
  switch_stmt x___32 ;
  AST_generic tEmPcast___32 ;
  for_stmt x___33 ;
  AST_generic tEmPcast___33 ;
  return_stmt x___34 ;
  AST_generic tEmPcast___34 ;
  goto_stmt x___35 ;
  AST_generic tEmPcast___35 ;
  computed_goto_stmt x___36 ;
  AST_generic tEmPcast___36 ;
  unary x___37 ;
  AST_generic tEmPcast___37 ;
  binary x___38 ;
  AST_generic tEmPcast___38 ;
  comma x___39 ;
  AST_generic tEmPcast___39 ;
  sizeof_type x___40 ;
  AST_generic tEmPcast___40 ;
  alignof_type x___41 ;
  AST_generic tEmPcast___41 ;
  label_address x___42 ;
  AST_generic tEmPcast___42 ;
  cast x___43 ;
  AST_generic tEmPcast___43 ;
  cast_list x___44 ;
  AST_generic tEmPcast___44 ;
  conditional x___45 ;
  AST_generic tEmPcast___45 ;
  compound_expr x___46 ;
  AST_generic tEmPcast___46 ;
  function_call x___47 ;
  AST_generic tEmPcast___47 ;
  field_ref x___48 ;
  AST_generic tEmPcast___48 ;
  increment x___49 ;
  AST_generic tEmPcast___49 ;
  comparison x___50 ;
  AST_generic tEmPcast___50 ;
  assignment x___51 ;
  AST_generic tEmPcast___51 ;
  init_list x___52 ;
  AST_generic tEmPcast___52 ;
  init_specific x___53 ;
  AST_generic tEmPcast___53 ;
  designate_index x___54 ;
  AST_generic tEmPcast___54 ;
  string x___55 ;
  AST_generic tEmPcast___55 ;
  case_label x___56 ;
  AST_generic tEmPcast___56 ;
  asm_operand x___57 ;
  AST_generic tEmPcast___57 ;
  nesc_decl x___58 ;
  AST_generic tEmPcast___58 ;
  interface x___59 ;
  AST_generic tEmPcast___59 ;
  component x___60 ;
  AST_generic tEmPcast___60 ;
  configuration x___61 ;
  AST_generic tEmPcast___61 ;
  module x___62 ;
  AST_generic tEmPcast___62 ;
  rp_interface x___63 ;
  AST_generic tEmPcast___63 ;
  interface_ref x___64 ;
  AST_generic tEmPcast___64 ;
  component_ref x___65 ;
  AST_generic tEmPcast___65 ;
  connection x___66 ;
  AST_generic tEmPcast___66 ;
  endpoint x___67 ;
  AST_generic tEmPcast___67 ;
  parameterised_identifier x___68 ;
  AST_generic tEmPcast___68 ;
  generic_declarator x___69 ;
  AST_generic tEmPcast___69 ;
  generic_call x___70 ;
  AST_generic tEmPcast___70 ;
  interface_ref_declarator x___71 ;
  AST_generic tEmPcast___71 ;
  interface_deref x___72 ;
  AST_generic tEmPcast___72 ;
  component_deref x___73 ;
  AST_generic tEmPcast___73 ;
  atomic_stmt x___74 ;
  AST_generic tEmPcast___74 ;
  nesc_attribute x___75 ;
  AST_generic tEmPcast___75 ;
  type_argument x___76 ;
  AST_generic tEmPcast___76 ;
  attribute_ref x___77 ;
  AST_generic tEmPcast___77 ;
  enum_ref x___78 ;
  AST_generic tEmPcast___78 ;
  while_stmt x___79 ;
  AST_generic tEmPcast___79 ;
  dowhile_stmt x___80 ;
  AST_generic tEmPcast___80 ;
  array_ref x___81 ;
  AST_generic tEmPcast___81 ;
  dereference x___82 ;
  AST_generic tEmPcast___82 ;
  extension_expr x___83 ;
  AST_generic tEmPcast___83 ;
  sizeof_expr x___84 ;
  AST_generic tEmPcast___84 ;
  alignof_expr x___85 ;
  AST_generic tEmPcast___85 ;
  realpart x___86 ;
  AST_generic tEmPcast___86 ;
  imagpart x___87 ;
  AST_generic tEmPcast___87 ;
  address_of x___88 ;
  AST_generic tEmPcast___88 ;
  unary_minus x___89 ;
  AST_generic tEmPcast___89 ;
  unary_plus x___90 ;
  AST_generic tEmPcast___90 ;
  conjugate x___91 ;
  AST_generic tEmPcast___91 ;
  bitnot x___92 ;
  AST_generic tEmPcast___92 ;
  not x___93 ;
  AST_generic tEmPcast___93 ;
  preincrement x___94 ;
  AST_generic tEmPcast___94 ;
  predecrement x___95 ;
  AST_generic tEmPcast___95 ;
  postincrement x___96 ;
  AST_generic tEmPcast___96 ;
  postdecrement x___97 ;
  AST_generic tEmPcast___97 ;
  plus x___98 ;
  AST_generic tEmPcast___98 ;
  minus x___99 ;
  AST_generic tEmPcast___99 ;
  times x___100 ;
  AST_generic tEmPcast___100 ;
  divide x___101 ;
  AST_generic tEmPcast___101 ;
  modulo x___102 ;
  AST_generic tEmPcast___102 ;
  lshift x___103 ;
  AST_generic tEmPcast___103 ;
  rshift x___104 ;
  AST_generic tEmPcast___104 ;
  leq x___105 ;
  AST_generic tEmPcast___105 ;
  geq x___106 ;
  AST_generic tEmPcast___106 ;
  lt x___107 ;
  AST_generic tEmPcast___107 ;
  gt x___108 ;
  AST_generic tEmPcast___108 ;
  eq x___109 ;
  AST_generic tEmPcast___109 ;
  ne x___110 ;
  AST_generic tEmPcast___110 ;
  bitand x___111 ;
  AST_generic tEmPcast___111 ;
  bitor x___112 ;
  AST_generic tEmPcast___112 ;
  bitxor x___113 ;
  AST_generic tEmPcast___113 ;
  andand x___114 ;
  AST_generic tEmPcast___114 ;
  oror x___115 ;
  AST_generic tEmPcast___115 ;
  assign x___116 ;
  AST_generic tEmPcast___116 ;
  plus_assign x___117 ;
  AST_generic tEmPcast___117 ;
  minus_assign x___118 ;
  AST_generic tEmPcast___118 ;
  times_assign x___119 ;
  AST_generic tEmPcast___119 ;
  divide_assign x___120 ;
  AST_generic tEmPcast___120 ;
  modulo_assign x___121 ;
  AST_generic tEmPcast___121 ;
  lshift_assign x___122 ;
  AST_generic tEmPcast___122 ;
  rshift_assign x___123 ;
  AST_generic tEmPcast___123 ;
  bitand_assign x___124 ;
  AST_generic tEmPcast___124 ;
  bitor_assign x___125 ;
  AST_generic tEmPcast___125 ;
  bitxor_assign x___126 ;
  AST_generic tEmPcast___126 ;
  rp_connection x___127 ;
  AST_generic tEmPcast___127 ;
  eq_connection x___128 ;
  AST_generic tEmPcast___128 ;
  nx_struct_ref x___129 ;
  AST_generic tEmPcast___129 ;
  nx_union_ref x___130 ;
  AST_generic tEmPcast___130 ;
  target_attribute x___131 ;
  AST_generic tEmPcast___131 ;

  {
  {
#line 162
  pindent(indent);
#line 163
  indent ++;
  }
  {
#line 168
  if ((unsigned int )n->kind == 146U) {
#line 168
    goto case_146;
  }
#line 174
  if ((unsigned int )n->kind == 151U) {
#line 174
    goto case_151;
  }
#line 180
  if ((unsigned int )n->kind == 152U) {
#line 180
    goto case_152;
  }
#line 186
  if ((unsigned int )n->kind == 185U) {
#line 186
    goto case_185;
  }
#line 192
  if ((unsigned int )n->kind == 182U) {
#line 192
    goto case_182;
  }
#line 198
  if ((unsigned int )n->kind == 192U) {
#line 198
    goto case_192;
  }
#line 204
  if ((unsigned int )n->kind == 166U) {
#line 204
    goto case_166;
  }
#line 210
  goto switch_default;
  case_146: /* CIL Label */ 
#line 169
  tEmPcast = (AST_generic )n;
#line 169
  if (tEmPcast) {
#line 169
    if ((unsigned int )tEmPcast->kind >= 146U) {
#line 169
      if (! ((unsigned int )tEmPcast->kind <= 146U)) {
        {
#line 169
        __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 169U, "AST_print1");
        }
      }
    } else {
      {
#line 169
      __assert_fail("((tEmPcast)->kind >= kind_identifier && (tEmPcast)->kind <= postkind_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 169U, "AST_print1");
      }
    }
  }
  {
#line 169
  x = (identifier )tEmPcast;
#line 171
  printf((char const   */* __restrict  */)"identifier %s\n", (x->ddecl)->name);
  }
#line 172
  return;
  case_151: /* CIL Label */ 
#line 175
  tEmPcast___0 = (AST_generic )n;
#line 175
  if (tEmPcast___0) {
#line 175
    if ((unsigned int )tEmPcast___0->kind >= 151U) {
#line 175
      if (! ((unsigned int )tEmPcast___0->kind <= 152U)) {
        {
#line 175
        __assert_fail("((tEmPcast)->kind >= kind_lexical_cst && (tEmPcast)->kind <= postkind_lexical_cst)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 175U, "AST_print1");
        }
      }
    } else {
      {
#line 175
      __assert_fail("((tEmPcast)->kind >= kind_lexical_cst && (tEmPcast)->kind <= postkind_lexical_cst)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 175U, "AST_print1");
      }
    }
  }
  {
#line 175
  x___0 = (lexical_cst )tEmPcast___0;
#line 177
  printf((char const   */* __restrict  */)"lexical_cst %s\n", x___0->cstring.data);
  }
#line 178
  return;
  case_152: /* CIL Label */ 
#line 181
  tEmPcast___1 = (AST_generic )n;
#line 181
  if (tEmPcast___1) {
#line 181
    if ((unsigned int )tEmPcast___1->kind >= 152U) {
#line 181
      if (! ((unsigned int )tEmPcast___1->kind <= 152U)) {
        {
#line 181
        __assert_fail("((tEmPcast)->kind >= kind_string_cst && (tEmPcast)->kind <= postkind_string_cst)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 181U, "AST_print1");
        }
      }
    } else {
      {
#line 181
      __assert_fail("((tEmPcast)->kind >= kind_string_cst && (tEmPcast)->kind <= postkind_string_cst)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 181U, "AST_print1");
      }
    }
  }
  {
#line 181
  x___1 = (string_cst )tEmPcast___1;
#line 183
  printf((char const   */* __restrict  */)"string_cst %s\n", x___1->cstring.data);
  }
#line 184
  return;
  case_185: /* CIL Label */ 
#line 187
  tEmPcast___2 = (AST_generic )n;
#line 187
  if (tEmPcast___2) {
#line 187
    if ((unsigned int )tEmPcast___2->kind >= 185U) {
#line 187
      if (! ((unsigned int )tEmPcast___2->kind <= 185U)) {
        {
#line 187
        __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 187U, "AST_print1");
        }
      }
    } else {
      {
#line 187
      __assert_fail("((tEmPcast)->kind >= kind_id_label && (tEmPcast)->kind <= postkind_id_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 187U, "AST_print1");
      }
    }
  }
  {
#line 187
  x___2 = (id_label )tEmPcast___2;
#line 189
  printf((char const   */* __restrict  */)"id_label %s\n", x___2->cstring.data);
  }
#line 190
  return;
  case_182: /* CIL Label */ 
#line 193
  tEmPcast___3 = (AST_generic )n;
#line 193
  if (tEmPcast___3) {
#line 193
    if ((unsigned int )tEmPcast___3->kind >= 182U) {
#line 193
      if (! ((unsigned int )tEmPcast___3->kind <= 182U)) {
        {
#line 193
        __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 193U, "AST_print1");
        }
      }
    } else {
      {
#line 193
      __assert_fail("((tEmPcast)->kind >= kind_identifier_declarator && (tEmPcast)->kind <= postkind_identifier_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 193U, "AST_print1");
      }
    }
  }
  {
#line 193
  x___3 = (identifier_declarator )tEmPcast___3;
#line 195
  printf((char const   */* __restrict  */)"identifier_declarator %s\n", x___3->cstring.data);
  }
#line 196
  return;
  case_192: /* CIL Label */ 
#line 199
  tEmPcast___4 = (AST_generic )n;
#line 199
  if (tEmPcast___4) {
#line 199
    if ((unsigned int )tEmPcast___4->kind >= 192U) {
#line 199
      if (! ((unsigned int )tEmPcast___4->kind <= 192U)) {
        {
#line 199
        __assert_fail("((tEmPcast)->kind >= kind_word && (tEmPcast)->kind <= postkind_word)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 199U, "AST_print1");
        }
      }
    } else {
      {
#line 199
      __assert_fail("((tEmPcast)->kind >= kind_word && (tEmPcast)->kind <= postkind_word)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 199U, "AST_print1");
      }
    }
  }
  {
#line 199
  x___4 = (word )tEmPcast___4;
#line 201
  printf((char const   */* __restrict  */)"word %s\n", x___4->cstring.data);
  }
#line 202
  return;
  case_166: /* CIL Label */ 
#line 205
  tEmPcast___5 = (AST_generic )n;
#line 205
  if (tEmPcast___5) {
#line 205
    if ((unsigned int )tEmPcast___5->kind >= 166U) {
#line 205
      if (! ((unsigned int )tEmPcast___5->kind <= 166U)) {
        {
#line 205
        __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 205U, "AST_print1");
        }
      }
    } else {
      {
#line 205
      __assert_fail("((tEmPcast)->kind >= kind_rid && (tEmPcast)->kind <= postkind_rid)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 205U, "AST_print1");
      }
    }
  }
  {
#line 205
  x___5 = (rid )tEmPcast___5;
#line 207
  tmp = rid_name(x___5);
#line 207
  printf((char const   */* __restrict  */)"rid %s\n", tmp);
  }
#line 208
  return;
  switch_default: /* CIL Label */ 
#line 211
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 4
  if ((unsigned int )n->kind == 42U) {
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c"
    goto case_42;
  }
#line 5
  if ((unsigned int )n->kind == 43U) {
#line 5
    goto case_43;
  }
#line 6
  if ((unsigned int )n->kind == 65U) {
#line 6
    goto case_65;
  }
#line 7
  if ((unsigned int )n->kind == 84U) {
#line 7
    goto case_84;
  }
#line 8
  if ((unsigned int )n->kind == 157U) {
#line 8
    goto case_157;
  }
#line 9
  if ((unsigned int )n->kind == 175U) {
#line 9
    goto case_175;
  }
#line 10
  if ((unsigned int )n->kind == 184U) {
#line 10
    goto case_184;
  }
#line 11
  if ((unsigned int )n->kind == 44U) {
#line 11
    goto case_44;
  }
#line 18
  if ((unsigned int )n->kind == 45U) {
#line 18
    goto case_45;
  }
#line 26
  if ((unsigned int )n->kind == 46U) {
#line 26
    goto case_46;
  }
#line 33
  if ((unsigned int )n->kind == 47U) {
#line 33
    goto case_47;
  }
#line 34
  if ((unsigned int )n->kind == 48U) {
#line 34
    goto case_48;
  }
#line 41
  if ((unsigned int )n->kind == 49U) {
#line 41
    goto case_49;
  }
#line 42
  if ((unsigned int )n->kind == 50U) {
#line 42
    goto case_50;
  }
#line 52
  if ((unsigned int )n->kind == 51U) {
#line 52
    goto case_51;
  }
#line 53
  if ((unsigned int )n->kind == 52U) {
#line 53
    goto case_52;
  }
#line 63
  if ((unsigned int )n->kind == 53U) {
#line 63
    goto case_53;
  }
#line 72
  if ((unsigned int )n->kind == 188U) {
#line 72
    goto case_188;
  }
#line 80
  if ((unsigned int )n->kind == 158U) {
#line 80
    goto case_158;
  }
#line 81
  if ((unsigned int )n->kind == 160U) {
#line 81
    goto case_160;
  }
#line 88
  if ((unsigned int )n->kind == 161U) {
#line 88
    goto case_161;
  }
#line 95
  if ((unsigned int )n->kind == 162U) {
#line 95
    goto case_162;
  }
#line 102
  if ((unsigned int )n->kind == 163U) {
#line 102
    goto case_163;
  }
#line 110
  if ((unsigned int )n->kind == 166U) {
#line 110
    goto case_166___0;
  }
#line 111
  if ((unsigned int )n->kind == 167U) {
#line 111
    goto case_167;
  }
#line 112
  if ((unsigned int )n->kind == 168U) {
#line 112
    goto case_168;
  }
#line 121
  if ((unsigned int )n->kind == 169U) {
#line 121
    goto case_169;
  }
#line 130
  if ((unsigned int )n->kind == 171U) {
#line 130
    goto case_171;
  }
#line 139
  if ((unsigned int )n->kind == 176U) {
#line 139
    goto case_176;
  }
#line 146
  if ((unsigned int )n->kind == 177U) {
#line 146
    goto case_177;
  }
#line 157
  if ((unsigned int )n->kind == 178U) {
#line 157
    goto case_178;
  }
#line 164
  if ((unsigned int )n->kind == 179U) {
#line 164
    goto case_179;
  }
#line 172
  if ((unsigned int )n->kind == 180U) {
#line 172
    goto case_180;
  }
#line 180
  if ((unsigned int )n->kind == 182U) {
#line 180
    goto case_182___0;
  }
#line 181
  if ((unsigned int )n->kind == 66U) {
#line 181
    goto case_66;
  }
#line 192
  if ((unsigned int )n->kind == 67U) {
#line 192
    goto case_67;
  }
#line 201
  if ((unsigned int )n->kind == 68U) {
#line 201
    goto case_68;
  }
#line 210
  if ((unsigned int )n->kind == 69U) {
#line 210
    goto case_69;
  }
#line 218
  if ((unsigned int )n->kind == 70U) {
#line 218
    goto case_70;
  }
#line 225
  if ((unsigned int )n->kind == 71U) {
#line 225
    goto case_71;
  }
#line 233
  if ((unsigned int )n->kind == 72U) {
#line 233
    goto case_72;
  }
#line 241
  if ((unsigned int )n->kind == 75U) {
#line 241
    goto case_75;
  }
#line 251
  if ((unsigned int )n->kind == 76U) {
#line 251
    goto case_76;
  }
#line 252
  if ((unsigned int )n->kind == 77U) {
#line 252
    goto case_77;
  }
#line 253
  if ((unsigned int )n->kind == 78U) {
#line 253
    goto case_78;
  }
#line 260
  if ((unsigned int )n->kind == 79U) {
#line 260
    goto case_79;
  }
#line 267
  if ((unsigned int )n->kind == 80U) {
#line 267
    goto case_80;
  }
#line 274
  if ((unsigned int )n->kind == 81U) {
#line 274
    goto case_81;
  }
#line 275
  if ((unsigned int )n->kind == 85U) {
#line 275
    goto case_85;
  }
#line 282
  if ((unsigned int )n->kind == 107U) {
#line 282
    goto case_107;
  }
#line 290
  if ((unsigned int )n->kind == 140U) {
#line 290
    goto case_140;
  }
#line 297
  if ((unsigned int )n->kind == 141U) {
#line 297
    goto case_141;
  }
#line 304
  if ((unsigned int )n->kind == 142U) {
#line 304
    goto case_142;
  }
#line 311
  if ((unsigned int )n->kind == 143U) {
#line 311
    goto case_143;
  }
#line 318
  if ((unsigned int )n->kind == 86U) {
#line 318
    goto case_86;
  }
#line 326
  if ((unsigned int )n->kind == 144U) {
#line 326
    goto case_144;
  }
#line 334
  if ((unsigned int )n->kind == 145U) {
#line 334
    goto case_145;
  }
#line 343
  if ((unsigned int )n->kind == 146U) {
#line 343
    goto case_146___0;
  }
#line 344
  if ((unsigned int )n->kind == 147U) {
#line 344
    goto case_147;
  }
#line 351
  if ((unsigned int )n->kind == 148U) {
#line 351
    goto case_148;
  }
#line 359
  if ((unsigned int )n->kind == 87U) {
#line 359
    goto case_87;
  }
#line 366
  if ((unsigned int )n->kind == 88U) {
#line 366
    goto case_88;
  }
#line 373
  if ((unsigned int )n->kind == 108U) {
#line 373
    goto case_108;
  }
#line 381
  if ((unsigned int )n->kind == 115U) {
#line 381
    goto case_115;
  }
#line 389
  if ((unsigned int )n->kind == 149U) {
#line 389
    goto case_149;
  }
#line 396
  if ((unsigned int )n->kind == 150U) {
#line 396
    goto case_150;
  }
#line 404
  if ((unsigned int )n->kind == 189U) {
#line 404
    goto case_189;
  }
#line 405
  if ((unsigned int )n->kind == 190U) {
#line 405
    goto case_190;
  }
#line 406
  if ((unsigned int )n->kind == 191U) {
#line 406
    goto case_191;
  }
#line 414
  if ((unsigned int )n->kind == 151U) {
#line 414
    goto case_151___0;
  }
#line 415
  if ((unsigned int )n->kind == 152U) {
#line 415
    goto case_152___0;
  }
#line 416
  if ((unsigned int )n->kind == 153U) {
#line 416
    goto case_153;
  }
#line 423
  if ((unsigned int )n->kind == 185U) {
#line 423
    goto case_185___0;
  }
#line 424
  if ((unsigned int )n->kind == 186U) {
#line 424
    goto case_186;
  }
#line 432
  if ((unsigned int )n->kind == 187U) {
#line 432
    goto case_187;
  }
#line 433
  if ((unsigned int )n->kind == 192U) {
#line 433
    goto case_192___0;
  }
#line 434
  if ((unsigned int )n->kind == 193U) {
#line 434
    goto case_193;
  }
#line 443
  if ((unsigned int )n->kind == 54U) {
#line 443
    goto case_54;
  }
#line 451
  if ((unsigned int )n->kind == 55U) {
#line 451
    goto case_55;
  }
#line 460
  if ((unsigned int )n->kind == 56U) {
#line 460
    goto case_56;
  }
#line 471
  if ((unsigned int )n->kind == 194U) {
#line 471
    goto case_194;
  }
#line 472
  if ((unsigned int )n->kind == 195U) {
#line 472
    goto case_195;
  }
#line 479
  if ((unsigned int )n->kind == 196U) {
#line 479
    goto case_196;
  }
#line 486
  if ((unsigned int )n->kind == 197U) {
#line 486
    goto case_197;
  }
#line 487
  if ((unsigned int )n->kind == 57U) {
#line 487
    goto case_57;
  }
#line 494
  if ((unsigned int )n->kind == 58U) {
#line 494
    goto case_58;
  }
#line 505
  if ((unsigned int )n->kind == 59U) {
#line 505
    goto case_59;
  }
#line 514
  if ((unsigned int )n->kind == 60U) {
#line 514
    goto case_60;
  }
#line 522
  if ((unsigned int )n->kind == 198U) {
#line 522
    goto case_198;
  }
#line 529
  if ((unsigned int )n->kind == 199U) {
#line 529
    goto case_199;
  }
#line 537
  if ((unsigned int )n->kind == 183U) {
#line 537
    goto case_183;
  }
#line 545
  if ((unsigned int )n->kind == 154U) {
#line 545
    goto case_154;
  }
#line 553
  if ((unsigned int )n->kind == 181U) {
#line 553
    goto case_181;
  }
#line 561
  if ((unsigned int )n->kind == 93U) {
#line 561
    goto case_93;
  }
#line 568
  if ((unsigned int )n->kind == 94U) {
#line 568
    goto case_94;
  }
#line 575
  if ((unsigned int )n->kind == 159U) {
#line 575
    goto case_159;
  }
#line 576
  if ((unsigned int )n->kind == 82U) {
#line 576
    goto case_82;
  }
#line 583
  if ((unsigned int )n->kind == 165U) {
#line 583
    goto case_165;
  }
#line 591
  if ((unsigned int )n->kind == 63U) {
#line 591
    goto case_63;
  }
#line 592
  if ((unsigned int )n->kind == 155U) {
#line 592
    goto case_155;
  }
#line 599
  if ((unsigned int )n->kind == 64U) {
#line 599
    goto case_64;
  }
#line 600
  if ((unsigned int )n->kind == 173U) {
#line 600
    goto case_173;
  }
#line 609
  if ((unsigned int )n->kind == 174U) {
#line 609
    goto case_174;
  }
#line 618
  if ((unsigned int )n->kind == 83U) {
#line 618
    goto case_83;
  }
#line 619
  if ((unsigned int )n->kind == 73U) {
#line 619
    goto case_73;
  }
#line 627
  if ((unsigned int )n->kind == 74U) {
#line 627
    goto case_74;
  }
#line 635
  if ((unsigned int )n->kind == 156U) {
#line 635
    goto case_156;
  }
#line 636
  if ((unsigned int )n->kind == 127U) {
#line 636
    goto case_127;
  }
#line 644
  if ((unsigned int )n->kind == 95U) {
#line 644
    goto case_95;
  }
#line 651
  if ((unsigned int )n->kind == 96U) {
#line 651
    goto case_96;
  }
#line 658
  if ((unsigned int )n->kind == 97U) {
#line 658
    goto case_97;
  }
#line 665
  if ((unsigned int )n->kind == 98U) {
#line 665
    goto case_98;
  }
#line 672
  if ((unsigned int )n->kind == 99U) {
#line 672
    goto case_99;
  }
#line 679
  if ((unsigned int )n->kind == 100U) {
#line 679
    goto case_100;
  }
#line 686
  if ((unsigned int )n->kind == 101U) {
#line 686
    goto case_101;
  }
#line 693
  if ((unsigned int )n->kind == 102U) {
#line 693
    goto case_102;
  }
#line 700
  if ((unsigned int )n->kind == 103U) {
#line 700
    goto case_103;
  }
#line 707
  if ((unsigned int )n->kind == 104U) {
#line 707
    goto case_104;
  }
#line 714
  if ((unsigned int )n->kind == 105U) {
#line 714
    goto case_105;
  }
#line 721
  if ((unsigned int )n->kind == 106U) {
#line 721
    goto case_106;
  }
#line 728
  if ((unsigned int )n->kind == 89U) {
#line 728
    goto case_89;
  }
#line 735
  if ((unsigned int )n->kind == 90U) {
#line 735
    goto case_90;
  }
#line 742
  if ((unsigned int )n->kind == 91U) {
#line 742
    goto case_91;
  }
#line 749
  if ((unsigned int )n->kind == 92U) {
#line 749
    goto case_92;
  }
#line 756
  if ((unsigned int )n->kind == 128U) {
#line 756
    goto case_128;
  }
#line 764
  if ((unsigned int )n->kind == 129U) {
#line 764
    goto case_129;
  }
#line 772
  if ((unsigned int )n->kind == 130U) {
#line 772
    goto case_130;
  }
#line 780
  if ((unsigned int )n->kind == 131U) {
#line 780
    goto case_131;
  }
#line 788
  if ((unsigned int )n->kind == 132U) {
#line 788
    goto case_132;
  }
#line 796
  if ((unsigned int )n->kind == 133U) {
#line 796
    goto case_133;
  }
#line 804
  if ((unsigned int )n->kind == 134U) {
#line 804
    goto case_134;
  }
#line 812
  if ((unsigned int )n->kind == 109U) {
#line 812
    goto case_109;
  }
#line 820
  if ((unsigned int )n->kind == 110U) {
#line 820
    goto case_110;
  }
#line 828
  if ((unsigned int )n->kind == 111U) {
#line 828
    goto case_111;
  }
#line 836
  if ((unsigned int )n->kind == 112U) {
#line 836
    goto case_112;
  }
#line 844
  if ((unsigned int )n->kind == 113U) {
#line 844
    goto case_113;
  }
#line 852
  if ((unsigned int )n->kind == 114U) {
#line 852
    goto case_114;
  }
#line 860
  if ((unsigned int )n->kind == 135U) {
#line 860
    goto case_135;
  }
#line 868
  if ((unsigned int )n->kind == 136U) {
#line 868
    goto case_136;
  }
#line 876
  if ((unsigned int )n->kind == 137U) {
#line 876
    goto case_137;
  }
#line 884
  if ((unsigned int )n->kind == 138U) {
#line 884
    goto case_138;
  }
#line 892
  if ((unsigned int )n->kind == 139U) {
#line 892
    goto case_139;
  }
#line 900
  if ((unsigned int )n->kind == 116U) {
#line 900
    goto case_116;
  }
#line 908
  if ((unsigned int )n->kind == 117U) {
#line 908
    goto case_117;
  }
#line 916
  if ((unsigned int )n->kind == 118U) {
#line 916
    goto case_118;
  }
#line 924
  if ((unsigned int )n->kind == 119U) {
#line 924
    goto case_119;
  }
#line 932
  if ((unsigned int )n->kind == 120U) {
#line 932
    goto case_120;
  }
#line 940
  if ((unsigned int )n->kind == 121U) {
#line 940
    goto case_121;
  }
#line 948
  if ((unsigned int )n->kind == 122U) {
#line 948
    goto case_122;
  }
#line 956
  if ((unsigned int )n->kind == 123U) {
#line 956
    goto case_123;
  }
#line 964
  if ((unsigned int )n->kind == 124U) {
#line 964
    goto case_124;
  }
#line 972
  if ((unsigned int )n->kind == 125U) {
#line 972
    goto case_125;
  }
#line 980
  if ((unsigned int )n->kind == 126U) {
#line 980
    goto case_126;
  }
#line 988
  if ((unsigned int )n->kind == 61U) {
#line 988
    goto case_61;
  }
#line 996
  if ((unsigned int )n->kind == 62U) {
#line 996
    goto case_62;
  }
#line 1004
  if ((unsigned int )n->kind == 170U) {
#line 1004
    goto case_170;
  }
#line 1013
  if ((unsigned int )n->kind == 172U) {
#line 1013
    goto case_172;
  }
#line 1022
  if ((unsigned int )n->kind == 164U) {
#line 1022
    goto case_164;
  }
#line 227 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
  goto switch_default___0;
  case_42: /* CIL Label */ 
  {
#line 4 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c"
  puts("node");
  }
#line 4
  goto switch_break___0;
  case_43: /* CIL Label */ 
  {
#line 5
  puts("declaration");
  }
#line 5
  goto switch_break___0;
  case_65: /* CIL Label */ 
  {
#line 6
  puts("statement");
  }
#line 6
  goto switch_break___0;
  case_84: /* CIL Label */ 
  {
#line 7
  puts("expression");
  }
#line 7
  goto switch_break___0;
  case_157: /* CIL Label */ 
  {
#line 8
  puts("type_element");
  }
#line 8
  goto switch_break___0;
  case_175: /* CIL Label */ 
  {
#line 9
  puts("declarator");
  }
#line 9
  goto switch_break___0;
  case_184: /* CIL Label */ 
  {
#line 10
  puts("label");
  }
#line 10
  goto switch_break___0;
  case_44: /* CIL Label */ 
#line 12
  tEmPcast___6 = (AST_generic )n;
#line 12
  if (tEmPcast___6) {
#line 12
    if ((unsigned int )tEmPcast___6->kind >= 44U) {
#line 12
      if (! ((unsigned int )tEmPcast___6->kind <= 44U)) {
        {
#line 12
        __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 12U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 12
      __assert_fail("((tEmPcast)->kind >= kind_asm_decl && (tEmPcast)->kind <= postkind_asm_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 12U,
                    "AST_print1");
      }
    }
  }
  {
#line 12
  x___6 = (asm_decl )tEmPcast___6;
#line 14
  puts("asm_decl");
#line 15
  pindent(indent);
#line 15
  puts("asm_stmt:");
#line 15
  AST_print_list(indent + 1, (void *)x___6->asm_stmt);
  }
#line 16
  goto switch_break___0;
  case_45: /* CIL Label */ 
#line 19
  tEmPcast___7 = (AST_generic )n;
#line 19
  if (tEmPcast___7) {
#line 19
    if ((unsigned int )tEmPcast___7->kind >= 45U) {
#line 19
      if (! ((unsigned int )tEmPcast___7->kind <= 45U)) {
        {
#line 19
        __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 19U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 19
      __assert_fail("((tEmPcast)->kind >= kind_data_decl && (tEmPcast)->kind <= postkind_data_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 19U,
                    "AST_print1");
      }
    }
  }
  {
#line 19
  x___7 = (data_decl )tEmPcast___7;
#line 21
  puts("data_decl");
#line 22
  pindent(indent);
#line 22
  puts("modifiers:");
#line 22
  AST_print_list(indent + 1, (void *)x___7->modifiers);
#line 23
  pindent(indent);
#line 23
  puts("decls:");
#line 23
  AST_print_list(indent + 1, (void *)x___7->decls);
  }
#line 24
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 27
  tEmPcast___8 = (AST_generic )n;
#line 27
  if (tEmPcast___8) {
#line 27
    if ((unsigned int )tEmPcast___8->kind >= 46U) {
#line 27
      if (! ((unsigned int )tEmPcast___8->kind <= 46U)) {
        {
#line 27
        __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 27U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 27
      __assert_fail("((tEmPcast)->kind >= kind_extension_decl && (tEmPcast)->kind <= postkind_extension_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 27U,
                    "AST_print1");
      }
    }
  }
  {
#line 27
  x___8 = (extension_decl )tEmPcast___8;
#line 29
  puts("extension_decl");
#line 30
  pindent(indent);
#line 30
  puts("decl:");
#line 30
  AST_print_list(indent + 1, (void *)x___8->decl);
  }
#line 31
  goto switch_break___0;
  case_47: /* CIL Label */ 
  {
#line 33
  puts("ellipsis_decl");
  }
#line 33
  goto switch_break___0;
  case_48: /* CIL Label */ 
#line 35
  tEmPcast___9 = (AST_generic )n;
#line 35
  if (tEmPcast___9) {
#line 35
    if ((unsigned int )tEmPcast___9->kind >= 48U) {
#line 35
      if (! ((unsigned int )tEmPcast___9->kind <= 48U)) {
        {
#line 35
        __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 35U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 35
      __assert_fail("((tEmPcast)->kind >= kind_enumerator && (tEmPcast)->kind <= postkind_enumerator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 35U,
                    "AST_print1");
      }
    }
  }
  {
#line 35
  x___9 = (enumerator )tEmPcast___9;
#line 37
  puts("enumerator");
#line 38
  pindent(indent);
#line 38
  puts("arg1:");
#line 38
  AST_print_list(indent + 1, (void *)x___9->arg1);
  }
#line 39
  goto switch_break___0;
  case_49: /* CIL Label */ 
  {
#line 41
  puts("oldidentifier_decl");
  }
#line 41
  goto switch_break___0;
  case_50: /* CIL Label */ 
#line 43
  tEmPcast___10 = (AST_generic )n;
#line 43
  if (tEmPcast___10) {
#line 43
    if ((unsigned int )tEmPcast___10->kind >= 50U) {
#line 43
      if (! ((unsigned int )tEmPcast___10->kind <= 50U)) {
        {
#line 43
        __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 43U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 43
      __assert_fail("((tEmPcast)->kind >= kind_function_decl && (tEmPcast)->kind <= postkind_function_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 43U,
                    "AST_print1");
      }
    }
  }
  {
#line 43
  x___10 = (function_decl )tEmPcast___10;
#line 45
  puts("function_decl");
#line 46
  pindent(indent);
#line 46
  puts("declarator:");
#line 46
  AST_print_list(indent + 1, (void *)x___10->declarator);
#line 47
  pindent(indent);
#line 47
  puts("modifiers:");
#line 47
  AST_print_list(indent + 1, (void *)x___10->modifiers);
#line 48
  pindent(indent);
#line 48
  puts("attributes:");
#line 48
  AST_print_list(indent + 1, (void *)x___10->attributes);
#line 49
  pindent(indent);
#line 49
  puts("stmt:");
#line 49
  AST_print_list(indent + 1, (void *)x___10->stmt);
  }
#line 50
  goto switch_break___0;
  case_51: /* CIL Label */ 
  {
#line 52
  puts("implicit_decl");
  }
#line 52
  goto switch_break___0;
  case_52: /* CIL Label */ 
#line 54
  tEmPcast___11 = (AST_generic )n;
#line 54
  if (tEmPcast___11) {
#line 54
    if ((unsigned int )tEmPcast___11->kind >= 52U) {
#line 54
      if (! ((unsigned int )tEmPcast___11->kind <= 52U)) {
        {
#line 54
        __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 54U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 54
      __assert_fail("((tEmPcast)->kind >= kind_variable_decl && (tEmPcast)->kind <= postkind_variable_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 54U,
                    "AST_print1");
      }
    }
  }
  {
#line 54
  x___11 = (variable_decl )tEmPcast___11;
#line 56
  puts("variable_decl");
#line 57
  pindent(indent);
#line 57
  puts("declarator:");
#line 57
  AST_print_list(indent + 1, (void *)x___11->declarator);
#line 58
  pindent(indent);
#line 58
  puts("attributes:");
#line 58
  AST_print_list(indent + 1, (void *)x___11->attributes);
#line 59
  pindent(indent);
#line 59
  puts("arg1:");
#line 59
  AST_print_list(indent + 1, (void *)x___11->arg1);
#line 60
  pindent(indent);
#line 60
  puts("asm_stmt:");
#line 60
  AST_print_list(indent + 1, (void *)x___11->asm_stmt);
  }
#line 61
  goto switch_break___0;
  case_53: /* CIL Label */ 
#line 64
  tEmPcast___12 = (AST_generic )n;
#line 64
  if (tEmPcast___12) {
#line 64
    if ((unsigned int )tEmPcast___12->kind >= 53U) {
#line 64
      if (! ((unsigned int )tEmPcast___12->kind <= 53U)) {
        {
#line 64
        __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 64U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 64
      __assert_fail("((tEmPcast)->kind >= kind_field_decl && (tEmPcast)->kind <= postkind_field_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 64U,
                    "AST_print1");
      }
    }
  }
  {
#line 64
  x___12 = (field_decl )tEmPcast___12;
#line 66
  puts("field_decl");
#line 67
  pindent(indent);
#line 67
  puts("declarator:");
#line 67
  AST_print_list(indent + 1, (void *)x___12->declarator);
#line 68
  pindent(indent);
#line 68
  puts("attributes:");
#line 68
  AST_print_list(indent + 1, (void *)x___12->attributes);
#line 69
  pindent(indent);
#line 69
  puts("arg1:");
#line 69
  AST_print_list(indent + 1, (void *)x___12->arg1);
  }
#line 70
  goto switch_break___0;
  case_188: /* CIL Label */ 
#line 73
  tEmPcast___13 = (AST_generic )n;
#line 73
  if (tEmPcast___13) {
#line 73
    if ((unsigned int )tEmPcast___13->kind >= 188U) {
#line 73
      if (! ((unsigned int )tEmPcast___13->kind <= 188U)) {
        {
#line 73
        __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 73U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 73
      __assert_fail("((tEmPcast)->kind >= kind_asttype && (tEmPcast)->kind <= postkind_asttype)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 73U,
                    "AST_print1");
      }
    }
  }
  {
#line 73
  x___13 = (asttype )tEmPcast___13;
#line 75
  puts("asttype");
#line 76
  pindent(indent);
#line 76
  puts("declarator:");
#line 76
  AST_print_list(indent + 1, (void *)x___13->declarator);
#line 77
  pindent(indent);
#line 77
  puts("qualifiers:");
#line 77
  AST_print_list(indent + 1, (void *)x___13->qualifiers);
  }
#line 78
  goto switch_break___0;
  case_158: /* CIL Label */ 
  {
#line 80
  puts("typename");
  }
#line 80
  goto switch_break___0;
  case_160: /* CIL Label */ 
#line 82
  tEmPcast___14 = (AST_generic )n;
#line 82
  if (tEmPcast___14) {
#line 82
    if ((unsigned int )tEmPcast___14->kind >= 160U) {
#line 82
      if (! ((unsigned int )tEmPcast___14->kind <= 160U)) {
        {
#line 82
        __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 82U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 82
      __assert_fail("((tEmPcast)->kind >= kind_typeof_expr && (tEmPcast)->kind <= postkind_typeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 82U,
                    "AST_print1");
      }
    }
  }
  {
#line 82
  x___14 = (typeof_expr )tEmPcast___14;
#line 84
  puts("typeof_expr");
#line 85
  pindent(indent);
#line 85
  puts("arg1:");
#line 85
  AST_print_list(indent + 1, (void *)x___14->arg1);
  }
#line 86
  goto switch_break___0;
  case_161: /* CIL Label */ 
#line 89
  tEmPcast___15 = (AST_generic )n;
#line 89
  if (tEmPcast___15) {
#line 89
    if ((unsigned int )tEmPcast___15->kind >= 161U) {
#line 89
      if (! ((unsigned int )tEmPcast___15->kind <= 161U)) {
        {
#line 89
        __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 89U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 89
      __assert_fail("((tEmPcast)->kind >= kind_typeof_type && (tEmPcast)->kind <= postkind_typeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 89U,
                    "AST_print1");
      }
    }
  }
  {
#line 89
  x___15 = (typeof_type )tEmPcast___15;
#line 91
  puts("typeof_type");
#line 92
  pindent(indent);
#line 92
  puts("asttype:");
#line 92
  AST_print_list(indent + 1, (void *)x___15->asttype);
  }
#line 93
  goto switch_break___0;
  case_162: /* CIL Label */ 
#line 96
  tEmPcast___16 = (AST_generic )n;
#line 96
  if (tEmPcast___16) {
#line 96
    if ((unsigned int )tEmPcast___16->kind >= 162U) {
#line 96
      if (! ((unsigned int )tEmPcast___16->kind <= 165U)) {
        {
#line 96
        __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 96U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 96
      __assert_fail("((tEmPcast)->kind >= kind_attribute && (tEmPcast)->kind <= postkind_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 96U,
                    "AST_print1");
      }
    }
  }
  {
#line 96
  x___16 = (attribute )tEmPcast___16;
#line 98
  puts("attribute");
#line 99
  pindent(indent);
#line 99
  puts("word1:");
#line 99
  AST_print_list(indent + 1, (void *)x___16->word1);
  }
#line 100
  goto switch_break___0;
  case_163: /* CIL Label */ 
#line 103
  tEmPcast___17 = (AST_generic )n;
#line 103
  if (tEmPcast___17) {
#line 103
    if ((unsigned int )tEmPcast___17->kind >= 163U) {
#line 103
      if (! ((unsigned int )tEmPcast___17->kind <= 164U)) {
        {
#line 103
        __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 103U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 103
      __assert_fail("((tEmPcast)->kind >= kind_gcc_attribute && (tEmPcast)->kind <= postkind_gcc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 103U,
                    "AST_print1");
      }
    }
  }
  {
#line 103
  x___17 = (gcc_attribute )tEmPcast___17;
#line 105
  puts("gcc_attribute");
#line 106
  pindent(indent);
#line 106
  puts("word1:");
#line 106
  AST_print_list(indent + 1, (void *)x___17->word1);
#line 107
  pindent(indent);
#line 107
  puts("args:");
#line 107
  AST_print_list(indent + 1, (void *)x___17->args);
  }
#line 108
  goto switch_break___0;
  case_166___0: /* CIL Label */ 
  {
#line 110
  puts("rid");
  }
#line 110
  goto switch_break___0;
  case_167: /* CIL Label */ 
  {
#line 111
  puts("qualifier");
  }
#line 111
  goto switch_break___0;
  case_168: /* CIL Label */ 
#line 113
  tEmPcast___18 = (AST_generic )n;
#line 113
  if (tEmPcast___18) {
#line 113
    if ((unsigned int )tEmPcast___18->kind >= 168U) {
#line 113
      if (! ((unsigned int )tEmPcast___18->kind <= 174U)) {
        {
#line 113
        __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 113U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 113
      __assert_fail("((tEmPcast)->kind >= kind_tag_ref && (tEmPcast)->kind <= postkind_tag_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 113U,
                    "AST_print1");
      }
    }
  }
  {
#line 113
  x___18 = (tag_ref )tEmPcast___18;
#line 115
  puts("tag_ref");
#line 116
  pindent(indent);
#line 116
  puts("word1:");
#line 116
  AST_print_list(indent + 1, (void *)x___18->word1);
#line 117
  pindent(indent);
#line 117
  puts("attributes:");
#line 117
  AST_print_list(indent + 1, (void *)x___18->attributes);
#line 118
  pindent(indent);
#line 118
  puts("fields:");
#line 118
  AST_print_list(indent + 1, (void *)x___18->fields);
  }
#line 119
  goto switch_break___0;
  case_169: /* CIL Label */ 
#line 122
  tEmPcast___19 = (AST_generic )n;
#line 122
  if (tEmPcast___19) {
#line 122
    if ((unsigned int )tEmPcast___19->kind >= 169U) {
#line 122
      if (! ((unsigned int )tEmPcast___19->kind <= 170U)) {
        {
#line 122
        __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 122U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 122
      __assert_fail("((tEmPcast)->kind >= kind_struct_ref && (tEmPcast)->kind <= postkind_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 122U,
                    "AST_print1");
      }
    }
  }
  {
#line 122
  x___19 = (struct_ref )tEmPcast___19;
#line 124
  puts("struct_ref");
#line 125
  pindent(indent);
#line 125
  puts("word1:");
#line 125
  AST_print_list(indent + 1, (void *)x___19->word1);
#line 126
  pindent(indent);
#line 126
  puts("attributes:");
#line 126
  AST_print_list(indent + 1, (void *)x___19->attributes);
#line 127
  pindent(indent);
#line 127
  puts("fields:");
#line 127
  AST_print_list(indent + 1, (void *)x___19->fields);
  }
#line 128
  goto switch_break___0;
  case_171: /* CIL Label */ 
#line 131
  tEmPcast___20 = (AST_generic )n;
#line 131
  if (tEmPcast___20) {
#line 131
    if ((unsigned int )tEmPcast___20->kind >= 171U) {
#line 131
      if (! ((unsigned int )tEmPcast___20->kind <= 172U)) {
        {
#line 131
        __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 131U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 131
      __assert_fail("((tEmPcast)->kind >= kind_union_ref && (tEmPcast)->kind <= postkind_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 131U,
                    "AST_print1");
      }
    }
  }
  {
#line 131
  x___20 = (union_ref )tEmPcast___20;
#line 133
  puts("union_ref");
#line 134
  pindent(indent);
#line 134
  puts("word1:");
#line 134
  AST_print_list(indent + 1, (void *)x___20->word1);
#line 135
  pindent(indent);
#line 135
  puts("attributes:");
#line 135
  AST_print_list(indent + 1, (void *)x___20->attributes);
#line 136
  pindent(indent);
#line 136
  puts("fields:");
#line 136
  AST_print_list(indent + 1, (void *)x___20->fields);
  }
#line 137
  goto switch_break___0;
  case_176: /* CIL Label */ 
#line 140
  tEmPcast___21 = (AST_generic )n;
#line 140
  if (tEmPcast___21) {
#line 140
    if ((unsigned int )tEmPcast___21->kind >= 176U) {
#line 140
      if (! ((unsigned int )tEmPcast___21->kind <= 181U)) {
        {
#line 140
        __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 140U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 140
      __assert_fail("((tEmPcast)->kind >= kind_nested_declarator && (tEmPcast)->kind <= postkind_nested_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 140U,
                    "AST_print1");
      }
    }
  }
  {
#line 140
  x___21 = (nested_declarator )tEmPcast___21;
#line 142
  puts("nested_declarator");
#line 143
  pindent(indent);
#line 143
  puts("declarator:");
#line 143
  AST_print_list(indent + 1, (void *)x___21->declarator);
  }
#line 144
  goto switch_break___0;
  case_177: /* CIL Label */ 
#line 147
  tEmPcast___22 = (AST_generic )n;
#line 147
  if (tEmPcast___22) {
#line 147
    if ((unsigned int )tEmPcast___22->kind >= 177U) {
#line 147
      if (! ((unsigned int )tEmPcast___22->kind <= 177U)) {
        {
#line 147
        __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 147U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 147
      __assert_fail("((tEmPcast)->kind >= kind_function_declarator && (tEmPcast)->kind <= postkind_function_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 147U,
                    "AST_print1");
      }
    }
  }
  {
#line 147
  x___22 = (function_declarator )tEmPcast___22;
#line 149
  puts("function_declarator");
#line 150
  pindent(indent);
#line 150
  puts("declarator:");
#line 150
  AST_print_list(indent + 1, (void *)x___22->declarator);
#line 151
  pindent(indent);
#line 151
  puts("parms:");
#line 151
  AST_print_list(indent + 1, (void *)x___22->parms);
#line 152
  pindent(indent);
#line 152
  puts("gparms:");
#line 152
  AST_print_list(indent + 1, (void *)x___22->gparms);
#line 153
  pindent(indent);
#line 153
  puts("qualifiers:");
#line 153
  AST_print_list(indent + 1, (void *)x___22->qualifiers);
#line 154
  pindent(indent);
#line 154
  puts("return_type:");
#line 154
  AST_print_list(indent + 1, (void *)x___22->return_type);
  }
#line 155
  goto switch_break___0;
  case_178: /* CIL Label */ 
#line 158
  tEmPcast___23 = (AST_generic )n;
#line 158
  if (tEmPcast___23) {
#line 158
    if ((unsigned int )tEmPcast___23->kind >= 178U) {
#line 158
      if (! ((unsigned int )tEmPcast___23->kind <= 178U)) {
        {
#line 158
        __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 158U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 158
      __assert_fail("((tEmPcast)->kind >= kind_pointer_declarator && (tEmPcast)->kind <= postkind_pointer_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 158U,
                    "AST_print1");
      }
    }
  }
  {
#line 158
  x___23 = (pointer_declarator )tEmPcast___23;
#line 160
  puts("pointer_declarator");
#line 161
  pindent(indent);
#line 161
  puts("declarator:");
#line 161
  AST_print_list(indent + 1, (void *)x___23->declarator);
  }
#line 162
  goto switch_break___0;
  case_179: /* CIL Label */ 
#line 165
  tEmPcast___24 = (AST_generic )n;
#line 165
  if (tEmPcast___24) {
#line 165
    if ((unsigned int )tEmPcast___24->kind >= 179U) {
#line 165
      if (! ((unsigned int )tEmPcast___24->kind <= 179U)) {
        {
#line 165
        __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 165U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 165
      __assert_fail("((tEmPcast)->kind >= kind_qualified_declarator && (tEmPcast)->kind <= postkind_qualified_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 165U,
                    "AST_print1");
      }
    }
  }
  {
#line 165
  x___24 = (qualified_declarator )tEmPcast___24;
#line 167
  puts("qualified_declarator");
#line 168
  pindent(indent);
#line 168
  puts("declarator:");
#line 168
  AST_print_list(indent + 1, (void *)x___24->declarator);
#line 169
  pindent(indent);
#line 169
  puts("modifiers:");
#line 169
  AST_print_list(indent + 1, (void *)x___24->modifiers);
  }
#line 170
  goto switch_break___0;
  case_180: /* CIL Label */ 
#line 173
  tEmPcast___25 = (AST_generic )n;
#line 173
  if (tEmPcast___25) {
#line 173
    if ((unsigned int )tEmPcast___25->kind >= 180U) {
#line 173
      if (! ((unsigned int )tEmPcast___25->kind <= 180U)) {
        {
#line 173
        __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 173U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 173
      __assert_fail("((tEmPcast)->kind >= kind_array_declarator && (tEmPcast)->kind <= postkind_array_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 173U,
                    "AST_print1");
      }
    }
  }
  {
#line 173
  x___25 = (array_declarator )tEmPcast___25;
#line 175
  puts("array_declarator");
#line 176
  pindent(indent);
#line 176
  puts("declarator:");
#line 176
  AST_print_list(indent + 1, (void *)x___25->declarator);
#line 177
  pindent(indent);
#line 177
  puts("arg1:");
#line 177
  AST_print_list(indent + 1, (void *)x___25->arg1);
  }
#line 178
  goto switch_break___0;
  case_182___0: /* CIL Label */ 
  {
#line 180
  puts("identifier_declarator");
  }
#line 180
  goto switch_break___0;
  case_66: /* CIL Label */ 
#line 182
  tEmPcast___26 = (AST_generic )n;
#line 182
  if (tEmPcast___26) {
#line 182
    if ((unsigned int )tEmPcast___26->kind >= 66U) {
#line 182
      if (! ((unsigned int )tEmPcast___26->kind <= 66U)) {
        {
#line 182
        __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 182U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 182
      __assert_fail("((tEmPcast)->kind >= kind_asm_stmt && (tEmPcast)->kind <= postkind_asm_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 182U,
                    "AST_print1");
      }
    }
  }
  {
#line 182
  x___26 = (asm_stmt )tEmPcast___26;
#line 184
  puts("asm_stmt");
#line 185
  pindent(indent);
#line 185
  puts("arg1:");
#line 185
  AST_print_list(indent + 1, (void *)x___26->arg1);
#line 186
  pindent(indent);
#line 186
  puts("asm_operands1:");
#line 186
  AST_print_list(indent + 1, (void *)x___26->asm_operands1);
#line 187
  pindent(indent);
#line 187
  puts("asm_operands2:");
#line 187
  AST_print_list(indent + 1, (void *)x___26->asm_operands2);
#line 188
  pindent(indent);
#line 188
  puts("asm_clobbers:");
#line 188
  AST_print_list(indent + 1, (void *)x___26->asm_clobbers);
#line 189
  pindent(indent);
#line 189
  puts("qualifiers:");
#line 189
  AST_print_list(indent + 1, (void *)x___26->qualifiers);
  }
#line 190
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 193
  tEmPcast___27 = (AST_generic )n;
#line 193
  if (tEmPcast___27) {
#line 193
    if ((unsigned int )tEmPcast___27->kind >= 67U) {
#line 193
      if (! ((unsigned int )tEmPcast___27->kind <= 67U)) {
        {
#line 193
        __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 193U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 193
      __assert_fail("((tEmPcast)->kind >= kind_compound_stmt && (tEmPcast)->kind <= postkind_compound_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 193U,
                    "AST_print1");
      }
    }
  }
  {
#line 193
  x___27 = (compound_stmt )tEmPcast___27;
#line 195
  puts("compound_stmt");
#line 196
  pindent(indent);
#line 196
  puts("id_labels:");
#line 196
  AST_print_list(indent + 1, (void *)x___27->id_labels);
#line 197
  pindent(indent);
#line 197
  puts("decls:");
#line 197
  AST_print_list(indent + 1, (void *)x___27->decls);
#line 198
  pindent(indent);
#line 198
  puts("stmts:");
#line 198
  AST_print_list(indent + 1, (void *)x___27->stmts);
  }
#line 199
  goto switch_break___0;
  case_68: /* CIL Label */ 
#line 202
  tEmPcast___28 = (AST_generic )n;
#line 202
  if (tEmPcast___28) {
#line 202
    if ((unsigned int )tEmPcast___28->kind >= 68U) {
#line 202
      if (! ((unsigned int )tEmPcast___28->kind <= 68U)) {
        {
#line 202
        __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 202U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 202
      __assert_fail("((tEmPcast)->kind >= kind_if_stmt && (tEmPcast)->kind <= postkind_if_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 202U,
                    "AST_print1");
      }
    }
  }
  {
#line 202
  x___28 = (if_stmt )tEmPcast___28;
#line 204
  puts("if_stmt");
#line 205
  pindent(indent);
#line 205
  puts("condition:");
#line 205
  AST_print_list(indent + 1, (void *)x___28->condition);
#line 206
  pindent(indent);
#line 206
  puts("stmt1:");
#line 206
  AST_print_list(indent + 1, (void *)x___28->stmt1);
#line 207
  pindent(indent);
#line 207
  puts("stmt2:");
#line 207
  AST_print_list(indent + 1, (void *)x___28->stmt2);
  }
#line 208
  goto switch_break___0;
  case_69: /* CIL Label */ 
#line 211
  tEmPcast___29 = (AST_generic )n;
#line 211
  if (tEmPcast___29) {
#line 211
    if ((unsigned int )tEmPcast___29->kind >= 69U) {
#line 211
      if (! ((unsigned int )tEmPcast___29->kind <= 69U)) {
        {
#line 211
        __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 211U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 211
      __assert_fail("((tEmPcast)->kind >= kind_labeled_stmt && (tEmPcast)->kind <= postkind_labeled_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 211U,
                    "AST_print1");
      }
    }
  }
  {
#line 211
  x___29 = (labeled_stmt )tEmPcast___29;
#line 213
  puts("labeled_stmt");
#line 214
  pindent(indent);
#line 214
  puts("label:");
#line 214
  AST_print_list(indent + 1, (void *)x___29->label);
#line 215
  pindent(indent);
#line 215
  puts("stmt:");
#line 215
  AST_print_list(indent + 1, (void *)x___29->stmt);
  }
#line 216
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 219
  tEmPcast___30 = (AST_generic )n;
#line 219
  if (tEmPcast___30) {
#line 219
    if ((unsigned int )tEmPcast___30->kind >= 70U) {
#line 219
      if (! ((unsigned int )tEmPcast___30->kind <= 70U)) {
        {
#line 219
        __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 219U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 219
      __assert_fail("((tEmPcast)->kind >= kind_expression_stmt && (tEmPcast)->kind <= postkind_expression_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 219U,
                    "AST_print1");
      }
    }
  }
  {
#line 219
  x___30 = (expression_stmt )tEmPcast___30;
#line 221
  puts("expression_stmt");
#line 222
  pindent(indent);
#line 222
  puts("arg1:");
#line 222
  AST_print_list(indent + 1, (void *)x___30->arg1);
  }
#line 223
  goto switch_break___0;
  case_71: /* CIL Label */ 
#line 226
  tEmPcast___31 = (AST_generic )n;
#line 226
  if (tEmPcast___31) {
#line 226
    if ((unsigned int )tEmPcast___31->kind >= 71U) {
#line 226
      if (! ((unsigned int )tEmPcast___31->kind <= 74U)) {
        {
#line 226
        __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 226U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 226
      __assert_fail("((tEmPcast)->kind >= kind_conditional_stmt && (tEmPcast)->kind <= postkind_conditional_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 226U,
                    "AST_print1");
      }
    }
  }
  {
#line 226
  x___31 = (conditional_stmt )tEmPcast___31;
#line 228
  puts("conditional_stmt");
#line 229
  pindent(indent);
#line 229
  puts("condition:");
#line 229
  AST_print_list(indent + 1, (void *)x___31->condition);
#line 230
  pindent(indent);
#line 230
  puts("stmt:");
#line 230
  AST_print_list(indent + 1, (void *)x___31->stmt);
  }
#line 231
  goto switch_break___0;
  case_72: /* CIL Label */ 
#line 234
  tEmPcast___32 = (AST_generic )n;
#line 234
  if (tEmPcast___32) {
#line 234
    if ((unsigned int )tEmPcast___32->kind >= 72U) {
#line 234
      if (! ((unsigned int )tEmPcast___32->kind <= 72U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 234U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_switch_stmt && (tEmPcast)->kind <= postkind_switch_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 234U,
                    "AST_print1");
      }
    }
  }
  {
#line 234
  x___32 = (switch_stmt )tEmPcast___32;
#line 236
  puts("switch_stmt");
#line 237
  pindent(indent);
#line 237
  puts("condition:");
#line 237
  AST_print_list(indent + 1, (void *)x___32->condition);
#line 238
  pindent(indent);
#line 238
  puts("stmt:");
#line 238
  AST_print_list(indent + 1, (void *)x___32->stmt);
  }
#line 239
  goto switch_break___0;
  case_75: /* CIL Label */ 
#line 242
  tEmPcast___33 = (AST_generic )n;
#line 242
  if (tEmPcast___33) {
#line 242
    if ((unsigned int )tEmPcast___33->kind >= 75U) {
#line 242
      if (! ((unsigned int )tEmPcast___33->kind <= 75U)) {
        {
#line 242
        __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 242U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 242
      __assert_fail("((tEmPcast)->kind >= kind_for_stmt && (tEmPcast)->kind <= postkind_for_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 242U,
                    "AST_print1");
      }
    }
  }
  {
#line 242
  x___33 = (for_stmt )tEmPcast___33;
#line 244
  puts("for_stmt");
#line 245
  pindent(indent);
#line 245
  puts("arg1:");
#line 245
  AST_print_list(indent + 1, (void *)x___33->arg1);
#line 246
  pindent(indent);
#line 246
  puts("arg2:");
#line 246
  AST_print_list(indent + 1, (void *)x___33->arg2);
#line 247
  pindent(indent);
#line 247
  puts("arg3:");
#line 247
  AST_print_list(indent + 1, (void *)x___33->arg3);
#line 248
  pindent(indent);
#line 248
  puts("stmt:");
#line 248
  AST_print_list(indent + 1, (void *)x___33->stmt);
  }
#line 249
  goto switch_break___0;
  case_76: /* CIL Label */ 
  {
#line 251
  puts("break_stmt");
  }
#line 251
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 252
  puts("continue_stmt");
  }
#line 252
  goto switch_break___0;
  case_78: /* CIL Label */ 
#line 254
  tEmPcast___34 = (AST_generic )n;
#line 254
  if (tEmPcast___34) {
#line 254
    if ((unsigned int )tEmPcast___34->kind >= 78U) {
#line 254
      if (! ((unsigned int )tEmPcast___34->kind <= 78U)) {
        {
#line 254
        __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 254U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 254
      __assert_fail("((tEmPcast)->kind >= kind_return_stmt && (tEmPcast)->kind <= postkind_return_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 254U,
                    "AST_print1");
      }
    }
  }
  {
#line 254
  x___34 = (return_stmt )tEmPcast___34;
#line 256
  puts("return_stmt");
#line 257
  pindent(indent);
#line 257
  puts("arg1:");
#line 257
  AST_print_list(indent + 1, (void *)x___34->arg1);
  }
#line 258
  goto switch_break___0;
  case_79: /* CIL Label */ 
#line 261
  tEmPcast___35 = (AST_generic )n;
#line 261
  if (tEmPcast___35) {
#line 261
    if ((unsigned int )tEmPcast___35->kind >= 79U) {
#line 261
      if (! ((unsigned int )tEmPcast___35->kind <= 79U)) {
        {
#line 261
        __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 261U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 261
      __assert_fail("((tEmPcast)->kind >= kind_goto_stmt && (tEmPcast)->kind <= postkind_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 261U,
                    "AST_print1");
      }
    }
  }
  {
#line 261
  x___35 = (goto_stmt )tEmPcast___35;
#line 263
  puts("goto_stmt");
#line 264
  pindent(indent);
#line 264
  puts("id_label:");
#line 264
  AST_print_list(indent + 1, (void *)x___35->id_label);
  }
#line 265
  goto switch_break___0;
  case_80: /* CIL Label */ 
#line 268
  tEmPcast___36 = (AST_generic )n;
#line 268
  if (tEmPcast___36) {
#line 268
    if ((unsigned int )tEmPcast___36->kind >= 80U) {
#line 268
      if (! ((unsigned int )tEmPcast___36->kind <= 80U)) {
        {
#line 268
        __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 268U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 268
      __assert_fail("((tEmPcast)->kind >= kind_computed_goto_stmt && (tEmPcast)->kind <= postkind_computed_goto_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 268U,
                    "AST_print1");
      }
    }
  }
  {
#line 268
  x___36 = (computed_goto_stmt )tEmPcast___36;
#line 270
  puts("computed_goto_stmt");
#line 271
  pindent(indent);
#line 271
  puts("arg1:");
#line 271
  AST_print_list(indent + 1, (void *)x___36->arg1);
  }
#line 272
  goto switch_break___0;
  case_81: /* CIL Label */ 
  {
#line 274
  puts("empty_stmt");
  }
#line 274
  goto switch_break___0;
  case_85: /* CIL Label */ 
#line 276
  tEmPcast___37 = (AST_generic )n;
#line 276
  if (tEmPcast___37) {
#line 276
    if ((unsigned int )tEmPcast___37->kind >= 85U) {
#line 276
      if (! ((unsigned int )tEmPcast___37->kind <= 106U)) {
        {
#line 276
        __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 276U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 276
      __assert_fail("((tEmPcast)->kind >= kind_unary && (tEmPcast)->kind <= postkind_unary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 276U,
                    "AST_print1");
      }
    }
  }
  {
#line 276
  x___37 = (unary )tEmPcast___37;
#line 278
  puts("unary");
#line 279
  pindent(indent);
#line 279
  puts("arg1:");
#line 279
  AST_print_list(indent + 1, (void *)x___37->arg1);
  }
#line 280
  goto switch_break___0;
  case_107: /* CIL Label */ 
#line 283
  tEmPcast___38 = (AST_generic )n;
#line 283
  if (tEmPcast___38) {
#line 283
    if ((unsigned int )tEmPcast___38->kind >= 107U) {
#line 283
      if (! ((unsigned int )tEmPcast___38->kind <= 139U)) {
        {
#line 283
        __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 283U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 283
      __assert_fail("((tEmPcast)->kind >= kind_binary && (tEmPcast)->kind <= postkind_binary)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 283U,
                    "AST_print1");
      }
    }
  }
  {
#line 283
  x___38 = (binary )tEmPcast___38;
#line 285
  puts("binary");
#line 286
  pindent(indent);
#line 286
  puts("arg1:");
#line 286
  AST_print_list(indent + 1, (void *)x___38->arg1);
#line 287
  pindent(indent);
#line 287
  puts("arg2:");
#line 287
  AST_print_list(indent + 1, (void *)x___38->arg2);
  }
#line 288
  goto switch_break___0;
  case_140: /* CIL Label */ 
#line 291
  tEmPcast___39 = (AST_generic )n;
#line 291
  if (tEmPcast___39) {
#line 291
    if ((unsigned int )tEmPcast___39->kind >= 140U) {
#line 291
      if (! ((unsigned int )tEmPcast___39->kind <= 140U)) {
        {
#line 291
        __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 291U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 291
      __assert_fail("((tEmPcast)->kind >= kind_comma && (tEmPcast)->kind <= postkind_comma)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 291U,
                    "AST_print1");
      }
    }
  }
  {
#line 291
  x___39 = (comma )tEmPcast___39;
#line 293
  puts("comma");
#line 294
  pindent(indent);
#line 294
  puts("arg1:");
#line 294
  AST_print_list(indent + 1, (void *)x___39->arg1);
  }
#line 295
  goto switch_break___0;
  case_141: /* CIL Label */ 
#line 298
  tEmPcast___40 = (AST_generic )n;
#line 298
  if (tEmPcast___40) {
#line 298
    if ((unsigned int )tEmPcast___40->kind >= 141U) {
#line 298
      if (! ((unsigned int )tEmPcast___40->kind <= 141U)) {
        {
#line 298
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 298U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 298
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_type && (tEmPcast)->kind <= postkind_sizeof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 298U,
                    "AST_print1");
      }
    }
  }
  {
#line 298
  x___40 = (sizeof_type )tEmPcast___40;
#line 300
  puts("sizeof_type");
#line 301
  pindent(indent);
#line 301
  puts("asttype:");
#line 301
  AST_print_list(indent + 1, (void *)x___40->asttype);
  }
#line 302
  goto switch_break___0;
  case_142: /* CIL Label */ 
#line 305
  tEmPcast___41 = (AST_generic )n;
#line 305
  if (tEmPcast___41) {
#line 305
    if ((unsigned int )tEmPcast___41->kind >= 142U) {
#line 305
      if (! ((unsigned int )tEmPcast___41->kind <= 142U)) {
        {
#line 305
        __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 305U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 305
      __assert_fail("((tEmPcast)->kind >= kind_alignof_type && (tEmPcast)->kind <= postkind_alignof_type)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 305U,
                    "AST_print1");
      }
    }
  }
  {
#line 305
  x___41 = (alignof_type )tEmPcast___41;
#line 307
  puts("alignof_type");
#line 308
  pindent(indent);
#line 308
  puts("asttype:");
#line 308
  AST_print_list(indent + 1, (void *)x___41->asttype);
  }
#line 309
  goto switch_break___0;
  case_143: /* CIL Label */ 
#line 312
  tEmPcast___42 = (AST_generic )n;
#line 312
  if (tEmPcast___42) {
#line 312
    if ((unsigned int )tEmPcast___42->kind >= 143U) {
#line 312
      if (! ((unsigned int )tEmPcast___42->kind <= 143U)) {
        {
#line 312
        __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 312U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 312
      __assert_fail("((tEmPcast)->kind >= kind_label_address && (tEmPcast)->kind <= postkind_label_address)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 312U,
                    "AST_print1");
      }
    }
  }
  {
#line 312
  x___42 = (label_address )tEmPcast___42;
#line 314
  puts("label_address");
#line 315
  pindent(indent);
#line 315
  puts("id_label:");
#line 315
  AST_print_list(indent + 1, (void *)x___42->id_label);
  }
#line 316
  goto switch_break___0;
  case_86: /* CIL Label */ 
#line 319
  tEmPcast___43 = (AST_generic )n;
#line 319
  if (tEmPcast___43) {
#line 319
    if ((unsigned int )tEmPcast___43->kind >= 86U) {
#line 319
      if (! ((unsigned int )tEmPcast___43->kind <= 86U)) {
        {
#line 319
        __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 319U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 319
      __assert_fail("((tEmPcast)->kind >= kind_cast && (tEmPcast)->kind <= postkind_cast)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 319U,
                    "AST_print1");
      }
    }
  }
  {
#line 319
  x___43 = (cast )tEmPcast___43;
#line 321
  puts("cast");
#line 322
  pindent(indent);
#line 322
  puts("arg1:");
#line 322
  AST_print_list(indent + 1, (void *)x___43->arg1);
#line 323
  pindent(indent);
#line 323
  puts("asttype:");
#line 323
  AST_print_list(indent + 1, (void *)x___43->asttype);
  }
#line 324
  goto switch_break___0;
  case_144: /* CIL Label */ 
#line 327
  tEmPcast___44 = (AST_generic )n;
#line 327
  if (tEmPcast___44) {
#line 327
    if ((unsigned int )tEmPcast___44->kind >= 144U) {
#line 327
      if (! ((unsigned int )tEmPcast___44->kind <= 144U)) {
        {
#line 327
        __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 327U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 327
      __assert_fail("((tEmPcast)->kind >= kind_cast_list && (tEmPcast)->kind <= postkind_cast_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 327U,
                    "AST_print1");
      }
    }
  }
  {
#line 327
  x___44 = (cast_list )tEmPcast___44;
#line 329
  puts("cast_list");
#line 330
  pindent(indent);
#line 330
  puts("asttype:");
#line 330
  AST_print_list(indent + 1, (void *)x___44->asttype);
#line 331
  pindent(indent);
#line 331
  puts("init_expr:");
#line 331
  AST_print_list(indent + 1, (void *)x___44->init_expr);
  }
#line 332
  goto switch_break___0;
  case_145: /* CIL Label */ 
#line 335
  tEmPcast___45 = (AST_generic )n;
#line 335
  if (tEmPcast___45) {
#line 335
    if ((unsigned int )tEmPcast___45->kind >= 145U) {
#line 335
      if (! ((unsigned int )tEmPcast___45->kind <= 145U)) {
        {
#line 335
        __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 335U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 335
      __assert_fail("((tEmPcast)->kind >= kind_conditional && (tEmPcast)->kind <= postkind_conditional)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 335U,
                    "AST_print1");
      }
    }
  }
  {
#line 335
  x___45 = (conditional )tEmPcast___45;
#line 337
  puts("conditional");
#line 338
  pindent(indent);
#line 338
  puts("condition:");
#line 338
  AST_print_list(indent + 1, (void *)x___45->condition);
#line 339
  pindent(indent);
#line 339
  puts("arg1:");
#line 339
  AST_print_list(indent + 1, (void *)x___45->arg1);
#line 340
  pindent(indent);
#line 340
  puts("arg2:");
#line 340
  AST_print_list(indent + 1, (void *)x___45->arg2);
  }
#line 341
  goto switch_break___0;
  case_146___0: /* CIL Label */ 
  {
#line 343
  puts("identifier");
  }
#line 343
  goto switch_break___0;
  case_147: /* CIL Label */ 
#line 345
  tEmPcast___46 = (AST_generic )n;
#line 345
  if (tEmPcast___46) {
#line 345
    if ((unsigned int )tEmPcast___46->kind >= 147U) {
#line 345
      if (! ((unsigned int )tEmPcast___46->kind <= 147U)) {
        {
#line 345
        __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 345U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 345
      __assert_fail("((tEmPcast)->kind >= kind_compound_expr && (tEmPcast)->kind <= postkind_compound_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 345U,
                    "AST_print1");
      }
    }
  }
  {
#line 345
  x___46 = (compound_expr )tEmPcast___46;
#line 347
  puts("compound_expr");
#line 348
  pindent(indent);
#line 348
  puts("stmt:");
#line 348
  AST_print_list(indent + 1, (void *)x___46->stmt);
  }
#line 349
  goto switch_break___0;
  case_148: /* CIL Label */ 
#line 352
  tEmPcast___47 = (AST_generic )n;
#line 352
  if (tEmPcast___47) {
#line 352
    if ((unsigned int )tEmPcast___47->kind >= 148U) {
#line 352
      if (! ((unsigned int )tEmPcast___47->kind <= 148U)) {
        {
#line 352
        __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 352U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 352
      __assert_fail("((tEmPcast)->kind >= kind_function_call && (tEmPcast)->kind <= postkind_function_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 352U,
                    "AST_print1");
      }
    }
  }
  {
#line 352
  x___47 = (function_call )tEmPcast___47;
#line 354
  puts("function_call");
#line 355
  pindent(indent);
#line 355
  puts("arg1:");
#line 355
  AST_print_list(indent + 1, (void *)x___47->arg1);
#line 356
  pindent(indent);
#line 356
  puts("args:");
#line 356
  AST_print_list(indent + 1, (void *)x___47->args);
  }
#line 357
  goto switch_break___0;
  case_87: /* CIL Label */ 
#line 360
  tEmPcast___48 = (AST_generic )n;
#line 360
  if (tEmPcast___48) {
#line 360
    if ((unsigned int )tEmPcast___48->kind >= 87U) {
#line 360
      if (! ((unsigned int )tEmPcast___48->kind <= 87U)) {
        {
#line 360
        __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 360U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 360
      __assert_fail("((tEmPcast)->kind >= kind_field_ref && (tEmPcast)->kind <= postkind_field_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 360U,
                    "AST_print1");
      }
    }
  }
  {
#line 360
  x___48 = (field_ref )tEmPcast___48;
#line 362
  puts("field_ref");
#line 363
  pindent(indent);
#line 363
  puts("arg1:");
#line 363
  AST_print_list(indent + 1, (void *)x___48->arg1);
  }
#line 364
  goto switch_break___0;
  case_88: /* CIL Label */ 
#line 367
  tEmPcast___49 = (AST_generic )n;
#line 367
  if (tEmPcast___49) {
#line 367
    if ((unsigned int )tEmPcast___49->kind >= 88U) {
#line 367
      if (! ((unsigned int )tEmPcast___49->kind <= 92U)) {
        {
#line 367
        __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 367U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 367
      __assert_fail("((tEmPcast)->kind >= kind_increment && (tEmPcast)->kind <= postkind_increment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 367U,
                    "AST_print1");
      }
    }
  }
  {
#line 367
  x___49 = (increment )tEmPcast___49;
#line 369
  puts("increment");
#line 370
  pindent(indent);
#line 370
  puts("arg1:");
#line 370
  AST_print_list(indent + 1, (void *)x___49->arg1);
  }
#line 371
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 374
  tEmPcast___50 = (AST_generic )n;
#line 374
  if (tEmPcast___50) {
#line 374
    if ((unsigned int )tEmPcast___50->kind >= 108U) {
#line 374
      if (! ((unsigned int )tEmPcast___50->kind <= 114U)) {
        {
#line 374
        __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 374U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 374
      __assert_fail("((tEmPcast)->kind >= kind_comparison && (tEmPcast)->kind <= postkind_comparison)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 374U,
                    "AST_print1");
      }
    }
  }
  {
#line 374
  x___50 = (comparison )tEmPcast___50;
#line 376
  puts("comparison");
#line 377
  pindent(indent);
#line 377
  puts("arg1:");
#line 377
  AST_print_list(indent + 1, (void *)x___50->arg1);
#line 378
  pindent(indent);
#line 378
  puts("arg2:");
#line 378
  AST_print_list(indent + 1, (void *)x___50->arg2);
  }
#line 379
  goto switch_break___0;
  case_115: /* CIL Label */ 
#line 382
  tEmPcast___51 = (AST_generic )n;
#line 382
  if (tEmPcast___51) {
#line 382
    if ((unsigned int )tEmPcast___51->kind >= 115U) {
#line 382
      if (! ((unsigned int )tEmPcast___51->kind <= 126U)) {
        {
#line 382
        __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 382U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 382
      __assert_fail("((tEmPcast)->kind >= kind_assignment && (tEmPcast)->kind <= postkind_assignment)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 382U,
                    "AST_print1");
      }
    }
  }
  {
#line 382
  x___51 = (assignment )tEmPcast___51;
#line 384
  puts("assignment");
#line 385
  pindent(indent);
#line 385
  puts("arg1:");
#line 385
  AST_print_list(indent + 1, (void *)x___51->arg1);
#line 386
  pindent(indent);
#line 386
  puts("arg2:");
#line 386
  AST_print_list(indent + 1, (void *)x___51->arg2);
  }
#line 387
  goto switch_break___0;
  case_149: /* CIL Label */ 
#line 390
  tEmPcast___52 = (AST_generic )n;
#line 390
  if (tEmPcast___52) {
#line 390
    if ((unsigned int )tEmPcast___52->kind >= 149U) {
#line 390
      if (! ((unsigned int )tEmPcast___52->kind <= 149U)) {
        {
#line 390
        __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 390U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 390
      __assert_fail("((tEmPcast)->kind >= kind_init_list && (tEmPcast)->kind <= postkind_init_list)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 390U,
                    "AST_print1");
      }
    }
  }
  {
#line 390
  x___52 = (init_list )tEmPcast___52;
#line 392
  puts("init_list");
#line 393
  pindent(indent);
#line 393
  puts("args:");
#line 393
  AST_print_list(indent + 1, (void *)x___52->args);
  }
#line 394
  goto switch_break___0;
  case_150: /* CIL Label */ 
#line 397
  tEmPcast___53 = (AST_generic )n;
#line 397
  if (tEmPcast___53) {
#line 397
    if ((unsigned int )tEmPcast___53->kind >= 150U) {
#line 397
      if (! ((unsigned int )tEmPcast___53->kind <= 150U)) {
        {
#line 397
        __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 397U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 397
      __assert_fail("((tEmPcast)->kind >= kind_init_specific && (tEmPcast)->kind <= postkind_init_specific)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 397U,
                    "AST_print1");
      }
    }
  }
  {
#line 397
  x___53 = (init_specific )tEmPcast___53;
#line 399
  puts("init_specific");
#line 400
  pindent(indent);
#line 400
  puts("designator:");
#line 400
  AST_print_list(indent + 1, (void *)x___53->designator);
#line 401
  pindent(indent);
#line 401
  puts("init_expr:");
#line 401
  AST_print_list(indent + 1, (void *)x___53->init_expr);
  }
#line 402
  goto switch_break___0;
  case_189: /* CIL Label */ 
  {
#line 404
  puts("designator");
  }
#line 404
  goto switch_break___0;
  case_190: /* CIL Label */ 
  {
#line 405
  puts("designate_field");
  }
#line 405
  goto switch_break___0;
  case_191: /* CIL Label */ 
#line 407
  tEmPcast___54 = (AST_generic )n;
#line 407
  if (tEmPcast___54) {
#line 407
    if ((unsigned int )tEmPcast___54->kind >= 191U) {
#line 407
      if (! ((unsigned int )tEmPcast___54->kind <= 191U)) {
        {
#line 407
        __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 407U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 407
      __assert_fail("((tEmPcast)->kind >= kind_designate_index && (tEmPcast)->kind <= postkind_designate_index)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 407U,
                    "AST_print1");
      }
    }
  }
  {
#line 407
  x___54 = (designate_index )tEmPcast___54;
#line 409
  puts("designate_index");
#line 410
  pindent(indent);
#line 410
  puts("arg1:");
#line 410
  AST_print_list(indent + 1, (void *)x___54->arg1);
#line 411
  pindent(indent);
#line 411
  puts("arg2:");
#line 411
  AST_print_list(indent + 1, (void *)x___54->arg2);
  }
#line 412
  goto switch_break___0;
  case_151___0: /* CIL Label */ 
  {
#line 414
  puts("lexical_cst");
  }
#line 414
  goto switch_break___0;
  case_152___0: /* CIL Label */ 
  {
#line 415
  puts("string_cst");
  }
#line 415
  goto switch_break___0;
  case_153: /* CIL Label */ 
#line 417
  tEmPcast___55 = (AST_generic )n;
#line 417
  if (tEmPcast___55) {
#line 417
    if ((unsigned int )tEmPcast___55->kind >= 153U) {
#line 417
      if (! ((unsigned int )tEmPcast___55->kind <= 153U)) {
        {
#line 417
        __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 417U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 417
      __assert_fail("((tEmPcast)->kind >= kind_string && (tEmPcast)->kind <= postkind_string)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 417U,
                    "AST_print1");
      }
    }
  }
  {
#line 417
  x___55 = (string )tEmPcast___55;
#line 419
  puts("string");
#line 420
  pindent(indent);
#line 420
  puts("strings:");
#line 420
  AST_print_list(indent + 1, (void *)x___55->strings);
  }
#line 421
  goto switch_break___0;
  case_185___0: /* CIL Label */ 
  {
#line 423
  puts("id_label");
  }
#line 423
  goto switch_break___0;
  case_186: /* CIL Label */ 
#line 425
  tEmPcast___56 = (AST_generic )n;
#line 425
  if (tEmPcast___56) {
#line 425
    if ((unsigned int )tEmPcast___56->kind >= 186U) {
#line 425
      if (! ((unsigned int )tEmPcast___56->kind <= 186U)) {
        {
#line 425
        __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 425U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 425
      __assert_fail("((tEmPcast)->kind >= kind_case_label && (tEmPcast)->kind <= postkind_case_label)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 425U,
                    "AST_print1");
      }
    }
  }
  {
#line 425
  x___56 = (case_label )tEmPcast___56;
#line 427
  puts("case_label");
#line 428
  pindent(indent);
#line 428
  puts("arg1:");
#line 428
  AST_print_list(indent + 1, (void *)x___56->arg1);
#line 429
  pindent(indent);
#line 429
  puts("arg2:");
#line 429
  AST_print_list(indent + 1, (void *)x___56->arg2);
  }
#line 430
  goto switch_break___0;
  case_187: /* CIL Label */ 
  {
#line 432
  puts("default_label");
  }
#line 432
  goto switch_break___0;
  case_192___0: /* CIL Label */ 
  {
#line 433
  puts("word");
  }
#line 433
  goto switch_break___0;
  case_193: /* CIL Label */ 
#line 435
  tEmPcast___57 = (AST_generic )n;
#line 435
  if (tEmPcast___57) {
#line 435
    if ((unsigned int )tEmPcast___57->kind >= 193U) {
#line 435
      if (! ((unsigned int )tEmPcast___57->kind <= 193U)) {
        {
#line 435
        __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 435U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 435
      __assert_fail("((tEmPcast)->kind >= kind_asm_operand && (tEmPcast)->kind <= postkind_asm_operand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 435U,
                    "AST_print1");
      }
    }
  }
  {
#line 435
  x___57 = (asm_operand )tEmPcast___57;
#line 437
  puts("asm_operand");
#line 438
  pindent(indent);
#line 438
  puts("word1:");
#line 438
  AST_print_list(indent + 1, (void *)x___57->word1);
#line 439
  pindent(indent);
#line 439
  puts("string:");
#line 439
  AST_print_list(indent + 1, (void *)x___57->string);
#line 440
  pindent(indent);
#line 440
  puts("arg1:");
#line 440
  AST_print_list(indent + 1, (void *)x___57->arg1);
  }
#line 441
  goto switch_break___0;
  case_54: /* CIL Label */ 
#line 444
  tEmPcast___58 = (AST_generic )n;
#line 444
  if (tEmPcast___58) {
#line 444
    if ((unsigned int )tEmPcast___58->kind >= 54U) {
#line 444
      if (! ((unsigned int )tEmPcast___58->kind <= 56U)) {
        {
#line 444
        __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 444U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 444
      __assert_fail("((tEmPcast)->kind >= kind_nesc_decl && (tEmPcast)->kind <= postkind_nesc_decl)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 444U,
                    "AST_print1");
      }
    }
  }
  {
#line 444
  x___58 = (nesc_decl )tEmPcast___58;
#line 446
  puts("nesc_decl");
#line 447
  pindent(indent);
#line 447
  puts("word1:");
#line 447
  AST_print_list(indent + 1, (void *)x___58->word1);
#line 448
  pindent(indent);
#line 448
  puts("attributes:");
#line 448
  AST_print_list(indent + 1, (void *)x___58->attributes);
  }
#line 449
  goto switch_break___0;
  case_55: /* CIL Label */ 
#line 452
  tEmPcast___59 = (AST_generic )n;
#line 452
  if (tEmPcast___59) {
#line 452
    if ((unsigned int )tEmPcast___59->kind >= 55U) {
#line 452
      if (! ((unsigned int )tEmPcast___59->kind <= 55U)) {
        {
#line 452
        __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 452U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 452
      __assert_fail("((tEmPcast)->kind >= kind_interface && (tEmPcast)->kind <= postkind_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 452U,
                    "AST_print1");
      }
    }
  }
  {
#line 452
  x___59 = (interface )tEmPcast___59;
#line 454
  puts("interface");
#line 455
  pindent(indent);
#line 455
  puts("word1:");
#line 455
  AST_print_list(indent + 1, (void *)x___59->word1);
#line 456
  pindent(indent);
#line 456
  puts("attributes:");
#line 456
  AST_print_list(indent + 1, (void *)x___59->attributes);
#line 457
  pindent(indent);
#line 457
  puts("decls:");
#line 457
  AST_print_list(indent + 1, (void *)x___59->decls);
  }
#line 458
  goto switch_break___0;
  case_56: /* CIL Label */ 
#line 461
  tEmPcast___60 = (AST_generic )n;
#line 461
  if (tEmPcast___60) {
#line 461
    if ((unsigned int )tEmPcast___60->kind >= 56U) {
#line 461
      if (! ((unsigned int )tEmPcast___60->kind <= 56U)) {
        {
#line 461
        __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 461U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 461
      __assert_fail("((tEmPcast)->kind >= kind_component && (tEmPcast)->kind <= postkind_component)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 461U,
                    "AST_print1");
      }
    }
  }
  {
#line 461
  x___60 = (component )tEmPcast___60;
#line 463
  puts("component");
#line 464
  pindent(indent);
#line 464
  puts("word1:");
#line 464
  AST_print_list(indent + 1, (void *)x___60->word1);
#line 465
  pindent(indent);
#line 465
  puts("attributes:");
#line 465
  AST_print_list(indent + 1, (void *)x___60->attributes);
#line 466
  pindent(indent);
#line 466
  puts("parms:");
#line 466
  AST_print_list(indent + 1, (void *)x___60->parms);
#line 467
  pindent(indent);
#line 467
  puts("decls:");
#line 467
  AST_print_list(indent + 1, (void *)x___60->decls);
#line 468
  pindent(indent);
#line 468
  puts("implementation:");
#line 468
  AST_print_list(indent + 1, (void *)x___60->implementation);
  }
#line 469
  goto switch_break___0;
  case_194: /* CIL Label */ 
  {
#line 471
  puts("implementation");
  }
#line 471
  goto switch_break___0;
  case_195: /* CIL Label */ 
#line 473
  tEmPcast___61 = (AST_generic )n;
#line 473
  if (tEmPcast___61) {
#line 473
    if ((unsigned int )tEmPcast___61->kind >= 195U) {
#line 473
      if (! ((unsigned int )tEmPcast___61->kind <= 195U)) {
        {
#line 473
        __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 473U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 473
      __assert_fail("((tEmPcast)->kind >= kind_configuration && (tEmPcast)->kind <= postkind_configuration)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 473U,
                    "AST_print1");
      }
    }
  }
  {
#line 473
  x___61 = (configuration )tEmPcast___61;
#line 475
  puts("configuration");
#line 476
  pindent(indent);
#line 476
  puts("decls:");
#line 476
  AST_print_list(indent + 1, (void *)x___61->decls);
  }
#line 477
  goto switch_break___0;
  case_196: /* CIL Label */ 
#line 480
  tEmPcast___62 = (AST_generic )n;
#line 480
  if (tEmPcast___62) {
#line 480
    if ((unsigned int )tEmPcast___62->kind >= 196U) {
#line 480
      if (! ((unsigned int )tEmPcast___62->kind <= 196U)) {
        {
#line 480
        __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 480U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 480
      __assert_fail("((tEmPcast)->kind >= kind_module && (tEmPcast)->kind <= postkind_module)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 480U,
                    "AST_print1");
      }
    }
  }
  {
#line 480
  x___62 = (module )tEmPcast___62;
#line 482
  puts("module");
#line 483
  pindent(indent);
#line 483
  puts("decls:");
#line 483
  AST_print_list(indent + 1, (void *)x___62->decls);
  }
#line 484
  goto switch_break___0;
  case_197: /* CIL Label */ 
  {
#line 486
  puts("binary_component");
  }
#line 486
  goto switch_break___0;
  case_57: /* CIL Label */ 
#line 488
  tEmPcast___63 = (AST_generic )n;
#line 488
  if (tEmPcast___63) {
#line 488
    if ((unsigned int )tEmPcast___63->kind >= 57U) {
#line 488
      if (! ((unsigned int )tEmPcast___63->kind <= 57U)) {
        {
#line 488
        __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 488U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 488
      __assert_fail("((tEmPcast)->kind >= kind_rp_interface && (tEmPcast)->kind <= postkind_rp_interface)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 488U,
                    "AST_print1");
      }
    }
  }
  {
#line 488
  x___63 = (rp_interface )tEmPcast___63;
#line 490
  puts("rp_interface");
#line 491
  pindent(indent);
#line 491
  puts("decls:");
#line 491
  AST_print_list(indent + 1, (void *)x___63->decls);
  }
#line 492
  goto switch_break___0;
  case_58: /* CIL Label */ 
#line 495
  tEmPcast___64 = (AST_generic )n;
#line 495
  if (tEmPcast___64) {
#line 495
    if ((unsigned int )tEmPcast___64->kind >= 58U) {
#line 495
      if (! ((unsigned int )tEmPcast___64->kind <= 58U)) {
        {
#line 495
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 495U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 495
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref && (tEmPcast)->kind <= postkind_interface_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 495U,
                    "AST_print1");
      }
    }
  }
  {
#line 495
  x___64 = (interface_ref )tEmPcast___64;
#line 497
  puts("interface_ref");
#line 498
  pindent(indent);
#line 498
  puts("word1:");
#line 498
  AST_print_list(indent + 1, (void *)x___64->word1);
#line 499
  pindent(indent);
#line 499
  puts("args:");
#line 499
  AST_print_list(indent + 1, (void *)x___64->args);
#line 500
  pindent(indent);
#line 500
  puts("word2:");
#line 500
  AST_print_list(indent + 1, (void *)x___64->word2);
#line 501
  pindent(indent);
#line 501
  puts("gparms:");
#line 501
  AST_print_list(indent + 1, (void *)x___64->gparms);
#line 502
  pindent(indent);
#line 502
  puts("attributes:");
#line 502
  AST_print_list(indent + 1, (void *)x___64->attributes);
  }
#line 503
  goto switch_break___0;
  case_59: /* CIL Label */ 
#line 506
  tEmPcast___65 = (AST_generic )n;
#line 506
  if (tEmPcast___65) {
#line 506
    if ((unsigned int )tEmPcast___65->kind >= 59U) {
#line 506
      if (! ((unsigned int )tEmPcast___65->kind <= 59U)) {
        {
#line 506
        __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 506U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 506
      __assert_fail("((tEmPcast)->kind >= kind_component_ref && (tEmPcast)->kind <= postkind_component_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 506U,
                    "AST_print1");
      }
    }
  }
  {
#line 506
  x___65 = (component_ref )tEmPcast___65;
#line 508
  puts("component_ref");
#line 509
  pindent(indent);
#line 509
  puts("word1:");
#line 509
  AST_print_list(indent + 1, (void *)x___65->word1);
#line 510
  pindent(indent);
#line 510
  puts("word2:");
#line 510
  AST_print_list(indent + 1, (void *)x___65->word2);
#line 511
  pindent(indent);
#line 511
  puts("args:");
#line 511
  AST_print_list(indent + 1, (void *)x___65->args);
  }
#line 512
  goto switch_break___0;
  case_60: /* CIL Label */ 
#line 515
  tEmPcast___66 = (AST_generic )n;
#line 515
  if (tEmPcast___66) {
#line 515
    if ((unsigned int )tEmPcast___66->kind >= 60U) {
#line 515
      if (! ((unsigned int )tEmPcast___66->kind <= 62U)) {
        {
#line 515
        __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 515U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 515
      __assert_fail("((tEmPcast)->kind >= kind_connection && (tEmPcast)->kind <= postkind_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 515U,
                    "AST_print1");
      }
    }
  }
  {
#line 515
  x___66 = (connection )tEmPcast___66;
#line 517
  puts("connection");
#line 518
  pindent(indent);
#line 518
  puts("ep1:");
#line 518
  AST_print_list(indent + 1, (void *)x___66->ep1);
#line 519
  pindent(indent);
#line 519
  puts("ep2:");
#line 519
  AST_print_list(indent + 1, (void *)x___66->ep2);
  }
#line 520
  goto switch_break___0;
  case_198: /* CIL Label */ 
#line 523
  tEmPcast___67 = (AST_generic )n;
#line 523
  if (tEmPcast___67) {
#line 523
    if ((unsigned int )tEmPcast___67->kind >= 198U) {
#line 523
      if (! ((unsigned int )tEmPcast___67->kind <= 198U)) {
        {
#line 523
        __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 523U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 523
      __assert_fail("((tEmPcast)->kind >= kind_endpoint && (tEmPcast)->kind <= postkind_endpoint)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 523U,
                    "AST_print1");
      }
    }
  }
  {
#line 523
  x___67 = (endpoint )tEmPcast___67;
#line 525
  puts("endpoint");
#line 526
  pindent(indent);
#line 526
  puts("ids:");
#line 526
  AST_print_list(indent + 1, (void *)x___67->ids);
  }
#line 527
  goto switch_break___0;
  case_199: /* CIL Label */ 
#line 530
  tEmPcast___68 = (AST_generic )n;
#line 530
  if (tEmPcast___68) {
#line 530
    if ((unsigned int )tEmPcast___68->kind >= 199U) {
#line 530
      if (! ((unsigned int )tEmPcast___68->kind <= 199U)) {
        {
#line 530
        __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 530U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 530
      __assert_fail("((tEmPcast)->kind >= kind_parameterised_identifier && (tEmPcast)->kind <= postkind_parameterised_identifier)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 530U,
                    "AST_print1");
      }
    }
  }
  {
#line 530
  x___68 = (parameterised_identifier )tEmPcast___68;
#line 532
  puts("parameterised_identifier");
#line 533
  pindent(indent);
#line 533
  puts("word1:");
#line 533
  AST_print_list(indent + 1, (void *)x___68->word1);
#line 534
  pindent(indent);
#line 534
  puts("args:");
#line 534
  AST_print_list(indent + 1, (void *)x___68->args);
  }
#line 535
  goto switch_break___0;
  case_183: /* CIL Label */ 
#line 538
  tEmPcast___69 = (AST_generic )n;
#line 538
  if (tEmPcast___69) {
#line 538
    if ((unsigned int )tEmPcast___69->kind >= 183U) {
#line 538
      if (! ((unsigned int )tEmPcast___69->kind <= 183U)) {
        {
#line 538
        __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 538U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 538
      __assert_fail("((tEmPcast)->kind >= kind_generic_declarator && (tEmPcast)->kind <= postkind_generic_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 538U,
                    "AST_print1");
      }
    }
  }
  {
#line 538
  x___69 = (generic_declarator )tEmPcast___69;
#line 540
  puts("generic_declarator");
#line 541
  pindent(indent);
#line 541
  puts("declarator:");
#line 541
  AST_print_list(indent + 1, (void *)x___69->declarator);
#line 542
  pindent(indent);
#line 542
  puts("parms:");
#line 542
  AST_print_list(indent + 1, (void *)x___69->parms);
  }
#line 543
  goto switch_break___0;
  case_154: /* CIL Label */ 
#line 546
  tEmPcast___70 = (AST_generic )n;
#line 546
  if (tEmPcast___70) {
#line 546
    if ((unsigned int )tEmPcast___70->kind >= 154U) {
#line 546
      if (! ((unsigned int )tEmPcast___70->kind <= 154U)) {
        {
#line 546
        __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 546U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 546
      __assert_fail("((tEmPcast)->kind >= kind_generic_call && (tEmPcast)->kind <= postkind_generic_call)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 546U,
                    "AST_print1");
      }
    }
  }
  {
#line 546
  x___70 = (generic_call )tEmPcast___70;
#line 548
  puts("generic_call");
#line 549
  pindent(indent);
#line 549
  puts("arg1:");
#line 549
  AST_print_list(indent + 1, (void *)x___70->arg1);
#line 550
  pindent(indent);
#line 550
  puts("args:");
#line 550
  AST_print_list(indent + 1, (void *)x___70->args);
  }
#line 551
  goto switch_break___0;
  case_181: /* CIL Label */ 
#line 554
  tEmPcast___71 = (AST_generic )n;
#line 554
  if (tEmPcast___71) {
#line 554
    if ((unsigned int )tEmPcast___71->kind >= 181U) {
#line 554
      if (! ((unsigned int )tEmPcast___71->kind <= 181U)) {
        {
#line 554
        __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 554U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 554
      __assert_fail("((tEmPcast)->kind >= kind_interface_ref_declarator && (tEmPcast)->kind <= postkind_interface_ref_declarator)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 554U,
                    "AST_print1");
      }
    }
  }
  {
#line 554
  x___71 = (interface_ref_declarator )tEmPcast___71;
#line 556
  puts("interface_ref_declarator");
#line 557
  pindent(indent);
#line 557
  puts("declarator:");
#line 557
  AST_print_list(indent + 1, (void *)x___71->declarator);
#line 558
  pindent(indent);
#line 558
  puts("word1:");
#line 558
  AST_print_list(indent + 1, (void *)x___71->word1);
  }
#line 559
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 562
  tEmPcast___72 = (AST_generic )n;
#line 562
  if (tEmPcast___72) {
#line 562
    if ((unsigned int )tEmPcast___72->kind >= 93U) {
#line 562
      if (! ((unsigned int )tEmPcast___72->kind <= 93U)) {
        {
#line 562
        __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 562U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 562
      __assert_fail("((tEmPcast)->kind >= kind_interface_deref && (tEmPcast)->kind <= postkind_interface_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 562U,
                    "AST_print1");
      }
    }
  }
  {
#line 562
  x___72 = (interface_deref )tEmPcast___72;
#line 564
  puts("interface_deref");
#line 565
  pindent(indent);
#line 565
  puts("arg1:");
#line 565
  AST_print_list(indent + 1, (void *)x___72->arg1);
  }
#line 566
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 569
  tEmPcast___73 = (AST_generic )n;
#line 569
  if (tEmPcast___73) {
#line 569
    if ((unsigned int )tEmPcast___73->kind >= 94U) {
#line 569
      if (! ((unsigned int )tEmPcast___73->kind <= 94U)) {
        {
#line 569
        __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 569U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 569
      __assert_fail("((tEmPcast)->kind >= kind_component_deref && (tEmPcast)->kind <= postkind_component_deref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 569U,
                    "AST_print1");
      }
    }
  }
  {
#line 569
  x___73 = (component_deref )tEmPcast___73;
#line 571
  puts("component_deref");
#line 572
  pindent(indent);
#line 572
  puts("arg1:");
#line 572
  AST_print_list(indent + 1, (void *)x___73->arg1);
  }
#line 573
  goto switch_break___0;
  case_159: /* CIL Label */ 
  {
#line 575
  puts("component_typeref");
  }
#line 575
  goto switch_break___0;
  case_82: /* CIL Label */ 
#line 577
  tEmPcast___74 = (AST_generic )n;
#line 577
  if (tEmPcast___74) {
#line 577
    if ((unsigned int )tEmPcast___74->kind >= 82U) {
#line 577
      if (! ((unsigned int )tEmPcast___74->kind <= 82U)) {
        {
#line 577
        __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 577U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 577
      __assert_fail("((tEmPcast)->kind >= kind_atomic_stmt && (tEmPcast)->kind <= postkind_atomic_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 577U,
                    "AST_print1");
      }
    }
  }
  {
#line 577
  x___74 = (atomic_stmt )tEmPcast___74;
#line 579
  puts("atomic_stmt");
#line 580
  pindent(indent);
#line 580
  puts("stmt:");
#line 580
  AST_print_list(indent + 1, (void *)x___74->stmt);
  }
#line 581
  goto switch_break___0;
  case_165: /* CIL Label */ 
#line 584
  tEmPcast___75 = (AST_generic )n;
#line 584
  if (tEmPcast___75) {
#line 584
    if ((unsigned int )tEmPcast___75->kind >= 165U) {
#line 584
      if (! ((unsigned int )tEmPcast___75->kind <= 165U)) {
        {
#line 584
        __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 584U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 584
      __assert_fail("((tEmPcast)->kind >= kind_nesc_attribute && (tEmPcast)->kind <= postkind_nesc_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 584U,
                    "AST_print1");
      }
    }
  }
  {
#line 584
  x___75 = (nesc_attribute )tEmPcast___75;
#line 586
  puts("nesc_attribute");
#line 587
  pindent(indent);
#line 587
  puts("word1:");
#line 587
  AST_print_list(indent + 1, (void *)x___75->word1);
#line 588
  pindent(indent);
#line 588
  puts("arg1:");
#line 588
  AST_print_list(indent + 1, (void *)x___75->arg1);
  }
#line 589
  goto switch_break___0;
  case_63: /* CIL Label */ 
  {
#line 591
  puts("type_parm_decl");
  }
#line 591
  goto switch_break___0;
  case_155: /* CIL Label */ 
#line 593
  tEmPcast___76 = (AST_generic )n;
#line 593
  if (tEmPcast___76) {
#line 593
    if ((unsigned int )tEmPcast___76->kind >= 155U) {
#line 593
      if (! ((unsigned int )tEmPcast___76->kind <= 155U)) {
        {
#line 593
        __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 593U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 593
      __assert_fail("((tEmPcast)->kind >= kind_type_argument && (tEmPcast)->kind <= postkind_type_argument)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 593U,
                    "AST_print1");
      }
    }
  }
  {
#line 593
  x___76 = (type_argument )tEmPcast___76;
#line 595
  puts("type_argument");
#line 596
  pindent(indent);
#line 596
  puts("asttype:");
#line 596
  AST_print_list(indent + 1, (void *)x___76->asttype);
  }
#line 597
  goto switch_break___0;
  case_64: /* CIL Label */ 
  {
#line 599
  puts("error_decl");
  }
#line 599
  goto switch_break___0;
  case_173: /* CIL Label */ 
#line 601
  tEmPcast___77 = (AST_generic )n;
#line 601
  if (tEmPcast___77) {
#line 601
    if ((unsigned int )tEmPcast___77->kind >= 173U) {
#line 601
      if (! ((unsigned int )tEmPcast___77->kind <= 173U)) {
        {
#line 601
        __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 601U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 601
      __assert_fail("((tEmPcast)->kind >= kind_attribute_ref && (tEmPcast)->kind <= postkind_attribute_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 601U,
                    "AST_print1");
      }
    }
  }
  {
#line 601
  x___77 = (attribute_ref )tEmPcast___77;
#line 603
  puts("attribute_ref");
#line 604
  pindent(indent);
#line 604
  puts("word1:");
#line 604
  AST_print_list(indent + 1, (void *)x___77->word1);
#line 605
  pindent(indent);
#line 605
  puts("attributes:");
#line 605
  AST_print_list(indent + 1, (void *)x___77->attributes);
#line 606
  pindent(indent);
#line 606
  puts("fields:");
#line 606
  AST_print_list(indent + 1, (void *)x___77->fields);
  }
#line 607
  goto switch_break___0;
  case_174: /* CIL Label */ 
#line 610
  tEmPcast___78 = (AST_generic )n;
#line 610
  if (tEmPcast___78) {
#line 610
    if ((unsigned int )tEmPcast___78->kind >= 174U) {
#line 610
      if (! ((unsigned int )tEmPcast___78->kind <= 174U)) {
        {
#line 610
        __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 610U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 610
      __assert_fail("((tEmPcast)->kind >= kind_enum_ref && (tEmPcast)->kind <= postkind_enum_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 610U,
                    "AST_print1");
      }
    }
  }
  {
#line 610
  x___78 = (enum_ref )tEmPcast___78;
#line 612
  puts("enum_ref");
#line 613
  pindent(indent);
#line 613
  puts("word1:");
#line 613
  AST_print_list(indent + 1, (void *)x___78->word1);
#line 614
  pindent(indent);
#line 614
  puts("attributes:");
#line 614
  AST_print_list(indent + 1, (void *)x___78->attributes);
#line 615
  pindent(indent);
#line 615
  puts("fields:");
#line 615
  AST_print_list(indent + 1, (void *)x___78->fields);
  }
#line 616
  goto switch_break___0;
  case_83: /* CIL Label */ 
  {
#line 618
  puts("error_stmt");
  }
#line 618
  goto switch_break___0;
  case_73: /* CIL Label */ 
#line 620
  tEmPcast___79 = (AST_generic )n;
#line 620
  if (tEmPcast___79) {
#line 620
    if ((unsigned int )tEmPcast___79->kind >= 73U) {
#line 620
      if (! ((unsigned int )tEmPcast___79->kind <= 73U)) {
        {
#line 620
        __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 620U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 620
      __assert_fail("((tEmPcast)->kind >= kind_while_stmt && (tEmPcast)->kind <= postkind_while_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 620U,
                    "AST_print1");
      }
    }
  }
  {
#line 620
  x___79 = (while_stmt )tEmPcast___79;
#line 622
  puts("while_stmt");
#line 623
  pindent(indent);
#line 623
  puts("condition:");
#line 623
  AST_print_list(indent + 1, (void *)x___79->condition);
#line 624
  pindent(indent);
#line 624
  puts("stmt:");
#line 624
  AST_print_list(indent + 1, (void *)x___79->stmt);
  }
#line 625
  goto switch_break___0;
  case_74: /* CIL Label */ 
#line 628
  tEmPcast___80 = (AST_generic )n;
#line 628
  if (tEmPcast___80) {
#line 628
    if ((unsigned int )tEmPcast___80->kind >= 74U) {
#line 628
      if (! ((unsigned int )tEmPcast___80->kind <= 74U)) {
        {
#line 628
        __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 628U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 628
      __assert_fail("((tEmPcast)->kind >= kind_dowhile_stmt && (tEmPcast)->kind <= postkind_dowhile_stmt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 628U,
                    "AST_print1");
      }
    }
  }
  {
#line 628
  x___80 = (dowhile_stmt )tEmPcast___80;
#line 630
  puts("dowhile_stmt");
#line 631
  pindent(indent);
#line 631
  puts("condition:");
#line 631
  AST_print_list(indent + 1, (void *)x___80->condition);
#line 632
  pindent(indent);
#line 632
  puts("stmt:");
#line 632
  AST_print_list(indent + 1, (void *)x___80->stmt);
  }
#line 633
  goto switch_break___0;
  case_156: /* CIL Label */ 
  {
#line 635
  puts("error_expr");
  }
#line 635
  goto switch_break___0;
  case_127: /* CIL Label */ 
#line 637
  tEmPcast___81 = (AST_generic )n;
#line 637
  if (tEmPcast___81) {
#line 637
    if ((unsigned int )tEmPcast___81->kind >= 127U) {
#line 637
      if (! ((unsigned int )tEmPcast___81->kind <= 127U)) {
        {
#line 637
        __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 637U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 637
      __assert_fail("((tEmPcast)->kind >= kind_array_ref && (tEmPcast)->kind <= postkind_array_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 637U,
                    "AST_print1");
      }
    }
  }
  {
#line 637
  x___81 = (array_ref )tEmPcast___81;
#line 639
  puts("array_ref");
#line 640
  pindent(indent);
#line 640
  puts("arg1:");
#line 640
  AST_print_list(indent + 1, (void *)x___81->arg1);
#line 641
  pindent(indent);
#line 641
  puts("arg2:");
#line 641
  AST_print_list(indent + 1, (void *)x___81->arg2);
  }
#line 642
  goto switch_break___0;
  case_95: /* CIL Label */ 
#line 645
  tEmPcast___82 = (AST_generic )n;
#line 645
  if (tEmPcast___82) {
#line 645
    if ((unsigned int )tEmPcast___82->kind >= 95U) {
#line 645
      if (! ((unsigned int )tEmPcast___82->kind <= 95U)) {
        {
#line 645
        __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 645U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 645
      __assert_fail("((tEmPcast)->kind >= kind_dereference && (tEmPcast)->kind <= postkind_dereference)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 645U,
                    "AST_print1");
      }
    }
  }
  {
#line 645
  x___82 = (dereference )tEmPcast___82;
#line 647
  puts("dereference");
#line 648
  pindent(indent);
#line 648
  puts("arg1:");
#line 648
  AST_print_list(indent + 1, (void *)x___82->arg1);
  }
#line 649
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 652
  tEmPcast___83 = (AST_generic )n;
#line 652
  if (tEmPcast___83) {
#line 652
    if ((unsigned int )tEmPcast___83->kind >= 96U) {
#line 652
      if (! ((unsigned int )tEmPcast___83->kind <= 96U)) {
        {
#line 652
        __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 652U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 652
      __assert_fail("((tEmPcast)->kind >= kind_extension_expr && (tEmPcast)->kind <= postkind_extension_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 652U,
                    "AST_print1");
      }
    }
  }
  {
#line 652
  x___83 = (extension_expr )tEmPcast___83;
#line 654
  puts("extension_expr");
#line 655
  pindent(indent);
#line 655
  puts("arg1:");
#line 655
  AST_print_list(indent + 1, (void *)x___83->arg1);
  }
#line 656
  goto switch_break___0;
  case_97: /* CIL Label */ 
#line 659
  tEmPcast___84 = (AST_generic )n;
#line 659
  if (tEmPcast___84) {
#line 659
    if ((unsigned int )tEmPcast___84->kind >= 97U) {
#line 659
      if (! ((unsigned int )tEmPcast___84->kind <= 97U)) {
        {
#line 659
        __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 659U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 659
      __assert_fail("((tEmPcast)->kind >= kind_sizeof_expr && (tEmPcast)->kind <= postkind_sizeof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 659U,
                    "AST_print1");
      }
    }
  }
  {
#line 659
  x___84 = (sizeof_expr )tEmPcast___84;
#line 661
  puts("sizeof_expr");
#line 662
  pindent(indent);
#line 662
  puts("arg1:");
#line 662
  AST_print_list(indent + 1, (void *)x___84->arg1);
  }
#line 663
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 666
  tEmPcast___85 = (AST_generic )n;
#line 666
  if (tEmPcast___85) {
#line 666
    if ((unsigned int )tEmPcast___85->kind >= 98U) {
#line 666
      if (! ((unsigned int )tEmPcast___85->kind <= 98U)) {
        {
#line 666
        __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 666U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 666
      __assert_fail("((tEmPcast)->kind >= kind_alignof_expr && (tEmPcast)->kind <= postkind_alignof_expr)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 666U,
                    "AST_print1");
      }
    }
  }
  {
#line 666
  x___85 = (alignof_expr )tEmPcast___85;
#line 668
  puts("alignof_expr");
#line 669
  pindent(indent);
#line 669
  puts("arg1:");
#line 669
  AST_print_list(indent + 1, (void *)x___85->arg1);
  }
#line 670
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 673
  tEmPcast___86 = (AST_generic )n;
#line 673
  if (tEmPcast___86) {
#line 673
    if ((unsigned int )tEmPcast___86->kind >= 99U) {
#line 673
      if (! ((unsigned int )tEmPcast___86->kind <= 99U)) {
        {
#line 673
        __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 673U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 673
      __assert_fail("((tEmPcast)->kind >= kind_realpart && (tEmPcast)->kind <= postkind_realpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 673U,
                    "AST_print1");
      }
    }
  }
  {
#line 673
  x___86 = (realpart )tEmPcast___86;
#line 675
  puts("realpart");
#line 676
  pindent(indent);
#line 676
  puts("arg1:");
#line 676
  AST_print_list(indent + 1, (void *)x___86->arg1);
  }
#line 677
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 680
  tEmPcast___87 = (AST_generic )n;
#line 680
  if (tEmPcast___87) {
#line 680
    if ((unsigned int )tEmPcast___87->kind >= 100U) {
#line 680
      if (! ((unsigned int )tEmPcast___87->kind <= 100U)) {
        {
#line 680
        __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 680U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 680
      __assert_fail("((tEmPcast)->kind >= kind_imagpart && (tEmPcast)->kind <= postkind_imagpart)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 680U,
                    "AST_print1");
      }
    }
  }
  {
#line 680
  x___87 = (imagpart )tEmPcast___87;
#line 682
  puts("imagpart");
#line 683
  pindent(indent);
#line 683
  puts("arg1:");
#line 683
  AST_print_list(indent + 1, (void *)x___87->arg1);
  }
#line 684
  goto switch_break___0;
  case_101: /* CIL Label */ 
#line 687
  tEmPcast___88 = (AST_generic )n;
#line 687
  if (tEmPcast___88) {
#line 687
    if ((unsigned int )tEmPcast___88->kind >= 101U) {
#line 687
      if (! ((unsigned int )tEmPcast___88->kind <= 101U)) {
        {
#line 687
        __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 687U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 687
      __assert_fail("((tEmPcast)->kind >= kind_address_of && (tEmPcast)->kind <= postkind_address_of)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 687U,
                    "AST_print1");
      }
    }
  }
  {
#line 687
  x___88 = (address_of )tEmPcast___88;
#line 689
  puts("address_of");
#line 690
  pindent(indent);
#line 690
  puts("arg1:");
#line 690
  AST_print_list(indent + 1, (void *)x___88->arg1);
  }
#line 691
  goto switch_break___0;
  case_102: /* CIL Label */ 
#line 694
  tEmPcast___89 = (AST_generic )n;
#line 694
  if (tEmPcast___89) {
#line 694
    if ((unsigned int )tEmPcast___89->kind >= 102U) {
#line 694
      if (! ((unsigned int )tEmPcast___89->kind <= 102U)) {
        {
#line 694
        __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 694U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 694
      __assert_fail("((tEmPcast)->kind >= kind_unary_minus && (tEmPcast)->kind <= postkind_unary_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 694U,
                    "AST_print1");
      }
    }
  }
  {
#line 694
  x___89 = (unary_minus )tEmPcast___89;
#line 696
  puts("unary_minus");
#line 697
  pindent(indent);
#line 697
  puts("arg1:");
#line 697
  AST_print_list(indent + 1, (void *)x___89->arg1);
  }
#line 698
  goto switch_break___0;
  case_103: /* CIL Label */ 
#line 701
  tEmPcast___90 = (AST_generic )n;
#line 701
  if (tEmPcast___90) {
#line 701
    if ((unsigned int )tEmPcast___90->kind >= 103U) {
#line 701
      if (! ((unsigned int )tEmPcast___90->kind <= 103U)) {
        {
#line 701
        __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 701U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 701
      __assert_fail("((tEmPcast)->kind >= kind_unary_plus && (tEmPcast)->kind <= postkind_unary_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 701U,
                    "AST_print1");
      }
    }
  }
  {
#line 701
  x___90 = (unary_plus )tEmPcast___90;
#line 703
  puts("unary_plus");
#line 704
  pindent(indent);
#line 704
  puts("arg1:");
#line 704
  AST_print_list(indent + 1, (void *)x___90->arg1);
  }
#line 705
  goto switch_break___0;
  case_104: /* CIL Label */ 
#line 708
  tEmPcast___91 = (AST_generic )n;
#line 708
  if (tEmPcast___91) {
#line 708
    if ((unsigned int )tEmPcast___91->kind >= 104U) {
#line 708
      if (! ((unsigned int )tEmPcast___91->kind <= 104U)) {
        {
#line 708
        __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 708U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 708
      __assert_fail("((tEmPcast)->kind >= kind_conjugate && (tEmPcast)->kind <= postkind_conjugate)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 708U,
                    "AST_print1");
      }
    }
  }
  {
#line 708
  x___91 = (conjugate )tEmPcast___91;
#line 710
  puts("conjugate");
#line 711
  pindent(indent);
#line 711
  puts("arg1:");
#line 711
  AST_print_list(indent + 1, (void *)x___91->arg1);
  }
#line 712
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 715
  tEmPcast___92 = (AST_generic )n;
#line 715
  if (tEmPcast___92) {
#line 715
    if ((unsigned int )tEmPcast___92->kind >= 105U) {
#line 715
      if (! ((unsigned int )tEmPcast___92->kind <= 105U)) {
        {
#line 715
        __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 715U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 715
      __assert_fail("((tEmPcast)->kind >= kind_bitnot && (tEmPcast)->kind <= postkind_bitnot)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 715U,
                    "AST_print1");
      }
    }
  }
  {
#line 715
  x___92 = (bitnot )tEmPcast___92;
#line 717
  puts("bitnot");
#line 718
  pindent(indent);
#line 718
  puts("arg1:");
#line 718
  AST_print_list(indent + 1, (void *)x___92->arg1);
  }
#line 719
  goto switch_break___0;
  case_106: /* CIL Label */ 
#line 722
  tEmPcast___93 = (AST_generic )n;
#line 722
  if (tEmPcast___93) {
#line 722
    if ((unsigned int )tEmPcast___93->kind >= 106U) {
#line 722
      if (! ((unsigned int )tEmPcast___93->kind <= 106U)) {
        {
#line 722
        __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 722U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 722
      __assert_fail("((tEmPcast)->kind >= kind_not && (tEmPcast)->kind <= postkind_not)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 722U,
                    "AST_print1");
      }
    }
  }
  {
#line 722
  x___93 = (not )tEmPcast___93;
#line 724
  puts("not");
#line 725
  pindent(indent);
#line 725
  puts("arg1:");
#line 725
  AST_print_list(indent + 1, (void *)x___93->arg1);
  }
#line 726
  goto switch_break___0;
  case_89: /* CIL Label */ 
#line 729
  tEmPcast___94 = (AST_generic )n;
#line 729
  if (tEmPcast___94) {
#line 729
    if ((unsigned int )tEmPcast___94->kind >= 89U) {
#line 729
      if (! ((unsigned int )tEmPcast___94->kind <= 89U)) {
        {
#line 729
        __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 729U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 729
      __assert_fail("((tEmPcast)->kind >= kind_preincrement && (tEmPcast)->kind <= postkind_preincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 729U,
                    "AST_print1");
      }
    }
  }
  {
#line 729
  x___94 = (preincrement )tEmPcast___94;
#line 731
  puts("preincrement");
#line 732
  pindent(indent);
#line 732
  puts("arg1:");
#line 732
  AST_print_list(indent + 1, (void *)x___94->arg1);
  }
#line 733
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 736
  tEmPcast___95 = (AST_generic )n;
#line 736
  if (tEmPcast___95) {
#line 736
    if ((unsigned int )tEmPcast___95->kind >= 90U) {
#line 736
      if (! ((unsigned int )tEmPcast___95->kind <= 90U)) {
        {
#line 736
        __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 736U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 736
      __assert_fail("((tEmPcast)->kind >= kind_predecrement && (tEmPcast)->kind <= postkind_predecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 736U,
                    "AST_print1");
      }
    }
  }
  {
#line 736
  x___95 = (predecrement )tEmPcast___95;
#line 738
  puts("predecrement");
#line 739
  pindent(indent);
#line 739
  puts("arg1:");
#line 739
  AST_print_list(indent + 1, (void *)x___95->arg1);
  }
#line 740
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 743
  tEmPcast___96 = (AST_generic )n;
#line 743
  if (tEmPcast___96) {
#line 743
    if ((unsigned int )tEmPcast___96->kind >= 91U) {
#line 743
      if (! ((unsigned int )tEmPcast___96->kind <= 91U)) {
        {
#line 743
        __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 743U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 743
      __assert_fail("((tEmPcast)->kind >= kind_postincrement && (tEmPcast)->kind <= postkind_postincrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 743U,
                    "AST_print1");
      }
    }
  }
  {
#line 743
  x___96 = (postincrement )tEmPcast___96;
#line 745
  puts("postincrement");
#line 746
  pindent(indent);
#line 746
  puts("arg1:");
#line 746
  AST_print_list(indent + 1, (void *)x___96->arg1);
  }
#line 747
  goto switch_break___0;
  case_92: /* CIL Label */ 
#line 750
  tEmPcast___97 = (AST_generic )n;
#line 750
  if (tEmPcast___97) {
#line 750
    if ((unsigned int )tEmPcast___97->kind >= 92U) {
#line 750
      if (! ((unsigned int )tEmPcast___97->kind <= 92U)) {
        {
#line 750
        __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 750U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 750
      __assert_fail("((tEmPcast)->kind >= kind_postdecrement && (tEmPcast)->kind <= postkind_postdecrement)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 750U,
                    "AST_print1");
      }
    }
  }
  {
#line 750
  x___97 = (postdecrement )tEmPcast___97;
#line 752
  puts("postdecrement");
#line 753
  pindent(indent);
#line 753
  puts("arg1:");
#line 753
  AST_print_list(indent + 1, (void *)x___97->arg1);
  }
#line 754
  goto switch_break___0;
  case_128: /* CIL Label */ 
#line 757
  tEmPcast___98 = (AST_generic )n;
#line 757
  if (tEmPcast___98) {
#line 757
    if ((unsigned int )tEmPcast___98->kind >= 128U) {
#line 757
      if (! ((unsigned int )tEmPcast___98->kind <= 128U)) {
        {
#line 757
        __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 757U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 757
      __assert_fail("((tEmPcast)->kind >= kind_plus && (tEmPcast)->kind <= postkind_plus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 757U,
                    "AST_print1");
      }
    }
  }
  {
#line 757
  x___98 = (plus )tEmPcast___98;
#line 759
  puts("plus");
#line 760
  pindent(indent);
#line 760
  puts("arg1:");
#line 760
  AST_print_list(indent + 1, (void *)x___98->arg1);
#line 761
  pindent(indent);
#line 761
  puts("arg2:");
#line 761
  AST_print_list(indent + 1, (void *)x___98->arg2);
  }
#line 762
  goto switch_break___0;
  case_129: /* CIL Label */ 
#line 765
  tEmPcast___99 = (AST_generic )n;
#line 765
  if (tEmPcast___99) {
#line 765
    if ((unsigned int )tEmPcast___99->kind >= 129U) {
#line 765
      if (! ((unsigned int )tEmPcast___99->kind <= 129U)) {
        {
#line 765
        __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 765U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 765
      __assert_fail("((tEmPcast)->kind >= kind_minus && (tEmPcast)->kind <= postkind_minus)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 765U,
                    "AST_print1");
      }
    }
  }
  {
#line 765
  x___99 = (minus )tEmPcast___99;
#line 767
  puts("minus");
#line 768
  pindent(indent);
#line 768
  puts("arg1:");
#line 768
  AST_print_list(indent + 1, (void *)x___99->arg1);
#line 769
  pindent(indent);
#line 769
  puts("arg2:");
#line 769
  AST_print_list(indent + 1, (void *)x___99->arg2);
  }
#line 770
  goto switch_break___0;
  case_130: /* CIL Label */ 
#line 773
  tEmPcast___100 = (AST_generic )n;
#line 773
  if (tEmPcast___100) {
#line 773
    if ((unsigned int )tEmPcast___100->kind >= 130U) {
#line 773
      if (! ((unsigned int )tEmPcast___100->kind <= 130U)) {
        {
#line 773
        __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 773U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 773
      __assert_fail("((tEmPcast)->kind >= kind_times && (tEmPcast)->kind <= postkind_times)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 773U,
                    "AST_print1");
      }
    }
  }
  {
#line 773
  x___100 = (times )tEmPcast___100;
#line 775
  puts("times");
#line 776
  pindent(indent);
#line 776
  puts("arg1:");
#line 776
  AST_print_list(indent + 1, (void *)x___100->arg1);
#line 777
  pindent(indent);
#line 777
  puts("arg2:");
#line 777
  AST_print_list(indent + 1, (void *)x___100->arg2);
  }
#line 778
  goto switch_break___0;
  case_131: /* CIL Label */ 
#line 781
  tEmPcast___101 = (AST_generic )n;
#line 781
  if (tEmPcast___101) {
#line 781
    if ((unsigned int )tEmPcast___101->kind >= 131U) {
#line 781
      if (! ((unsigned int )tEmPcast___101->kind <= 131U)) {
        {
#line 781
        __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 781U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 781
      __assert_fail("((tEmPcast)->kind >= kind_divide && (tEmPcast)->kind <= postkind_divide)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 781U,
                    "AST_print1");
      }
    }
  }
  {
#line 781
  x___101 = (divide )tEmPcast___101;
#line 783
  puts("divide");
#line 784
  pindent(indent);
#line 784
  puts("arg1:");
#line 784
  AST_print_list(indent + 1, (void *)x___101->arg1);
#line 785
  pindent(indent);
#line 785
  puts("arg2:");
#line 785
  AST_print_list(indent + 1, (void *)x___101->arg2);
  }
#line 786
  goto switch_break___0;
  case_132: /* CIL Label */ 
#line 789
  tEmPcast___102 = (AST_generic )n;
#line 789
  if (tEmPcast___102) {
#line 789
    if ((unsigned int )tEmPcast___102->kind >= 132U) {
#line 789
      if (! ((unsigned int )tEmPcast___102->kind <= 132U)) {
        {
#line 789
        __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 789U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 789
      __assert_fail("((tEmPcast)->kind >= kind_modulo && (tEmPcast)->kind <= postkind_modulo)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 789U,
                    "AST_print1");
      }
    }
  }
  {
#line 789
  x___102 = (modulo )tEmPcast___102;
#line 791
  puts("modulo");
#line 792
  pindent(indent);
#line 792
  puts("arg1:");
#line 792
  AST_print_list(indent + 1, (void *)x___102->arg1);
#line 793
  pindent(indent);
#line 793
  puts("arg2:");
#line 793
  AST_print_list(indent + 1, (void *)x___102->arg2);
  }
#line 794
  goto switch_break___0;
  case_133: /* CIL Label */ 
#line 797
  tEmPcast___103 = (AST_generic )n;
#line 797
  if (tEmPcast___103) {
#line 797
    if ((unsigned int )tEmPcast___103->kind >= 133U) {
#line 797
      if (! ((unsigned int )tEmPcast___103->kind <= 133U)) {
        {
#line 797
        __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 797U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 797
      __assert_fail("((tEmPcast)->kind >= kind_lshift && (tEmPcast)->kind <= postkind_lshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 797U,
                    "AST_print1");
      }
    }
  }
  {
#line 797
  x___103 = (lshift )tEmPcast___103;
#line 799
  puts("lshift");
#line 800
  pindent(indent);
#line 800
  puts("arg1:");
#line 800
  AST_print_list(indent + 1, (void *)x___103->arg1);
#line 801
  pindent(indent);
#line 801
  puts("arg2:");
#line 801
  AST_print_list(indent + 1, (void *)x___103->arg2);
  }
#line 802
  goto switch_break___0;
  case_134: /* CIL Label */ 
#line 805
  tEmPcast___104 = (AST_generic )n;
#line 805
  if (tEmPcast___104) {
#line 805
    if ((unsigned int )tEmPcast___104->kind >= 134U) {
#line 805
      if (! ((unsigned int )tEmPcast___104->kind <= 134U)) {
        {
#line 805
        __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 805U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 805
      __assert_fail("((tEmPcast)->kind >= kind_rshift && (tEmPcast)->kind <= postkind_rshift)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 805U,
                    "AST_print1");
      }
    }
  }
  {
#line 805
  x___104 = (rshift )tEmPcast___104;
#line 807
  puts("rshift");
#line 808
  pindent(indent);
#line 808
  puts("arg1:");
#line 808
  AST_print_list(indent + 1, (void *)x___104->arg1);
#line 809
  pindent(indent);
#line 809
  puts("arg2:");
#line 809
  AST_print_list(indent + 1, (void *)x___104->arg2);
  }
#line 810
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 813
  tEmPcast___105 = (AST_generic )n;
#line 813
  if (tEmPcast___105) {
#line 813
    if ((unsigned int )tEmPcast___105->kind >= 109U) {
#line 813
      if (! ((unsigned int )tEmPcast___105->kind <= 109U)) {
        {
#line 813
        __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 813U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 813
      __assert_fail("((tEmPcast)->kind >= kind_leq && (tEmPcast)->kind <= postkind_leq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 813U,
                    "AST_print1");
      }
    }
  }
  {
#line 813
  x___105 = (leq )tEmPcast___105;
#line 815
  puts("leq");
#line 816
  pindent(indent);
#line 816
  puts("arg1:");
#line 816
  AST_print_list(indent + 1, (void *)x___105->arg1);
#line 817
  pindent(indent);
#line 817
  puts("arg2:");
#line 817
  AST_print_list(indent + 1, (void *)x___105->arg2);
  }
#line 818
  goto switch_break___0;
  case_110: /* CIL Label */ 
#line 821
  tEmPcast___106 = (AST_generic )n;
#line 821
  if (tEmPcast___106) {
#line 821
    if ((unsigned int )tEmPcast___106->kind >= 110U) {
#line 821
      if (! ((unsigned int )tEmPcast___106->kind <= 110U)) {
        {
#line 821
        __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 821U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 821
      __assert_fail("((tEmPcast)->kind >= kind_geq && (tEmPcast)->kind <= postkind_geq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 821U,
                    "AST_print1");
      }
    }
  }
  {
#line 821
  x___106 = (geq )tEmPcast___106;
#line 823
  puts("geq");
#line 824
  pindent(indent);
#line 824
  puts("arg1:");
#line 824
  AST_print_list(indent + 1, (void *)x___106->arg1);
#line 825
  pindent(indent);
#line 825
  puts("arg2:");
#line 825
  AST_print_list(indent + 1, (void *)x___106->arg2);
  }
#line 826
  goto switch_break___0;
  case_111: /* CIL Label */ 
#line 829
  tEmPcast___107 = (AST_generic )n;
#line 829
  if (tEmPcast___107) {
#line 829
    if ((unsigned int )tEmPcast___107->kind >= 111U) {
#line 829
      if (! ((unsigned int )tEmPcast___107->kind <= 111U)) {
        {
#line 829
        __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 829U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 829
      __assert_fail("((tEmPcast)->kind >= kind_lt && (tEmPcast)->kind <= postkind_lt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 829U,
                    "AST_print1");
      }
    }
  }
  {
#line 829
  x___107 = (lt )tEmPcast___107;
#line 831
  puts("lt");
#line 832
  pindent(indent);
#line 832
  puts("arg1:");
#line 832
  AST_print_list(indent + 1, (void *)x___107->arg1);
#line 833
  pindent(indent);
#line 833
  puts("arg2:");
#line 833
  AST_print_list(indent + 1, (void *)x___107->arg2);
  }
#line 834
  goto switch_break___0;
  case_112: /* CIL Label */ 
#line 837
  tEmPcast___108 = (AST_generic )n;
#line 837
  if (tEmPcast___108) {
#line 837
    if ((unsigned int )tEmPcast___108->kind >= 112U) {
#line 837
      if (! ((unsigned int )tEmPcast___108->kind <= 112U)) {
        {
#line 837
        __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 837U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 837
      __assert_fail("((tEmPcast)->kind >= kind_gt && (tEmPcast)->kind <= postkind_gt)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 837U,
                    "AST_print1");
      }
    }
  }
  {
#line 837
  x___108 = (gt )tEmPcast___108;
#line 839
  puts("gt");
#line 840
  pindent(indent);
#line 840
  puts("arg1:");
#line 840
  AST_print_list(indent + 1, (void *)x___108->arg1);
#line 841
  pindent(indent);
#line 841
  puts("arg2:");
#line 841
  AST_print_list(indent + 1, (void *)x___108->arg2);
  }
#line 842
  goto switch_break___0;
  case_113: /* CIL Label */ 
#line 845
  tEmPcast___109 = (AST_generic )n;
#line 845
  if (tEmPcast___109) {
#line 845
    if ((unsigned int )tEmPcast___109->kind >= 113U) {
#line 845
      if (! ((unsigned int )tEmPcast___109->kind <= 113U)) {
        {
#line 845
        __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 845U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 845
      __assert_fail("((tEmPcast)->kind >= kind_eq && (tEmPcast)->kind <= postkind_eq)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 845U,
                    "AST_print1");
      }
    }
  }
  {
#line 845
  x___109 = (eq )tEmPcast___109;
#line 847
  puts("eq");
#line 848
  pindent(indent);
#line 848
  puts("arg1:");
#line 848
  AST_print_list(indent + 1, (void *)x___109->arg1);
#line 849
  pindent(indent);
#line 849
  puts("arg2:");
#line 849
  AST_print_list(indent + 1, (void *)x___109->arg2);
  }
#line 850
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 853
  tEmPcast___110 = (AST_generic )n;
#line 853
  if (tEmPcast___110) {
#line 853
    if ((unsigned int )tEmPcast___110->kind >= 114U) {
#line 853
      if (! ((unsigned int )tEmPcast___110->kind <= 114U)) {
        {
#line 853
        __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 853U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 853
      __assert_fail("((tEmPcast)->kind >= kind_ne && (tEmPcast)->kind <= postkind_ne)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 853U,
                    "AST_print1");
      }
    }
  }
  {
#line 853
  x___110 = (ne )tEmPcast___110;
#line 855
  puts("ne");
#line 856
  pindent(indent);
#line 856
  puts("arg1:");
#line 856
  AST_print_list(indent + 1, (void *)x___110->arg1);
#line 857
  pindent(indent);
#line 857
  puts("arg2:");
#line 857
  AST_print_list(indent + 1, (void *)x___110->arg2);
  }
#line 858
  goto switch_break___0;
  case_135: /* CIL Label */ 
#line 861
  tEmPcast___111 = (AST_generic )n;
#line 861
  if (tEmPcast___111) {
#line 861
    if ((unsigned int )tEmPcast___111->kind >= 135U) {
#line 861
      if (! ((unsigned int )tEmPcast___111->kind <= 135U)) {
        {
#line 861
        __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 861U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 861
      __assert_fail("((tEmPcast)->kind >= kind_bitand && (tEmPcast)->kind <= postkind_bitand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 861U,
                    "AST_print1");
      }
    }
  }
  {
#line 861
  x___111 = (bitand )tEmPcast___111;
#line 863
  puts("bitand");
#line 864
  pindent(indent);
#line 864
  puts("arg1:");
#line 864
  AST_print_list(indent + 1, (void *)x___111->arg1);
#line 865
  pindent(indent);
#line 865
  puts("arg2:");
#line 865
  AST_print_list(indent + 1, (void *)x___111->arg2);
  }
#line 866
  goto switch_break___0;
  case_136: /* CIL Label */ 
#line 869
  tEmPcast___112 = (AST_generic )n;
#line 869
  if (tEmPcast___112) {
#line 869
    if ((unsigned int )tEmPcast___112->kind >= 136U) {
#line 869
      if (! ((unsigned int )tEmPcast___112->kind <= 136U)) {
        {
#line 869
        __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 869U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 869
      __assert_fail("((tEmPcast)->kind >= kind_bitor && (tEmPcast)->kind <= postkind_bitor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 869U,
                    "AST_print1");
      }
    }
  }
  {
#line 869
  x___112 = (bitor )tEmPcast___112;
#line 871
  puts("bitor");
#line 872
  pindent(indent);
#line 872
  puts("arg1:");
#line 872
  AST_print_list(indent + 1, (void *)x___112->arg1);
#line 873
  pindent(indent);
#line 873
  puts("arg2:");
#line 873
  AST_print_list(indent + 1, (void *)x___112->arg2);
  }
#line 874
  goto switch_break___0;
  case_137: /* CIL Label */ 
#line 877
  tEmPcast___113 = (AST_generic )n;
#line 877
  if (tEmPcast___113) {
#line 877
    if ((unsigned int )tEmPcast___113->kind >= 137U) {
#line 877
      if (! ((unsigned int )tEmPcast___113->kind <= 137U)) {
        {
#line 877
        __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 877U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 877
      __assert_fail("((tEmPcast)->kind >= kind_bitxor && (tEmPcast)->kind <= postkind_bitxor)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 877U,
                    "AST_print1");
      }
    }
  }
  {
#line 877
  x___113 = (bitxor )tEmPcast___113;
#line 879
  puts("bitxor");
#line 880
  pindent(indent);
#line 880
  puts("arg1:");
#line 880
  AST_print_list(indent + 1, (void *)x___113->arg1);
#line 881
  pindent(indent);
#line 881
  puts("arg2:");
#line 881
  AST_print_list(indent + 1, (void *)x___113->arg2);
  }
#line 882
  goto switch_break___0;
  case_138: /* CIL Label */ 
#line 885
  tEmPcast___114 = (AST_generic )n;
#line 885
  if (tEmPcast___114) {
#line 885
    if ((unsigned int )tEmPcast___114->kind >= 138U) {
#line 885
      if (! ((unsigned int )tEmPcast___114->kind <= 138U)) {
        {
#line 885
        __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 885U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 885
      __assert_fail("((tEmPcast)->kind >= kind_andand && (tEmPcast)->kind <= postkind_andand)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 885U,
                    "AST_print1");
      }
    }
  }
  {
#line 885
  x___114 = (andand )tEmPcast___114;
#line 887
  puts("andand");
#line 888
  pindent(indent);
#line 888
  puts("arg1:");
#line 888
  AST_print_list(indent + 1, (void *)x___114->arg1);
#line 889
  pindent(indent);
#line 889
  puts("arg2:");
#line 889
  AST_print_list(indent + 1, (void *)x___114->arg2);
  }
#line 890
  goto switch_break___0;
  case_139: /* CIL Label */ 
#line 893
  tEmPcast___115 = (AST_generic )n;
#line 893
  if (tEmPcast___115) {
#line 893
    if ((unsigned int )tEmPcast___115->kind >= 139U) {
#line 893
      if (! ((unsigned int )tEmPcast___115->kind <= 139U)) {
        {
#line 893
        __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 893U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 893
      __assert_fail("((tEmPcast)->kind >= kind_oror && (tEmPcast)->kind <= postkind_oror)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 893U,
                    "AST_print1");
      }
    }
  }
  {
#line 893
  x___115 = (oror )tEmPcast___115;
#line 895
  puts("oror");
#line 896
  pindent(indent);
#line 896
  puts("arg1:");
#line 896
  AST_print_list(indent + 1, (void *)x___115->arg1);
#line 897
  pindent(indent);
#line 897
  puts("arg2:");
#line 897
  AST_print_list(indent + 1, (void *)x___115->arg2);
  }
#line 898
  goto switch_break___0;
  case_116: /* CIL Label */ 
#line 901
  tEmPcast___116 = (AST_generic )n;
#line 901
  if (tEmPcast___116) {
#line 901
    if ((unsigned int )tEmPcast___116->kind >= 116U) {
#line 901
      if (! ((unsigned int )tEmPcast___116->kind <= 116U)) {
        {
#line 901
        __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 901U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 901
      __assert_fail("((tEmPcast)->kind >= kind_assign && (tEmPcast)->kind <= postkind_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 901U,
                    "AST_print1");
      }
    }
  }
  {
#line 901
  x___116 = (assign )tEmPcast___116;
#line 903
  puts("assign");
#line 904
  pindent(indent);
#line 904
  puts("arg1:");
#line 904
  AST_print_list(indent + 1, (void *)x___116->arg1);
#line 905
  pindent(indent);
#line 905
  puts("arg2:");
#line 905
  AST_print_list(indent + 1, (void *)x___116->arg2);
  }
#line 906
  goto switch_break___0;
  case_117: /* CIL Label */ 
#line 909
  tEmPcast___117 = (AST_generic )n;
#line 909
  if (tEmPcast___117) {
#line 909
    if ((unsigned int )tEmPcast___117->kind >= 117U) {
#line 909
      if (! ((unsigned int )tEmPcast___117->kind <= 117U)) {
        {
#line 909
        __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 909U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 909
      __assert_fail("((tEmPcast)->kind >= kind_plus_assign && (tEmPcast)->kind <= postkind_plus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 909U,
                    "AST_print1");
      }
    }
  }
  {
#line 909
  x___117 = (plus_assign )tEmPcast___117;
#line 911
  puts("plus_assign");
#line 912
  pindent(indent);
#line 912
  puts("arg1:");
#line 912
  AST_print_list(indent + 1, (void *)x___117->arg1);
#line 913
  pindent(indent);
#line 913
  puts("arg2:");
#line 913
  AST_print_list(indent + 1, (void *)x___117->arg2);
  }
#line 914
  goto switch_break___0;
  case_118: /* CIL Label */ 
#line 917
  tEmPcast___118 = (AST_generic )n;
#line 917
  if (tEmPcast___118) {
#line 917
    if ((unsigned int )tEmPcast___118->kind >= 118U) {
#line 917
      if (! ((unsigned int )tEmPcast___118->kind <= 118U)) {
        {
#line 917
        __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 917U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 917
      __assert_fail("((tEmPcast)->kind >= kind_minus_assign && (tEmPcast)->kind <= postkind_minus_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 917U,
                    "AST_print1");
      }
    }
  }
  {
#line 917
  x___118 = (minus_assign )tEmPcast___118;
#line 919
  puts("minus_assign");
#line 920
  pindent(indent);
#line 920
  puts("arg1:");
#line 920
  AST_print_list(indent + 1, (void *)x___118->arg1);
#line 921
  pindent(indent);
#line 921
  puts("arg2:");
#line 921
  AST_print_list(indent + 1, (void *)x___118->arg2);
  }
#line 922
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 925
  tEmPcast___119 = (AST_generic )n;
#line 925
  if (tEmPcast___119) {
#line 925
    if ((unsigned int )tEmPcast___119->kind >= 119U) {
#line 925
      if (! ((unsigned int )tEmPcast___119->kind <= 119U)) {
        {
#line 925
        __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 925U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 925
      __assert_fail("((tEmPcast)->kind >= kind_times_assign && (tEmPcast)->kind <= postkind_times_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 925U,
                    "AST_print1");
      }
    }
  }
  {
#line 925
  x___119 = (times_assign )tEmPcast___119;
#line 927
  puts("times_assign");
#line 928
  pindent(indent);
#line 928
  puts("arg1:");
#line 928
  AST_print_list(indent + 1, (void *)x___119->arg1);
#line 929
  pindent(indent);
#line 929
  puts("arg2:");
#line 929
  AST_print_list(indent + 1, (void *)x___119->arg2);
  }
#line 930
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 933
  tEmPcast___120 = (AST_generic )n;
#line 933
  if (tEmPcast___120) {
#line 933
    if ((unsigned int )tEmPcast___120->kind >= 120U) {
#line 933
      if (! ((unsigned int )tEmPcast___120->kind <= 120U)) {
        {
#line 933
        __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 933U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 933
      __assert_fail("((tEmPcast)->kind >= kind_divide_assign && (tEmPcast)->kind <= postkind_divide_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 933U,
                    "AST_print1");
      }
    }
  }
  {
#line 933
  x___120 = (divide_assign )tEmPcast___120;
#line 935
  puts("divide_assign");
#line 936
  pindent(indent);
#line 936
  puts("arg1:");
#line 936
  AST_print_list(indent + 1, (void *)x___120->arg1);
#line 937
  pindent(indent);
#line 937
  puts("arg2:");
#line 937
  AST_print_list(indent + 1, (void *)x___120->arg2);
  }
#line 938
  goto switch_break___0;
  case_121: /* CIL Label */ 
#line 941
  tEmPcast___121 = (AST_generic )n;
#line 941
  if (tEmPcast___121) {
#line 941
    if ((unsigned int )tEmPcast___121->kind >= 121U) {
#line 941
      if (! ((unsigned int )tEmPcast___121->kind <= 121U)) {
        {
#line 941
        __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 941U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 941
      __assert_fail("((tEmPcast)->kind >= kind_modulo_assign && (tEmPcast)->kind <= postkind_modulo_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 941U,
                    "AST_print1");
      }
    }
  }
  {
#line 941
  x___121 = (modulo_assign )tEmPcast___121;
#line 943
  puts("modulo_assign");
#line 944
  pindent(indent);
#line 944
  puts("arg1:");
#line 944
  AST_print_list(indent + 1, (void *)x___121->arg1);
#line 945
  pindent(indent);
#line 945
  puts("arg2:");
#line 945
  AST_print_list(indent + 1, (void *)x___121->arg2);
  }
#line 946
  goto switch_break___0;
  case_122: /* CIL Label */ 
#line 949
  tEmPcast___122 = (AST_generic )n;
#line 949
  if (tEmPcast___122) {
#line 949
    if ((unsigned int )tEmPcast___122->kind >= 122U) {
#line 949
      if (! ((unsigned int )tEmPcast___122->kind <= 122U)) {
        {
#line 949
        __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 949U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 949
      __assert_fail("((tEmPcast)->kind >= kind_lshift_assign && (tEmPcast)->kind <= postkind_lshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 949U,
                    "AST_print1");
      }
    }
  }
  {
#line 949
  x___122 = (lshift_assign )tEmPcast___122;
#line 951
  puts("lshift_assign");
#line 952
  pindent(indent);
#line 952
  puts("arg1:");
#line 952
  AST_print_list(indent + 1, (void *)x___122->arg1);
#line 953
  pindent(indent);
#line 953
  puts("arg2:");
#line 953
  AST_print_list(indent + 1, (void *)x___122->arg2);
  }
#line 954
  goto switch_break___0;
  case_123: /* CIL Label */ 
#line 957
  tEmPcast___123 = (AST_generic )n;
#line 957
  if (tEmPcast___123) {
#line 957
    if ((unsigned int )tEmPcast___123->kind >= 123U) {
#line 957
      if (! ((unsigned int )tEmPcast___123->kind <= 123U)) {
        {
#line 957
        __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 957U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 957
      __assert_fail("((tEmPcast)->kind >= kind_rshift_assign && (tEmPcast)->kind <= postkind_rshift_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 957U,
                    "AST_print1");
      }
    }
  }
  {
#line 957
  x___123 = (rshift_assign )tEmPcast___123;
#line 959
  puts("rshift_assign");
#line 960
  pindent(indent);
#line 960
  puts("arg1:");
#line 960
  AST_print_list(indent + 1, (void *)x___123->arg1);
#line 961
  pindent(indent);
#line 961
  puts("arg2:");
#line 961
  AST_print_list(indent + 1, (void *)x___123->arg2);
  }
#line 962
  goto switch_break___0;
  case_124: /* CIL Label */ 
#line 965
  tEmPcast___124 = (AST_generic )n;
#line 965
  if (tEmPcast___124) {
#line 965
    if ((unsigned int )tEmPcast___124->kind >= 124U) {
#line 965
      if (! ((unsigned int )tEmPcast___124->kind <= 124U)) {
        {
#line 965
        __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 965U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 965
      __assert_fail("((tEmPcast)->kind >= kind_bitand_assign && (tEmPcast)->kind <= postkind_bitand_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 965U,
                    "AST_print1");
      }
    }
  }
  {
#line 965
  x___124 = (bitand_assign )tEmPcast___124;
#line 967
  puts("bitand_assign");
#line 968
  pindent(indent);
#line 968
  puts("arg1:");
#line 968
  AST_print_list(indent + 1, (void *)x___124->arg1);
#line 969
  pindent(indent);
#line 969
  puts("arg2:");
#line 969
  AST_print_list(indent + 1, (void *)x___124->arg2);
  }
#line 970
  goto switch_break___0;
  case_125: /* CIL Label */ 
#line 973
  tEmPcast___125 = (AST_generic )n;
#line 973
  if (tEmPcast___125) {
#line 973
    if ((unsigned int )tEmPcast___125->kind >= 125U) {
#line 973
      if (! ((unsigned int )tEmPcast___125->kind <= 125U)) {
        {
#line 973
        __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 973U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 973
      __assert_fail("((tEmPcast)->kind >= kind_bitor_assign && (tEmPcast)->kind <= postkind_bitor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 973U,
                    "AST_print1");
      }
    }
  }
  {
#line 973
  x___125 = (bitor_assign )tEmPcast___125;
#line 975
  puts("bitor_assign");
#line 976
  pindent(indent);
#line 976
  puts("arg1:");
#line 976
  AST_print_list(indent + 1, (void *)x___125->arg1);
#line 977
  pindent(indent);
#line 977
  puts("arg2:");
#line 977
  AST_print_list(indent + 1, (void *)x___125->arg2);
  }
#line 978
  goto switch_break___0;
  case_126: /* CIL Label */ 
#line 981
  tEmPcast___126 = (AST_generic )n;
#line 981
  if (tEmPcast___126) {
#line 981
    if ((unsigned int )tEmPcast___126->kind >= 126U) {
#line 981
      if (! ((unsigned int )tEmPcast___126->kind <= 126U)) {
        {
#line 981
        __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 981U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 981
      __assert_fail("((tEmPcast)->kind >= kind_bitxor_assign && (tEmPcast)->kind <= postkind_bitxor_assign)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 981U,
                    "AST_print1");
      }
    }
  }
  {
#line 981
  x___126 = (bitxor_assign )tEmPcast___126;
#line 983
  puts("bitxor_assign");
#line 984
  pindent(indent);
#line 984
  puts("arg1:");
#line 984
  AST_print_list(indent + 1, (void *)x___126->arg1);
#line 985
  pindent(indent);
#line 985
  puts("arg2:");
#line 985
  AST_print_list(indent + 1, (void *)x___126->arg2);
  }
#line 986
  goto switch_break___0;
  case_61: /* CIL Label */ 
#line 989
  tEmPcast___127 = (AST_generic )n;
#line 989
  if (tEmPcast___127) {
#line 989
    if ((unsigned int )tEmPcast___127->kind >= 61U) {
#line 989
      if (! ((unsigned int )tEmPcast___127->kind <= 61U)) {
        {
#line 989
        __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 989U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 989
      __assert_fail("((tEmPcast)->kind >= kind_rp_connection && (tEmPcast)->kind <= postkind_rp_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 989U,
                    "AST_print1");
      }
    }
  }
  {
#line 989
  x___127 = (rp_connection )tEmPcast___127;
#line 991
  puts("rp_connection");
#line 992
  pindent(indent);
#line 992
  puts("ep1:");
#line 992
  AST_print_list(indent + 1, (void *)x___127->ep1);
#line 993
  pindent(indent);
#line 993
  puts("ep2:");
#line 993
  AST_print_list(indent + 1, (void *)x___127->ep2);
  }
#line 994
  goto switch_break___0;
  case_62: /* CIL Label */ 
#line 997
  tEmPcast___128 = (AST_generic )n;
#line 997
  if (tEmPcast___128) {
#line 997
    if ((unsigned int )tEmPcast___128->kind >= 62U) {
#line 997
      if (! ((unsigned int )tEmPcast___128->kind <= 62U)) {
        {
#line 997
        __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 997U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 997
      __assert_fail("((tEmPcast)->kind >= kind_eq_connection && (tEmPcast)->kind <= postkind_eq_connection)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 997U,
                    "AST_print1");
      }
    }
  }
  {
#line 997
  x___128 = (eq_connection )tEmPcast___128;
#line 999
  puts("eq_connection");
#line 1000
  pindent(indent);
#line 1000
  puts("ep1:");
#line 1000
  AST_print_list(indent + 1, (void *)x___128->ep1);
#line 1001
  pindent(indent);
#line 1001
  puts("ep2:");
#line 1001
  AST_print_list(indent + 1, (void *)x___128->ep2);
  }
#line 1002
  goto switch_break___0;
  case_170: /* CIL Label */ 
#line 1005
  tEmPcast___129 = (AST_generic )n;
#line 1005
  if (tEmPcast___129) {
#line 1005
    if ((unsigned int )tEmPcast___129->kind >= 170U) {
#line 1005
      if (! ((unsigned int )tEmPcast___129->kind <= 170U)) {
        {
#line 1005
        __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1005U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 1005
      __assert_fail("((tEmPcast)->kind >= kind_nx_struct_ref && (tEmPcast)->kind <= postkind_nx_struct_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1005U,
                    "AST_print1");
      }
    }
  }
  {
#line 1005
  x___129 = (nx_struct_ref )tEmPcast___129;
#line 1007
  puts("nx_struct_ref");
#line 1008
  pindent(indent);
#line 1008
  puts("word1:");
#line 1008
  AST_print_list(indent + 1, (void *)x___129->word1);
#line 1009
  pindent(indent);
#line 1009
  puts("attributes:");
#line 1009
  AST_print_list(indent + 1, (void *)x___129->attributes);
#line 1010
  pindent(indent);
#line 1010
  puts("fields:");
#line 1010
  AST_print_list(indent + 1, (void *)x___129->fields);
  }
#line 1011
  goto switch_break___0;
  case_172: /* CIL Label */ 
#line 1014
  tEmPcast___130 = (AST_generic )n;
#line 1014
  if (tEmPcast___130) {
#line 1014
    if ((unsigned int )tEmPcast___130->kind >= 172U) {
#line 1014
      if (! ((unsigned int )tEmPcast___130->kind <= 172U)) {
        {
#line 1014
        __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1014U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 1014
      __assert_fail("((tEmPcast)->kind >= kind_nx_union_ref && (tEmPcast)->kind <= postkind_nx_union_ref)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1014U,
                    "AST_print1");
      }
    }
  }
  {
#line 1014
  x___130 = (nx_union_ref )tEmPcast___130;
#line 1016
  puts("nx_union_ref");
#line 1017
  pindent(indent);
#line 1017
  puts("word1:");
#line 1017
  AST_print_list(indent + 1, (void *)x___130->word1);
#line 1018
  pindent(indent);
#line 1018
  puts("attributes:");
#line 1018
  AST_print_list(indent + 1, (void *)x___130->attributes);
#line 1019
  pindent(indent);
#line 1019
  puts("fields:");
#line 1019
  AST_print_list(indent + 1, (void *)x___130->fields);
  }
#line 1020
  goto switch_break___0;
  case_164: /* CIL Label */ 
#line 1023
  tEmPcast___131 = (AST_generic )n;
#line 1023
  if (tEmPcast___131) {
#line 1023
    if ((unsigned int )tEmPcast___131->kind >= 164U) {
#line 1023
      if (! ((unsigned int )tEmPcast___131->kind <= 164U)) {
        {
#line 1023
        __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1023U,
                      "AST_print1");
        }
      }
    } else {
      {
#line 1023
      __assert_fail("((tEmPcast)->kind >= kind_target_attribute && (tEmPcast)->kind <= postkind_target_attribute)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST_print.c", 1023U,
                    "AST_print1");
      }
    }
  }
  {
#line 1023
  x___131 = (target_attribute )tEmPcast___131;
#line 1025
  puts("target_attribute");
#line 1026
  pindent(indent);
#line 1026
  puts("word1:");
#line 1026
  AST_print_list(indent + 1, (void *)x___131->word1);
#line 1027
  pindent(indent);
#line 1027
  puts("args:");
#line 1027
  AST_print_list(indent + 1, (void *)x___131->args);
  }
#line 1028
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 228 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 228U, "AST_print1");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 232 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
static void AST_print_list(int indent , void *vn ) 
{ 
  node n ;
  AST_generic tEmPcast ;

  {
#line 234
  tEmPcast = (AST_generic )vn;
#line 234
  if (tEmPcast) {
#line 234
    if ((unsigned int )tEmPcast->kind >= 42U) {
#line 234
      if (! ((unsigned int )tEmPcast->kind <= 199U)) {
        {
#line 234
        __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 234U, "AST_print_list");
        }
      }
    } else {
      {
#line 234
      __assert_fail("((tEmPcast)->kind >= kind_node && (tEmPcast)->kind <= postkind_node)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c", 234U, "AST_print_list");
      }
    }
  }
#line 234
  n = (node )tEmPcast;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! n) {
#line 236
      goto while_break;
    }
    {
#line 238
    AST_print1(indent, n);
#line 239
    n = n->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/nescc-1.3.4/src/AST.c"
void AST_print(node n ) 
{ 


  {
  {
#line 245
  fflush(stdout);
#line 246
  AST_print_list(0, (void *)n);
#line 247
  fflush(stdout);
  }
#line 248
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 27 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
char const   *progname  ;
#line 29 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
int errorcount  ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.h"
int warningcount  ;
#line 34
void set_error_location(location l ) ;
#line 35
void clear_error_location(void) ;
#line 40
void verror_with_location(location l , char const   *format , va_list args ) ;
#line 43
void verror_with_decl(declaration d , char const   *format , va_list args ) ;
#line 46
void verror(char const   *format , va_list args ) ;
#line 52
void error_with_decl(declaration d , char const   *format  , ...) ;
#line 58
void vfatal(char const   *format , va_list args ) ;
#line 63
void vwarning_with_location(location l , char const   *format , va_list args ) ;
#line 66
void vwarning_with_decl(declaration d , char const   *format , va_list args ) ;
#line 69
void vwarning(char const   *format , va_list args ) ;
#line 76
void warning_with_decl(declaration d , char const   *format  , ...) ;
#line 82
void warning_or_error(bool iswarning , char const   *format  , ...) ;
#line 85
void warning_or_error_with_decl(bool iswarning , declaration d , char const   *format 
                                , ...) ;
#line 96
void pedwarn_with_decl(declaration d , char const   *format  , ...) ;
#line 99
void pedwarn_with_location(location l , char const   *format  , ...) ;
#line 153 "/home/wheatley/newnew/temp/nescc-1.3.4/src/semantics.h"
extern void declarator_name(declarator d , char const   **oname , char const   **iname ) ;
#line 37 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static location error_location  ;
#line 41 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void set_error_location(location l ) 
{ 


  {
#line 43
  error_location = l;
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void clear_error_location(void) 
{ 


  {
#line 48
  error_location = (location )((void *)0);
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
location current_location(void) 
{ 


  {
#line 53
  if (current.lex.input) {
#line 54
    return (& (current.lex.input)->l);
  } else
#line 55
  if (error_location) {
#line 56
    return (error_location);
  } else {
#line 58
    return (dummy_location);
  }
}
}
#line 71
int count_error(int warningp ) ;
#line 71 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static int warning_message  =    0;
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
int count_error(int warningp ) 
{ 


  {
#line 64
  if (warningp) {
#line 64
    if (inhibit_warnings) {
#line 65
      return (0);
    }
  }
#line 67
  if (warningp) {
#line 67
    if (! warnings_are_errors) {
#line 68
      warningcount ++;
    } else {
#line 67
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 73
    if (warningp) {
#line 73
      if (! warning_message) {
        {
#line 75
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warnings being treated as errors\n",
                progname);
#line 76
        warning_message = 1;
        }
      }
    }
#line 78
    errorcount ++;
  }
#line 81
  return (1);
}
}
#line 87 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static function_decl last_error_function  =    (function_decl )((void *)0);
#line 90 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static int last_error_tick  ;
#line 96 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void print_error_function(char const   *file ) 
{ 
  char const   *name ;
  char const   *iname ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 98
  if ((unsigned long )last_error_function != (unsigned long )current.function_decl) {
#line 100
    if (file) {
      {
#line 101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              file);
      }
    }
#line 103
    if ((unsigned long )current.function_decl == (unsigned long )((void *)0)) {
      {
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"At top level:\n");
      }
    } else {
      {
#line 109
      declarator_name((current.function_decl)->declarator, & name, & iname);
      }
#line 110
      if (iname) {
#line 110
        tmp = ".";
      } else {
#line 110
        tmp = "";
      }
#line 110
      if (iname) {
#line 110
        tmp___0 = iname;
      } else {
#line 110
        tmp___0 = "";
      }
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In function `%s%s%s\':\n",
              tmp___0, tmp, name);
      }
    }
#line 114
    last_error_function = current.function_decl;
  }
#line 116
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static nesc_declaration last_container  ;
#line 119 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void print_current_nesc_instance(void) 
{ 
  char const   *tmp ;

  {
#line 123
  if ((unsigned long )last_container != (unsigned long )current.container) {
#line 125
    if (current.container) {
      {
#line 126
      tmp = language_name((current.container)->kind);
#line 126
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In %s `%s\':\n",
              tmp, (current.container)->instance_name);
      }
    } else {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In C file:\n");
      }
    }
#line 131
    last_container = current.container;
  }
#line 133
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void report_error_function(char const   *file ) 
{ 
  struct file_stack *p ;

  {
#line 143
  if (current.lex.input) {
#line 143
    if ((unsigned long )(current.lex.input)->next != (unsigned long )((struct file_stack *)0)) {
#line 143
      if (input_file_stack_tick != last_error_tick) {
#line 143
        if ((unsigned long )file == (unsigned long )(current.lex.input)->l.filename) {
          {
#line 147
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In file included");
#line 148
          p = (current.lex.input)->next;
          }
          {
#line 148
          while (1) {
            while_continue: /* CIL Label */ ;
#line 148
            if (! p) {
#line 148
              goto while_break;
            }
            {
#line 150
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" from %s:%lu",
                    p->l.filename, p->l.lineno);
            }
#line 151
            if (p->next) {
              {
#line 152
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)",\n                ");
              }
            }
#line 148
            p = p->next;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 154
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":\n");
#line 155
          last_error_tick = input_file_stack_tick;
          }
        }
      }
    }
  }
  {
#line 157
  print_current_nesc_instance();
#line 159
  print_error_function(file);
  }
#line 160
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
static void pfile_and_line(FILE *f , location l ) 
{ 


  {
#line 165
  if (l->container) {
    {
#line 166
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s(%s):%lu: ",
            l->filename, (l->container)->instance_name, l->lineno);
    }
  } else
#line 167
  if (l->lineno) {
    {
#line 168
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s:%lu: ",
            l->filename, l->lineno);
    }
  } else {
    {
#line 170
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s: ", l->filename);
    }
  }
#line 171
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void verror_with_location(location l , char const   *format , va_list args ) 
{ 


  {
  {
#line 176
  count_error(0);
#line 177
  report_error_function(l->filename);
#line 178
  pfile_and_line(stderr, l);
#line 179
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           args);
#line 180
  _IO_putc('\n', stderr);
  }
#line 181
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void verror_with_decl(declaration d , char const   *format , va_list args ) 
{ 


  {
  {
#line 186
  verror_with_location(d->location, format, args);
  }
#line 187
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void verror(char const   *format , va_list args ) 
{ 


  {
#line 192
  if (current.lex.input) {
    {
#line 193
    verror_with_location(& (current.lex.input)->l, format, args);
    }
  } else
#line 194
  if (error_location) {
    {
#line 195
    verror_with_location(error_location, format, args);
    }
  } else {
    {
#line 198
    count_error(0);
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 200
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 201
    _IO_putc('\n', stderr);
    }
  }
#line 203
  return;
}
}
#line 206 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void error(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 210
  __builtin_va_start(args, format);
#line 211
  verror(format, args);
#line 212
  __builtin_va_end(args);
  }
#line 213
  return;
}
}
#line 216 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void error_with_decl(declaration d , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 220
  __builtin_va_start(args, format);
#line 221
  verror_with_decl(d, format, args);
#line 222
  __builtin_va_end(args);
  }
#line 223
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void error_with_location(location l , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 230
  __builtin_va_start(args, format);
#line 231
  verror_with_location(l, format, args);
#line 232
  __builtin_va_end(args);
  }
#line 233
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void vfatal(char const   *format , va_list args ) 
{ 


  {
  {
#line 238
  verror(format, args);
#line 239
  exit(33);
  }
}
}
#line 242 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void fatal(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 246
  __builtin_va_start(args, format);
#line 247
  vfatal(format, args);
#line 248
  __builtin_va_end(args);
  }
#line 249
  return;
}
}
#line 252 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void vwarning_with_location(location l , char const   *format , va_list args ) 
{ 
  int tmp ;

  {
  {
#line 254
  tmp = count_error(1);
  }
#line 254
  if (tmp) {
    {
#line 256
    report_error_function(l->filename);
#line 257
    pfile_and_line(stderr, l);
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: ");
#line 259
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 260
    _IO_putc('\n', stderr);
    }
  }
#line 262
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void vwarning_with_decl(declaration d , char const   *format , va_list args ) 
{ 


  {
  {
#line 267
  vwarning_with_location(d->location, format, args);
  }
#line 268
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void vwarning(char const   *format , va_list args ) 
{ 
  int tmp ;

  {
#line 273
  if (current.lex.input) {
    {
#line 274
    vwarning_with_location(& (current.lex.input)->l, format, args);
    }
  } else
#line 275
  if (error_location) {
    {
#line 276
    vwarning_with_location(error_location, format, args);
    }
  } else {
    {
#line 277
    tmp = count_error(1);
    }
#line 277
    if (tmp) {
      {
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: ",
              progname);
#line 280
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
               args);
#line 281
      _IO_putc('\n', stderr);
      }
    }
  }
#line 283
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 290
  __builtin_va_start(args, format);
#line 291
  vwarning(format, args);
#line 292
  __builtin_va_end(args);
  }
#line 293
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning_with_decl(declaration d , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 301
  __builtin_va_start(args, format);
#line 302
  vwarning_with_decl(d, format, args);
#line 303
  __builtin_va_end(args);
  }
#line 304
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning_with_location(location l , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 311
  __builtin_va_start(args, format);
#line 312
  vwarning_with_location(l, format, args);
#line 313
  __builtin_va_end(args);
  }
#line 314
  return;
}
}
#line 317 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning_or_error(bool iswarning , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 321
  __builtin_va_start(args, format);
  }
#line 322
  if (iswarning) {
    {
#line 323
    vwarning(format, args);
    }
  } else {
    {
#line 325
    verror(format, args);
    }
  }
  {
#line 326
  __builtin_va_end(args);
  }
#line 327
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning_or_error_with_decl(bool iswarning , declaration d , char const   *format 
                                , ...) 
{ 
  va_list args ;

  {
  {
#line 336
  __builtin_va_start(args, format);
  }
#line 337
  if (iswarning) {
    {
#line 338
    vwarning_with_decl(d, format, args);
    }
  } else {
    {
#line 340
    verror_with_decl(d, format, args);
    }
  }
  {
#line 341
  __builtin_va_end(args);
  }
#line 342
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void warning_or_error_with_location(bool iswarning , location l , char const   *format 
                                    , ...) 
{ 
  va_list args ;

  {
  {
#line 350
  __builtin_va_start(args, format);
  }
#line 351
  if (iswarning) {
    {
#line 352
    vwarning_with_location(l, format, args);
    }
  } else {
    {
#line 354
    verror_with_location(l, format, args);
    }
  }
  {
#line 355
  __builtin_va_end(args);
  }
#line 356
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void pedwarn(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 363
  __builtin_va_start(args, format);
  }
#line 364
  if (flag_pedantic_errors) {
    {
#line 365
    verror(format, args);
    }
  } else {
    {
#line 367
    vwarning(format, args);
    }
  }
  {
#line 368
  __builtin_va_end(args);
  }
#line 369
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void pedwarn_with_decl(declaration d , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 376
  __builtin_va_start(args, format);
  }
#line 377
  if (flag_pedantic_errors) {
    {
#line 378
    verror_with_decl(d, format, args);
    }
  } else {
    {
#line 380
    vwarning_with_decl(d, format, args);
    }
  }
  {
#line 381
  __builtin_va_end(args);
  }
#line 382
  return;
}
}
#line 385 "/home/wheatley/newnew/temp/nescc-1.3.4/src/errors.c"
void pedwarn_with_location(location l , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 389
  __builtin_va_start(args, format);
  }
#line 390
  if (flag_pedantic_errors) {
    {
#line 391
    verror_with_location(l, format, args);
    }
  } else {
    {
#line 393
    vwarning_with_location(l, format, args);
    }
  }
  {
#line 394
  __builtin_va_end(args);
  }
#line 395
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 63 "./../include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__string , int __flags ) ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dump.h"
extern region dump_region ;
#line 6 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_list_nd_arg.h"
extern int ND_nd_arg_length(nd_arg l ) ;
#line 83 "/home/wheatley/newnew/temp/nescc-1.3.4/src/ND_defs.h"
extern ndf_and new_ndf_and(region r , nd_filter filter1 , nd_filter filter2 ) ;
#line 86
extern ndf_op new_ndf_op(region r , char const   *name , nd_arg args , int count ) ;
#line 30 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dspec.h"
extern char const   *nd_tokenval(nd_arg arg ) ;
#line 35 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dspec-int.h"
extern void nderror(char *err ) ;
#line 57 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool filter_file(ndf_op filter , location loc ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 59
  tmp = nd_tokenval(filter->args);
#line 59
  tmp___0 = fnmatch(tmp, loc->filename, 0);
  }
#line 59
  if (tmp___0) {
#line 59
    tmp___1 = 0;
  } else {
#line 59
    tmp___1 = 1;
  }
#line 59
  return ((bool )tmp___1);
}
}
#line 62 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool filter_name(ndf_op filter , char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 64
  if (name) {
    {
#line 64
    tmp = regexec((regex_t const   */* __restrict  */)filter->info, (char const   */* __restrict  */)name,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 64
    if (tmp) {
#line 64
      tmp___0 = 0;
    } else {
#line 64
      tmp___0 = 1;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return ((bool )tmp___0);
}
}
#line 67 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool filter_attribute(ndf_op filter , dd_list attrs ) 
{ 
  nd_arg reqattr ;
  dd_list_pos actualattr ;
  AST_generic tEmPcast ;
  char const   *reqname ;
  char const   *tmp ;
  nesc_attribute a ;
  int tmp___0 ;

  {
#line 72
  if (! attrs) {
#line 73
    return ((bool )0);
  }
#line 77
  reqattr = filter->args;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! reqattr) {
#line 77
      goto while_break;
    }
    {
#line 79
    tmp = nd_tokenval(reqattr);
#line 79
    reqname = tmp;
#line 81
    actualattr = dd_first(attrs);
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (! (! actualattr->next))) {
#line 81
        goto while_break___0;
      }
      {
#line 83
      a = (nesc_attribute )actualattr->data;
#line 85
      tmp___0 = strcmp((char const   *)(a->word1)->cstring.data, reqname);
      }
#line 85
      if (! tmp___0) {
#line 86
        return ((bool )1);
      }
#line 81
      actualattr = actualattr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 77
    tEmPcast = (AST_generic )reqattr->next;
#line 77
    if (tEmPcast) {
#line 77
      if ((unsigned int )tEmPcast->kind >= 10001U) {
#line 77
        if (! ((unsigned int )tEmPcast->kind <= 10008U)) {
          {
#line 77
          __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                        77U, "filter_attribute");
          }
        }
      } else {
        {
#line 77
        __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      77U, "filter_attribute");
        }
      }
    }
#line 77
    reqattr = (nd_arg )tEmPcast;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return ((bool )0);
}
}
#line 92 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool filter_component(ndf_op filter , nesc_declaration container ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 94
  if (container) {
    {
#line 94
    tmp = nd_tokenval(filter->args);
#line 94
    tmp___0 = strcmp(tmp, container->instance_name);
    }
#line 94
    if (tmp___0) {
#line 94
      tmp___1 = 0;
    } else {
#line 94
      tmp___1 = 1;
    }
  } else {
#line 94
    tmp___1 = 0;
  }
#line 94
  return ((bool )tmp___1);
}
}
#line 100 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_file(ndf_op op , data_declaration ddecl ) 
{ 
  location tmp ;
  bool tmp___0 ;

  {
#line 102
  if (ddecl->definition) {
#line 102
    tmp = (ddecl->definition)->location;
  } else {
#line 102
    tmp = (ddecl->ast)->location;
  }
  {
#line 102
  tmp___0 = filter_file(op, tmp);
  }
#line 102
  return (tmp___0);
}
}
#line 105 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_file(ndf_op op , nesc_declaration ndecl ) 
{ 
  bool tmp ;

  {
  {
#line 107
  tmp = filter_file(op, (ndecl->ast)->location);
  }
#line 107
  return (tmp);
}
}
#line 110 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_file(ndf_op op , tag_declaration tdecl ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 112
  if (tdecl->definition) {
    {
#line 112
    tmp = filter_file(op, (tdecl->definition)->location);
    }
#line 112
    if (tmp) {
#line 112
      tmp___0 = 1;
    } else {
#line 112
      tmp___0 = 0;
    }
  } else {
#line 112
    tmp___0 = 0;
  }
#line 112
  return ((bool )tmp___0);
}
}
#line 115 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_attribute(ndf_op op , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 117
  tmp = filter_attribute(op, ddecl->attributes);
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_attribute(ndf_op op , nesc_declaration ndecl ) 
{ 
  bool tmp ;

  {
  {
#line 122
  tmp = filter_attribute(op, ndecl->attributes);
  }
#line 122
  return (tmp);
}
}
#line 125 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_attribute(ndf_op op , tag_declaration tdecl ) 
{ 
  bool tmp ;

  {
  {
#line 127
  tmp = filter_attribute(op, tdecl->attributes);
  }
#line 127
  return (tmp);
}
}
#line 130 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static void fcompile_name(ndf_op op ) 
{ 
  int err ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char errmsg[200] ;

  {
#line 134
  if (sizeof(regex_t ) < (unsigned long )(1 << 9)) {
    {
#line 134
    tmp = __rcralloc_small0(dump_region, sizeof(regex_t ));
#line 134
    op->info = tmp;
    }
  } else {
    {
#line 134
    tmp___0 = typed_ralloc(dump_region, sizeof(regex_t ), 0);
#line 134
    op->info = tmp___0;
    }
  }
  {
#line 135
  tmp___1 = nd_tokenval(op->args);
#line 135
  err = regcomp((regex_t */* __restrict  */)op->info, (char const   */* __restrict  */)tmp___1,
                1);
  }
#line 136
  if (err) {
    {
#line 140
    regerror(err, (regex_t const   */* __restrict  */)op->info, (char */* __restrict  */)(errmsg),
             sizeof(errmsg));
#line 141
    nderror(errmsg);
    }
  }
#line 143
  return;
}
}
#line 145 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_name(ndf_op op , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 147
  tmp = filter_name(op, ddecl->name);
  }
#line 147
  return (tmp);
}
}
#line 150 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_name(ndf_op op , nesc_declaration ndecl ) 
{ 
  bool tmp ;

  {
  {
#line 152
  tmp = filter_name(op, ndecl->instance_name);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_name(ndf_op op , tag_declaration tdecl ) 
{ 
  bool tmp ;

  {
  {
#line 157
  tmp = filter_name(op, tdecl->name);
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_component(ndf_op op , data_declaration ddecl ) 
{ 
  bool tmp ;

  {
  {
#line 162
  tmp = filter_component(op, ddecl->container);
  }
#line 162
  return (tmp);
}
}
#line 165 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_component(ndf_op op , nesc_declaration ndecl ) 
{ 


  {
#line 169
  return ((bool )0);
}
}
#line 172 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_component(ndf_op op , tag_declaration tdecl ) 
{ 
  bool tmp ;

  {
  {
#line 174
  tmp = filter_component(op, tdecl->container);
  }
#line 174
  return (tmp);
}
}
#line 177 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_global(ndf_op op , data_declaration ddecl ) 
{ 
  int tmp ;

  {
#line 179
  if (! ddecl->container) {
#line 179
    if (! ddecl->container_function) {
#line 179
      tmp = 1;
    } else {
#line 179
      tmp = 0;
    }
  } else {
#line 179
    tmp = 0;
  }
#line 179
  return ((bool )tmp);
}
}
#line 182 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_global(ndf_op op , nesc_declaration ndecl ) 
{ 


  {
#line 185
  return ((bool )1);
}
}
#line 188 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_global(ndf_op op , tag_declaration tdecl ) 
{ 


  {
#line 190
  return ((bool )(! tdecl->container));
}
}
#line 193 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool is_instance(nesc_declaration ndecl ) 
{ 
  int tmp ;

  {
#line 195
  if (ndecl) {
#line 195
    if (ndecl->arguments) {
#line 195
      tmp = 1;
    } else {
#line 195
      tmp = 0;
    }
  } else {
#line 195
    tmp = 0;
  }
#line 195
  return ((bool )tmp);
}
}
#line 198 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_instance(ndf_op op , data_declaration ddecl ) 
{ 
  nesc_declaration tmp ;
  bool tmp___0 ;

  {
  {
#line 200
  tmp = ddecl_container(ddecl);
#line 200
  tmp___0 = is_instance(tmp);
  }
#line 200
  return (tmp___0);
}
}
#line 203 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_instance(ndf_op op , nesc_declaration ndecl ) 
{ 
  bool tmp ;

  {
  {
#line 205
  tmp = is_instance(ndecl);
  }
#line 205
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_instance(ndf_op op , tag_declaration tdecl ) 
{ 
  nesc_declaration tmp ;
  bool tmp___0 ;

  {
  {
#line 210
  tmp = tdecl_container(tdecl);
#line 210
  tmp___0 = is_instance(tmp);
  }
#line 210
  return (tmp___0);
}
}
#line 213 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool is_abstract(nesc_declaration ndecl ) 
{ 
  int tmp ;

  {
#line 215
  if (ndecl) {
#line 215
    if (ndecl->abstract) {
#line 215
      tmp = 1;
    } else {
#line 215
      tmp = 0;
    }
  } else {
#line 215
    tmp = 0;
  }
#line 215
  return ((bool )tmp);
}
}
#line 218 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fddecl_abstract(ndf_op op , data_declaration ddecl ) 
{ 
  nesc_declaration tmp ;
  bool tmp___0 ;

  {
  {
#line 220
  tmp = ddecl_container(ddecl);
#line 220
  tmp___0 = is_abstract(tmp);
  }
#line 220
  return (tmp___0);
}
}
#line 223 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool fndecl_abstract(ndf_op op , nesc_declaration ndecl ) 
{ 
  bool tmp ;

  {
  {
#line 225
  tmp = is_abstract(ndecl);
  }
#line 225
  return (tmp);
}
}
#line 228 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool ftdecl_abstract(ndf_op op , tag_declaration tdecl ) 
{ 
  nesc_declaration tmp ;
  bool tmp___0 ;

  {
  {
#line 230
  tmp = tdecl_container(tdecl);
#line 230
  tmp___0 = is_abstract(tmp);
  }
#line 230
  return (tmp___0);
}
}
#line 233 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static struct filter_op ops[7]  = {      {"file", "t", (void (*)(ndf_op op ))((void *)0), & fddecl_file, & fndecl_file,
      & ftdecl_file}, 
        {"name", "t", & fcompile_name, & fddecl_name, & fndecl_name, & ftdecl_name}, 
        {"component", "t", (void (*)(ndf_op op ))((void *)0), & fddecl_component, & fndecl_component,
      & ftdecl_component}, 
        {"global", "", (void (*)(ndf_op op ))((void *)0), & fddecl_global, & fndecl_global,
      & ftdecl_global}, 
        {"instance", "", (void (*)(ndf_op op ))((void *)0), & fddecl_instance, & fndecl_instance,
      & ftdecl_instance}, 
        {"abstract", "", (void (*)(ndf_op op ))((void *)0), & fddecl_abstract, & fndecl_abstract,
      & ftdecl_abstract}, 
        {"attribute", "*t", (void (*)(ndf_op op ))((void *)0), & fddecl_attribute, & fndecl_attribute,
      & ftdecl_attribute}};
#line 254 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static void check_arg(nd_arg arg , int kind ) 
{ 
  bool ok ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 261
  if (kind == 116) {
#line 261
    goto case_116;
  }
#line 262
  if (kind == 110) {
#line 262
    goto case_110;
  }
#line 260
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 260
  ok = (bool )1;
  case_116: /* CIL Label */ 
#line 261
  if ((unsigned int )arg->kind >= 10003U) {
#line 261
    if ((unsigned int )arg->kind <= 10003U) {
#line 261
      tmp = 1;
    } else {
#line 261
      tmp = 0;
    }
  } else {
#line 261
    tmp = 0;
  }
#line 261
  ok = (bool )tmp;
#line 261
  goto switch_break;
  case_110: /* CIL Label */ 
#line 262
  if ((unsigned int )arg->kind >= 10002U) {
#line 262
    if ((unsigned int )arg->kind <= 10002U) {
#line 262
      tmp___0 = 1;
    } else {
#line 262
      tmp___0 = 0;
    }
  } else {
#line 262
    tmp___0 = 0;
  }
#line 262
  ok = (bool )tmp___0;
#line 262
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (! ok) {
    {
#line 265
    nderror((char *)"wrong argument type");
    }
  }
#line 266
  return;
}
}
#line 268 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
nd_filter make_ndf_op(region r , char const   *name , nd_arg args ) 
{ 
  int nargs ;
  AST_generic tEmPcast ;
  int tmp ;
  ndf_op op ;
  ndf_op tmp___0 ;
  int i ;
  char const   *argspec ;
  nd_arg arg ;
  int old_ec ;
  AST_generic tEmPcast___0 ;
  AST_generic tEmPcast___1 ;
  char const   *tmp___1 ;
  AST_generic tEmPcast___2 ;
  int tmp___2 ;
  AST_generic tEmPcast___3 ;

  {
#line 270
  tEmPcast = (AST_generic )args;
#line 270
  if (tEmPcast) {
#line 270
    if ((unsigned int )tEmPcast->kind >= 10001U) {
#line 270
      if (! ((unsigned int )tEmPcast->kind <= 10008U)) {
        {
#line 270
        __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      270U, "make_ndf_op");
        }
      }
    } else {
      {
#line 270
      __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 270U,
                    "make_ndf_op");
      }
    }
  }
  {
#line 270
  tmp = ND_nd_arg_length((nd_arg )tEmPcast);
#line 270
  nargs = tmp;
#line 271
  tmp___0 = new_ndf_op(r, name, args, nargs);
#line 271
  op = tmp___0;
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((unsigned long )i < sizeof(ops) / sizeof(ops[0]))) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp___2 = strcmp(name, ops[i].name);
    }
#line 275
    if (! tmp___2) {
#line 277
      argspec = ops[i].args;
#line 279
      old_ec = errorcount;
#line 281
      op->filter_index = i;
#line 284
      if ((int const   )*(argspec + 0) == 42) {
#line 285
        arg = args;
        {
#line 285
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 285
          if (! arg) {
#line 285
            goto while_break___0;
          }
          {
#line 286
          check_arg(arg, (int )*(argspec + 1));
#line 285
          tEmPcast___0 = (AST_generic )arg->next;
          }
#line 285
          if (tEmPcast___0) {
#line 285
            if ((unsigned int )tEmPcast___0->kind >= 10001U) {
#line 285
              if (! ((unsigned int )tEmPcast___0->kind <= 10008U)) {
                {
#line 285
                __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                              285U, "make_ndf_op");
                }
              }
            } else {
              {
#line 285
              __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                            285U, "make_ndf_op");
              }
            }
          }
#line 285
          arg = (nd_arg )tEmPcast___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 289
        arg = args;
        {
#line 289
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 289
          if (! arg) {
#line 289
            goto while_break___1;
          }
#line 291
          if (! *argspec) {
            {
#line 292
            nderror((char *)"too many arguments");
            }
          } else {
            {
#line 294
            tmp___1 = argspec;
#line 294
            argspec ++;
#line 294
            check_arg(arg, (int )*tmp___1);
            }
          }
#line 289
          tEmPcast___1 = (AST_generic )arg->next;
#line 289
          if (tEmPcast___1) {
#line 289
            if ((unsigned int )tEmPcast___1->kind >= 10001U) {
#line 289
              if (! ((unsigned int )tEmPcast___1->kind <= 10008U)) {
                {
#line 289
                __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                              289U, "make_ndf_op");
                }
              }
            } else {
              {
#line 289
              __assert_fail("((tEmPcast)->kind >= kind_nd_arg && (tEmPcast)->kind <= postkind_nd_arg)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                            289U, "make_ndf_op");
              }
            }
          }
#line 289
          arg = (nd_arg )tEmPcast___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 296
        if (*argspec) {
          {
#line 297
          nderror((char *)"not enough arguments");
          }
        }
      }
#line 300
      if (errorcount == old_ec) {
#line 300
        if (ops[i].compile) {
          {
#line 301
          (*(ops[i].compile))(op);
          }
        }
      }
#line 303
      tEmPcast___2 = (AST_generic )op;
#line 303
      if (tEmPcast___2) {
#line 303
        if ((unsigned int )tEmPcast___2->kind >= 10004U) {
#line 303
          if (! ((unsigned int )tEmPcast___2->kind <= 10008U)) {
            {
#line 303
            __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                          303U, "make_ndf_op");
            }
          }
        } else {
          {
#line 303
          __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                        "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                        303U, "make_ndf_op");
          }
        }
      }
#line 303
      return ((nd_filter )tEmPcast___2);
    }
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  nderror((char *)"unknown filter operator");
#line 307
  tEmPcast___3 = (AST_generic )op;
  }
#line 307
  if (tEmPcast___3) {
#line 307
    if ((unsigned int )tEmPcast___3->kind >= 10004U) {
#line 307
      if (! ((unsigned int )tEmPcast___3->kind <= 10008U)) {
        {
#line 307
        __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      307U, "make_ndf_op");
        }
      }
    } else {
      {
#line 307
      __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 307U,
                    "make_ndf_op");
      }
    }
  }
#line 307
  return ((nd_filter )tEmPcast___3);
}
}
#line 311 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static nd_filter current_filter  ;
#line 315 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
static bool dofilter(int op , nd_filter f , void *decl ) 
{ 
  ndf_and f1 ;
  AST_generic tEmPcast ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  ndf_or f1___0 ;
  AST_generic tEmPcast___0 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  ndf_not f1___1 ;
  AST_generic tEmPcast___1 ;
  bool tmp___5 ;
  int tmp___6 ;
  ndf_op f1___2 ;
  AST_generic tEmPcast___2 ;
  struct filter_op *fop ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 319
  if ((unsigned int )f->kind == 10005U) {
#line 319
    goto case_10005;
  }
#line 323
  if ((unsigned int )f->kind == 10006U) {
#line 323
    goto case_10006;
  }
#line 327
  if ((unsigned int )f->kind == 10007U) {
#line 327
    goto case_10007;
  }
#line 331
  if ((unsigned int )f->kind == 10008U) {
#line 331
    goto case_10008;
  }
#line 343
  goto switch_default___0;
  case_10005: /* CIL Label */ 
#line 320
  tEmPcast = (AST_generic )f;
#line 320
  if (tEmPcast) {
#line 320
    if ((unsigned int )tEmPcast->kind >= 10005U) {
#line 320
      if (! ((unsigned int )tEmPcast->kind <= 10005U)) {
        {
#line 320
        __assert_fail("((tEmPcast)->kind >= kind_ndf_and && (tEmPcast)->kind <= postkind_ndf_and)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      320U, "dofilter");
        }
      }
    } else {
      {
#line 320
      __assert_fail("((tEmPcast)->kind >= kind_ndf_and && (tEmPcast)->kind <= postkind_ndf_and)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 320U,
                    "dofilter");
      }
    }
  }
  {
#line 320
  f1 = (ndf_and )tEmPcast;
#line 321
  tmp = dofilter(op, f1->filter1, decl);
  }
#line 321
  if (tmp) {
    {
#line 321
    tmp___0 = dofilter(op, f1->filter2, decl);
    }
#line 321
    if (tmp___0) {
#line 321
      tmp___1 = 1;
    } else {
#line 321
      tmp___1 = 0;
    }
  } else {
#line 321
    tmp___1 = 0;
  }
#line 321
  return ((bool )tmp___1);
  case_10006: /* CIL Label */ 
#line 324
  tEmPcast___0 = (AST_generic )f;
#line 324
  if (tEmPcast___0) {
#line 324
    if ((unsigned int )tEmPcast___0->kind >= 10006U) {
#line 324
      if (! ((unsigned int )tEmPcast___0->kind <= 10006U)) {
        {
#line 324
        __assert_fail("((tEmPcast)->kind >= kind_ndf_or && (tEmPcast)->kind <= postkind_ndf_or)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      324U, "dofilter");
        }
      }
    } else {
      {
#line 324
      __assert_fail("((tEmPcast)->kind >= kind_ndf_or && (tEmPcast)->kind <= postkind_ndf_or)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 324U,
                    "dofilter");
      }
    }
  }
  {
#line 324
  f1___0 = (ndf_or )tEmPcast___0;
#line 325
  tmp___2 = dofilter(op, f1___0->filter1, decl);
  }
#line 325
  if (tmp___2) {
#line 325
    tmp___4 = 1;
  } else {
    {
#line 325
    tmp___3 = dofilter(op, f1___0->filter2, decl);
    }
#line 325
    if (tmp___3) {
#line 325
      tmp___4 = 1;
    } else {
#line 325
      tmp___4 = 0;
    }
  }
#line 325
  return ((bool )tmp___4);
  case_10007: /* CIL Label */ 
#line 328
  tEmPcast___1 = (AST_generic )f;
#line 328
  if (tEmPcast___1) {
#line 328
    if ((unsigned int )tEmPcast___1->kind >= 10007U) {
#line 328
      if (! ((unsigned int )tEmPcast___1->kind <= 10007U)) {
        {
#line 328
        __assert_fail("((tEmPcast)->kind >= kind_ndf_not && (tEmPcast)->kind <= postkind_ndf_not)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      328U, "dofilter");
        }
      }
    } else {
      {
#line 328
      __assert_fail("((tEmPcast)->kind >= kind_ndf_not && (tEmPcast)->kind <= postkind_ndf_not)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 328U,
                    "dofilter");
      }
    }
  }
  {
#line 328
  f1___1 = (ndf_not )tEmPcast___1;
#line 329
  tmp___5 = dofilter(op, f1___1->filter1, decl);
  }
#line 329
  if (tmp___5) {
#line 329
    tmp___6 = 0;
  } else {
#line 329
    tmp___6 = 1;
  }
#line 329
  return ((bool )tmp___6);
  case_10008: /* CIL Label */ 
#line 332
  tEmPcast___2 = (AST_generic )f;
#line 332
  if (tEmPcast___2) {
#line 332
    if ((unsigned int )tEmPcast___2->kind >= 10008U) {
#line 332
      if (! ((unsigned int )tEmPcast___2->kind <= 10008U)) {
        {
#line 332
        __assert_fail("((tEmPcast)->kind >= kind_ndf_op && (tEmPcast)->kind <= postkind_ndf_op)",
                      "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                      332U, "dofilter");
        }
      }
    } else {
      {
#line 332
      __assert_fail("((tEmPcast)->kind >= kind_ndf_op && (tEmPcast)->kind <= postkind_ndf_op)",
                    "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c", 332U,
                    "dofilter");
      }
    }
  }
#line 332
  f1___2 = (ndf_op )tEmPcast___2;
#line 333
  fop = & ops[f1___2->filter_index];
  {
#line 337
  if (op == 0) {
#line 337
    goto case_0;
  }
#line 338
  if (op == 1) {
#line 338
    goto case_1;
  }
#line 339
  if (op == 2) {
#line 339
    goto case_2;
  }
#line 340
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 337
  tmp___7 = (*(fop->execute_ddecl))(f1___2, (data_declaration )decl);
  }
#line 337
  return (tmp___7);
  case_1: /* CIL Label */ 
  {
#line 338
  tmp___8 = (*(fop->execute_ndecl))(f1___2, (nesc_declaration )decl);
  }
#line 338
  return (tmp___8);
  case_2: /* CIL Label */ 
  {
#line 339
  tmp___9 = (*(fop->execute_tdecl))(f1___2, (tag_declaration )decl);
  }
#line 339
  return (tmp___9);
  switch_default: /* CIL Label */ 
  {
#line 340
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                340U, "dofilter");
  }
#line 340
  return ((bool )0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 344
  __assert_fail("0", "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                344U, "dofilter");
  }
#line 344
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
bool dump_filter_ddecl(data_declaration ddecl ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 350
  if (! current_filter) {
#line 350
    tmp___0 = 1;
  } else {
    {
#line 350
    tmp = dofilter(0, current_filter, (void *)ddecl);
    }
#line 350
    if (tmp) {
#line 350
      tmp___0 = 1;
    } else {
#line 350
      tmp___0 = 0;
    }
  }
#line 350
  return ((bool )tmp___0);
}
}
#line 353 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
bool dump_filter_ndecl(nesc_declaration ndecl ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 355
  if (! current_filter) {
#line 355
    tmp___0 = 1;
  } else {
    {
#line 355
    tmp = dofilter(1, current_filter, (void *)ndecl);
    }
#line 355
    if (tmp) {
#line 355
      tmp___0 = 1;
    } else {
#line 355
      tmp___0 = 0;
    }
  }
#line 355
  return ((bool )tmp___0);
}
}
#line 358 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
bool dump_filter_tdecl(tag_declaration tdecl ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 360
  if (! current_filter) {
#line 360
    tmp___0 = 1;
  } else {
    {
#line 360
    tmp = dofilter(2, current_filter, (void *)tdecl);
    }
#line 360
    if (tmp) {
#line 360
      tmp___0 = 1;
    } else {
#line 360
      tmp___0 = 0;
    }
  }
#line 360
  return ((bool )tmp___0);
}
}
#line 363 "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c"
void dump_set_filter(nd_option opt ) 
{ 
  nd_arg *optargs ;
  nd_filter extracted ;
  nd_filter f ;
  AST_generic tEmPcast ;
  ndf_and x ;
  ndf_and tmp ;
  AST_generic tEmPcast___0 ;

  {
#line 365
  optargs = & opt->args;
#line 366
  extracted = (nd_filter )((void *)0);
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! *optargs) {
#line 370
      goto while_break;
    }
#line 371
    if ((unsigned int )(*optargs)->kind >= 10004U) {
#line 371
      if ((unsigned int )(*optargs)->kind <= 10008U) {
#line 375
        tEmPcast = (AST_generic )*optargs;
#line 375
        if (tEmPcast) {
#line 375
          if ((unsigned int )tEmPcast->kind >= 10004U) {
#line 375
            if (! ((unsigned int )tEmPcast->kind <= 10008U)) {
              {
#line 375
              __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                            375U, "dump_set_filter");
              }
            }
          } else {
            {
#line 375
            __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                          "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                          375U, "dump_set_filter");
            }
          }
        }
#line 375
        f = (nd_filter )tEmPcast;
#line 376
        *optargs = (*optargs)->next;
#line 378
        if (extracted) {
          {
#line 380
          tmp = new_ndf_and(dump_region, extracted, f);
#line 380
          x = tmp;
#line 381
          tEmPcast___0 = (AST_generic )x;
          }
#line 381
          if (tEmPcast___0) {
#line 381
            if ((unsigned int )tEmPcast___0->kind >= 10004U) {
#line 381
              if (! ((unsigned int )tEmPcast___0->kind <= 10008U)) {
                {
#line 381
                __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                              "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                              381U, "dump_set_filter");
                }
              }
            } else {
              {
#line 381
              __assert_fail("((tEmPcast)->kind >= kind_nd_filter && (tEmPcast)->kind <= postkind_nd_filter)",
                            "/home/wheatley/newnew/temp/nescc-1.3.4/src/nesc-dfilter.c",
                            381U, "dump_set_filter");
              }
            }
          }
#line 381
          extracted = (nd_filter )tEmPcast___0;
        } else {
#line 384
          extracted = f;
        }
      } else {
#line 372
        optargs = & (*optargs)->next;
      }
    } else {
#line 372
      optargs = & (*optargs)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  current_filter = extracted;
#line 388
  return;
}
}
