/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 31 "/usr/include/nss.h"
enum nss_status {
    NSS_STATUS_TRYAGAIN = -2,
    NSS_STATUS_UNAVAIL = -1,
    NSS_STATUS_NOTFOUND = 0,
    NSS_STATUS_SUCCESS = 1,
    NSS_STATUS_RETURN = 2
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 649
extern char *fgets_unlocked(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 836
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 913
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) flockfile)(FILE *__stream ) ;
#line 920
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) funlockfile)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 47 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_getpwuid_r(uid_t uid , struct passwd *result , char *buf ,
                                           size_t buflen , int *errnop ) ;
#line 48
enum nss_status _nss_extrausers_setpwent(void) ;
#line 49
enum nss_status _nss_extrausers_endpwent(void) ;
#line 50
enum nss_status _nss_extrausers_getpwnam_r(char const   *name , struct passwd *result ,
                                           char *buf , size_t buflen , int *errnop ) ;
#line 51
enum nss_status _nss_extrausers_getpwent_r(struct passwd *pw , char *buffer , size_t buflen ,
                                           int *errnop ) ;
#line 53
__inline static enum nss_status p_search(FILE *f , char const   *name , uid_t const   uid ,
                                         struct passwd *pw , int *errnop , char *buffer ,
                                         size_t buflen ) ;
#line 55 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
__inline static enum nss_status p_search(FILE *f , char const   *name , uid_t const   uid ,
                                         struct passwd *pw , int *errnop , char *buffer ,
                                         size_t buflen ) 
{ 
  FILE *stream ;
  char *p ;
  char *h ;
  uid_t t_uid ;
  gid_t t_gid ;
  char *t_name ;
  char *t_passwd ;
  char *t_gecos ;
  char *t_shell ;
  char *t_dir ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;

  {
#line 69
  stream = f;
#line 75
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
#line 76
    stream = fopen((char const   */* __restrict  */)"/var/lib/extrausers/passwd",
                   (char const   */* __restrict  */)"r");
    }
#line 77
    if ((unsigned long )stream == (unsigned long )((void *)0)) {
      {
#line 78
      tmp = __errno_location();
#line 78
      *errnop = *tmp;
      }
#line 79
      return ((enum nss_status )-1);
    }
  }
  {
#line 82
  flockfile(stream);
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    *(buffer + (buflen - 1UL)) = (char )'\377';
#line 85
    p = fgets_unlocked((char */* __restrict  */)buffer, (int )buflen, (FILE */* __restrict  */)stream);
    }
#line 86
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 87
      tmp___1 = feof_unlocked(stream);
      }
#line 87
      if (tmp___1) {
        {
#line 88
        funlockfile(stream);
        }
#line 88
        if ((unsigned long )f == (unsigned long )((void *)0)) {
          {
#line 88
          fclose(stream);
          }
        }
#line 89
        *errnop = 2;
#line 90
        return ((enum nss_status )0);
      } else {
        {
#line 92
        tmp___0 = __errno_location();
#line 92
        *errnop = *tmp___0;
#line 93
        funlockfile(stream);
        }
#line 93
        if ((unsigned long )f == (unsigned long )((void *)0)) {
          {
#line 93
          fclose(stream);
          }
        }
#line 94
        return ((enum nss_status )-1);
      }
    }
    {
#line 97
    h = index((char const   *)p, '\n');
    }
#line 98
    if ((int )*(buffer + (buflen - 1UL)) != -1) {
#line 98
      goto _L;
    } else
#line 98
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 99
      funlockfile(stream);
      }
#line 99
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 99
        fclose(stream);
        }
      }
#line 100
      *errnop = 34;
#line 101
      return ((enum nss_status )-2);
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 103
      tmp___2 = __ctype_b_loc();
      }
#line 103
      if ((int const   )*(*tmp___2 + (int )*h) & 8192) {
#line 103
        if (! ((unsigned long )h != (unsigned long )p)) {
#line 103
          goto while_break___0;
        }
      } else {
#line 103
        goto while_break___0;
      }
#line 104
      *h = (char )'\000';
#line 105
      h --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    if ((int )*p == 35) {
#line 109
      goto while_continue;
    }
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___3 = __ctype_b_loc();
      }
#line 111
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 111
        goto while_break___1;
      }
#line 112
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 114
    if ((int )*p == 0) {
#line 115
      goto while_continue;
    }
#line 116
    t_name = p;
    {
#line 117
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 117
      if (*p) {
#line 117
        if (! ((int )*p != 58)) {
#line 117
          goto while_break___2;
        }
      } else {
#line 117
        goto while_break___2;
      }
#line 117
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 117
    h = p;
#line 117
    if (! *p) {
      {
#line 117
      funlockfile(stream);
      }
#line 117
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 117
        fclose(stream);
        }
      }
#line 117
      *errnop = 0;
#line 117
      return ((enum nss_status )-1);
    }
#line 117
    p ++;
#line 117
    *h = (char )'\000';
#line 117
    h --;
#line 118
    if (name) {
      {
#line 118
      tmp___4 = strcmp(name, (char const   *)t_name);
      }
#line 118
      if (tmp___4 != 0) {
#line 119
        goto while_continue;
      }
    }
    {
#line 121
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 121
      tmp___5 = __ctype_b_loc();
      }
#line 121
      if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 121
        goto while_break___3;
      }
#line 122
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 123
    t_passwd = p;
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (*p) {
#line 124
        if (! ((int )*p != 58)) {
#line 124
          goto while_break___4;
        }
      } else {
#line 124
        goto while_break___4;
      }
#line 124
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 124
    h = p;
#line 124
    if (! *p) {
      {
#line 124
      funlockfile(stream);
      }
#line 124
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 124
        fclose(stream);
        }
      }
#line 124
      *errnop = 0;
#line 124
      return ((enum nss_status )-1);
    }
    {
#line 124
    p ++;
#line 124
    *h = (char )'\000';
#line 124
    h --;
#line 126
    tmp___6 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
#line 126
    t_uid = (uid_t )tmp___6;
    }
#line 127
    if ((int )*h != 58) {
      {
#line 128
      funlockfile(stream);
      }
#line 128
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 128
        fclose(stream);
        }
      }
#line 129
      *errnop = 0;
#line 130
      return ((enum nss_status )-1);
    }
#line 132
    if (t_uid < 500U) {
#line 133
      goto while_continue;
    }
#line 135
    if (uid != 0U) {
#line 135
      if (uid != (uid_t const   )t_uid) {
#line 136
        goto while_continue;
      }
    }
    {
#line 138
    h ++;
#line 138
    p = h;
#line 140
    tmp___7 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
#line 140
    t_gid = (gid_t )tmp___7;
    }
#line 141
    if ((int )*h != 58) {
      {
#line 142
      funlockfile(stream);
      }
#line 142
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 142
        fclose(stream);
        }
      }
#line 143
      *errnop = 0;
#line 144
      return ((enum nss_status )-1);
    }
#line 147
    if (t_gid < 500U) {
#line 147
      if (t_gid != 100U) {
#line 151
        goto while_continue;
      }
    }
#line 153
    h ++;
#line 153
    p = h;
    {
#line 155
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 155
      tmp___8 = __ctype_b_loc();
      }
#line 155
      if (! ((int const   )*(*tmp___8 + (int )*p) & 8192)) {
#line 155
        goto while_break___5;
      }
#line 156
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 157
    t_gecos = p;
    {
#line 158
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 158
      if (*p) {
#line 158
        if (! ((int )*p != 58)) {
#line 158
          goto while_break___6;
        }
      } else {
#line 158
        goto while_break___6;
      }
#line 158
      p ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 158
    h = p;
#line 158
    if (! *p) {
      {
#line 158
      funlockfile(stream);
      }
#line 158
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 158
        fclose(stream);
        }
      }
#line 158
      *errnop = 0;
#line 158
      return ((enum nss_status )-1);
    }
#line 158
    p ++;
#line 158
    *h = (char )'\000';
#line 158
    h --;
    {
#line 160
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 160
      tmp___9 = __ctype_b_loc();
      }
#line 160
      if (! ((int const   )*(*tmp___9 + (int )*p) & 8192)) {
#line 160
        goto while_break___7;
      }
#line 161
      p ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 162
    t_dir = p;
    {
#line 163
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 163
      if (*p) {
#line 163
        if (! ((int )*p != 58)) {
#line 163
          goto while_break___8;
        }
      } else {
#line 163
        goto while_break___8;
      }
#line 163
      p ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 163
    h = p;
#line 163
    if (! *p) {
      {
#line 163
      funlockfile(stream);
      }
#line 163
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 163
        fclose(stream);
        }
      }
#line 163
      *errnop = 0;
#line 163
      return ((enum nss_status )-1);
    }
#line 163
    p ++;
#line 163
    *h = (char )'\000';
#line 163
    h --;
    {
#line 165
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 165
      tmp___10 = __ctype_b_loc();
      }
#line 165
      if (! ((int const   )*(*tmp___10 + (int )*p) & 8192)) {
#line 165
        goto while_break___9;
      }
#line 166
      p ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 167
    t_shell = p;
#line 168
    tmp___11 = index((char const   *)p, ':');
    }
#line 168
    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
      {
#line 169
      funlockfile(stream);
      }
#line 169
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 169
        fclose(stream);
        }
      }
#line 170
      *errnop = 0;
#line 171
      return ((enum nss_status )-1);
    }
    {
#line 174
    funlockfile(stream);
    }
#line 174
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 174
      fclose(stream);
      }
    }
#line 175
    *errnop = 0;
#line 176
    pw->pw_name = t_name;
#line 177
    pw->pw_uid = t_uid;
#line 178
    pw->pw_passwd = t_passwd;
#line 179
    pw->pw_gid = t_gid;
#line 180
    pw->pw_gecos = t_gecos;
#line 181
    pw->pw_dir = t_dir;
#line 182
    pw->pw_shell = t_shell;
#line 183
    return ((enum nss_status )1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 187 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_getpwuid_r(uid_t uid , struct passwd *result , char *buf ,
                                           size_t buflen , int *errnop ) 
{ 
  enum nss_status tmp ;

  {
#line 188
  *errnop = 0;
#line 189
  if (result) {
    {
#line 190
    tmp = p_search((FILE *)((void *)0), (char const   *)((void *)0), (uid_t const   )uid,
                   result, errnop, buf, buflen);
    }
#line 190
    return (tmp);
  } else {
#line 192
    return ((enum nss_status )-1);
  }
}
}
#line 195 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_getpwnam_r(char const   *name , struct passwd *result ,
                                           char *buf , size_t buflen , int *errnop ) 
{ 
  enum nss_status tmp ;

  {
#line 196
  *errnop = 0;
#line 197
  if (result) {
    {
#line 198
    tmp = p_search((FILE *)((void *)0), name, (uid_t const   )0, result, errnop, buf,
                   buflen);
    }
#line 198
    return (tmp);
  } else {
#line 200
    return ((enum nss_status )-1);
  }
}
}
#line 203 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
static FILE *usersfile  =    (FILE *)((void *)0);
#line 205 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_setpwent(void) 
{ 


  {
#line 207
  if ((unsigned long )usersfile != (unsigned long )((void *)0)) {
    {
#line 209
    fclose(usersfile);
#line 210
    usersfile = (FILE *)((void *)0);
    }
  }
  {
#line 212
  usersfile = fopen((char const   */* __restrict  */)"/var/lib/extrausers/passwd",
                    (char const   */* __restrict  */)"r");
  }
#line 213
  if ((unsigned long )usersfile == (unsigned long )((void *)0)) {
#line 215
    return ((enum nss_status )-1);
  }
#line 218
  return ((enum nss_status )1);
}
}
#line 221 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_endpwent(void) 
{ 


  {
#line 223
  if ((unsigned long )usersfile != (unsigned long )((void *)0)) {
    {
#line 225
    fclose(usersfile);
#line 226
    usersfile = (FILE *)((void *)0);
    }
  }
#line 228
  return ((enum nss_status )1);
}
}
#line 231 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/passwd.c"
enum nss_status _nss_extrausers_getpwent_r(struct passwd *pw , char *buffer , size_t buflen ,
                                           int *errnop ) 
{ 
  enum nss_status tmp ;

  {
#line 232
  *errnop = -1;
#line 234
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 235
    return ((enum nss_status )-1);
  }
#line 236
  if ((unsigned long )usersfile == (unsigned long )((void *)0)) {
#line 237
    return ((enum nss_status )-1);
  }
  {
#line 239
  tmp = p_search(usersfile, (char const   *)((void *)0), (uid_t const   )0, pw, errnop,
                 buffer, buflen);
  }
#line 239
  return (tmp);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 47 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
enum nss_status _nss_extrausers_getspent_r(struct spwd *spw , char *buffer , size_t buflen ,
                                           int *errnop ) ;
#line 48
enum nss_status _nss_extrausers_getspnam_r(char const   *name , struct spwd *spw ,
                                           char *buffer , size_t buflen , int *errnop ) ;
#line 49
enum nss_status _nss_extrausers_setspent(void) ;
#line 50
enum nss_status _nss_extrausers_endspent(void) ;
#line 52
static enum nss_status shadow_search(FILE *stream , char const   *name , struct spwd *spw ,
                                     char *buffer , size_t buflen , int *errnop ) ;
#line 54 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
enum nss_status _nss_extrausers_getspnam_r(char const   *name , struct spwd *spw ,
                                           char *buffer , size_t buflen , int *errnop ) 
{ 
  FILE *stream ;
  enum nss_status s ;
  int *tmp ;

  {
#line 58
  if ((unsigned long )spw == (unsigned long )((void *)0)) {
#line 60
    *errnop = 1;
#line 61
    return ((enum nss_status )-1);
  } else
#line 58
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 60
    *errnop = 1;
#line 61
    return ((enum nss_status )-1);
  }
  {
#line 64
  stream = fopen((char const   */* __restrict  */)"/var/lib/extrausers/shadow", (char const   */* __restrict  */)"r");
  }
#line 65
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
#line 66
    tmp = __errno_location();
#line 66
    *errnop = *tmp;
    }
#line 67
    return ((enum nss_status )-1);
  }
  {
#line 69
  flockfile(stream);
#line 70
  s = shadow_search(stream, name, spw, buffer, buflen, errnop);
#line 71
  funlockfile(stream);
#line 72
  fclose(stream);
  }
#line 73
  return (s);
}
}
#line 76 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
static FILE *shadowfile  =    (FILE *)((void *)0);
#line 78 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
enum nss_status _nss_extrausers_setspent(void) 
{ 


  {
#line 80
  if ((unsigned long )shadowfile != (unsigned long )((void *)0)) {
    {
#line 81
    fclose(shadowfile);
#line 82
    shadowfile = (FILE *)((void *)0);
    }
  }
  {
#line 84
  shadowfile = fopen((char const   */* __restrict  */)"/var/lib/extrausers/shadow",
                     (char const   */* __restrict  */)"r");
  }
#line 85
  if ((unsigned long )shadowfile == (unsigned long )((void *)0)) {
#line 86
    return ((enum nss_status )-1);
  }
#line 89
  return ((enum nss_status )1);
}
}
#line 92 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
enum nss_status _nss_extrausers_endspent(void) 
{ 


  {
#line 94
  if ((unsigned long )shadowfile != (unsigned long )((void *)0)) {
    {
#line 95
    fclose(shadowfile);
#line 96
    shadowfile = (FILE *)((void *)0);
    }
  }
#line 98
  return ((enum nss_status )1);
}
}
#line 101 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
enum nss_status _nss_extrausers_getspent_r(struct spwd *spw , char *buffer , size_t buflen ,
                                           int *errnop ) 
{ 
  enum nss_status s ;
  int *tmp ;

  {
#line 104
  if ((unsigned long )spw == (unsigned long )((void *)0)) {
#line 105
    *errnop = 1;
#line 106
    return ((enum nss_status )-1);
  }
#line 109
  if ((unsigned long )shadowfile == (unsigned long )((void *)0)) {
    {
#line 110
    shadowfile = fopen((char const   */* __restrict  */)"/var/lib/extrausers/shadow",
                       (char const   */* __restrict  */)"r");
    }
#line 111
    if ((unsigned long )shadowfile == (unsigned long )((void *)0)) {
      {
#line 112
      tmp = __errno_location();
#line 112
      *errnop = *tmp;
      }
#line 113
      return ((enum nss_status )-1);
    }
  }
  {
#line 116
  flockfile(shadowfile);
#line 117
  s = shadow_search(shadowfile, (char const   *)((void *)0), spw, buffer, buflen,
                    errnop);
#line 118
  funlockfile(shadowfile);
  }
#line 119
  return (s);
}
}
#line 122 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/shadow.c"
static enum nss_status shadow_search(FILE *stream , char const   *name , struct spwd *spw ,
                                     char *buffer , size_t buflen , int *errnop ) 
{ 
  char *p ;
  char *h ;
  char *t_namp ;
  char *t_pwdp ;
  long t_lstchg ;
  long t_min ;
  long t_max ;
  long t_warn ;
  long t_inact ;
  long t_expire ;
  unsigned long t_flag ;
  int *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    *(buffer + (buflen - 1UL)) = (char )'\377';
#line 136
    p = fgets_unlocked((char */* __restrict  */)buffer, (int )buflen, (FILE */* __restrict  */)stream);
    }
#line 137
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 138
      tmp___0 = feof_unlocked(stream);
      }
#line 138
      if (tmp___0) {
#line 139
        *errnop = 2;
#line 140
        return ((enum nss_status )0);
      } else {
        {
#line 142
        tmp = __errno_location();
#line 142
        *errnop = *tmp;
        }
#line 143
        return ((enum nss_status )-1);
      }
    }
    {
#line 146
    h = index((char const   *)p, '\n');
    }
#line 147
    if ((int )*(buffer + (buflen - 1UL)) != -1) {
#line 148
      *errnop = 34;
#line 149
      return ((enum nss_status )-2);
    } else
#line 147
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 148
      *errnop = 34;
#line 149
      return ((enum nss_status )-2);
    }
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 151
      tmp___1 = __ctype_b_loc();
      }
#line 151
      if ((int const   )*(*tmp___1 + (int )*h) & 8192) {
#line 151
        if (! ((unsigned long )h >= (unsigned long )p)) {
#line 151
          goto while_break___0;
        }
      } else {
#line 151
        goto while_break___0;
      }
#line 152
      *h = (char )'\000';
#line 153
      h --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    if ((int )*p == 35) {
#line 157
      goto while_continue;
    }
    {
#line 160
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 160
      tmp___2 = __ctype_b_loc();
      }
#line 160
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 160
        goto while_break___1;
      }
#line 161
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 163
    if ((int )*p == 0) {
#line 164
      goto while_continue;
    }
#line 165
    t_namp = p;
    {
#line 166
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 166
      if (*p) {
#line 166
        if (! ((int )*p != 58)) {
#line 166
          goto while_break___2;
        }
      } else {
#line 166
        goto while_break___2;
      }
#line 166
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 166
    if ((int )*p != 58) {
#line 166
      *errnop = 0;
#line 166
      return ((enum nss_status )-1);
    } else {
#line 166
      tmp___3 = p;
#line 166
      p ++;
#line 166
      *tmp___3 = (char )'\000';
    }
#line 167
    if (name) {
      {
#line 167
      tmp___4 = strcmp(name, (char const   *)t_namp);
      }
#line 167
      if (tmp___4 != 0) {
#line 168
        goto while_continue;
      }
    }
    {
#line 170
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 170
      tmp___5 = __ctype_b_loc();
      }
#line 170
      if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 170
        goto while_break___3;
      }
#line 171
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 172
    t_pwdp = p;
    {
#line 173
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 173
      if (*p) {
#line 173
        if (! ((int )*p != 58)) {
#line 173
          goto while_break___4;
        }
      } else {
#line 173
        goto while_break___4;
      }
#line 173
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 173
    if ((int )*p != 58) {
#line 173
      *errnop = 0;
#line 173
      return ((enum nss_status )-1);
    } else {
#line 173
      tmp___6 = p;
#line 173
      p ++;
#line 173
      *tmp___6 = (char )'\000';
    }
#line 184
    if ((int )*p == 58) {
#line 184
      t_lstchg = -1L;
#line 184
      tmp___7 = p;
#line 184
      p ++;
#line 184
      *tmp___7 = (char )'\000';
    } else {
      {
#line 184
      t_lstchg = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                        10);
#line 184
      p = h;
      }
#line 184
      if ((int )*p != 58) {
#line 184
        *errnop = 0;
#line 184
        return ((enum nss_status )-1);
      } else {
#line 184
        tmp___8 = p;
#line 184
        p ++;
#line 184
        *tmp___8 = (char )'\000';
      }
    }
#line 186
    if ((int )*p == 58) {
#line 186
      t_min = -1L;
#line 186
      tmp___9 = p;
#line 186
      p ++;
#line 186
      *tmp___9 = (char )'\000';
    } else {
      {
#line 186
      t_min = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
#line 186
      p = h;
      }
#line 186
      if ((int )*p != 58) {
#line 186
        *errnop = 0;
#line 186
        return ((enum nss_status )-1);
      } else {
#line 186
        tmp___10 = p;
#line 186
        p ++;
#line 186
        *tmp___10 = (char )'\000';
      }
    }
#line 188
    if ((int )*p == 58) {
#line 188
      t_max = -1L;
#line 188
      tmp___11 = p;
#line 188
      p ++;
#line 188
      *tmp___11 = (char )'\000';
    } else {
      {
#line 188
      t_max = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
#line 188
      p = h;
      }
#line 188
      if ((int )*p != 58) {
#line 188
        *errnop = 0;
#line 188
        return ((enum nss_status )-1);
      } else {
#line 188
        tmp___12 = p;
#line 188
        p ++;
#line 188
        *tmp___12 = (char )'\000';
      }
    }
#line 190
    if ((int )*p == 58) {
#line 190
      t_warn = -1L;
#line 190
      tmp___13 = p;
#line 190
      p ++;
#line 190
      *tmp___13 = (char )'\000';
    } else {
      {
#line 190
      t_warn = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                      10);
#line 190
      p = h;
      }
#line 190
      if ((int )*p != 58) {
#line 190
        *errnop = 0;
#line 190
        return ((enum nss_status )-1);
      } else {
#line 190
        tmp___14 = p;
#line 190
        p ++;
#line 190
        *tmp___14 = (char )'\000';
      }
    }
#line 192
    if ((int )*p == 58) {
#line 192
      t_inact = -1L;
#line 192
      tmp___15 = p;
#line 192
      p ++;
#line 192
      *tmp___15 = (char )'\000';
    } else {
      {
#line 192
      t_inact = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                       10);
#line 192
      p = h;
      }
#line 192
      if ((int )*p != 58) {
#line 192
        *errnop = 0;
#line 192
        return ((enum nss_status )-1);
      } else {
#line 192
        tmp___16 = p;
#line 192
        p ++;
#line 192
        *tmp___16 = (char )'\000';
      }
    }
#line 194
    if ((int )*p == 58) {
#line 194
      t_expire = -1L;
#line 194
      tmp___17 = p;
#line 194
      p ++;
#line 194
      *tmp___17 = (char )'\000';
    } else {
      {
#line 194
      t_expire = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                        10);
#line 194
      p = h;
      }
#line 194
      if ((int )*p != 58) {
#line 194
        *errnop = 0;
#line 194
        return ((enum nss_status )-1);
      } else {
#line 194
        tmp___18 = p;
#line 194
        p ++;
#line 194
        *tmp___18 = (char )'\000';
      }
    }
    {
#line 197
    t_flag = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
    }
#line 198
    if ((int )*h != 0) {
#line 199
      *errnop = 0;
#line 200
      return ((enum nss_status )-1);
    } else
#line 201
    if ((unsigned long )p == (unsigned long )h) {
#line 202
      t_flag = 0xffffffffffffffffUL;
    }
#line 203
    *errnop = 0;
#line 204
    spw->sp_namp = t_namp;
#line 205
    spw->sp_pwdp = t_pwdp;
#line 206
    spw->sp_lstchg = t_lstchg;
#line 207
    spw->sp_min = t_min;
#line 208
    spw->sp_max = t_max;
#line 209
    spw->sp_warn = t_warn;
#line 210
    spw->sp_inact = t_inact;
#line 211
    spw->sp_expire = t_expire;
#line 212
    spw->sp_flag = t_flag;
#line 213
    return ((enum nss_status )1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 781 "/usr/include/stdio.h"
extern int fseeko(FILE *__stream , __off64_t __off , int __whence )  __asm__("fseeko64")  ;
#line 784
extern __off64_t ftello(FILE *__stream )  __asm__("ftello64")  ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 46 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_setgrent(void) ;
#line 47
enum nss_status _nss_extrausers_endgrent(void) ;
#line 48
enum nss_status _nss_extrausers_getgrent_r(struct group *gr , char *buffer , size_t buflen ,
                                           int *errnop ) ;
#line 49
enum nss_status _nss_extrausers_getgrnam_r(char const   *name , struct group *gr ,
                                           char *buffer , size_t buflen , int *errnop ) ;
#line 50
enum nss_status _nss_extrausers_getgrgid_r(gid_t const   gid , struct group *gr ,
                                           char *buffer , size_t buflen , int *errnop ) ;
#line 52 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
static FILE *groupsfile  =    (FILE *)((void *)0);
#line 55 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
__inline static char **parse_list(char *line , char *data , size_t datalen , int *errnop ) 
{ 
  char *eol ;
  char **list ;
  char **p ;
  char *tmp ;
  char *elt ;
  unsigned short const   **tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;

  {
#line 58
  if ((unsigned long )line >= (unsigned long )data) {
#line 58
    if ((unsigned long )line < (unsigned long )(data + datalen)) {
      {
#line 61
      tmp = strchr((char const   *)line, '\000');
#line 61
      eol = tmp + 1;
      }
    } else {
#line 66
      eol = data;
    }
  } else {
#line 66
    eol = data;
  }
#line 68
  eol += __alignof__(char *) - 1UL;
#line 69
  eol -= (unsigned long )(eol - (char *)0) % __alignof__(char *);
#line 71
  list = (char **)eol;
#line 73
  p = list;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if ((size_t )((char *)(p + 1) - data) > datalen) {
#line 81
      *errnop = 34;
#line 82
      return ((char **)((void *)0));
    }
#line 84
    if ((int )*line == 0) {
#line 85
      goto while_break;
    }
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 88
      tmp___0 = __ctype_b_loc();
      }
#line 88
      if (! ((int const   )*(*tmp___0 + (int )*line) & 8192)) {
#line 88
        goto while_break___0;
      }
#line 89
      line ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    elt = line;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if ((int )*line == 0) {
#line 93
        goto _L;
      } else
#line 93
      if ((int )*line == 44) {
        _L: /* CIL Label */ 
#line 95
        if ((unsigned long )line > (unsigned long )elt) {
#line 97
          tmp___1 = p;
#line 97
          p ++;
#line 97
          *tmp___1 = elt;
        }
#line 100
        if ((int )*line != 0) {
#line 101
          tmp___2 = line;
#line 101
          line ++;
#line 101
          *tmp___2 = (char )'\000';
        }
#line 102
        goto while_break___1;
      }
#line 104
      line ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *p = (char *)((void *)0);
#line 109
  return (list);
}
}
#line 124 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
__inline static enum nss_status g_search(FILE *stream , char const   *name , gid_t const   gid ,
                                         struct group *gr , int *errnop , char *buffer ,
                                         size_t buflen ) 
{ 
  char *p ;
  char *h ;
  gid_t t_gid ;
  char *t_name ;
  char *t_passwd ;
  char **t_mem ;
  off_t last_position ;
  int *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  long tmp___7 ;

  {
#line 131
  if (gid != 0U) {
#line 131
    if (gid < 500U) {
#line 132
      *errnop = 2;
#line 133
      return ((enum nss_status )0);
    }
  }
  {
#line 136
  last_position = ftello(stream);
#line 137
  flockfile(stream);
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    *(buffer + (buflen - 1UL)) = (char )'\377';
#line 140
    p = fgets_unlocked((char */* __restrict  */)buffer, (int )buflen, (FILE */* __restrict  */)stream);
    }
#line 141
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 142
      tmp___0 = feof_unlocked(stream);
      }
#line 142
      if (tmp___0) {
        {
#line 143
        funlockfile(stream);
#line 144
        *errnop = 2;
        }
#line 145
        return ((enum nss_status )0);
      } else {
        {
#line 147
        funlockfile(stream);
#line 148
        tmp = __errno_location();
#line 148
        *errnop = *tmp;
        }
#line 149
        return ((enum nss_status )-1);
      }
    }
    {
#line 152
    h = index((char const   *)p, '\n');
    }
#line 153
    if ((int )*(buffer + (buflen - 1UL)) != -1) {
      {
#line 154
      funlockfile(stream);
#line 155
      *errnop = 34;
#line 156
      fseeko(stream, last_position, 0);
      }
#line 157
      return ((enum nss_status )-2);
    } else
#line 153
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
#line 154
      funlockfile(stream);
#line 155
      *errnop = 34;
#line 156
      fseeko(stream, last_position, 0);
      }
#line 157
      return ((enum nss_status )-2);
    }
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 159
      tmp___1 = __ctype_b_loc();
      }
#line 159
      if ((int const   )*(*tmp___1 + (int )*h) & 8192) {
#line 159
        if (! ((unsigned long )h != (unsigned long )p)) {
#line 159
          goto while_break___0;
        }
      } else {
#line 159
        goto while_break___0;
      }
#line 160
      *h = (char )'\000';
#line 161
      h --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 164
    if ((int )*p == 35) {
#line 165
      goto while_continue;
    }
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 168
        goto while_break___1;
      }
#line 169
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    if ((int )*p == 0) {
#line 172
      goto while_continue;
    }
#line 173
    t_name = p;
    {
#line 174
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 174
      if (*p) {
#line 174
        if (! ((int )*p != 58)) {
#line 174
          goto while_break___2;
        }
      } else {
#line 174
        goto while_break___2;
      }
#line 174
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 174
    h = p;
#line 174
    if (*p) {
#line 174
      p ++;
    }
#line 174
    *h = (char )'\000';
#line 174
    h --;
    {
#line 174
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 174
      tmp___3 = __ctype_b_loc();
      }
#line 174
      if (! ((int const   )*(*tmp___3 + (int )*h) & 8192)) {
#line 174
        goto while_break___3;
      }
#line 174
      *h = (char )'\000';
#line 174
      h --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 175
    if (name) {
      {
#line 175
      tmp___4 = strcmp(name, (char const   *)t_name);
      }
#line 175
      if (tmp___4 != 0) {
#line 176
        goto while_continue;
      }
    }
    {
#line 178
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 178
      tmp___5 = __ctype_b_loc();
      }
#line 178
      if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 178
        goto while_break___4;
      }
#line 179
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 180
    t_passwd = p;
    {
#line 181
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 181
      if (*p) {
#line 181
        if (! ((int )*p != 58)) {
#line 181
          goto while_break___5;
        }
      } else {
#line 181
        goto while_break___5;
      }
#line 181
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 181
    h = p;
#line 181
    if (*p) {
#line 181
      p ++;
    }
#line 181
    *h = (char )'\000';
#line 181
    h --;
    {
#line 181
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 181
      tmp___6 = __ctype_b_loc();
      }
#line 181
      if (! ((int const   )*(*tmp___6 + (int )*h) & 8192)) {
#line 181
        goto while_break___6;
      }
#line 181
      *h = (char )'\000';
#line 181
      h --;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 183
    tmp___7 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& h),
                     10);
#line 183
    t_gid = (gid_t )tmp___7;
    }
#line 184
    if ((int )*h != 58) {
      {
#line 185
      funlockfile(stream);
#line 186
      *errnop = 0;
      }
#line 187
      return ((enum nss_status )-1);
    }
#line 189
    if (gid != 0U) {
#line 189
      if (gid != (gid_t const   )t_gid) {
#line 190
        goto while_continue;
      }
    }
#line 192
    if (t_gid < 500U) {
#line 193
      goto while_continue;
    }
    {
#line 195
    p = h;
#line 197
    h ++;
#line 198
    t_mem = parse_list(h, buffer, buflen, errnop);
    }
#line 199
    if ((unsigned long )t_mem == (unsigned long )((void *)0)) {
      {
#line 200
      funlockfile(stream);
#line 201
      fseeko(stream, last_position, 0);
      }
#line 202
      return ((enum nss_status )-2);
    }
    {
#line 204
    funlockfile(stream);
#line 205
    *errnop = 0;
#line 206
    gr->gr_name = t_name;
#line 207
    gr->gr_passwd = t_passwd;
#line 208
    gr->gr_gid = t_gid;
#line 209
    gr->gr_mem = t_mem;
    }
#line 210
    return ((enum nss_status )1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 215 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_setgrent(void) 
{ 


  {
  {
#line 216
  groupsfile = fopen((char const   */* __restrict  */)"/var/lib/extrausers/group",
                     (char const   */* __restrict  */)"r");
  }
#line 217
  if ((unsigned long )groupsfile == (unsigned long )((void *)0)) {
#line 218
    return ((enum nss_status )-1);
  }
#line 219
  return ((enum nss_status )1);
}
}
#line 222 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_endgrent(void) 
{ 


  {
#line 223
  if ((unsigned long )groupsfile != (unsigned long )((void *)0)) {
    {
#line 224
    fclose(groupsfile);
#line 225
    groupsfile = (FILE *)((void *)0);
    }
  }
#line 227
  return ((enum nss_status )1);
}
}
#line 230 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_getgrent_r(struct group *gr , char *buffer , size_t buflen ,
                                           int *errnop ) 
{ 
  enum nss_status tmp ;

  {
#line 231
  *errnop = 0;
#line 232
  if ((unsigned long )groupsfile == (unsigned long )((void *)0)) {
#line 233
    return ((enum nss_status )-1);
  }
  {
#line 235
  tmp = g_search(groupsfile, (char const   *)((void *)0), (gid_t const   )0, gr, errnop,
                 buffer, buflen);
  }
#line 235
  return (tmp);
}
}
#line 239 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_getgrnam_r(char const   *name , struct group *gr ,
                                           char *buffer , size_t buflen , int *errnop ) 
{ 
  enum nss_status e ;
  FILE *f ;
  int *tmp ;

  {
#line 243
  *errnop = 0;
#line 245
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
#line 246
    return ((enum nss_status )-1);
  } else
#line 245
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 246
    return ((enum nss_status )-1);
  }
  {
#line 248
  f = fopen((char const   */* __restrict  */)"/var/lib/extrausers/group", (char const   */* __restrict  */)"r");
  }
#line 249
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 250
    tmp = __errno_location();
#line 250
    *errnop = *tmp;
    }
#line 251
    return ((enum nss_status )-1);
  }
  {
#line 254
  e = g_search(f, name, (gid_t const   )0, gr, errnop, buffer, buflen);
#line 255
  fclose(f);
  }
#line 256
  return (e);
}
}
#line 259 "/home/wheatley/newnew/temp/libnss-extrausers-0.6/group.c"
enum nss_status _nss_extrausers_getgrgid_r(gid_t const   gid , struct group *gr ,
                                           char *buffer , size_t buflen , int *errnop ) 
{ 
  enum nss_status e ;
  FILE *f ;
  int *tmp ;

  {
#line 262
  *errnop = 0;
#line 263
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
#line 264
    return ((enum nss_status )-1);
  }
#line 265
  if (gid == 0U) {
#line 266
    return ((enum nss_status )0);
  } else
#line 265
  if (gid < 500U) {
#line 266
    return ((enum nss_status )0);
  }
  {
#line 268
  f = fopen((char const   */* __restrict  */)"/var/lib/extrausers/group", (char const   */* __restrict  */)"r");
  }
#line 269
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 270
    tmp = __errno_location();
#line 270
    *errnop = *tmp;
    }
#line 271
    return ((enum nss_status )-1);
  }
  {
#line 274
  e = g_search(f, (char const   *)((void *)0), gid, gr, errnop, buffer, buflen);
#line 275
  fclose(f);
  }
#line 276
  return (e);
}
}
