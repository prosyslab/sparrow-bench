/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_3 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_4 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_3 __wait_terminated ;
   struct __anonstruct___wait_stopped_4 __wait_stopped ;
};
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 223 "/home/june/collector/temp/buffer-1.19/buffer.c"
struct block {
   int bytes ;
   char *data ;
};
#line 229 "/home/june/collector/temp/buffer-1.19/buffer.c"
struct buffer {
   int semid ;
   int blocks_used_lock ;
   int blocks_free_lock ;
   int next_block_in ;
   int next_block_out ;
   struct block block[2048] ;
   char data_space[1] ;
};
#line 907 "/home/june/collector/temp/buffer-1.19/buffer.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 907 "/home/june/collector/temp/buffer-1.19/buffer.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 38 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __glibc_reserved1 ;
   __time_t sem_ctime ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 45 "/home/june/collector/temp/buffer-1.19/sem.c"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 459 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmctl)(int __shmid ,
                                                                             int __cmd ,
                                                                             struct shmid_ds *__buf ) ;
#line 53
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 125
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 30 "/home/june/collector/temp/buffer-1.19/sem.h"
int new_sems(int nsems ) ;
#line 33
void sem_set(int sem_id , int semn , int val ) ;
#line 34
void lock(int sem_id , int semn ) ;
#line 35
void unlock(int sem_id , int semn ) ;
#line 36
void remove_sems(int sem_id ) ;
#line 152 "/home/june/collector/temp/buffer-1.19/buffer.c"
void byee(int exit_val ) ;
#line 153
void start_reader_and_writer(void) ;
#line 154
void parse_args(int argc , char **argv ) ;
#line 155
void set_handlers(void) ;
#line 156
void buffer_allocate(void) ;
#line 157
void report_proc(void) ;
#line 158
int do_size(char *arg ) ;
#line 159
void get_buffer(void) ;
#line 160
void reader(void) ;
#line 161
void writer(void) ;
#line 163
void wait_for_writer_end(void) ;
#line 164
void get_next_free_block(void) ;
#line 165
void test_writer(void) ;
#line 166
int fill_block(void) ;
#line 167
void get_next_filled_block(void) ;
#line 168
int data_to_write(void) ;
#line 169
void write_blocks_to_stdout(int filled , int first_block ) ;
#line 170
void write_block_to_stdout(void) ;
#line 171
void pr_out(void) ;
#line 172
void end_writer(void) ;
#line 175 "/home/june/collector/temp/buffer-1.19/buffer.c"
int showevery  =    0;
#line 179 "/home/june/collector/temp/buffer-1.19/buffer.c"
unsigned int write_pause  ;
#line 198 "/home/june/collector/temp/buffer-1.19/buffer.c"
int blocksize  =    10240;
#line 201 "/home/june/collector/temp/buffer-1.19/buffer.c"
char *proc_string  =    (char *)"buffer";
#line 206 "/home/june/collector/temp/buffer-1.19/buffer.c"
int blocks  =    1;
#line 216 "/home/june/collector/temp/buffer-1.19/buffer.c"
int max_shmem  =    1048576;
#line 222 "/home/june/collector/temp/buffer-1.19/buffer.c"
int buffer_id  =    -1;
#line 223 "/home/june/collector/temp/buffer-1.19/buffer.c"
struct block *curr_block  ;
#line 229 "/home/june/collector/temp/buffer-1.19/buffer.c"
struct buffer *pbuffer  =    (struct buffer *)-1;
#line 247 "/home/june/collector/temp/buffer-1.19/buffer.c"
int buffer_size  ;
#line 249 "/home/june/collector/temp/buffer-1.19/buffer.c"
int fdin  =    0;
#line 250 "/home/june/collector/temp/buffer-1.19/buffer.c"
int fdout  =    1;
#line 251 "/home/june/collector/temp/buffer-1.19/buffer.c"
int in_ISCHR  =    0;
#line 252 "/home/june/collector/temp/buffer-1.19/buffer.c"
int out_ISCHR  =    0;
#line 253 "/home/june/collector/temp/buffer-1.19/buffer.c"
int padblock  =    0;
#line 254 "/home/june/collector/temp/buffer-1.19/buffer.c"
int writer_pid  =    0;
#line 255 "/home/june/collector/temp/buffer-1.19/buffer.c"
int reader_pid  =    0;
#line 256 "/home/june/collector/temp/buffer-1.19/buffer.c"
int free_shm  =    1;
#line 257 "/home/june/collector/temp/buffer-1.19/buffer.c"
int percent  =    0;
#line 258 "/home/june/collector/temp/buffer-1.19/buffer.c"
int debug  =    0;
#line 259 "/home/june/collector/temp/buffer-1.19/buffer.c"
int Zflag  =    0;
#line 260 "/home/june/collector/temp/buffer-1.19/buffer.c"
int writer_status  =    0;
#line 261 "/home/june/collector/temp/buffer-1.19/buffer.c"
char *progname  =    (char *)"buffer";
#line 263 "/home/june/collector/temp/buffer-1.19/buffer.c"
char print_total  =    (char)0;
#line 265 "/home/june/collector/temp/buffer-1.19/buffer.c"
unsigned long long outk  =    0ULL;
#line 267 "/home/june/collector/temp/buffer-1.19/buffer.c"
struct timeval starttime  ;
#line 269 "/home/june/collector/temp/buffer-1.19/buffer.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 274
  parse_args(argc, argv);
#line 276
  set_handlers();
#line 278
  buffer_allocate();
#line 280
  gettimeofday((struct timeval */* __restrict  */)(& starttime), (__timezone_ptr_t )((void *)0));
#line 282
  start_reader_and_writer();
#line 284
  byee(0);
#line 287
  exit(0);
  }
}
}
#line 290 "/home/june/collector/temp/buffer-1.19/buffer.c"
void parse_args(int argc , char **argv ) 
{ 
  int c ;
  int iflag ;
  int oflag ;
  int zflag ;
  char blocks_given ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 296
  iflag = 0;
#line 297
  oflag = 0;
#line 298
  zflag = 0;
#line 300
  blocks_given = (char)0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 304
    c = getopt(argc, (char * const  *)argv, "BS:Zdm:s:b:p:u:ti:o:z:");
    }
#line 304
    if (! (c != -1)) {
#line 304
      goto while_break;
    }
    {
#line 306
    if (c == 116) {
#line 306
      goto case_116;
    }
#line 309
    if (c == 117) {
#line 309
      goto case_117;
    }
#line 312
    if (c == 66) {
#line 312
      goto case_66;
    }
#line 315
    if (c == 90) {
#line 315
      goto case_90;
    }
#line 318
    if (c == 105) {
#line 318
      goto case_105;
    }
#line 332
    if (c == 111) {
#line 332
      goto case_111;
    }
#line 346
    if (c == 83) {
#line 346
      goto case_83;
    }
#line 352
    if (c == 100) {
#line 352
      goto case_100;
    }
#line 360
    if (c == 109) {
#line 360
      goto case_109;
    }
#line 369
    if (c == 98) {
#line 369
      goto case_98;
    }
#line 378
    if (c == 112) {
#line 378
      goto case_112;
    }
#line 388
    if (c == 122) {
#line 388
      goto case_122;
    }
#line 391
    if (c == 115) {
#line 391
      goto case_115;
    }
#line 399
    goto switch_default;
    case_116: /* CIL Label */ 
#line 307
    print_total = (char )((int )print_total + 1);
#line 308
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 310
    tmp = atoi((char const   *)optarg);
#line 310
    write_pause = (unsigned int )tmp;
    }
#line 311
    goto switch_break;
    case_66: /* CIL Label */ 
#line 313
    padblock = 1;
#line 314
    goto switch_break;
    case_90: /* CIL Label */ 
#line 316
    Zflag = 1;
#line 317
    goto switch_break;
    case_105: /* CIL Label */ 
#line 319
    iflag ++;
#line 320
    if (iflag > 1) {
      {
#line 321
      report_proc();
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-i given twice\n");
#line 323
      byee(-1);
      }
    }
    {
#line 325
    fdin = open((char const   *)optarg, 0);
    }
#line 325
    if (fdin < 0) {
      {
#line 326
      report_proc();
#line 327
      perror("cannot open input file");
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filename: %s\n",
              optarg);
#line 329
      byee(-1);
      }
    }
#line 331
    goto switch_break;
    case_111: /* CIL Label */ 
#line 333
    oflag ++;
#line 334
    if (oflag > 1) {
      {
#line 335
      report_proc();
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-o given twice\n");
#line 337
      byee(-1);
      }
    }
    {
#line 339
    fdout = open((char const   *)optarg, 577, 438);
    }
#line 339
    if (fdout < 0) {
      {
#line 340
      report_proc();
#line 341
      perror("cannot open output file");
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filename: %s\n",
              optarg);
#line 343
      byee(-1);
      }
    }
#line 345
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 348
    showevery = do_size(optarg);
    }
#line 349
    if (showevery <= 0) {
#line 350
      showevery = 10240;
    }
#line 351
    goto switch_break;
    case_100: /* CIL Label */ 
#line 353
    debug ++;
#line 354
    if (debug == 1) {
      {
#line 355
      setbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0));
#line 356
      setbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((void *)0));
#line 357
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debugging turned on\n");
      }
    }
#line 359
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 362
    max_shmem = do_size(optarg);
    }
#line 364
    if ((unsigned long )max_shmem < sizeof(struct buffer ) + (unsigned long )(blocksize * blocks)) {
      {
#line 365
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"max_shmem %d too low\n",
              max_shmem);
#line 366
      byee(-1);
      }
    }
#line 368
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 371
    blocks_given = (char)1;
#line 372
    blocks = atoi((char const   *)optarg);
    }
#line 373
    if (blocks <= 0) {
      {
#line 374
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"blocks %d out of range\n",
              blocks);
#line 375
      byee(-1);
      }
    } else
#line 373
    if (2048 < blocks) {
      {
#line 374
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"blocks %d out of range\n",
              blocks);
#line 375
      byee(-1);
      }
    }
#line 377
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 379
    percent = atoi((char const   *)optarg);
    }
#line 381
    if (percent < 0) {
      {
#line 382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent %d out of range\n",
              percent);
#line 383
      byee(-1);
      }
    } else
#line 381
    if (100 < percent) {
      {
#line 382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent %d out of range\n",
              percent);
#line 383
      byee(-1);
      }
    }
#line 385
    if (debug) {
      {
#line 386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent set to %d\n",
              percent);
      }
    }
#line 387
    goto switch_break;
    case_122: /* CIL Label */ 
#line 389
    zflag ++;
    case_115: /* CIL Label */ 
    {
#line 392
    blocksize = do_size(optarg);
    }
#line 394
    if (blocksize <= 0) {
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"blocksize %d out of range\n",
              blocksize);
#line 396
      byee(-1);
      }
    } else
#line 394
    if (524288 < blocksize) {
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"blocksize %d out of range\n",
              blocksize);
#line 396
      byee(-1);
      }
    }
#line 398
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 400
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-B] [-t] [-S size] [-m memsize] [-b blocks] [-p percent] [-s blocksize] [-u pause] [-i infile] [-o outfile] [-z size] [-Z] [-d]\n",
            progname);
#line 402
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-B = blocked device - pad out last block\n");
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-t = show total amount written at end\n");
#line 404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-S size = show amount written every size bytes\n");
#line 405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-m size = size of shared mem chunk to grab\n");
#line 406
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-b num = number of blocks in queue\n");
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-p percent = don\'t start writing until percent blocks filled\n");
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-s size = size of a block\n");
#line 409
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u usecs = microseconds to sleep after each write\n");
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-i infile = file to read from\n");
#line 411
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-o outfile = file to write to\n");
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-z size = combined -S/-s flag\n");
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-Z = seek to beginning of output after each 1GB (for some tape drives)\n");
#line 414
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-d = print debug information to stderr\n");
#line 415
    byee(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  if (argc > optind) {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many arguments\n");
#line 421
    byee(-1);
    }
  }
#line 424
  if (zflag) {
#line 424
    showevery = blocksize;
  }
#line 427
  if (! blocks_given) {
#line 428
    blocks = (int )(((unsigned long )max_shmem - sizeof(struct buffer )) / (unsigned long )blocksize);
#line 429
    if (blocks <= 0) {
      {
#line 430
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot handle blocks that big, aborting!\n");
#line 431
      byee(-1);
      }
    }
#line 433
    if (2048 < blocks) {
      {
#line 434
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot handle that many blocks, aborting!\n");
#line 435
      byee(-1);
      }
    }
  }
  {
#line 440
  tmp___0 = fstat(fdin, & buf);
  }
#line 440
  if (tmp___0 != 0) {
    {
#line 441
    report_proc();
#line 442
    perror("can\'t stat input file");
#line 443
    byee(-1);
    }
  }
  {
#line 445
  in_ISCHR = (buf.st_mode & 61440U) == 8192U;
#line 446
  tmp___1 = fstat(fdout, & buf);
  }
#line 446
  if (tmp___1 != 0) {
    {
#line 447
    report_proc();
#line 448
    perror("can\'t stat output file");
#line 449
    byee(-1);
    }
  }
#line 451
  out_ISCHR = (buf.st_mode & 61440U) == 8192U;
#line 452
  return;
}
}
#line 458 "/home/june/collector/temp/buffer-1.19/buffer.c"
static int shutting  ;
#line 455 "/home/june/collector/temp/buffer-1.19/buffer.c"
void shutdown(void) 
{ 


  {
#line 459
  if (shutting) {
#line 460
    if (debug) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ALREADY SHUTTING!\n",
              proc_string);
      }
    }
#line 462
    return;
  }
#line 464
  shutting = 1;
#line 465
  if (debug) {
    {
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: shutdown on signal\n",
            proc_string);
    }
  }
  {
#line 468
  byee(-1);
  }
#line 469
  return;
}
}
#line 472 "/home/june/collector/temp/buffer-1.19/buffer.c"
void child_shutdown(void) 
{ 
  int deadpid ;

  {
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    deadpid = waitpid(-1, & writer_status, 1);
    }
#line 481
    if (deadpid) {
#line 481
      if (deadpid != -1) {
#line 481
        if (! (deadpid != 0)) {
#line 481
          goto while_break;
        }
      } else {
#line 481
        goto while_break;
      }
    } else {
#line 481
      goto while_break;
    }
#line 483
    if (debug > 2) {
      {
#line 484
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"child_shutdown %d: 0x%04x\n",
              deadpid, writer_status);
      }
    }
#line 485
    if (deadpid == writer_pid) {
#line 486
      if (debug > 2) {
        {
#line 487
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writer has ended\n");
        }
      }
      {
#line 488
      writer_pid = 0;
#line 489
      byee(0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 494 "/home/june/collector/temp/buffer-1.19/buffer.c"
void set_handlers(void) 
{ 


  {
#line 497
  if (debug) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: setting handlers\n",
            proc_string);
    }
  }
  {
#line 500
  signal(1, (void (*)(int  ))(& shutdown));
#line 501
  signal(2, (void (*)(int  ))(& shutdown));
#line 502
  signal(3, (void (*)(int  ))(& shutdown));
#line 503
  signal(15, (void (*)(int  ))(& shutdown));
#line 505
  signal(17, (void (*)(int  ))(& child_shutdown));
  }
#line 511
  return;
}
}
#line 513 "/home/june/collector/temp/buffer-1.19/buffer.c"
void buffer_allocate(void) 
{ 


  {
  {
#line 517
  buffer_size = (int )(sizeof(struct buffer ) + ((unsigned long )(blocks * blocksize) - sizeof(char )));
#line 521
  buffer_id = shmget(0, (size_t )buffer_size, 896);
  }
#line 524
  if (buffer_id < 0) {
    {
#line 525
    report_proc();
#line 526
    perror("couldn\'t create shared memory segment");
#line 527
    byee(-1);
    }
  }
  {
#line 530
  get_buffer();
  }
#line 532
  if (debug) {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s pbuffer is 0x%08lx, buffer_size is %d [%d x %d]\n",
            proc_string, (unsigned long )pbuffer, buffer_size, blocks, blocksize);
    }
  }
  {
#line 540
  bzero((void *)(pbuffer->data_space), (size_t )(blocks * blocksize));
#line 542
  pbuffer->semid = -1;
#line 543
  pbuffer->blocks_used_lock = -1;
#line 544
  pbuffer->blocks_free_lock = -1;
#line 546
  pbuffer->semid = new_sems(2);
#line 547
  pbuffer->blocks_used_lock = 0;
#line 549
  lock(pbuffer->semid, pbuffer->blocks_used_lock);
#line 551
  pbuffer->blocks_free_lock = 1;
#line 563
  sem_set(pbuffer->semid, pbuffer->blocks_free_lock, blocks);
  }
#line 579
  return;
}
}
#line 584
void buffer_remove(void) ;
#line 584 "/home/june/collector/temp/buffer-1.19/buffer.c"
static char removing  =    (char)0;
#line 581 "/home/june/collector/temp/buffer-1.19/buffer.c"
void buffer_remove(void) 
{ 
  int tmp ;

  {
#line 587
  if (removing) {
#line 588
    return;
  }
#line 589
  removing = (char)1;
#line 592
  if (buffer_id == -1) {
#line 593
    return;
  }
#line 597
  if ((unsigned long )pbuffer == (unsigned long )((struct buffer *)-1)) {
    {
#line 598
    get_buffer();
    }
  }
#line 600
  if (debug) {
    {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: removing semaphores and buffer\n",
            proc_string);
    }
  }
  {
#line 602
  remove_sems(pbuffer->semid);
#line 604
  tmp = shmctl(buffer_id, 0, (struct shmid_ds *)0);
  }
#line 604
  if (tmp == -1) {
    {
#line 605
    report_proc();
#line 606
    perror("failed to remove shared memory buffer");
    }
  }
#line 608
  return;
}
}
#line 610 "/home/june/collector/temp/buffer-1.19/buffer.c"
void get_buffer(void) 
{ 
  int b ;
  void *tmp ;

  {
  {
#line 616
  tmp = shmat(buffer_id, (void const   *)((char *)0), 0);
#line 616
  pbuffer = (struct buffer *)tmp;
  }
#line 617
  if ((unsigned long )pbuffer == (unsigned long )((struct buffer *)-1)) {
    {
#line 618
    report_proc();
#line 619
    perror("failed to attach shared memory");
#line 620
    byee(-1);
    }
  }
#line 624
  b = 0;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (b < blocks)) {
#line 624
      goto while_break;
    }
#line 625
    pbuffer->block[b].data = & pbuffer->data_space[b * blocksize];
#line 624
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return;
}
}
#line 630 "/home/june/collector/temp/buffer-1.19/buffer.c"
void start_reader_and_writer(void) 
{ 


  {
  {
#line 633
  fflush(stdout);
#line 634
  fflush(stderr);
#line 636
  writer_pid = fork();
  }
#line 636
  if (writer_pid == -1) {
    {
#line 637
    report_proc();
#line 638
    perror("unable to fork");
#line 639
    byee(-1);
    }
  } else
#line 641
  if (writer_pid == 0) {
    {
#line 642
    free_shm = 0;
#line 643
    proc_string = (char *)"buffer (writer)";
#line 644
    reader_pid = getppid();
#line 647
    set_handlers();
#line 649
    writer();
    }
  } else {
    {
#line 652
    proc_string = (char *)"buffer (reader)";
#line 653
    reader();
#line 655
    wait_for_writer_end();
    }
  }
#line 657
  return;
}
}
#line 660 "/home/june/collector/temp/buffer-1.19/buffer.c"
void reader(void) 
{ 
  int tmp ;

  {
#line 663
  if (debug) {
    {
#line 664
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"R: Entering reader\n");
    }
  }
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 667
    get_next_free_block();
#line 668
    tmp = fill_block();
    }
#line 668
    if (! tmp) {
#line 669
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  if (debug) {
    {
#line 673
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"R: Exiting reader\n");
    }
  }
#line 674
  return;
}
}
#line 676 "/home/june/collector/temp/buffer-1.19/buffer.c"
void get_next_free_block(void) 
{ 


  {
  {
#line 679
  test_writer();
#line 682
  lock(pbuffer->semid, pbuffer->blocks_free_lock);
#line 684
  curr_block = & pbuffer->block[pbuffer->next_block_in];
  }
#line 686
  if (pbuffer->next_block_in + 1 == blocks) {
#line 686
    pbuffer->next_block_in = 0;
  } else {
#line 686
    (pbuffer->next_block_in) ++;
  }
#line 687
  return;
}
}
#line 695 "/home/june/collector/temp/buffer-1.19/buffer.c"
static char eof_reached  =    (char)0;
#line 689 "/home/june/collector/temp/buffer-1.19/buffer.c"
int fill_block(void) 
{ 
  int bytes ;
  char *start ;
  int toread ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 692
  bytes = 0;
#line 697
  if (eof_reached) {
    {
#line 698
    curr_block->bytes = 0;
#line 699
    unlock(pbuffer->semid, pbuffer->blocks_used_lock);
    }
#line 700
    return (0);
  }
#line 703
  start = curr_block->data;
#line 704
  toread = blocksize;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (toread != 0)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp = read(fdin, (void *)start, (size_t )toread);
#line 708
    bytes = (int )tmp;
    }
#line 709
    if (bytes <= 0) {
#line 712
      if (bytes < 0) {
        {
#line 712
        tmp___0 = __errno_location();
        }
#line 712
        if (*tmp___0 == 4) {
#line 713
          goto while_continue;
        }
      }
#line 714
      goto while_break;
    }
#line 716
    start += bytes;
#line 717
    toread -= bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  if (bytes == 0) {
#line 721
    eof_reached = (char)1;
  }
#line 723
  if (bytes < 0) {
    {
#line 724
    report_proc();
#line 725
    perror("failed to read input");
#line 726
    byee(-1);
    }
  }
#line 730
  if (! padblock) {
#line 731
    curr_block->bytes = blocksize - toread;
  } else
#line 730
  if (toread == blocksize) {
#line 731
    curr_block->bytes = blocksize - toread;
  } else {
#line 733
    if (toread) {
      {
#line 733
      bzero((void *)start, (size_t )toread);
      }
    }
#line 734
    curr_block->bytes = blocksize;
  }
#line 737
  if (debug > 1) {
    {
#line 738
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"R: got %d bytes\n",
            curr_block->bytes);
    }
  }
  {
#line 740
  unlock(pbuffer->semid, pbuffer->blocks_used_lock);
  }
#line 742
  return (curr_block->bytes);
}
}
#line 746 "/home/june/collector/temp/buffer-1.19/buffer.c"
void writer(void) 
{ 
  int filled ;
  int maxfilled ;
  int first_block ;
  int tmp ;

  {
#line 749
  filled = 0;
#line 750
  maxfilled = (blocks * percent) / 100;
#line 751
  first_block = 0;
#line 753
  if (debug) {
    {
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tW: Entering writer\n blocks = %d\n maxfilled = %d\n",
            blocks, maxfilled);
    }
  }
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! filled) {
#line 760
      first_block = pbuffer->next_block_out;
    }
    {
#line 761
    get_next_filled_block();
#line 762
    tmp = data_to_write();
    }
#line 762
    if (! tmp) {
#line 763
      goto while_break;
    }
#line 765
    filled ++;
#line 766
    if (debug > 1) {
      {
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: filled = %d\n",
              filled);
      }
    }
#line 768
    if (filled >= maxfilled) {
#line 769
      if (debug > 1) {
        {
#line 770
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: writing\n");
        }
      }
      {
#line 771
      write_blocks_to_stdout(filled, first_block);
#line 772
      filled = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 776
  write_blocks_to_stdout(filled, first_block);
  }
#line 778
  if (showevery) {
    {
#line 779
    pr_out();
#line 780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 783
  if (print_total) {
    {
#line 784
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Kilobytes Out %llu\n",
            outk);
    }
  }
#line 787
  if (debug) {
    {
#line 788
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tW: Exiting writer\n");
    }
  }
#line 789
  return;
}
}
#line 791 "/home/june/collector/temp/buffer-1.19/buffer.c"
void get_next_filled_block(void) 
{ 


  {
  {
#line 795
  lock(pbuffer->semid, pbuffer->blocks_used_lock);
#line 797
  curr_block = & pbuffer->block[pbuffer->next_block_out];
  }
#line 799
  if (pbuffer->next_block_out + 1 == blocks) {
#line 799
    pbuffer->next_block_out = 0;
  } else {
#line 799
    (pbuffer->next_block_out) ++;
  }
#line 800
  return;
}
}
#line 802 "/home/june/collector/temp/buffer-1.19/buffer.c"
int data_to_write(void) 
{ 


  {
#line 805
  return (curr_block->bytes);
}
}
#line 808 "/home/june/collector/temp/buffer-1.19/buffer.c"
void write_blocks_to_stdout(int filled , int first_block ) 
{ 
  int tmp ;

  {
#line 813
  pbuffer->next_block_out = first_block;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    tmp = filled;
#line 815
    filled --;
#line 815
    if (! tmp) {
#line 815
      goto while_break;
    }
#line 816
    curr_block = & pbuffer->block[pbuffer->next_block_out];
#line 817
    if (pbuffer->next_block_out + 1 == blocks) {
#line 817
      pbuffer->next_block_out = 0;
    } else {
#line 817
      (pbuffer->next_block_out) ++;
    }
    {
#line 818
    write_block_to_stdout();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return;
}
}
#line 826 "/home/june/collector/temp/buffer-1.19/buffer.c"
static unsigned long last_gb  =    0UL;
#line 827 "/home/june/collector/temp/buffer-1.19/buffer.c"
static unsigned long long next_k  =    0ULL;
#line 822 "/home/june/collector/temp/buffer-1.19/buffer.c"
void write_block_to_stdout(void) 
{ 
  unsigned long out ;
  int written ;
  ssize_t tmp ;

  {
#line 825
  out = 0UL;
#line 830
  if (next_k == 0ULL) {
#line 830
    if (showevery) {
#line 831
      if (debug > 3) {
        {
#line 832
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: next_k = %llu showevery = %d\n",
                next_k, showevery);
        }
      }
#line 833
      showevery /= 1024;
#line 834
      next_k = (unsigned long long )showevery;
    }
  }
  {
#line 837
  tmp = write(fdout, (void const   *)curr_block->data, (size_t )curr_block->bytes);
#line 837
  written = (int )tmp;
  }
#line 837
  if (written != curr_block->bytes) {
    {
#line 838
    report_proc();
#line 839
    perror("write of data failed");
#line 840
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bytes to write=%d, bytes written=%d, total written %10lluK\n",
            curr_block->bytes, written, outk);
#line 841
    byee(-1);
    }
  }
#line 844
  if (write_pause) {
    {
#line 845
    usleep(write_pause);
    }
  }
#line 848
  out = (unsigned long )(curr_block->bytes / 1024);
#line 849
  outk += (unsigned long long )out;
#line 850
  last_gb += out;
#line 858
  if (Zflag) {
#line 858
    if (last_gb >= 1048576UL) {
#line 859
      last_gb = 0UL;
#line 860
      if (in_ISCHR) {
        {
#line 861
        lseek(fdin, (__off_t )0, 0);
        }
      }
#line 862
      if (out_ISCHR) {
        {
#line 863
        lseek(fdout, (__off_t )0, 0);
        }
      }
    }
  }
#line 865
  if (showevery) {
#line 866
    if (debug > 3) {
      {
#line 867
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: outk = %llu, next_k = %llu\n",
              outk, next_k);
      }
    }
#line 869
    if (outk >= next_k) {
      {
#line 870
      pr_out();
#line 871
      next_k += (unsigned long long )showevery;
      }
    }
  }
  {
#line 875
  unlock(pbuffer->semid, pbuffer->blocks_free_lock);
  }
#line 876
  return;
}
}
#line 879 "/home/june/collector/temp/buffer-1.19/buffer.c"
void byee(int exit_val ) 
{ 
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;

  {
#line 883
  if (writer_pid != 0) {
#line 884
    if (exit_val != 0) {
      {
#line 888
      end_writer();
      }
    }
    {
#line 890
    wait_for_writer_end();
    }
  }
#line 893
  if (free_shm) {
    {
#line 894
    buffer_remove();
    }
  }
  {
#line 898
  signal(17, (void (*)(int  ))1);
  }
#line 906
  if (writer_status) {
#line 907
    __constr_expr_0.__in = writer_status;
#line 907
    if ((__constr_expr_0.__i & 65280) >> 8) {
#line 907
      goto _L;
    } else {
#line 907
      __constr_expr_1.__in = writer_status;
#line 907
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
        _L: /* CIL Label */ 
#line 908
        if (debug) {
          {
#line 909
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writer died badly: 0x%04x\n",
                  writer_status);
          }
        }
        {
#line 910
        exit(-2);
        }
      }
    }
  }
  {
#line 914
  exit(exit_val);
  }
}
}
#line 918 "/home/june/collector/temp/buffer-1.19/buffer.c"
void end_writer(void) 
{ 


  {
#line 921
  if (writer_pid) {
    {
#line 922
    kill(writer_pid, 1);
    }
  }
#line 923
  return;
}
}
#line 925 "/home/june/collector/temp/buffer-1.19/buffer.c"
void wait_for_writer_end(void) 
{ 
  int deadpid ;

  {
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 931
    if (writer_pid) {
      {
#line 931
      deadpid = wait((union wait *)(& writer_status));
      }
#line 931
      if (deadpid != writer_pid) {
#line 931
        if (! (deadpid != -1)) {
#line 931
          goto while_break;
        }
      } else {
#line 931
        goto while_break;
      }
    } else {
#line 931
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  return;
}
}
#line 936 "/home/june/collector/temp/buffer-1.19/buffer.c"
void test_writer(void) 
{ 


  {
#line 940
  if (writer_pid == 0) {
    {
#line 941
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writer has died unexpectedly\n");
#line 942
    byee(-1);
    }
  }
#line 944
  return;
}
}
#line 952 "/home/june/collector/temp/buffer-1.19/buffer.c"
int do_size(char *arg ) 
{ 
  int ret ;
  char unit ;

  {
  {
#line 956
  ret = 0;
#line 958
  unit = (char )'\000';
#line 959
  sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d%c",
         & ret, & unit);
  }
  {
#line 963
  if ((int )unit == 77) {
#line 963
    goto case_77;
  }
#line 963
  if ((int )unit == 109) {
#line 963
    goto case_77;
  }
#line 967
  if ((int )unit == 75) {
#line 967
    goto case_75;
  }
#line 967
  if ((int )unit == 107) {
#line 967
    goto case_75;
  }
#line 971
  if ((int )unit == 66) {
#line 971
    goto case_66;
  }
#line 971
  if ((int )unit == 98) {
#line 971
    goto case_66;
  }
#line 961
  goto switch_break;
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
#line 964
  ret = (ret * 1024) * 1024;
#line 965
  goto switch_break;
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 968
  ret *= 1024;
#line 969
  goto switch_break;
  case_66: /* CIL Label */ 
  case_98: /* CIL Label */ 
#line 972
  ret *= 512;
#line 973
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 976
  return (ret);
}
}
#line 979 "/home/june/collector/temp/buffer-1.19/buffer.c"
void pr_out(void) 
{ 
  struct timeval now ;
  unsigned long ms_delta ;
  unsigned long k_per_s ;

  {
  {
#line 985
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 986
  ms_delta = (unsigned long )((now.tv_sec - starttime.tv_sec) * 1000L + (now.tv_usec - starttime.tv_usec) / 1000L);
  }
#line 988
  if (ms_delta) {
#line 997
    if (outk < 18446744073709551ULL) {
#line 998
      k_per_s = (unsigned long )((outk * 1000ULL) / (unsigned long long )ms_delta);
    } else
#line 999
    if (ms_delta >= 1000UL) {
#line 1000
      k_per_s = (unsigned long )(outk / (unsigned long long )(ms_delta / 1000UL));
    } else {
#line 1002
      k_per_s = (unsigned long )((outk / (unsigned long long )ms_delta) * 1000ULL);
    }
    {
#line 1004
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %10lluK, %10luK/s\r",
            outk, k_per_s);
    }
  } else
#line 1006
  if (outk) {
    {
#line 1007
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %10lluK,          ?K/s\r",
            outk);
    }
  } else {
    {
#line 1009
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"          0K,          0K/s\r");
    }
  }
#line 1012
  return;
}
}
#line 1047 "/home/june/collector/temp/buffer-1.19/buffer.c"
void report_proc(void) 
{ 


  {
  {
#line 1050
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          proc_string);
  }
#line 1051
  return;
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semctl)(int __semid ,
                                                                             int __semnum ,
                                                                             int __cmd 
                                                                             , ...) ;
#line 55
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semget)(key_t __key ,
                                                                             int __nsems ,
                                                                             int __semflg ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semop)(int __semid ,
                                                                            struct sembuf *__sops ,
                                                                            size_t __nsops ) ;
#line 73 "/home/june/collector/temp/buffer-1.19/sem.c"
void sem_set(int sem_id , int semn , int val ) 
{ 
  union semun arg ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 82
  arg.val = val;
#line 84
  tmp = __errno_location();
#line 84
  *tmp = 0;
#line 85
  semctl(sem_id, semn, 16, arg);
#line 86
  tmp___0 = __errno_location();
  }
#line 86
  if (*tmp___0 != 0) {
    {
#line 87
    report_proc();
#line 88
    perror("internal error, sem_set");
#line 89
    byee(-1);
    }
  }
#line 91
  return;
}
}
#line 93 "/home/june/collector/temp/buffer-1.19/sem.c"
int new_sems(int nsems ) 
{ 
  int sem ;
  int i ;

  {
  {
#line 100
  sem = semget(0, nsems, 896);
  }
#line 101
  if (sem < 0) {
    {
#line 102
    report_proc();
#line 103
    perror("internal error, couldn\'t create semaphore");
#line 104
    byee(-1);
    }
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < nsems)) {
#line 107
      goto while_break;
    }
    {
#line 108
    sem_set(sem, i, 1);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (sem);
}
}
#line 114 "/home/june/collector/temp/buffer-1.19/sem.c"
static void do_sem(int sem_id , struct sembuf *pbuf , char *err ) 
{ 
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    tmp___1 = semop(sem_id, pbuf, (size_t )1);
    }
#line 122
    if (tmp___1 == -1) {
      {
#line 123
      tmp = __errno_location();
      }
#line 123
      if (*tmp == 4) {
#line 124
        goto while_continue;
      }
      {
#line 126
      report_proc();
#line 127
      tmp___0 = getpid();
#line 127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error pid %d, lock id %d\n",
              tmp___0, sem_id);
#line 129
      perror((char const   *)err);
#line 130
      byee(-1);
      }
    }
#line 132
    return;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/june/collector/temp/buffer-1.19/sem.c"
void lock(int sem_id , int semn ) 
{ 
  struct sembuf sembuf ;

  {
  {
#line 143
  sembuf.sem_num = (unsigned short )semn;
#line 144
  sembuf.sem_op = (short)-1;
#line 145
  sembuf.sem_flg = (short)0;
#line 147
  do_sem(sem_id, & sembuf, (char *)"lock error");
  }
#line 148
  return;
}
}
#line 150 "/home/june/collector/temp/buffer-1.19/sem.c"
void unlock(int sem_id , int semn ) 
{ 
  struct sembuf sembuf ;

  {
  {
#line 157
  sembuf.sem_num = (unsigned short )semn;
#line 158
  sembuf.sem_op = (short)1;
#line 159
  sembuf.sem_flg = (short)0;
#line 161
  do_sem(sem_id, & sembuf, (char *)"unlock error");
  }
#line 162
  return;
}
}
#line 164 "/home/june/collector/temp/buffer-1.19/sem.c"
void remove_sems(int sem_id ) 
{ 
  union semun arg ;
  int tmp ;

  {
#line 170
  if (sem_id == -1) {
#line 171
    return;
  }
  {
#line 173
  arg.val = 0;
#line 174
  tmp = semctl(sem_id, 0, 0, arg);
  }
#line 174
  if (tmp == -1) {
    {
#line 175
    report_proc();
#line 176
    perror("internal error, failed to remove semaphore");
    }
  }
#line 178
  return;
}
}
