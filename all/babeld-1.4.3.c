/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 23 "/home/june/collector/temp/babeld-1.4.3/interface.h"
struct buffered_update {
   unsigned char id[8] ;
   unsigned char prefix[16] ;
   unsigned char plen ;
   unsigned char pad[3] ;
};
#line 30 "/home/june/collector/temp/babeld-1.4.3/interface.h"
struct interface_conf {
   char *ifname ;
   unsigned int hello_interval ;
   unsigned int update_interval ;
   unsigned short cost ;
   char wired ;
   char split_horizon ;
   char lq ;
   char faraway ;
   int channel ;
   struct interface_conf *next ;
};
#line 58 "/home/june/collector/temp/babeld-1.4.3/interface.h"
struct interface {
   struct interface *next ;
   struct interface_conf *conf ;
   unsigned int ifindex ;
   unsigned short flags ;
   unsigned short cost ;
   int channel ;
   struct timeval hello_timeout ;
   struct timeval update_timeout ;
   struct timeval flush_timeout ;
   struct timeval update_flush_timeout ;
   char name[16] ;
   unsigned char *ipv4 ;
   int numll ;
   unsigned char (*ll)[16] ;
   int buffered ;
   int bufsize ;
   char have_buffered_hello ;
   char have_buffered_id ;
   char have_buffered_nh ;
   char have_buffered_prefix ;
   unsigned char buffered_id[16] ;
   unsigned char buffered_nh[4] ;
   unsigned char buffered_prefix[16] ;
   unsigned char *sendbuf ;
   struct buffered_update *buffered_updates ;
   int num_buffered_updates ;
   int update_bufsize ;
   time_t bucket_time ;
   unsigned int bucket ;
   time_t last_update_time ;
   unsigned short hello_seqno ;
   unsigned int hello_interval ;
   unsigned int update_interval ;
};
#line 23 "/home/june/collector/temp/babeld-1.4.3/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   int hello_seqno ;
   unsigned char address[16] ;
   unsigned short reach ;
   unsigned short txcost ;
   struct timeval hello_time ;
   struct timeval ihu_time ;
   unsigned short hello_interval ;
   unsigned short ihu_interval ;
   struct interface *ifp ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_31 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_31 __in6_u ;
};
#line 288 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 28 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
struct kernel_route {
   unsigned char prefix[16] ;
   int plen ;
   int metric ;
   unsigned int ifindex ;
   int proto ;
   unsigned char gw[16] ;
};
#line 30 "/home/june/collector/temp/babeld-1.4.3/route.h"
struct source;
#line 30 "/home/june/collector/temp/babeld-1.4.3/route.h"
struct babel_route {
   struct source *src ;
   unsigned short refmetric ;
   unsigned short cost ;
   unsigned short add_metric ;
   unsigned short seqno ;
   struct neighbour *neigh ;
   unsigned char nexthop[16] ;
   time_t time ;
   unsigned short hold_time ;
   unsigned short smoothed_metric ;
   time_t smoothed_metric_time ;
   short installed ;
   unsigned char channels[8] ;
   struct babel_route *next ;
};
#line 23 "/home/june/collector/temp/babeld-1.4.3/xroute.h"
struct xroute {
   unsigned char prefix[16] ;
   unsigned char plen ;
   unsigned short metric ;
   unsigned int ifindex ;
   int proto ;
};
#line 25 "/home/june/collector/temp/babeld-1.4.3/source.h"
struct source {
   struct source *next ;
   unsigned char id[8] ;
   unsigned char prefix[16] ;
   unsigned char plen ;
   unsigned short seqno ;
   unsigned short metric ;
   unsigned short route_count ;
   time_t time ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 23 "/home/june/collector/temp/babeld-1.4.3/configuration.h"
struct filter {
   int af ;
   char *ifname ;
   unsigned int ifindex ;
   unsigned char *id ;
   unsigned char *prefix ;
   unsigned char plen ;
   unsigned char plen_ge ;
   unsigned char plen_le ;
   unsigned char *neigh ;
   int proto ;
   unsigned int result ;
   struct filter *next ;
};
#line 765 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct file_state {
   FILE *f ;
   int line ;
};
#line 799 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct string_state {
   char *string ;
   int n ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 29 "/home/june/collector/temp/babeld-1.4.3/resend.h"
struct resend {
   unsigned char kind ;
   unsigned char max ;
   unsigned short delay ;
   struct timeval time ;
   unsigned char prefix[16] ;
   unsigned char plen ;
   unsigned short seqno ;
   unsigned char id[8] ;
   struct interface *ifp ;
   struct resend *next ;
};
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_43 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_44 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_43 ifr_ifrn ;
   union __anonunion_ifr_ifru_44 ifr_ifru ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 99 "/usr/include/linux/netlink.h"
struct nlmsgerr {
   int error ;
   struct nlmsghdr msg ;
};
#line 7 "/usr/include/linux/if_addr.h"
struct ifaddrmsg {
   __u8 ifa_family ;
   __u8 ifa_prefixlen ;
   __u8 ifa_flags ;
   __u8 ifa_scope ;
   __u32 ifa_index ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 175 "/usr/include/linux/rtnetlink.h"
struct rtmsg {
   unsigned char rtm_family ;
   unsigned char rtm_dst_len ;
   unsigned char rtm_src_len ;
   unsigned char rtm_tos ;
   unsigned char rtm_table ;
   unsigned char rtm_protocol ;
   unsigned char rtm_scope ;
   unsigned char rtm_type ;
   unsigned int rtm_flags ;
};
#line 432 "/usr/include/linux/rtnetlink.h"
struct rtgenmsg {
   unsigned char rtgen_family ;
};
#line 445 "/usr/include/linux/rtnetlink.h"
struct ifinfomsg {
   unsigned char ifi_family ;
   unsigned char __ifi_pad ;
   unsigned short ifi_type ;
   int ifi_index ;
   unsigned int ifi_flags ;
   unsigned int ifi_change ;
};
#line 65 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
struct old_if {
   char *ifname ;
   int rp_filter ;
};
#line 192 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
struct netlink {
   unsigned short seqno ;
   int sock ;
   struct sockaddr_nl sockaddr ;
   socklen_t socklen ;
};
#line 427 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
union __anonunion_buf_109 {
   char raw[((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL] ;
   struct nlmsghdr nh ;
};
#line 828 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
struct iw_freq {
   int m ;
   short e ;
   unsigned char i ;
   unsigned char flags ;
};
#line 835 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
union __anonunion_ifr_ifrn_110 {
   char ifrn_name[16] ;
};
#line 835 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
union __anonunion_u_111 {
   struct iw_freq freq ;
};
#line 835 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
struct iwreq_subset {
   union __anonunion_ifr_ifrn_110 ifr_ifrn ;
   union __anonunion_u_111 u ;
};
#line 905 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
union __anonunion_buf_112 {
   char raw[1024] ;
   struct nlmsghdr nh ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 83 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
struct timeval now ;
#line 84
int debug ;
#line 57 "/home/june/collector/temp/babeld-1.4.3/util.h"
__inline static short seqno_minus(unsigned short s1 , unsigned short s2 ) 
{ 


  {
#line 60
  return ((short )(((int )s1 - (int )s2) & 65535));
}
}
#line 63 "/home/june/collector/temp/babeld-1.4.3/util.h"
__inline static unsigned short seqno_plus(unsigned short s , int plus ) 
{ 


  {
#line 66
  return ((unsigned short )(((int )s + plus) & 65535));
}
}
#line 72
unsigned int timeval_minus_msec(struct timeval  const  *s1 , struct timeval  const  *s2 )  __attribute__((__pure__)) ;
#line 74
void timeval_add_msec(struct timeval *d , struct timeval  const  *s , int msecs ) ;
#line 82
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...)  __attribute__((__cold__)) ;
#line 90
char const   *format_address(unsigned char const   *address ) ;
#line 101 "/home/june/collector/temp/babeld-1.4.3/interface.h"
__inline static int if_up(struct interface *ifp ) 
{ 


  {
#line 104
  return (! (! ((int )ifp->flags & 1)));
}
}
#line 37 "/home/june/collector/temp/babeld-1.4.3/neighbour.h"
struct neighbour *neighs ;
#line 43
void flush_neighbour(struct neighbour *neigh ) ;
#line 44
struct neighbour *find_neighbour(unsigned char const   *address , struct interface *ifp ) ;
#line 46
int update_neighbour(struct neighbour *neigh , int hello , int hello_interval ) ;
#line 47
unsigned int check_neighbours(void) ;
#line 48
unsigned int neighbour_txcost(struct neighbour *neigh ) ;
#line 49
unsigned int neighbour_rxcost(struct neighbour *neigh ) ;
#line 50
unsigned int neighbour_cost(struct neighbour *neigh ) ;
#line 77 "/home/june/collector/temp/babeld-1.4.3/route.h"
void flush_neighbour_routes(struct neighbour *neigh ) ;
#line 96
void update_neighbour_metric(struct neighbour *neigh , int changed ) ;
#line 56 "/home/june/collector/temp/babeld-1.4.3/message.h"
struct neighbour *unicast_neighbour ;
#line 66
void send_hello(struct interface *ifp ) ;
#line 67
void flush_unicast(int dofree ) ;
#line 74
void send_self_update(struct interface *ifp ) ;
#line 75
void send_ihu(struct neighbour *neigh , struct interface *ifp ) ;
#line 79
void send_unicast_request(struct neighbour *neigh , unsigned char const   *prefix ,
                          unsigned char plen ) ;
#line 46 "/home/june/collector/temp/babeld-1.4.3/resend.h"
void flush_resends(struct neighbour *neigh ) ;
#line 42 "/home/june/collector/temp/babeld-1.4.3/local.h"
void local_notify_neighbour(struct neighbour *neigh , int kind ) ;
#line 39 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
struct neighbour *neighs  =    (struct neighbour *)((void *)0);
#line 41 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
static struct neighbour *find_neighbour_nocreate(unsigned char const   *address ,
                                                 struct interface *ifp ) 
{ 
  struct neighbour *neigh ;
  int tmp ;

  {
#line 45
  neigh = neighs;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! neigh) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp = memcmp((void const   *)address, (void const   *)(neigh->address), (size_t )16);
    }
#line 46
    if (tmp == 0) {
#line 46
      if ((unsigned long )neigh->ifp == (unsigned long )ifp) {
#line 48
        return (neigh);
      }
    }
#line 45
    neigh = neigh->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((struct neighbour *)((void *)0));
}
}
#line 53 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
void flush_neighbour(struct neighbour *neigh ) 
{ 
  struct neighbour *previous___0 ;

  {
  {
#line 56
  flush_neighbour_routes(neigh);
  }
#line 57
  if ((unsigned long )unicast_neighbour == (unsigned long )neigh) {
    {
#line 58
    flush_unicast(1);
    }
  }
  {
#line 59
  flush_resends(neigh);
  }
#line 61
  if ((unsigned long )neighs == (unsigned long )neigh) {
#line 62
    neighs = neigh->next;
  } else {
#line 64
    previous___0 = neighs;
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if (! ((unsigned long )previous___0->next != (unsigned long )neigh)) {
#line 65
        goto while_break;
      }
#line 66
      previous___0 = previous___0->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 67
    previous___0->next = neigh->next;
  }
  {
#line 69
  local_notify_neighbour(neigh, 0);
#line 70
  free((void *)neigh);
  }
#line 71
  return;
}
}
#line 73 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
struct neighbour *find_neighbour(unsigned char const   *address , struct interface *ifp ) 
{ 
  struct neighbour *neigh ;
  struct timeval zero ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 77
  zero.tv_sec = (__time_t )0;
#line 77
  zero.tv_usec = (__suseconds_t )0;
#line 79
  neigh = find_neighbour_nocreate(address, ifp);
  }
#line 80
  if (neigh) {
#line 81
    return (neigh);
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 83
    if (tmp___0) {
      {
#line 83
      tmp = format_address(address);
#line 83
      do_debugf(2, "Creating neighbour %s on %s.\n", tmp, ifp->name);
      }
    }
#line 83
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  tmp___1 = malloc(sizeof(struct neighbour ));
#line 86
  neigh = (struct neighbour *)tmp___1;
  }
#line 87
  if ((unsigned long )neigh == (unsigned long )((void *)0)) {
    {
#line 88
    perror("malloc(neighbour)");
    }
#line 89
    return ((struct neighbour *)((void *)0));
  }
  {
#line 92
  neigh->hello_seqno = -1;
#line 93
  memcpy((void */* __restrict  */)(neigh->address), (void const   */* __restrict  */)address,
         (size_t )16);
#line 94
  neigh->reach = (unsigned short)0;
#line 95
  neigh->txcost = (unsigned short )(~ 0);
#line 96
  neigh->ihu_time = now;
#line 97
  neigh->hello_time = zero;
#line 98
  neigh->hello_interval = (unsigned short)0;
#line 99
  neigh->ihu_interval = (unsigned short)0;
#line 100
  neigh->ifp = ifp;
#line 101
  neigh->next = neighs;
#line 102
  neighs = neigh;
#line 103
  local_notify_neighbour(neigh, 1);
#line 104
  send_hello(ifp);
  }
#line 105
  return (neigh);
}
}
#line 110 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
int update_neighbour(struct neighbour *neigh , int hello , int hello_interval ) 
{ 
  int missed_hellos ;
  int rc ;
  unsigned int tmp ;
  short tmp___0 ;
  unsigned short tmp___1 ;
  int a ;
  int b ;

  {
#line 114
  rc = 0;
#line 116
  if (hello < 0) {
#line 117
    if ((int )neigh->hello_interval <= 0) {
#line 118
      return (rc);
    }
    {
#line 119
    tmp = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& neigh->hello_time));
#line 119
    missed_hellos = ((int )tmp - (int )neigh->hello_interval * 7) / ((int )neigh->hello_interval * 10);
    }
#line 123
    if (missed_hellos <= 0) {
#line 124
      return (rc);
    }
    {
#line 125
    timeval_add_msec(& neigh->hello_time, (struct timeval  const  *)(& neigh->hello_time),
                     (missed_hellos * (int )neigh->hello_interval) * 10);
    }
  } else {
#line 128
    if (neigh->hello_seqno >= 0) {
#line 128
      if ((int )neigh->reach > 0) {
        {
#line 129
        tmp___0 = seqno_minus((unsigned short )hello, (unsigned short )neigh->hello_seqno);
#line 129
        missed_hellos = (int )tmp___0 - 1;
        }
#line 130
        if (missed_hellos < -8) {
#line 133
          neigh->reach = (unsigned short)0;
#line 134
          missed_hellos = 0;
#line 135
          rc = 1;
        } else
#line 136
        if (missed_hellos < 0) {
#line 137
          if (hello_interval > (int )neigh->hello_interval) {
#line 140
            neigh->reach = (unsigned short )((int )neigh->reach << - missed_hellos);
#line 141
            missed_hellos = 0;
          } else {
#line 146
            neigh->hello_seqno = hello;
#line 147
            hello = -1;
#line 148
            missed_hellos = 0;
          }
#line 150
          rc = 1;
        }
      } else {
#line 153
        missed_hellos = 0;
      }
    } else {
#line 153
      missed_hellos = 0;
    }
#line 155
    neigh->hello_time = now;
#line 156
    neigh->hello_interval = (unsigned short )hello_interval;
  }
#line 159
  if (missed_hellos > 0) {
    {
#line 160
    neigh->reach = (unsigned short )((int )neigh->reach >> missed_hellos);
#line 161
    tmp___1 = seqno_plus((unsigned short )neigh->hello_seqno, missed_hellos);
#line 161
    neigh->hello_seqno = (int )tmp___1;
#line 162
    missed_hellos = 0;
#line 163
    rc = 1;
    }
  }
#line 166
  if (hello >= 0) {
#line 167
    neigh->hello_seqno = hello;
#line 168
    neigh->reach = (unsigned short )((int )neigh->reach >> 1);
#line 169
    neigh->reach = (unsigned short )((int )neigh->reach | 32768);
#line 170
    if (((int )neigh->reach & 64512) != 64512) {
#line 171
      rc = 1;
    }
  }
#line 175
  if (((int )neigh->reach & 48896) == 32768) {
    {
#line 177
    send_hello(neigh->ifp);
    }
  } else {
#line 180
    a = (int )neigh->reach & 49152;
#line 181
    b = (int )neigh->reach & 12288;
#line 182
    if (a == 49152) {
#line 182
      if (b == 0) {
        {
#line 184
        send_self_update(neigh->ifp);
        }
      } else {
#line 182
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 182
    if (a == 0) {
#line 182
      if (b == 12288) {
        {
#line 184
        send_self_update(neigh->ifp);
        }
      }
    }
  }
#line 188
  if (((int )neigh->reach & 64512) == 49152) {
    {
#line 191
    send_unicast_request(neigh, (unsigned char const   *)((void *)0), (unsigned char)0);
#line 192
    send_ihu(neigh, (struct interface *)((void *)0));
    }
  }
#line 194
  return (rc);
}
}
#line 197 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
static int reset_txcost(struct neighbour *neigh ) 
{ 
  unsigned int delay ;

  {
  {
#line 202
  delay = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& neigh->ihu_time));
  }
#line 204
  if ((int )neigh->ihu_interval > 0) {
#line 204
    if (delay < (unsigned int )(((int )neigh->ihu_interval * 10) * 3)) {
#line 205
      return (0);
    }
  }
#line 208
  if (delay >= 180000U) {
#line 211
    neigh->txcost = (unsigned short )(~ 0);
#line 212
    neigh->ihu_time = now;
#line 213
    return (1);
  } else
#line 208
  if (((int )neigh->reach & 65520) == 0) {
#line 211
    neigh->txcost = (unsigned short )(~ 0);
#line 212
    neigh->ihu_time = now;
#line 213
    return (1);
  } else
#line 208
  if ((int )neigh->ihu_interval > 0) {
#line 208
    if (delay >= (unsigned int )(((int )neigh->ihu_interval * 10) * 10)) {
#line 211
      neigh->txcost = (unsigned short )(~ 0);
#line 212
      neigh->ihu_time = now;
#line 213
      return (1);
    }
  }
#line 216
  return (0);
}
}
#line 219 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
unsigned int neighbour_txcost(struct neighbour *neigh ) 
{ 


  {
#line 222
  return ((unsigned int )neigh->txcost);
}
}
#line 225 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
unsigned int check_neighbours(void) 
{ 
  struct neighbour *neigh ;
  int changed ;
  int rc ;
  unsigned int msecs ;
  long tmp ;
  struct neighbour *old ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 230
  msecs = 50000U;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 232
    if (tmp) {
      {
#line 232
      do_debugf(2, "Checking neighbours.\n");
      }
    }
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  neigh = neighs;
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    if (! neigh) {
#line 235
      goto while_break___0;
    }
    {
#line 236
    changed = update_neighbour(neigh, -1, 0);
    }
#line 238
    if ((int )neigh->reach == 0) {
      {
#line 241
      old = neigh;
#line 242
      neigh = neigh->next;
#line 243
      flush_neighbour(old);
      }
#line 244
      goto while_continue___0;
    } else
#line 238
    if (neigh->hello_time.tv_sec > now.tv_sec) {
      {
#line 241
      old = neigh;
#line 242
      neigh = neigh->next;
#line 243
      flush_neighbour(old);
      }
#line 244
      goto while_continue___0;
    } else {
      {
#line 238
      tmp___0 = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& neigh->hello_time));
      }
#line 238
      if (tmp___0 > 300000U) {
        {
#line 241
        old = neigh;
#line 242
        neigh = neigh->next;
#line 243
        flush_neighbour(old);
        }
#line 244
        goto while_continue___0;
      }
    }
    {
#line 247
    rc = reset_txcost(neigh);
    }
#line 248
    if (changed) {
#line 248
      tmp___1 = 1;
    } else
#line 248
    if (rc) {
#line 248
      tmp___1 = 1;
    } else {
#line 248
      tmp___1 = 0;
    }
    {
#line 248
    changed = tmp___1;
#line 250
    update_neighbour_metric(neigh, changed);
    }
#line 252
    if ((int )neigh->hello_interval > 0) {
#line 253
      if (msecs <= (unsigned int )((int )neigh->hello_interval * 10)) {
#line 253
        msecs = msecs;
      } else {
#line 253
        msecs = (unsigned int )((int )neigh->hello_interval * 10);
      }
    }
#line 254
    if ((int )neigh->ihu_interval > 0) {
#line 255
      if (msecs <= (unsigned int )((int )neigh->ihu_interval * 10)) {
#line 255
        msecs = msecs;
      } else {
#line 255
        msecs = (unsigned int )((int )neigh->ihu_interval * 10);
      }
    }
#line 256
    neigh = neigh->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  return (msecs);
}
}
#line 262 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
unsigned int neighbour_rxcost(struct neighbour *neigh ) 
{ 
  unsigned int delay ;
  unsigned short reach ;
  int sreach ;
  int cost ;
  int tmp ;

  {
  {
#line 266
  reach = neigh->reach;
#line 268
  delay = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& neigh->hello_time));
  }
#line 270
  if (((int )reach & 65520) == 0) {
#line 271
    return ((unsigned int )((unsigned short )(~ 0)));
  } else
#line 270
  if (delay >= 180000U) {
#line 271
    return ((unsigned int )((unsigned short )(~ 0)));
  } else
#line 272
  if ((int )(neigh->ifp)->flags & (1 << 3)) {
#line 273
    sreach = ((((int )reach & 32768) >> 2) + (((int )reach & 16384) >> 1)) + ((int )reach & 16383);
#line 278
    cost = (32768 * (int )(neigh->ifp)->cost) / (sreach + 1);
#line 280
    if (delay >= 40000U) {
#line 281
      cost = (int )(((unsigned int )cost * (delay - 20000U) + 10000U) / 20000U);
    }
#line 282
    if (cost <= 65535) {
#line 282
      tmp = cost;
    } else {
#line 282
      tmp = (int )((unsigned short )(~ 0));
    }
#line 282
    return ((unsigned int )tmp);
  } else
#line 285
  if (((int )reach & 49152) == 49152) {
#line 286
    return ((unsigned int )(neigh->ifp)->cost);
  } else
#line 287
  if (((int )reach & 49152) == 0) {
#line 288
    return ((unsigned int )((unsigned short )(~ 0)));
  } else
#line 289
  if ((int )reach & 8192) {
#line 290
    return ((unsigned int )(neigh->ifp)->cost);
  } else {
#line 292
    return ((unsigned int )((unsigned short )(~ 0)));
  }
}
}
#line 296 "/home/june/collector/temp/babeld-1.4.3/neighbour.c"
unsigned int neighbour_cost(struct neighbour *neigh ) 
{ 
  unsigned int a ;
  unsigned int b ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 301
  tmp = if_up(neigh->ifp);
  }
#line 301
  if (! tmp) {
#line 302
    return ((unsigned int )((unsigned short )(~ 0)));
  }
  {
#line 304
  a = neighbour_txcost(neigh);
  }
#line 306
  if (a >= 65535U) {
#line 307
    return ((unsigned int )((unsigned short )(~ 0)));
  }
  {
#line 309
  b = neighbour_rxcost(neigh);
  }
#line 310
  if (b >= 65535U) {
#line 311
    return ((unsigned int )((unsigned short )(~ 0)));
  }
#line 313
  if (! ((int )(neigh->ifp)->flags & (1 << 3))) {
#line 314
    return (a);
  } else
#line 313
  if (a < 256U) {
#line 313
    if (b < 256U) {
#line 314
      return (a);
    } else {
#line 313
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 319
    if (a <= 256U) {
#line 319
      a = 256U;
    } else {
#line 319
      a = a;
    }
#line 320
    if (b <= 256U) {
#line 320
      b = 256U;
    } else {
#line 320
      b = b;
    }
#line 323
    if ((a * b + 128U) >> 8 <= 65535U) {
#line 323
      tmp___0 = (a * b + 128U) >> 8;
    } else {
#line 323
      tmp___0 = (unsigned int )((unsigned short )(~ 0));
    }
#line 323
    return (tmp___0);
  }
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 86 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
int default_wireless_hello_interval ;
#line 86
int default_wired_hello_interval ;
#line 92
int all_wireless ;
#line 99
unsigned char protocol_group[16] ;
#line 100
int protocol_socket ;
#line 105
void schedule_interfaces_check(int msecs , int override ) ;
#line 106
int resize_receive_buffer(int size ) ;
#line 69 "/home/june/collector/temp/babeld-1.4.3/util.h"
int roughly(int value ) ;
#line 55 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int kernel_setup_interface(int setup , char const   *ifname , int ifindex ) ;
#line 56
int kernel_interface_operational(char const   *ifname , int ifindex ) ;
#line 57
int kernel_interface_ipv4(char const   *ifname , int ifindex , unsigned char *addr_r ) ;
#line 59
int kernel_interface_mtu(char const   *ifname , int ifindex ) ;
#line 60
int kernel_interface_wireless(char const   *ifname , int ifindex ) ;
#line 61
int kernel_interface_channel(char const   *ifname , int ifindex ) ;
#line 68
int kernel_addresses(char *ifname , int ifindex , int ll , struct kernel_route *routes___0 ,
                     int maxroutes___0 ) ;
#line 97 "/home/june/collector/temp/babeld-1.4.3/interface.h"
struct interface *interfaces ;
#line 107
struct interface *add_interface(char *ifname , struct interface_conf *if_conf ) ;
#line 108
unsigned int jitter(struct interface *ifp , int urgent ) ;
#line 109
unsigned int update_jitter(struct interface *ifp , int urgent ) ;
#line 110
void set_timeout(struct timeval *timeout , int msecs ) ;
#line 111
int interface_up(struct interface *ifp , int up ) ;
#line 112
int interface_ll_address(struct interface *ifp , unsigned char const   *address ) ;
#line 113
void check_interfaces(void) ;
#line 52 "/home/june/collector/temp/babeld-1.4.3/message.h"
int split_horizon ;
#line 54
unsigned char packet_header[4] ;
#line 68
void send_update(struct interface *ifp , int urgent , unsigned char const   *prefix ,
                 unsigned char plen ) ;
#line 77
void send_request(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ) ;
#line 78 "/home/june/collector/temp/babeld-1.4.3/route.h"
void flush_interface_routes(struct interface *ifp , int v4only ) ;
#line 97
void update_interface_metric(struct interface *ifp ) ;
#line 37 "/home/june/collector/temp/babeld-1.4.3/configuration.h"
struct interface_conf *default_interface_conf ;
#line 41
void renumber_filters(void) ;
#line 44 "/home/june/collector/temp/babeld-1.4.3/interface.c"
struct interface *interfaces  =    (struct interface *)((void *)0);
#line 46 "/home/june/collector/temp/babeld-1.4.3/interface.c"
static struct interface *last_interface(void) 
{ 
  struct interface *ifp ;

  {
#line 49
  ifp = interfaces;
#line 51
  if (! ifp) {
#line 52
    return ((struct interface *)((void *)0));
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ifp->next) {
#line 54
      goto while_break;
    }
#line 55
    ifp = ifp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (ifp);
}
}
#line 60 "/home/june/collector/temp/babeld-1.4.3/interface.c"
struct interface *add_interface(char *ifname , struct interface_conf *if_conf ) 
{ 
  struct interface *ifp ;
  int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct interface *tmp___2 ;

  {
#line 65
  ifp = interfaces;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ifp) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp = strcmp((char const   *)(ifp->name), (char const   *)ifname);
    }
#line 66
    if (tmp == 0) {
#line 67
      if (! ((unsigned long )if_conf == (unsigned long )((void *)0))) {
        {
#line 67
        __assert_fail("if_conf == ((void *)0)", "/home/june/collector/temp/babeld-1.4.3/interface.c",
                      67U, "add_interface");
        }
      }
#line 68
      return (ifp);
    }
#line 65
    ifp = ifp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  tmp___0 = malloc(sizeof(struct interface ));
#line 72
  ifp = (struct interface *)tmp___0;
  }
#line 73
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 74
    return ((struct interface *)((void *)0));
  }
  {
#line 76
  memset((void *)ifp, 0, sizeof(struct interface ));
#line 77
  strncpy((char */* __restrict  */)(ifp->name), (char const   */* __restrict  */)ifname,
          (size_t )16);
  }
#line 78
  if (if_conf) {
#line 78
    ifp->conf = if_conf;
  } else {
#line 78
    ifp->conf = default_interface_conf;
  }
  {
#line 79
  ifp->bucket_time = now.tv_sec;
#line 80
  ifp->bucket = 200U;
#line 81
  tmp___1 = random();
#line 81
  ifp->hello_seqno = (unsigned short )(tmp___1 & 65535L);
  }
#line 83
  if ((unsigned long )interfaces == (unsigned long )((void *)0)) {
#line 84
    interfaces = ifp;
  } else {
    {
#line 86
    tmp___2 = last_interface();
#line 86
    tmp___2->next = ifp;
    }
  }
#line 88
  return (ifp);
}
}
#line 93 "/home/june/collector/temp/babeld-1.4.3/interface.c"
unsigned int jitter(struct interface *ifp , int urgent ) 
{ 
  unsigned int interval ;
  int tmp ;

  {
#line 96
  interval = ifp->hello_interval;
#line 97
  if (urgent) {
#line 98
    if (interval <= 100U) {
#line 98
      interval = interval;
    } else {
#line 98
      interval = 100U;
    }
  } else
#line 100
  if (interval <= 4000U) {
#line 100
    interval = interval;
  } else {
#line 100
    interval = 4000U;
  }
  {
#line 101
  tmp = roughly((int )interval);
  }
#line 101
  return ((unsigned int )(tmp / 4));
}
}
#line 104 "/home/june/collector/temp/babeld-1.4.3/interface.c"
unsigned int update_jitter(struct interface *ifp , int urgent ) 
{ 
  unsigned int interval ;
  int tmp ;

  {
#line 107
  interval = ifp->hello_interval;
#line 108
  if (urgent) {
#line 109
    if (interval <= 100U) {
#line 109
      interval = interval;
    } else {
#line 109
      interval = 100U;
    }
  } else
#line 111
  if (interval <= 4000U) {
#line 111
    interval = interval;
  } else {
#line 111
    interval = 4000U;
  }
  {
#line 112
  tmp = roughly((int )interval);
  }
#line 112
  return ((unsigned int )tmp);
}
}
#line 115 "/home/june/collector/temp/babeld-1.4.3/interface.c"
void set_timeout(struct timeval *timeout , int msecs ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = roughly(msecs);
#line 118
  timeval_add_msec(timeout, (struct timeval  const  *)(& now), tmp);
  }
#line 119
  return;
}
}
#line 121 "/home/june/collector/temp/babeld-1.4.3/interface.c"
static int check_interface_ipv4(struct interface *ifp ) 
{ 
  unsigned char ipv4[4] ;
  int rc ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 127
  if (ifp->ifindex > 0U) {
    {
#line 128
    rc = kernel_interface_ipv4((char const   *)(ifp->name), (int )ifp->ifindex, ipv4);
    }
  } else {
#line 130
    rc = 0;
  }
#line 132
  if (rc > 0) {
#line 133
    if (! ifp->ipv4) {
#line 133
      goto _L;
    } else {
      {
#line 133
      tmp___1 = memcmp((void const   *)(ipv4), (void const   *)ifp->ipv4, (size_t )4);
      }
#line 133
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
        {
#line 134
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 134
          tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
          }
#line 134
          if (tmp) {
            {
#line 134
            do_debugf(2, "Noticed IPv4 change for %s.\n", ifp->name);
            }
          }
#line 134
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 135
        flush_interface_routes(ifp, 0);
        }
#line 136
        if (! ifp->ipv4) {
          {
#line 137
          tmp___0 = malloc((size_t )4);
#line 137
          ifp->ipv4 = (unsigned char *)tmp___0;
          }
        }
#line 138
        if (ifp->ipv4) {
          {
#line 139
          memcpy((void */* __restrict  */)ifp->ipv4, (void const   */* __restrict  */)(ipv4),
                 (size_t )4);
          }
        }
#line 140
        return (1);
      }
    }
  } else
#line 143
  if (ifp->ipv4) {
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 144
      tmp___2 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 144
      if (tmp___2) {
        {
#line 144
        do_debugf(2, "Noticed IPv4 change for %s.\n", ifp->name);
        }
      }
#line 144
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 145
    flush_interface_routes(ifp, 0);
#line 146
    free((void *)ifp->ipv4);
#line 147
    ifp->ipv4 = (unsigned char *)((void *)0);
    }
#line 148
    return (1);
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/collector/temp/babeld-1.4.3/interface.c"
static int check_interface_channel(struct interface *ifp ) 
{ 
  int channel ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 157
  if (ifp->conf) {
#line 157
    tmp = (ifp->conf)->channel;
  } else {
#line 157
    tmp = 0;
  }
#line 157
  channel = tmp;
#line 159
  if (channel == 0) {
#line 160
    if ((int )ifp->flags & (1 << 1)) {
#line 161
      channel = -2;
    } else {
      {
#line 163
      channel = kernel_interface_channel((char const   *)(ifp->name), (int )ifp->ifindex);
      }
#line 164
      if (channel < 0) {
        {
#line 165
        tmp___0 = __errno_location();
#line 165
        tmp___1 = strerror(*tmp___0);
#line 165
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t determine channel of interface %s: %s.\n",
                ifp->name, tmp___1);
        }
      }
#line 168
      if (channel <= 0) {
#line 169
        channel = 255;
      }
    }
  }
#line 173
  if (ifp->channel != channel) {
#line 174
    ifp->channel = channel;
#line 175
    return (1);
  }
#line 177
  return (0);
}
}
#line 180 "/home/june/collector/temp/babeld-1.4.3/interface.c"
int interface_up(struct interface *ifp , int up ) 
{ 
  int mtu ;
  int rc ;
  int wired ;
  struct ipv6_mreq mreq ;
  int tmp ;
  struct kernel_route ll[32] ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  void *tmp___13 ;
  int i___2 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  long tmp___16 ;

  {
  {
#line 186
  tmp = if_up(ifp);
  }
#line 186
  if (! (! up) == tmp) {
#line 187
    return (0);
  }
#line 189
  if (up) {
#line 190
    ifp->flags = (unsigned short )((int )ifp->flags | 1);
  } else {
#line 192
    ifp->flags = (unsigned short )((int )ifp->flags & -2);
  }
#line 194
  if (up) {
#line 196
    if (ifp->ifindex <= 0U) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Upping unknown interface %s.\n",
              ifp->name);
      }
#line 199
      goto fail;
    }
    {
#line 202
    rc = kernel_setup_interface(1, (char const   *)(ifp->name), (int )ifp->ifindex);
    }
#line 203
    if (rc < 0) {
      {
#line 204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_setup_interface(%s, %d) failed.\n",
              ifp->name, ifp->ifindex);
      }
#line 206
      goto fail;
    }
    {
#line 209
    mtu = kernel_interface_mtu((char const   *)(ifp->name), (int )ifp->ifindex);
    }
#line 210
    if (mtu < 0) {
      {
#line 211
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t get MTU of interface %s (%d).\n",
              ifp->name, ifp->ifindex);
#line 213
      mtu = 1280;
      }
    }
#line 220
    if (mtu < 128) {
      {
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Suspiciously low MTU %d on interface %s (%d).\n",
              mtu, ifp->name, ifp->ifindex);
#line 223
      mtu = 128;
      }
    }
#line 226
    if (ifp->sendbuf) {
      {
#line 227
      free((void *)ifp->sendbuf);
      }
    }
    {
#line 230
    ifp->bufsize = (int )(((unsigned long )mtu - sizeof(packet_header)) - 60UL);
#line 231
    tmp___0 = malloc((size_t )ifp->bufsize);
#line 231
    ifp->sendbuf = (unsigned char *)tmp___0;
    }
#line 232
    if ((unsigned long )ifp->sendbuf == (unsigned long )((void *)0)) {
      {
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate sendbuf.\n");
#line 234
      ifp->bufsize = 0;
      }
#line 235
      goto fail;
    }
    {
#line 238
    rc = resize_receive_buffer(mtu);
    }
#line 239
    if (rc < 0) {
      {
#line 240
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t resize receive buffer for interface %s (%d) (%d bytes).\n",
              ifp->name, ifp->ifindex, mtu);
      }
    }
#line 244
    if (ifp->conf) {
#line 244
      tmp___2 = (int )(ifp->conf)->wired;
    } else {
#line 244
      tmp___2 = 0;
    }
#line 244
    if (tmp___2 == 1) {
#line 245
      wired = 0;
    } else {
#line 246
      if (ifp->conf) {
#line 246
        tmp___1 = (int )(ifp->conf)->wired;
      } else {
#line 246
        tmp___1 = 0;
      }
#line 246
      if (tmp___1 == 2) {
#line 247
        wired = 1;
      } else
#line 248
      if (all_wireless) {
#line 249
        wired = 0;
      } else {
        {
#line 251
        rc = kernel_interface_wireless((char const   *)(ifp->name), (int )ifp->ifindex);
        }
#line 252
        if (rc < 0) {
          {
#line 253
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t determine whether %s (%d) is a wireless interface.\n",
                  ifp->name, ifp->ifindex);
#line 257
          wired = 0;
          }
        } else {
#line 259
          wired = ! rc;
        }
      }
    }
#line 263
    if (wired) {
#line 264
      ifp->flags = (unsigned short )((int )ifp->flags | (1 << 1));
#line 265
      if (ifp->conf) {
#line 265
        ifp->cost = (ifp->conf)->cost;
      } else {
#line 265
        ifp->cost = (unsigned short)0;
      }
#line 266
      if ((int )ifp->cost <= 0) {
#line 266
        ifp->cost = (unsigned short)96;
      }
#line 267
      if (ifp->conf) {
#line 267
        tmp___4 = (int )(ifp->conf)->split_horizon;
      } else {
#line 267
        tmp___4 = 0;
      }
#line 267
      if (tmp___4 == 1) {
#line 268
        ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 2));
      } else {
#line 269
        if (ifp->conf) {
#line 269
          tmp___3 = (int )(ifp->conf)->split_horizon;
        } else {
#line 269
          tmp___3 = 0;
        }
#line 269
        if (tmp___3 == 2) {
#line 270
          ifp->flags = (unsigned short )((int )ifp->flags | (1 << 2));
        } else
#line 271
        if (split_horizon) {
#line 272
          ifp->flags = (unsigned short )((int )ifp->flags | (1 << 2));
        } else {
#line 274
          ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 2));
        }
      }
#line 275
      if (ifp->conf) {
#line 275
        tmp___5 = (int )(ifp->conf)->lq;
      } else {
#line 275
        tmp___5 = 0;
      }
#line 275
      if (tmp___5 == 2) {
#line 276
        ifp->flags = (unsigned short )((int )ifp->flags | (1 << 3));
      } else {
#line 278
        ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 3));
      }
    } else {
#line 280
      ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 1));
#line 281
      if (ifp->conf) {
#line 281
        ifp->cost = (ifp->conf)->cost;
      } else {
#line 281
        ifp->cost = (unsigned short)0;
      }
#line 282
      if ((int )ifp->cost <= 0) {
#line 282
        ifp->cost = (unsigned short)256;
      }
#line 283
      if (ifp->conf) {
#line 283
        tmp___6 = (int )(ifp->conf)->split_horizon;
      } else {
#line 283
        tmp___6 = 0;
      }
#line 283
      if (tmp___6 == 2) {
#line 284
        ifp->flags = (unsigned short )((int )ifp->flags | (1 << 2));
      } else {
#line 286
        ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 2));
      }
#line 287
      if (ifp->conf) {
#line 287
        tmp___7 = (int )(ifp->conf)->lq;
      } else {
#line 287
        tmp___7 = 0;
      }
#line 287
      if (tmp___7 == 1) {
#line 288
        ifp->flags = (unsigned short )((int )ifp->flags & ~ (1 << 3));
      } else {
#line 290
        ifp->flags = (unsigned short )((int )ifp->flags | (1 << 3));
      }
    }
#line 293
    if (ifp->conf) {
#line 293
      tmp___8 = (int )(ifp->conf)->faraway;
    } else {
#line 293
      tmp___8 = 0;
    }
#line 293
    if (tmp___8 == 2) {
#line 294
      ifp->flags = (unsigned short )((int )ifp->flags | (1 << 4));
    }
#line 296
    if (ifp->conf) {
#line 296
      tmp___9 = (ifp->conf)->hello_interval;
    } else {
#line 296
      tmp___9 = 0U;
    }
#line 296
    if (tmp___9 > 0U) {
#line 297
      if (ifp->conf) {
#line 297
        ifp->hello_interval = (ifp->conf)->hello_interval;
      } else {
#line 297
        ifp->hello_interval = 0U;
      }
    } else
#line 298
    if ((int )ifp->flags & (1 << 1)) {
#line 299
      ifp->hello_interval = (unsigned int )default_wired_hello_interval;
    } else {
#line 301
      ifp->hello_interval = (unsigned int )default_wireless_hello_interval;
    }
#line 303
    if (ifp->conf) {
#line 303
      tmp___12 = (ifp->conf)->update_interval;
    } else {
#line 303
      tmp___12 = 0U;
    }
#line 303
    if (tmp___12 > 0U) {
#line 303
      if (ifp->conf) {
#line 303
        tmp___11 = (ifp->conf)->update_interval;
      } else {
#line 303
        tmp___11 = 0U;
      }
#line 303
      ifp->update_interval = tmp___11;
    } else {
#line 303
      ifp->update_interval = ifp->hello_interval * 4U;
    }
#line 308
    if (ifp->ll) {
      {
#line 309
      free((void *)ifp->ll);
      }
    }
    {
#line 310
    ifp->numll = 0;
#line 311
    ifp->ll = (unsigned char (*)[16])((void *)0);
#line 312
    rc = kernel_addresses(ifp->name, (int )ifp->ifindex, 1, ll, 32);
    }
#line 313
    if (rc < 0) {
      {
#line 314
      perror("kernel_addresses(link local)");
      }
#line 315
      goto fail;
    } else
#line 316
    if (rc == 0) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface %s has no link-local address.\n",
              ifp->name);
      }
#line 321
      goto fail_retry;
    } else {
      {
#line 323
      tmp___13 = malloc((size_t )(16 * rc));
#line 323
      ifp->ll = (unsigned char (*)[16])tmp___13;
      }
#line 324
      if ((unsigned long )ifp->ll == (unsigned long )((void *)0)) {
        {
#line 325
        perror("malloc(ll)");
        }
      } else {
#line 328
        i___2 = 0;
        {
#line 328
        while (1) {
          while_continue: /* CIL Label */ ;
#line 328
          if (! (i___2 < rc)) {
#line 328
            goto while_break;
          }
          {
#line 329
          memcpy((void */* __restrict  */)(*(ifp->ll + i___2)), (void const   */* __restrict  */)(ll[i___2].prefix),
                 (size_t )16);
#line 328
          i___2 ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 330
        ifp->numll = rc;
      }
    }
    {
#line 334
    memset((void *)(& mreq), 0, sizeof(mreq));
#line 335
    memcpy((void */* __restrict  */)(& mreq.ipv6mr_multiaddr), (void const   */* __restrict  */)(protocol_group),
           (size_t )16);
#line 336
    mreq.ipv6mr_interface = ifp->ifindex;
#line 337
    rc = setsockopt(protocol_socket, 41, 20, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
    }
#line 339
    if (rc < 0) {
      {
#line 340
      perror("setsockopt(IPV6_JOIN_GROUP)");
      }
#line 341
      goto fail;
    }
    {
#line 344
    check_interface_channel(ifp);
#line 345
    update_interface_metric(ifp);
#line 346
    rc = check_interface_ipv4(ifp);
    }
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 348
      tmp___16 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 348
      if (tmp___16) {
#line 348
        if (ifp->ipv4) {
#line 348
          tmp___14 = ", IPv4";
        } else {
#line 348
          tmp___14 = "";
        }
#line 348
        if ((int )ifp->flags & (1 << 1)) {
#line 348
          tmp___15 = "wired";
        } else {
#line 348
          tmp___15 = "wireless";
        }
        {
#line 348
        do_debugf(2, "Upped interface %s (%s, cost=%d, channel=%d%s).\n", ifp->name,
                  tmp___15, (int )ifp->cost, ifp->channel, tmp___14);
        }
      }
#line 348
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 355
    set_timeout(& ifp->hello_timeout, (int )ifp->hello_interval);
#line 356
    set_timeout(& ifp->update_timeout, (int )ifp->update_interval);
#line 357
    send_hello(ifp);
    }
#line 358
    if (rc > 0) {
      {
#line 359
      send_update(ifp, 0, (unsigned char const   *)((void *)0), (unsigned char)0);
      }
    }
    {
#line 360
    send_request(ifp, (unsigned char const   *)((void *)0), (unsigned char)0);
    }
  } else {
    {
#line 362
    flush_interface_routes(ifp, 0);
#line 363
    ifp->buffered = 0;
#line 364
    ifp->bufsize = 0;
#line 365
    free((void *)ifp->sendbuf);
#line 366
    ifp->num_buffered_updates = 0;
#line 367
    ifp->update_bufsize = 0;
    }
#line 368
    if (ifp->buffered_updates) {
      {
#line 369
      free((void *)ifp->buffered_updates);
      }
    }
#line 370
    ifp->buffered_updates = (struct buffered_update *)((void *)0);
#line 371
    ifp->sendbuf = (unsigned char *)((void *)0);
#line 372
    if (ifp->ifindex > 0U) {
      {
#line 373
      memset((void *)(& mreq), 0, sizeof(mreq));
#line 374
      memcpy((void */* __restrict  */)(& mreq.ipv6mr_multiaddr), (void const   */* __restrict  */)(protocol_group),
             (size_t )16);
#line 375
      mreq.ipv6mr_interface = ifp->ifindex;
#line 376
      rc = setsockopt(protocol_socket, 41, 21, (void const   *)((char *)(& mreq)),
                      (socklen_t )sizeof(mreq));
      }
#line 378
      if (rc < 0) {
        {
#line 379
        perror("setsockopt(IPV6_LEAVE_GROUP)");
        }
      }
      {
#line 380
      kernel_setup_interface(0, (char const   *)(ifp->name), (int )ifp->ifindex);
      }
    }
#line 382
    if (ifp->ll) {
      {
#line 383
      free((void *)ifp->ll);
      }
    }
#line 384
    ifp->ll = (unsigned char (*)[16])((void *)0);
#line 385
    ifp->numll = 0;
  }
#line 388
  return (1);
  fail_retry: 
  {
#line 391
  schedule_interfaces_check(2000, 0);
  }
  fail: 
#line 393
  if (! up) {
    {
#line 393
    __assert_fail("up", "/home/june/collector/temp/babeld-1.4.3/interface.c", 393U,
                  "interface_up");
    }
  }
  {
#line 394
  interface_up(ifp, 0);
  }
#line 395
  return (-1);
}
}
#line 398 "/home/june/collector/temp/babeld-1.4.3/interface.c"
int interface_ll_address(struct interface *ifp , unsigned char const   *address ) 
{ 
  int i___2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 403
  tmp = if_up(ifp);
  }
#line 403
  if (! tmp) {
#line 404
    return (0);
  }
#line 406
  i___2 = 0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i___2 < ifp->numll)) {
#line 406
      goto while_break;
    }
    {
#line 407
    tmp___0 = memcmp((void const   *)(*(ifp->ll + i___2)), (void const   *)address,
                     (size_t )16);
    }
#line 407
    if (tmp___0 == 0) {
#line 408
      return (1);
    }
#line 406
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (0);
}
}
#line 413 "/home/june/collector/temp/babeld-1.4.3/interface.c"
void check_interfaces(void) 
{ 
  struct interface *ifp ;
  int rc ;
  int ifindex_changed ;
  unsigned int ifindex ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 417
  ifindex_changed = 0;
#line 420
  ifp = interfaces;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! ifp) {
#line 420
      goto while_break;
    }
    {
#line 421
    ifindex = if_nametoindex((char const   *)(ifp->name));
    }
#line 422
    if (ifindex != ifp->ifindex) {
      {
#line 423
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 423
        tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 423
        if (tmp) {
          {
#line 423
          do_debugf(2, "Noticed ifindex change for %s.\n", ifp->name);
          }
        }
#line 423
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 424
      ifp->ifindex = 0U;
#line 425
      interface_up(ifp, 0);
#line 426
      ifp->ifindex = ifindex;
#line 427
      ifindex_changed = 1;
      }
    }
#line 430
    if (ifp->ifindex > 0U) {
      {
#line 431
      rc = kernel_interface_operational((char const   *)(ifp->name), (int )ifp->ifindex);
      }
    } else {
#line 433
      rc = 0;
    }
    {
#line 434
    tmp___1 = if_up(ifp);
    }
#line 434
    if ((rc > 0) != tmp___1) {
      {
#line 435
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 435
        tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 435
        if (tmp___0) {
          {
#line 435
          do_debugf(2, "Noticed status change for %s.\n", ifp->name);
          }
        }
#line 435
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 436
      interface_up(ifp, rc > 0);
      }
    }
    {
#line 439
    tmp___2 = if_up(ifp);
    }
#line 439
    if (tmp___2) {
      {
#line 442
      check_interface_channel(ifp);
#line 443
      rc = check_interface_ipv4(ifp);
      }
#line 444
      if (rc > 0) {
        {
#line 445
        send_request(ifp, (unsigned char const   *)((void *)0), (unsigned char)0);
#line 446
        send_update(ifp, 0, (unsigned char const   *)((void *)0), (unsigned char)0);
        }
      }
    }
#line 420
    ifp = ifp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (ifindex_changed) {
    {
#line 452
    renumber_filters();
    }
  }
#line 453
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 66 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int kernel_routes(struct kernel_route *routes___0 , int maxroutes___0 ) ;
#line 70 "/home/june/collector/temp/babeld-1.4.3/message.h"
void send_update_resend(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ) ;
#line 48 "/home/june/collector/temp/babeld-1.4.3/route.h"
int allow_duplicates ;
#line 72
struct babel_route *find_installed_route(unsigned char const   *prefix , unsigned char plen ) ;
#line 81
void install_route(struct babel_route *route ) ;
#line 82
void uninstall_route(struct babel_route *route ) ;
#line 92
struct babel_route *find_best_route(unsigned char const   *prefix , unsigned char plen ,
                                    int feasible , struct neighbour *exclude ) ;
#line 31 "/home/june/collector/temp/babeld-1.4.3/xroute.h"
struct xroute *find_xroute(unsigned char const   *prefix , unsigned char plen ) ;
#line 32
void flush_xroute(struct xroute *xroute ) ;
#line 33
int add_xroute(unsigned char *prefix , unsigned char plen , unsigned short metric ,
               unsigned int ifindex , int proto ) ;
#line 35
int xroutes_estimate(void) ;
#line 36
void for_all_xroutes(void (*f)(struct xroute * , void * ) , void *closure ) ;
#line 37
int check_xroutes(int send_updates ) ;
#line 98 "/home/june/collector/temp/babeld-1.4.3/util.h"
int martian_prefix(unsigned char const   *prefix , int plen )  __attribute__((__pure__)) ;
#line 48 "/home/june/collector/temp/babeld-1.4.3/configuration.h"
int redistribute_filter(unsigned char const   *prefix , unsigned short plen , unsigned int ifindex ,
                        int proto ) ;
#line 43 "/home/june/collector/temp/babeld-1.4.3/local.h"
void local_notify_xroute(struct xroute *xroute , int kind ) ;
#line 42 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
static struct xroute *xroutes  ;
#line 43 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
static int numxroutes  =    0;
#line 43 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
static int maxxroutes  =    0;
#line 45 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
struct xroute *find_xroute(unsigned char const   *prefix , unsigned char plen ) 
{ 
  int i___2 ;
  int tmp ;

  {
#line 49
  i___2 = 0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i___2 < numxroutes)) {
#line 49
      goto while_break;
    }
#line 50
    if ((int )(xroutes + i___2)->plen == (int )plen) {
      {
#line 50
      tmp = memcmp((void const   *)((xroutes + i___2)->prefix), (void const   *)prefix,
                   (size_t )16);
      }
#line 50
      if (tmp == 0) {
#line 52
        return (xroutes + i___2);
      }
    }
#line 49
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return ((struct xroute *)((void *)0));
}
}
#line 57 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
void flush_xroute(struct xroute *xroute ) 
{ 
  int i___2 ;
  struct xroute *new_xroutes ;
  int n ;
  void *tmp ;

  {
#line 62
  i___2 = (int )(xroute - xroutes);
#line 63
  if (i___2 >= 0) {
#line 63
    if (! (i___2 < numxroutes)) {
      {
#line 63
      __assert_fail("i >= 0 && i < numxroutes", "/home/june/collector/temp/babeld-1.4.3/xroute.c",
                    63U, "flush_xroute");
      }
    }
  } else {
    {
#line 63
    __assert_fail("i >= 0 && i < numxroutes", "/home/june/collector/temp/babeld-1.4.3/xroute.c",
                  63U, "flush_xroute");
    }
  }
  {
#line 65
  local_notify_xroute(xroute, 0);
  }
#line 67
  if (i___2 != numxroutes - 1) {
    {
#line 68
    memcpy((void */* __restrict  */)(xroutes + i___2), (void const   */* __restrict  */)((xroutes + numxroutes) - 1),
           sizeof(struct xroute ));
    }
  }
#line 69
  numxroutes --;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (numxroutes == 0) {
    {
#line 73
    free((void *)xroutes);
#line 74
    xroutes = (struct xroute *)((void *)0);
#line 75
    maxxroutes = 0;
    }
  } else
#line 76
  if (maxxroutes > 8) {
#line 76
    if (numxroutes < maxxroutes / 4) {
      {
#line 78
      n = maxxroutes / 2;
#line 79
      tmp = realloc((void *)xroutes, (unsigned long )n * sizeof(struct xroute ));
#line 79
      new_xroutes = (struct xroute *)tmp;
      }
#line 80
      if ((unsigned long )new_xroutes == (unsigned long )((void *)0)) {
#line 81
        return;
      }
#line 82
      xroutes = new_xroutes;
#line 83
      maxxroutes = n;
    }
  }
#line 85
  return;
}
}
#line 87 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
int add_xroute(unsigned char *prefix , unsigned char plen , unsigned short metric ,
               unsigned int ifindex , int proto ) 
{ 
  struct xroute *xroute ;
  struct xroute *tmp ;
  struct xroute *new_xroutes ;
  int n ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 91
  tmp = find_xroute((unsigned char const   *)prefix, plen);
#line 91
  xroute = tmp;
  }
#line 92
  if (xroute) {
#line 93
    if ((int )xroute->metric <= (int )metric) {
#line 94
      return (0);
    }
    {
#line 95
    xroute->metric = metric;
#line 96
    local_notify_xroute(xroute, 2);
    }
#line 97
    return (1);
  }
#line 100
  if (numxroutes >= maxxroutes) {
#line 102
    if (maxxroutes < 1) {
#line 102
      tmp___0 = 8;
    } else {
#line 102
      tmp___0 = 2 * maxxroutes;
    }
#line 102
    n = tmp___0;
#line 103
    if ((unsigned long )xroutes == (unsigned long )((void *)0)) {
      {
#line 103
      tmp___1 = malloc((unsigned long )n * sizeof(struct xroute ));
#line 103
      new_xroutes = (struct xroute *)tmp___1;
      }
    } else {
      {
#line 103
      tmp___2 = realloc((void *)xroutes, (unsigned long )n * sizeof(struct xroute ));
#line 103
      new_xroutes = (struct xroute *)tmp___2;
      }
    }
#line 106
    if ((unsigned long )new_xroutes == (unsigned long )((void *)0)) {
#line 107
      return (-1);
    }
#line 108
    maxxroutes = n;
#line 109
    xroutes = new_xroutes;
  }
  {
#line 112
  memcpy((void */* __restrict  */)((xroutes + numxroutes)->prefix), (void const   */* __restrict  */)prefix,
         (size_t )16);
#line 113
  (xroutes + numxroutes)->plen = plen;
#line 114
  (xroutes + numxroutes)->metric = metric;
#line 115
  (xroutes + numxroutes)->ifindex = ifindex;
#line 116
  (xroutes + numxroutes)->proto = proto;
#line 117
  numxroutes ++;
#line 118
  local_notify_xroute(xroutes + (numxroutes - 1), 1);
  }
#line 119
  return (1);
}
}
#line 123 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
int xroutes_estimate(void) 
{ 


  {
#line 126
  return (numxroutes);
}
}
#line 129 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
void for_all_xroutes(void (*f)(struct xroute * , void * ) , void *closure ) 
{ 
  int i___2 ;
  int n ;

  {
#line 132
  n = numxroutes;
#line 134
  i___2 = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i___2 < n)) {
#line 134
      goto while_break;
    }
    {
#line 135
    (*f)(xroutes + i___2, closure);
#line 134
    i___2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 144 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
static int maxroutes  =    8;
#line 138 "/home/june/collector/temp/babeld-1.4.3/xroute.c"
int check_xroutes(int send_updates ) 
{ 
  int i___2 ;
  int j ;
  int metric ;
  int export ;
  int change ;
  int rc ;
  struct kernel_route *routes___0 ;
  int numroutes ;
  int maxmaxroutes ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char prefix[16] ;
  unsigned char plen ;
  struct babel_route *route ;
  int tmp___2 ;
  struct babel_route *route___0 ;

  {
#line 141
  change = 0;
#line 145
  maxmaxroutes = 16384;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 147
    if (tmp) {
      {
#line 147
      do_debugf(2, "\nChecking kernel routes.\n");
      }
    }
#line 147
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  again: 
  {
#line 150
  tmp___0 = malloc((unsigned long )maxroutes * sizeof(struct kernel_route ));
#line 150
  routes___0 = (struct kernel_route *)tmp___0;
  }
#line 151
  if ((unsigned long )routes___0 == (unsigned long )((void *)0)) {
#line 152
    return (-1);
  }
  {
#line 154
  rc = kernel_addresses((char *)((void *)0), 0, 0, routes___0, maxroutes);
  }
#line 155
  if (rc < 0) {
    {
#line 156
    perror("kernel_addresses");
#line 157
    numroutes = 0;
    }
  } else {
#line 159
    numroutes = rc;
  }
#line 162
  if (numroutes >= maxroutes) {
#line 163
    goto resize;
  }
  {
#line 165
  rc = kernel_routes(routes___0 + numroutes, maxroutes - numroutes);
  }
#line 166
  if (rc < 0) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get kernel routes.\n");
    }
  } else {
#line 169
    numroutes += rc;
  }
#line 171
  if (numroutes >= maxroutes) {
#line 172
    goto resize;
  }
#line 176
  i___2 = 0;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (i___2 < numxroutes)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    export = 0;
#line 179
    metric = redistribute_filter((unsigned char const   *)((xroutes + i___2)->prefix),
                                 (unsigned short )(xroutes + i___2)->plen, (xroutes + i___2)->ifindex,
                                 (xroutes + i___2)->proto);
    }
#line 181
    if (metric < 65535) {
#line 181
      if (metric == (int )(xroutes + i___2)->metric) {
#line 182
        j = 0;
        {
#line 182
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 182
          if (! (j < numroutes)) {
#line 182
            goto while_break___1;
          }
#line 183
          if ((int )(xroutes + i___2)->plen == (routes___0 + j)->plen) {
            {
#line 183
            tmp___1 = memcmp((void const   *)((xroutes + i___2)->prefix), (void const   *)((routes___0 + j)->prefix),
                             (size_t )16);
            }
#line 183
            if (tmp___1 == 0) {
#line 183
              if ((xroutes + i___2)->ifindex == (routes___0 + j)->ifindex) {
#line 183
                if ((xroutes + i___2)->proto == (routes___0 + j)->proto) {
#line 187
                  export = 1;
#line 188
                  goto while_break___1;
                }
              }
            }
          }
#line 182
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 193
    if (! export) {
      {
#line 196
      memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)((xroutes + i___2)->prefix),
             (size_t )16);
#line 197
      plen = (xroutes + i___2)->plen;
#line 198
      flush_xroute(xroutes + i___2);
#line 199
      route = find_best_route((unsigned char const   *)(prefix), plen, 1, (struct neighbour *)((void *)0));
      }
#line 200
      if (route) {
        {
#line 201
        install_route(route);
        }
      }
#line 204
      if (send_updates) {
        {
#line 205
        send_update_resend((struct interface *)((void *)0), (unsigned char const   *)(prefix),
                           plen);
        }
      }
#line 206
      change = 1;
    } else {
#line 208
      i___2 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  i___2 = 0;
  {
#line 214
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 214
    if (! (i___2 < numroutes)) {
#line 214
      goto while_break___2;
    }
    {
#line 215
    tmp___2 = martian_prefix((unsigned char const   *)((routes___0 + i___2)->prefix),
                             (routes___0 + i___2)->plen);
    }
#line 215
    if (tmp___2) {
#line 216
      goto __Cont;
    }
    {
#line 217
    metric = redistribute_filter((unsigned char const   *)((routes___0 + i___2)->prefix),
                                 (unsigned short )(routes___0 + i___2)->plen, (routes___0 + i___2)->ifindex,
                                 (routes___0 + i___2)->proto);
    }
#line 219
    if (metric < 65535) {
      {
#line 220
      rc = add_xroute((unsigned char *)((routes___0 + i___2)->prefix), (unsigned char )(routes___0 + i___2)->plen,
                      (unsigned short )metric, (routes___0 + i___2)->ifindex, (routes___0 + i___2)->proto);
      }
#line 222
      if (rc > 0) {
        {
#line 224
        route___0 = find_installed_route((unsigned char const   *)((routes___0 + i___2)->prefix),
                                         (unsigned char )(routes___0 + i___2)->plen);
        }
#line 225
        if (route___0) {
#line 226
          if (allow_duplicates < 0) {
            {
#line 228
            uninstall_route(route___0);
            }
          } else
#line 226
          if ((routes___0 + i___2)->metric < allow_duplicates) {
            {
#line 228
            uninstall_route(route___0);
            }
          }
        }
#line 230
        change = 1;
#line 231
        if (send_updates) {
          {
#line 232
          send_update((struct interface *)((void *)0), 0, (unsigned char const   *)((routes___0 + i___2)->prefix),
                      (unsigned char )(routes___0 + i___2)->plen);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 214
    i___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 237
  free((void *)routes___0);
  }
#line 239
  if (numroutes + 8 <= maxmaxroutes) {
#line 239
    maxroutes = numroutes + 8;
  } else {
#line 239
    maxroutes = maxmaxroutes;
  }
#line 240
  return (change);
  resize: 
  {
#line 243
  free((void *)routes___0);
  }
#line 244
  if (maxroutes >= maxmaxroutes) {
#line 245
    return (-1);
  }
#line 246
  if (maxmaxroutes <= 2 * maxroutes) {
#line 246
    maxroutes = maxmaxroutes;
  } else {
#line 246
    maxroutes = 2 * maxroutes;
  }
#line 247
  goto again;
}
}
#line 48 "/home/june/collector/temp/babeld-1.4.3/util.h"
__inline static int seqno_compare(unsigned short s1 , unsigned short s2 ) 
{ 
  int tmp ;

  {
#line 51
  if ((int )s1 == (int )s2) {
#line 52
    return (0);
  } else {
#line 54
    if (((int )s2 - (int )s1) & 32768) {
#line 54
      tmp = 1;
    } else {
#line 54
      tmp = -1;
    }
#line 54
    return (tmp);
  }
}
}
#line 91
char const   *format_prefix(unsigned char const   *prefix , unsigned char plen ) ;
#line 92
char const   *format_eui64(unsigned char const   *eui ) ;
#line 36 "/home/june/collector/temp/babeld-1.4.3/source.h"
struct source *find_source(unsigned char const   *id , unsigned char const   *p ,
                           unsigned char plen , int create , unsigned short seqno ) ;
#line 40
struct source *retain_source(struct source *src ) ;
#line 41
void release_source(struct source *src ) ;
#line 42
int flush_source(struct source *src ) ;
#line 43
void update_source(struct source *src , unsigned short seqno , unsigned short metric ) ;
#line 45
void expire_sources(void) ;
#line 46
void check_sources_released(void) ;
#line 35 "/home/june/collector/temp/babeld-1.4.3/source.c"
struct source *srcs  =    (struct source *)((void *)0);
#line 37 "/home/june/collector/temp/babeld-1.4.3/source.c"
struct source *find_source(unsigned char const   *id , unsigned char const   *p ,
                           unsigned char plen , int create , unsigned short seqno ) 
{ 
  struct source *src ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 43
  src = srcs;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! src) {
#line 43
      goto while_break;
    }
#line 46
    if ((int )src->id[7] != (int )*(id + 7)) {
#line 47
      goto __Cont;
    }
    {
#line 48
    tmp = memcmp((void const   *)(src->id), (void const   *)id, (size_t )8);
    }
#line 48
    if (tmp != 0) {
#line 49
      goto __Cont;
    }
#line 50
    if ((int )src->plen != (int )plen) {
#line 51
      goto __Cont;
    }
    {
#line 52
    tmp___0 = memcmp((void const   *)(src->prefix), (void const   *)p, (size_t )16);
    }
#line 52
    if (tmp___0 == 0) {
#line 53
      return (src);
    }
    __Cont: /* CIL Label */ 
#line 43
    src = src->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (! create) {
#line 57
    return ((struct source *)((void *)0));
  }
  {
#line 59
  tmp___1 = malloc(sizeof(struct source ));
#line 59
  src = (struct source *)tmp___1;
  }
#line 60
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 61
    perror("malloc(source)");
    }
#line 62
    return ((struct source *)((void *)0));
  }
  {
#line 65
  memcpy((void */* __restrict  */)(src->id), (void const   */* __restrict  */)id,
         (size_t )8);
#line 66
  memcpy((void */* __restrict  */)(src->prefix), (void const   */* __restrict  */)p,
         (size_t )16);
#line 67
  src->plen = plen;
#line 68
  src->seqno = seqno;
#line 69
  src->metric = (unsigned short )(~ 0);
#line 70
  src->time = now.tv_sec;
#line 71
  src->route_count = (unsigned short)0;
#line 72
  src->next = srcs;
#line 73
  srcs = src;
  }
#line 74
  return (src);
}
}
#line 77 "/home/june/collector/temp/babeld-1.4.3/source.c"
struct source *retain_source(struct source *src ) 
{ 


  {
#line 80
  if (! ((int )src->route_count < 65535)) {
    {
#line 80
    __assert_fail("src->route_count < 0xffff", "/home/june/collector/temp/babeld-1.4.3/source.c",
                  80U, "retain_source");
    }
  }
#line 81
  src->route_count = (unsigned short )((int )src->route_count + 1);
#line 82
  return (src);
}
}
#line 85 "/home/june/collector/temp/babeld-1.4.3/source.c"
void release_source(struct source *src ) 
{ 


  {
#line 88
  if (! ((int )src->route_count > 0)) {
    {
#line 88
    __assert_fail("src->route_count > 0", "/home/june/collector/temp/babeld-1.4.3/source.c",
                  88U, "release_source");
    }
  }
#line 89
  src->route_count = (unsigned short )((int )src->route_count - 1);
#line 90
  return;
}
}
#line 92 "/home/june/collector/temp/babeld-1.4.3/source.c"
int flush_source(struct source *src ) 
{ 
  struct source *previous___0 ;

  {
#line 95
  if ((int )src->route_count > 0) {
#line 97
    return (0);
  }
#line 99
  if ((unsigned long )srcs == (unsigned long )src) {
#line 100
    srcs = src->next;
  } else {
#line 102
    previous___0 = srcs;
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! ((unsigned long )previous___0->next != (unsigned long )src)) {
#line 103
        goto while_break;
      }
#line 104
      previous___0 = previous___0->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 105
    previous___0->next = src->next;
  }
  {
#line 108
  free((void *)src);
  }
#line 109
  return (1);
}
}
#line 112 "/home/june/collector/temp/babeld-1.4.3/source.c"
void update_source(struct source *src , unsigned short seqno , unsigned short metric ) 
{ 
  int tmp ;

  {
#line 116
  if ((int )metric >= 65535) {
#line 117
    return;
  }
#line 123
  if (src->time < now.tv_sec - 200L) {
#line 126
    src->seqno = seqno;
#line 127
    src->metric = metric;
  } else {
    {
#line 123
    tmp = seqno_compare(src->seqno, seqno);
    }
#line 123
    if (tmp < 0) {
#line 126
      src->seqno = seqno;
#line 127
      src->metric = metric;
    } else
#line 123
    if ((int )src->seqno == (int )seqno) {
#line 123
      if ((int )src->metric > (int )metric) {
#line 126
        src->seqno = seqno;
#line 127
        src->metric = metric;
      }
    }
  }
#line 129
  src->time = now.tv_sec;
#line 130
  return;
}
}
#line 132 "/home/june/collector/temp/babeld-1.4.3/source.c"
void expire_sources(void) 
{ 
  struct source *src ;
  struct source *old ;

  {
#line 137
  src = srcs;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! src) {
#line 138
      goto while_break;
    }
#line 139
    if (src->time > now.tv_sec) {
#line 141
      src->time = now.tv_sec;
    }
#line 142
    if (src->time < now.tv_sec - 200L) {
      {
#line 143
      old = src;
#line 144
      src = src->next;
#line 145
      flush_source(old);
      }
#line 146
      goto while_continue;
    }
#line 148
    src = src->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/home/june/collector/temp/babeld-1.4.3/source.c"
void check_sources_released(void) 
{ 
  struct source *src ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 157
  src = srcs;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! src) {
#line 157
      goto while_break;
    }
#line 158
    if ((int )src->route_count != 0) {
      {
#line 159
      tmp = format_prefix((unsigned char const   *)(src->prefix), src->plen);
#line 159
      tmp___0 = format_eui64((unsigned char const   *)(src->id));
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: source %s %s has refcount %d.\n",
              tmp___0, tmp, (int )src->route_count);
      }
    }
#line 157
    src = src->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 87 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
int resend_delay ;
#line 94
unsigned char myid[8] ;
#line 98
int protocol_port ;
#line 104
void schedule_neighbours_check(int msecs , int override ) ;
#line 87 "/home/june/collector/temp/babeld-1.4.3/util.h"
unsigned char *mask_prefix(unsigned char * __restrict  ret , unsigned char const   * __restrict  prefix ,
                           unsigned char plen ) ;
#line 99
int linklocal(unsigned char const   *address )  __attribute__((__pure__)) ;
#line 100
int v4mapped(unsigned char const   *address )  __attribute__((__pure__)) ;
#line 25 "/home/june/collector/temp/babeld-1.4.3/net.h"
int babel_send(int s , void const   *buf1 , int buflen1 , void const   *buf2 , int buflen2 ,
               struct sockaddr  const  *sin , int slen ) ;
#line 48 "/home/june/collector/temp/babeld-1.4.3/route.h"
int kernel_metric ;
#line 49
int diversity_kind ;
#line 49
int diversity_factor ;
#line 52 "/home/june/collector/temp/babeld-1.4.3/route.h"
__inline static int route_metric(struct babel_route  const  *route ) 
{ 
  int m ;
  int tmp ;

  {
#line 55
  m = ((int )route->refmetric + (int )route->cost) + (int )route->add_metric;
#line 56
  if (m <= 65535) {
#line 56
    tmp = m;
  } else {
#line 56
    tmp = (int )((unsigned short )(~ 0));
  }
#line 56
  return (tmp);
}
}
#line 59 "/home/june/collector/temp/babeld-1.4.3/route.h"
__inline static int route_metric_noninterfering(struct babel_route  const  *route ) 
{ 
  int m ;
  int tmp ;

  {
#line 62
  m = ((int )route->refmetric + (diversity_factor * (int )route->cost + 128) / 256) + (int )route->add_metric;
#line 66
  if (m <= (int )((int const   )route->refmetric + 1)) {
#line 66
    m = (int )((int const   )route->refmetric + 1);
  } else {
#line 66
    m = m;
  }
#line 67
  if (m <= 65535) {
#line 67
    tmp = m;
  } else {
#line 67
    tmp = (int )((unsigned short )(~ 0));
  }
#line 67
  return (tmp);
}
}
#line 74
int installed_routes_estimate(void) ;
#line 80
void for_all_installed_routes(void (*f)(struct babel_route * , void * ) , void *closure ) ;
#line 87
int route_interferes(struct babel_route *route , struct interface *ifp ) ;
#line 99
struct babel_route *update_route(unsigned char const   *id , unsigned char const   *prefix ,
                                 unsigned char plen , unsigned short seqno , unsigned short refmetric ,
                                 unsigned short interval , struct neighbour *neigh ,
                                 unsigned char const   *nexthop , unsigned char const   *channels ,
                                 int channels_len___0 ) ;
#line 105
void retract_neighbour_routes(struct neighbour *neigh ) ;
#line 47 "/home/june/collector/temp/babeld-1.4.3/resend.h"
int record_resend(int kind , unsigned char const   *prefix , unsigned char plen ,
                  unsigned short seqno , unsigned char const   *id , struct interface *ifp ,
                  int delay ) ;
#line 52
int request_redundant(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ,
                      unsigned short seqno , unsigned char const   *id ) ;
#line 55
int satisfy_request(unsigned char const   *prefix , unsigned char plen , unsigned short seqno ,
                    unsigned char const   *id , struct interface *ifp ) ;
#line 48 "/home/june/collector/temp/babeld-1.4.3/message.h"
unsigned short myseqno ;
#line 49
struct timeval seqno_time ;
#line 57
struct timeval unicast_flush_timeout ;
#line 59
void parse_packet(unsigned char const   *from , struct interface *ifp , unsigned char const   *packet ,
                  int packetlen ) ;
#line 61
void flushbuf(struct interface *ifp ) ;
#line 62
void flushupdates(struct interface *ifp ) ;
#line 63
void send_ack(struct neighbour *neigh , unsigned short nonce , unsigned short interval ) ;
#line 65
void send_hello_noupdate(struct interface *ifp , unsigned int interval ) ;
#line 72
void send_wildcard_retraction(struct interface *ifp ) ;
#line 73
void update_myseqno(void) ;
#line 76
void send_marginal_ihu(struct interface *ifp ) ;
#line 81
void send_multihop_request(struct interface *ifp , unsigned char const   *prefix ,
                           unsigned char plen , unsigned short seqno , unsigned char const   *id ,
                           unsigned short hop_count ) ;
#line 85
void send_unicast_multihop_request(struct neighbour *neigh , unsigned char const   *prefix ,
                                   unsigned char plen , unsigned short seqno , unsigned char const   *id ,
                                   unsigned short hop_count ) ;
#line 90
void send_request_resend(struct neighbour *neigh , unsigned char const   *prefix ,
                         unsigned char plen , unsigned short seqno , unsigned char *id ) ;
#line 93
void handle_request(struct neighbour *neigh , unsigned char const   *prefix , unsigned char plen ,
                    unsigned char hop_count , unsigned short seqno , unsigned char const   *id ) ;
#line 46 "/home/june/collector/temp/babeld-1.4.3/configuration.h"
int output_filter(unsigned char const   *id , unsigned char const   *prefix , unsigned short plen ,
                  unsigned int ifindex ) ;
#line 44 "/home/june/collector/temp/babeld-1.4.3/message.c"
unsigned char packet_header[4]  = {      (unsigned char)42,      (unsigned char)2};
#line 46 "/home/june/collector/temp/babeld-1.4.3/message.c"
int split_horizon  =    1;
#line 48 "/home/june/collector/temp/babeld-1.4.3/message.c"
unsigned short myseqno  =    (unsigned short)0;
#line 49 "/home/june/collector/temp/babeld-1.4.3/message.c"
struct timeval seqno_time  =    {(__time_t )0, (__suseconds_t )0};
#line 52 "/home/june/collector/temp/babeld-1.4.3/message.c"
int unicast_buffered  =    0;
#line 53 "/home/june/collector/temp/babeld-1.4.3/message.c"
unsigned char *unicast_buffer  =    (unsigned char *)((void *)0);
#line 54 "/home/june/collector/temp/babeld-1.4.3/message.c"
struct neighbour *unicast_neighbour  =    (struct neighbour *)((void *)0);
#line 55 "/home/june/collector/temp/babeld-1.4.3/message.c"
struct timeval unicast_flush_timeout  =    {(__time_t )0, (__suseconds_t )0};
#line 57 "/home/june/collector/temp/babeld-1.4.3/message.c"
static unsigned char const   v4prefix[16]  = 
#line 57
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 62 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int network_prefix(int ae , int plen , unsigned int omitted , unsigned char const   *p ,
                          unsigned char const   *dp , unsigned int len , unsigned char *p_r ) 
{ 
  unsigned int pb ;
  unsigned char prefix[16] ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 69
  ret = -1;
#line 71
  if (plen >= 0) {
#line 72
    pb = (unsigned int )((plen + 7) / 8);
  } else
#line 73
  if (ae == 1) {
#line 74
    pb = 4U;
  } else {
#line 76
    pb = 16U;
  }
#line 78
  if (pb > 16U) {
#line 79
    return (-1);
  }
  {
#line 81
  memset((void *)(prefix), 0, (size_t )16);
  }
  {
#line 84
  if (ae == 0) {
#line 84
    goto case_0;
  }
#line 87
  if (ae == 1) {
#line 87
    goto case_1;
  }
#line 98
  if (ae == 2) {
#line 98
    goto case_2;
  }
#line 107
  if (ae == 3) {
#line 107
    goto case_3;
  }
#line 114
  goto switch_default;
  case_0: /* CIL Label */ 
#line 85
  ret = 0;
#line 86
  goto switch_break;
  case_1: /* CIL Label */ 
#line 88
  if (omitted > 4U) {
#line 89
    return (-1);
  } else
#line 88
  if (pb > 4U) {
#line 89
    return (-1);
  } else
#line 88
  if (pb > omitted) {
#line 88
    if (len < pb - omitted) {
#line 89
      return (-1);
    }
  }
  {
#line 90
  memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)(v4prefix),
         (size_t )12);
  }
#line 91
  if (omitted) {
#line 92
    if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 92
      return (-1);
    } else {
      {
#line 92
      tmp = v4mapped(dp);
      }
#line 92
      if (! tmp) {
#line 92
        return (-1);
      }
    }
    {
#line 93
    memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)dp,
           (size_t )(12U + omitted));
    }
  }
#line 95
  if (pb > omitted) {
    {
#line 95
    memcpy((void */* __restrict  */)((prefix + 12) + omitted), (void const   */* __restrict  */)p,
           (size_t )(pb - omitted));
    }
  }
#line 96
  ret = (int )(pb - omitted);
#line 97
  goto switch_break;
  case_2: /* CIL Label */ 
#line 99
  if (omitted > 16U) {
#line 99
    return (-1);
  } else
#line 99
  if (pb > omitted) {
#line 99
    if (len < pb - omitted) {
#line 99
      return (-1);
    }
  }
#line 100
  if (omitted) {
#line 101
    if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 101
      return (-1);
    } else {
      {
#line 101
      tmp___0 = v4mapped(dp);
      }
#line 101
      if (tmp___0) {
#line 101
        return (-1);
      }
    }
    {
#line 102
    memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)dp,
           (size_t )omitted);
    }
  }
#line 104
  if (pb > omitted) {
    {
#line 104
    memcpy((void */* __restrict  */)(prefix + omitted), (void const   */* __restrict  */)p,
           (size_t )(pb - omitted));
    }
  }
#line 105
  ret = (int )(pb - omitted);
#line 106
  goto switch_break;
  case_3: /* CIL Label */ 
#line 108
  if (pb > 8U) {
#line 108
    if (len < pb - 8U) {
#line 108
      return (-1);
    }
  }
#line 109
  prefix[0] = (unsigned char)254;
#line 110
  prefix[1] = (unsigned char)128;
#line 111
  if (pb > 8U) {
    {
#line 111
    memcpy((void */* __restrict  */)(prefix + 8), (void const   */* __restrict  */)p,
           (size_t )(pb - 8U));
    }
  }
#line 112
  ret = (int )(pb - 8U);
#line 113
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 115
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 118
  if (plen < 0) {
#line 118
    tmp___2 = 128;
  } else {
#line 118
    if (ae == 1) {
#line 118
      tmp___1 = plen + 96;
    } else {
#line 118
      tmp___1 = plen;
    }
#line 118
    tmp___2 = tmp___1;
  }
  {
#line 118
  mask_prefix((unsigned char */* __restrict  */)p_r, (unsigned char const   */* __restrict  */)(prefix),
              (unsigned char )tmp___2);
  }
#line 119
  return (ret);
}
}
#line 122 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void parse_route_attributes(unsigned char const   *a , int alen , unsigned char *channels ) 
{ 
  int type ;
  int len ;
  int i___2 ;
  void *tmp ;

  {
#line 126
  i___2 = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i___2 < alen)) {
#line 128
      goto while_break;
    }
#line 129
    type = (int )*(a + i___2);
#line 130
    if (type == 0) {
#line 131
      i___2 ++;
#line 132
      goto while_continue;
    }
#line 135
    if (i___2 + 1 > alen) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated attributes.\n");
      }
#line 137
      return;
    }
#line 139
    len = (int )*(a + (i___2 + 1));
#line 140
    if (i___2 + len > alen) {
      {
#line 141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated attributes.\n");
      }
#line 142
      return;
    }
#line 145
    if (! (type == 1)) {
#line 147
      if (type == 2) {
#line 148
        if (len > 8) {
          {
#line 149
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received overlong channel information (%d > %d).\n",
                  len, 8);
#line 152
          len = 8;
          }
        }
        {
#line 154
        tmp = memchr((void const   *)((a + i___2) + 2), 0, (size_t )len);
        }
#line 154
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
#line 156
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Channel information contains 0!");
          }
#line 157
          return;
        }
        {
#line 159
        memset((void *)channels, 0, (size_t )8);
#line 160
        memcpy((void */* __restrict  */)channels, (void const   */* __restrict  */)((a + i___2) + 2),
               (size_t )len);
        }
      } else {
        {
#line 162
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received unknown route attribute %d.\n",
                type);
        }
      }
    }
#line 165
    i___2 += len + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int network_address(int ae , unsigned char const   *a , unsigned int len ,
                           unsigned char *a_r ) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = network_prefix(ae, -1, 0U, a, (unsigned char const   *)((void *)0), len, a_r);
  }
#line 173
  return (tmp);
}
}
#line 176 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int channels_len(unsigned char *channels ) 
{ 
  unsigned char *p ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 179
  tmp = memchr((void const   *)channels, 0, (size_t )8);
#line 179
  p = (unsigned char *)tmp;
  }
#line 180
  if (p) {
#line 180
    tmp___0 = p - channels;
  } else {
#line 180
    tmp___0 = 8L;
  }
#line 180
  return ((int )tmp___0);
}
}
#line 183 "/home/june/collector/temp/babeld-1.4.3/message.c"
void parse_packet(unsigned char const   *from , struct interface *ifp , unsigned char const   *packet ,
                  int packetlen ) 
{ 
  int i___2 ;
  unsigned char const   *message ;
  unsigned char type ;
  unsigned char len ;
  int bodylen ;
  struct neighbour *neigh ;
  int have_router_id ;
  int have_v4_prefix ;
  int have_v6_prefix ;
  int have_v4_nh ;
  int have_v6_nh ;
  unsigned char router_id[8] ;
  unsigned char v4_prefix[16] ;
  unsigned char v6_prefix[16] ;
  unsigned char v4_nh[16] ;
  unsigned char v6_nh[16] ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  unsigned short nonce ;
  unsigned short interval ;
  char const   *tmp___8 ;
  long tmp___9 ;
  char const   *tmp___10 ;
  long tmp___11 ;
  unsigned short seqno ;
  unsigned short interval___0 ;
  int changed ;
  char const   *tmp___12 ;
  long tmp___13 ;
  unsigned short txcost ;
  unsigned short interval___1 ;
  unsigned char address[16] ;
  int rc ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  long tmp___16 ;
  int changed___0 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  long tmp___20 ;
  unsigned char nh[16] ;
  int rc___0 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  long tmp___23 ;
  unsigned char prefix[16] ;
  unsigned char *nh___0 ;
  unsigned char plen ;
  unsigned char channels[8] ;
  unsigned short interval___2 ;
  unsigned short seqno___0 ;
  unsigned short metric ;
  int rc___1 ;
  int parsed_len ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  long tmp___31 ;
  int tmp___32 ;
  unsigned char prefix___0[16] ;
  unsigned char plen___0 ;
  int rc___2 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  long tmp___37 ;
  unsigned int tmp___38 ;
  unsigned char prefix___1[16] ;
  unsigned char plen___1 ;
  unsigned short seqno___1 ;
  int rc___3 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  long tmp___43 ;
  char const   *tmp___44 ;
  long tmp___45 ;
  char const   *tmp___46 ;

  {
  {
#line 192
  have_router_id = 0;
#line 192
  have_v4_prefix = 0;
#line 192
  have_v6_prefix = 0;
#line 192
  have_v4_nh = 0;
#line 192
  have_v6_nh = 0;
#line 197
  tmp___0 = linklocal(from);
  }
#line 197
  if (! tmp___0) {
    {
#line 198
    tmp = format_address(from);
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received packet from non-local address %s.\n",
            tmp);
    }
#line 200
    return;
  }
#line 203
  if ((int const   )*(packet + 0) != 42) {
    {
#line 204
    tmp___1 = format_address(from);
#line 204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received malformed packet on %s from %s.\n",
            ifp->name, tmp___1);
    }
#line 206
    return;
  }
#line 209
  if ((int const   )*(packet + 1) != 2) {
    {
#line 210
    tmp___2 = format_address(from);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received packet with unknown version %d on %s from %s.\n",
            (int const   )*(packet + 1), ifp->name, tmp___2);
    }
#line 213
    return;
  }
  {
#line 216
  neigh = find_neighbour(from, ifp);
  }
#line 217
  if ((unsigned long )neigh == (unsigned long )((void *)0)) {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate neighbour.\n");
    }
#line 219
    return;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    tmp___3 = ntohs((uint16_t )*((unsigned short const   *)(packet + 2)));
#line 222
    bodylen = (int )tmp___3;
    }
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (bodylen + 4 > packetlen) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated packet (%d + 4 > %d).\n",
            bodylen, packetlen);
#line 227
    bodylen = packetlen - 4;
    }
  }
#line 230
  i___2 = 0;
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 231
    if (! (i___2 < bodylen)) {
#line 231
      goto while_break___0;
    }
#line 232
    message = (packet + 4) + i___2;
#line 233
    type = (unsigned char )*(message + 0);
#line 234
    if ((int )type == 0) {
      {
#line 235
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 235
        tmp___5 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 235
        if (tmp___5) {
          {
#line 235
          tmp___4 = format_address(from);
#line 235
          do_debugf(2, "Received pad1 from %s on %s.\n", tmp___4, ifp->name);
          }
        }
#line 235
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 237
      i___2 ++;
#line 238
      goto while_continue___0;
    }
#line 240
    if (i___2 + 1 > bodylen) {
      {
#line 241
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated message.\n");
      }
#line 242
      goto while_break___0;
    }
#line 244
    len = (unsigned char )*(message + 1);
#line 245
    if (i___2 + (int )len > bodylen) {
      {
#line 246
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated message.\n");
      }
#line 247
      goto while_break___0;
    }
#line 250
    if ((int )type == 1) {
      {
#line 251
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 251
        tmp___7 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 251
        if (tmp___7) {
          {
#line 251
          tmp___6 = format_address(from);
#line 251
          do_debugf(2, "Received pad%d from %s on %s.\n", (int )len, tmp___6, ifp->name);
          }
        }
#line 251
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 253
    if ((int )type == 2) {
#line 255
      if ((int )len < 6) {
#line 255
        goto fail;
      }
      {
#line 256
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 256
        nonce = ntohs((uint16_t )*((unsigned short const   *)(message + 4)));
        }
#line 256
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 257
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 257
        interval = ntohs((uint16_t )*((unsigned short const   *)(message + 6)));
        }
#line 257
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 258
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 258
        tmp___9 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 258
        if (tmp___9) {
          {
#line 258
          tmp___8 = format_address(from);
#line 258
          do_debugf(2, "Received ack-req (%04X %d) from %s on %s.\n", (int )nonce,
                    (int )interval, tmp___8, ifp->name);
          }
        }
#line 258
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 260
      send_ack(neigh, nonce, interval);
      }
    } else
#line 261
    if ((int )type == 3) {
      {
#line 262
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 262
        tmp___11 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 262
        if (tmp___11) {
          {
#line 262
          tmp___10 = format_address(from);
#line 262
          do_debugf(2, "Received ack from %s on %s.\n", tmp___10, ifp->name);
          }
        }
#line 262
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 265
    if ((int )type == 4) {
#line 268
      if ((int )len < 6) {
#line 268
        goto fail;
      }
      {
#line 269
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 269
        seqno = ntohs((uint16_t )*((unsigned short const   *)(message + 4)));
        }
#line 269
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 270
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 270
        interval___0 = ntohs((uint16_t )*((unsigned short const   *)(message + 6)));
        }
#line 270
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 271
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 271
        tmp___13 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 271
        if (tmp___13) {
          {
#line 271
          tmp___12 = format_address(from);
#line 271
          do_debugf(2, "Received hello %d (%d) from %s on %s.\n", (int )seqno, (int )interval___0,
                    tmp___12, ifp->name);
          }
        }
#line 271
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 274
      changed = update_neighbour(neigh, (int )seqno, (int )interval___0);
#line 275
      update_neighbour_metric(neigh, changed);
      }
#line 276
      if ((int )interval___0 > 0) {
        {
#line 278
        schedule_neighbours_check((int )interval___0 * 15, 0);
        }
      }
    } else
#line 279
    if ((int )type == 5) {
#line 283
      if ((int )len < 6) {
#line 283
        goto fail;
      }
      {
#line 284
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 284
        txcost = ntohs((uint16_t )*((unsigned short const   *)(message + 4)));
        }
#line 284
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 285
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 285
        interval___1 = ntohs((uint16_t )*((unsigned short const   *)(message + 6)));
        }
#line 285
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 286
      rc = network_address((int )*(message + 2), message + 8, (unsigned int )((int )len - 6),
                           address);
      }
#line 287
      if (rc < 0) {
#line 287
        goto fail;
      }
      {
#line 288
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 288
        tmp___16 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 288
        if (tmp___16) {
          {
#line 288
          tmp___14 = format_address((unsigned char const   *)(address));
#line 288
          tmp___15 = format_address(from);
#line 288
          do_debugf(2, "Received ihu %d (%d) from %s on %s for %s.\n", (int )txcost,
                    (int )interval___1, tmp___15, ifp->name, tmp___14);
          }
        }
#line 288
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 292
      if ((int const   )*(message + 2) == 0) {
#line 292
        goto _L;
      } else {
        {
#line 292
        tmp___17 = interface_ll_address(ifp, (unsigned char const   *)(address));
        }
#line 292
        if (tmp___17) {
          _L: /* CIL Label */ 
          {
#line 293
          changed___0 = (int )txcost != (int )neigh->txcost;
#line 294
          neigh->txcost = txcost;
#line 295
          neigh->ihu_time = now;
#line 296
          neigh->ihu_interval = interval___1;
#line 297
          update_neighbour_metric(neigh, changed___0);
          }
#line 298
          if ((int )interval___1 > 0) {
            {
#line 300
            schedule_neighbours_check((int )interval___1 * 45, 0);
            }
          }
        }
      }
    } else
#line 302
    if ((int )type == 6) {
#line 303
      if ((int )len < 10) {
#line 304
        have_router_id = 0;
#line 305
        goto fail;
      }
      {
#line 307
      memcpy((void */* __restrict  */)(router_id), (void const   */* __restrict  */)(message + 4),
             (size_t )8);
#line 308
      have_router_id = 1;
      }
      {
#line 309
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 309
        tmp___20 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 309
        if (tmp___20) {
          {
#line 309
          tmp___18 = format_address(from);
#line 309
          tmp___19 = format_eui64((unsigned char const   *)(router_id));
#line 309
          do_debugf(2, "Received router-id %s from %s on %s.\n", tmp___19, tmp___18,
                    ifp->name);
          }
        }
#line 309
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    } else
#line 311
    if ((int )type == 7) {
#line 314
      if ((int )len < 2) {
#line 315
        have_v4_nh = 0;
#line 316
        have_v6_nh = 0;
#line 317
        goto fail;
      }
      {
#line 319
      rc___0 = network_address((int )*(message + 2), message + 4, (unsigned int )((int )len - 2),
                               nh);
      }
#line 321
      if (rc___0 < 0) {
#line 322
        have_v4_nh = 0;
#line 323
        have_v6_nh = 0;
#line 324
        goto fail;
      }
      {
#line 326
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 326
        tmp___23 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 326
        if (tmp___23) {
          {
#line 326
          tmp___21 = format_address(from);
#line 326
          tmp___22 = format_address((unsigned char const   *)(nh));
#line 326
          do_debugf(2, "Received nh %s (%d) from %s on %s.\n", tmp___22, (int const   )*(message + 2),
                    tmp___21, ifp->name);
          }
        }
#line 326
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 329
      if ((int const   )*(message + 2) == 1) {
        {
#line 330
        memcpy((void */* __restrict  */)(v4_nh), (void const   */* __restrict  */)(nh),
               (size_t )16);
#line 331
        have_v4_nh = 1;
        }
      } else {
        {
#line 333
        memcpy((void */* __restrict  */)(v6_nh), (void const   */* __restrict  */)(nh),
               (size_t )16);
#line 334
        have_v6_nh = 1;
        }
      }
    } else
#line 336
    if ((int )type == 8) {
#line 342
      if ((int )len < 10) {
#line 343
        if ((int )len < 2) {
#line 344
          have_v6_prefix = 0;
#line 344
          have_v4_prefix = have_v6_prefix;
        } else
#line 343
        if ((int const   )*(message + 3) & 128) {
#line 344
          have_v6_prefix = 0;
#line 344
          have_v4_prefix = have_v6_prefix;
        }
#line 345
        goto fail;
      }
      {
#line 347
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 347
        interval___2 = ntohs((uint16_t )*((unsigned short const   *)(message + 6)));
        }
#line 347
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 348
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 348
        seqno___0 = ntohs((uint16_t )*((unsigned short const   *)(message + 8)));
        }
#line 348
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 349
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 349
        metric = ntohs((uint16_t )*((unsigned short const   *)(message + 10)));
        }
#line 349
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 350
      if ((int const   )*(message + 5) == 0) {
#line 350
        goto _L___0;
      } else {
#line 350
        if ((int const   )*(message + 2) == 1) {
#line 350
          tmp___25 = have_v4_prefix;
        } else {
#line 350
          tmp___25 = have_v6_prefix;
        }
#line 350
        if (tmp___25) {
          _L___0: /* CIL Label */ 
#line 352
          if ((int const   )*(message + 2) == 1) {
#line 352
            tmp___24 = v4_prefix;
          } else {
#line 352
            tmp___24 = v6_prefix;
          }
          {
#line 352
          rc___1 = network_prefix((int )*(message + 2), (int )*(message + 4), (unsigned int )*(message + 5),
                                  message + 12, (unsigned char const   *)tmp___24,
                                  (unsigned int )((int )len - 10), prefix);
          }
        } else {
#line 357
          rc___1 = -1;
        }
      }
#line 358
      if (rc___1 < 0) {
#line 359
        if ((int const   )*(message + 3) & 128) {
#line 360
          have_v6_prefix = 0;
#line 360
          have_v4_prefix = have_v6_prefix;
        }
#line 361
        goto fail;
      }
#line 363
      parsed_len = 10 + rc___1;
#line 365
      if ((int const   )*(message + 2) == 1) {
#line 365
        tmp___26 = 96;
      } else {
#line 365
        tmp___26 = 0;
      }
#line 365
      plen = (unsigned char )((int const   )*(message + 4) + (int const   )tmp___26);
#line 367
      if ((int const   )*(message + 3) & 128) {
#line 368
        if ((int const   )*(message + 2) == 1) {
          {
#line 369
          memcpy((void */* __restrict  */)(v4_prefix), (void const   */* __restrict  */)(prefix),
                 (size_t )16);
#line 370
          have_v4_prefix = 1;
          }
        } else {
          {
#line 372
          memcpy((void */* __restrict  */)(v6_prefix), (void const   */* __restrict  */)(prefix),
                 (size_t )16);
#line 373
          have_v6_prefix = 1;
          }
        }
      }
#line 376
      if ((int const   )*(message + 3) & 64) {
#line 377
        if ((int const   )*(message + 2) == 1) {
          {
#line 378
          memset((void *)(router_id), 0, (size_t )4);
#line 379
          memcpy((void */* __restrict  */)(router_id + 4), (void const   */* __restrict  */)(prefix + 12),
                 (size_t )4);
          }
        } else {
          {
#line 381
          memcpy((void */* __restrict  */)(router_id), (void const   */* __restrict  */)(prefix + 8),
                 (size_t )8);
          }
        }
#line 383
        have_router_id = 1;
      }
#line 385
      if (! have_router_id) {
#line 385
        if ((int const   )*(message + 2) != 0) {
          {
#line 386
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received prefix with no router id.\n");
          }
#line 387
          goto fail;
        }
      }
      {
#line 389
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 389
        tmp___31 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 389
        if (tmp___31) {
          {
#line 389
          tmp___27 = format_address(from);
#line 389
          tmp___28 = format_prefix((unsigned char const   *)(prefix), plen);
          }
#line 389
          if ((int const   )*(message + 3) & 64) {
#line 389
            tmp___29 = "/id";
          } else {
#line 389
            tmp___29 = "";
          }
#line 389
          if ((int const   )*(message + 3) & 128) {
#line 389
            tmp___30 = "/prefix";
          } else {
#line 389
            tmp___30 = "";
          }
          {
#line 389
          do_debugf(2, "Received update%s%s for %s from %s on %s.\n", tmp___30, tmp___29,
                    tmp___28, tmp___27, ifp->name);
          }
        }
#line 389
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 395
      if ((int const   )*(message + 2) == 0) {
#line 396
        if ((int )metric < 65535) {
          {
#line 397
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received wildcard update with finite metric.\n");
          }
#line 399
          goto done;
        }
        {
#line 401
        retract_neighbour_routes(neigh);
        }
#line 402
        goto done;
      } else
#line 403
      if ((int const   )*(message + 2) == 1) {
#line 404
        if (! have_v4_nh) {
#line 405
          goto fail;
        }
#line 406
        nh___0 = v4_nh;
      } else
#line 407
      if (have_v6_nh) {
#line 408
        nh___0 = v6_nh;
      } else {
#line 410
        nh___0 = neigh->address;
      }
#line 413
      if ((int const   )*(message + 2) == 1) {
#line 414
        if (! ifp->ipv4) {
#line 415
          goto done;
        }
      }
#line 418
      if ((int )ifp->flags & (1 << 4)) {
#line 419
        channels[0] = (unsigned char)0;
      } else {
#line 422
        if ((int )metric < 256) {
#line 424
          channels[0] = (unsigned char)0;
        } else {
#line 427
          channels[0] = (unsigned char)255;
#line 428
          channels[1] = (unsigned char)0;
        }
#line 431
        if (parsed_len < (int )len) {
          {
#line 432
          parse_route_attributes((message + 2) + parsed_len, (int )len - parsed_len,
                                 channels);
          }
        }
      }
      {
#line 436
      tmp___32 = channels_len(channels);
#line 436
      update_route((unsigned char const   *)(router_id), (unsigned char const   *)(prefix),
                   plen, seqno___0, metric, interval___2, neigh, (unsigned char const   *)nh___0,
                   (unsigned char const   *)(channels), tmp___32);
      }
    } else
#line 439
    if ((int )type == 9) {
#line 442
      if ((int )len < 2) {
#line 442
        goto fail;
      }
      {
#line 443
      rc___2 = network_prefix((int )*(message + 2), (int )*(message + 3), 0U, message + 4,
                              (unsigned char const   *)((void *)0), (unsigned int )((int )len - 2),
                              prefix___0);
      }
#line 445
      if (rc___2 < 0) {
#line 445
        goto fail;
      }
#line 446
      if ((int const   )*(message + 2) == 1) {
#line 446
        tmp___33 = 96;
      } else {
#line 446
        tmp___33 = 0;
      }
#line 446
      plen___0 = (unsigned char )((int const   )*(message + 3) + (int const   )tmp___33);
      {
#line 447
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 447
        tmp___37 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 447
        if (tmp___37) {
          {
#line 447
          tmp___34 = format_address(from);
          }
#line 447
          if ((int const   )*(message + 2) == 0) {
#line 447
            tmp___36 = "any";
          } else {
            {
#line 447
            tmp___35 = format_prefix((unsigned char const   *)(prefix___0), plen___0);
#line 447
            tmp___36 = tmp___35;
            }
          }
          {
#line 447
          do_debugf(2, "Received request for %s from %s on %s.\n", tmp___36, tmp___34,
                    ifp->name);
          }
        }
#line 447
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 450
      if ((int const   )*(message + 2) == 0) {
        {
#line 453
        send_ihu(neigh, (struct interface *)((void *)0));
        }
#line 458
        if ((neigh->ifp)->hello_interval / 100U <= 1U) {
#line 458
          tmp___38 = 1U;
        } else {
#line 458
          tmp___38 = (neigh->ifp)->hello_interval / 100U;
        }
#line 458
        if ((neigh->ifp)->last_update_time < now.tv_sec - (__time_t )tmp___38) {
          {
#line 460
          send_update(neigh->ifp, 0, (unsigned char const   *)((void *)0), (unsigned char)0);
          }
        }
      } else {
        {
#line 462
        send_update(neigh->ifp, 0, (unsigned char const   *)(prefix___0), plen___0);
        }
      }
    } else
#line 464
    if ((int )type == 10) {
#line 468
      if ((int )len < 14) {
#line 468
        goto fail;
      }
      {
#line 469
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 469
        seqno___1 = ntohs((uint16_t )*((unsigned short const   *)(message + 4)));
        }
#line 469
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 470
      rc___3 = network_prefix((int )*(message + 2), (int )*(message + 3), 0U, message + 16,
                              (unsigned char const   *)((void *)0), (unsigned int )((int )len - 14),
                              prefix___1);
      }
#line 472
      if (rc___3 < 0) {
#line 472
        goto fail;
      }
#line 473
      if ((int const   )*(message + 2) == 1) {
#line 473
        tmp___39 = 96;
      } else {
#line 473
        tmp___39 = 0;
      }
#line 473
      plen___1 = (unsigned char )((int const   )*(message + 3) + (int const   )tmp___39);
      {
#line 474
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 474
        tmp___43 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 474
        if (tmp___43) {
          {
#line 474
          tmp___40 = format_eui64(message + 8);
#line 474
          tmp___41 = format_address(from);
#line 474
          tmp___42 = format_prefix((unsigned char const   *)(prefix___1), plen___1);
#line 474
          do_debugf(2, "Received request (%d) for %s from %s on %s (%s, %d).\n", (int const   )*(message + 6),
                    tmp___42, tmp___41, ifp->name, tmp___40, (int )seqno___1);
          }
        }
#line 474
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 479
      handle_request(neigh, (unsigned char const   *)(prefix___1), plen___1, (unsigned char )*(message + 6),
                     seqno___1, message + 8);
      }
    } else {
      {
#line 482
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 482
        tmp___45 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 482
        if (tmp___45) {
          {
#line 482
          tmp___44 = format_address(from);
#line 482
          do_debugf(2, "Received unknown packet type %d from %s on %s.\n", (int )type,
                    tmp___44, ifp->name);
          }
        }
#line 482
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
    done: 
#line 486
    i___2 += (int )len + 2;
#line 487
    goto while_continue___0;
    fail: 
    {
#line 490
    tmp___46 = format_address(from);
#line 490
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse packet (%d, %d) from %s on %s.\n",
            (int const   )*(message + 0), (int const   )*(message + 1), tmp___46,
            ifp->name);
    }
#line 492
    goto done;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 501 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int check_bucket(struct interface *ifp ) 
{ 
  int seconds ;

  {
#line 504
  if (ifp->bucket <= 0U) {
#line 505
    seconds = (int )(now.tv_sec - ifp->bucket_time);
#line 506
    if (seconds > 0) {
#line 507
      if (200 <= seconds * 40) {
#line 507
        ifp->bucket = 200U;
      } else {
#line 507
        ifp->bucket = (unsigned int )(seconds * 40);
      }
    }
#line 511
    ifp->bucket_time = now.tv_sec;
  }
#line 514
  if (ifp->bucket > 0U) {
#line 515
    (ifp->bucket) --;
#line 516
    return (1);
  } else {
#line 518
    return (0);
  }
}
}
#line 522 "/home/june/collector/temp/babeld-1.4.3/message.c"
void flushbuf(struct interface *ifp ) 
{ 
  int rc ;
  struct sockaddr_in6 sin6 ;
  long tmp ;
  int tmp___0 ;

  {
#line 528
  if (! (ifp->buffered <= ifp->bufsize)) {
    {
#line 528
    __assert_fail("ifp->buffered <= ifp->bufsize", "/home/june/collector/temp/babeld-1.4.3/message.c",
                  528U, "flushbuf");
    }
  }
  {
#line 530
  flushupdates(ifp);
  }
#line 532
  if (ifp->buffered > 0) {
    {
#line 533
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 533
      tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 533
      if (tmp) {
        {
#line 533
        do_debugf(2, "  (flushing %d buffered bytes on %s)\n", ifp->buffered, ifp->name);
        }
      }
#line 533
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 535
    tmp___0 = check_bucket(ifp);
    }
#line 535
    if (tmp___0) {
      {
#line 536
      memset((void *)(& sin6), 0, sizeof(sin6));
#line 537
      sin6.sin6_family = (sa_family_t )10;
#line 538
      memcpy((void */* __restrict  */)(& sin6.sin6_addr), (void const   */* __restrict  */)(protocol_group),
             (size_t )16);
#line 539
      sin6.sin6_port = htons((uint16_t )protocol_port);
#line 540
      sin6.sin6_scope_id = ifp->ifindex;
      }
      {
#line 541
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 541
        *((unsigned short *)(packet_header + 2)) = htons((uint16_t )ifp->buffered);
        }
#line 541
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 542
      rc = babel_send(protocol_socket, (void const   *)(packet_header), (int )sizeof(packet_header),
                      (void const   *)ifp->sendbuf, ifp->buffered, (struct sockaddr  const  *)((struct sockaddr *)(& sin6)),
                      (int )sizeof(sin6));
      }
#line 546
      if (rc < 0) {
        {
#line 547
        perror("send");
        }
      }
    } else {
      {
#line 549
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: bucket full, dropping packet to %s.\n",
              ifp->name);
      }
    }
  }
  {
#line 553
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 553
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 554
  ifp->buffered = 0;
#line 555
  ifp->have_buffered_hello = (char)0;
#line 556
  ifp->have_buffered_id = (char)0;
#line 557
  ifp->have_buffered_nh = (char)0;
#line 558
  ifp->have_buffered_prefix = (char)0;
#line 559
  ifp->flush_timeout.tv_sec = (__time_t )0;
#line 560
  ifp->flush_timeout.tv_usec = (__suseconds_t )0;
#line 561
  return;
}
}
#line 563 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void schedule_flush(struct interface *ifp ) 
{ 
  unsigned int msecs ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 566
  tmp = jitter(ifp, 0);
#line 566
  msecs = tmp;
  }
#line 567
  if (ifp->flush_timeout.tv_sec != 0L) {
    {
#line 567
    tmp___0 = timeval_minus_msec((struct timeval  const  *)(& ifp->flush_timeout),
                                 (struct timeval  const  *)(& now));
    }
#line 567
    if (tmp___0 < msecs) {
#line 569
      return;
    }
  }
  {
#line 570
  set_timeout(& ifp->flush_timeout, (int )msecs);
  }
#line 571
  return;
}
}
#line 573 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void schedule_flush_now(struct interface *ifp ) 
{ 
  unsigned int msecs ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 577
  tmp = roughly(10);
#line 577
  msecs = (unsigned int )tmp;
  }
#line 578
  if (ifp->flush_timeout.tv_sec != 0L) {
    {
#line 578
    tmp___0 = timeval_minus_msec((struct timeval  const  *)(& ifp->flush_timeout),
                                 (struct timeval  const  *)(& now));
    }
#line 578
    if (tmp___0 < msecs) {
#line 580
      return;
    }
  }
  {
#line 581
  set_timeout(& ifp->flush_timeout, (int )msecs);
  }
#line 582
  return;
}
}
#line 584 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void schedule_unicast_flush(unsigned int msecs ) 
{ 
  unsigned int tmp ;

  {
#line 587
  if (! unicast_neighbour) {
#line 588
    return;
  }
#line 589
  if (unicast_flush_timeout.tv_sec != 0L) {
    {
#line 589
    tmp = timeval_minus_msec((struct timeval  const  *)(& unicast_flush_timeout),
                             (struct timeval  const  *)(& now));
    }
#line 589
    if (tmp < msecs) {
#line 591
      return;
    }
  }
#line 592
  unicast_flush_timeout.tv_usec = (now.tv_usec + (__suseconds_t )(msecs * 1000U)) % 1000000L;
#line 593
  unicast_flush_timeout.tv_sec = now.tv_sec + (now.tv_usec / 1000L + (__suseconds_t )msecs) / 1000L;
#line 595
  return;
}
}
#line 597 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void ensure_space(struct interface *ifp , int space ) 
{ 


  {
#line 600
  if (ifp->bufsize - ifp->buffered < space) {
    {
#line 601
    flushbuf(ifp);
    }
  }
#line 602
  return;
}
}
#line 604 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void start_message(struct interface *ifp , int type , int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 607
  if (ifp->bufsize - ifp->buffered < len + 2) {
    {
#line 608
    flushbuf(ifp);
    }
  }
#line 609
  tmp = ifp->buffered;
#line 609
  (ifp->buffered) ++;
#line 609
  *(ifp->sendbuf + tmp) = (unsigned char )type;
#line 610
  tmp___0 = ifp->buffered;
#line 610
  (ifp->buffered) ++;
#line 610
  *(ifp->sendbuf + tmp___0) = (unsigned char )len;
#line 611
  return;
}
}
#line 613 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void end_message(struct interface *ifp , int type , int bytes ) 
{ 


  {
#line 616
  if (ifp->buffered >= bytes + 2) {
#line 616
    if ((int )*(ifp->sendbuf + ((ifp->buffered - bytes) - 2)) == type) {
#line 616
      if (! ((int )*(ifp->sendbuf + ((ifp->buffered - bytes) - 1)) == bytes)) {
        {
#line 616
        __assert_fail("ifp->buffered >= bytes + 2 && ifp->sendbuf[ifp->buffered - bytes - 2] == type && ifp->sendbuf[ifp->buffered - bytes - 1] == bytes",
                      "/home/june/collector/temp/babeld-1.4.3/message.c", 618U, "end_message");
        }
      }
    } else {
      {
#line 616
      __assert_fail("ifp->buffered >= bytes + 2 && ifp->sendbuf[ifp->buffered - bytes - 2] == type && ifp->sendbuf[ifp->buffered - bytes - 1] == bytes",
                    "/home/june/collector/temp/babeld-1.4.3/message.c", 618U, "end_message");
      }
    }
  } else {
    {
#line 616
    __assert_fail("ifp->buffered >= bytes + 2 && ifp->sendbuf[ifp->buffered - bytes - 2] == type && ifp->sendbuf[ifp->buffered - bytes - 1] == bytes",
                  "/home/june/collector/temp/babeld-1.4.3/message.c", 618U, "end_message");
    }
  }
  {
#line 619
  schedule_flush(ifp);
  }
#line 620
  return;
}
}
#line 622 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_byte(struct interface *ifp , unsigned char value ) 
{ 
  int tmp ;

  {
#line 625
  tmp = ifp->buffered;
#line 625
  (ifp->buffered) ++;
#line 625
  *(ifp->sendbuf + tmp) = value;
#line 626
  return;
}
}
#line 628 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_short(struct interface *ifp , unsigned short value ) 
{ 


  {
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 631
    *((unsigned short *)(ifp->sendbuf + ifp->buffered)) = htons(value);
    }
#line 631
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  ifp->buffered += 2;
#line 633
  return;
}
}
#line 635 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_bytes(struct interface *ifp , unsigned char const   *value ,
                             unsigned int len ) 
{ 


  {
  {
#line 639
  memcpy((void */* __restrict  */)(ifp->sendbuf + ifp->buffered), (void const   */* __restrict  */)value,
         (size_t )len);
#line 640
  ifp->buffered = (int )((unsigned int )ifp->buffered + len);
  }
#line 641
  return;
}
}
#line 643 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int start_unicast_message(struct neighbour *neigh , int type , int len ) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 646
  if (unicast_neighbour) {
#line 647
    if ((unsigned long )neigh != (unsigned long )unicast_neighbour) {
      {
#line 650
      flush_unicast(0);
      }
    } else {
#line 647
      if (1024 <= (neigh->ifp)->bufsize) {
#line 647
        tmp = 1024;
      } else {
#line 647
        tmp = (neigh->ifp)->bufsize;
      }
#line 647
      if ((unicast_buffered + len) + 2 >= tmp) {
        {
#line 650
        flush_unicast(0);
        }
      }
    }
  }
#line 652
  if (! unicast_buffer) {
    {
#line 653
    tmp___0 = malloc((size_t )1024);
#line 653
    unicast_buffer = (unsigned char *)tmp___0;
    }
  }
#line 654
  if (! unicast_buffer) {
    {
#line 655
    perror("malloc(unicast_buffer)");
    }
#line 656
    return (-1);
  }
#line 659
  unicast_neighbour = neigh;
#line 661
  tmp___1 = unicast_buffered;
#line 661
  unicast_buffered ++;
#line 661
  *(unicast_buffer + tmp___1) = (unsigned char )type;
#line 662
  tmp___2 = unicast_buffered;
#line 662
  unicast_buffered ++;
#line 662
  *(unicast_buffer + tmp___2) = (unsigned char )len;
#line 663
  return (1);
}
}
#line 666 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void end_unicast_message(struct neighbour *neigh , int type , int bytes ) 
{ 
  unsigned int tmp ;

  {
#line 669
  if ((unsigned long )unicast_neighbour == (unsigned long )neigh) {
#line 669
    if (unicast_buffered >= bytes + 2) {
#line 669
      if ((int )*(unicast_buffer + ((unicast_buffered - bytes) - 2)) == type) {
#line 669
        if (! ((int )*(unicast_buffer + ((unicast_buffered - bytes) - 1)) == bytes)) {
          {
#line 669
          __assert_fail("unicast_neighbour == neigh && unicast_buffered >= bytes + 2 && unicast_buffer[unicast_buffered - bytes - 2] == type && unicast_buffer[unicast_buffered - bytes - 1] == bytes",
                        "/home/june/collector/temp/babeld-1.4.3/message.c", 671U,
                        "end_unicast_message");
          }
        }
      } else {
        {
#line 669
        __assert_fail("unicast_neighbour == neigh && unicast_buffered >= bytes + 2 && unicast_buffer[unicast_buffered - bytes - 2] == type && unicast_buffer[unicast_buffered - bytes - 1] == bytes",
                      "/home/june/collector/temp/babeld-1.4.3/message.c", 671U, "end_unicast_message");
        }
      }
    } else {
      {
#line 669
      __assert_fail("unicast_neighbour == neigh && unicast_buffered >= bytes + 2 && unicast_buffer[unicast_buffered - bytes - 2] == type && unicast_buffer[unicast_buffered - bytes - 1] == bytes",
                    "/home/june/collector/temp/babeld-1.4.3/message.c", 671U, "end_unicast_message");
      }
    }
  } else {
    {
#line 669
    __assert_fail("unicast_neighbour == neigh && unicast_buffered >= bytes + 2 && unicast_buffer[unicast_buffered - bytes - 2] == type && unicast_buffer[unicast_buffered - bytes - 1] == bytes",
                  "/home/june/collector/temp/babeld-1.4.3/message.c", 671U, "end_unicast_message");
    }
  }
  {
#line 672
  tmp = jitter(neigh->ifp, 0);
#line 672
  schedule_unicast_flush(tmp);
  }
#line 673
  return;
}
}
#line 675 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_unicast_byte(struct neighbour *neigh , unsigned char value ) 
{ 
  int tmp ;

  {
#line 678
  tmp = unicast_buffered;
#line 678
  unicast_buffered ++;
#line 678
  *(unicast_buffer + tmp) = value;
#line 679
  return;
}
}
#line 681 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_unicast_short(struct neighbour *neigh , unsigned short value ) 
{ 


  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    *((unsigned short *)(unicast_buffer + unicast_buffered)) = htons(value);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  unicast_buffered += 2;
#line 686
  return;
}
}
#line 688 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void accumulate_unicast_bytes(struct neighbour *neigh , unsigned char const   *value ,
                                     unsigned int len ) 
{ 


  {
  {
#line 692
  memcpy((void */* __restrict  */)(unicast_buffer + unicast_buffered), (void const   */* __restrict  */)value,
         (size_t )len);
#line 693
  unicast_buffered = (int )((unsigned int )unicast_buffered + len);
  }
#line 694
  return;
}
}
#line 696 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_ack(struct neighbour *neigh , unsigned short nonce , unsigned short interval ) 
{ 
  int rc ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 700
    tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 700
    if (tmp___0) {
      {
#line 700
      tmp = format_address((unsigned char const   *)(neigh->address));
#line 700
      do_debugf(2, "Sending ack (%04x) to %s on %s.\n", (int )nonce, tmp, (neigh->ifp)->name);
      }
    }
#line 700
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  rc = start_unicast_message(neigh, 3, 2);
  }
#line 702
  if (rc < 0) {
#line 702
    return;
  }
  {
#line 703
  accumulate_unicast_short(neigh, nonce);
#line 704
  end_unicast_message(neigh, 3, 2);
#line 706
  tmp___1 = roughly((int )interval * 6);
#line 706
  schedule_unicast_flush((unsigned int )tmp___1);
  }
#line 707
  return;
}
}
#line 709 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_hello_noupdate(struct interface *ifp , unsigned int interval ) 
{ 
  int tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 714
  if (ifp->have_buffered_hello) {
    {
#line 715
    flushbuf(ifp);
    }
  }
  {
#line 717
  ifp->hello_seqno = seqno_plus(ifp->hello_seqno, 1);
#line 718
  set_timeout(& ifp->hello_timeout, (int )ifp->hello_interval);
#line 720
  tmp = if_up(ifp);
  }
#line 720
  if (! tmp) {
#line 721
    return;
  }
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 723
    tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 723
    if (tmp___0) {
      {
#line 723
      do_debugf(2, "Sending hello %d (%d) to %s.\n", (int )ifp->hello_seqno, interval,
                ifp->name);
      }
    }
#line 723
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 726
  start_message(ifp, 4, 6);
#line 727
  accumulate_short(ifp, (unsigned short)0);
#line 728
  accumulate_short(ifp, ifp->hello_seqno);
  }
#line 729
  if (interval > 65535U) {
#line 729
    tmp___1 = 65535U;
  } else {
#line 729
    tmp___1 = interval;
  }
  {
#line 729
  accumulate_short(ifp, (unsigned short )tmp___1);
#line 730
  end_message(ifp, 4, 6);
#line 731
  ifp->have_buffered_hello = (char)1;
  }
#line 732
  return;
}
}
#line 734 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_hello(struct interface *ifp ) 
{ 


  {
  {
#line 737
  send_hello_noupdate(ifp, (ifp->hello_interval + 9U) / 10U);
  }
#line 739
  if ((int )ifp->hello_seqno % 3 == 0) {
    {
#line 740
    send_ihu((struct neighbour *)((void *)0), ifp);
    }
  } else {
    {
#line 742
    send_marginal_ihu(ifp);
    }
  }
#line 743
  return;
}
}
#line 745 "/home/june/collector/temp/babeld-1.4.3/message.c"
void flush_unicast(int dofree ) 
{ 
  struct sockaddr_in6 sin6 ;
  int rc ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 751
  if (unicast_buffered == 0) {
#line 752
    goto done;
  }
  {
#line 754
  tmp = if_up(unicast_neighbour->ifp);
  }
#line 754
  if (! tmp) {
#line 755
    goto done;
  }
  {
#line 758
  flushbuf(unicast_neighbour->ifp);
#line 760
  tmp___1 = check_bucket(unicast_neighbour->ifp);
  }
#line 760
  if (tmp___1) {
    {
#line 761
    memset((void *)(& sin6), 0, sizeof(sin6));
#line 762
    sin6.sin6_family = (sa_family_t )10;
#line 763
    memcpy((void */* __restrict  */)(& sin6.sin6_addr), (void const   */* __restrict  */)(unicast_neighbour->address),
           (size_t )16);
#line 764
    sin6.sin6_port = htons((uint16_t )protocol_port);
#line 765
    sin6.sin6_scope_id = (unicast_neighbour->ifp)->ifindex;
    }
    {
#line 766
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 766
      *((unsigned short *)(packet_header + 2)) = htons((uint16_t )unicast_buffered);
      }
#line 766
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 767
    rc = babel_send(protocol_socket, (void const   *)(packet_header), (int )sizeof(packet_header),
                    (void const   *)unicast_buffer, unicast_buffered, (struct sockaddr  const  *)((struct sockaddr *)(& sin6)),
                    (int )sizeof(sin6));
    }
#line 771
    if (rc < 0) {
      {
#line 772
      perror("send(unicast)");
      }
    }
  } else {
    {
#line 774
    tmp___0 = format_address((unsigned char const   *)(unicast_neighbour->address));
#line 774
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: bucket full, dropping unicast packetto %s if %s.\n",
            tmp___0, (unicast_neighbour->ifp)->name);
    }
  }
  done: 
  {
#line 782
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 782
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 783
  unicast_buffered = 0;
#line 784
  if (dofree) {
#line 784
    if (unicast_buffer) {
      {
#line 785
      free((void *)unicast_buffer);
#line 786
      unicast_buffer = (unsigned char *)((void *)0);
      }
    }
  }
#line 788
  unicast_neighbour = (struct neighbour *)((void *)0);
#line 789
  unicast_flush_timeout.tv_sec = (__time_t )0;
#line 790
  unicast_flush_timeout.tv_usec = (__suseconds_t )0;
#line 791
  return;
}
}
#line 793 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void really_send_update(struct interface *ifp , unsigned char const   *id ,
                               unsigned char const   *prefix , unsigned char plen ,
                               unsigned short seqno , unsigned short metric , unsigned char *channels ,
                               int channels_len___0 ) 
{ 
  int add_metric ;
  int v4 ;
  int real_plen ;
  int omit ;
  unsigned char const   *real_prefix ;
  unsigned short flags ;
  int channels_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 800
  omit = 0;
#line 802
  flags = (unsigned short)0;
#line 805
  if (diversity_kind != 3) {
#line 806
    channels_len___0 = -1;
  }
#line 808
  if (channels_len___0 >= 0) {
#line 808
    channels_size = channels_len___0 + 2;
  } else {
#line 808
    channels_size = 0;
  }
  {
#line 810
  tmp = if_up(ifp);
  }
#line 810
  if (! tmp) {
#line 811
    return;
  }
  {
#line 813
  add_metric = output_filter(id, prefix, (unsigned short )plen, ifp->ifindex);
  }
#line 814
  if (add_metric >= 65535) {
#line 815
    return;
  }
#line 817
  if ((int )metric + add_metric <= 65535) {
#line 817
    metric = (unsigned short )((int )metric + add_metric);
  } else {
#line 817
    metric = (unsigned short )(~ 0);
  }
  {
#line 819
  ensure_space(ifp, 60);
  }
#line 821
  if ((int )plen >= 96) {
    {
#line 821
    tmp___0 = v4mapped(prefix);
    }
#line 821
    if (tmp___0) {
#line 821
      tmp___1 = 1;
    } else {
#line 821
      tmp___1 = 0;
    }
  } else {
#line 821
    tmp___1 = 0;
  }
#line 821
  v4 = tmp___1;
#line 823
  if (v4) {
#line 824
    if (! ifp->ipv4) {
#line 825
      return;
    }
#line 826
    if (! ifp->have_buffered_nh) {
#line 826
      goto _L;
    } else {
      {
#line 826
      tmp___2 = memcmp((void const   *)(ifp->buffered_nh), (void const   *)ifp->ipv4,
                       (size_t )4);
      }
#line 826
      if (tmp___2 != 0) {
        _L: /* CIL Label */ 
        {
#line 828
        start_message(ifp, 7, 6);
#line 829
        accumulate_byte(ifp, (unsigned char)1);
#line 830
        accumulate_byte(ifp, (unsigned char)0);
#line 831
        accumulate_bytes(ifp, (unsigned char const   *)ifp->ipv4, 4U);
#line 832
        end_message(ifp, 7, 6);
#line 833
        memcpy((void */* __restrict  */)(ifp->buffered_nh), (void const   */* __restrict  */)ifp->ipv4,
               (size_t )4);
#line 834
        ifp->have_buffered_nh = (char)1;
        }
      }
    }
#line 837
    real_prefix = prefix + 12;
#line 838
    real_plen = (int )plen - 96;
  } else {
#line 840
    if (ifp->have_buffered_prefix) {
      {
#line 841
      while (1) {
        while_continue: /* CIL Label */ ;
#line 841
        if (omit < (int )plen / 8) {
#line 841
          if (! ((int )ifp->buffered_prefix[omit] == (int )*(prefix + omit))) {
#line 841
            goto while_break;
          }
        } else {
#line 841
          goto while_break;
        }
#line 843
        omit ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 845
    if (! ifp->have_buffered_prefix) {
#line 846
      flags = (unsigned short )((int )flags | 128);
    } else
#line 845
    if ((int )plen >= 48) {
#line 846
      flags = (unsigned short )((int )flags | 128);
    }
#line 847
    real_prefix = prefix;
#line 848
    real_plen = (int )plen;
  }
#line 851
  if (! ifp->have_buffered_id) {
#line 851
    goto _L___0;
  } else {
    {
#line 851
    tmp___4 = memcmp((void const   *)id, (void const   *)(ifp->buffered_id), (size_t )8);
    }
#line 851
    if (tmp___4 != 0) {
      _L___0: /* CIL Label */ 
#line 852
      if (real_plen == 128) {
        {
#line 852
        tmp___3 = memcmp((void const   *)(real_prefix + 8), (void const   *)id, (size_t )8);
        }
#line 852
        if (tmp___3 == 0) {
#line 853
          flags = (unsigned short )((int )flags | 64);
        } else {
          {
#line 855
          start_message(ifp, 6, 10);
#line 856
          accumulate_short(ifp, (unsigned short)0);
#line 857
          accumulate_bytes(ifp, id, 8U);
#line 858
          end_message(ifp, 6, 10);
          }
        }
      } else {
        {
#line 855
        start_message(ifp, 6, 10);
#line 856
        accumulate_short(ifp, (unsigned short)0);
#line 857
        accumulate_bytes(ifp, id, 8U);
#line 858
        end_message(ifp, 6, 10);
        }
      }
      {
#line 860
      memcpy((void */* __restrict  */)(ifp->buffered_id), (void const   */* __restrict  */)id,
             (size_t )16);
#line 861
      ifp->have_buffered_id = (char)1;
      }
    }
  }
  {
#line 864
  start_message(ifp, 8, ((10 + (real_plen + 7) / 8) - omit) + channels_size);
  }
#line 866
  if (v4) {
#line 866
    tmp___5 = 1;
  } else {
#line 866
    tmp___5 = 2;
  }
  {
#line 866
  accumulate_byte(ifp, (unsigned char )tmp___5);
#line 867
  accumulate_byte(ifp, (unsigned char )flags);
#line 868
  accumulate_byte(ifp, (unsigned char )real_plen);
#line 869
  accumulate_byte(ifp, (unsigned char )omit);
#line 870
  accumulate_short(ifp, (unsigned short )((ifp->update_interval + 5U) / 10U));
#line 871
  accumulate_short(ifp, seqno);
#line 872
  accumulate_short(ifp, metric);
#line 873
  accumulate_bytes(ifp, real_prefix + omit, (unsigned int )((real_plen + 7) / 8 - omit));
  }
#line 875
  if (channels_len___0 >= 0) {
    {
#line 876
    accumulate_byte(ifp, (unsigned char)2);
#line 877
    accumulate_byte(ifp, (unsigned char )channels_len___0);
#line 878
    accumulate_bytes(ifp, (unsigned char const   *)channels, (unsigned int )channels_len___0);
    }
  }
  {
#line 880
  end_message(ifp, 8, ((10 + (real_plen + 7) / 8) - omit) + channels_size);
  }
#line 883
  if ((int )flags & 128) {
    {
#line 884
    memcpy((void */* __restrict  */)(ifp->buffered_prefix), (void const   */* __restrict  */)prefix,
           (size_t )16);
#line 885
    ifp->have_buffered_prefix = (char)1;
    }
  }
#line 887
  return;
}
}
#line 889 "/home/june/collector/temp/babeld-1.4.3/message.c"
static int compare_buffered_updates(void const   *av , void const   *bv ) 
{ 
  struct buffered_update  const  *a ;
  struct buffered_update  const  *b ;
  int rc ;
  int v4a ;
  int v4b ;
  int ma ;
  int mb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 892
  a = (struct buffered_update  const  *)av;
#line 892
  b = (struct buffered_update  const  *)bv;
#line 895
  rc = memcmp((void const   *)(a->id), (void const   *)(b->id), (size_t )8);
  }
#line 896
  if (rc != 0) {
#line 897
    return (rc);
  }
#line 899
  if ((int const   )a->plen >= 96) {
    {
#line 899
    tmp = v4mapped((unsigned char const   *)(a->prefix));
    }
#line 899
    if (tmp) {
#line 899
      tmp___0 = 1;
    } else {
#line 899
      tmp___0 = 0;
    }
  } else {
#line 899
    tmp___0 = 0;
  }
#line 899
  v4a = tmp___0;
#line 900
  if ((int const   )b->plen >= 96) {
    {
#line 900
    tmp___1 = v4mapped((unsigned char const   *)(b->prefix));
    }
#line 900
    if (tmp___1) {
#line 900
      tmp___2 = 1;
    } else {
#line 900
      tmp___2 = 0;
    }
  } else {
#line 900
    tmp___2 = 0;
  }
#line 900
  v4b = tmp___2;
#line 902
  if (v4a > v4b) {
#line 903
    return (1);
  } else
#line 904
  if (v4a < v4b) {
#line 905
    return (-1);
  }
#line 907
  if (! v4a) {
#line 907
    if ((int const   )a->plen == 128) {
      {
#line 907
      tmp___3 = memcmp((void const   *)(a->prefix + 8), (void const   *)(a->id), (size_t )8);
      }
#line 907
      if (tmp___3 == 0) {
#line 907
        tmp___4 = 1;
      } else {
#line 907
        tmp___4 = 0;
      }
    } else {
#line 907
      tmp___4 = 0;
    }
  } else {
#line 907
    tmp___4 = 0;
  }
#line 907
  ma = tmp___4;
#line 908
  if (! v4b) {
#line 908
    if ((int const   )b->plen == 128) {
      {
#line 908
      tmp___5 = memcmp((void const   *)(b->prefix + 8), (void const   *)(b->id), (size_t )8);
      }
#line 908
      if (tmp___5 == 0) {
#line 908
        tmp___6 = 1;
      } else {
#line 908
        tmp___6 = 0;
      }
    } else {
#line 908
      tmp___6 = 0;
    }
  } else {
#line 908
    tmp___6 = 0;
  }
#line 908
  mb = tmp___6;
#line 910
  if (ma > mb) {
#line 911
    return (-1);
  } else
#line 912
  if (mb > ma) {
#line 913
    return (1);
  }
#line 915
  if ((int const   )a->plen < (int const   )b->plen) {
#line 916
    return (1);
  } else
#line 917
  if ((int const   )a->plen > (int const   )b->plen) {
#line 918
    return (-1);
  }
  {
#line 920
  tmp___7 = memcmp((void const   *)(a->prefix), (void const   *)(b->prefix), (size_t )16);
  }
#line 920
  return (tmp___7);
}
}
#line 923 "/home/june/collector/temp/babeld-1.4.3/message.c"
void flushupdates(struct interface *ifp ) 
{ 
  struct xroute *xroute ;
  struct babel_route *route ;
  unsigned char const   *last_prefix ;
  unsigned char last_plen ;
  int i___2 ;
  struct interface *ifp_aux ;
  struct buffered_update *b ;
  int n ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned char channels[8] ;
  int chlen ;
  struct interface *route_ifp ;
  unsigned short metric ;
  unsigned short seqno ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 928
  last_prefix = (unsigned char const   *)((void *)0);
#line 929
  last_plen = (unsigned char)255;
#line 932
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 934
    ifp_aux = interfaces;
    {
#line 934
    while (1) {
      while_continue: /* CIL Label */ ;
#line 934
      if (! ifp_aux) {
#line 934
        goto while_break;
      }
      {
#line 935
      flushupdates(ifp_aux);
#line 934
      ifp_aux = ifp_aux->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 936
    return;
  }
#line 939
  if (ifp->num_buffered_updates > 0) {
    {
#line 940
    b = ifp->buffered_updates;
#line 941
    n = ifp->num_buffered_updates;
#line 943
    ifp->buffered_updates = (struct buffered_update *)((void *)0);
#line 944
    ifp->update_bufsize = 0;
#line 945
    ifp->num_buffered_updates = 0;
#line 947
    tmp = if_up(ifp);
    }
#line 947
    if (! tmp) {
#line 948
      goto done;
    }
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 950
      tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 950
      if (tmp___0) {
        {
#line 950
        do_debugf(2, "  (flushing %d buffered updates on %s (%d))\n", n, ifp->name,
                  ifp->ifindex);
        }
      }
#line 950
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 956
    i___2 = 0;
    {
#line 956
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 956
      if (! (i___2 < n)) {
#line 956
        goto while_break___1;
      }
      {
#line 957
      route = find_installed_route((unsigned char const   *)((b + i___2)->prefix),
                                   (b + i___2)->plen);
      }
#line 958
      if (route) {
        {
#line 959
        memcpy((void */* __restrict  */)((b + i___2)->id), (void const   */* __restrict  */)((route->src)->id),
               (size_t )8);
        }
      } else {
        {
#line 961
        memcpy((void */* __restrict  */)((b + i___2)->id), (void const   */* __restrict  */)(myid),
               (size_t )8);
        }
      }
#line 956
      i___2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 964
    qsort((void *)b, (size_t )n, sizeof(struct buffered_update ), & compare_buffered_updates);
#line 966
    i___2 = 0;
    }
    {
#line 966
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 966
      if (! (i___2 < n)) {
#line 966
        goto while_break___2;
      }
#line 971
      if (last_prefix) {
#line 972
        if ((int )(b + i___2)->plen == (int )last_plen) {
          {
#line 972
          tmp___1 = memcmp((void const   *)((b + i___2)->prefix), (void const   *)last_prefix,
                           (size_t )16);
          }
#line 972
          if (tmp___1 == 0) {
#line 974
            goto __Cont;
          }
        }
      }
      {
#line 977
      xroute = find_xroute((unsigned char const   *)((b + i___2)->prefix), (b + i___2)->plen);
#line 978
      route = find_installed_route((unsigned char const   *)((b + i___2)->prefix),
                                   (b + i___2)->plen);
      }
#line 980
      if (xroute) {
#line 980
        if (! route) {
          {
#line 981
          really_send_update(ifp, (unsigned char const   *)(myid), (unsigned char const   *)(xroute->prefix),
                             xroute->plen, myseqno, xroute->metric, (unsigned char *)((void *)0),
                             0);
#line 985
          last_prefix = (unsigned char const   *)(xroute->prefix);
#line 986
          last_plen = xroute->plen;
          }
        } else
#line 980
        if ((int )xroute->metric <= kernel_metric) {
          {
#line 981
          really_send_update(ifp, (unsigned char const   *)(myid), (unsigned char const   *)(xroute->prefix),
                             xroute->plen, myseqno, xroute->metric, (unsigned char *)((void *)0),
                             0);
#line 985
          last_prefix = (unsigned char const   *)(xroute->prefix);
#line 986
          last_plen = xroute->plen;
          }
        } else {
#line 980
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 987
      if (route) {
        {
#line 990
        route_ifp = (route->neigh)->ifp;
#line 994
        seqno = route->seqno;
#line 995
        tmp___5 = route_interferes(route, ifp);
        }
#line 995
        if (tmp___5) {
          {
#line 995
          tmp___3 = route_metric((struct babel_route  const  *)route);
#line 995
          metric = (unsigned short )tmp___3;
          }
        } else {
          {
#line 995
          tmp___4 = route_metric_noninterfering((struct babel_route  const  *)route);
#line 995
          metric = (unsigned short )tmp___4;
          }
        }
#line 1000
        if ((int )metric < 65535) {
          {
#line 1001
          satisfy_request((unsigned char const   *)((route->src)->prefix), (route->src)->plen,
                          seqno, (unsigned char const   *)((route->src)->id), ifp);
          }
        }
#line 1004
        if ((int )ifp->flags & (1 << 2)) {
#line 1004
          if ((unsigned long )(route->neigh)->ifp == (unsigned long )ifp) {
#line 1006
            goto __Cont;
          }
        }
#line 1008
        if (route_ifp->channel == -2) {
          {
#line 1009
          memcpy((void */* __restrict  */)(channels), (void const   */* __restrict  */)(route->channels),
                 (size_t )8);
          }
        } else {
#line 1011
          if (route_ifp->channel == 0) {
#line 1012
            channels[0] = (unsigned char)255;
          } else {
#line 1014
            if (route_ifp->channel > 0) {
#line 1014
              if (! (route_ifp->channel <= 255)) {
                {
#line 1014
                __assert_fail("route_ifp->channel > 0 && route_ifp->channel <= 255",
                              "/home/june/collector/temp/babeld-1.4.3/message.c",
                              1015U, "flushupdates");
                }
              }
            } else {
              {
#line 1014
              __assert_fail("route_ifp->channel > 0 && route_ifp->channel <= 255",
                            "/home/june/collector/temp/babeld-1.4.3/message.c", 1015U,
                            "flushupdates");
              }
            }
#line 1016
            channels[0] = (unsigned char )route_ifp->channel;
          }
          {
#line 1018
          memcpy((void */* __restrict  */)(channels + 1), (void const   */* __restrict  */)(route->channels),
                 (size_t )7);
          }
        }
        {
#line 1021
        chlen = channels_len(channels);
#line 1022
        really_send_update(ifp, (unsigned char const   *)((route->src)->id), (unsigned char const   *)((route->src)->prefix),
                           (route->src)->plen, seqno, metric, channels, chlen);
#line 1027
        update_source(route->src, seqno, metric);
#line 1028
        last_prefix = (unsigned char const   *)((route->src)->prefix);
#line 1029
        last_plen = (route->src)->plen;
        }
      } else {
        {
#line 1033
        really_send_update(ifp, (unsigned char const   *)(myid), (unsigned char const   *)((b + i___2)->prefix),
                           (b + i___2)->plen, myseqno, (unsigned short )(~ 0), (unsigned char *)((void *)0),
                           -1);
        }
      }
      __Cont: /* CIL Label */ 
#line 966
      i___2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1037
    schedule_flush_now(ifp);
    }
    done: 
    {
#line 1039
    free((void *)b);
    }
  }
#line 1041
  ifp->update_flush_timeout.tv_sec = (__time_t )0;
#line 1042
  ifp->update_flush_timeout.tv_usec = (__suseconds_t )0;
#line 1043
  return;
}
}
#line 1045 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void schedule_update_flush(struct interface *ifp , int urgent ) 
{ 
  unsigned int msecs ;
  unsigned int tmp ;

  {
  {
#line 1049
  msecs = update_jitter(ifp, urgent);
  }
#line 1050
  if (ifp->update_flush_timeout.tv_sec != 0L) {
    {
#line 1050
    tmp = timeval_minus_msec((struct timeval  const  *)(& ifp->update_flush_timeout),
                             (struct timeval  const  *)(& now));
    }
#line 1050
    if (tmp < msecs) {
#line 1052
      return;
    }
  }
  {
#line 1053
  set_timeout(& ifp->update_flush_timeout, (int )msecs);
  }
#line 1054
  return;
}
}
#line 1056 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void buffer_update(struct interface *ifp , unsigned char const   *prefix ,
                          unsigned char plen ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1060
  if (ifp->num_buffered_updates > 0) {
#line 1060
    if (ifp->num_buffered_updates >= ifp->update_bufsize) {
      {
#line 1062
      flushupdates(ifp);
      }
    }
  }
#line 1064
  if (ifp->update_bufsize == 0) {
#line 1066
    if (! ((unsigned long )ifp->buffered_updates == (unsigned long )((void *)0))) {
      {
#line 1066
      __assert_fail("ifp->buffered_updates == ((void *)0)", "/home/june/collector/temp/babeld-1.4.3/message.c",
                    1066U, "buffer_update");
      }
    }
    {
#line 1070
    tmp = installed_routes_estimate();
#line 1070
    tmp___0 = xroutes_estimate();
#line 1070
    n = (tmp + tmp___0) + 4;
    }
#line 1071
    if (n <= ifp->bufsize / 16) {
#line 1071
      n = ifp->bufsize / 16;
    } else {
#line 1071
      n = n;
    }
    again: 
    {
#line 1073
    tmp___1 = malloc((unsigned long )n * sizeof(struct buffered_update ));
#line 1073
    ifp->buffered_updates = (struct buffered_update *)tmp___1;
    }
#line 1074
    if ((unsigned long )ifp->buffered_updates == (unsigned long )((void *)0)) {
      {
#line 1075
      perror("malloc(buffered_updates)");
      }
#line 1076
      if (n > 4) {
#line 1078
        n = 4;
#line 1079
        goto again;
      }
#line 1081
      return;
    }
#line 1083
    ifp->update_bufsize = n;
#line 1084
    ifp->num_buffered_updates = 0;
  }
  {
#line 1087
  memcpy((void */* __restrict  */)((ifp->buffered_updates + ifp->num_buffered_updates)->prefix),
         (void const   */* __restrict  */)prefix, (size_t )16);
#line 1089
  (ifp->buffered_updates + ifp->num_buffered_updates)->plen = plen;
#line 1090
  (ifp->num_buffered_updates) ++;
  }
#line 1091
  return;
}
}
#line 1093 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void buffer_update_callback(struct babel_route *route , void *closure ) 
{ 


  {
  {
#line 1096
  buffer_update((struct interface *)closure, (unsigned char const   *)((route->src)->prefix),
                (route->src)->plen);
  }
#line 1098
  return;
}
}
#line 1100 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_update(struct interface *ifp , int urgent , unsigned char const   *prefix ,
                 unsigned char plen ) 
{ 
  struct interface *ifp_aux ;
  struct babel_route *route ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1104
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1107
    ifp_aux = interfaces;
    {
#line 1107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1107
      if (! ifp_aux) {
#line 1107
        goto while_break;
      }
      {
#line 1108
      send_update(ifp_aux, urgent, prefix, plen);
#line 1107
      ifp_aux = ifp_aux->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1109
    if (prefix) {
      {
#line 1112
      route = find_installed_route(prefix, plen);
      }
#line 1113
      if (route) {
        {
#line 1113
        tmp = route_metric((struct babel_route  const  *)route);
        }
#line 1113
        if (tmp < 65535) {
          {
#line 1114
          satisfy_request(prefix, plen, (route->src)->seqno, (unsigned char const   *)((route->src)->id),
                          (struct interface *)((void *)0));
          }
        }
      }
    }
#line 1117
    return;
  }
  {
#line 1120
  tmp___0 = if_up(ifp);
  }
#line 1120
  if (! tmp___0) {
#line 1121
    return;
  }
#line 1123
  if (prefix) {
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1124
      tmp___2 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 1124
      if (tmp___2) {
        {
#line 1124
        tmp___1 = format_prefix(prefix, plen);
#line 1124
        do_debugf(2, "Sending update to %s for %s.\n", ifp->name, tmp___1);
        }
      }
#line 1124
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1126
    buffer_update(ifp, prefix, plen);
    }
  } else {
    {
#line 1128
    send_self_update(ifp);
    }
    {
#line 1129
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1129
      tmp___3 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 1129
      if (tmp___3) {
        {
#line 1129
        do_debugf(2, "Sending update to %s for any.\n", ifp->name);
        }
      }
#line 1129
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1130
    for_all_installed_routes(& buffer_update_callback, (void *)ifp);
#line 1131
    set_timeout(& ifp->update_timeout, (int )ifp->update_interval);
#line 1132
    ifp->last_update_time = now.tv_sec;
    }
  }
  {
#line 1134
  schedule_update_flush(ifp, urgent);
  }
#line 1135
  return;
}
}
#line 1137 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_update_resend(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ) 
{ 


  {
#line 1141
  if (! ((unsigned long )prefix != (unsigned long )((void *)0))) {
    {
#line 1141
    __assert_fail("prefix != ((void *)0)", "/home/june/collector/temp/babeld-1.4.3/message.c",
                  1141U, "send_update_resend");
    }
  }
  {
#line 1143
  send_update(ifp, 1, prefix, plen);
#line 1144
  record_resend(2, prefix, plen, (unsigned short)0, (unsigned char const   *)0, (struct interface *)((void *)0),
                resend_delay);
  }
#line 1145
  return;
}
}
#line 1147 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_wildcard_retraction(struct interface *ifp ) 
{ 
  struct interface *ifp_aux ;
  int tmp ;

  {
#line 1150
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1152
    ifp_aux = interfaces;
    {
#line 1152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1152
      if (! ifp_aux) {
#line 1152
        goto while_break;
      }
      {
#line 1153
      send_wildcard_retraction(ifp_aux);
#line 1152
      ifp_aux = ifp_aux->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1154
    return;
  }
  {
#line 1157
  tmp = if_up(ifp);
  }
#line 1157
  if (! tmp) {
#line 1158
    return;
  }
  {
#line 1160
  start_message(ifp, 8, 10);
#line 1161
  accumulate_byte(ifp, (unsigned char)0);
#line 1162
  accumulate_byte(ifp, (unsigned char)64);
#line 1163
  accumulate_byte(ifp, (unsigned char)0);
#line 1164
  accumulate_byte(ifp, (unsigned char)0);
#line 1165
  accumulate_short(ifp, (unsigned short)65535);
#line 1166
  accumulate_short(ifp, myseqno);
#line 1167
  accumulate_short(ifp, (unsigned short)65535);
#line 1168
  end_message(ifp, 8, 10);
#line 1170
  ifp->have_buffered_id = (char)0;
  }
#line 1171
  return;
}
}
#line 1173 "/home/june/collector/temp/babeld-1.4.3/message.c"
void update_myseqno(void) 
{ 


  {
  {
#line 1176
  myseqno = seqno_plus(myseqno, 1);
#line 1177
  seqno_time = now;
  }
#line 1178
  return;
}
}
#line 1180 "/home/june/collector/temp/babeld-1.4.3/message.c"
static void send_xroute_update_callback(struct xroute *xroute , void *closure ) 
{ 
  struct interface *ifp ;

  {
  {
#line 1183
  ifp = (struct interface *)closure;
#line 1184
  send_update(ifp, 0, (unsigned char const   *)(xroute->prefix), xroute->plen);
  }
#line 1185
  return;
}
}
#line 1187 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_self_update(struct interface *ifp ) 
{ 
  struct interface *ifp_aux ;
  int tmp ;
  long tmp___0 ;

  {
#line 1190
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1192
    ifp_aux = interfaces;
    {
#line 1192
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1192
      if (! ifp_aux) {
#line 1192
        goto while_break;
      }
      {
#line 1193
      tmp = if_up(ifp_aux);
      }
#line 1193
      if (! tmp) {
#line 1194
        goto __Cont;
      }
      {
#line 1195
      send_self_update(ifp_aux);
      }
      __Cont: /* CIL Label */ 
#line 1192
      ifp_aux = ifp_aux->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1197
    return;
  }
  {
#line 1200
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1200
    tmp___0 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1200
    if (tmp___0) {
      {
#line 1200
      do_debugf(2, "Sending self update to %s.\n", ifp->name);
      }
    }
#line 1200
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1201
  for_all_xroutes(& send_xroute_update_callback, (void *)ifp);
  }
#line 1202
  return;
}
}
#line 1204 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_ihu(struct neighbour *neigh , struct interface *ifp ) 
{ 
  int rxcost ;
  int interval ;
  int ll ;
  struct interface *ifp_aux ;
  int tmp ;
  struct neighbour *ngh ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int rc ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1210
  if ((unsigned long )neigh == (unsigned long )((void *)0)) {
#line 1210
    if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1212
      ifp_aux = interfaces;
      {
#line 1212
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1212
        if (! ifp_aux) {
#line 1212
          goto while_break;
        }
        {
#line 1213
        tmp = if_up(ifp_aux);
        }
#line 1213
        if (tmp) {
#line 1214
          goto __Cont;
        }
        {
#line 1215
        send_ihu((struct neighbour *)((void *)0), ifp_aux);
        }
        __Cont: /* CIL Label */ 
#line 1212
        ifp_aux = ifp_aux->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 1217
      return;
    }
  }
#line 1220
  if ((unsigned long )neigh == (unsigned long )((void *)0)) {
#line 1222
    ngh = neighs;
    {
#line 1222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1222
      if (! ngh) {
#line 1222
        goto while_break___0;
      }
#line 1223
      if ((unsigned long )ngh->ifp == (unsigned long )ifp) {
        {
#line 1224
        send_ihu(ngh, ifp);
        }
      }
#line 1222
      ngh = ngh->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1226
    return;
  }
#line 1230
  if (ifp) {
#line 1230
    if ((unsigned long )neigh->ifp != (unsigned long )ifp) {
#line 1231
      return;
    }
  }
  {
#line 1233
  ifp = neigh->ifp;
#line 1234
  tmp___0 = if_up(ifp);
  }
#line 1234
  if (! tmp___0) {
#line 1235
    return;
  }
  {
#line 1237
  tmp___1 = neighbour_rxcost(neigh);
#line 1237
  rxcost = (int )tmp___1;
#line 1238
  interval = (int )((ifp->hello_interval * 3U + 9U) / 10U);
  }
  {
#line 1244
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1244
    tmp___4 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1244
    if (tmp___4) {
      {
#line 1244
      tmp___2 = format_address((unsigned char const   *)(neigh->address));
      }
#line 1244
      if ((unsigned long )unicast_neighbour == (unsigned long )neigh) {
#line 1244
        tmp___3 = "unicast ";
      } else {
#line 1244
        tmp___3 = "";
      }
      {
#line 1244
      do_debugf(2, "Sending %sihu %d on %s to %s.\n", tmp___3, rxcost, (neigh->ifp)->name,
                tmp___2);
      }
    }
#line 1244
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1250
  ll = linklocal((unsigned char const   *)(neigh->address));
  }
#line 1252
  if ((unsigned long )unicast_neighbour != (unsigned long )neigh) {
#line 1253
    if (ll) {
#line 1253
      tmp___5 = 14;
    } else {
#line 1253
      tmp___5 = 22;
    }
    {
#line 1253
    start_message(ifp, 5, tmp___5);
    }
#line 1254
    if (ll) {
#line 1254
      tmp___6 = 3;
    } else {
#line 1254
      tmp___6 = 2;
    }
    {
#line 1254
    accumulate_byte(ifp, (unsigned char )tmp___6);
#line 1255
    accumulate_byte(ifp, (unsigned char)0);
#line 1256
    accumulate_short(ifp, (unsigned short )rxcost);
#line 1257
    accumulate_short(ifp, (unsigned short )interval);
    }
#line 1258
    if (ll) {
      {
#line 1259
      accumulate_bytes(ifp, (unsigned char const   *)(neigh->address + 8), 8U);
      }
    } else {
      {
#line 1261
      accumulate_bytes(ifp, (unsigned char const   *)(neigh->address), 16U);
      }
    }
#line 1262
    if (ll) {
#line 1262
      tmp___7 = 14;
    } else {
#line 1262
      tmp___7 = 22;
    }
    {
#line 1262
    end_message(ifp, 5, tmp___7);
    }
  } else {
#line 1265
    if (ll) {
#line 1265
      tmp___8 = 14;
    } else {
#line 1265
      tmp___8 = 22;
    }
    {
#line 1265
    rc = start_unicast_message(neigh, 5, tmp___8);
    }
#line 1266
    if (rc < 0) {
#line 1266
      return;
    }
#line 1267
    if (ll) {
#line 1267
      tmp___9 = 3;
    } else {
#line 1267
      tmp___9 = 2;
    }
    {
#line 1267
    accumulate_unicast_byte(neigh, (unsigned char )tmp___9);
#line 1268
    accumulate_unicast_byte(neigh, (unsigned char)0);
#line 1269
    accumulate_unicast_short(neigh, (unsigned short )rxcost);
#line 1270
    accumulate_unicast_short(neigh, (unsigned short )interval);
    }
#line 1271
    if (ll) {
      {
#line 1272
      accumulate_unicast_bytes(neigh, (unsigned char const   *)(neigh->address + 8),
                               8U);
      }
    } else {
      {
#line 1274
      accumulate_unicast_bytes(neigh, (unsigned char const   *)(neigh->address), 16U);
      }
    }
#line 1275
    if (ll) {
#line 1275
      tmp___10 = 14;
    } else {
#line 1275
      tmp___10 = 22;
    }
    {
#line 1275
    end_unicast_message(neigh, 5, tmp___10);
    }
  }
#line 1277
  return;
}
}
#line 1280 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_marginal_ihu(struct interface *ifp ) 
{ 
  struct neighbour *neigh ;

  {
#line 1284
  neigh = neighs;
  {
#line 1284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1284
    if (! neigh) {
#line 1284
      goto while_break;
    }
#line 1285
    if (ifp) {
#line 1285
      if ((unsigned long )neigh->ifp != (unsigned long )ifp) {
#line 1286
        goto __Cont;
      }
    }
#line 1287
    if ((int )neigh->txcost >= 384) {
      {
#line 1288
      send_ihu(neigh, ifp);
      }
    } else
#line 1287
    if (((int )neigh->reach & 61440) != 61440) {
      {
#line 1288
      send_ihu(neigh, ifp);
      }
    }
    __Cont: /* CIL Label */ 
#line 1284
    neigh = neigh->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  return;
}
}
#line 1292 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_request(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ) 
{ 
  int v4 ;
  int pb ;
  int len ;
  struct interface *ifp_auxn ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1298
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1300
    ifp_auxn = interfaces;
    {
#line 1300
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1300
      if (! ifp_auxn) {
#line 1300
        goto while_break;
      }
      {
#line 1301
      tmp = if_up(ifp_auxn);
      }
#line 1301
      if (tmp) {
#line 1302
        goto __Cont;
      }
      {
#line 1303
      send_request(ifp_auxn, prefix, plen);
      }
      __Cont: /* CIL Label */ 
#line 1300
      ifp_auxn = ifp_auxn->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1305
    return;
  }
  {
#line 1309
  flushupdates(ifp);
#line 1311
  tmp___0 = if_up(ifp);
  }
#line 1311
  if (! tmp___0) {
#line 1312
    return;
  }
  {
#line 1314
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1314
    tmp___3 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1314
    if (tmp___3) {
#line 1314
      if (prefix) {
        {
#line 1314
        tmp___1 = format_prefix(prefix, plen);
#line 1314
        tmp___2 = tmp___1;
        }
      } else {
#line 1314
        tmp___2 = "any";
      }
      {
#line 1314
      do_debugf(2, "sending request to %s for %s.\n", ifp->name, tmp___2);
      }
    }
#line 1314
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1316
  if ((int )plen >= 96) {
    {
#line 1316
    tmp___4 = v4mapped(prefix);
    }
#line 1316
    if (tmp___4) {
#line 1316
      tmp___5 = 1;
    } else {
#line 1316
      tmp___5 = 0;
    }
  } else {
#line 1316
    tmp___5 = 0;
  }
#line 1316
  v4 = tmp___5;
#line 1317
  if (v4) {
#line 1317
    pb = (((int )plen - 96) + 7) / 8;
  } else {
#line 1317
    pb = ((int )plen + 7) / 8;
  }
#line 1318
  if (! prefix) {
#line 1318
    len = 2;
  } else {
#line 1318
    len = 2 + pb;
  }
  {
#line 1320
  start_message(ifp, 9, len);
  }
#line 1321
  if (! prefix) {
#line 1321
    tmp___7 = 0;
  } else {
#line 1321
    if (v4) {
#line 1321
      tmp___6 = 1;
    } else {
#line 1321
      tmp___6 = 2;
    }
#line 1321
    tmp___7 = tmp___6;
  }
  {
#line 1321
  accumulate_byte(ifp, (unsigned char )tmp___7);
  }
#line 1322
  if (! prefix) {
#line 1322
    tmp___9 = 0;
  } else {
#line 1322
    if (v4) {
#line 1322
      tmp___8 = (int )plen - 96;
    } else {
#line 1322
      tmp___8 = (int )plen;
    }
#line 1322
    tmp___9 = tmp___8;
  }
  {
#line 1322
  accumulate_byte(ifp, (unsigned char )tmp___9);
  }
#line 1323
  if (prefix) {
#line 1324
    if (v4) {
      {
#line 1325
      accumulate_bytes(ifp, prefix + 12, (unsigned int )pb);
      }
    } else {
      {
#line 1327
      accumulate_bytes(ifp, prefix, (unsigned int )pb);
      }
    }
  }
  {
#line 1329
  end_message(ifp, 9, len);
  }
#line 1330
  return;
}
}
#line 1332 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_unicast_request(struct neighbour *neigh , unsigned char const   *prefix ,
                          unsigned char plen ) 
{ 
  int rc ;
  int v4 ;
  int pb ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1339
  flushupdates(neigh->ifp);
  }
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1341
    tmp___2 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1341
    if (tmp___2) {
#line 1341
      if (prefix) {
        {
#line 1341
        tmp = format_prefix(prefix, plen);
#line 1341
        tmp___0 = tmp;
        }
      } else {
#line 1341
        tmp___0 = "any";
      }
      {
#line 1341
      tmp___1 = format_address((unsigned char const   *)(neigh->address));
#line 1341
      do_debugf(2, "sending unicast request to %s for %s.\n", tmp___1, tmp___0);
      }
    }
#line 1341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  if ((int )plen >= 96) {
    {
#line 1344
    tmp___3 = v4mapped(prefix);
    }
#line 1344
    if (tmp___3) {
#line 1344
      tmp___4 = 1;
    } else {
#line 1344
      tmp___4 = 0;
    }
  } else {
#line 1344
    tmp___4 = 0;
  }
#line 1344
  v4 = tmp___4;
#line 1345
  if (v4) {
#line 1345
    pb = (((int )plen - 96) + 7) / 8;
  } else {
#line 1345
    pb = ((int )plen + 7) / 8;
  }
#line 1346
  if (! prefix) {
#line 1346
    len = 2;
  } else {
#line 1346
    len = 2 + pb;
  }
  {
#line 1348
  rc = start_unicast_message(neigh, 9, len);
  }
#line 1349
  if (rc < 0) {
#line 1349
    return;
  }
#line 1350
  if (! prefix) {
#line 1350
    tmp___6 = 0;
  } else {
#line 1350
    if (v4) {
#line 1350
      tmp___5 = 1;
    } else {
#line 1350
      tmp___5 = 2;
    }
#line 1350
    tmp___6 = tmp___5;
  }
  {
#line 1350
  accumulate_unicast_byte(neigh, (unsigned char )tmp___6);
  }
#line 1351
  if (! prefix) {
#line 1351
    tmp___8 = 0;
  } else {
#line 1351
    if (v4) {
#line 1351
      tmp___7 = (int )plen - 96;
    } else {
#line 1351
      tmp___7 = (int )plen;
    }
#line 1351
    tmp___8 = tmp___7;
  }
  {
#line 1351
  accumulate_unicast_byte(neigh, (unsigned char )tmp___8);
  }
#line 1352
  if (prefix) {
#line 1353
    if (v4) {
      {
#line 1354
      accumulate_unicast_bytes(neigh, prefix + 12, (unsigned int )pb);
      }
    } else {
      {
#line 1356
      accumulate_unicast_bytes(neigh, prefix, (unsigned int )pb);
      }
    }
  }
  {
#line 1358
  end_unicast_message(neigh, 9, len);
  }
#line 1359
  return;
}
}
#line 1361 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_multihop_request(struct interface *ifp , unsigned char const   *prefix ,
                           unsigned char plen , unsigned short seqno , unsigned char const   *id ,
                           unsigned short hop_count ) 
{ 
  int v4 ;
  int pb ;
  int len ;
  struct interface *ifp_aux ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1370
  flushupdates(ifp);
  }
#line 1372
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1374
    ifp_aux = interfaces;
    {
#line 1374
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1374
      if (! ifp_aux) {
#line 1374
        goto while_break;
      }
      {
#line 1375
      tmp = if_up(ifp_aux);
      }
#line 1375
      if (! tmp) {
#line 1376
        goto __Cont;
      }
      {
#line 1377
      send_multihop_request(ifp_aux, prefix, plen, seqno, id, hop_count);
      }
      __Cont: /* CIL Label */ 
#line 1374
      ifp_aux = ifp_aux->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1379
    return;
  }
  {
#line 1382
  tmp___0 = if_up(ifp);
  }
#line 1382
  if (! tmp___0) {
#line 1383
    return;
  }
  {
#line 1385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1385
    tmp___2 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1385
    if (tmp___2) {
      {
#line 1385
      tmp___1 = format_prefix(prefix, plen);
#line 1385
      do_debugf(2, "Sending request (%d) on %s for %s.\n", (int )hop_count, ifp->name,
                tmp___1);
      }
    }
#line 1385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1387
  if ((int )plen >= 96) {
    {
#line 1387
    tmp___3 = v4mapped(prefix);
    }
#line 1387
    if (tmp___3) {
#line 1387
      tmp___4 = 1;
    } else {
#line 1387
      tmp___4 = 0;
    }
  } else {
#line 1387
    tmp___4 = 0;
  }
#line 1387
  v4 = tmp___4;
#line 1388
  if (v4) {
#line 1388
    pb = (((int )plen - 96) + 7) / 8;
  } else {
#line 1388
    pb = ((int )plen + 7) / 8;
  }
  {
#line 1389
  len = 14 + pb;
#line 1391
  start_message(ifp, 10, len);
  }
#line 1392
  if (v4) {
#line 1392
    tmp___5 = 1;
  } else {
#line 1392
    tmp___5 = 2;
  }
  {
#line 1392
  accumulate_byte(ifp, (unsigned char )tmp___5);
  }
#line 1393
  if (v4) {
#line 1393
    tmp___6 = (int )plen - 96;
  } else {
#line 1393
    tmp___6 = (int )plen;
  }
  {
#line 1393
  accumulate_byte(ifp, (unsigned char )tmp___6);
#line 1394
  accumulate_short(ifp, seqno);
#line 1395
  accumulate_byte(ifp, (unsigned char )hop_count);
#line 1396
  accumulate_byte(ifp, (unsigned char)0);
#line 1397
  accumulate_bytes(ifp, id, 8U);
  }
#line 1398
  if (prefix) {
#line 1399
    if (v4) {
      {
#line 1400
      accumulate_bytes(ifp, prefix + 12, (unsigned int )pb);
      }
    } else {
      {
#line 1402
      accumulate_bytes(ifp, prefix, (unsigned int )pb);
      }
    }
  }
  {
#line 1404
  end_message(ifp, 10, len);
  }
#line 1405
  return;
}
}
#line 1407 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_unicast_multihop_request(struct neighbour *neigh , unsigned char const   *prefix ,
                                   unsigned char plen , unsigned short seqno , unsigned char const   *id ,
                                   unsigned short hop_count ) 
{ 
  int rc ;
  int v4 ;
  int pb ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1416
  flushupdates(neigh->ifp);
  }
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1418
    tmp___1 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1418
    if (tmp___1) {
      {
#line 1418
      tmp = format_prefix(prefix, plen);
#line 1418
      tmp___0 = format_address((unsigned char const   *)(neigh->address));
#line 1418
      do_debugf(2, "Sending multi-hop request to %s for %s (%d hops).\n", tmp___0,
                tmp, (int )hop_count);
      }
    }
#line 1418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1421
  if ((int )plen >= 96) {
    {
#line 1421
    tmp___2 = v4mapped(prefix);
    }
#line 1421
    if (tmp___2) {
#line 1421
      tmp___3 = 1;
    } else {
#line 1421
      tmp___3 = 0;
    }
  } else {
#line 1421
    tmp___3 = 0;
  }
#line 1421
  v4 = tmp___3;
#line 1422
  if (v4) {
#line 1422
    pb = (((int )plen - 96) + 7) / 8;
  } else {
#line 1422
    pb = ((int )plen + 7) / 8;
  }
  {
#line 1423
  len = 14 + pb;
#line 1425
  rc = start_unicast_message(neigh, 10, len);
  }
#line 1426
  if (rc < 0) {
#line 1426
    return;
  }
#line 1427
  if (v4) {
#line 1427
    tmp___4 = 1;
  } else {
#line 1427
    tmp___4 = 2;
  }
  {
#line 1427
  accumulate_unicast_byte(neigh, (unsigned char )tmp___4);
  }
#line 1428
  if (v4) {
#line 1428
    tmp___5 = (int )plen - 96;
  } else {
#line 1428
    tmp___5 = (int )plen;
  }
  {
#line 1428
  accumulate_unicast_byte(neigh, (unsigned char )tmp___5);
#line 1429
  accumulate_unicast_short(neigh, seqno);
#line 1430
  accumulate_unicast_byte(neigh, (unsigned char )hop_count);
#line 1431
  accumulate_unicast_byte(neigh, (unsigned char)0);
#line 1432
  accumulate_unicast_bytes(neigh, id, 8U);
  }
#line 1433
  if (prefix) {
#line 1434
    if (v4) {
      {
#line 1435
      accumulate_unicast_bytes(neigh, prefix + 12, (unsigned int )pb);
      }
    } else {
      {
#line 1437
      accumulate_unicast_bytes(neigh, prefix, (unsigned int )pb);
      }
    }
  }
  {
#line 1439
  end_unicast_message(neigh, 10, len);
  }
#line 1440
  return;
}
}
#line 1442 "/home/june/collector/temp/babeld-1.4.3/message.c"
void send_request_resend(struct neighbour *neigh , unsigned char const   *prefix ,
                         unsigned char plen , unsigned short seqno , unsigned char *id ) 
{ 
  struct interface *tmp ;

  {
#line 1447
  if (neigh) {
    {
#line 1448
    send_unicast_multihop_request(neigh, prefix, plen, seqno, (unsigned char const   *)id,
                                  (unsigned short)127);
    }
  } else {
    {
#line 1450
    send_multihop_request((struct interface *)((void *)0), prefix, plen, seqno, (unsigned char const   *)id,
                          (unsigned short)127);
    }
  }
#line 1452
  if (neigh) {
#line 1452
    tmp = neigh->ifp;
  } else {
#line 1452
    tmp = (struct interface *)((void *)0);
  }
  {
#line 1452
  record_resend(1, prefix, plen, seqno, (unsigned char const   *)id, tmp, resend_delay);
  }
#line 1454
  return;
}
}
#line 1456 "/home/june/collector/temp/babeld-1.4.3/message.c"
void handle_request(struct neighbour *neigh , unsigned char const   *prefix , unsigned char plen ,
                    unsigned char hop_count , unsigned short seqno , unsigned char const   *id ) 
{ 
  struct xroute *xroute ;
  struct babel_route *route ;
  struct neighbour *successor ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  short tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct babel_route *other_route ;
  int tmp___8 ;

  {
  {
#line 1463
  successor = (struct neighbour *)((void *)0);
#line 1465
  xroute = find_xroute(prefix, plen);
#line 1466
  route = find_installed_route(prefix, plen);
  }
#line 1468
  if (xroute) {
#line 1468
    if (! route) {
#line 1468
      goto _L;
    } else
#line 1468
    if ((int )xroute->metric <= kernel_metric) {
      _L: /* CIL Label */ 
#line 1469
      if ((int )hop_count > 0) {
        {
#line 1469
        tmp___1 = memcmp((void const   *)id, (void const   *)(myid), (size_t )8);
        }
#line 1469
        if (tmp___1 == 0) {
          {
#line 1470
          tmp___0 = seqno_compare(seqno, myseqno);
          }
#line 1470
          if (tmp___0 > 0) {
            {
#line 1471
            tmp = seqno_minus(seqno, myseqno);
            }
#line 1471
            if ((int )tmp > 100) {
#line 1473
              return;
            }
            {
#line 1475
            update_myseqno();
            }
          }
        }
      }
      {
#line 1478
      send_update(neigh->ifp, 1, prefix, plen);
      }
#line 1479
      return;
    }
  }
#line 1482
  if (route) {
    {
#line 1482
    tmp___2 = memcmp((void const   *)id, (void const   *)((route->src)->id), (size_t )8);
    }
#line 1482
    if (tmp___2 != 0) {
      {
#line 1485
      send_update(neigh->ifp, 1, prefix, plen);
      }
#line 1486
      return;
    } else {
      {
#line 1482
      tmp___3 = seqno_compare(seqno, route->seqno);
      }
#line 1482
      if (tmp___3 <= 0) {
        {
#line 1485
        send_update(neigh->ifp, 1, prefix, plen);
        }
#line 1486
        return;
      }
    }
  }
#line 1489
  if ((int )hop_count <= 1) {
#line 1490
    return;
  }
#line 1492
  if (route) {
    {
#line 1492
    tmp___4 = memcmp((void const   *)id, (void const   *)((route->src)->id), (size_t )8);
    }
#line 1492
    if (tmp___4 == 0) {
      {
#line 1492
      tmp___5 = seqno_minus(seqno, route->seqno);
      }
#line 1492
      if ((int )tmp___5 > 100) {
#line 1495
        return;
      }
    }
  }
  {
#line 1498
  tmp___6 = request_redundant(neigh->ifp, prefix, plen, seqno, id);
  }
#line 1498
  if (tmp___6) {
#line 1499
    return;
  }
#line 1502
  if (route) {
    {
#line 1502
    tmp___7 = route_metric((struct babel_route  const  *)route);
    }
#line 1502
    if (tmp___7 < 65535) {
#line 1503
      successor = route->neigh;
    }
  }
#line 1505
  if (! successor) {
#line 1505
    goto _L___0;
  } else
#line 1505
  if ((unsigned long )successor == (unsigned long )neigh) {
    _L___0: /* CIL Label */ 
    {
#line 1510
    other_route = find_best_route(prefix, plen, 0, neigh);
    }
#line 1511
    if (other_route) {
      {
#line 1511
      tmp___8 = route_metric((struct babel_route  const  *)other_route);
      }
#line 1511
      if (tmp___8 < 65535) {
#line 1512
        successor = other_route->neigh;
      }
    }
  }
#line 1515
  if (! successor) {
#line 1517
    return;
  } else
#line 1515
  if ((unsigned long )successor == (unsigned long )neigh) {
#line 1517
    return;
  }
  {
#line 1519
  send_unicast_multihop_request(successor, prefix, plen, seqno, id, (unsigned short )((int )hop_count - 1));
#line 1521
  record_resend(1, prefix, plen, seqno, id, neigh->ifp, 0);
  }
#line 1523
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 88 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
int random_id ;
#line 89
int do_daemonise ;
#line 90
char const   *logfile ;
#line 90
char const   *pidfile ;
#line 90
char const   *state_file ;
#line 91
int link_detect ;
#line 98
int local_server_port ;
#line 81 "/home/june/collector/temp/babeld-1.4.3/util.h"
int parse_msec(char const   *string )  __attribute__((__pure__)) ;
#line 84
int in_prefix(unsigned char const   * __restrict  address , unsigned char const   * __restrict  prefix ,
              unsigned char plen )  __attribute__((__pure__)) ;
#line 93
int parse_address(char const   *address , unsigned char *addr_r , int *af_r ) ;
#line 94
int parse_net(char const   *net , unsigned char *prefix_r , unsigned char *plen_r ,
              int *af_r ) ;
#line 96
int parse_eui64(char const   *eui , unsigned char *eui_r ) ;
#line 50 "/home/june/collector/temp/babeld-1.4.3/route.h"
int keep_unfeasible ;
#line 90
void change_smoothing_half_life(int half_life ) ;
#line 49 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int export_table ;
#line 51
int add_import_table(int table ) ;
#line 39 "/home/june/collector/temp/babeld-1.4.3/configuration.h"
int parse_config_from_file(char const   *filename , int *line_return ) ;
#line 40
int parse_config_from_string(char *string ) ;
#line 43
int input_filter(unsigned char const   *id , unsigned char const   *prefix , unsigned short plen ,
                 unsigned char const   *neigh , unsigned int ifindex ) ;
#line 50
int finalise_config(void) ;
#line 42 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct filter *input_filters  =    (struct filter *)((void *)0);
#line 43 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct filter *output_filters  =    (struct filter *)((void *)0);
#line 44 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct filter *redistribute_filters  =    (struct filter *)((void *)0);
#line 45 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct interface_conf *default_interface_conf  =    (struct interface_conf *)((void *)0);
#line 46 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
struct interface_conf *interface_confs  =    (struct interface_conf *)((void *)0);
#line 58 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int skip_whitespace(int c , int (*gnc)(void * ) , void *closure ) 
{ 


  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (c == 32)) {
#line 61
      if (! (c == 9)) {
#line 61
        goto while_break;
      }
    }
    {
#line 62
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (c);
}
}
#line 66 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int skip_to_eol(int c , int (*gnc)(void * ) , void *closure ) 
{ 


  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (c != 10) {
#line 69
      if (! (c >= 0)) {
#line 69
        goto while_break;
      }
    } else {
#line 69
      goto while_break;
    }
    {
#line 70
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (c == 10) {
    {
#line 72
    c = (*gnc)(closure);
    }
  }
#line 73
  return (c);
}
}
#line 76 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getword(int c , char **token_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char buf___2[256] ;
  int i___2 ;
  int tmp ;

  {
  {
#line 80
  i___2 = 0;
#line 82
  c = skip_whitespace(c, gnc, closure);
  }
#line 83
  if (c < 0) {
#line 84
    return (-2);
  } else
#line 83
  if (c == 34) {
#line 84
    return (-2);
  } else
#line 83
  if (c == 10) {
#line 84
    return (-2);
  } else
#line 83
  if (c == 35) {
#line 84
    return (-2);
  } else
#line 83
  if (c < 0) {
#line 84
    return (-2);
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (i___2 >= 255) {
#line 86
      return (-2);
    }
    {
#line 87
    tmp = i___2;
#line 87
    i___2 ++;
#line 87
    buf___2[tmp] = (char )c;
#line 88
    c = (*gnc)(closure);
    }
#line 85
    if (c != 32) {
#line 85
      if (c != 9) {
#line 85
        if (c != 10) {
#line 85
          if (c != 35) {
#line 85
            if (! (c >= 0)) {
#line 85
              goto while_break;
            }
          } else {
#line 85
            goto while_break;
          }
        } else {
#line 85
          goto while_break;
        }
      } else {
#line 85
        goto while_break;
      }
    } else {
#line 85
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  buf___2[i___2] = (char )'\000';
#line 91
  *token_r = strdup((char const   *)(buf___2));
  }
#line 92
  return (c);
}
}
#line 95 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getstring(int c , char **token_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char buf___2[256] ;
  int i___2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 99
  i___2 = 0;
#line 101
  c = skip_whitespace(c, gnc, closure);
  }
#line 102
  if (c < 0) {
#line 103
    return (-2);
  } else
#line 102
  if (c == 10) {
#line 103
    return (-2);
  } else
#line 102
  if (c == 35) {
#line 103
    return (-2);
  }
#line 106
  if (c != 34) {
    {
#line 107
    tmp = getword(c, token_r, gnc, closure);
    }
#line 107
    return (tmp);
  }
  {
#line 109
  c = (*gnc)(closure);
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (i___2 >= 255) {
#line 112
      return (-2);
    } else
#line 112
    if (c == 10) {
#line 112
      return (-2);
    }
#line 113
    if (c == 34) {
      {
#line 114
      c = (*gnc)(closure);
      }
#line 115
      goto while_break;
    }
#line 117
    if (c == 92) {
      {
#line 118
      c = (*gnc)(closure);
      }
    }
#line 120
    if (c < 0) {
#line 121
      return (-2);
    }
    {
#line 123
    tmp___0 = i___2;
#line 123
    i___2 ++;
#line 123
    buf___2[tmp___0] = (char )c;
#line 124
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  buf___2[i___2] = (char )'\000';
#line 128
  *token_r = strdup((char const   *)(buf___2));
  }
#line 129
  return (c);
}
}
#line 132 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getint(int c , int *int_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char *t ;
  char *end ;
  int i___2 ;
  long tmp ;

  {
  {
#line 137
  c = getword(c, & t, gnc, closure);
  }
#line 138
  if (c < -1) {
#line 139
    return (c);
  }
  {
#line 140
  tmp = strtol((char const   */* __restrict  */)t, (char **/* __restrict  */)(& end),
               0);
#line 140
  i___2 = (int )tmp;
  }
#line 141
  if ((int )*end != 0) {
    {
#line 142
    free((void *)t);
    }
#line 143
    return (-2);
  }
  {
#line 145
  free((void *)t);
#line 146
  *int_r = i___2;
  }
#line 147
  return (c);
}
}
#line 150 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getmsec(int c , int *int_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char *t ;
  int i___2 ;

  {
  {
#line 155
  c = getword(c, & t, gnc, closure);
  }
#line 156
  if (c < -1) {
#line 157
    return (c);
  }
  {
#line 158
  i___2 = parse_msec((char const   *)t);
  }
#line 159
  if (i___2 < 0) {
    {
#line 160
    free((void *)t);
    }
#line 161
    return (-2);
  }
  {
#line 163
  free((void *)t);
#line 164
  *int_r = i___2;
  }
#line 165
  return (c);
}
}
#line 168 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getbool(int c , int *int_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char *t ;
  int i___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 173
  c = getword(c, & t, gnc, closure);
  }
#line 174
  if (c < -1) {
#line 175
    return (c);
  }
  {
#line 176
  tmp___3 = strcmp((char const   *)t, "true");
  }
#line 176
  if (tmp___3 == 0) {
#line 177
    i___2 = 2;
  } else {
    {
#line 176
    tmp___4 = strcmp((char const   *)t, "yes");
    }
#line 176
    if (tmp___4 == 0) {
#line 177
      i___2 = 2;
    } else {
      {
#line 178
      tmp___1 = strcmp((char const   *)t, "false");
      }
#line 178
      if (tmp___1 == 0) {
#line 179
        i___2 = 1;
      } else {
        {
#line 178
        tmp___2 = strcmp((char const   *)t, "no");
        }
#line 178
        if (tmp___2 == 0) {
#line 179
          i___2 = 1;
        } else {
          {
#line 180
          tmp = strcmp((char const   *)t, "default");
          }
#line 180
          if (tmp == 0) {
#line 181
            i___2 = 0;
          } else {
            {
#line 180
            tmp___0 = strcmp((char const   *)t, "auto");
            }
#line 180
            if (tmp___0 == 0) {
#line 181
              i___2 = 0;
            } else {
              {
#line 183
              free((void *)t);
              }
#line 184
              return (-2);
            }
          }
        }
      }
    }
  }
  {
#line 186
  free((void *)t);
#line 187
  *int_r = i___2;
  }
#line 188
  return (c);
}
}
#line 191 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getip(int c , unsigned char **ip_r , int *af_r , int (*gnc)(void * ) ,
                 void *closure ) 
{ 
  char *t ;
  unsigned char *ip ;
  unsigned char addr[16] ;
  int af ;
  int rc ;
  void *tmp ;

  {
  {
#line 199
  c = getword(c, & t, gnc, closure);
  }
#line 200
  if (c < -1) {
#line 201
    return (c);
  }
  {
#line 202
  rc = parse_address((char const   *)t, addr, & af);
  }
#line 203
  if (rc < 0) {
    {
#line 204
    free((void *)t);
    }
#line 205
    return (-2);
  }
  {
#line 207
  free((void *)t);
#line 209
  tmp = malloc((size_t )16);
#line 209
  ip = (unsigned char *)tmp;
  }
#line 210
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 211
    return (-2);
  }
  {
#line 213
  memcpy((void */* __restrict  */)ip, (void const   */* __restrict  */)(addr), (size_t )16);
#line 214
  *ip_r = ip;
  }
#line 215
  if (af_r) {
#line 216
    *af_r = af;
  }
#line 217
  return (c);
}
}
#line 220 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getid(int c , unsigned char **id_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char *t ;
  unsigned char *idp ;
  unsigned char id[8] ;
  int rc ;
  void *tmp ;

  {
  {
#line 228
  c = getword(c, & t, gnc, closure);
  }
#line 229
  if (c < -1) {
#line 230
    return (c);
  }
  {
#line 231
  rc = parse_eui64((char const   *)t, id);
  }
#line 232
  if (rc < 0) {
    {
#line 233
    free((void *)t);
    }
#line 234
    return (-2);
  }
  {
#line 236
  free((void *)t);
#line 238
  tmp = malloc((size_t )8);
#line 238
  idp = (unsigned char *)tmp;
  }
#line 239
  if ((unsigned long )idp == (unsigned long )((void *)0)) {
#line 240
    return (-2);
  }
  {
#line 242
  memcpy((void */* __restrict  */)idp, (void const   */* __restrict  */)(id), (size_t )8);
#line 243
  *id_r = idp;
  }
#line 244
  return (c);
}
}
#line 247 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int getnet(int c , unsigned char **p_r , unsigned char *plen_r , int *af_r ,
                  int (*gnc)(void * ) , void *closure ) 
{ 
  char *t ;
  unsigned char *ip ;
  unsigned char addr[16] ;
  unsigned char plen ;
  int af ;
  int rc ;
  void *tmp ;

  {
  {
#line 257
  c = getword(c, & t, gnc, closure);
  }
#line 258
  if (c < -1) {
#line 259
    return (c);
  }
  {
#line 260
  rc = parse_net((char const   *)t, addr, & plen, & af);
  }
#line 261
  if (rc < 0) {
    {
#line 262
    free((void *)t);
    }
#line 263
    return (-2);
  }
  {
#line 265
  free((void *)t);
#line 266
  tmp = malloc((size_t )16);
#line 266
  ip = (unsigned char *)tmp;
  }
#line 267
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 268
    return (-2);
  }
  {
#line 269
  memcpy((void */* __restrict  */)ip, (void const   */* __restrict  */)(addr), (size_t )16);
#line 270
  *p_r = ip;
#line 271
  *plen_r = plen;
  }
#line 272
  if (af_r) {
#line 272
    *af_r = af;
  }
#line 273
  return (c);
}
}
#line 276 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int parse_filter(int c , int (*gnc)(void * ) , void *closure , struct filter **filter_return ) 
{ 
  char *token ;
  struct filter *filter ;
  void *tmp ;
  int p ;
  int p___0 ;
  int p___1 ;
  unsigned char *neigh ;
  unsigned char *id ;
  int proto ;
  char *interface ;
  int metric ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 282
  tmp = calloc((size_t )1, sizeof(struct filter ));
#line 282
  filter = (struct filter *)tmp;
  }
#line 283
  if ((unsigned long )filter == (unsigned long )((void *)0)) {
#line 284
    goto error;
  }
#line 285
  filter->plen_le = (unsigned char)128;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    c = skip_whitespace(c, gnc, closure);
    }
#line 289
    if (c < 0) {
      {
#line 290
      c = skip_to_eol(c, gnc, closure);
      }
#line 291
      goto while_break;
    } else
#line 289
    if (c == 10) {
      {
#line 290
      c = skip_to_eol(c, gnc, closure);
      }
#line 291
      goto while_break;
    } else
#line 289
    if (c == 35) {
      {
#line 290
      c = skip_to_eol(c, gnc, closure);
      }
#line 291
      goto while_break;
    }
    {
#line 293
    c = getword(c, & token, gnc, closure);
    }
#line 294
    if (c < -1) {
#line 295
      goto error;
    }
    {
#line 297
    tmp___11 = strcmp((char const   *)token, "ip");
    }
#line 297
    if (tmp___11 == 0) {
      {
#line 298
      c = getnet(c, & filter->prefix, & filter->plen, & filter->af, gnc, closure);
      }
#line 300
      if (c < -1) {
#line 301
        goto error;
      }
    } else {
      {
#line 302
      tmp___10 = strcmp((char const   *)token, "eq");
      }
#line 302
      if (tmp___10 == 0) {
        {
#line 304
        c = getint(c, & p, gnc, closure);
        }
#line 305
        if (c < -1) {
#line 306
          goto error;
        }
#line 307
        if ((int )filter->plen_ge <= p) {
#line 307
          filter->plen_ge = (unsigned char )p;
        } else {
#line 307
          filter->plen_ge = filter->plen_ge;
        }
#line 308
        if ((int )filter->plen_le <= p) {
#line 308
          filter->plen_le = filter->plen_le;
        } else {
#line 308
          filter->plen_le = (unsigned char )p;
        }
      } else {
        {
#line 309
        tmp___9 = strcmp((char const   *)token, "le");
        }
#line 309
        if (tmp___9 == 0) {
          {
#line 311
          c = getint(c, & p___0, gnc, closure);
          }
#line 312
          if (c < -1) {
#line 313
            goto error;
          }
#line 314
          if ((int )filter->plen_le <= p___0) {
#line 314
            filter->plen_le = filter->plen_le;
          } else {
#line 314
            filter->plen_le = (unsigned char )p___0;
          }
        } else {
          {
#line 315
          tmp___8 = strcmp((char const   *)token, "ge");
          }
#line 315
          if (tmp___8 == 0) {
            {
#line 317
            c = getint(c, & p___1, gnc, closure);
            }
#line 318
            if (c < -1) {
#line 319
              goto error;
            }
#line 320
            if ((int )filter->plen_ge <= p___1) {
#line 320
              filter->plen_ge = (unsigned char )p___1;
            } else {
#line 320
              filter->plen_ge = filter->plen_ge;
            }
          } else {
            {
#line 321
            tmp___7 = strcmp((char const   *)token, "neigh");
            }
#line 321
            if (tmp___7 == 0) {
              {
#line 322
              neigh = (unsigned char *)((void *)0);
#line 323
              c = getip(c, & neigh, (int *)((void *)0), gnc, closure);
              }
#line 324
              if (c < -1) {
#line 325
                goto error;
              }
#line 326
              filter->neigh = neigh;
            } else {
              {
#line 327
              tmp___6 = strcmp((char const   *)token, "id");
              }
#line 327
              if (tmp___6 == 0) {
                {
#line 328
                id = (unsigned char *)((void *)0);
#line 329
                c = getid(c, & id, gnc, closure);
                }
#line 330
                if (c < -1) {
#line 331
                  goto error;
                }
#line 332
                filter->id = id;
              } else {
                {
#line 333
                tmp___5 = strcmp((char const   *)token, "proto");
                }
#line 333
                if (tmp___5 == 0) {
                  {
#line 335
                  c = getint(c, & proto, gnc, closure);
                  }
#line 336
                  if (c < -1) {
#line 337
                    goto error;
                  }
#line 338
                  filter->proto = proto;
                } else {
                  {
#line 339
                  tmp___4 = strcmp((char const   *)token, "local");
                  }
#line 339
                  if (tmp___4 == 0) {
#line 340
                    filter->proto = -2;
                  } else {
                    {
#line 341
                    tmp___3 = strcmp((char const   *)token, "if");
                    }
#line 341
                    if (tmp___3 == 0) {
                      {
#line 343
                      c = getstring(c, & interface, gnc, closure);
                      }
#line 344
                      if (c < -1) {
#line 345
                        goto error;
                      }
                      {
#line 346
                      filter->ifname = interface;
#line 347
                      filter->ifindex = if_nametoindex((char const   *)interface);
                      }
                    } else {
                      {
#line 348
                      tmp___2 = strcmp((char const   *)token, "allow");
                      }
#line 348
                      if (tmp___2 == 0) {
#line 349
                        filter->result = 0U;
                      } else {
                        {
#line 350
                        tmp___1 = strcmp((char const   *)token, "deny");
                        }
#line 350
                        if (tmp___1 == 0) {
#line 351
                          filter->result = (unsigned int )((unsigned short )(~ 0));
                        } else {
                          {
#line 352
                          tmp___0 = strcmp((char const   *)token, "metric");
                          }
#line 352
                          if (tmp___0 == 0) {
                            {
#line 354
                            c = getint(c, & metric, gnc, closure);
                            }
#line 355
                            if (c < -1) {
#line 355
                              goto error;
                            }
#line 356
                            if (metric <= 0) {
#line 357
                              goto error;
                            } else
#line 356
                            if (metric > 65535) {
#line 357
                              goto error;
                            }
#line 358
                            filter->result = (unsigned int )metric;
                          } else {
#line 360
                            goto error;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 362
    free((void *)token);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (filter->af == 0) {
#line 365
    if ((int )filter->plen_le < 128) {
#line 366
      filter->af = 10;
    } else
#line 365
    if ((int )filter->plen_ge > 0) {
#line 366
      filter->af = 10;
    }
  } else
#line 367
  if (filter->af == 2) {
#line 368
    filter->plen_le = (unsigned char )((int )filter->plen_le + 96);
#line 369
    filter->plen_ge = (unsigned char )((int )filter->plen_ge + 96);
  }
#line 371
  *filter_return = filter;
#line 372
  return (c);
  error: 
  {
#line 375
  free((void *)filter);
  }
#line 376
  return (-2);
}
}
#line 379 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int parse_anonymous_ifconf(int c , int (*gnc)(void * ) , void *closure , struct interface_conf *if_conf ,
                                  struct interface_conf **if_conf_return ) 
{ 
  char *token ;
  void *tmp ;
  int cost ;
  int interval ;
  int interval___0 ;
  int v ;
  int v___0 ;
  int v___1 ;
  int v___2 ;
  char *t ;
  char *end ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 387
  if ((unsigned long )if_conf == (unsigned long )((void *)0)) {
    {
#line 388
    tmp = calloc((size_t )1, sizeof(struct interface_conf ));
#line 388
    if_conf = (struct interface_conf *)tmp;
    }
#line 389
    if ((unsigned long )if_conf == (unsigned long )((void *)0)) {
#line 390
      goto error;
    }
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 394
    c = skip_whitespace(c, gnc, closure);
    }
#line 395
    if (c < 0) {
      {
#line 396
      c = skip_to_eol(c, gnc, closure);
      }
#line 397
      goto while_break;
    } else
#line 395
    if (c == 10) {
      {
#line 396
      c = skip_to_eol(c, gnc, closure);
      }
#line 397
      goto while_break;
    } else
#line 395
    if (c == 35) {
      {
#line 396
      c = skip_to_eol(c, gnc, closure);
      }
#line 397
      goto while_break;
    }
    {
#line 399
    c = getword(c, & token, gnc, closure);
    }
#line 400
    if (c < -1) {
#line 401
      goto error;
    }
    {
#line 403
    tmp___10 = strcmp((char const   *)token, "rxcost");
    }
#line 403
    if (tmp___10 == 0) {
      {
#line 405
      c = getint(c, & cost, gnc, closure);
      }
#line 406
      if (c < -1) {
#line 407
        goto error;
      } else
#line 406
      if (cost <= 0) {
#line 407
        goto error;
      } else
#line 406
      if (cost > 65535) {
#line 407
        goto error;
      }
#line 408
      if_conf->cost = (unsigned short )cost;
    } else {
      {
#line 409
      tmp___9 = strcmp((char const   *)token, "hello-interval");
      }
#line 409
      if (tmp___9 == 0) {
        {
#line 411
        c = getmsec(c, & interval, gnc, closure);
        }
#line 412
        if (c < -1) {
#line 413
          goto error;
        } else
#line 412
        if (interval <= 0) {
#line 413
          goto error;
        } else
#line 412
        if (interval > 655350) {
#line 413
          goto error;
        }
#line 414
        if_conf->hello_interval = (unsigned int )interval;
      } else {
        {
#line 415
        tmp___8 = strcmp((char const   *)token, "update-interval");
        }
#line 415
        if (tmp___8 == 0) {
          {
#line 417
          c = getmsec(c, & interval___0, gnc, closure);
          }
#line 418
          if (c < -1) {
#line 419
            goto error;
          } else
#line 418
          if (interval___0 <= 0) {
#line 419
            goto error;
          } else
#line 418
          if (interval___0 > 655350) {
#line 419
            goto error;
          }
#line 420
          if_conf->update_interval = (unsigned int )interval___0;
        } else {
          {
#line 421
          tmp___7 = strcmp((char const   *)token, "wired");
          }
#line 421
          if (tmp___7 == 0) {
            {
#line 423
            c = getbool(c, & v, gnc, closure);
            }
#line 424
            if (c < -1) {
#line 425
              goto error;
            }
#line 426
            if_conf->wired = (char )v;
          } else {
            {
#line 427
            tmp___6 = strcmp((char const   *)token, "faraway");
            }
#line 427
            if (tmp___6 == 0) {
              {
#line 429
              c = getbool(c, & v___0, gnc, closure);
              }
#line 430
              if (c < -1) {
#line 431
                goto error;
              }
#line 432
              if_conf->faraway = (char )v___0;
            } else {
              {
#line 433
              tmp___5 = strcmp((char const   *)token, "link-quality");
              }
#line 433
              if (tmp___5 == 0) {
                {
#line 435
                c = getbool(c, & v___1, gnc, closure);
                }
#line 436
                if (c < -1) {
#line 437
                  goto error;
                }
#line 438
                if_conf->lq = (char )v___1;
              } else {
                {
#line 439
                tmp___4 = strcmp((char const   *)token, "split-horizon");
                }
#line 439
                if (tmp___4 == 0) {
                  {
#line 441
                  c = getbool(c, & v___2, gnc, closure);
                  }
#line 442
                  if (c < -1) {
#line 443
                    goto error;
                  }
#line 444
                  if_conf->split_horizon = (char )v___2;
                } else {
                  {
#line 445
                  tmp___3 = strcmp((char const   *)token, "channel");
                  }
#line 445
                  if (tmp___3 == 0) {
                    {
#line 448
                    c = getword(c, & t, gnc, closure);
                    }
#line 449
                    if (c < -1) {
#line 450
                      goto error;
                    }
                    {
#line 452
                    tmp___2 = strcmp((char const   *)t, "noninterfering");
                    }
#line 452
                    if (tmp___2 == 0) {
#line 453
                      if_conf->channel = -2;
                    } else {
                      {
#line 454
                      tmp___1 = strcmp((char const   *)t, "interfering");
                      }
#line 454
                      if (tmp___1 == 0) {
#line 455
                        if_conf->channel = 255;
                      } else {
                        {
#line 457
                        tmp___0 = strtol((char const   */* __restrict  */)t, (char **/* __restrict  */)(& end),
                                         0);
#line 457
                        if_conf->channel = (int )tmp___0;
                        }
#line 458
                        if ((int )*end != 0) {
#line 459
                          goto error;
                        }
                      }
                    }
                    {
#line 462
                    free((void *)t);
                    }
#line 464
                    if (if_conf->channel < 1) {
#line 464
                      goto _L;
                    } else
#line 464
                    if (if_conf->channel > 255) {
                      _L: /* CIL Label */ 
#line 464
                      if (if_conf->channel != -2) {
#line 466
                        goto error;
                      }
                    }
                  } else {
#line 468
                    goto error;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 470
    free((void *)token);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  *if_conf_return = if_conf;
#line 474
  return (c);
  error: 
  {
#line 477
  free((void *)if_conf);
  }
#line 478
  return (-2);
}
}
#line 481 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int parse_ifconf(int c , int (*gnc)(void * ) , void *closure , struct interface_conf **if_conf_return ) 
{ 
  char *token ;
  struct interface_conf *if_conf ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 488
  tmp = calloc((size_t )1, sizeof(struct interface_conf ));
#line 488
  if_conf = (struct interface_conf *)tmp;
  }
#line 489
  if ((unsigned long )if_conf == (unsigned long )((void *)0)) {
#line 490
    goto error;
  }
  {
#line 492
  c = skip_whitespace(c, gnc, closure);
  }
#line 493
  if (c < -1) {
#line 494
    goto error;
  } else
#line 493
  if (c == 10) {
#line 494
    goto error;
  } else
#line 493
  if (c == 35) {
#line 494
    goto error;
  }
  {
#line 496
  c = getstring(c, & token, gnc, closure);
  }
#line 497
  if (c < -1) {
#line 498
    goto error;
  } else
#line 497
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 498
    goto error;
  }
  {
#line 500
  if_conf->ifname = token;
#line 502
  tmp___0 = parse_anonymous_ifconf(c, gnc, closure, if_conf, if_conf_return);
  }
#line 502
  return (tmp___0);
  error: 
  {
#line 505
  free((void *)if_conf);
  }
#line 506
  return (-2);
}
}
#line 509 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static void add_filter(struct filter *filter , struct filter **filters ) 
{ 
  struct filter *f ;

  {
#line 512
  if ((unsigned long )*filters == (unsigned long )((void *)0)) {
#line 513
    filter->next = (struct filter *)((void *)0);
#line 514
    *filters = filter;
  } else {
#line 517
    f = *filters;
    {
#line 518
    while (1) {
      while_continue: /* CIL Label */ ;
#line 518
      if (! f->next) {
#line 518
        goto while_break;
      }
#line 519
      f = f->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 520
    filter->next = (struct filter *)((void *)0);
#line 521
    f->next = filter;
  }
#line 523
  return;
}
}
#line 525 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static void merge_ifconf(struct interface_conf *dest , struct interface_conf  const  *src1 ,
                         struct interface_conf  const  *src2 ) 
{ 


  {
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (src1->hello_interval) {
#line 539
      dest->hello_interval = (unsigned int )src1->hello_interval;
    } else {
#line 539
      dest->hello_interval = (unsigned int )src2->hello_interval;
    }
#line 539
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 540
    if (src1->update_interval) {
#line 540
      dest->update_interval = (unsigned int )src1->update_interval;
    } else {
#line 540
      dest->update_interval = (unsigned int )src2->update_interval;
    }
#line 540
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 541
    if (src1->cost) {
#line 541
      dest->cost = (unsigned short )src1->cost;
    } else {
#line 541
      dest->cost = (unsigned short )src2->cost;
    }
#line 541
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 542
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 542
    if (src1->wired) {
#line 542
      dest->wired = (char )src1->wired;
    } else {
#line 542
      dest->wired = (char )src2->wired;
    }
#line 542
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 543
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 543
    if (src1->split_horizon) {
#line 543
      dest->split_horizon = (char )src1->split_horizon;
    } else {
#line 543
      dest->split_horizon = (char )src2->split_horizon;
    }
#line 543
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 544
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 544
    if (src1->lq) {
#line 544
      dest->lq = (char )src1->lq;
    } else {
#line 544
      dest->lq = (char )src2->lq;
    }
#line 544
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 545
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 545
    if (src1->faraway) {
#line 545
      dest->faraway = (char )src1->faraway;
    } else {
#line 545
      dest->faraway = (char )src2->faraway;
    }
#line 545
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 546
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 546
    if (src1->channel) {
#line 546
      dest->channel = (int )src1->channel;
    } else {
#line 546
      dest->channel = (int )src2->channel;
    }
#line 546
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 549
  return;
}
}
#line 551 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static void add_ifconf(struct interface_conf *if_conf , struct interface_conf **if_confs ) 
{ 
  struct interface_conf *prev ;
  struct interface_conf *next ;
  int tmp ;

  {
#line 554
  if ((unsigned long )*if_confs == (unsigned long )((void *)0)) {
#line 555
    if_conf->next = (struct interface_conf *)((void *)0);
#line 556
    *if_confs = if_conf;
  } else {
#line 559
    next = *if_confs;
#line 560
    prev = (struct interface_conf *)((void *)0);
    {
#line 561
    while (1) {
      while_continue: /* CIL Label */ ;
#line 561
      if (! next) {
#line 561
        goto while_break;
      }
      {
#line 562
      tmp = strcmp((char const   *)next->ifname, (char const   *)if_conf->ifname);
      }
#line 562
      if (tmp == 0) {
        {
#line 563
        merge_ifconf(next, (struct interface_conf  const  *)if_conf, (struct interface_conf  const  *)next);
#line 564
        free((void *)if_conf);
        }
#line 565
        return;
      }
#line 567
      prev = next;
#line 568
      next = next->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 570
    if_conf->next = (struct interface_conf *)((void *)0);
#line 571
    prev->next = if_conf;
  }
#line 573
  return;
}
}
#line 575 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int parse_option(int c , int (*gnc)(void * ) , void *closure , char *token ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int b ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char *group ;
  char *file ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int d ;
  int d___0 ;
  int b___0 ;
  int f ;
  int h ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  {
#line 578
  tmp___24 = strcmp((char const   *)token, "protocol-port");
  }
#line 578
  if (tmp___24 == 0) {
#line 578
    goto _L___2;
  } else {
    {
#line 578
    tmp___25 = strcmp((char const   *)token, "kernel-priority");
    }
#line 578
    if (tmp___25 == 0) {
#line 578
      goto _L___2;
    } else {
      {
#line 578
      tmp___26 = strcmp((char const   *)token, "allow-duplicates");
      }
#line 578
      if (tmp___26 == 0) {
#line 578
        goto _L___2;
      } else {
        {
#line 578
        tmp___27 = strcmp((char const   *)token, "local-port");
        }
#line 578
        if (tmp___27 == 0) {
#line 578
          goto _L___2;
        } else {
          {
#line 578
          tmp___28 = strcmp((char const   *)token, "export-table");
          }
#line 578
          if (tmp___28 == 0) {
#line 578
            goto _L___2;
          } else {
            {
#line 578
            tmp___29 = strcmp((char const   *)token, "import-table");
            }
#line 578
            if (tmp___29 == 0) {
              _L___2: /* CIL Label */ 
              {
#line 587
              c = getint(c, & v, gnc, closure);
              }
#line 588
              if (c < -1) {
#line 589
                goto error;
              } else
#line 588
              if (v <= 0) {
#line 589
                goto error;
              } else
#line 588
              if (v >= 65535) {
#line 589
                goto error;
              }
              {
#line 591
              tmp___4 = strcmp((char const   *)token, "protocol-port");
              }
#line 591
              if (tmp___4 == 0) {
#line 592
                protocol_port = v;
              } else {
                {
#line 593
                tmp___3 = strcmp((char const   *)token, "kernel-priority");
                }
#line 593
                if (tmp___3 == 0) {
#line 594
                  kernel_metric = v;
                } else {
                  {
#line 595
                  tmp___2 = strcmp((char const   *)token, "allow_duplicates");
                  }
#line 595
                  if (tmp___2 == 0) {
#line 596
                    allow_duplicates = v;
                  } else {
                    {
#line 598
                    tmp___1 = strcmp((char const   *)token, "local-port");
                    }
#line 598
                    if (tmp___1 == 0) {
#line 599
                      local_server_port = v;
                    } else {
                      {
#line 601
                      tmp___0 = strcmp((char const   *)token, "export-table");
                      }
#line 601
                      if (tmp___0 == 0) {
#line 602
                        export_table = v;
                      } else {
                        {
#line 603
                        tmp = strcmp((char const   *)token, "import-table");
                        }
#line 603
                        if (tmp == 0) {
                          {
#line 604
                          add_import_table(v);
                          }
                        } else {
                          {
#line 606
                          abort();
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              {
#line 607
              tmp___20 = strcmp((char const   *)token, "keep-unfeasible");
              }
#line 607
              if (tmp___20 == 0) {
#line 607
                goto _L___1;
              } else {
                {
#line 607
                tmp___21 = strcmp((char const   *)token, "link-detect");
                }
#line 607
                if (tmp___21 == 0) {
#line 607
                  goto _L___1;
                } else {
                  {
#line 607
                  tmp___22 = strcmp((char const   *)token, "random-id");
                  }
#line 607
                  if (tmp___22 == 0) {
#line 607
                    goto _L___1;
                  } else {
                    {
#line 607
                    tmp___23 = strcmp((char const   *)token, "daemonise");
                    }
#line 607
                    if (tmp___23 == 0) {
                      _L___1: /* CIL Label */ 
                      {
#line 612
                      c = getbool(c, & b, gnc, closure);
                      }
#line 613
                      if (c < -1) {
#line 614
                        goto error;
                      }
                      {
#line 615
                      b = b == 2;
#line 616
                      tmp___8 = strcmp((char const   *)token, "keep-unfeasible");
                      }
#line 616
                      if (tmp___8 == 0) {
#line 617
                        keep_unfeasible = b;
                      } else {
                        {
#line 618
                        tmp___7 = strcmp((char const   *)token, "link-detect");
                        }
#line 618
                        if (tmp___7 == 0) {
#line 619
                          link_detect = b;
                        } else {
                          {
#line 620
                          tmp___6 = strcmp((char const   *)token, "random-id");
                          }
#line 620
                          if (tmp___6 == 0) {
#line 621
                            random_id = b;
                          } else {
                            {
#line 622
                            tmp___5 = strcmp((char const   *)token, "daemonise");
                            }
#line 622
                            if (tmp___5 == 0) {
#line 623
                              do_daemonise = b;
                            } else {
                              {
#line 625
                              abort();
                              }
                            }
                          }
                        }
                      }
                    } else {
                      {
#line 626
                      tmp___19 = strcmp((char const   *)token, "protocol-group");
                      }
#line 626
                      if (tmp___19 == 0) {
                        {
#line 627
                        group = (unsigned char *)((void *)0);
#line 628
                        c = getip(c, & group, (int *)((void *)0), gnc, closure);
                        }
#line 629
                        if (c < -1) {
#line 630
                          goto error;
                        }
                        {
#line 631
                        memcpy((void */* __restrict  */)(protocol_group), (void const   */* __restrict  */)group,
                               (size_t )16);
#line 632
                        free((void *)group);
                        }
                      } else {
                        {
#line 633
                        tmp___16 = strcmp((char const   *)token, "state-file");
                        }
#line 633
                        if (tmp___16 == 0) {
#line 633
                          goto _L___0;
                        } else {
                          {
#line 633
                          tmp___17 = strcmp((char const   *)token, "log-file");
                          }
#line 633
                          if (tmp___17 == 0) {
#line 633
                            goto _L___0;
                          } else {
                            {
#line 633
                            tmp___18 = strcmp((char const   *)token, "pid-file");
                            }
#line 633
                            if (tmp___18 == 0) {
                              _L___0: /* CIL Label */ 
                              {
#line 637
                              c = getstring(c, & file, gnc, closure);
                              }
#line 638
                              if (c < -1) {
#line 639
                                goto error;
                              }
                              {
#line 640
                              tmp___11 = strcmp((char const   *)token, "state-file");
                              }
#line 640
                              if (tmp___11 == 0) {
#line 641
                                state_file = (char const   *)file;
                              } else {
                                {
#line 642
                                tmp___10 = strcmp((char const   *)token, "log-file");
                                }
#line 642
                                if (tmp___10 == 0) {
#line 643
                                  logfile = (char const   *)file;
                                } else {
                                  {
#line 644
                                  tmp___9 = strcmp((char const   *)token, "pid-file");
                                  }
#line 644
                                  if (tmp___9 == 0) {
#line 645
                                    pidfile = (char const   *)file;
                                  } else {
                                    {
#line 647
                                    abort();
                                    }
                                  }
                                }
                              }
                            } else {
                              {
#line 648
                              tmp___15 = strcmp((char const   *)token, "debug");
                              }
#line 648
                              if (tmp___15 == 0) {
                                {
#line 650
                                c = getint(c, & d, gnc, closure);
                                }
#line 651
                                if (d < 0) {
#line 652
                                  goto error;
                                }
#line 653
                                debug = d;
                              } else {
                                {
#line 654
                                tmp___14 = strcmp((char const   *)token, "diversity");
                                }
#line 654
                                if (tmp___14 == 0) {
                                  {
#line 656
                                  c = skip_whitespace(c, gnc, closure);
                                  }
#line 657
                                  if (c >= 48) {
#line 657
                                    if (c <= 57) {
                                      {
#line 658
                                      c = getint(c, & d___0, gnc, closure);
                                      }
#line 659
                                      if (c < -1) {
#line 660
                                        goto error;
                                      }
                                    } else {
#line 657
                                      goto _L;
                                    }
                                  } else {
                                    _L: /* CIL Label */ 
                                    {
#line 663
                                    c = getbool(c, & b___0, gnc, closure);
                                    }
#line 664
                                    if (c < -1) {
#line 665
                                      goto error;
                                    }
#line 666
                                    if (b___0 == 2) {
#line 666
                                      d___0 = 3;
                                    } else {
#line 666
                                      d___0 = 0;
                                    }
                                  }
#line 668
                                  diversity_kind = d___0;
                                } else {
                                  {
#line 669
                                  tmp___13 = strcmp((char const   *)token, "diversity-factor");
                                  }
#line 669
                                  if (tmp___13 == 0) {
                                    {
#line 671
                                    c = getint(c, & f, gnc, closure);
                                    }
#line 672
                                    if (c < -1) {
#line 673
                                      goto error;
                                    } else
#line 672
                                    if (f < 0) {
#line 673
                                      goto error;
                                    } else
#line 672
                                    if (f > 256) {
#line 673
                                      goto error;
                                    }
#line 674
                                    diversity_factor = f;
                                  } else {
                                    {
#line 675
                                    tmp___12 = strcmp((char const   *)token, "smoothing-half-life");
                                    }
#line 675
                                    if (tmp___12 == 0) {
                                      {
#line 677
                                      c = getint(c, & h, gnc, closure);
                                      }
#line 678
                                      if (c < -1) {
#line 679
                                        goto error;
                                      } else
#line 678
                                      if (h < 0) {
#line 679
                                        goto error;
                                      }
                                      {
#line 680
                                      change_smoothing_half_life(h);
                                      }
                                    } else {
#line 682
                                      goto error;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 685
  c = skip_whitespace(c, gnc, closure);
  }
#line 686
  if (c < 0) {
    {
#line 687
    c = skip_to_eol(c, gnc, closure);
    }
#line 688
    return (c);
  } else
#line 686
  if (c == 10) {
    {
#line 687
    c = skip_to_eol(c, gnc, closure);
    }
#line 688
    return (c);
  } else
#line 686
  if (c == 35) {
    {
#line 687
    c = skip_to_eol(c, gnc, closure);
    }
#line 688
    return (c);
  }
  error: 
#line 693
  return (-2);
}
}
#line 697 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int parse_config(int (*gnc)(void * ) , void *closure ) 
{ 
  int c ;
  char *token ;
  struct filter *filter ;
  struct filter *filter___0 ;
  struct filter *filter___1 ;
  struct interface_conf *if_conf ;
  struct interface_conf *if_conf___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 703
  c = (*gnc)(closure);
  }
#line 704
  if (c < -1) {
#line 705
    return (-1);
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 708
    c = skip_whitespace(c, gnc, closure);
    }
#line 709
    if (c == 10) {
      {
#line 710
      c = skip_to_eol(c, gnc, closure);
      }
#line 711
      goto while_continue;
    } else
#line 709
    if (c == 35) {
      {
#line 710
      c = skip_to_eol(c, gnc, closure);
      }
#line 711
      goto while_continue;
    }
#line 713
    if (c < 0) {
#line 714
      goto while_break;
    }
    {
#line 715
    c = getword(c, & token, gnc, closure);
    }
#line 716
    if (c < -1) {
#line 717
      return (-1);
    }
    {
#line 719
    tmp___3 = strcmp((char const   *)token, "in");
    }
#line 719
    if (tmp___3 == 0) {
      {
#line 721
      c = parse_filter(c, gnc, closure, & filter);
      }
#line 722
      if (c < -1) {
#line 723
        return (-1);
      }
      {
#line 724
      add_filter(filter, & input_filters);
      }
    } else {
      {
#line 725
      tmp___2 = strcmp((char const   *)token, "out");
      }
#line 725
      if (tmp___2 == 0) {
        {
#line 727
        c = parse_filter(c, gnc, closure, & filter___0);
        }
#line 728
        if (c < -1) {
#line 729
          return (-1);
        }
        {
#line 730
        add_filter(filter___0, & output_filters);
        }
      } else {
        {
#line 731
        tmp___1 = strcmp((char const   *)token, "redistribute");
        }
#line 731
        if (tmp___1 == 0) {
          {
#line 733
          c = parse_filter(c, gnc, closure, & filter___1);
          }
#line 734
          if (c < -1) {
#line 735
            return (-1);
          }
          {
#line 736
          add_filter(filter___1, & redistribute_filters);
          }
        } else {
          {
#line 737
          tmp___0 = strcmp((char const   *)token, "interface");
          }
#line 737
          if (tmp___0 == 0) {
            {
#line 739
            c = parse_ifconf(c, gnc, closure, & if_conf);
            }
#line 740
            if (c < -1) {
#line 741
              return (-1);
            }
            {
#line 742
            add_ifconf(if_conf, & interface_confs);
            }
          } else {
            {
#line 743
            tmp = strcmp((char const   *)token, "default");
            }
#line 743
            if (tmp == 0) {
              {
#line 745
              c = parse_anonymous_ifconf(c, gnc, closure, (struct interface_conf *)((void *)0),
                                         & if_conf___0);
              }
#line 746
              if (c < -1) {
#line 747
                return (-1);
              }
#line 748
              if ((unsigned long )default_interface_conf == (unsigned long )((void *)0)) {
#line 749
                default_interface_conf = if_conf___0;
              } else {
                {
#line 751
                merge_ifconf(default_interface_conf, (struct interface_conf  const  *)if_conf___0,
                             (struct interface_conf  const  *)default_interface_conf);
#line 753
                free((void *)if_conf___0);
                }
              }
            } else {
              {
#line 756
              c = parse_option(c, gnc, closure, token);
              }
#line 757
              if (c < -1) {
#line 758
                return (-1);
              }
            }
          }
        }
      }
    }
    {
#line 760
    free((void *)token);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return (1);
}
}
#line 770 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int gnc_file(struct file_state *s ) 
{ 
  int c ;

  {
  {
#line 774
  c = fgetc(s->f);
  }
#line 775
  if (c == 10) {
#line 776
    (s->line) ++;
  }
#line 777
  return (c);
}
}
#line 780 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int parse_config_from_file(char const   *filename , int *line_return ) 
{ 
  struct file_state s ;
  int rc ;

  {
  {
#line 783
  s.f = (FILE *)((void *)0);
#line 783
  s.line = 1;
#line 786
  s.f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 787
  if ((unsigned long )s.f == (unsigned long )((void *)0)) {
#line 788
    *line_return = 0;
#line 789
    return (-1);
  }
  {
#line 792
  rc = parse_config((int (*)(void * ))(& gnc_file), (void *)(& s));
#line 793
  fclose(s.f);
#line 795
  *line_return = s.line;
  }
#line 796
  return (rc);
}
}
#line 804 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int gnc_string(struct string_state *s ) 
{ 
  int tmp ;

  {
#line 807
  if ((int )*(s->string + s->n) == 0) {
#line 808
    return (-1);
  } else {
#line 810
    tmp = s->n;
#line 810
    (s->n) ++;
#line 810
    return ((int )*(s->string + tmp));
  }
}
}
#line 813 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int parse_config_from_string(char *string ) 
{ 
  struct string_state s ;
  int tmp ;

  {
  {
#line 816
  s.string = string;
#line 816
  s.n = 0;
#line 817
  tmp = parse_config((int (*)(void * ))(& gnc_string), (void *)(& s));
  }
#line 817
  return (tmp);
}
}
#line 820 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static void renumber_filter(struct filter *filter ) 
{ 


  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! filter) {
#line 823
      goto while_break;
    }
#line 824
    if (filter->ifname) {
      {
#line 825
      filter->ifindex = if_nametoindex((char const   *)filter->ifname);
      }
    }
#line 826
    filter = filter->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  return;
}
}
#line 830 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
void renumber_filters(void) 
{ 


  {
  {
#line 833
  renumber_filter(input_filters);
#line 834
  renumber_filter(output_filters);
#line 835
  renumber_filter(redistribute_filters);
  }
#line 836
  return;
}
}
#line 838 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int filter_match(struct filter *f , unsigned char const   *id , unsigned char const   *prefix ,
                        unsigned short plen , unsigned char const   *neigh , unsigned int ifindex ,
                        int proto ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 843
  if (f->af) {
#line 844
    if ((int )plen >= 96) {
      {
#line 844
      tmp = v4mapped(prefix);
      }
#line 844
      if (tmp) {
#line 845
        if (f->af == 10) {
#line 845
          return (0);
        }
      } else {
#line 844
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 847
    if (f->af == 2) {
#line 847
      return (0);
    }
  }
#line 850
  if (f->id) {
#line 851
    if (! id) {
#line 852
      return (0);
    } else {
      {
#line 851
      tmp___0 = memcmp((void const   *)f->id, (void const   *)id, (size_t )8);
      }
#line 851
      if (tmp___0 != 0) {
#line 852
        return (0);
      }
    }
  }
#line 854
  if (f->prefix) {
#line 855
    if (! prefix) {
#line 856
      return (0);
    } else
#line 855
    if ((int )plen < (int )f->plen) {
#line 856
      return (0);
    } else {
      {
#line 855
      tmp___1 = in_prefix((unsigned char const   */* __restrict  */)prefix, (unsigned char const   */* __restrict  */)f->prefix,
                          f->plen);
      }
#line 855
      if (! tmp___1) {
#line 856
        return (0);
      }
    }
  }
#line 858
  if ((int )f->plen_ge > 0) {
#line 858
    goto _L___0;
  } else
#line 858
  if ((int )f->plen_le < 128) {
    _L___0: /* CIL Label */ 
#line 859
    if (! prefix) {
#line 860
      return (0);
    }
#line 861
    if ((int )plen > (int )f->plen_le) {
#line 862
      return (0);
    }
#line 863
    if ((int )plen < (int )f->plen_ge) {
#line 864
      return (0);
    }
  }
#line 866
  if (f->neigh) {
#line 867
    if (! neigh) {
#line 868
      return (0);
    } else {
      {
#line 867
      tmp___2 = memcmp((void const   *)f->neigh, (void const   *)neigh, (size_t )16);
      }
#line 867
      if (tmp___2 != 0) {
#line 868
        return (0);
      }
    }
  }
#line 870
  if (f->ifname) {
#line 871
    if (! f->ifindex) {
#line 872
      return (0);
    }
#line 873
    if (! ifindex) {
#line 874
      return (0);
    } else
#line 873
    if (f->ifindex != ifindex) {
#line 874
      return (0);
    }
  }
#line 876
  if (f->proto) {
#line 877
    if (! proto) {
#line 878
      return (0);
    } else
#line 877
    if (f->proto != proto) {
#line 878
      return (0);
    }
  } else
#line 879
  if (proto == -2) {
#line 880
    return (0);
  } else
#line 882
  if (proto == 3) {
#line 883
    return (0);
  }
#line 887
  return (1);
}
}
#line 890 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
static int do_filter(struct filter *f , unsigned char const   *id , unsigned char const   *prefix ,
                     unsigned short plen , unsigned char const   *neigh , unsigned int ifindex ,
                     int proto ) 
{ 
  int tmp ;

  {
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! f) {
#line 895
      goto while_break;
    }
    {
#line 896
    tmp = filter_match(f, id, prefix, plen, neigh, ifindex, proto);
    }
#line 896
    if (tmp) {
#line 897
      return ((int )f->result);
    }
#line 898
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return (-1);
}
}
#line 903 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int input_filter(unsigned char const   *id , unsigned char const   *prefix , unsigned short plen ,
                 unsigned char const   *neigh , unsigned int ifindex ) 
{ 
  int res ;

  {
  {
#line 909
  res = do_filter(input_filters, id, prefix, plen, neigh, ifindex, 0);
  }
#line 910
  if (res < 0) {
#line 911
    res = 0;
  }
#line 912
  return (res);
}
}
#line 915 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int output_filter(unsigned char const   *id , unsigned char const   *prefix , unsigned short plen ,
                  unsigned int ifindex ) 
{ 
  int res ;

  {
  {
#line 920
  res = do_filter(output_filters, id, prefix, plen, (unsigned char const   *)((void *)0),
                  ifindex, 0);
  }
#line 921
  if (res < 0) {
#line 922
    res = 0;
  }
#line 923
  return (res);
}
}
#line 926 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int redistribute_filter(unsigned char const   *prefix , unsigned short plen , unsigned int ifindex ,
                        int proto ) 
{ 
  int res ;

  {
  {
#line 931
  res = do_filter(redistribute_filters, (unsigned char const   *)((void *)0), prefix,
                  plen, (unsigned char const   *)((void *)0), ifindex, proto);
  }
#line 933
  if (res < 0) {
#line 934
    res = (int )((unsigned short )(~ 0));
  }
#line 935
  return (res);
}
}
#line 938 "/home/june/collector/temp/babeld-1.4.3/configuration.c"
int finalise_config(void) 
{ 
  struct filter *filter ;
  void *tmp ;
  struct interface_conf *if_conf ;
  void *vrc ;
  struct interface *tmp___0 ;

  {
  {
#line 941
  tmp = calloc((size_t )1, sizeof(struct filter ));
#line 941
  filter = (struct filter *)tmp;
  }
#line 942
  if ((unsigned long )filter == (unsigned long )((void *)0)) {
#line 943
    return (-1);
  }
  {
#line 945
  filter->proto = -2;
#line 946
  filter->plen_le = (unsigned char)128;
#line 947
  add_filter(filter, & redistribute_filters);
  }
  {
#line 949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 949
    if (! interface_confs) {
#line 949
      goto while_break;
    }
#line 952
    if_conf = interface_confs;
#line 953
    interface_confs = interface_confs->next;
#line 954
    if_conf->next = (struct interface_conf *)((void *)0);
#line 955
    if (default_interface_conf) {
      {
#line 956
      merge_ifconf(if_conf, (struct interface_conf  const  *)if_conf, (struct interface_conf  const  *)default_interface_conf);
      }
    }
    {
#line 957
    tmp___0 = add_interface(if_conf->ifname, if_conf);
#line 957
    vrc = (void *)tmp___0;
    }
#line 958
    if ((unsigned long )vrc == (unsigned long )((void *)0)) {
      {
#line 959
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t add interface %s.\n",
              if_conf->ifname);
      }
#line 960
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 964
  return (1);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 261 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 79 "/home/june/collector/temp/babeld-1.4.3/route.h"
void for_all_routes(void (*f)(struct babel_route * , void * ) , void *closure ) ;
#line 97 "/home/june/collector/temp/babeld-1.4.3/util.h"
int wait_for_fd(int direction , int fd , int msecs ) ;
#line 37 "/home/june/collector/temp/babeld-1.4.3/local.h"
int local_server_socket ;
#line 37 "/home/june/collector/temp/babeld-1.4.3/local.h"
int local_sockets[4]  ;
#line 38
int num_local_sockets ;
#line 41
int local_read(int s ) ;
#line 44
void local_notify_route(struct babel_route *route , int kind ) ;
#line 45
void local_notify_all_1(int s ) ;
#line 44 "/home/june/collector/temp/babeld-1.4.3/local.c"
int local_server_socket  =    -1;
#line 45 "/home/june/collector/temp/babeld-1.4.3/local.c"
int num_local_sockets  =    0;
#line 46 "/home/june/collector/temp/babeld-1.4.3/local.c"
int local_server_port  =    -1;
#line 48 "/home/june/collector/temp/babeld-1.4.3/local.c"
int local_read(int s ) 
{ 
  int rc ;
  char buf___2[500] ;
  ssize_t tmp ;

  {
  {
#line 55
  tmp = read(s, (void *)(buf___2), (size_t )500);
#line 55
  rc = (int )tmp;
  }
#line 57
  if (rc <= 0) {
#line 58
    return (rc);
  }
#line 60
  return (1);
}
}
#line 63 "/home/june/collector/temp/babeld-1.4.3/local.c"
static int write_timeout(int fd , void const   *buf___2 , int len ) 
{ 
  int n ;
  int rc ;
  char const   *b ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 66
  n = 0;
#line 66
  rc = 0;
#line 67
  b = (char const   *)buf___2;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (n < len)) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp = write(fd, (void const   *)(b + n), (size_t )(len - n));
#line 70
    rc = (int )tmp;
    }
#line 71
    if (rc < 0) {
      {
#line 72
      tmp___1 = __errno_location();
      }
#line 72
      if (*tmp___1 == 11) {
#line 72
        goto _L;
      } else {
        {
#line 72
        tmp___2 = __errno_location();
        }
#line 72
        if (*tmp___2 == 4) {
          _L: /* CIL Label */ 
          {
#line 73
          rc = wait_for_fd(1, fd, 100);
          }
#line 74
          if (rc > 0) {
            {
#line 75
            tmp___0 = write(fd, (void const   *)(b + n), (size_t )(len - n));
#line 75
            rc = (int )tmp___0;
            }
          }
        }
      }
    }
#line 79
    if (rc > 0) {
#line 80
      n += rc;
    } else {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (n >= len) {
#line 86
    return (1);
  } else {
#line 88
    if (rc >= 0) {
      {
#line 89
      tmp___3 = __errno_location();
#line 89
      *tmp___3 = 11;
      }
    }
#line 90
    return (-1);
  }
}
}
#line 94 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_self_1(int s ) 
{ 
  char buf___2[512] ;
  char host[64] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 101
  rc = gethostname(host, (size_t )64);
  }
#line 103
  if (rc < 0) {
    {
#line 104
    strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"alamakota",
            (size_t )64);
    }
  }
  {
#line 106
  tmp = format_eui64((unsigned char const   *)(myid));
#line 106
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )512, (char const   */* __restrict  */)"add self %.64s id %s\n",
                host, tmp);
  }
#line 109
  if (rc < 0) {
#line 110
    goto fail;
  } else
#line 109
  if (rc >= 512) {
#line 110
    goto fail;
  }
  {
#line 112
  rc = write_timeout(s, (void const   *)(buf___2), rc);
  }
#line 113
  if (rc < 0) {
#line 114
    goto fail;
  }
#line 115
  return;
  fail: 
  {
#line 118
  shutdown(s, 1);
  }
#line 119
  return;
}
}
#line 122 "/home/june/collector/temp/babeld-1.4.3/local.c"
static char const   *local_kind(int kind ) 
{ 


  {
  {
#line 126
  if (kind == 0) {
#line 126
    goto case_0;
  }
#line 127
  if (kind == 2) {
#line 127
    goto case_2;
  }
#line 128
  if (kind == 1) {
#line 128
    goto case_1;
  }
#line 129
  goto switch_default;
  case_0: /* CIL Label */ 
#line 126
  return ("flush");
  case_2: /* CIL Label */ 
#line 127
  return ("change");
  case_1: /* CIL Label */ 
#line 128
  return ("add");
  switch_default: /* CIL Label */ 
#line 129
  return ("???");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 133 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_neighbour_1(int s , struct neighbour *neigh , int kind ) 
{ 
  char buf___2[512] ;
  int rc ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 139
  tmp = neighbour_cost(neigh);
#line 139
  tmp___0 = neighbour_txcost(neigh);
#line 139
  tmp___1 = neighbour_rxcost(neigh);
#line 139
  tmp___2 = format_address((unsigned char const   *)(neigh->address));
#line 139
  tmp___3 = local_kind(kind);
#line 139
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )512, (char const   */* __restrict  */)"%s neighbour %lx address %s if %s reach %04x rxcost %d txcost %d cost %d\n",
                tmp___3, (unsigned long )neigh, tmp___2, (neigh->ifp)->name, (int )neigh->reach,
                tmp___1, tmp___0, tmp);
  }
#line 153
  if (rc < 0) {
#line 154
    goto fail;
  } else
#line 153
  if (rc >= 512) {
#line 154
    goto fail;
  }
  {
#line 156
  rc = write_timeout(s, (void const   *)(buf___2), rc);
  }
#line 157
  if (rc < 0) {
#line 158
    goto fail;
  }
#line 159
  return;
  fail: 
  {
#line 162
  shutdown(s, 1);
  }
#line 163
  return;
}
}
#line 166 "/home/june/collector/temp/babeld-1.4.3/local.c"
void local_notify_neighbour(struct neighbour *neigh , int kind ) 
{ 
  int i___2 ;

  {
#line 170
  i___2 = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i___2 < num_local_sockets)) {
#line 170
      goto while_break;
    }
    {
#line 171
    local_notify_neighbour_1(local_sockets[i___2], neigh, kind);
#line 170
    i___2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 174 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_xroute_1(int s , struct xroute *xroute , int kind ) 
{ 
  char buf___2[512] ;
  int rc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 180
  tmp = format_prefix((unsigned char const   *)(xroute->prefix), xroute->plen);
#line 180
  tmp___0 = format_prefix((unsigned char const   *)(xroute->prefix), xroute->plen);
#line 180
  tmp___1 = local_kind(kind);
#line 180
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )512, (char const   */* __restrict  */)"%s xroute %s prefix %s metric %d\n",
                tmp___1, tmp___0, tmp, (int )xroute->metric);
  }
#line 186
  if (rc < 0) {
#line 187
    goto fail;
  } else
#line 186
  if (rc >= 512) {
#line 187
    goto fail;
  }
  {
#line 189
  rc = write_timeout(s, (void const   *)(buf___2), rc);
  }
#line 190
  if (rc < 0) {
#line 191
    goto fail;
  }
#line 192
  return;
  fail: 
  {
#line 195
  shutdown(s, 1);
  }
#line 196
  return;
}
}
#line 199 "/home/june/collector/temp/babeld-1.4.3/local.c"
void local_notify_xroute(struct xroute *xroute , int kind ) 
{ 
  int i___2 ;

  {
#line 203
  i___2 = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i___2 < num_local_sockets)) {
#line 203
      goto while_break;
    }
    {
#line 204
    local_notify_xroute_1(local_sockets[i___2], xroute, kind);
#line 203
    i___2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_route_1(int s , struct babel_route *route , int kind ) 
{ 
  char buf___2[512] ;
  int rc ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 213
  tmp = format_address((unsigned char const   *)((route->neigh)->address));
#line 213
  tmp___0 = route_metric((struct babel_route  const  *)route);
#line 213
  tmp___1 = format_eui64((unsigned char const   *)((route->src)->id));
  }
#line 213
  if (route->installed) {
#line 213
    tmp___2 = "yes";
  } else {
#line 213
    tmp___2 = "no";
  }
  {
#line 213
  tmp___3 = format_prefix((unsigned char const   *)((route->src)->prefix), (route->src)->plen);
#line 213
  tmp___4 = format_prefix((unsigned char const   *)((route->src)->prefix), (route->src)->plen);
#line 213
  tmp___5 = local_kind(kind);
#line 213
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )512, (char const   */* __restrict  */)"%s route %s-%lx prefix %s installed %s id %s metric %d refmetric %d via %s if %s\n",
                tmp___5, tmp___4, (unsigned long )route->neigh, tmp___3, tmp___2,
                tmp___1, tmp___0, (int )route->refmetric, tmp, ((route->neigh)->ifp)->name);
  }
#line 226
  if (rc < 0) {
#line 227
    goto fail;
  } else
#line 226
  if (rc >= 512) {
#line 227
    goto fail;
  }
  {
#line 229
  rc = write_timeout(s, (void const   *)(buf___2), rc);
  }
#line 230
  if (rc < 0) {
#line 231
    goto fail;
  }
#line 232
  return;
  fail: 
  {
#line 235
  shutdown(s, 1);
  }
#line 236
  return;
}
}
#line 239 "/home/june/collector/temp/babeld-1.4.3/local.c"
void local_notify_route(struct babel_route *route , int kind ) 
{ 
  int i___2 ;

  {
#line 243
  i___2 = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i___2 < num_local_sockets)) {
#line 243
      goto while_break;
    }
    {
#line 244
    local_notify_route_1(local_sockets[i___2], route, kind);
#line 243
    i___2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 247 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_xroute_callback(struct xroute *xroute , void *closure ) 
{ 


  {
  {
#line 250
  local_notify_xroute_1(*((int *)closure), xroute, 1);
  }
#line 251
  return;
}
}
#line 253 "/home/june/collector/temp/babeld-1.4.3/local.c"
static void local_notify_route_callback(struct babel_route *route , void *closure ) 
{ 


  {
  {
#line 256
  local_notify_route_1(*((int *)closure), route, 1);
  }
#line 257
  return;
}
}
#line 259 "/home/june/collector/temp/babeld-1.4.3/local.c"
void local_notify_all_1(int s ) 
{ 
  int rc ;
  struct neighbour *neigh ;
  char const   *header ;
  size_t tmp ;

  {
  {
#line 264
  header = "BABEL 0.0\n";
#line 266
  tmp = strlen(header);
#line 266
  rc = write_timeout(s, (void const   *)header, (int )tmp);
  }
#line 267
  if (rc < 0) {
#line 268
    goto fail;
  }
  {
#line 270
  local_notify_self_1(s);
#line 271
  neigh = neighs;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! neigh) {
#line 271
      goto while_break;
    }
    {
#line 272
    local_notify_neighbour_1(s, neigh, 1);
#line 271
    neigh = neigh->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  for_all_xroutes(& local_notify_xroute_callback, (void *)(& s));
#line 275
  for_all_routes(& local_notify_route_callback, (void *)(& s));
#line 276
  rc = write_timeout(s, (void const   *)"done\n", 5);
  }
#line 277
  if (rc < 0) {
#line 278
    goto fail;
  }
#line 279
  return;
  fail: 
  {
#line 282
  shutdown(s, 1);
  }
#line 283
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 23 "/home/june/collector/temp/babeld-1.4.3/net.h"
int babel_socket(int port ) ;
#line 24
int babel_recv(int s , void *buf___2 , int buflen , struct sockaddr *sin , int slen ) ;
#line 28
int tcp_server_socket(int port , int local ) ;
#line 41 "/home/june/collector/temp/babeld-1.4.3/net.c"
int babel_socket(int port ) 
{ 
  struct sockaddr_in6 sin6 ;
  int s ;
  int rc ;
  int saved_errno ;
  int one ;
  int zero ;
  int ds ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 47
  one = 1;
#line 47
  zero = 0;
#line 48
  ds = 192;
#line 50
  s = socket(10, 2, 0);
  }
#line 51
  if (s < 0) {
#line 52
    return (-1);
  }
  {
#line 54
  rc = setsockopt(s, 41, 26, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 55
  if (rc < 0) {
#line 56
    goto fail;
  }
  {
#line 58
  rc = setsockopt(s, 1, 2, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 59
  if (rc < 0) {
#line 60
    goto fail;
  }
  {
#line 62
  rc = setsockopt(s, 41, 19, (void const   *)(& zero), (socklen_t )sizeof(zero));
  }
#line 64
  if (rc < 0) {
#line 65
    goto fail;
  }
  {
#line 67
  rc = setsockopt(s, 41, 16, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 69
  if (rc < 0) {
#line 70
    goto fail;
  }
  {
#line 72
  rc = setsockopt(s, 41, 18, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 74
  if (rc < 0) {
#line 75
    goto fail;
  }
  {
#line 78
  rc = setsockopt(s, 41, 67, (void const   *)(& ds), (socklen_t )sizeof(ds));
  }
#line 83
  if (rc < 0) {
    {
#line 84
    perror("Couldn\'t set traffic class");
    }
  }
  {
#line 86
  rc = fcntl(s, 3, 0);
  }
#line 87
  if (rc < 0) {
#line 88
    goto fail;
  }
  {
#line 90
  rc = fcntl(s, 4, rc | 2048);
  }
#line 91
  if (rc < 0) {
#line 92
    goto fail;
  }
  {
#line 94
  rc = fcntl(s, 1, 0);
  }
#line 95
  if (rc < 0) {
#line 96
    goto fail;
  }
  {
#line 98
  rc = fcntl(s, 2, rc | 1);
  }
#line 99
  if (rc < 0) {
#line 100
    goto fail;
  }
  {
#line 102
  memset((void *)(& sin6), 0, sizeof(sin6));
#line 103
  sin6.sin6_family = (sa_family_t )10;
#line 104
  sin6.sin6_port = htons((uint16_t )port);
#line 105
  rc = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin6)), (socklen_t )sizeof(sin6));
  }
#line 106
  if (rc < 0) {
#line 107
    goto fail;
  }
#line 109
  return (s);
  fail: 
  {
#line 112
  tmp = __errno_location();
#line 112
  saved_errno = *tmp;
#line 113
  close(s);
#line 114
  tmp___0 = __errno_location();
#line 114
  *tmp___0 = saved_errno;
  }
#line 115
  return (-1);
}
}
#line 118 "/home/june/collector/temp/babeld-1.4.3/net.c"
int babel_recv(int s , void *buf___2 , int buflen , struct sockaddr *sin , int slen ) 
{ 
  struct iovec iovec ;
  struct msghdr msg ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 125
  memset((void *)(& msg), 0, sizeof(msg));
#line 126
  iovec.iov_base = buf___2;
#line 127
  iovec.iov_len = (size_t )buflen;
#line 128
  msg.msg_name = (void *)sin;
#line 129
  msg.msg_namelen = (socklen_t )slen;
#line 130
  msg.msg_iov = & iovec;
#line 131
  msg.msg_iovlen = (size_t )1;
#line 133
  tmp = recvmsg(s, & msg, 0);
#line 133
  rc = (int )tmp;
  }
#line 134
  return (rc);
}
}
#line 137 "/home/june/collector/temp/babeld-1.4.3/net.c"
int babel_send(int s , void const   *buf1 , int buflen1 , void const   *buf2 , int buflen2 ,
               struct sockaddr  const  *sin , int slen ) 
{ 
  struct iovec iovec[2] ;
  struct msghdr msg ;
  int rc ;
  ssize_t tmp ;
  int rc2 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 146
  iovec[0].iov_base = (void *)buf1;
#line 147
  iovec[0].iov_len = (size_t )buflen1;
#line 148
  iovec[1].iov_base = (void *)buf2;
#line 149
  iovec[1].iov_len = (size_t )buflen2;
#line 150
  memset((void *)(& msg), 0, sizeof(msg));
#line 151
  msg.msg_name = (void *)((struct sockaddr *)sin);
#line 152
  msg.msg_namelen = (socklen_t )slen;
#line 153
  msg.msg_iov = iovec;
#line 154
  msg.msg_iovlen = (size_t )2;
  }
  again: 
  {
#line 157
  tmp = sendmsg(s, (struct msghdr  const  *)(& msg), 0);
#line 157
  rc = (int )tmp;
  }
#line 158
  if (rc < 0) {
    {
#line 159
    tmp___2 = __errno_location();
    }
#line 159
    if (*tmp___2 == 4) {
#line 160
      goto again;
    } else {
      {
#line 161
      tmp___1 = __errno_location();
      }
#line 161
      if (*tmp___1 == 11) {
        {
#line 163
        rc2 = wait_for_fd(1, s, 5);
        }
#line 164
        if (rc2 > 0) {
#line 165
          goto again;
        }
        {
#line 166
        tmp___0 = __errno_location();
#line 166
        *tmp___0 = 11;
        }
      }
    }
  }
#line 169
  return (rc);
}
}
#line 172 "/home/june/collector/temp/babeld-1.4.3/net.c"
int tcp_server_socket(int port , int local ) 
{ 
  struct sockaddr_in6 sin6 ;
  int s ;
  int rc ;
  int saved_errno ;
  int one ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 177
  one = 1;
#line 179
  s = socket(10, 1, 0);
  }
#line 180
  if (s < 0) {
#line 181
    return (-1);
  }
  {
#line 183
  rc = setsockopt(s, 1, 2, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 184
  if (rc < 0) {
#line 185
    goto fail;
  }
  {
#line 187
  rc = fcntl(s, 3, 0);
  }
#line 188
  if (rc < 0) {
#line 189
    goto fail;
  }
  {
#line 191
  rc = fcntl(s, 4, rc | 2048);
  }
#line 192
  if (rc < 0) {
#line 193
    goto fail;
  }
  {
#line 195
  rc = fcntl(s, 1, 0);
  }
#line 196
  if (rc < 0) {
#line 197
    goto fail;
  }
  {
#line 199
  rc = fcntl(s, 2, rc | 1);
  }
#line 200
  if (rc < 0) {
#line 201
    goto fail;
  }
  {
#line 203
  memset((void *)(& sin6), 0, sizeof(sin6));
#line 204
  sin6.sin6_family = (sa_family_t )10;
#line 205
  sin6.sin6_port = htons((uint16_t )port);
  }
#line 206
  if (local) {
    {
#line 207
    rc = inet_pton(10, (char const   */* __restrict  */)"::1", (void */* __restrict  */)(& sin6.sin6_addr));
    }
#line 208
    if (rc < 0) {
#line 209
      goto fail;
    }
  }
  {
#line 211
  rc = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin6)), (socklen_t )sizeof(sin6));
  }
#line 212
  if (rc < 0) {
#line 213
    goto fail;
  }
  {
#line 215
  rc = listen(s, 2);
  }
#line 216
  if (rc < 0) {
#line 217
    goto fail;
  }
#line 219
  return (s);
  fail: 
  {
#line 222
  tmp = __errno_location();
#line 222
  saved_errno = *tmp;
#line 223
  close(s);
#line 224
  tmp___0 = __errno_location();
#line 224
  *tmp___0 = saved_errno;
  }
#line 225
  return (-1);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 194 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) if_indextoname)(unsigned int __ifindex ,
                                                                                       char *__ifname ) ;
#line 83 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
struct timeval now  ;
#line 94 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
unsigned char myid[8]  ;
#line 96
unsigned char const   zeroes[16] ;
#line 96
unsigned char const   ones[16] ;
#line 98 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
int protocol_port  ;
#line 99 "/home/june/collector/temp/babeld-1.4.3/babeld.h"
unsigned char protocol_group[16]  ;
#line 101
int kernel_socket ;
#line 70 "/home/june/collector/temp/babeld-1.4.3/util.h"
void timeval_minus(struct timeval *d , struct timeval  const  *s1 , struct timeval  const  *s2 ) ;
#line 76
int timeval_compare(struct timeval  const  *s1 , struct timeval  const  *s2 )  __attribute__((__pure__)) ;
#line 78
void timeval_min(struct timeval *d , struct timeval  const  *s ) ;
#line 79
void timeval_min_sec(struct timeval *d , time_t secs ) ;
#line 80
int parse_nat(char const   *string )  __attribute__((__pure__)) ;
#line 102
int daemonise(void) ;
#line 53 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int kernel_setup(int setup ) ;
#line 54
int kernel_setup_socket(int setup ) ;
#line 67
int kernel_callback(int (*fn)(int  , void * ) , void *closure ) ;
#line 70
int if_eui64(char *ifname , int ifindex , unsigned char *eui ) ;
#line 71
int gettime(struct timeval *tv ) ;
#line 72
int read_random_bytes(void *buf___2 , size_t len ) ;
#line 76 "/home/june/collector/temp/babeld-1.4.3/route.h"
void flush_all_routes(void) ;
#line 84
int route_feasible(struct babel_route *route ) ;
#line 91
int route_smoothed_metric(struct babel_route *route ) ;
#line 115
void expire_routes(void) ;
#line 42 "/home/june/collector/temp/babeld-1.4.3/resend.h"
struct timeval resend_time ;
#line 59
void expire_resend(void) ;
#line 61
void do_resend(void) ;
#line 59 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int debug  =    0;
#line 61 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int link_detect  =    0;
#line 62 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int all_wireless  =    0;
#line 63 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int default_wireless_hello_interval  =    -1;
#line 64 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int default_wired_hello_interval  =    -1;
#line 65 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int resend_delay  =    -1;
#line 66 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int random_id  =    0;
#line 67 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int do_daemonise  =    0;
#line 68 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
char const   *logfile  =    (char const   *)((void *)0);
#line 68 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
char const   *pidfile  =    "/var/run/babeld.pid";
#line 68 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
char const   *state_file  =    "/var/lib/babel-state";
#line 72 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
unsigned char *receive_buffer  =    (unsigned char *)((void *)0);
#line 73 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int receive_buffer_size  =    0;
#line 75 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
unsigned char const   zeroes[16]  = {      (unsigned char const   )0};
#line 76 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
unsigned char const   ones[16]  = 
#line 76
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255};
#line 82 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int protocol_socket  =    -1;
#line 83 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int kernel_socket  =    -1;
#line 84 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int kernel_routes_changed  =    0;
#line 85 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int kernel_link_changed  =    0;
#line 86 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int kernel_addr_changed  =    0;
#line 88 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
struct timeval check_neighbours_timeout  ;
#line 88 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
struct timeval check_interfaces_timeout  ;
#line 90 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int volatile   exiting  =    (sig_atomic_t volatile   )0;
#line 90 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int volatile   dumping  =    (sig_atomic_t volatile   )0;
#line 90 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int volatile   reopening  =    (sig_atomic_t volatile   )0;
#line 92
static int accept_local_connections(fd_set *readfds ) ;
#line 93
static int kernel_routes_callback(int changed , void *closure ) ;
#line 94
static void init_signals(void) ;
#line 95
static void dump_tables(FILE *out ) ;
#line 96
static int reopen_logfile(void) ;
#line 98 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int main(int argc , char **argv ) 
{ 
  struct sockaddr_in6 sin6 ;
  int rc ;
  int fd ;
  int i___2 ;
  int opt ;
  time_t expiry_time ;
  time_t source_expiry_time ;
  time_t kernel_dump_time ;
  char const   *config_file ;
  void *vrc ;
  unsigned int seed ;
  struct interface *ifp ;
  char *comma ;
  long tmp ;
  int l ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int line ;
  int tmp___4 ;
  int pfd ;
  int len ;
  char buf___2[100] ;
  __pid_t tmp___5 ;
  char buf___3[40] ;
  ssize_t tmp___6 ;
  struct interface *tmp___7 ;
  int ifindex ;
  unsigned int tmp___8 ;
  unsigned char eui[8] ;
  char buf___4[16] ;
  char *ifname ;
  unsigned char eui___0[8] ;
  long tmp___9 ;
  int *tmp___10 ;
  char buf___5[100] ;
  char buf2[100] ;
  int s ;
  long t ;
  ssize_t tmp___11 ;
  unsigned char sid[8] ;
  struct timeval realnow ;
  char const   *tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  struct timeval tv ;
  fd_set readfds ;
  int tmp___23 ;
  int __d0 ;
  int __d1 ;
  int maxfd ;
  int *tmp___24 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int msecs ;
  unsigned int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  long tmp___46 ;
  long tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  struct timeval realnow___0 ;
  char buf___6[100] ;
  char const   *tmp___53 ;
  ssize_t tmp___54 ;
  long tmp___55 ;
  int tmp___56 ;

  {
  {
#line 104
  config_file = (char const   *)((void *)0);
#line 109
  gettime(& now);
#line 111
  rc = read_random_bytes((void *)(& seed), sizeof(seed));
  }
#line 112
  if (rc < 0) {
    {
#line 113
    perror("read(random)");
#line 114
    seed = 42U;
    }
  }
  {
#line 117
  seed = (unsigned int )((long )seed ^ (now.tv_sec ^ now.tv_usec));
#line 118
  srandom(seed);
#line 120
  parse_address("ff02:0:0:0:0:0:1:6", protocol_group, (int *)((void *)0));
#line 121
  protocol_port = 6696;
#line 122
  change_smoothing_half_life(4);
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    opt = getopt(argc, (char * const  *)argv, "m:p:h:H:i:k:A:sruS:d:g:lwz:M:t:T:c:C:DL:I:");
    }
#line 126
    if (opt < 0) {
#line 127
      goto while_break;
    }
    {
#line 130
    if (opt == 109) {
#line 130
      goto case_109;
    }
#line 145
    if (opt == 112) {
#line 145
      goto case_112;
    }
#line 150
    if (opt == 104) {
#line 150
      goto case_104;
    }
#line 156
    if (opt == 72) {
#line 156
      goto case_72;
    }
#line 162
    if (opt == 107) {
#line 162
      goto case_107;
    }
#line 167
    if (opt == 65) {
#line 167
      goto case_65;
    }
#line 172
    if (opt == 115) {
#line 172
      goto case_115;
    }
#line 175
    if (opt == 114) {
#line 175
      goto case_114;
    }
#line 178
    if (opt == 117) {
#line 178
      goto case_117;
    }
#line 181
    if (opt == 83) {
#line 181
      goto case_83;
    }
#line 184
    if (opt == 100) {
#line 184
      goto case_100;
    }
#line 189
    if (opt == 103) {
#line 189
      goto case_103;
    }
#line 198
    if (opt == 108) {
#line 198
      goto case_108;
    }
#line 201
    if (opt == 119) {
#line 201
      goto case_119;
    }
#line 204
    if (opt == 122) {
#line 204
      goto case_122;
    }
#line 218
    if (opt == 77) {
#line 218
      goto case_77;
    }
#line 225
    if (opt == 116) {
#line 225
      goto case_116;
    }
#line 230
    if (opt == 84) {
#line 230
      goto case_84;
    }
#line 234
    if (opt == 99) {
#line 234
      goto case_99;
    }
#line 237
    if (opt == 67) {
#line 237
      goto case_67;
    }
#line 245
    if (opt == 68) {
#line 245
      goto case_68;
    }
#line 248
    if (opt == 76) {
#line 248
      goto case_76;
    }
#line 251
    if (opt == 73) {
#line 251
      goto case_73;
    }
#line 254
    goto switch_default;
    case_109: /* CIL Label */ 
    {
#line 131
    rc = parse_address((char const   *)optarg, protocol_group, (int *)((void *)0));
    }
#line 132
    if (rc < 0) {
#line 133
      goto usage;
    }
#line 134
    if ((int )protocol_group[0] != 255) {
      {
#line 135
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is not a multicast address\n",
              optarg);
      }
#line 137
      goto usage;
    }
#line 139
    if ((int )protocol_group[1] != 2) {
      {
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s is not a link-local multicast address\n",
              optarg);
      }
    }
#line 144
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 146
    protocol_port = parse_nat((char const   *)optarg);
    }
#line 147
    if (protocol_port <= 0) {
#line 148
      goto usage;
    } else
#line 147
    if (protocol_port > 65535) {
#line 148
      goto usage;
    }
#line 149
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 151
    default_wireless_hello_interval = parse_msec((char const   *)optarg);
    }
#line 152
    if (default_wireless_hello_interval <= 0) {
#line 154
      goto usage;
    } else
#line 152
    if (default_wireless_hello_interval > 655350) {
#line 154
      goto usage;
    }
#line 155
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 157
    default_wired_hello_interval = parse_msec((char const   *)optarg);
    }
#line 158
    if (default_wired_hello_interval <= 0) {
#line 160
      goto usage;
    } else
#line 158
    if (default_wired_hello_interval > 655350) {
#line 160
      goto usage;
    }
#line 161
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 163
    kernel_metric = parse_nat((char const   *)optarg);
    }
#line 164
    if (kernel_metric < 0) {
#line 165
      goto usage;
    } else
#line 164
    if (kernel_metric > 65535) {
#line 165
      goto usage;
    }
#line 166
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 168
    allow_duplicates = parse_nat((char const   *)optarg);
    }
#line 169
    if (allow_duplicates < 0) {
#line 170
      goto usage;
    } else
#line 169
    if (allow_duplicates > 65535) {
#line 170
      goto usage;
    }
#line 171
    goto switch_break;
    case_115: /* CIL Label */ 
#line 173
    split_horizon = 0;
#line 174
    goto switch_break;
    case_114: /* CIL Label */ 
#line 176
    random_id = 1;
#line 177
    goto switch_break;
    case_117: /* CIL Label */ 
#line 179
    keep_unfeasible = 1;
#line 180
    goto switch_break;
    case_83: /* CIL Label */ 
#line 182
    state_file = (char const   *)optarg;
#line 183
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 185
    debug = parse_nat((char const   *)optarg);
    }
#line 186
    if (debug < 0) {
#line 187
      goto usage;
    }
#line 188
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 193
    local_server_port = parse_nat((char const   *)optarg);
    }
#line 194
    if (local_server_port <= 0) {
#line 195
      goto usage;
    } else
#line 194
    if (local_server_port > 65535) {
#line 195
      goto usage;
    }
#line 197
    goto switch_break;
    case_108: /* CIL Label */ 
#line 199
    link_detect = 1;
#line 200
    goto switch_break;
    case_119: /* CIL Label */ 
#line 202
    all_wireless = 1;
#line 203
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 207
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& comma),
                 0);
#line 207
    diversity_kind = (int )tmp;
    }
#line 208
    if ((int )*comma == 0) {
#line 209
      diversity_factor = 128;
    } else
#line 210
    if ((int )*comma == 44) {
      {
#line 211
      diversity_factor = parse_nat((char const   *)(comma + 1));
      }
    } else {
#line 213
      goto usage;
    }
#line 214
    if (diversity_factor <= 0) {
#line 215
      goto usage;
    } else
#line 214
    if (diversity_factor > 256) {
#line 215
      goto usage;
    }
#line 217
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 219
    tmp___0 = parse_nat((char const   *)optarg);
#line 219
    l = tmp___0;
    }
#line 220
    if (l < 0) {
#line 221
      goto usage;
    } else
#line 220
    if (l > 3600) {
#line 221
      goto usage;
    }
    {
#line 222
    change_smoothing_half_life(l);
    }
#line 223
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 226
    export_table = parse_nat((char const   *)optarg);
    }
#line 227
    if (export_table < 0) {
#line 228
      goto usage;
    } else
#line 227
    if (export_table > 65535) {
#line 228
      goto usage;
    }
#line 229
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 231
    tmp___1 = parse_nat((char const   *)optarg);
#line 231
    tmp___2 = add_import_table(tmp___1);
    }
#line 231
    if (tmp___2) {
#line 232
      goto usage;
    }
#line 233
    goto switch_break;
    case_99: /* CIL Label */ 
#line 235
    config_file = (char const   *)optarg;
#line 236
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 238
    rc = parse_config_from_string(optarg);
    }
#line 239
    if (rc < 0) {
      {
#line 240
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse configuration from command line.\n");
#line 242
      exit(1);
      }
    }
#line 244
    goto switch_break;
    case_68: /* CIL Label */ 
#line 246
    do_daemonise = 1;
#line 247
    goto switch_break;
    case_76: /* CIL Label */ 
#line 249
    logfile = (char const   *)optarg;
#line 250
    goto switch_break;
    case_73: /* CIL Label */ 
#line 252
    pidfile = (char const   *)optarg;
#line 253
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 255
    goto usage;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  if (! config_file) {
    {
#line 260
    tmp___3 = access("/etc/babeld.conf", 0);
    }
#line 260
    if (tmp___3 >= 0) {
#line 261
      config_file = "/etc/babeld.conf";
    }
  }
#line 263
  if (config_file) {
    {
#line 265
    rc = parse_config_from_file(config_file, & line);
    }
#line 266
    if (rc < 0) {
      {
#line 267
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse configuration from file %s (error at line %d).\n",
              config_file, line);
#line 271
      exit(1);
      }
    }
  } else {
    {
#line 274
    tmp___4 = access("/etc/babel.conf", 0);
    }
#line 274
    if (tmp___4 >= 0) {
      {
#line 275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: /etc/babel.conf exists, it will be ignored.\n");
      }
    }
  }
#line 279
  if (default_wireless_hello_interval <= 0) {
#line 280
    default_wireless_hello_interval = 4000;
  }
#line 281
  if (default_wireless_hello_interval <= 5) {
#line 281
    default_wireless_hello_interval = 5;
  } else {
#line 281
    default_wireless_hello_interval = default_wireless_hello_interval;
  }
#line 283
  if (default_wired_hello_interval <= 0) {
#line 284
    default_wired_hello_interval = 4000;
  }
#line 285
  if (default_wired_hello_interval <= 5) {
#line 285
    default_wired_hello_interval = 5;
  } else {
#line 285
    default_wired_hello_interval = default_wired_hello_interval;
  }
#line 287
  resend_delay = 2000;
#line 288
  if (resend_delay <= default_wireless_hello_interval / 2) {
#line 288
    resend_delay = resend_delay;
  } else {
#line 288
    resend_delay = default_wireless_hello_interval / 2;
  }
#line 289
  if (resend_delay <= default_wired_hello_interval / 2) {
#line 289
    resend_delay = resend_delay;
  } else {
#line 289
    resend_delay = default_wired_hello_interval / 2;
  }
#line 290
  if (resend_delay <= 20) {
#line 290
    resend_delay = 20;
  } else {
#line 290
    resend_delay = resend_delay;
  }
#line 292
  if (do_daemonise) {
#line 293
    if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 294
      logfile = "/var/log/babeld.log";
    }
  }
  {
#line 297
  rc = reopen_logfile();
  }
#line 298
  if (rc < 0) {
    {
#line 299
    perror("reopen_logfile()");
#line 300
    exit(1);
    }
  }
  {
#line 303
  fd = open("/dev/null", 0);
  }
#line 304
  if (fd < 0) {
    {
#line 305
    perror("open(null)");
#line 306
    exit(1);
    }
  }
  {
#line 309
  rc = dup2(fd, 0);
  }
#line 310
  if (rc < 0) {
    {
#line 311
    perror("dup2(null, 0)");
#line 312
    exit(1);
    }
  }
  {
#line 315
  close(fd);
  }
#line 317
  if (do_daemonise) {
    {
#line 318
    rc = daemonise();
    }
#line 319
    if (rc < 0) {
      {
#line 320
      perror("daemonise");
#line 321
      exit(1);
      }
    }
  }
#line 325
  if (pidfile) {
#line 325
    if ((int const   )*(pidfile + 0) != 0) {
      {
#line 329
      tmp___5 = getpid();
#line 329
      len = snprintf((char */* __restrict  */)(buf___2), (size_t )100, (char const   */* __restrict  */)"%lu",
                     (unsigned long )tmp___5);
      }
#line 330
      if (len < 0) {
        {
#line 331
        perror("snprintf(getpid)");
#line 332
        exit(1);
        }
      } else
#line 330
      if (len >= 100) {
        {
#line 331
        perror("snprintf(getpid)");
#line 332
        exit(1);
        }
      }
      {
#line 335
      pfd = open(pidfile, 193, 420);
      }
#line 336
      if (pfd < 0) {
        {
#line 338
        snprintf((char */* __restrict  */)(buf___3), (size_t )40, (char const   */* __restrict  */)"creat(%s)",
                 pidfile);
#line 339
        buf___3[39] = (char )'\000';
#line 340
        perror((char const   *)(buf___3));
#line 341
        exit(1);
        }
      }
      {
#line 344
      tmp___6 = write(pfd, (void const   *)(buf___2), (size_t )len);
#line 344
      rc = (int )tmp___6;
      }
#line 345
      if (rc < len) {
        {
#line 346
        perror("write(pidfile)");
        }
#line 347
        goto fail_pid;
      }
      {
#line 350
      close(pfd);
      }
    }
  }
  {
#line 353
  rc = kernel_setup(1);
  }
#line 354
  if (rc < 0) {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_setup failed.\n");
    }
#line 356
    goto fail_pid;
  }
  {
#line 359
  rc = kernel_setup_socket(1);
  }
#line 360
  if (rc < 0) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_setup_socket failed.\n");
#line 362
    kernel_setup(0);
    }
#line 363
    goto fail_pid;
  }
  {
#line 366
  rc = finalise_config();
  }
#line 367
  if (rc < 0) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t finalise configuration.\n");
    }
#line 369
    goto fail;
  }
#line 372
  i___2 = optind;
  {
#line 372
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 372
    if (! (i___2 < argc)) {
#line 372
      goto while_break___0;
    }
    {
#line 373
    tmp___7 = add_interface(*(argv + i___2), (struct interface_conf *)((void *)0));
#line 373
    vrc = (void *)tmp___7;
    }
#line 374
    if ((unsigned long )vrc == (unsigned long )((void *)0)) {
#line 375
      goto fail;
    }
#line 372
    i___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 378
  if ((unsigned long )interfaces == (unsigned long )((void *)0)) {
    {
#line 379
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Eek... asked to run on no interfaces!\n");
    }
#line 380
    goto fail;
  }
#line 383
  if (random_id) {
#line 384
    goto random_id;
  }
#line 386
  ifp = interfaces;
  {
#line 386
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 386
    if (! ifp) {
#line 386
      goto while_break___1;
    }
    {
#line 388
    tmp___8 = if_nametoindex((char const   *)(ifp->name));
#line 388
    ifindex = (int )tmp___8;
    }
#line 389
    if (ifindex > 0) {
      {
#line 391
      rc = if_eui64(ifp->name, ifindex, eui);
      }
#line 392
      if (rc < 0) {
#line 393
        goto __Cont;
      }
      {
#line 394
      memcpy((void */* __restrict  */)(myid), (void const   */* __restrict  */)(eui),
             (size_t )8);
      }
#line 395
      goto have_id;
    }
    __Cont: /* CIL Label */ 
#line 386
    ifp = ifp->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 401
  i___2 = 1;
  {
#line 401
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 401
    if (! (i___2 < 256)) {
#line 401
      goto while_break___2;
    }
    {
#line 404
    ifname = if_indextoname((unsigned int )i___2, buf___4);
    }
#line 405
    if ((unsigned long )ifname == (unsigned long )((void *)0)) {
#line 406
      goto __Cont___0;
    }
    {
#line 407
    rc = if_eui64(ifname, i___2, eui___0);
    }
#line 408
    if (rc < 0) {
#line 409
      goto __Cont___0;
    }
    {
#line 410
    memcpy((void */* __restrict  */)(myid), (void const   */* __restrict  */)(eui___0),
           (size_t )8);
    }
#line 411
    goto have_id;
    __Cont___0: /* CIL Label */ 
#line 401
    i___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 414
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t find router id -- using random value.\n");
  }
  random_id: 
  {
#line 418
  rc = read_random_bytes((void *)(myid), (size_t )8);
  }
#line 419
  if (rc < 0) {
    {
#line 420
    perror("read(random)");
    }
#line 421
    goto fail;
  }
#line 424
  myid[0] = (unsigned char )((int )myid[0] & -4);
  have_id: 
  {
#line 427
  tmp___9 = random();
#line 427
  myseqno = (unsigned short )(tmp___9 & 65535L);
#line 429
  fd = open(state_file, 0);
  }
#line 430
  if (fd < 0) {
    {
#line 430
    tmp___10 = __errno_location();
    }
#line 430
    if (*tmp___10 != 2) {
      {
#line 431
      perror("open(babel-state)");
      }
    }
  }
  {
#line 432
  rc = unlink(state_file);
  }
#line 433
  if (fd >= 0) {
#line 433
    if (rc < 0) {
      {
#line 434
      perror("unlink(babel-state)");
#line 436
      close(fd);
#line 437
      fd = -1;
      }
    }
  }
#line 439
  if (fd >= 0) {
    {
#line 444
    tmp___11 = read(fd, (void *)(buf___5), (size_t )99);
#line 444
    rc = (int )tmp___11;
    }
#line 445
    if (rc < 0) {
      {
#line 446
      perror("read(babel-state)");
      }
    } else {
      {
#line 448
      buf___5[rc] = (char )'\000';
#line 449
      rc = sscanf((char const   */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%99s %d %ld\n",
                  buf2, & s, & t);
      }
#line 450
      if (rc == 3) {
#line 450
        if (s >= 0) {
#line 450
          if (s <= 65535) {
            {
#line 452
            rc = parse_eui64((char const   *)(buf2), sid);
            }
#line 453
            if (rc < 0) {
              {
#line 454
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse babel-state.\n");
              }
            } else {
              {
#line 457
              while (1) {
                while_continue___3: /* CIL Label */ ;
                {
#line 457
                tmp___13 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                }
#line 457
                if (tmp___13) {
                  {
#line 457
                  tmp___12 = format_eui64((unsigned char const   *)(sid));
#line 457
                  do_debugf(2, "Got %s %d %ld from babel-state.\n", tmp___12, s, t);
                  }
                }
#line 457
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 459
              gettimeofday((struct timeval */* __restrict  */)(& realnow), (__timezone_ptr_t )((void *)0));
#line 460
              tmp___14 = memcmp((void const   *)(sid), (void const   *)(myid), (size_t )8);
              }
#line 460
              if (tmp___14 == 0) {
                {
#line 461
                myseqno = seqno_plus((unsigned short )s, 1);
                }
              } else
#line 462
              if (! random_id) {
                {
#line 463
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ID mismatch in babel-state.\n");
                }
              }
            }
          } else {
            {
#line 466
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse babel-state.\n");
            }
          }
        } else {
          {
#line 466
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse babel-state.\n");
          }
        }
      } else {
        {
#line 466
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse babel-state.\n");
        }
      }
    }
    {
#line 469
    close(fd);
#line 470
    fd = -1;
    }
  }
  {
#line 473
  protocol_socket = babel_socket(protocol_port);
  }
#line 474
  if (protocol_socket < 0) {
    {
#line 475
    perror("Couldn\'t create link local socket");
    }
#line 476
    goto fail;
  }
#line 480
  if (local_server_port >= 0) {
    {
#line 481
    local_server_socket = tcp_server_socket(local_server_port, 1);
    }
#line 482
    if (local_server_socket < 0) {
      {
#line 483
      perror("local_server_socket");
      }
#line 484
      goto fail;
    }
  }
  {
#line 489
  init_signals();
#line 490
  rc = resize_receive_buffer(1500);
  }
#line 491
  if (rc < 0) {
#line 492
    goto fail;
  }
#line 493
  if ((unsigned long )receive_buffer == (unsigned long )((void *)0)) {
#line 494
    goto fail;
  }
  {
#line 496
  check_interfaces();
#line 498
  rc = check_xroutes(0);
  }
#line 499
  if (rc < 0) {
    {
#line 500
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t check exported routes.\n");
    }
  }
  {
#line 502
  kernel_routes_changed = 0;
#line 503
  kernel_link_changed = 0;
#line 504
  kernel_addr_changed = 0;
#line 505
  tmp___15 = roughly(30);
#line 505
  kernel_dump_time = now.tv_sec + (__time_t )tmp___15;
#line 506
  schedule_neighbours_check(5000, 1);
#line 507
  schedule_interfaces_check(30000, 1);
#line 508
  tmp___16 = roughly(30);
#line 508
  expiry_time = now.tv_sec + (__time_t )tmp___16;
#line 509
  tmp___17 = roughly(300);
#line 509
  source_expiry_time = now.tv_sec + (__time_t )tmp___17;
#line 513
  ifp = interfaces;
  }
  {
#line 513
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 513
    if (! ifp) {
#line 513
      goto while_break___4;
    }
    {
#line 514
    tmp___18 = if_up(ifp);
    }
#line 514
    if (! tmp___18) {
#line 515
      goto __Cont___1;
    }
    {
#line 517
    tmp___19 = roughly(10000);
#line 517
    usleep((__useconds_t )tmp___19);
#line 518
    gettime(& now);
#line 519
    send_hello(ifp);
#line 520
    send_wildcard_retraction(ifp);
    }
    __Cont___1: /* CIL Label */ 
#line 513
    ifp = ifp->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 523
  ifp = interfaces;
  {
#line 523
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 523
    if (! ifp) {
#line 523
      goto while_break___5;
    }
    {
#line 524
    tmp___20 = if_up(ifp);
    }
#line 524
    if (! tmp___20) {
#line 525
      goto __Cont___2;
    }
    {
#line 526
    tmp___21 = roughly(10000);
#line 526
    usleep((__useconds_t )tmp___21);
#line 527
    gettime(& now);
#line 528
    send_hello(ifp);
#line 529
    send_wildcard_retraction(ifp);
#line 530
    send_self_update(ifp);
#line 531
    send_request(ifp, (unsigned char const   *)((void *)0), (unsigned char)0);
#line 532
    flushupdates(ifp);
#line 533
    flushbuf(ifp);
    }
    __Cont___2: /* CIL Label */ 
#line 523
    ifp = ifp->next;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 536
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 536
    tmp___22 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 536
    if (tmp___22) {
      {
#line 536
      do_debugf(2, "Entering main loop.\n");
      }
    }
#line 536
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 538
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 542
    gettime(& now);
#line 544
    tv = check_neighbours_timeout;
#line 545
    timeval_min(& tv, (struct timeval  const  *)(& check_interfaces_timeout));
#line 546
    timeval_min_sec(& tv, expiry_time);
#line 547
    timeval_min_sec(& tv, source_expiry_time);
#line 548
    timeval_min_sec(& tv, kernel_dump_time);
#line 549
    timeval_min(& tv, (struct timeval  const  *)(& resend_time));
#line 550
    ifp = interfaces;
    }
    {
#line 550
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 550
      if (! ifp) {
#line 550
        goto while_break___8;
      }
      {
#line 551
      tmp___23 = if_up(ifp);
      }
#line 551
      if (! tmp___23) {
#line 552
        goto __Cont___3;
      }
      {
#line 553
      timeval_min(& tv, (struct timeval  const  *)(& ifp->flush_timeout));
#line 554
      timeval_min(& tv, (struct timeval  const  *)(& ifp->hello_timeout));
#line 555
      timeval_min(& tv, (struct timeval  const  *)(& ifp->update_timeout));
#line 556
      timeval_min(& tv, (struct timeval  const  *)(& ifp->update_flush_timeout));
      }
      __Cont___3: /* CIL Label */ 
#line 550
      ifp = ifp->next;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 558
    timeval_min(& tv, (struct timeval  const  *)(& unicast_flush_timeout));
    }
    {
#line 559
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 559
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 559
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 560
    tmp___25 = timeval_compare((struct timeval  const  *)(& tv), (struct timeval  const  *)(& now));
    }
#line 560
    if (tmp___25 > 0) {
      {
#line 561
      maxfd = 0;
#line 562
      timeval_minus(& tv, (struct timeval  const  *)(& tv), (struct timeval  const  *)(& now));
#line 563
      readfds.__fds_bits[protocol_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << protocol_socket % (8 * (int )sizeof(__fd_mask ));
      }
#line 564
      if (maxfd <= protocol_socket) {
#line 564
        maxfd = protocol_socket;
      } else {
#line 564
        maxfd = maxfd;
      }
#line 565
      if (kernel_socket < 0) {
        {
#line 565
        kernel_setup_socket(1);
        }
      }
#line 566
      if (kernel_socket >= 0) {
#line 567
        readfds.__fds_bits[kernel_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << kernel_socket % (8 * (int )sizeof(__fd_mask ));
#line 568
        if (maxfd <= kernel_socket) {
#line 568
          maxfd = kernel_socket;
        } else {
#line 568
          maxfd = maxfd;
        }
      }
#line 571
      if (local_server_socket >= 0) {
#line 571
        if (num_local_sockets < 4) {
#line 573
          readfds.__fds_bits[local_server_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << local_server_socket % (8 * (int )sizeof(__fd_mask ));
#line 574
          if (maxfd <= local_server_socket) {
#line 574
            maxfd = local_server_socket;
          } else {
#line 574
            maxfd = maxfd;
          }
        }
      }
#line 576
      i___2 = 0;
      {
#line 576
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 576
        if (! (i___2 < num_local_sockets)) {
#line 576
          goto while_break___10;
        }
#line 577
        readfds.__fds_bits[local_sockets[i___2] / (8 * (int )sizeof(__fd_mask ))] |= 1L << local_sockets[i___2] % (8 * (int )sizeof(__fd_mask ));
#line 578
        if (maxfd <= local_sockets[i___2]) {
#line 578
          maxfd = local_sockets[i___2];
        } else {
#line 578
          maxfd = maxfd;
        }
#line 576
        i___2 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 581
      rc = select(maxfd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 582
      if (rc < 0) {
        {
#line 583
        tmp___24 = __errno_location();
        }
#line 583
        if (*tmp___24 != 4) {
          {
#line 584
          perror("select");
#line 585
          sleep(1U);
          }
        }
#line 587
        rc = 0;
        {
#line 588
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 588
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& readfds.__fds_bits[0]): "memory");
#line 588
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    }
    {
#line 592
    gettime(& now);
    }
#line 594
    if (exiting) {
#line 595
      goto while_break___7;
    }
#line 597
    if (kernel_socket >= 0) {
#line 597
      if ((readfds.__fds_bits[kernel_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << kernel_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 598
        kernel_callback(& kernel_routes_callback, (void *)0);
        }
      }
    }
#line 600
    if ((readfds.__fds_bits[protocol_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << protocol_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 601
      rc = babel_recv(protocol_socket, (void *)receive_buffer, receive_buffer_size,
                      (struct sockaddr *)(& sin6), (int )sizeof(sin6));
      }
#line 604
      if (rc < 0) {
        {
#line 605
        tmp___26 = __errno_location();
        }
#line 605
        if (*tmp___26 != 11) {
          {
#line 605
          tmp___27 = __errno_location();
          }
#line 605
          if (*tmp___27 != 4) {
            {
#line 606
            perror("recv");
#line 607
            sleep(1U);
            }
          }
        }
      } else {
#line 610
        ifp = interfaces;
        {
#line 610
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 610
          if (! ifp) {
#line 610
            goto while_break___12;
          }
          {
#line 611
          tmp___28 = if_up(ifp);
          }
#line 611
          if (! tmp___28) {
#line 612
            goto __Cont___4;
          }
#line 613
          if (ifp->ifindex == sin6.sin6_scope_id) {
            {
#line 614
            parse_packet((unsigned char const   *)((unsigned char *)(& sin6.sin6_addr)),
                         ifp, (unsigned char const   *)receive_buffer, rc);
            }
            {
#line 616
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 616
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 618
            goto while_break___12;
          }
          __Cont___4: /* CIL Label */ 
#line 610
          ifp = ifp->next;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
    {
#line 625
    accept_local_connections(& readfds);
#line 627
    i___2 = 0;
    }
    {
#line 628
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 628
      if (! (i___2 < num_local_sockets)) {
#line 628
        goto while_break___14;
      }
#line 629
      if ((readfds.__fds_bits[local_sockets[i___2] / (8 * (int )sizeof(__fd_mask ))] & (1L << local_sockets[i___2] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 630
        rc = local_read(local_sockets[i___2]);
        }
#line 631
        if (rc <= 0) {
#line 632
          if (rc < 0) {
            {
#line 633
            tmp___29 = __errno_location();
            }
#line 633
            if (*tmp___29 == 4) {
#line 634
              goto while_continue___14;
            }
            {
#line 635
            perror("read(local_socket)");
            }
          }
          {
#line 637
          close(local_sockets[i___2]);
#line 638
          num_local_sockets --;
#line 638
          local_sockets[i___2] = local_sockets[num_local_sockets];
          }
#line 639
          goto while_continue___14;
        }
      }
#line 642
      i___2 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 646
    if (reopening) {
      {
#line 647
      kernel_dump_time = now.tv_sec;
#line 648
      check_neighbours_timeout = now;
#line 649
      expiry_time = now.tv_sec;
#line 650
      rc = reopen_logfile();
      }
#line 651
      if (rc < 0) {
        {
#line 652
        perror("reopen_logfile");
        }
#line 653
        goto while_break___7;
      }
#line 655
      reopening = (int volatile   )0;
    }
#line 658
    if (kernel_link_changed) {
      {
#line 659
      check_interfaces();
#line 660
      kernel_link_changed = 0;
      }
    } else
#line 658
    if (kernel_addr_changed) {
      {
#line 659
      check_interfaces();
#line 660
      kernel_link_changed = 0;
      }
    }
#line 663
    if (kernel_routes_changed) {
#line 663
      goto _L;
    } else
#line 663
    if (kernel_addr_changed) {
#line 663
      goto _L;
    } else
#line 663
    if (now.tv_sec >= kernel_dump_time) {
      _L: /* CIL Label */ 
      {
#line 665
      rc = check_xroutes(1);
      }
#line 666
      if (rc < 0) {
        {
#line 667
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: couldn\'t check exported routes.\n");
        }
      }
#line 668
      kernel_addr_changed = 0;
#line 668
      kernel_routes_changed = kernel_addr_changed;
#line 669
      if (kernel_socket >= 0) {
        {
#line 670
        tmp___30 = roughly(300);
#line 670
        kernel_dump_time = now.tv_sec + (__time_t )tmp___30;
        }
      } else {
        {
#line 672
        tmp___31 = roughly(30);
#line 672
        kernel_dump_time = now.tv_sec + (__time_t )tmp___31;
        }
      }
    }
    {
#line 675
    tmp___33 = timeval_compare((struct timeval  const  *)(& check_neighbours_timeout),
                               (struct timeval  const  *)(& now));
    }
#line 675
    if (tmp___33 < 0) {
      {
#line 677
      tmp___32 = check_neighbours();
#line 677
      msecs = (int )tmp___32;
      }
#line 679
      if ((3 * msecs) / 2 <= 10) {
#line 679
        msecs = 10;
      } else {
#line 679
        msecs = (3 * msecs) / 2;
      }
      {
#line 680
      schedule_neighbours_check(msecs, 1);
      }
    }
    {
#line 683
    tmp___34 = timeval_compare((struct timeval  const  *)(& check_interfaces_timeout),
                               (struct timeval  const  *)(& now));
    }
#line 683
    if (tmp___34 < 0) {
      {
#line 684
      check_interfaces();
#line 685
      schedule_interfaces_check(30000, 1);
      }
    }
#line 688
    if (now.tv_sec >= expiry_time) {
      {
#line 689
      expire_routes();
#line 690
      expire_resend();
#line 691
      tmp___35 = roughly(30);
#line 691
      expiry_time = now.tv_sec + (__time_t )tmp___35;
      }
    }
#line 694
    if (now.tv_sec >= source_expiry_time) {
      {
#line 695
      expire_sources();
#line 696
      tmp___36 = roughly(300);
#line 696
      source_expiry_time = now.tv_sec + (__time_t )tmp___36;
      }
    }
#line 699
    ifp = interfaces;
    {
#line 699
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 699
      if (! ifp) {
#line 699
        goto while_break___15;
      }
      {
#line 700
      tmp___37 = if_up(ifp);
      }
#line 700
      if (! tmp___37) {
#line 701
        goto __Cont___5;
      }
      {
#line 702
      tmp___38 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& ifp->hello_timeout));
      }
#line 702
      if (tmp___38 >= 0) {
        {
#line 703
        send_hello(ifp);
        }
      }
      {
#line 704
      tmp___39 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& ifp->update_timeout));
      }
#line 704
      if (tmp___39 >= 0) {
        {
#line 705
        send_update(ifp, 0, (unsigned char const   *)((void *)0), (unsigned char)0);
        }
      }
      {
#line 706
      tmp___40 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& ifp->update_flush_timeout));
      }
#line 706
      if (tmp___40 >= 0) {
        {
#line 707
        flushupdates(ifp);
        }
      }
      __Cont___5: /* CIL Label */ 
#line 699
      ifp = ifp->next;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 710
    if (resend_time.tv_sec != 0L) {
      {
#line 711
      tmp___41 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& resend_time));
      }
#line 711
      if (tmp___41 >= 0) {
        {
#line 712
        do_resend();
        }
      }
    }
#line 715
    if (unicast_flush_timeout.tv_sec != 0L) {
      {
#line 716
      tmp___42 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& unicast_flush_timeout));
      }
#line 716
      if (tmp___42 >= 0) {
        {
#line 717
        flush_unicast(1);
        }
      }
    }
#line 720
    ifp = interfaces;
    {
#line 720
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 720
      if (! ifp) {
#line 720
        goto while_break___16;
      }
      {
#line 721
      tmp___43 = if_up(ifp);
      }
#line 721
      if (! tmp___43) {
#line 722
        goto __Cont___6;
      }
#line 723
      if (ifp->flush_timeout.tv_sec != 0L) {
        {
#line 724
        tmp___44 = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& ifp->flush_timeout));
        }
#line 724
        if (tmp___44 >= 0) {
          {
#line 725
          flushbuf(ifp);
          }
        }
      }
      __Cont___6: /* CIL Label */ 
#line 720
      ifp = ifp->next;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 729
    if (debug) {
#line 729
      tmp___45 = 1;
    } else
#line 729
    if (dumping) {
#line 729
      tmp___45 = 1;
    } else {
#line 729
      tmp___45 = 0;
    }
    {
#line 729
    tmp___46 = __builtin_expect((long )tmp___45, 0L);
    }
#line 729
    if (tmp___46) {
      {
#line 730
      dump_tables(stdout);
#line 731
      dumping = (int volatile   )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 735
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 735
    tmp___47 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 735
    if (tmp___47) {
      {
#line 735
      do_debugf(2, "Exiting...\n");
      }
    }
#line 735
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 736
  tmp___48 = roughly(10000);
#line 736
  usleep((__useconds_t )tmp___48);
#line 737
  gettime(& now);
#line 740
  flush_all_routes();
#line 742
  ifp = interfaces;
  }
  {
#line 742
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 742
    if (! ifp) {
#line 742
      goto while_break___18;
    }
    {
#line 743
    tmp___49 = if_up(ifp);
    }
#line 743
    if (! tmp___49) {
#line 744
      goto __Cont___7;
    }
    {
#line 745
    send_wildcard_retraction(ifp);
#line 748
    send_hello_noupdate(ifp, 10U);
#line 749
    flushbuf(ifp);
#line 750
    tmp___50 = roughly(1000);
#line 750
    usleep((__useconds_t )tmp___50);
#line 751
    gettime(& now);
    }
    __Cont___7: /* CIL Label */ 
#line 742
    ifp = ifp->next;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 753
  ifp = interfaces;
  {
#line 753
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 753
    if (! ifp) {
#line 753
      goto while_break___19;
    }
    {
#line 754
    tmp___51 = if_up(ifp);
    }
#line 754
    if (! tmp___51) {
#line 755
      goto __Cont___8;
    }
    {
#line 757
    send_wildcard_retraction(ifp);
#line 758
    send_hello_noupdate(ifp, 1U);
#line 759
    flushbuf(ifp);
#line 760
    tmp___52 = roughly(10000);
#line 760
    usleep((__useconds_t )tmp___52);
#line 761
    gettime(& now);
#line 762
    interface_up(ifp, 0);
    }
    __Cont___8: /* CIL Label */ 
#line 753
    ifp = ifp->next;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 764
  kernel_setup_socket(0);
#line 765
  kernel_setup(0);
#line 767
  fd = open(state_file, 577, 420);
  }
#line 768
  if (fd < 0) {
    {
#line 769
    perror("creat(babel-state)");
#line 770
    unlink(state_file);
    }
  } else {
    {
#line 774
    gettimeofday((struct timeval */* __restrict  */)(& realnow___0), (__timezone_ptr_t )((void *)0));
#line 775
    tmp___53 = format_eui64((unsigned char const   *)(myid));
#line 775
    rc = snprintf((char */* __restrict  */)(buf___6), (size_t )100, (char const   */* __restrict  */)"%s %d %ld\n",
                  tmp___53, (int )myseqno, realnow___0.tv_sec);
    }
#line 778
    if (rc < 0) {
      {
#line 779
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write(babel-state): overflow.\n");
#line 780
      unlink(state_file);
      }
    } else
#line 778
    if (rc >= 100) {
      {
#line 779
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write(babel-state): overflow.\n");
#line 780
      unlink(state_file);
      }
    } else {
      {
#line 782
      tmp___54 = write(fd, (void const   *)(buf___6), (size_t )rc);
#line 782
      rc = (int )tmp___54;
      }
#line 783
      if (rc < 0) {
        {
#line 784
        perror("write(babel-state)");
#line 785
        unlink(state_file);
        }
      }
      {
#line 787
      fsync(fd);
      }
    }
    {
#line 789
    close(fd);
    }
  }
#line 791
  if (pidfile) {
    {
#line 792
    unlink(pidfile);
    }
  }
  {
#line 793
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 793
    tmp___55 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 793
    if (tmp___55) {
      {
#line 793
      do_debugf(2, "Done.\n");
      }
    }
#line 793
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 794
  return (0);
  usage: 
  {
#line 797
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: %s [-m multicast_address] [-p port] [-S state-file]\n                [-h hello] [-H wired_hello] [-z kind[,factor]]\n                [-k metric] [-A metric] [-s] [-l] [-w] [-r] [-u] [-g port]\n                [-t table] [-T table] [-c file] [-C statement]\n                [-d level] [-D] [-L logfile] [-I pidfile]\n                [id] interface...\n",
          *(argv + 0));
#line 811
  exit(1);
  }
  fail: 
#line 814
  ifp = interfaces;
  {
#line 814
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 814
    if (! ifp) {
#line 814
      goto while_break___21;
    }
    {
#line 815
    tmp___56 = if_up(ifp);
    }
#line 815
    if (! tmp___56) {
#line 816
      goto __Cont___9;
    }
    {
#line 817
    interface_up(ifp, 0);
    }
    __Cont___9: /* CIL Label */ 
#line 814
    ifp = ifp->next;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 819
  kernel_setup_socket(0);
#line 820
  kernel_setup(0);
  }
  fail_pid: 
#line 822
  if (pidfile) {
    {
#line 823
    unlink(pidfile);
    }
  }
  {
#line 824
  exit(1);
  }
}
}
#line 827 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int accept_local_connections(fd_set *readfds ) 
{ 
  int rc ;
  int s ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 832
  if (local_server_socket < 0) {
#line 833
    return (0);
  } else
#line 832
  if (! ((readfds->__fds_bits[local_server_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << local_server_socket % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 833
    return (0);
  }
  {
#line 836
  s = accept(local_server_socket, (struct sockaddr */* __restrict  */)((void *)0),
             (socklen_t */* __restrict  */)((void *)0));
  }
#line 838
  if (s < 0) {
    {
#line 839
    tmp = __errno_location();
    }
#line 839
    if (*tmp != 4) {
      {
#line 839
      tmp___0 = __errno_location();
      }
#line 839
      if (*tmp___0 != 11) {
        {
#line 840
        perror("accept(local_server_socket)");
        }
#line 841
        return (-1);
      }
    }
#line 843
    return (0);
  }
#line 846
  if (num_local_sockets >= 4) {
    {
#line 849
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal error: too many local sockets.\n");
#line 850
    close(s);
    }
#line 851
    return (-1);
  }
  {
#line 854
  rc = fcntl(s, 3, 0);
  }
#line 855
  if (rc < 0) {
    {
#line 856
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to get flags of local socket.\n");
#line 857
    close(s);
    }
#line 858
    return (-1);
  }
  {
#line 861
  rc = fcntl(s, 4, rc | 2048);
  }
#line 862
  if (rc < 0) {
    {
#line 863
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to set flags of local socket.\n");
#line 864
    close(s);
    }
#line 865
    return (-1);
  }
  {
#line 868
  tmp___1 = num_local_sockets;
#line 868
  num_local_sockets ++;
#line 868
  local_sockets[tmp___1] = s;
#line 869
  local_notify_all_1(s);
  }
#line 870
  return (1);
}
}
#line 873 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
void schedule_neighbours_check(int msecs , int override ) 
{ 
  struct timeval timeout ;
  int tmp ;

  {
  {
#line 878
  tmp = roughly(msecs);
#line 878
  timeval_add_msec(& timeout, (struct timeval  const  *)(& now), tmp);
  }
#line 879
  if (override) {
#line 880
    check_neighbours_timeout = timeout;
  } else {
    {
#line 882
    timeval_min(& check_neighbours_timeout, (struct timeval  const  *)(& timeout));
    }
  }
#line 883
  return;
}
}
#line 885 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
void schedule_interfaces_check(int msecs , int override ) 
{ 
  struct timeval timeout ;
  int tmp ;

  {
  {
#line 890
  tmp = roughly(msecs);
#line 890
  timeval_add_msec(& timeout, (struct timeval  const  *)(& now), tmp);
  }
#line 891
  if (override) {
#line 892
    check_interfaces_timeout = timeout;
  } else {
    {
#line 894
    timeval_min(& check_interfaces_timeout, (struct timeval  const  *)(& timeout));
    }
  }
#line 895
  return;
}
}
#line 897 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
int resize_receive_buffer(int size ) 
{ 
  void *tmp ;
  unsigned char *new ;
  void *tmp___0 ;

  {
#line 900
  if (size <= receive_buffer_size) {
#line 901
    return (0);
  }
#line 903
  if ((unsigned long )receive_buffer == (unsigned long )((void *)0)) {
    {
#line 904
    tmp = malloc((size_t )size);
#line 904
    receive_buffer = (unsigned char *)tmp;
    }
#line 905
    if ((unsigned long )receive_buffer == (unsigned long )((void *)0)) {
      {
#line 906
      perror("malloc(receive_buffer)");
      }
#line 907
      return (-1);
    }
#line 909
    receive_buffer_size = size;
  } else {
    {
#line 912
    tmp___0 = realloc((void *)receive_buffer, (size_t )size);
#line 912
    new = (unsigned char *)tmp___0;
    }
#line 913
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      {
#line 914
      perror("realloc(receive_buffer)");
      }
#line 915
      return (-1);
    }
#line 917
    receive_buffer = new;
#line 918
    receive_buffer_size = size;
  }
#line 920
  return (1);
}
}
#line 923 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void sigexit(int signo ) 
{ 


  {
#line 926
  exiting = (int volatile   )1;
#line 927
  return;
}
}
#line 929 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void sigdump(int signo ) 
{ 


  {
#line 932
  dumping = (int volatile   )1;
#line 933
  return;
}
}
#line 935 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void sigreopening(int signo ) 
{ 


  {
#line 938
  reopening = (int volatile   )1;
#line 939
  return;
}
}
#line 941 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void init_signals(void) 
{ 
  struct sigaction sa ;
  sigset_t ss ;

  {
  {
#line 947
  sigemptyset(& ss);
#line 948
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 949
  sa.sa_mask = ss;
#line 950
  sa.sa_flags = 0;
#line 951
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 953
  sigemptyset(& ss);
#line 954
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 955
  sa.sa_mask = ss;
#line 956
  sa.sa_flags = 0;
#line 957
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 959
  sigemptyset(& ss);
#line 960
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 961
  sa.sa_mask = ss;
#line 962
  sa.sa_flags = 0;
#line 963
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 965
  sigemptyset(& ss);
#line 966
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 967
  sa.sa_mask = ss;
#line 968
  sa.sa_flags = 0;
#line 969
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 971
  sigemptyset(& ss);
#line 972
  sa.__sigaction_handler.sa_handler = & sigdump;
#line 973
  sa.sa_mask = ss;
#line 974
  sa.sa_flags = 0;
#line 975
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 977
  sigemptyset(& ss);
#line 978
  sa.__sigaction_handler.sa_handler = & sigreopening;
#line 979
  sa.sa_mask = ss;
#line 980
  sa.sa_flags = 0;
#line 981
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 990
  return;
}
}
#line 992 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void dump_route_callback(struct babel_route *route , void *closure ) 
{ 
  FILE *out ;
  unsigned char const   *nexthop ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  char channels[100] ;
  int k ;
  int j ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;

  {
  {
#line 995
  out = (FILE *)closure;
#line 996
  tmp___1 = memcmp((void const   *)(route->nexthop), (void const   *)((route->neigh)->address),
                   (size_t )16);
  }
#line 996
  if (tmp___1 == 0) {
#line 996
    tmp___0 = (unsigned char *)((void *)0);
  } else {
#line 996
    tmp___0 = route->nexthop;
  }
#line 996
  nexthop = (unsigned char const   *)tmp___0;
#line 1001
  if ((int )route->channels[0] == 0) {
#line 1002
    channels[0] = (char )'\000';
  } else {
    {
#line 1004
    j = 0;
#line 1005
    snprintf((char */* __restrict  */)(channels), (size_t )100, (char const   */* __restrict  */)" chan (");
#line 1006
    tmp___2 = strlen((char const   *)(channels));
#line 1006
    j = (int )tmp___2;
#line 1007
    k = 0;
    }
    {
#line 1007
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1007
      if (! (k < 8)) {
#line 1007
        goto while_break;
      }
#line 1008
      if ((int )route->channels[k] == 0) {
#line 1009
        goto while_break;
      }
#line 1010
      if (k > 0) {
#line 1011
        tmp___3 = j;
#line 1011
        j ++;
#line 1011
        channels[tmp___3] = (char )',';
      }
      {
#line 1012
      snprintf((char */* __restrict  */)(channels + j), (size_t )(100 - j), (char const   */* __restrict  */)"%u",
               (unsigned int )route->channels[k]);
#line 1013
      tmp___4 = strlen((char const   *)(channels));
#line 1013
      j = (int )tmp___4;
#line 1007
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1015
    snprintf((char */* __restrict  */)(channels + j), (size_t )(100 - j), (char const   */* __restrict  */)")");
    }
#line 1016
    if (k == 0) {
#line 1017
      channels[0] = (char )'\000';
    }
  }
#line 1020
  if (route->installed) {
#line 1020
    tmp___8 = " (installed)";
  } else {
    {
#line 1020
    tmp___7 = route_feasible(route);
    }
#line 1020
    if (tmp___7) {
#line 1020
      tmp___6 = " (feasible)";
    } else {
#line 1020
      tmp___6 = "";
    }
#line 1020
    tmp___8 = tmp___6;
  }
#line 1020
  if (nexthop) {
    {
#line 1020
    tmp___9 = format_address(nexthop);
#line 1020
    tmp___10 = tmp___9;
    }
  } else {
#line 1020
    tmp___10 = "";
  }
#line 1020
  if (nexthop) {
#line 1020
    tmp___11 = " nexthop ";
  } else {
#line 1020
    tmp___11 = "";
  }
  {
#line 1020
  tmp___12 = format_address((unsigned char const   *)((route->neigh)->address));
#line 1020
  tmp___13 = format_eui64((unsigned char const   *)((route->src)->id));
#line 1020
  tmp___14 = route_smoothed_metric(route);
#line 1020
  tmp___15 = route_metric((struct babel_route  const  *)route);
#line 1020
  tmp___16 = format_prefix((unsigned char const   *)((route->src)->prefix), (route->src)->plen);
#line 1020
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s metric %d (%d) refmetric %d id %s seqno %d%s age %d via %s neigh %s%s%s%s\n",
          tmp___16, tmp___15, tmp___14, (int )route->refmetric, tmp___13, (int )route->seqno,
          channels, (int )(now.tv_sec - route->time), ((route->neigh)->ifp)->name,
          tmp___12, tmp___11, tmp___10, tmp___8);
  }
#line 1034
  return;
}
}
#line 1036 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void dump_xroute_callback(struct xroute *xroute , void *closure ) 
{ 
  FILE *out ;
  char const   *tmp ;

  {
  {
#line 1039
  out = (FILE *)closure;
#line 1040
  tmp = format_prefix((unsigned char const   *)(xroute->prefix), xroute->plen);
#line 1040
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s metric %d (exported)\n",
          tmp, (int )xroute->metric);
  }
#line 1043
  return;
}
}
#line 1045 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static void dump_tables(FILE *out ) 
{ 
  struct neighbour *neigh ;
  char const   *tmp ;
  char const   *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1050
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 1052
  tmp = format_eui64((unsigned char const   *)(myid));
#line 1052
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"My id %s seqno %d\n",
          tmp, (int )myseqno);
#line 1054
  neigh = neighs;
  }
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! neigh) {
#line 1054
      goto while_break;
    }
    {
#line 1055
    tmp___2 = if_up(neigh->ifp);
    }
#line 1055
    if (tmp___2) {
#line 1055
      tmp___1 = "";
    } else {
#line 1055
      tmp___1 = " (down)";
    }
    {
#line 1055
    tmp___3 = neighbour_rxcost(neigh);
#line 1055
    tmp___4 = format_address((unsigned char const   *)(neigh->address));
#line 1055
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Neighbour %s dev %s reach %04x rxcost %d txcost %d chan %d%s.\n",
            tmp___4, (neigh->ifp)->name, (int )neigh->reach, tmp___3, (int )neigh->txcost,
            (neigh->ifp)->channel, tmp___1);
#line 1054
    neigh = neigh->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1064
  for_all_xroutes(& dump_xroute_callback, (void *)out);
#line 1065
  for_all_routes(& dump_route_callback, (void *)out);
#line 1066
  fflush(out);
  }
#line 1067
  return;
}
}
#line 1069 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int reopen_logfile(void) 
{ 
  int lfd ;
  int rc ;

  {
#line 1074
  if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 1075
    return (0);
  }
  {
#line 1077
  lfd = open(logfile, 1089, 420);
  }
#line 1078
  if (lfd < 0) {
#line 1079
    return (-1);
  }
  {
#line 1081
  fflush(stdout);
#line 1082
  fflush(stderr);
#line 1084
  rc = dup2(lfd, 1);
  }
#line 1085
  if (rc < 0) {
#line 1086
    return (-1);
  }
  {
#line 1088
  rc = dup2(lfd, 2);
  }
#line 1089
  if (rc < 0) {
#line 1090
    return (-1);
  }
#line 1092
  if (lfd > 2) {
    {
#line 1093
    close(lfd);
    }
  }
#line 1095
  return (1);
}
}
#line 1098 "/home/june/collector/temp/babeld-1.4.3/babeld.c"
static int kernel_routes_callback(int changed , void *closure ) 
{ 


  {
#line 1101
  if (changed & 1) {
#line 1102
    kernel_link_changed = 1;
  }
#line 1103
  if (changed & (1 << 2)) {
#line 1104
    kernel_addr_changed = 1;
  }
#line 1105
  if (changed & (1 << 1)) {
#line 1106
    kernel_routes_changed = 1;
  }
#line 1107
  return (1);
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 62 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int kernel_route(int operation , unsigned char const   *dest , unsigned short plen ,
                 unsigned char const   *gate , int ifindex , unsigned int metric ,
                 unsigned char const   *newgate , int newifindex , unsigned int newmetric ) ;
#line 47 "/home/june/collector/temp/babeld-1.4.3/route.h"
struct babel_route **routes ;
#line 70
struct babel_route *find_route(unsigned char const   *prefix , unsigned char plen ,
                               struct neighbour *neigh , unsigned char const   *nexthop ) ;
#line 75
void flush_route(struct babel_route *route ) ;
#line 85
int route_old(struct babel_route *route ) ;
#line 86
int route_expired(struct babel_route *route ) ;
#line 88
int update_feasible(struct source *src , unsigned short seqno , unsigned short refmetric ) ;
#line 98
void update_route_metric(struct babel_route *route ) ;
#line 106
void send_unfeasible_request(struct neighbour *neigh , int force , unsigned short seqno ,
                             unsigned short metric , struct source *src ) ;
#line 109
void consider_route(struct babel_route *route ) ;
#line 110
void send_triggered_update(struct babel_route *route , struct source *oldsrc , unsigned int oldmetric ) ;
#line 112
void route_changed(struct babel_route *route , struct source *oldsrc , unsigned short oldmetric ) ;
#line 114
void route_lost(struct source *src , unsigned int oldmetric ) ;
#line 50 "/home/june/collector/temp/babeld-1.4.3/resend.h"
int unsatisfied_request(unsigned char const   *prefix , unsigned char plen , unsigned short seqno ,
                        unsigned char const   *id ) ;
#line 43 "/home/june/collector/temp/babeld-1.4.3/route.c"
struct babel_route **routes  =    (struct babel_route **)((void *)0);
#line 44 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int route_slots  =    0;
#line 44 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int max_route_slots  =    0;
#line 45 "/home/june/collector/temp/babeld-1.4.3/route.c"
int kernel_metric  =    0;
#line 46 "/home/june/collector/temp/babeld-1.4.3/route.c"
int allow_duplicates  =    -1;
#line 47 "/home/june/collector/temp/babeld-1.4.3/route.c"
int diversity_kind  =    0;
#line 48 "/home/june/collector/temp/babeld-1.4.3/route.c"
int diversity_factor  =    256;
#line 49 "/home/june/collector/temp/babeld-1.4.3/route.c"
int keep_unfeasible  =    0;
#line 51 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int smoothing_half_life  =    0;
#line 52 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int two_to_the_one_over_hl  =    0;
#line 58 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int route_compare(unsigned char const   *prefix , unsigned char plen , struct babel_route *route ) 
{ 
  int i___2 ;
  int tmp ;

  {
  {
#line 62
  tmp = memcmp((void const   *)prefix, (void const   *)((route->src)->prefix), (size_t )16);
#line 62
  i___2 = tmp;
  }
#line 63
  if (i___2 != 0) {
#line 64
    return (i___2);
  }
#line 66
  if ((int )plen < (int )(route->src)->plen) {
#line 67
    return (-1);
  } else
#line 68
  if ((int )plen > (int )(route->src)->plen) {
#line 69
    return (1);
  } else {
#line 71
    return (0);
  }
}
}
#line 77 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int find_route_slot(unsigned char const   *prefix , unsigned char plen , int *new_return ) 
{ 
  int p ;
  int m ;
  int g ;
  int c ;

  {
#line 83
  if (route_slots < 1) {
#line 84
    if (new_return) {
#line 85
      *new_return = 0;
    }
#line 86
    return (-1);
  }
#line 89
  p = 0;
#line 89
  g = route_slots - 1;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    m = (p + g) / 2;
#line 93
    c = route_compare(prefix, plen, *(routes + m));
    }
#line 94
    if (c == 0) {
#line 95
      return (m);
    } else
#line 96
    if (c < 0) {
#line 97
      g = m - 1;
    } else {
#line 99
      p = m + 1;
    }
#line 91
    if (! (p <= g)) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (new_return) {
#line 103
    *new_return = p;
  }
#line 105
  return (-1);
}
}
#line 108 "/home/june/collector/temp/babeld-1.4.3/route.c"
struct babel_route *find_route(unsigned char const   *prefix , unsigned char plen ,
                               struct neighbour *neigh , unsigned char const   *nexthop ) 
{ 
  struct babel_route *route ;
  int i___2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 113
  tmp = find_route_slot(prefix, plen, (int *)((void *)0));
#line 113
  i___2 = tmp;
  }
#line 115
  if (i___2 < 0) {
#line 116
    return ((struct babel_route *)((void *)0));
  }
#line 118
  route = *(routes + i___2);
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! route) {
#line 120
      goto while_break;
    }
#line 121
    if ((unsigned long )route->neigh == (unsigned long )neigh) {
      {
#line 121
      tmp___0 = memcmp((void const   *)(route->nexthop), (void const   *)nexthop,
                       (size_t )16);
      }
#line 121
      if (tmp___0 == 0) {
#line 122
        return (route);
      }
    }
#line 123
    route = route->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return ((struct babel_route *)((void *)0));
}
}
#line 129 "/home/june/collector/temp/babeld-1.4.3/route.c"
struct babel_route *find_installed_route(unsigned char const   *prefix , unsigned char plen ) 
{ 
  int i___2 ;
  int tmp ;

  {
  {
#line 132
  tmp = find_route_slot(prefix, plen, (int *)((void *)0));
#line 132
  i___2 = tmp;
  }
#line 134
  if (i___2 >= 0) {
#line 134
    if ((*(routes + i___2))->installed) {
#line 135
      return (*(routes + i___2));
    }
  }
#line 137
  return ((struct babel_route *)((void *)0));
}
}
#line 141 "/home/june/collector/temp/babeld-1.4.3/route.c"
int installed_routes_estimate(void) 
{ 


  {
#line 144
  return (route_slots);
}
}
#line 147 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int resize_route_table(int new_slots ) 
{ 
  struct babel_route **new_routes ;
  void *tmp ;

  {
#line 151
  if (! (new_slots >= route_slots)) {
    {
#line 151
    __assert_fail("new_slots >= route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  151U, "resize_route_table");
    }
  }
#line 153
  if (new_slots == 0) {
    {
#line 154
    new_routes = (struct babel_route **)((void *)0);
#line 155
    free((void *)routes);
    }
  } else {
    {
#line 157
    tmp = realloc((void *)routes, (unsigned long )new_slots * sizeof(struct babel_route *));
#line 157
    new_routes = (struct babel_route **)tmp;
    }
#line 158
    if ((unsigned long )new_routes == (unsigned long )((void *)0)) {
#line 159
      return (-1);
    }
  }
#line 162
  max_route_slots = new_slots;
#line 163
  routes = new_routes;
#line 164
  return (1);
}
}
#line 169 "/home/june/collector/temp/babeld-1.4.3/route.c"
static struct babel_route *insert_route(struct babel_route *route ) 
{ 
  int i___2 ;
  int n ;
  int tmp ;
  struct babel_route *r ;

  {
#line 174
  if (! (! route->installed)) {
    {
#line 174
    __assert_fail("!route->installed", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  174U, "insert_route");
    }
  }
  {
#line 176
  i___2 = find_route_slot((unsigned char const   *)((route->src)->prefix), (route->src)->plen,
                          & n);
  }
#line 178
  if (i___2 < 0) {
#line 179
    if (route_slots >= max_route_slots) {
#line 180
      if (max_route_slots < 1) {
#line 180
        tmp = 8;
      } else {
#line 180
        tmp = 2 * max_route_slots;
      }
      {
#line 180
      resize_route_table(tmp);
      }
    }
#line 181
    if (route_slots >= max_route_slots) {
#line 182
      return ((struct babel_route *)((void *)0));
    }
#line 183
    route->next = (struct babel_route *)((void *)0);
#line 184
    if (n < route_slots) {
      {
#line 185
      memmove((void *)((routes + n) + 1), (void const   *)(routes + n), (unsigned long )(route_slots - n) * sizeof(struct babel_route *));
      }
    }
#line 187
    route_slots ++;
#line 188
    *(routes + n) = route;
  } else {
#line 191
    r = *(routes + i___2);
    {
#line 192
    while (1) {
      while_continue: /* CIL Label */ ;
#line 192
      if (! r->next) {
#line 192
        goto while_break;
      }
#line 193
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 194
    r->next = route;
#line 195
    route->next = (struct babel_route *)((void *)0);
  }
#line 198
  return (route);
}
}
#line 201 "/home/june/collector/temp/babeld-1.4.3/route.c"
void flush_route(struct babel_route *route ) 
{ 
  int i___2 ;
  struct source *src ;
  unsigned int oldmetric ;
  int lost ;
  int tmp ;
  struct babel_route *r ;

  {
  {
#line 207
  lost = 0;
#line 209
  tmp = route_metric((struct babel_route  const  *)route);
#line 209
  oldmetric = (unsigned int )tmp;
#line 210
  src = route->src;
  }
#line 212
  if (route->installed) {
    {
#line 213
    uninstall_route(route);
#line 214
    lost = 1;
    }
  }
  {
#line 217
  i___2 = find_route_slot((unsigned char const   *)((route->src)->prefix), (route->src)->plen,
                          (int *)((void *)0));
  }
#line 218
  if (i___2 >= 0) {
#line 218
    if (! (i___2 < route_slots)) {
      {
#line 218
      __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                    218U, "flush_route");
      }
    }
  } else {
    {
#line 218
    __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  218U, "flush_route");
    }
  }
  {
#line 220
  local_notify_route(route, 0);
  }
#line 222
  if ((unsigned long )route == (unsigned long )*(routes + i___2)) {
    {
#line 223
    *(routes + i___2) = route->next;
#line 224
    route->next = (struct babel_route *)((void *)0);
#line 225
    free((void *)route);
    }
#line 227
    if ((unsigned long )*(routes + i___2) == (unsigned long )((void *)0)) {
#line 228
      if (i___2 < route_slots - 1) {
        {
#line 229
        memmove((void *)(routes + i___2), (void const   *)((routes + i___2) + 1),
                (unsigned long )((route_slots - i___2) - 1) * sizeof(struct babel_route *));
        }
      }
#line 231
      *(routes + (route_slots - 1)) = (struct babel_route *)((void *)0);
#line 232
      route_slots --;
    }
#line 235
    if (route_slots == 0) {
      {
#line 236
      resize_route_table(0);
      }
    } else
#line 237
    if (max_route_slots > 8) {
#line 237
      if (route_slots < max_route_slots / 4) {
        {
#line 238
        resize_route_table(max_route_slots / 2);
        }
      }
    }
  } else {
#line 240
    r = *(routes + i___2);
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! ((unsigned long )r->next != (unsigned long )route)) {
#line 241
        goto while_break;
      }
#line 242
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 243
    r->next = route->next;
#line 244
    route->next = (struct babel_route *)((void *)0);
#line 245
    free((void *)route);
    }
  }
#line 248
  if (lost) {
    {
#line 249
    route_lost(src, oldmetric);
    }
  }
  {
#line 251
  release_source(src);
  }
#line 252
  return;
}
}
#line 254 "/home/june/collector/temp/babeld-1.4.3/route.c"
void flush_all_routes(void) 
{ 
  int i___2 ;

  {
#line 260
  i___2 = route_slots - 1;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i___2 >= 0)) {
#line 261
      goto while_break;
    }
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 262
      if (! (i___2 < route_slots)) {
#line 262
        goto while_break___0;
      }
#line 264
      if ((*(routes + i___2))->installed) {
        {
#line 265
        uninstall_route(*(routes + i___2));
        }
      }
      {
#line 266
      flush_route(*(routes + i___2));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    i___2 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  check_sources_released();
  }
#line 272
  return;
}
}
#line 274 "/home/june/collector/temp/babeld-1.4.3/route.c"
void flush_neighbour_routes(struct neighbour *neigh ) 
{ 
  int i___2 ;
  struct babel_route *r ;

  {
#line 279
  i___2 = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i___2 < route_slots)) {
#line 280
      goto while_break;
    }
#line 282
    r = *(routes + i___2);
    {
#line 283
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 283
      if (! r) {
#line 283
        goto while_break___0;
      }
#line 284
      if ((unsigned long )r->neigh == (unsigned long )neigh) {
        {
#line 285
        flush_route(r);
        }
#line 286
        goto again;
      }
#line 288
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    i___2 ++;
    again: ;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return;
}
}
#line 296 "/home/june/collector/temp/babeld-1.4.3/route.c"
void flush_interface_routes(struct interface *ifp , int v4only ) 
{ 
  int i___2 ;
  struct babel_route *r ;
  int tmp ;

  {
#line 301
  i___2 = 0;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! (i___2 < route_slots)) {
#line 302
      goto while_break;
    }
#line 304
    r = *(routes + i___2);
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      if (! r) {
#line 305
        goto while_break___0;
      }
#line 306
      if ((unsigned long )(r->neigh)->ifp == (unsigned long )ifp) {
#line 306
        if (! v4only) {
          {
#line 308
          flush_route(r);
          }
#line 309
          goto again;
        } else {
          {
#line 306
          tmp = v4mapped((unsigned char const   *)(r->nexthop));
          }
#line 306
          if (tmp) {
            {
#line 308
            flush_route(r);
            }
#line 309
            goto again;
          }
        }
      }
#line 311
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    i___2 ++;
    again: ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 320 "/home/june/collector/temp/babeld-1.4.3/route.c"
void for_all_routes(void (*f)(struct babel_route * , void * ) , void *closure ) 
{ 
  int i___2 ;
  int n ;
  struct babel_route *r ;

  {
#line 323
  n = route_slots;
#line 325
  i___2 = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i___2 < n)) {
#line 325
      goto while_break;
    }
#line 326
    r = *(routes + i___2);
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (! r) {
#line 327
        goto while_break___0;
      }
      {
#line 328
      (*f)(r, closure);
#line 329
      r = r->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return;
}
}
#line 334 "/home/june/collector/temp/babeld-1.4.3/route.c"
void for_all_installed_routes(void (*f)(struct babel_route * , void * ) , void *closure ) 
{ 
  int i___2 ;
  int n ;

  {
#line 337
  n = route_slots;
#line 339
  i___2 = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i___2 < n)) {
#line 339
      goto while_break;
    }
#line 340
    if ((*(routes + i___2))->installed) {
      {
#line 341
      (*f)(*(routes + i___2), closure);
      }
    }
#line 339
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 345 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int metric_to_kernel(int metric ) 
{ 
  int tmp ;

  {
#line 348
  if (metric < 65535) {
#line 348
    tmp = kernel_metric;
  } else {
#line 348
    tmp = 65535;
  }
#line 348
  return (tmp);
}
}
#line 353 "/home/june/collector/temp/babeld-1.4.3/route.c"
static void move_installed_route(struct babel_route *route , int i___2 ) 
{ 
  struct babel_route *r ;

  {
#line 356
  if (i___2 >= 0) {
#line 356
    if (! (i___2 < route_slots)) {
      {
#line 356
      __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                    356U, "move_installed_route");
      }
    }
  } else {
    {
#line 356
    __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  356U, "move_installed_route");
    }
  }
#line 357
  if (! route->installed) {
    {
#line 357
    __assert_fail("route->installed", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  357U, "move_installed_route");
    }
  }
#line 359
  if ((unsigned long )route != (unsigned long )*(routes + i___2)) {
#line 360
    r = *(routes + i___2);
    {
#line 361
    while (1) {
      while_continue: /* CIL Label */ ;
#line 361
      if (! ((unsigned long )r->next != (unsigned long )route)) {
#line 361
        goto while_break;
      }
#line 362
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 363
    r->next = route->next;
#line 364
    route->next = *(routes + i___2);
#line 365
    *(routes + i___2) = route;
  }
#line 367
  return;
}
}
#line 369 "/home/june/collector/temp/babeld-1.4.3/route.c"
void install_route(struct babel_route *route ) 
{ 
  int i___2 ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int save ;
  int *tmp___2 ;

  {
#line 374
  if (route->installed) {
#line 375
    return;
  }
  {
#line 377
  tmp = route_feasible(route);
  }
#line 377
  if (! tmp) {
    {
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: installing unfeasible route (this shouldn\'t happen).");
    }
  }
  {
#line 381
  i___2 = find_route_slot((unsigned char const   *)((route->src)->prefix), (route->src)->plen,
                          (int *)((void *)0));
  }
#line 382
  if (i___2 >= 0) {
#line 382
    if (! (i___2 < route_slots)) {
      {
#line 382
      __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                    382U, "install_route");
      }
    }
  } else {
    {
#line 382
    __assert_fail("i >= 0 && i < route_slots", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  382U, "install_route");
    }
  }
#line 384
  if ((unsigned long )*(routes + i___2) != (unsigned long )route) {
#line 384
    if ((*(routes + i___2))->installed) {
      {
#line 385
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: attempting to install duplicate route (this shouldn\'t happen).");
      }
#line 387
      return;
    }
  }
  {
#line 390
  tmp___0 = route_metric((struct babel_route  const  *)route);
#line 390
  tmp___1 = metric_to_kernel(tmp___0);
#line 390
  rc = kernel_route(1, (unsigned char const   *)((route->src)->prefix), (unsigned short )(route->src)->plen,
                    (unsigned char const   *)(route->nexthop), (int )((route->neigh)->ifp)->ifindex,
                    (unsigned int )tmp___1, (unsigned char const   *)((void *)0),
                    0, 0U);
  }
#line 394
  if (rc < 0) {
    {
#line 395
    tmp___2 = __errno_location();
#line 395
    save = *tmp___2;
#line 396
    perror("kernel_route(ADD)");
    }
#line 397
    if (save != 17) {
#line 398
      return;
    }
  }
  {
#line 400
  route->installed = (short)1;
#line 401
  move_installed_route(route, i___2);
#line 403
  local_notify_route(route, 2);
  }
#line 404
  return;
}
}
#line 406 "/home/june/collector/temp/babeld-1.4.3/route.c"
void uninstall_route(struct babel_route *route ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
#line 411
  if (! route->installed) {
#line 412
    return;
  }
  {
#line 414
  tmp = route_metric((struct babel_route  const  *)route);
#line 414
  tmp___0 = metric_to_kernel(tmp);
#line 414
  rc = kernel_route(0, (unsigned char const   *)((route->src)->prefix), (unsigned short )(route->src)->plen,
                    (unsigned char const   *)(route->nexthop), (int )((route->neigh)->ifp)->ifindex,
                    (unsigned int )tmp___0, (unsigned char const   *)((void *)0),
                    0, 0U);
  }
#line 418
  if (rc < 0) {
    {
#line 419
    perror("kernel_route(FLUSH)");
    }
  }
  {
#line 421
  route->installed = (short)0;
#line 422
  local_notify_route(route, 2);
  }
#line 423
  return;
}
}
#line 429 "/home/june/collector/temp/babeld-1.4.3/route.c"
static void switch_routes(struct babel_route *old , struct babel_route *new ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 434
  if (! old) {
    {
#line 435
    install_route(new);
    }
#line 436
    return;
  }
#line 439
  if (! old->installed) {
#line 440
    return;
  }
  {
#line 442
  tmp = route_feasible(new);
  }
#line 442
  if (! tmp) {
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: switching to unfeasible route (this shouldn\'t happen).");
    }
  }
  {
#line 446
  tmp___0 = route_metric((struct babel_route  const  *)new);
#line 446
  tmp___1 = metric_to_kernel(tmp___0);
#line 446
  tmp___2 = route_metric((struct babel_route  const  *)old);
#line 446
  tmp___3 = metric_to_kernel(tmp___2);
#line 446
  rc = kernel_route(2, (unsigned char const   *)((old->src)->prefix), (unsigned short )(old->src)->plen,
                    (unsigned char const   *)(old->nexthop), (int )((old->neigh)->ifp)->ifindex,
                    (unsigned int )tmp___3, (unsigned char const   *)(new->nexthop),
                    (int )((new->neigh)->ifp)->ifindex, (unsigned int )tmp___1);
  }
#line 451
  if (rc < 0) {
    {
#line 452
    perror("kernel_route(MODIFY)");
    }
#line 453
    return;
  }
  {
#line 456
  old->installed = (short)0;
#line 457
  new->installed = (short)1;
#line 458
  tmp___4 = find_route_slot((unsigned char const   *)((new->src)->prefix), (new->src)->plen,
                            (int *)((void *)0));
#line 458
  move_installed_route(new, tmp___4);
#line 460
  local_notify_route(old, 2);
#line 461
  local_notify_route(new, 2);
  }
#line 462
  return;
}
}
#line 464 "/home/june/collector/temp/babeld-1.4.3/route.c"
static void change_route_metric(struct babel_route *route , unsigned int refmetric ,
                                unsigned int cost , unsigned int add ) 
{ 
  int old ;
  int new ;
  int newmetric ;
  unsigned int tmp ;
  int tmp___0 ;
  int rc ;
  int tmp___1 ;

  {
#line 469
  if ((refmetric + cost) + add <= 65535U) {
#line 469
    tmp = (refmetric + cost) + add;
  } else {
#line 469
    tmp = (unsigned int )((unsigned short )(~ 0));
  }
  {
#line 469
  newmetric = (int )tmp;
#line 471
  tmp___0 = route_metric((struct babel_route  const  *)route);
#line 471
  old = metric_to_kernel(tmp___0);
#line 472
  new = metric_to_kernel(newmetric);
  }
#line 474
  if (route->installed) {
#line 474
    if (old != new) {
      {
#line 476
      rc = kernel_route(2, (unsigned char const   *)((route->src)->prefix), (unsigned short )(route->src)->plen,
                        (unsigned char const   *)(route->nexthop), (int )((route->neigh)->ifp)->ifindex,
                        (unsigned int )old, (unsigned char const   *)(route->nexthop),
                        (int )((route->neigh)->ifp)->ifindex, (unsigned int )new);
      }
#line 481
      if (rc < 0) {
        {
#line 482
        perror("kernel_route(MODIFY metric)");
        }
#line 483
        return;
      }
    }
  }
  {
#line 488
  route_smoothed_metric(route);
#line 490
  route->refmetric = (unsigned short )refmetric;
#line 491
  route->cost = (unsigned short )cost;
#line 492
  route->add_metric = (unsigned short )add;
  }
#line 494
  if (smoothing_half_life == 0) {
    {
#line 495
    tmp___1 = route_metric((struct babel_route  const  *)route);
#line 495
    route->smoothed_metric = (unsigned short )tmp___1;
#line 496
    route->smoothed_metric_time = now.tv_sec;
    }
  }
  {
#line 499
  local_notify_route(route, 2);
  }
#line 500
  return;
}
}
#line 502 "/home/june/collector/temp/babeld-1.4.3/route.c"
static void retract_route(struct babel_route *route ) 
{ 


  {
  {
#line 507
  change_route_metric(route, (unsigned int )((unsigned short )(~ 0)), (unsigned int )((unsigned short )(~ 0)),
                      0U);
  }
#line 508
  return;
}
}
#line 510 "/home/june/collector/temp/babeld-1.4.3/route.c"
int route_feasible(struct babel_route *route ) 
{ 
  int tmp ;

  {
  {
#line 513
  tmp = update_feasible(route->src, route->seqno, route->refmetric);
  }
#line 513
  return (tmp);
}
}
#line 516 "/home/june/collector/temp/babeld-1.4.3/route.c"
int route_old(struct babel_route *route ) 
{ 


  {
#line 519
  return (route->time < now.tv_sec - (__time_t )(((int )route->hold_time * 7) / 8));
}
}
#line 522 "/home/june/collector/temp/babeld-1.4.3/route.c"
int route_expired(struct babel_route *route ) 
{ 


  {
#line 525
  return (route->time < now.tv_sec - (__time_t )route->hold_time);
}
}
#line 528 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int channels_interfere(int ch1 , int ch2 ) 
{ 


  {
#line 531
  if (ch1 == -2) {
#line 532
    return (0);
  } else
#line 531
  if (ch2 == -2) {
#line 532
    return (0);
  }
#line 533
  if (ch1 == 255) {
#line 534
    return (1);
  } else
#line 533
  if (ch2 == 255) {
#line 534
    return (1);
  }
#line 535
  return (ch1 == ch2);
}
}
#line 538 "/home/june/collector/temp/babeld-1.4.3/route.c"
int route_interferes(struct babel_route *route , struct interface *ifp ) 
{ 
  int tmp ;
  int i___2 ;
  int tmp___0 ;

  {
  {
#line 542
  if (diversity_kind == 0) {
#line 542
    goto case_0;
  }
#line 544
  if (diversity_kind == 1) {
#line 544
    goto case_1;
  }
#line 547
  if (diversity_kind == 3) {
#line 547
    goto case_3;
  }
#line 547
  if (diversity_kind == 2) {
#line 547
    goto case_3;
  }
#line 562
  goto switch_default;
  case_0: /* CIL Label */ 
#line 543
  return (1);
  case_1: /* CIL Label */ 
#line 545
  return ((unsigned long )(route->neigh)->ifp == (unsigned long )ifp);
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 548
  if ((unsigned long )(route->neigh)->ifp == (unsigned long )ifp) {
#line 549
    return (1);
  }
  {
#line 550
  tmp = channels_interfere(ifp->channel, ((route->neigh)->ifp)->channel);
  }
#line 550
  if (tmp) {
#line 551
    return (1);
  }
#line 552
  if (diversity_kind == 3) {
#line 554
    i___2 = 0;
    {
#line 554
    while (1) {
      while_continue: /* CIL Label */ ;
#line 554
      if (! (i___2 < 8)) {
#line 554
        goto while_break;
      }
#line 555
      if ((int )route->channels[i___2] == 0) {
#line 556
        goto while_break;
      }
      {
#line 557
      tmp___0 = channels_interfere(ifp->channel, (int )route->channels[i___2]);
      }
#line 557
      if (tmp___0) {
#line 558
        return (1);
      }
#line 554
      i___2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 561
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 563
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown kind of diversity.\n");
  }
#line 564
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/collector/temp/babeld-1.4.3/route.c"
int update_feasible(struct source *src , unsigned short seqno , unsigned short refmetric ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 572
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 573
    return (1);
  }
#line 575
  if (src->time < now.tv_sec - 200L) {
#line 577
    return (1);
  }
#line 579
  if ((int )refmetric >= 65535) {
#line 581
    return (1);
  }
  {
#line 583
  tmp = seqno_compare(seqno, src->seqno);
  }
#line 583
  if (tmp > 0) {
#line 583
    tmp___0 = 1;
  } else
#line 583
  if ((int )src->seqno == (int )seqno) {
#line 583
    if ((int )refmetric < (int )src->metric) {
#line 583
      tmp___0 = 1;
    } else {
#line 583
      tmp___0 = 0;
    }
  } else {
#line 583
    tmp___0 = 0;
  }
#line 583
  return (tmp___0);
}
}
#line 587 "/home/june/collector/temp/babeld-1.4.3/route.c"
void change_smoothing_half_life(int half_life ) 
{ 


  {
#line 590
  if (half_life <= 0) {
#line 591
    smoothing_half_life = 0;
#line 592
    two_to_the_one_over_hl = 0;
#line 593
    return;
  }
#line 596
  smoothing_half_life = half_life;
  {
#line 598
  if (smoothing_half_life == 1) {
#line 598
    goto case_1;
  }
#line 599
  if (smoothing_half_life == 2) {
#line 599
    goto case_2;
  }
#line 600
  if (smoothing_half_life == 3) {
#line 600
    goto case_3;
  }
#line 601
  if (smoothing_half_life == 4) {
#line 601
    goto case_4;
  }
#line 602
  goto switch_default;
  case_1: /* CIL Label */ 
#line 598
  two_to_the_one_over_hl = 131072;
#line 598
  goto switch_break;
  case_2: /* CIL Label */ 
#line 599
  two_to_the_one_over_hl = 92682;
#line 599
  goto switch_break;
  case_3: /* CIL Label */ 
#line 600
  two_to_the_one_over_hl = 82570;
#line 600
  goto switch_break;
  case_4: /* CIL Label */ 
#line 601
  two_to_the_one_over_hl = 77935;
#line 601
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 604
  two_to_the_one_over_hl = 65536 + 45426 / half_life;
  switch_break: /* CIL Label */ ;
  }
#line 606
  return;
}
}
#line 609 "/home/june/collector/temp/babeld-1.4.3/route.c"
int route_smoothed_metric(struct babel_route *route ) 
{ 
  int metric ;
  int tmp ;
  int diff ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 612
  tmp = route_metric((struct babel_route  const  *)route);
#line 612
  metric = tmp;
  }
#line 614
  if (smoothing_half_life <= 0) {
#line 618
    route->smoothed_metric = (unsigned short )metric;
#line 619
    route->smoothed_metric_time = now.tv_sec;
  } else
#line 614
  if (metric >= 65535) {
#line 618
    route->smoothed_metric = (unsigned short )metric;
#line 619
    route->smoothed_metric_time = now.tv_sec;
  } else
#line 614
  if (route->smoothed_metric_time > now.tv_sec) {
#line 618
    route->smoothed_metric = (unsigned short )metric;
#line 619
    route->smoothed_metric_time = now.tv_sec;
  } else
#line 614
  if ((int )route->smoothed_metric == metric) {
#line 618
    route->smoothed_metric = (unsigned short )metric;
#line 619
    route->smoothed_metric_time = now.tv_sec;
  } else {
    {
#line 624
    while (1) {
      while_continue: /* CIL Label */ ;
#line 624
      if (! (route->smoothed_metric_time <= now.tv_sec - (__time_t )smoothing_half_life)) {
#line 624
        goto while_break;
      }
      {
#line 625
      diff = metric - (int )route->smoothed_metric;
#line 626
      tmp___0 = roughly(diff);
#line 626
      route->smoothed_metric = (unsigned short )((int )route->smoothed_metric + tmp___0 / 2);
#line 627
      route->smoothed_metric_time += (time_t )smoothing_half_life;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 629
      if (! (route->smoothed_metric_time < now.tv_sec)) {
#line 629
        goto while_break___0;
      }
      {
#line 630
      diff = metric - (int )route->smoothed_metric;
#line 631
      tmp___1 = roughly(diff);
#line 631
      route->smoothed_metric = (unsigned short )((int )route->smoothed_metric + (tmp___1 * (two_to_the_one_over_hl - 65536)) / 65536);
#line 633
      (route->smoothed_metric_time) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 636
    diff = metric - (int )route->smoothed_metric;
#line 637
    if (diff > -4) {
#line 637
      if (diff < 4) {
#line 638
        route->smoothed_metric = (unsigned short )metric;
      }
    }
  }
#line 642
  if (! (route->smoothed_metric_time == now.tv_sec)) {
    {
#line 642
    __assert_fail("route->smoothed_metric_time == now.tv_sec", "/home/june/collector/temp/babeld-1.4.3/route.c",
                  642U, "route_smoothed_metric");
    }
  }
#line 643
  return ((int )route->smoothed_metric);
}
}
#line 646 "/home/june/collector/temp/babeld-1.4.3/route.c"
static int route_acceptable(struct babel_route *route , int feasible , struct neighbour *exclude ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 650
  tmp = route_expired(route);
  }
#line 650
  if (tmp) {
#line 651
    return (0);
  }
#line 652
  if (feasible) {
    {
#line 652
    tmp___0 = route_feasible(route);
    }
#line 652
    if (! tmp___0) {
#line 653
      return (0);
    }
  }
#line 654
  if (exclude) {
#line 654
    if ((unsigned long )route->neigh == (unsigned long )exclude) {
#line 655
      return (0);
    }
  }
#line 656
  return (1);
}
}
#line 664 "/home/june/collector/temp/babeld-1.4.3/route.c"
struct babel_route *find_best_route(unsigned char const   *prefix , unsigned char plen ,
                                    int feasible , struct neighbour *exclude ) 
{ 
  struct babel_route *route ;
  struct babel_route *r ;
  int i___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 669
  tmp = find_route_slot(prefix, plen, (int *)((void *)0));
#line 669
  i___2 = tmp;
  }
#line 671
  if (i___2 < 0) {
#line 672
    return ((struct babel_route *)((void *)0));
  }
#line 674
  route = *(routes + i___2);
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (route) {
      {
#line 675
      tmp___0 = route_acceptable(route, feasible, exclude);
      }
#line 675
      if (tmp___0) {
#line 675
        goto while_break;
      }
    } else {
#line 675
      goto while_break;
    }
#line 676
    route = route->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (! route) {
#line 679
    return ((struct babel_route *)((void *)0));
  }
#line 681
  r = route->next;
  {
#line 682
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 682
    if (! r) {
#line 682
      goto while_break___0;
    }
    {
#line 683
    tmp___1 = route_acceptable(r, feasible, exclude);
    }
#line 683
    if (tmp___1) {
      {
#line 683
      tmp___2 = route_smoothed_metric(r);
#line 683
      tmp___3 = route_smoothed_metric(route);
      }
#line 683
      if (tmp___2 < tmp___3) {
#line 685
        route = r;
      }
    }
#line 686
    r = r->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 689
  return (route);
}
}
#line 692 "/home/june/collector/temp/babeld-1.4.3/route.c"
void update_route_metric(struct babel_route *route ) 
{ 
  int oldmetric ;
  int tmp ;
  int old_smoothed_metric ;
  int tmp___0 ;
  struct neighbour *neigh ;
  int add_metric ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 695
  tmp = route_metric((struct babel_route  const  *)route);
#line 695
  oldmetric = tmp;
#line 696
  tmp___0 = route_smoothed_metric(route);
#line 696
  old_smoothed_metric = tmp___0;
#line 698
  tmp___5 = route_expired(route);
  }
#line 698
  if (tmp___5) {
#line 699
    if ((int )route->refmetric < 65535) {
      {
#line 700
      route->seqno = seqno_plus((route->src)->seqno, 1);
#line 701
      retract_route(route);
      }
#line 702
      if (oldmetric < 65535) {
        {
#line 703
        route_changed(route, route->src, (unsigned short )oldmetric);
        }
      }
    }
  } else {
    {
#line 706
    neigh = route->neigh;
#line 707
    tmp___1 = input_filter((unsigned char const   *)((route->src)->id), (unsigned char const   *)((route->src)->prefix),
                           (unsigned short )(route->src)->plen, (unsigned char const   *)(neigh->address),
                           (neigh->ifp)->ifindex);
#line 707
    add_metric = tmp___1;
#line 711
    tmp___2 = neighbour_cost(route->neigh);
#line 711
    change_route_metric(route, (unsigned int )route->refmetric, tmp___2, (unsigned int )add_metric);
#line 713
    tmp___3 = route_metric((struct babel_route  const  *)route);
    }
#line 713
    if (tmp___3 != oldmetric) {
      {
#line 715
      route_changed(route, route->src, (unsigned short )oldmetric);
      }
    } else {
      {
#line 713
      tmp___4 = route_smoothed_metric(route);
      }
#line 713
      if (tmp___4 != old_smoothed_metric) {
        {
#line 715
        route_changed(route, route->src, (unsigned short )oldmetric);
        }
      }
    }
  }
#line 717
  return;
}
}
#line 721 "/home/june/collector/temp/babeld-1.4.3/route.c"
void update_neighbour_metric(struct neighbour *neigh , int changed ) 
{ 
  int i___2 ;
  struct babel_route *r ;

  {
#line 725
  if (changed) {
#line 728
    i___2 = 0;
    {
#line 728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 728
      if (! (i___2 < route_slots)) {
#line 728
        goto while_break;
      }
#line 729
      r = *(routes + i___2);
      {
#line 730
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 730
        if (! r) {
#line 730
          goto while_break___0;
        }
#line 731
        if ((unsigned long )r->neigh == (unsigned long )neigh) {
          {
#line 732
          update_route_metric(r);
          }
        }
#line 733
        r = r->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 728
      i___2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 738
  local_notify_neighbour(neigh, 2);
  }
#line 739
  return;
}
}
#line 741 "/home/june/collector/temp/babeld-1.4.3/route.c"
void update_interface_metric(struct interface *ifp ) 
{ 
  int i___2 ;
  struct babel_route *r ;

  {
#line 746
  i___2 = 0;
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! (i___2 < route_slots)) {
#line 746
      goto while_break;
    }
#line 747
    r = *(routes + i___2);
    {
#line 748
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 748
      if (! r) {
#line 748
        goto while_break___0;
      }
#line 749
      if ((unsigned long )(r->neigh)->ifp == (unsigned long )ifp) {
        {
#line 750
        update_route_metric(r);
        }
      }
#line 751
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 746
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return;
}
}
#line 757 "/home/june/collector/temp/babeld-1.4.3/route.c"
struct babel_route *update_route(unsigned char const   *id , unsigned char const   *prefix ,
                                 unsigned char plen , unsigned short seqno , unsigned short refmetric ,
                                 unsigned short interval , struct neighbour *neigh ,
                                 unsigned char const   *nexthop , unsigned char const   *channels ,
                                 int channels_len___0 ) 
{ 
  struct babel_route *route ;
  struct source *src ;
  int metric ;
  int feasible ;
  int add_metric ;
  int hold_time ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  struct source *oldsrc ;
  unsigned short oldmetric ;
  int lost ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct babel_route *new_route ;
  void *tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 769
  if ((4 * (int )interval) / 100 + (int )interval / 50 <= 15) {
#line 769
    tmp = 15;
  } else {
#line 769
    tmp = (4 * (int )interval) / 100 + (int )interval / 50;
  }
  {
#line 769
  hold_time = tmp;
#line 771
  tmp___0 = memcmp((void const   *)id, (void const   *)(myid), (size_t )8);
  }
#line 771
  if (tmp___0 == 0) {
#line 772
    return ((struct babel_route *)((void *)0));
  }
  {
#line 774
  tmp___3 = martian_prefix(prefix, (int )plen);
  }
#line 774
  if (tmp___3) {
    {
#line 775
    tmp___1 = format_address(id);
#line 775
    tmp___2 = format_prefix(prefix, plen);
#line 775
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rejecting martian route to %s through %s.\n",
            tmp___2, tmp___1);
    }
#line 777
    return ((struct babel_route *)((void *)0));
  }
  {
#line 780
  add_metric = input_filter(id, prefix, (unsigned short )plen, (unsigned char const   *)(neigh->address),
                            (neigh->ifp)->ifindex);
  }
#line 782
  if (add_metric >= 65535) {
#line 783
    return ((struct babel_route *)((void *)0));
  }
  {
#line 785
  route = find_route(prefix, plen, neigh, nexthop);
  }
#line 787
  if (route) {
    {
#line 787
    tmp___4 = memcmp((void const   *)((route->src)->id), (void const   *)id, (size_t )8);
    }
#line 787
    if (tmp___4 == 0) {
#line 789
      src = route->src;
    } else {
      {
#line 791
      src = find_source(id, prefix, plen, 1, seqno);
      }
    }
  } else {
    {
#line 791
    src = find_source(id, prefix, plen, 1, seqno);
    }
  }
#line 793
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 794
    return ((struct babel_route *)((void *)0));
  }
  {
#line 796
  feasible = update_feasible(src, seqno, refmetric);
#line 797
  tmp___7 = neighbour_cost(neigh);
  }
#line 797
  if (((unsigned int )((int )refmetric) + tmp___7) + (unsigned int )add_metric <= 65535U) {
    {
#line 797
    tmp___6 = neighbour_cost(neigh);
#line 797
    metric = (int )(((unsigned int )((int )refmetric) + tmp___6) + (unsigned int )add_metric);
    }
  } else {
#line 797
    metric = (int )((unsigned short )(~ 0));
  }
#line 799
  if (route) {
    {
#line 802
    lost = 0;
#line 804
    oldsrc = route->src;
#line 805
    tmp___8 = route_metric((struct babel_route  const  *)route);
#line 805
    oldmetric = (unsigned short )tmp___8;
    }
#line 811
    if (! feasible) {
#line 811
      if (route->installed) {
        {
#line 812
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 812
          tmp___12 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
          }
#line 812
          if (tmp___12) {
            {
#line 812
            tmp___9 = format_address((unsigned char const   *)(src->id));
#line 812
            tmp___10 = format_address((unsigned char const   *)((route->src)->id));
#line 812
            tmp___11 = format_prefix((unsigned char const   *)(src->prefix), src->plen);
#line 812
            do_debugf(2, "Unfeasible update for installed route to %s (%s %d %d -> %s %d %d).\n",
                      tmp___11, tmp___10, (int )route->seqno, (int )route->refmetric,
                      tmp___9, (int )seqno, (int )refmetric);
            }
          }
#line 812
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 818
        if ((unsigned long )src != (unsigned long )route->src) {
          {
#line 819
          uninstall_route(route);
#line 820
          lost = 1;
          }
        }
      }
    }
    {
#line 824
    route->src = retain_source(src);
    }
#line 825
    if (feasible) {
#line 825
      goto _L;
    } else
#line 825
    if (keep_unfeasible) {
      _L: /* CIL Label */ 
#line 825
      if ((int )refmetric < 65535) {
#line 826
        route->time = now.tv_sec;
      }
    }
    {
#line 827
    route->seqno = seqno;
#line 829
    memset((void *)(& route->channels), 0, sizeof(route->channels));
    }
#line 830
    if (channels_len___0 > 0) {
#line 831
      if (channels_len___0 <= 8) {
#line 831
        tmp___13 = channels_len___0;
      } else {
#line 831
        tmp___13 = 8;
      }
      {
#line 831
      memcpy((void */* __restrict  */)(& route->channels), (void const   */* __restrict  */)channels,
             (size_t )tmp___13);
      }
    }
    {
#line 834
    tmp___14 = neighbour_cost(neigh);
#line 834
    change_route_metric(route, (unsigned int )refmetric, tmp___14, (unsigned int )add_metric);
#line 836
    route->hold_time = (unsigned short )hold_time;
#line 838
    route_changed(route, oldsrc, oldmetric);
    }
#line 839
    if (lost) {
      {
#line 840
      route_lost(oldsrc, (unsigned int )oldmetric);
      }
    }
#line 842
    if (! feasible) {
#line 843
      if (route->installed) {
        {
#line 843
        tmp___15 = route_old(route);
        }
#line 843
        if (tmp___15) {
#line 843
          tmp___16 = 1;
        } else {
#line 843
          tmp___16 = 0;
        }
      } else {
#line 843
        tmp___16 = 0;
      }
      {
#line 843
      send_unfeasible_request(neigh, tmp___16, seqno, (unsigned short )metric, src);
      }
    }
    {
#line 845
    release_source(oldsrc);
    }
  } else {
#line 849
    if ((int )refmetric >= 65535) {
#line 851
      return ((struct babel_route *)((void *)0));
    }
#line 852
    if (! feasible) {
      {
#line 853
      send_unfeasible_request(neigh, 0, seqno, (unsigned short )metric, src);
      }
#line 854
      if (! keep_unfeasible) {
#line 855
        return ((struct babel_route *)((void *)0));
      }
    }
    {
#line 858
    tmp___17 = malloc(sizeof(struct babel_route ));
#line 858
    route = (struct babel_route *)tmp___17;
    }
#line 859
    if ((unsigned long )route == (unsigned long )((void *)0)) {
      {
#line 860
      perror("malloc(route)");
      }
#line 861
      return ((struct babel_route *)((void *)0));
    }
    {
#line 864
    route->src = retain_source(src);
#line 865
    route->refmetric = refmetric;
#line 866
    tmp___18 = neighbour_cost(neigh);
#line 866
    route->cost = (unsigned short )tmp___18;
#line 867
    route->add_metric = (unsigned short )add_metric;
#line 868
    route->seqno = seqno;
#line 869
    route->neigh = neigh;
#line 870
    memcpy((void */* __restrict  */)(route->nexthop), (void const   */* __restrict  */)nexthop,
           (size_t )16);
#line 871
    route->time = now.tv_sec;
#line 872
    route->hold_time = (unsigned short )hold_time;
#line 873
    tmp___21 = route_metric((struct babel_route  const  *)route);
    }
#line 873
    if (tmp___21 <= 32767) {
#line 873
      route->smoothed_metric = (unsigned short)32767;
    } else {
      {
#line 873
      tmp___20 = route_metric((struct babel_route  const  *)route);
#line 873
      route->smoothed_metric = (unsigned short )tmp___20;
      }
    }
    {
#line 874
    route->smoothed_metric_time = now.tv_sec;
#line 875
    route->installed = (short)0;
#line 876
    memset((void *)(& route->channels), 0, sizeof(route->channels));
    }
#line 877
    if (channels_len___0 > 0) {
#line 878
      if (channels_len___0 <= 8) {
#line 878
        tmp___22 = channels_len___0;
      } else {
#line 878
        tmp___22 = 8;
      }
      {
#line 878
      memcpy((void */* __restrict  */)(& route->channels), (void const   */* __restrict  */)channels,
             (size_t )tmp___22);
      }
    }
    {
#line 880
    route->next = (struct babel_route *)((void *)0);
#line 881
    new_route = insert_route(route);
    }
#line 882
    if ((unsigned long )new_route == (unsigned long )((void *)0)) {
      {
#line 883
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t insert route.\n");
#line 884
      free((void *)route);
      }
#line 885
      return ((struct babel_route *)((void *)0));
    }
    {
#line 887
    local_notify_route(route, 1);
#line 888
    consider_route(route);
    }
  }
#line 890
  return (route);
}
}
#line 895 "/home/june/collector/temp/babeld-1.4.3/route.c"
void send_unfeasible_request(struct neighbour *neigh , int force , unsigned short seqno ,
                             unsigned short metric , struct source *src ) 
{ 
  struct babel_route *route ;
  struct babel_route *tmp ;
  short tmp___0 ;
  unsigned short tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 900
  tmp = find_installed_route((unsigned char const   *)(src->prefix), src->plen);
#line 900
  route = tmp;
#line 902
  tmp___0 = seqno_minus(src->seqno, seqno);
  }
#line 902
  if ((int )tmp___0 > 100) {
#line 904
    return;
  }
#line 907
  if (force) {
#line 907
    goto _L;
  } else
#line 907
  if (! route) {
#line 907
    goto _L;
  } else {
    {
#line 907
    tmp___3 = route_metric((struct babel_route  const  *)route);
    }
#line 907
    if (tmp___3 >= (int )metric + 512) {
      _L: /* CIL Label */ 
#line 908
      if ((int )src->metric >= 65535) {
#line 908
        tmp___2 = (int )src->seqno;
      } else {
        {
#line 908
        tmp___1 = seqno_plus(src->seqno, 1);
#line 908
        tmp___2 = (int )tmp___1;
        }
      }
      {
#line 908
      send_unicast_multihop_request(neigh, (unsigned char const   *)(src->prefix),
                                    src->plen, (unsigned short )tmp___2, (unsigned char const   *)(src->id),
                                    (unsigned short)127);
      }
    }
  }
#line 914
  return;
}
}
#line 921 "/home/june/collector/temp/babeld-1.4.3/route.c"
void consider_route(struct babel_route *route ) 
{ 
  struct babel_route *installed ;
  struct xroute *xroute ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 927
  if (route->installed) {
#line 928
    return;
  }
  {
#line 930
  tmp = route_feasible(route);
  }
#line 930
  if (! tmp) {
#line 931
    return;
  }
  {
#line 933
  xroute = find_xroute((unsigned char const   *)((route->src)->prefix), (route->src)->plen);
  }
#line 934
  if (xroute) {
#line 934
    if (allow_duplicates < 0) {
#line 935
      return;
    } else
#line 934
    if ((int )xroute->metric >= allow_duplicates) {
#line 935
      return;
    }
  }
  {
#line 937
  installed = find_installed_route((unsigned char const   *)((route->src)->prefix),
                                   (route->src)->plen);
  }
#line 939
  if ((unsigned long )installed == (unsigned long )((void *)0)) {
#line 940
    goto install;
  }
  {
#line 942
  tmp___0 = route_metric((struct babel_route  const  *)route);
  }
#line 942
  if (tmp___0 >= 65535) {
#line 943
    return;
  }
  {
#line 945
  tmp___1 = route_metric((struct babel_route  const  *)installed);
  }
#line 945
  if (tmp___1 >= 65535) {
#line 946
    goto install;
  }
  {
#line 948
  tmp___2 = route_metric((struct babel_route  const  *)installed);
#line 948
  tmp___3 = route_metric((struct babel_route  const  *)route);
  }
#line 948
  if (tmp___2 >= tmp___3) {
    {
#line 948
    tmp___4 = route_smoothed_metric(installed);
#line 948
    tmp___5 = route_smoothed_metric(route);
    }
#line 948
    if (tmp___4 > tmp___5) {
#line 950
      goto install;
    }
  }
#line 952
  return;
  install: 
  {
#line 955
  switch_routes(installed, route);
  }
#line 956
  if (installed) {
#line 956
    if (route->installed) {
      {
#line 957
      tmp___6 = route_metric((struct babel_route  const  *)installed);
#line 957
      send_triggered_update(route, installed->src, (unsigned int )tmp___6);
      }
    } else {
      {
#line 959
      send_update((struct interface *)((void *)0), 1, (unsigned char const   *)((route->src)->prefix),
                  (route->src)->plen);
      }
    }
  } else {
    {
#line 959
    send_update((struct interface *)((void *)0), 1, (unsigned char const   *)((route->src)->prefix),
                (route->src)->plen);
    }
  }
#line 960
  return;
}
}
#line 963 "/home/june/collector/temp/babeld-1.4.3/route.c"
void retract_neighbour_routes(struct neighbour *neigh ) 
{ 
  int i___2 ;
  struct babel_route *r ;
  unsigned short oldmetric ;
  int tmp ;

  {
#line 968
  i___2 = 0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (! (i___2 < route_slots)) {
#line 968
      goto while_break;
    }
#line 969
    r = *(routes + i___2);
    {
#line 970
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 970
      if (! r) {
#line 970
        goto while_break___0;
      }
#line 971
      if ((unsigned long )r->neigh == (unsigned long )neigh) {
#line 972
        if ((int )r->refmetric != 65535) {
          {
#line 973
          tmp = route_metric((struct babel_route  const  *)r);
#line 973
          oldmetric = (unsigned short )tmp;
#line 974
          retract_route(r);
          }
#line 975
          if ((int )oldmetric != 65535) {
            {
#line 976
            route_changed(r, r->src, oldmetric);
            }
          }
        }
      }
#line 979
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 981
    i___2 ++;
#line 968
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  return;
}
}
#line 985 "/home/june/collector/temp/babeld-1.4.3/route.c"
void send_triggered_update(struct babel_route *route , struct source *oldsrc , unsigned int oldmetric ) 
{ 
  unsigned int newmetric ;
  unsigned int diff ;
  int urgent ;
  int tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;
  int tmp___2 ;

  {
#line 993
  if (! route->installed) {
#line 994
    return;
  }
  {
#line 996
  tmp = route_metric((struct babel_route  const  *)route);
#line 996
  newmetric = (unsigned int )tmp;
  }
#line 997
  if (newmetric >= oldmetric) {
#line 997
    diff = newmetric - oldmetric;
  } else {
#line 997
    diff = oldmetric - newmetric;
  }
#line 1000
  if ((unsigned long )route->src != (unsigned long )oldsrc) {
#line 1003
    urgent = 2;
  } else
#line 1000
  if (oldmetric < 65535U) {
#line 1000
    if (newmetric >= 65535U) {
#line 1003
      urgent = 2;
    } else {
#line 1000
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1004
  if (newmetric > oldmetric) {
#line 1004
    if (oldmetric < 1536U) {
#line 1004
      if (diff >= 512U) {
#line 1006
        urgent = 1;
      } else {
#line 1004
        goto _L___2;
      }
    } else {
#line 1004
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 1007
    tmp___0 = unsatisfied_request((unsigned char const   *)((route->src)->prefix),
                                  (route->src)->plen, route->seqno, (unsigned char const   *)((route->src)->id));
    }
#line 1007
    if (tmp___0) {
#line 1010
      urgent = 1;
    } else
#line 1011
    if (oldmetric >= 65535U) {
#line 1011
      if (newmetric < 65535U) {
#line 1013
        urgent = 0;
      } else {
#line 1011
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1014
    if (newmetric < oldmetric) {
#line 1014
      if (diff < 1024U) {
#line 1017
        return;
      } else {
#line 1014
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1018
    if (diff < 384U) {
#line 1020
      return;
    } else {
#line 1022
      urgent = 0;
    }
  }
#line 1024
  if (urgent >= 2) {
    {
#line 1025
    send_update_resend((struct interface *)((void *)0), (unsigned char const   *)((route->src)->prefix),
                       (route->src)->plen);
    }
  } else {
    {
#line 1027
    send_update((struct interface *)((void *)0), urgent, (unsigned char const   *)((route->src)->prefix),
                (route->src)->plen);
    }
  }
#line 1029
  if (oldmetric < 65535U) {
#line 1030
    if (newmetric >= oldmetric + 512U) {
#line 1031
      if ((int )(route->src)->metric >= 65535) {
#line 1031
        tmp___2 = (int )(route->src)->seqno;
      } else {
        {
#line 1031
        tmp___1 = seqno_plus((route->src)->seqno, 1);
#line 1031
        tmp___2 = (int )tmp___1;
        }
      }
      {
#line 1031
      send_request_resend((struct neighbour *)((void *)0), (unsigned char const   *)((route->src)->prefix),
                          (route->src)->plen, (unsigned short )tmp___2, (route->src)->id);
      }
    } else
#line 1036
    if (newmetric >= oldmetric + 288U) {
      {
#line 1037
      send_request((struct interface *)((void *)0), (unsigned char const   *)((route->src)->prefix),
                   (route->src)->plen);
      }
    }
  }
#line 1040
  return;
}
}
#line 1044 "/home/june/collector/temp/babeld-1.4.3/route.c"
void route_changed(struct babel_route *route , struct source *oldsrc , unsigned short oldmetric ) 
{ 
  struct babel_route *better_route ;
  int tmp ;
  int tmp___0 ;

  {
#line 1048
  if (route->installed) {
    {
#line 1051
    better_route = find_best_route((unsigned char const   *)((route->src)->prefix),
                                   (route->src)->plen, 1, (struct neighbour *)((void *)0));
    }
#line 1053
    if (better_route) {
      {
#line 1053
      tmp = route_metric((struct babel_route  const  *)better_route);
#line 1053
      tmp___0 = route_metric((struct babel_route  const  *)route);
      }
#line 1053
      if (tmp < tmp___0) {
        {
#line 1054
        consider_route(better_route);
        }
      }
    }
  }
#line 1057
  if (route->installed) {
    {
#line 1059
    send_triggered_update(route, oldsrc, (unsigned int )oldmetric);
    }
  } else {
    {
#line 1063
    consider_route(route);
    }
  }
#line 1065
  return;
}
}
#line 1068 "/home/june/collector/temp/babeld-1.4.3/route.c"
void route_lost(struct source *src , unsigned int oldmetric ) 
{ 
  struct babel_route *new_route ;
  unsigned short tmp ;
  int tmp___0 ;

  {
  {
#line 1072
  new_route = find_best_route((unsigned char const   *)(src->prefix), src->plen, 1,
                              (struct neighbour *)((void *)0));
  }
#line 1073
  if (new_route) {
    {
#line 1074
    consider_route(new_route);
    }
  } else
#line 1075
  if (oldmetric < 65535U) {
    {
#line 1077
    send_update_resend((struct interface *)((void *)0), (unsigned char const   *)(src->prefix),
                       src->plen);
    }
#line 1081
    if (oldmetric <= 32767U) {
#line 1082
      if ((int )src->metric >= 65535) {
#line 1082
        tmp___0 = (int )src->seqno;
      } else {
        {
#line 1082
        tmp = seqno_plus(src->seqno, 1);
#line 1082
        tmp___0 = (int )tmp;
        }
      }
      {
#line 1082
      send_request_resend((struct neighbour *)((void *)0), (unsigned char const   *)(src->prefix),
                          src->plen, (unsigned short )tmp___0, src->id);
      }
    }
  }
#line 1087
  return;
}
}
#line 1091 "/home/june/collector/temp/babeld-1.4.3/route.c"
void expire_routes(void) 
{ 
  struct babel_route *r ;
  int i___2 ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1097
    tmp = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 1097
    if (tmp) {
      {
#line 1097
      do_debugf(2, "Expiring old routes.\n");
      }
    }
#line 1097
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  i___2 = 0;
  {
#line 1100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1100
    if (! (i___2 < route_slots)) {
#line 1100
      goto while_break___0;
    }
#line 1101
    r = *(routes + i___2);
    {
#line 1102
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1102
      if (! r) {
#line 1102
        goto while_break___1;
      }
#line 1104
      if (r->time > now.tv_sec) {
        {
#line 1105
        flush_route(r);
        }
#line 1106
        goto again;
      } else {
        {
#line 1104
        tmp___0 = route_old(r);
        }
#line 1104
        if (tmp___0) {
          {
#line 1105
          flush_route(r);
          }
#line 1106
          goto again;
        }
      }
      {
#line 1109
      update_route_metric(r);
      }
#line 1111
      if (r->installed) {
#line 1111
        if ((int )r->refmetric < 65535) {
          {
#line 1112
          tmp___1 = route_old(r);
          }
#line 1112
          if (tmp___1) {
            {
#line 1114
            send_unicast_request(r->neigh, (unsigned char const   *)((r->src)->prefix),
                                 (r->src)->plen);
            }
          }
        }
      }
#line 1117
      r = r->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1119
    i___2 ++;
    again: ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1123
  return;
}
}
#line 44 "/home/june/collector/temp/babeld-1.4.3/resend.h"
struct resend *find_request(unsigned char const   *prefix , unsigned char plen , struct resend **previous_return ) ;
#line 60
void recompute_resend_time(void) ;
#line 36 "/home/june/collector/temp/babeld-1.4.3/resend.c"
struct timeval resend_time  =    {(__time_t )0, (__suseconds_t )0};
#line 37 "/home/june/collector/temp/babeld-1.4.3/resend.c"
struct resend *to_resend  =    (struct resend *)((void *)0);
#line 39 "/home/june/collector/temp/babeld-1.4.3/resend.c"
static int resend_match(struct resend *resend , int kind , unsigned char const   *prefix ,
                        unsigned char plen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 43
  if ((int )resend->kind == kind) {
#line 43
    if ((int )resend->plen == (int )plen) {
      {
#line 43
      tmp = memcmp((void const   *)(resend->prefix), (void const   *)prefix, (size_t )16);
      }
#line 43
      if (tmp == 0) {
#line 43
        tmp___0 = 1;
      } else {
#line 43
        tmp___0 = 0;
      }
    } else {
#line 43
      tmp___0 = 0;
    }
  } else {
#line 43
    tmp___0 = 0;
  }
#line 43
  return (tmp___0);
}
}
#line 49 "/home/june/collector/temp/babeld-1.4.3/resend.c"
void flush_resends(struct neighbour *neigh ) 
{ 


  {
#line 53
  return;
}
}
#line 55 "/home/june/collector/temp/babeld-1.4.3/resend.c"
static struct resend *find_resend(int kind , unsigned char const   *prefix , unsigned char plen ,
                                  struct resend **previous_return ) 
{ 
  struct resend *current ;
  struct resend *previous___0 ;
  int tmp ;

  {
#line 61
  previous___0 = (struct resend *)((void *)0);
#line 62
  current = to_resend;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! current) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = resend_match(current, kind, prefix, plen);
    }
#line 64
    if (tmp) {
#line 65
      if (previous_return) {
#line 66
        *previous_return = previous___0;
      }
#line 67
      return (current);
    }
#line 69
    previous___0 = current;
#line 70
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return ((struct resend *)((void *)0));
}
}
#line 76 "/home/june/collector/temp/babeld-1.4.3/resend.c"
struct resend *find_request(unsigned char const   *prefix , unsigned char plen , struct resend **previous_return ) 
{ 
  struct resend *tmp ;

  {
  {
#line 80
  tmp = find_resend(1, prefix, plen, previous_return);
  }
#line 80
  return (tmp);
}
}
#line 83 "/home/june/collector/temp/babeld-1.4.3/resend.c"
int record_resend(int kind , unsigned char const   *prefix , unsigned char plen ,
                  unsigned short seqno , unsigned char const   *id , struct interface *ifp ,
                  int delay ) 
{ 
  struct resend *resend ;
  unsigned int ifindex ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  struct timeval timeout ;

  {
#line 89
  if (ifp) {
#line 89
    tmp = ifp->ifindex;
  } else {
#line 89
    tmp = 0U;
  }
#line 89
  ifindex = tmp;
#line 91
  if (kind == 1) {
    {
#line 91
    tmp___0 = input_filter((unsigned char const   *)((void *)0), prefix, (unsigned short )plen,
                           (unsigned char const   *)((void *)0), ifindex);
    }
#line 91
    if (tmp___0 >= 65535) {
#line 95
      return (0);
    } else {
#line 91
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 91
  if (kind == 2) {
    {
#line 91
    tmp___1 = output_filter((unsigned char const   *)((void *)0), prefix, (unsigned short )plen,
                            ifindex);
    }
#line 91
    if (tmp___1 >= 65535) {
#line 95
      return (0);
    }
  }
#line 97
  if (delay >= 65535) {
#line 98
    delay = 65535;
  }
  {
#line 100
  resend = find_resend(kind, prefix, plen, (struct resend **)((void *)0));
  }
#line 101
  if (resend) {
#line 102
    if (resend->delay) {
#line 102
      if (delay) {
#line 103
        if ((int )resend->delay <= delay) {
#line 103
          resend->delay = resend->delay;
        } else {
#line 103
          resend->delay = (unsigned short )delay;
        }
      } else {
#line 102
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 104
    if (delay) {
#line 105
      resend->delay = (unsigned short )delay;
    }
#line 106
    resend->time = now;
#line 107
    resend->max = (unsigned char)3;
#line 108
    if (id) {
      {
#line 108
      tmp___2 = memcmp((void const   *)(resend->id), (void const   *)id, (size_t )8);
      }
#line 108
      if (tmp___2 == 0) {
        {
#line 108
        tmp___3 = seqno_compare(resend->seqno, seqno);
        }
#line 108
        if (tmp___3 > 0) {
#line 110
          return (0);
        }
      }
    }
#line 112
    if (id) {
      {
#line 113
      memcpy((void */* __restrict  */)(resend->id), (void const   */* __restrict  */)id,
             (size_t )8);
      }
    } else {
      {
#line 115
      memset((void *)(resend->id), 0, (size_t )8);
      }
    }
#line 116
    resend->seqno = seqno;
#line 117
    if ((unsigned long )resend->ifp != (unsigned long )ifp) {
#line 118
      resend->ifp = (struct interface *)((void *)0);
    }
  } else {
    {
#line 120
    tmp___4 = malloc(sizeof(struct resend ));
#line 120
    resend = (struct resend *)tmp___4;
    }
#line 121
    if ((unsigned long )resend == (unsigned long )((void *)0)) {
#line 122
      return (-1);
    }
    {
#line 123
    resend->kind = (unsigned char )kind;
#line 124
    resend->max = (unsigned char)3;
#line 125
    resend->delay = (unsigned short )delay;
#line 126
    memcpy((void */* __restrict  */)(resend->prefix), (void const   */* __restrict  */)prefix,
           (size_t )16);
#line 127
    resend->plen = plen;
#line 128
    resend->seqno = seqno;
    }
#line 129
    if (id) {
      {
#line 130
      memcpy((void */* __restrict  */)(resend->id), (void const   */* __restrict  */)id,
             (size_t )8);
      }
    } else {
      {
#line 132
      memset((void *)(resend->id), 0, (size_t )8);
      }
    }
#line 133
    resend->ifp = ifp;
#line 134
    resend->time = now;
#line 135
    resend->next = to_resend;
#line 136
    to_resend = resend;
  }
#line 139
  if (resend->delay) {
    {
#line 141
    timeval_add_msec(& timeout, (struct timeval  const  *)(& resend->time), (int )resend->delay);
#line 142
    timeval_min(& resend_time, (struct timeval  const  *)(& timeout));
    }
  }
#line 144
  return (1);
}
}
#line 147 "/home/june/collector/temp/babeld-1.4.3/resend.c"
static int resend_expired(struct resend *resend ) 
{ 
  unsigned int tmp ;

  {
  {
#line 151
  if ((int )resend->kind == 1) {
#line 151
    goto case_1;
  }
#line 153
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 152
  tmp = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& resend->time));
  }
#line 152
  return (tmp >= 65000U);
  switch_default: /* CIL Label */ 
#line 154
  return ((int )resend->max <= 0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 158 "/home/june/collector/temp/babeld-1.4.3/resend.c"
int unsatisfied_request(unsigned char const   *prefix , unsigned char plen , unsigned short seqno ,
                        unsigned char const   *id ) 
{ 
  struct resend *request ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 164
  request = find_request(prefix, plen, (struct resend **)((void *)0));
  }
#line 165
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 166
    return (0);
  } else {
    {
#line 165
    tmp = resend_expired(request);
    }
#line 165
    if (tmp) {
#line 166
      return (0);
    }
  }
  {
#line 168
  tmp___0 = memcmp((void const   *)(request->id), (void const   *)id, (size_t )8);
  }
#line 168
  if (tmp___0 != 0) {
#line 170
    return (1);
  } else {
    {
#line 168
    tmp___1 = seqno_compare(request->seqno, seqno);
    }
#line 168
    if (tmp___1 <= 0) {
#line 170
      return (1);
    }
  }
#line 172
  return (0);
}
}
#line 176 "/home/june/collector/temp/babeld-1.4.3/resend.c"
int request_redundant(struct interface *ifp , unsigned char const   *prefix , unsigned char plen ,
                      unsigned short seqno , unsigned char const   *id ) 
{ 
  struct resend *request ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 183
  request = find_request(prefix, plen, (struct resend **)((void *)0));
  }
#line 184
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 185
    return (0);
  } else {
    {
#line 184
    tmp = resend_expired(request);
    }
#line 184
    if (tmp) {
#line 185
      return (0);
    }
  }
  {
#line 187
  tmp___0 = memcmp((void const   *)(request->id), (void const   *)id, (size_t )8);
  }
#line 187
  if (tmp___0 == 0) {
    {
#line 187
    tmp___1 = seqno_compare(request->seqno, seqno);
    }
#line 187
    if (tmp___1 > 0) {
#line 189
      return (0);
    }
  }
#line 191
  if ((unsigned long )request->ifp != (unsigned long )((void *)0)) {
#line 191
    if ((unsigned long )request->ifp != (unsigned long )ifp) {
#line 192
      return (0);
    }
  }
#line 194
  if ((int )request->max > 0) {
#line 196
    return (1);
  }
  {
#line 198
  tmp___2 = timeval_minus_msec((struct timeval  const  *)(& now), (struct timeval  const  *)(& request->time));
  }
#line 198
  if (ifp) {
#line 198
    if (ifp->hello_interval <= 1000U) {
#line 198
      tmp___3 = ifp->hello_interval;
    } else {
#line 198
      tmp___3 = 1000U;
    }
#line 198
    tmp___4 = tmp___3;
  } else {
#line 198
    tmp___4 = 1000U;
  }
#line 198
  if (tmp___2 < tmp___4) {
#line 201
    return (1);
  }
#line 203
  return (0);
}
}
#line 206 "/home/june/collector/temp/babeld-1.4.3/resend.c"
int satisfy_request(unsigned char const   *prefix , unsigned char plen , unsigned short seqno ,
                    unsigned char const   *id , struct interface *ifp ) 
{ 
  struct resend *request ;
  struct resend *previous___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 213
  request = find_request(prefix, plen, & previous___0);
  }
#line 214
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 215
    return (0);
  }
#line 217
  if ((unsigned long )ifp != (unsigned long )((void *)0)) {
#line 217
    if ((unsigned long )request->ifp != (unsigned long )ifp) {
#line 218
      return (0);
    }
  }
  {
#line 220
  tmp = memcmp((void const   *)(request->id), (void const   *)id, (size_t )8);
  }
#line 220
  if (tmp != 0) {
    {
#line 224
    request->max = (unsigned char)0;
#line 225
    request->time.tv_sec = (__time_t )0;
#line 226
    recompute_resend_time();
    }
#line 227
    return (1);
  } else {
    {
#line 220
    tmp___0 = seqno_compare(request->seqno, seqno);
    }
#line 220
    if (tmp___0 <= 0) {
      {
#line 224
      request->max = (unsigned char)0;
#line 225
      request->time.tv_sec = (__time_t )0;
#line 226
      recompute_resend_time();
      }
#line 227
      return (1);
    }
  }
#line 230
  return (0);
}
}
#line 233 "/home/june/collector/temp/babeld-1.4.3/resend.c"
void expire_resend(void) 
{ 
  struct resend *current ;
  struct resend *previous___0 ;
  int recompute ;
  int tmp ;

  {
#line 237
  recompute = 0;
#line 239
  previous___0 = (struct resend *)((void *)0);
#line 240
  current = to_resend;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! current) {
#line 241
      goto while_break;
    }
    {
#line 242
    tmp = resend_expired(current);
    }
#line 242
    if (tmp) {
#line 243
      if ((unsigned long )previous___0 == (unsigned long )((void *)0)) {
        {
#line 244
        to_resend = current->next;
#line 245
        free((void *)current);
#line 246
        current = to_resend;
        }
      } else {
        {
#line 248
        previous___0->next = current->next;
#line 249
        free((void *)current);
#line 250
        current = previous___0->next;
        }
      }
#line 252
      recompute = 1;
    } else {
#line 254
      previous___0 = current;
#line 255
      current = current->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if (recompute) {
    {
#line 259
    recompute_resend_time();
    }
  }
#line 260
  return;
}
}
#line 262 "/home/june/collector/temp/babeld-1.4.3/resend.c"
void recompute_resend_time(void) 
{ 
  struct resend *request ;
  struct timeval resend ;
  struct timeval timeout ;
  int tmp ;

  {
#line 266
  resend.tv_sec = (__time_t )0;
#line 266
  resend.tv_usec = (__suseconds_t )0;
#line 268
  request = to_resend;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! request) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = resend_expired(request);
    }
#line 270
    if (! tmp) {
#line 270
      if ((int )request->delay > 0) {
#line 270
        if ((int )request->max > 0) {
          {
#line 272
          timeval_add_msec(& timeout, (struct timeval  const  *)(& request->time),
                           (int )request->delay);
#line 273
          timeval_min(& resend, (struct timeval  const  *)(& timeout));
          }
        }
      }
    }
#line 275
    request = request->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  resend_time = resend;
#line 279
  return;
}
}
#line 281 "/home/june/collector/temp/babeld-1.4.3/resend.c"
void do_resend(void) 
{ 
  struct resend *resend ;
  struct timeval timeout ;
  int tmp ;
  int tmp___0 ;

  {
#line 286
  resend = to_resend;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! resend) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp___0 = resend_expired(resend);
    }
#line 288
    if (! tmp___0) {
#line 288
      if ((int )resend->delay > 0) {
#line 288
        if ((int )resend->max > 0) {
          {
#line 290
          timeval_add_msec(& timeout, (struct timeval  const  *)(& resend->time),
                           (int )resend->delay);
#line 291
          tmp = timeval_compare((struct timeval  const  *)(& now), (struct timeval  const  *)(& timeout));
          }
#line 291
          if (tmp >= 0) {
            {
#line 293
            if ((int )resend->kind == 1) {
#line 293
              goto case_1;
            }
#line 298
            if ((int )resend->kind == 2) {
#line 298
              goto case_2;
            }
#line 302
            goto switch_default;
            case_1: /* CIL Label */ 
            {
#line 294
            send_multihop_request(resend->ifp, (unsigned char const   *)(resend->prefix),
                                  resend->plen, resend->seqno, (unsigned char const   *)(resend->id),
                                  (unsigned short)127);
            }
#line 297
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 299
            send_update(resend->ifp, 1, (unsigned char const   *)(resend->prefix),
                        resend->plen);
            }
#line 301
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 302
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
#line 304
            if (65535 <= (int )resend->delay * 2) {
#line 304
              resend->delay = (unsigned short)65535;
            } else {
#line 304
              resend->delay = (unsigned short )((int )resend->delay * 2);
            }
#line 305
            resend->max = (unsigned char )((int )resend->max - 1);
          }
        }
      }
    }
#line 308
    resend = resend->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  recompute_resend_time();
  }
#line 311
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 49 "/home/june/collector/temp/babeld-1.4.3/kernel.h"
int import_tables[10]  ;
#line 49
int import_table_count ;
#line 101 "/home/june/collector/temp/babeld-1.4.3/util.h"
void v4tov6(unsigned char *dst , unsigned char const   *src ) ;
#line 58 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int export_table  =    -1;
#line 58 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int import_table_count  =    0;
#line 60 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int old_forwarding  =    -1;
#line 61 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int old_ipv4_forwarding  =    -1;
#line 62 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int old_accept_redirects  =    -1;
#line 63 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int old_rp_filter  =    -1;
#line 70 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
struct old_if old_if[20]  ;
#line 71 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int num_old_if  =    0;
#line 73 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int dgram_socket  =    -1;
#line 81 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int if_eui64(char *ifname , int ifindex , unsigned char *eui ) 
{ 
  int s ;
  int rc ;
  struct ifreq ifr ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  unsigned char *mac ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned char *mac___0 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 87
  s = socket(2, 2, 0);
  }
#line 88
  if (s < 0) {
#line 88
    return (-1);
  }
  {
#line 89
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 90
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(ifr.ifr_ifrn.ifrn_name));
#line 91
  rc = ioctl(s, 35111UL, & ifr);
  }
#line 92
  if (rc < 0) {
    {
#line 93
    tmp = __errno_location();
#line 93
    saved_errno = *tmp;
#line 94
    close(s);
#line 95
    tmp___0 = __errno_location();
#line 95
    *tmp___0 = saved_errno;
    }
#line 96
    return (-1);
  }
  {
#line 98
  close(s);
  }
  {
#line 105
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 6) {
#line 105
    goto case_6;
  }
#line 105
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 800) {
#line 105
    goto case_6;
  }
#line 105
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 774) {
#line 105
    goto case_6;
  }
#line 105
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 1) {
#line 105
    goto case_6;
  }
#line 126
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 32) {
#line 126
    goto case_32;
  }
#line 126
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 24) {
#line 126
    goto case_32;
  }
#line 126
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 27) {
#line 126
    goto case_32;
  }
#line 139
  goto switch_default;
  case_6: /* CIL Label */ 
  case_800: /* CIL Label */ 
  case_774: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 109
  mac = (unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data);
#line 111
  tmp___2 = memcmp((void const   *)mac, (void const   *)(zeroes), (size_t )6);
  }
#line 111
  if (tmp___2 == 0) {
    {
#line 113
    tmp___1 = __errno_location();
#line 113
    *tmp___1 = 2;
    }
#line 114
    return (-1);
  } else
#line 111
  if (((int )*(mac + 0) & 1) != 0) {
    {
#line 113
    tmp___1 = __errno_location();
#line 113
    *tmp___1 = 2;
    }
#line 114
    return (-1);
  } else
#line 111
  if (((int )*(mac + 0) & 2) != 0) {
    {
#line 113
    tmp___1 = __errno_location();
#line 113
    *tmp___1 = 2;
    }
#line 114
    return (-1);
  }
  {
#line 116
  memcpy((void */* __restrict  */)eui, (void const   */* __restrict  */)mac, (size_t )3);
#line 117
  *(eui + 3) = (unsigned char)255;
#line 118
  *(eui + 4) = (unsigned char)254;
#line 119
  memcpy((void */* __restrict  */)(eui + 5), (void const   */* __restrict  */)(mac + 3),
         (size_t )3);
#line 120
  *(eui + 0) = (unsigned char )((int )*(eui + 0) ^ 2);
  }
#line 121
  return (1);
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_27: /* CIL Label */ 
  {
#line 128
  mac___0 = (unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data);
#line 129
  tmp___4 = memcmp((void const   *)mac___0, (void const   *)(zeroes), (size_t )8);
  }
#line 129
  if (tmp___4 == 0) {
    {
#line 131
    tmp___3 = __errno_location();
#line 131
    *tmp___3 = 2;
    }
#line 132
    return (-1);
  } else
#line 129
  if (((int )*(mac___0 + 0) & 1) != 0) {
    {
#line 131
    tmp___3 = __errno_location();
#line 131
    *tmp___3 = 2;
    }
#line 132
    return (-1);
  } else
#line 129
  if (((int )*(mac___0 + 0) & 2) != 0) {
    {
#line 131
    tmp___3 = __errno_location();
#line 131
    *tmp___3 = 2;
    }
#line 132
    return (-1);
  }
  {
#line 134
  memcpy((void */* __restrict  */)eui, (void const   */* __restrict  */)mac___0, (size_t )8);
#line 135
  *(eui + 0) = (unsigned char )((int )*(eui + 0) ^ 2);
  }
#line 136
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 140
  tmp___5 = __errno_location();
#line 140
  *tmp___5 = 2;
  }
#line 141
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 145 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int read_proc(char *filename ) 
{ 
  char buf___2[100] ;
  int fd ;
  int rc ;
  ssize_t tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 150
  fd = open((char const   *)filename, 0);
  }
#line 151
  if (fd < 0) {
#line 152
    return (-1);
  }
  {
#line 153
  tmp = read(fd, (void *)(buf___2), (size_t )99);
#line 153
  rc = (int )tmp;
  }
#line 154
  if (rc < 0) {
    {
#line 155
    tmp___0 = __errno_location();
#line 155
    saved_errno = *tmp___0;
#line 156
    close(fd);
#line 157
    tmp___1 = __errno_location();
#line 157
    *tmp___1 = saved_errno;
    }
#line 158
    return (-1);
  }
  {
#line 160
  close(fd);
  }
#line 162
  if (rc == 0) {
#line 163
    return (-1);
  }
  {
#line 165
  buf___2[rc] = (char )'\000';
#line 166
  tmp___2 = atoi((char const   *)(buf___2));
  }
#line 166
  return (tmp___2);
}
}
#line 169 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int write_proc(char *filename , int value ) 
{ 
  char buf___2[100] ;
  int fd ;
  int rc ;
  int n ;
  ssize_t tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 174
  n = snprintf((char */* __restrict  */)(buf___2), (size_t )100, (char const   */* __restrict  */)"%d",
               value);
#line 176
  fd = open((char const   *)filename, 1);
  }
#line 177
  if (fd < 0) {
#line 178
    return (-1);
  }
  {
#line 180
  tmp = write(fd, (void const   *)(buf___2), (size_t )n);
#line 180
  rc = (int )tmp;
  }
#line 181
  if (rc < n) {
    {
#line 182
    tmp___0 = __errno_location();
#line 182
    saved_errno = *tmp___0;
#line 183
    close(fd);
#line 184
    tmp___1 = __errno_location();
#line 184
    *tmp___1 = saved_errno;
    }
#line 185
    return (-1);
  }
  {
#line 188
  close(fd);
  }
#line 189
  return (1);
}
}
#line 199 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static struct netlink nl_command  =    {(unsigned short)0, -1, {(__kernel_sa_family_t )0, (unsigned short)0, 0U, 0U},
    (socklen_t )0};
#line 200 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static struct netlink nl_listen  =    {(unsigned short)0, -1, {(__kernel_sa_family_t )0, (unsigned short)0, 0U, 0U},
    (socklen_t )0};
#line 201 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int nl_setup  =    0;
#line 203 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int netlink_socket(struct netlink *nl , uint32_t groups ) 
{ 
  int rc ;
  time_t tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 208
  nl->sock = socket(16, 3, 0);
  }
#line 209
  if (nl->sock < 0) {
#line 210
    return (-1);
  }
  {
#line 212
  memset((void *)(& nl->sockaddr), 0, sizeof(nl->sockaddr));
#line 213
  nl->sockaddr.nl_family = (__kernel_sa_family_t )16;
#line 214
  nl->sockaddr.nl_groups = groups;
#line 215
  nl->socklen = (socklen_t )sizeof(nl->sockaddr);
#line 217
  tmp = time((time_t *)((void *)0));
#line 217
  nl->seqno = (unsigned short )tmp;
#line 219
  rc = fcntl(nl->sock, 3, 0);
  }
#line 220
  if (rc < 0) {
#line 221
    goto fail;
  }
  {
#line 223
  rc = fcntl(nl->sock, 4, rc | 2048);
  }
#line 224
  if (rc < 0) {
#line 225
    goto fail;
  }
  {
#line 227
  rc = bind(nl->sock, (struct sockaddr  const  *)((struct sockaddr *)(& nl->sockaddr)),
            nl->socklen);
  }
#line 228
  if (rc < 0) {
#line 229
    goto fail;
  }
  {
#line 231
  rc = getsockname(nl->sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& nl->sockaddr)),
                   (socklen_t */* __restrict  */)(& nl->socklen));
  }
#line 232
  if (rc < 0) {
#line 233
    goto fail;
  }
#line 235
  return (0);
  fail: 
  {
#line 239
  tmp___0 = __errno_location();
#line 239
  saved_errno = *tmp___0;
#line 240
  close(nl->sock);
#line 241
  nl->sock = -1;
#line 242
  tmp___1 = __errno_location();
#line 242
  *tmp___1 = saved_errno;
  }
#line 243
  return (-1);
}
}
#line 247 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int netlink_read(struct netlink *nl , struct netlink *nl_ignore , int answer ,
                        int (*fn)(struct nlmsghdr *nh , void *data ) , void *data ) 
{ 
  int err ;
  struct msghdr msg ;
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct nlmsghdr *nh ;
  int len ;
  int interesting ;
  int done ;
  char buf___2[8192] ;
  ssize_t tmp ;
  int rc ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  struct nlmsgerr *err___0 ;
  long tmp___11 ;
  char *tmp___12 ;
  long tmp___13 ;
  int *tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  int *tmp___20 ;

  {
  {
#line 269
  interesting = 0;
#line 270
  done = 0;
#line 274
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 275
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 277
  memset((void *)(& msg), 0, sizeof(msg));
#line 278
  msg.msg_name = (void *)(& nladdr);
#line 279
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 280
  msg.msg_iov = & iov;
#line 281
  msg.msg_iovlen = (size_t )1;
#line 283
  iov.iov_base = (void *)(& buf___2);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    iov.iov_len = sizeof(buf___2);
#line 287
    tmp = recvmsg(nl->sock, & msg, 0);
#line 287
    len = (int )tmp;
    }
#line 289
    if (len < 0) {
      {
#line 289
      tmp___2 = __errno_location();
      }
#line 289
      if (*tmp___2 == 11) {
#line 289
        goto _L;
      } else {
        {
#line 289
        tmp___3 = __errno_location();
        }
#line 289
        if (*tmp___3 == 4) {
          _L: /* CIL Label */ 
          {
#line 291
          rc = wait_for_fd(0, nl->sock, 100);
          }
#line 292
          if (rc <= 0) {
#line 293
            if (rc == 0) {
              {
#line 294
              tmp___0 = __errno_location();
#line 294
              *tmp___0 = 11;
              }
            }
          } else {
            {
#line 296
            tmp___1 = recvmsg(nl->sock, & msg, 0);
#line 296
            len = (int )tmp___1;
            }
          }
        }
      }
    }
#line 300
    if (len < 0) {
      {
#line 301
      perror("netlink_read: recvmsg()");
      }
#line 302
      return (2);
    } else
#line 303
    if (len == 0) {
      {
#line 304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"netlink_read: EOF\n");
      }
#line 305
      goto socket_error;
    } else
#line 306
    if (msg.msg_namelen != nl->socklen) {
      {
#line 307
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"netlink_read: unexpected sender address length (%d)\n",
              msg.msg_namelen);
      }
#line 310
      goto socket_error;
    } else
#line 311
    if (nladdr.nl_pid != 0U) {
      {
#line 312
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 312
        tmp___4 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
        }
#line 312
        if (tmp___4) {
          {
#line 312
          do_debugf(3, "netlink_read: message not sent by kernel.\n");
          }
        }
#line 312
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 313
      return (2);
    }
    {
#line 316
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 316
      tmp___5 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
      }
#line 316
      if (tmp___5) {
        {
#line 316
        do_debugf(3, "Netlink message: ");
        }
      }
#line 316
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 318
    nh = (struct nlmsghdr *)(buf___2);
    {
#line 318
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 318
      if (len >= (int )sizeof(struct nlmsghdr )) {
#line 318
        if ((unsigned long )nh->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 318
          if (! (nh->nlmsg_len <= (__u32 )len)) {
#line 318
            goto while_break___2;
          }
        } else {
#line 318
          goto while_break___2;
        }
      } else {
#line 318
        goto while_break___2;
      }
      {
#line 321
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 321
        tmp___7 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
        }
#line 321
        if (tmp___7) {
#line 321
          if ((int )nh->nlmsg_flags & 2) {
#line 321
            tmp___6 = "[multi] ";
          } else {
#line 321
            tmp___6 = "";
          }
          {
#line 321
          do_debugf(3, "%s", tmp___6);
          }
        }
#line 321
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 322
      if (! answer) {
#line 323
        done = 1;
      }
#line 324
      if (nl_ignore) {
#line 324
        if (nh->nlmsg_pid == nl_ignore->sockaddr.nl_pid) {
          {
#line 325
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 325
            tmp___8 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
            }
#line 325
            if (tmp___8) {
              {
#line 325
              do_debugf(3, "(ignore), ");
              }
            }
#line 325
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 326
          goto __Cont;
        } else {
#line 324
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 327
      if (answer) {
#line 327
        if (nh->nlmsg_pid != nl->sockaddr.nl_pid) {
#line 327
          goto _L___1;
        } else
#line 327
        if (nh->nlmsg_seq != (__u32 )nl->seqno) {
          _L___1: /* CIL Label */ 
          {
#line 329
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 329
            tmp___9 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
            }
#line 329
            if (tmp___9) {
              {
#line 329
              do_debugf(3, "(wrong seqno %d %d /pid %d %d), ", nh->nlmsg_seq, (int )nl->seqno,
                        nh->nlmsg_pid, nl->sockaddr.nl_pid);
              }
            }
#line 329
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 332
          goto __Cont;
        } else {
#line 327
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 333
      if ((int )nh->nlmsg_type == 3) {
        {
#line 334
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 334
          tmp___10 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
          }
#line 334
          if (tmp___10) {
            {
#line 334
            do_debugf(3, "(done)\n");
            }
          }
#line 334
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 335
        done = 1;
#line 336
        goto while_break___2;
      } else
#line 337
      if ((int )nh->nlmsg_type == 2) {
#line 338
        err___0 = (struct nlmsgerr *)((void *)((char *)nh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 339
        if (err___0->error == 0) {
          {
#line 340
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 340
            tmp___11 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
            }
#line 340
            if (tmp___11) {
              {
#line 340
              do_debugf(3, "(ACK)\n");
              }
            }
#line 340
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 341
          return (0);
        } else {
          {
#line 343
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 343
            tmp___13 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
            }
#line 343
            if (tmp___13) {
              {
#line 343
              tmp___12 = strerror(- err___0->error);
#line 343
              do_debugf(3, "netlink_read: %s\n", tmp___12);
              }
            }
#line 343
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 344
          tmp___14 = __errno_location();
#line 344
          *tmp___14 = - err___0->error;
          }
#line 345
          return (-1);
        }
      } else
#line 347
      if (fn) {
        {
#line 348
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 348
          tmp___15 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
          }
#line 348
          if (tmp___15) {
            {
#line 348
            do_debugf(3, "(msg -> \"");
            }
          }
#line 348
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 349
        err = (*fn)(nh, data);
        }
        {
#line 350
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 350
          tmp___16 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
          }
#line 350
          if (tmp___16) {
            {
#line 350
            do_debugf(3, "\" %d), ", err);
            }
          }
#line 350
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 351
        if (err < 0) {
#line 351
          return (err);
        }
#line 352
        if (interesting) {
#line 352
          tmp___17 = 1;
        } else
#line 352
        if (err) {
#line 352
          tmp___17 = 1;
        } else {
#line 352
          tmp___17 = 0;
        }
#line 352
        interesting = tmp___17;
#line 353
        goto __Cont;
      }
      {
#line 355
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 355
        tmp___18 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
        }
#line 355
        if (tmp___18) {
          {
#line 355
          do_debugf(3, ", ");
          }
        }
#line 355
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 318
      len = (int )((unsigned int )len - (((nh->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 318
      nh = (struct nlmsghdr *)((char *)nh + (((nh->nlmsg_len + 4U) - 1U) & 4294967292U));
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 357
      tmp___19 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
      }
#line 357
      if (tmp___19) {
        {
#line 357
        do_debugf(3, "\n");
        }
      }
#line 357
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 359
    if (msg.msg_flags & 32) {
      {
#line 360
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"netlink_read: message truncated\n");
      }
    }
#line 285
    if (! (! done)) {
#line 285
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return (interesting);
  socket_error: 
  {
#line 367
  close(nl->sock);
#line 368
  nl->sock = -1;
#line 369
  tmp___20 = __errno_location();
#line 369
  *tmp___20 = 5;
  }
#line 370
  return (-1);
}
}
#line 373 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int netlink_talk(struct nlmsghdr *nh ) 
{ 
  int rc ;
  struct sockaddr_nl nladdr ;
  struct msghdr msg ;
  struct iovec iov ;
  ssize_t tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 382
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 383
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 384
  nladdr.nl_pid = (__u32 )0;
#line 386
  memset((void *)(& msg), 0, sizeof(msg));
#line 387
  msg.msg_name = (void *)(& nladdr);
#line 388
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 389
  msg.msg_iov = & iov;
#line 390
  msg.msg_iovlen = (size_t )1;
#line 392
  iov.iov_base = (void *)nh;
#line 393
  iov.iov_len = (size_t )nh->nlmsg_len;
#line 395
  nh->nlmsg_flags = (__u16 )((int )nh->nlmsg_flags | 4);
#line 396
  nl_command.seqno = (unsigned short )((int )nl_command.seqno + 1);
#line 396
  nh->nlmsg_seq = (__u32 )nl_command.seqno;
#line 398
  tmp = sendmsg(nl_command.sock, (struct msghdr  const  *)(& msg), 0);
#line 398
  rc = (int )tmp;
  }
#line 399
  if (rc < 0) {
    {
#line 399
    tmp___2 = __errno_location();
    }
#line 399
    if (*tmp___2 == 11) {
#line 399
      goto _L;
    } else {
      {
#line 399
      tmp___3 = __errno_location();
      }
#line 399
      if (*tmp___3 == 4) {
        _L: /* CIL Label */ 
        {
#line 400
        rc = wait_for_fd(1, nl_command.sock, 100);
        }
#line 401
        if (rc <= 0) {
#line 402
          if (rc == 0) {
            {
#line 403
            tmp___0 = __errno_location();
#line 403
            *tmp___0 = 11;
            }
          }
        } else {
          {
#line 405
          tmp___1 = sendmsg(nl_command.sock, (struct msghdr  const  *)(& msg), 0);
#line 405
          rc = (int )tmp___1;
          }
        }
      }
    }
  }
#line 409
  if ((__u32 )rc < nh->nlmsg_len) {
    {
#line 410
    tmp___4 = __errno_location();
#line 410
    saved_errno = *tmp___4;
#line 411
    perror("sendmsg");
#line 412
    tmp___5 = __errno_location();
#line 412
    *tmp___5 = saved_errno;
    }
#line 413
    return (-1);
  }
  {
#line 416
  rc = netlink_read(& nl_command, (struct netlink *)((void *)0), 1, (int (*)(struct nlmsghdr *nh ,
                                                                             void *data ))((void *)0),
                    (void *)0);
  }
#line 418
  return (rc);
}
}
#line 421 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int netlink_send_dump(int type , void *data , int len ) 
{ 
  struct sockaddr_nl nladdr ;
  struct msghdr msg ;
  struct iovec iov[2] ;
  union __anonunion_buf_109 buf___2 ;
  int rc ;
  int *tmp ;
  ssize_t tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 434
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 435
    tmp = __errno_location();
#line 435
    *tmp = 5;
    }
#line 436
    return (-1);
  } else
#line 434
  if (len == 0) {
    {
#line 435
    tmp = __errno_location();
#line 435
    *tmp = 5;
    }
#line 436
    return (-1);
  }
  {
#line 443
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 444
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 446
  memset((void *)(& msg), 0, sizeof(msg));
#line 447
  msg.msg_name = (void *)(& nladdr);
#line 448
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 449
  msg.msg_iov = iov;
#line 450
  msg.msg_iovlen = (size_t )2;
#line 452
  iov[0].iov_base = (void *)(buf___2.raw);
#line 453
  iov[0].iov_len = sizeof(buf___2.raw);
#line 454
  iov[1].iov_base = data;
#line 455
  iov[1].iov_len = (size_t )len;
#line 457
  memset((void *)(buf___2.raw), 0, sizeof(buf___2.raw));
#line 458
  buf___2.nh.nlmsg_flags = (__u16 )769;
#line 459
  buf___2.nh.nlmsg_type = (__u16 )type;
#line 460
  nl_command.seqno = (unsigned short )((int )nl_command.seqno + 1);
#line 460
  buf___2.nh.nlmsg_seq = (__u32 )nl_command.seqno;
#line 461
  buf___2.nh.nlmsg_len = (__u32 )(len + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 463
  tmp___0 = sendmsg(nl_command.sock, (struct msghdr  const  *)(& msg), 0);
#line 463
  rc = (int )tmp___0;
  }
#line 464
  if ((__u32 )rc < buf___2.nh.nlmsg_len) {
    {
#line 465
    tmp___1 = __errno_location();
#line 465
    saved_errno = *tmp___1;
#line 466
    perror("sendmsg");
#line 467
    tmp___2 = __errno_location();
#line 467
    *tmp___2 = saved_errno;
    }
#line 468
    return (-1);
  }
#line 471
  return (0);
}
}
#line 474 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_setup(int setup ) 
{ 
  int rc ;
  int tmp ;

  {
#line 479
  if (setup) {
#line 480
    if (export_table < 0) {
#line 481
      export_table = 254;
    }
#line 483
    if (import_table_count < 1) {
#line 484
      tmp = import_table_count;
#line 484
      import_table_count ++;
#line 484
      import_tables[tmp] = 254;
    }
    {
#line 486
    dgram_socket = socket(2, 2, 0);
    }
#line 487
    if (dgram_socket < 0) {
#line 488
      return (-1);
    }
    {
#line 490
    rc = netlink_socket(& nl_command, (uint32_t )0);
    }
#line 491
    if (rc < 0) {
      {
#line 492
      perror("netlink_socket(0)");
      }
#line 493
      return (-1);
    }
    {
#line 495
    nl_setup = 1;
#line 497
    old_forwarding = read_proc((char *)"/proc/sys/net/ipv6/conf/all/forwarding");
    }
#line 498
    if (old_forwarding < 0) {
      {
#line 499
      perror("Couldn\'t read forwarding knob.");
      }
#line 500
      return (-1);
    }
    {
#line 503
    rc = write_proc((char *)"/proc/sys/net/ipv6/conf/all/forwarding", 1);
    }
#line 504
    if (rc < 0) {
      {
#line 505
      perror("Couldn\'t write forwarding knob.");
      }
#line 506
      return (-1);
    }
    {
#line 509
    old_ipv4_forwarding = read_proc((char *)"/proc/sys/net/ipv4/conf/all/forwarding");
    }
#line 511
    if (old_ipv4_forwarding < 0) {
      {
#line 512
      perror("Couldn\'t read IPv4 forwarding knob.");
      }
#line 513
      return (-1);
    }
    {
#line 516
    rc = write_proc((char *)"/proc/sys/net/ipv4/conf/all/forwarding", 1);
    }
#line 517
    if (rc < 0) {
      {
#line 518
      perror("Couldn\'t write IPv4 forwarding knob.");
      }
#line 519
      return (-1);
    }
    {
#line 523
    old_accept_redirects = read_proc((char *)"/proc/sys/net/ipv6/conf/all/accept_redirects");
    }
#line 525
    if (old_accept_redirects < 0) {
      {
#line 526
      perror("Couldn\'t read accept_redirects knob.");
      }
#line 527
      return (-1);
    }
    {
#line 530
    rc = write_proc((char *)"/proc/sys/net/ipv6/conf/all/accept_redirects", 0);
    }
#line 531
    if (rc < 0) {
      {
#line 532
      perror("Couldn\'t write accept_redirects knob.");
      }
#line 533
      return (-1);
    }
    {
#line 536
    old_rp_filter = read_proc((char *)"/proc/sys/net/ipv4/conf/all/rp_filter");
    }
#line 538
    if (old_rp_filter < 0) {
      {
#line 539
      perror("Couldn\'t read rp_filter knob.");
      }
#line 540
      return (-1);
    }
    {
#line 543
    rc = write_proc((char *)"/proc/sys/net/ipv4/conf/all/rp_filter", 0);
    }
#line 544
    if (rc < 0) {
      {
#line 545
      perror("Couldn\'t write rp_filter knob.");
      }
#line 546
      return (-1);
    }
#line 549
    return (1);
  } else {
    {
#line 551
    close(dgram_socket);
#line 552
    dgram_socket = -1;
    }
#line 554
    if (old_forwarding >= 0) {
      {
#line 555
      rc = write_proc((char *)"/proc/sys/net/ipv6/conf/all/forwarding", old_forwarding);
      }
#line 557
      if (rc < 0) {
        {
#line 558
        perror("Couldn\'t write forwarding knob.\n");
        }
#line 559
        return (-1);
      }
    }
#line 563
    if (old_ipv4_forwarding >= 0) {
      {
#line 564
      rc = write_proc((char *)"/proc/sys/net/ipv4/conf/all/forwarding", old_ipv4_forwarding);
      }
#line 566
      if (rc < 0) {
        {
#line 567
        perror("Couldn\'t write IPv4 forwarding knob.\n");
        }
#line 568
        return (-1);
      }
    }
#line 572
    if (old_accept_redirects >= 0) {
      {
#line 573
      rc = write_proc((char *)"/proc/sys/net/ipv6/conf/all/accept_redirects", old_accept_redirects);
      }
#line 575
      if (rc < 0) {
        {
#line 576
        perror("Couldn\'t write accept_redirects knob.\n");
        }
#line 577
        return (-1);
      }
    }
#line 581
    if (old_rp_filter >= 0) {
      {
#line 582
      rc = write_proc((char *)"/proc/sys/net/ipv4/conf/all/rp_filter", old_rp_filter);
      }
#line 584
      if (rc < 0) {
        {
#line 585
        perror("Couldn\'t write rp_filter knob.\n");
        }
#line 586
        return (-1);
      }
    }
    {
#line 590
    close(nl_command.sock);
#line 591
    nl_command.sock = -1;
#line 593
    nl_setup = 0;
    }
#line 594
    return (1);
  }
}
}
#line 599 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_setup_socket(int setup ) 
{ 
  int rc ;

  {
#line 604
  if (setup) {
    {
#line 605
    rc = netlink_socket(& nl_listen, (uint32_t )1361);
    }
#line 608
    if (rc < 0) {
      {
#line 609
      perror("netlink_socket(RTMGRP_ROUTE | RTMGRP_LINK | RTMGRP_IFADDR)");
#line 610
      kernel_socket = -1;
      }
#line 611
      return (-1);
    }
#line 614
    kernel_socket = nl_listen.sock;
#line 616
    return (1);
  } else {
    {
#line 620
    close(nl_listen.sock);
#line 621
    nl_listen.sock = -1;
#line 622
    kernel_socket = -1;
    }
#line 624
    return (1);
  }
}
}
#line 629 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int get_old_if(char const   *ifname ) 
{ 
  int i___2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 633
  i___2 = 0;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! (i___2 < num_old_if)) {
#line 633
      goto while_break;
    }
    {
#line 634
    tmp = strcmp((char const   *)old_if[i___2].ifname, ifname);
    }
#line 634
    if (tmp == 0) {
#line 635
      return (i___2);
    }
#line 633
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (num_old_if >= 20) {
#line 637
    return (-1);
  }
  {
#line 638
  old_if[num_old_if].ifname = strdup(ifname);
  }
#line 639
  if ((unsigned long )old_if[num_old_if].ifname == (unsigned long )((void *)0)) {
#line 640
    return (-1);
  }
#line 641
  old_if[num_old_if].rp_filter = -1;
#line 642
  tmp___0 = num_old_if;
#line 642
  num_old_if ++;
#line 642
  return (tmp___0);
}
}
#line 645 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_setup_interface(int setup , char const   *ifname , int ifindex ) 
{ 
  char buf___2[100] ;
  int i___2 ;
  int rc ;

  {
  {
#line 654
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )100, (char const   */* __restrict  */)"/proc/sys/net/ipv4/conf/%s/rp_filter",
                ifname);
  }
#line 655
  if (rc < 0) {
#line 656
    return (-1);
  } else
#line 655
  if (rc >= 100) {
#line 656
    return (-1);
  }
  {
#line 658
  i___2 = get_old_if(ifname);
  }
#line 659
  if (setup) {
#line 660
    if (i___2 >= 0) {
      {
#line 661
      old_if[i___2].rp_filter = read_proc(buf___2);
      }
    }
#line 662
    if (i___2 < 0) {
      {
#line 663
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: cannot save old configuration for %s.\n",
              ifname);
      }
    } else
#line 662
    if (old_if[i___2].rp_filter < 0) {
      {
#line 663
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: cannot save old configuration for %s.\n",
              ifname);
      }
    }
    {
#line 666
    rc = write_proc(buf___2, 0);
    }
#line 667
    if (rc < 0) {
#line 668
      return (-1);
    }
  } else {
#line 670
    if (i___2 >= 0) {
#line 670
      if (old_if[i___2].rp_filter >= 0) {
        {
#line 671
        rc = write_proc(buf___2, old_if[i___2].rp_filter);
        }
      } else {
#line 673
        rc = -1;
      }
    } else {
#line 673
      rc = -1;
    }
#line 675
    if (rc < 0) {
      {
#line 676
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: cannot restore old configuration for %s.\n",
              ifname);
      }
    }
  }
#line 681
  return (1);
}
}
#line 684 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_interface_operational(char const   *ifname , int ifindex ) 
{ 
  struct ifreq req ;
  int rc ;
  int flags ;
  int tmp ;

  {
#line 689
  if (link_detect) {
#line 689
    tmp = 65;
  } else {
#line 689
    tmp = 1;
  }
  {
#line 689
  flags = tmp;
#line 691
  memset((void *)(& req), 0, sizeof(req));
#line 692
  strncpy((char */* __restrict  */)(req.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(req.ifr_ifrn.ifrn_name));
#line 693
  rc = ioctl(dgram_socket, 35091UL, & req);
  }
#line 694
  if (rc < 0) {
#line 695
    return (-1);
  }
#line 696
  return (((int )req.ifr_ifru.ifru_flags & flags) == flags);
}
}
#line 699 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_interface_ipv4(char const   *ifname , int ifindex , unsigned char *addr_r ) 
{ 
  struct ifreq req ;
  int rc ;

  {
  {
#line 705
  memset((void *)(& req), 0, sizeof(req));
#line 706
  strncpy((char */* __restrict  */)(req.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(req.ifr_ifrn.ifrn_name));
#line 707
  req.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 708
  rc = ioctl(dgram_socket, 35093UL, & req);
  }
#line 709
  if (rc < 0) {
#line 710
    return (-1);
  }
  {
#line 712
  memcpy((void */* __restrict  */)addr_r, (void const   */* __restrict  */)(& ((struct sockaddr_in *)(& req.ifr_ifru.ifru_addr))->sin_addr),
         (size_t )4);
  }
#line 713
  return (1);
}
}
#line 716 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_interface_mtu(char const   *ifname , int ifindex ) 
{ 
  struct ifreq req ;
  int rc ;

  {
  {
#line 722
  memset((void *)(& req), 0, sizeof(req));
#line 723
  strncpy((char */* __restrict  */)(req.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(req.ifr_ifrn.ifrn_name));
#line 724
  rc = ioctl(dgram_socket, 35105UL, & req);
  }
#line 725
  if (rc < 0) {
#line 726
    return (-1);
  }
#line 728
  return (req.ifr_ifru.ifru_mtu);
}
}
#line 731 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int isbridge(char const   *ifname , int ifindex ) 
{ 
  char buf___2[256] ;
  int rc ;
  int i___2 ;
  unsigned long args[3] ;
  int indices[256] ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 739
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )256, (char const   */* __restrict  */)"/sys/class/net/%s",
                ifname);
  }
#line 740
  if (rc < 0) {
#line 741
    goto fallback;
  } else
#line 740
  if (rc >= 256) {
#line 741
    goto fallback;
  }
  {
#line 743
  tmp = access((char const   *)(buf___2), 4);
  }
#line 743
  if (tmp < 0) {
#line 744
    goto fallback;
  }
  {
#line 746
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )256, (char const   */* __restrict  */)"/sys/class/net/%s/bridge",
                ifname);
  }
#line 747
  if (rc < 0) {
#line 748
    goto fallback;
  } else
#line 747
  if (rc >= 256) {
#line 748
    goto fallback;
  }
  {
#line 750
  tmp___1 = access((char const   *)(buf___2), 0);
  }
#line 750
  if (tmp___1 >= 0) {
#line 751
    return (1);
  } else {
    {
#line 752
    tmp___0 = __errno_location();
    }
#line 752
    if (*tmp___0 == 2) {
#line 753
      return (0);
    }
  }
  fallback: 
  {
#line 756
  args[0] = 1UL;
#line 757
  args[1] = (unsigned long )(indices);
#line 758
  args[2] = 256UL;
#line 760
  rc = ioctl(dgram_socket, 35136UL, args);
  }
#line 761
  if (rc < 0) {
    {
#line 762
    tmp___2 = __errno_location();
    }
#line 762
    if (*tmp___2 == 65) {
#line 763
      return (0);
    } else {
#line 765
      return (-1);
    }
  }
#line 768
  i___2 = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (i___2 < rc)) {
#line 768
      goto while_break;
    }
#line 769
    if (indices[i___2] == ifindex) {
#line 770
      return (1);
    }
#line 768
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  return (0);
}
}
#line 776 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int isbatman(char const   *ifname , int ifindex ) 
{ 
  char buf___2[256] ;
  int rc ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 782
  rc = snprintf((char */* __restrict  */)(buf___2), (size_t )256, (char const   */* __restrict  */)"/sys/devices/virtual/net/%s/mesh",
                ifname);
  }
#line 783
  if (rc < 0) {
#line 784
    return (-1);
  } else
#line 783
  if (rc >= 256) {
#line 784
    return (-1);
  }
  {
#line 786
  tmp = access((char const   *)(buf___2), 0);
  }
#line 786
  if (tmp >= 0) {
#line 787
    return (1);
  }
  {
#line 789
  tmp___0 = __errno_location();
  }
#line 789
  if (*tmp___0 != 2) {
#line 790
    return (-1);
  }
#line 792
  return (0);
}
}
#line 795 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_interface_wireless(char const   *ifname , int ifindex ) 
{ 
  struct ifreq req ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 804
  tmp = isbridge(ifname, ifindex);
  }
#line 804
  if (tmp != 0) {
#line 805
    return (-1);
  } else {
    {
#line 804
    tmp___0 = isbatman(ifname, ifindex);
    }
#line 804
    if (tmp___0 != 0) {
#line 805
      return (-1);
    }
  }
  {
#line 807
  memset((void *)(& req), 0, sizeof(req));
#line 808
  strncpy((char */* __restrict  */)(req.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(req.ifr_ifrn.ifrn_name));
#line 809
  rc = ioctl(dgram_socket, 35585UL, & req);
  }
#line 810
  if (rc < 0) {
    {
#line 811
    tmp___1 = __errno_location();
    }
#line 811
    if (*tmp___1 == 95) {
#line 812
      rc = 0;
    } else {
      {
#line 811
      tmp___2 = __errno_location();
      }
#line 811
      if (*tmp___2 == 22) {
#line 812
        rc = 0;
      } else {
        {
#line 814
        perror("ioctl(SIOCGIWNAME)");
#line 815
        rc = -1;
        }
      }
    }
  } else {
#line 818
    rc = 1;
  }
#line 820
  return (rc);
}
}
#line 845 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int freq_to_chan(struct iw_freq *freq ) 
{ 
  int m ;
  int e ;
  int mega ;
  int step ;
  int c ;
  int i___2 ;
  int *tmp ;

  {
#line 848
  m = freq->m;
#line 848
  e = (int )freq->e;
#line 851
  if (e == 0) {
#line 851
    if (m > 0) {
#line 851
      if (m < 254) {
#line 852
        return (m);
      }
    }
  }
#line 854
  if (e <= 6) {
#line 858
    mega = 1000000;
#line 859
    i___2 = 0;
    {
#line 859
    while (1) {
      while_continue: /* CIL Label */ ;
#line 859
      if (! (i___2 < e)) {
#line 859
        goto while_break;
      }
#line 860
      mega /= 10;
#line 859
      i___2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 863
    step = 5 * mega;
#line 864
    c = 1 + ((m - 2412 * mega) + step / 2) / step;
#line 865
    if (c >= 1) {
#line 865
      if (c <= 13) {
#line 866
        return (c);
      }
    }
#line 869
    if (c >= 14) {
#line 869
      if (m < 2484 * mega + step / 2) {
#line 870
        return (14);
      }
    }
#line 873
    c = 36 + ((m - 5180 * mega) + step / 2) / step;
#line 874
    if (c >= 34) {
#line 874
      if (c <= 165) {
#line 875
        return (c);
      }
    }
  }
  {
#line 878
  tmp = __errno_location();
#line 878
  *tmp = 2;
  }
#line 879
  return (-1);
}
}
#line 882 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_interface_channel(char const   *ifname , int ifindex ) 
{ 
  struct iwreq_subset iwreq ;
  int rc ;
  int tmp ;

  {
  {
#line 888
  memset((void *)(& iwreq), 0, sizeof(iwreq));
#line 889
  strncpy((char */* __restrict  */)(iwreq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 891
  rc = ioctl(dgram_socket, 35589UL, & iwreq);
  }
#line 892
  if (rc >= 0) {
    {
#line 893
    tmp = freq_to_chan(& iwreq.u.freq);
    }
#line 893
    return (tmp);
  } else {
#line 895
    return (-1);
  }
}
}
#line 898 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_route(int operation , unsigned char const   *dest , unsigned short plen ,
                 unsigned char const   *gate , int ifindex , unsigned int metric ,
                 unsigned char const   *newgate , int newifindex , unsigned int newmetric ) 
{ 
  union __anonunion_buf_112 buf___2 ;
  struct rtmsg *rtm ;
  struct rtattr *rta ;
  int len ;
  int rc ;
  int ipv4 ;
  int *tmp ;
  int olderrno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;

  {
#line 908
  len = (int )sizeof(buf___2.raw);
#line 911
  if (! nl_setup) {
    {
#line 912
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_route: netlink not initialized.\n");
#line 913
    tmp = __errno_location();
#line 913
    *tmp = 5;
    }
#line 914
    return (-1);
  }
#line 919
  if (nl_command.sock < 0) {
    {
#line 920
    rc = netlink_socket(& nl_command, (uint32_t )0);
    }
#line 921
    if (rc < 0) {
      {
#line 922
      tmp___0 = __errno_location();
#line 922
      olderrno = *tmp___0;
#line 923
      perror("kernel_route: netlink_socket()");
#line 924
      tmp___1 = __errno_location();
#line 924
      *tmp___1 = olderrno;
      }
#line 925
      return (-1);
    }
  }
#line 930
  if ((int )plen >= 96) {
    {
#line 930
    tmp___6 = v4mapped(dest);
    }
#line 930
    if (tmp___6) {
      {
#line 931
      tmp___3 = v4mapped(gate);
      }
#line 931
      if (! tmp___3) {
        {
#line 932
        tmp___2 = __errno_location();
#line 932
        *tmp___2 = 22;
        }
#line 933
        return (-1);
      }
    } else {
#line 930
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 936
    tmp___5 = v4mapped(gate);
    }
#line 936
    if (tmp___5) {
      {
#line 937
      tmp___4 = __errno_location();
#line 937
      *tmp___4 = 22;
      }
#line 938
      return (-1);
    }
  }
  {
#line 942
  ipv4 = v4mapped(gate);
  }
#line 944
  if (operation == 2) {
#line 945
    if (newmetric == metric) {
      {
#line 945
      tmp___7 = memcmp((void const   *)newgate, (void const   *)gate, (size_t )16);
      }
#line 945
      if (tmp___7 == 0) {
#line 945
        if (newifindex == ifindex) {
#line 947
          return (0);
        }
      }
    }
    {
#line 954
    kernel_route(0, dest, plen, gate, ifindex, metric, (unsigned char const   *)((void *)0),
                 0, 0U);
#line 957
    rc = kernel_route(1, dest, plen, newgate, newifindex, newmetric, (unsigned char const   *)((void *)0),
                      0, 0U);
    }
#line 960
    if (rc < 0) {
      {
#line 961
      tmp___8 = __errno_location();
      }
#line 961
      if (*tmp___8 == 17) {
#line 962
        rc = 1;
      }
    }
#line 966
    return (rc);
  }
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 969
    tmp___13 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 969
    if (tmp___13) {
      {
#line 969
      tmp___9 = format_address(gate);
#line 969
      tmp___10 = format_address(dest);
      }
#line 969
      if (operation == 1) {
#line 969
        tmp___12 = "add";
      } else {
#line 969
        if (operation == 0) {
#line 969
          tmp___11 = "flush";
        } else {
#line 969
          tmp___11 = "???";
        }
#line 969
        tmp___12 = tmp___11;
      }
      {
#line 969
      do_debugf(3, "kernel_route: %s %s/%d metric %d dev %d nexthop %s\n", tmp___12,
                tmp___10, (int )plen, metric, ifindex, tmp___9);
      }
    }
#line 969
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 977
  if (metric >= 65535U) {
#line 977
    if ((int )plen == 0) {
#line 978
      return (0);
    } else
#line 977
    if (ipv4) {
#line 977
      if ((int )plen == 96) {
#line 978
        return (0);
      }
    }
  }
  {
#line 980
  memset((void *)(buf___2.raw), 0, sizeof(buf___2.raw));
  }
#line 981
  if (operation == 1) {
#line 982
    buf___2.nh.nlmsg_flags = (__u16 )1537;
#line 983
    buf___2.nh.nlmsg_type = (__u16 )24;
  } else {
#line 985
    buf___2.nh.nlmsg_flags = (__u16 )1;
#line 986
    buf___2.nh.nlmsg_type = (__u16 )25;
  }
#line 989
  rtm = (struct rtmsg *)((void *)((char *)(& buf___2.nh) + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 990
  if (ipv4) {
#line 990
    rtm->rtm_family = (unsigned char)2;
  } else {
#line 990
    rtm->rtm_family = (unsigned char)10;
  }
#line 991
  if (ipv4) {
#line 991
    rtm->rtm_dst_len = (unsigned char )((int )plen - 96);
  } else {
#line 991
    rtm->rtm_dst_len = (unsigned char )plen;
  }
#line 992
  rtm->rtm_table = (unsigned char )export_table;
#line 993
  rtm->rtm_scope = (unsigned char)0;
#line 994
  if (metric < 65535U) {
#line 995
    rtm->rtm_type = (unsigned char)1;
  } else {
#line 997
    rtm->rtm_type = (unsigned char)7;
  }
#line 998
  rtm->rtm_protocol = (unsigned char)42;
#line 999
  rtm->rtm_flags |= 4U;
#line 1001
  rta = (struct rtattr *)((char *)rtm + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL));
#line 1003
  if (ipv4) {
    {
#line 1004
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1004
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1005
    rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(struct in_addr ));
#line 1006
    rta->rta_type = (unsigned short)1;
#line 1007
    memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
           (void const   */* __restrict  */)(dest + 12), sizeof(struct in_addr ));
    }
  } else {
    {
#line 1009
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1009
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1010
    rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(struct in6_addr ));
#line 1011
    rta->rta_type = (unsigned short)1;
#line 1012
    memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
           (void const   */* __restrict  */)dest, sizeof(struct in6_addr ));
    }
  }
#line 1015
  len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1015
  rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1016
  rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(int ));
#line 1017
  rta->rta_type = (unsigned short)6;
#line 1019
  if (metric < 65535U) {
#line 1020
    *((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)))) = (int )metric;
#line 1021
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1021
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1022
    rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(int ));
#line 1023
    rta->rta_type = (unsigned short)4;
#line 1024
    *((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)))) = ifindex;
#line 1026
    if (ipv4) {
      {
#line 1027
      len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1027
      rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1028
      rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(struct in_addr ));
#line 1029
      rta->rta_type = (unsigned short)5;
#line 1030
      memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)(gate + 12), sizeof(struct in_addr ));
      }
    } else {
      {
#line 1032
      len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1032
      rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 1033
      rta->rta_len = (unsigned short )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(struct in6_addr ));
#line 1034
      rta->rta_type = (unsigned short)5;
#line 1035
      memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)gate, sizeof(struct in6_addr ));
      }
    }
  } else {
#line 1038
    *((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)))) = -1;
  }
  {
#line 1040
  buf___2.nh.nlmsg_len = (__u32 )(((char *)rta + (int )rta->rta_len) - buf___2.raw);
#line 1042
  tmp___14 = netlink_talk(& buf___2.nh);
  }
#line 1042
  return (tmp___14);
}
}
#line 1045 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int parse_kernel_route_rta(struct rtmsg *rtm , int len , struct kernel_route *route ) 
{ 
  int table ;
  struct rtattr *rta ;
  unsigned char zeroes___0[4] ;
  int i___2 ;

  {
  {
#line 1048
  table = (int )rtm->rtm_table;
#line 1049
  rta = (struct rtattr *)((char *)rtm + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL));
#line 1050
  len = (int )((unsigned long )len - (((sizeof(*rtm) + 4UL) - 1UL) & 4294967292UL));
#line 1052
  memset((void *)(& route->prefix), 0, sizeof(struct in6_addr ));
#line 1053
  memset((void *)(& route->gw), 0, sizeof(struct in6_addr ));
#line 1054
  route->plen = (int )rtm->rtm_dst_len;
  }
#line 1055
  if ((int )rtm->rtm_family == 2) {
    {
#line 1056
    zeroes___0[0] = (unsigned char)0;
#line 1056
    zeroes___0[1] = (unsigned char)0;
#line 1056
    zeroes___0[2] = (unsigned char)0;
#line 1056
    zeroes___0[3] = (unsigned char)0;
#line 1057
    v4tov6(route->prefix, (unsigned char const   *)(zeroes___0));
#line 1058
    route->plen += 96;
    }
  }
#line 1061
  route->metric = 0;
#line 1062
  route->ifindex = 0U;
#line 1063
  route->proto = (int )rtm->rtm_protocol;
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (len >= (int )sizeof(struct rtattr )) {
#line 1075
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 1075
        if (! ((int )rta->rta_len <= len)) {
#line 1075
          goto while_break;
        }
      } else {
#line 1075
        goto while_break;
      }
    } else {
#line 1075
      goto while_break;
    }
    {
#line 1077
    if ((int )rta->rta_type == 1) {
#line 1077
      goto case_1;
    }
#line 1080
    if ((int )rta->rta_type == 5) {
#line 1080
      goto case_5;
    }
#line 1083
    if ((int )rta->rta_type == 4) {
#line 1083
      goto case_4;
    }
#line 1086
    if ((int )rta->rta_type == 6) {
#line 1086
      goto case_6;
    }
#line 1091
    if ((int )rta->rta_type == 15) {
#line 1091
      goto case_15;
    }
#line 1094
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1078
      if ((int )rtm->rtm_family == 10) {
        {
#line 1078
        memcpy((void */* __restrict  */)(route->prefix), (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
               (size_t )16);
        }
      } else
#line 1078
      if ((int )rtm->rtm_family == 2) {
        {
#line 1078
        v4tov6(route->prefix, (unsigned char const   *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
        }
      } else {
#line 1078
        return (-1);
      }
#line 1078
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1079
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1081
      if ((int )rtm->rtm_family == 10) {
        {
#line 1081
        memcpy((void */* __restrict  */)(route->gw), (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
               (size_t )16);
        }
      } else
#line 1081
      if ((int )rtm->rtm_family == 2) {
        {
#line 1081
        v4tov6(route->gw, (unsigned char const   *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
        }
      } else {
#line 1081
        return (-1);
      }
#line 1081
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1082
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1084
    route->ifindex = (unsigned int )*((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 1085
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1087
    route->metric = *((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 1088
    if (route->metric < 0) {
#line 1089
      route->metric = 65535;
    } else
#line 1088
    if (route->metric > 65535) {
#line 1089
      route->metric = 65535;
    }
#line 1090
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1092
    table = *((int *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 1093
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1095
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1097
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1097
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 1102
  i___2 = 0;
  {
#line 1102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1102
    if (! (i___2 < import_table_count)) {
#line 1102
      goto while_break___2;
    }
#line 1103
    if (table == import_tables[i___2]) {
#line 1104
      return (0);
    }
#line 1102
    i___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1105
  return (-1);
}
}
#line 1108 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static void print_kernel_route(int add , int protocol , int type , struct kernel_route *route ) 
{ 
  char ifname[16] ;
  char addr_prefix[46] ;
  char addr_gw[46] ;
  long tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1116
  tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(route->prefix), (char */* __restrict  */)(addr_prefix),
                      (socklen_t )sizeof(addr_prefix));
  }
#line 1116
  if (tmp___0) {
    {
#line 1116
    tmp___1 = inet_ntop(10, (void const   */* __restrict  */)(route->gw), (char */* __restrict  */)(addr_gw),
                        (socklen_t )sizeof(addr_gw));
    }
#line 1116
    if (tmp___1) {
      {
#line 1116
      tmp___2 = if_indextoname(route->ifindex, ifname);
      }
#line 1116
      if (! tmp___2) {
        _L: /* CIL Label */ 
        {
#line 1120
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1120
          tmp = __builtin_expect((long )(! (! (debug >= 3))), 0L);
          }
#line 1120
          if (tmp) {
            {
#line 1120
            do_debugf(3, "Couldn\'t format kernel route for printing.");
            }
          }
#line 1120
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1121
        return;
      }
    } else {
#line 1116
      goto _L;
    }
  } else {
#line 1116
    goto _L;
  }
  {
#line 1124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1124
    tmp___4 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 1124
    if (tmp___4) {
#line 1124
      if (add == 24) {
#line 1124
        tmp___3 = "Add";
      } else {
#line 1124
        tmp___3 = "Delete";
      }
      {
#line 1124
      do_debugf(3, "%s kernel route: dest: %s/%d gw: %s metric: %d if: %s (proto: %d, type: %d)",
                tmp___3, addr_prefix, route->plen, addr_gw, route->metric, ifname,
                protocol, type);
      }
    }
#line 1124
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1129
  return;
}
}
#line 1131 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int filter_kernel_routes(struct nlmsghdr *nh , void *data ) 
{ 
  int rc ;
  struct kernel_route *current_route ;
  struct kernel_route route ;
  int maxroutes___0 ;
  struct kernel_route *routes___0 ;
  int *found ;
  int len ;
  struct rtmsg *rtm ;
  void **args ;
  int tmp ;

  {
#line 1139
  maxroutes___0 = 0;
#line 1140
  routes___0 = (struct kernel_route *)((void *)0);
#line 1141
  found = (int *)((void *)0);
#line 1146
  if (data) {
#line 1147
    args = (void **)data;
#line 1148
    maxroutes___0 = *((int *)*(args + 0));
#line 1149
    routes___0 = (struct kernel_route *)*(args + 1);
#line 1150
    found = (int *)*(args + 2);
  }
#line 1153
  len = (int )nh->nlmsg_len;
#line 1155
  if (data) {
#line 1155
    if (*found >= maxroutes___0) {
#line 1156
      return (0);
    }
  }
#line 1158
  if ((int )nh->nlmsg_type != 24) {
#line 1158
    if (data) {
#line 1160
      return (0);
    } else
#line 1158
    if ((int )nh->nlmsg_type != 25) {
#line 1160
      return (0);
    }
  }
#line 1162
  rtm = (struct rtmsg *)((void *)((char *)nh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 1163
  len -= (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
#line 1165
  if ((int )rtm->rtm_protocol == 42) {
#line 1166
    return (0);
  }
#line 1168
  if ((int )rtm->rtm_src_len != 0) {
#line 1169
    return (0);
  }
#line 1172
  if (rtm->rtm_flags & 512U) {
#line 1173
    return (0);
  }
#line 1175
  if (data) {
#line 1176
    current_route = routes___0 + *found;
  } else {
#line 1178
    current_route = & route;
  }
  {
#line 1180
  rc = parse_kernel_route_rta(rtm, len, current_route);
  }
#line 1181
  if (rc < 0) {
#line 1182
    return (0);
  }
  {
#line 1184
  tmp = martian_prefix((unsigned char const   *)(current_route->prefix), current_route->plen);
  }
#line 1184
  if (tmp) {
#line 1185
    return (0);
  }
#line 1188
  if (current_route->plen == 0) {
#line 1188
    if (current_route->metric >= 65535) {
#line 1189
      return (0);
    }
  }
#line 1191
  if (debug >= 2) {
#line 1192
    if (rc >= 0) {
      {
#line 1193
      print_kernel_route((int )nh->nlmsg_type, (int )rtm->rtm_protocol, (int )rtm->rtm_type,
                         current_route);
      }
    }
  }
#line 1198
  if (data) {
#line 1198
    (*found) ++;
  }
#line 1200
  return (1);
}
}
#line 1205 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_routes(struct kernel_route *routes___0 , int maxroutes___0 ) 
{ 
  int i___2 ;
  int rc ;
  int maxr ;
  int found ;
  void *data[3] ;
  int families[2] ;
  struct rtgenmsg g ;
  int *tmp ;

  {
#line 1209
  maxr = maxroutes___0;
#line 1210
  found = 0;
#line 1211
  data[0] = (void *)(& maxr);
#line 1211
  data[1] = (void *)routes___0;
#line 1211
  data[2] = (void *)(& found);
#line 1212
  families[0] = 10;
#line 1212
  families[1] = 2;
#line 1215
  if (! nl_setup) {
    {
#line 1216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_routes: netlink not initialized.\n");
#line 1217
    tmp = __errno_location();
#line 1217
    *tmp = 5;
    }
#line 1218
    return (-1);
  }
#line 1221
  if (nl_command.sock < 0) {
    {
#line 1222
    rc = netlink_socket(& nl_command, (uint32_t )0);
    }
#line 1223
    if (rc < 0) {
      {
#line 1224
      perror("kernel_routes: netlink_socket()");
      }
#line 1225
      return (-1);
    }
  }
#line 1229
  i___2 = 0;
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    if (! (i___2 < 2)) {
#line 1229
      goto while_break;
    }
    {
#line 1230
    memset((void *)(& g), 0, sizeof(g));
#line 1231
    g.rtgen_family = (unsigned char )families[i___2];
#line 1232
    rc = netlink_send_dump(26, (void *)(& g), (int )sizeof(g));
    }
#line 1233
    if (rc < 0) {
#line 1234
      return (-1);
    }
    {
#line 1236
    rc = netlink_read(& nl_command, (struct netlink *)((void *)0), 1, & filter_kernel_routes,
                      (void *)(data));
    }
#line 1239
    if (rc < 0) {
#line 1240
      return (-1);
    }
#line 1229
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1243
  return (found);
}
}
#line 1246 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static char *parse_ifname_rta(struct ifinfomsg *info , int len ) 
{ 
  struct rtattr *rta ;
  char *ifname ;

  {
#line 1249
  rta = (struct rtattr *)((char *)info + (((sizeof(struct ifinfomsg ) + 4UL) - 1UL) & 4294967292UL));
#line 1250
  ifname = (char *)((void *)0);
#line 1252
  len = (int )((unsigned long )len - (((sizeof(*info) + 4UL) - 1UL) & 4294967292UL));
  {
#line 1254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1254
    if (len >= (int )sizeof(struct rtattr )) {
#line 1254
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 1254
        if (! ((int )rta->rta_len <= len)) {
#line 1254
          goto while_break;
        }
      } else {
#line 1254
        goto while_break;
      }
    } else {
#line 1254
      goto while_break;
    }
    {
#line 1256
    if ((int )rta->rta_type == 3) {
#line 1256
      goto case_3;
    }
#line 1259
    goto switch_default;
    case_3: /* CIL Label */ 
#line 1257
    ifname = (char *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 1258
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1260
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1262
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1262
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 1264
  return (ifname);
}
}
#line 1267 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int parse_addr_rta(struct ifaddrmsg *addr , int len , struct in6_addr *res ) 
{ 
  struct rtattr *rta ;
  long tmp ;

  {
#line 1271
  len = (int )((unsigned long )len - (((sizeof(*addr) + 4UL) - 1UL) & 4294967292UL));
#line 1272
  rta = (struct rtattr *)((char *)addr + (((sizeof(struct ifaddrmsg ) + 4UL) - 1UL) & 4294967292UL));
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1274
    if (len >= (int )sizeof(struct rtattr )) {
#line 1274
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 1274
        if (! ((int )rta->rta_len <= len)) {
#line 1274
          goto while_break;
        }
      } else {
#line 1274
        goto while_break;
      }
    } else {
#line 1274
      goto while_break;
    }
    {
#line 1277
    if ((int )rta->rta_type == 1) {
#line 1277
      goto case_1;
    }
#line 1277
    if ((int )rta->rta_type == 2) {
#line 1277
      goto case_1;
    }
#line 1293
    goto switch_default___0;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1279
    if ((int )addr->ifa_family == 2) {
#line 1279
      goto case_2___0;
    }
#line 1283
    if ((int )addr->ifa_family == 10) {
#line 1283
      goto case_10;
    }
#line 1287
    goto switch_default;
    case_2___0: /* CIL Label */ 
#line 1280
    if (res) {
      {
#line 1281
      v4tov6(res->__in6_u.__u6_addr8, (unsigned char const   *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
      }
    }
#line 1282
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 1284
    if (res) {
      {
#line 1285
      memcpy((void */* __restrict  */)(res->__in6_u.__u6_addr8), (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (size_t )16);
      }
    }
#line 1286
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1288
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1288
      tmp = __builtin_expect((long )(! (! (debug >= 3))), 0L);
      }
#line 1288
      if (tmp) {
        {
#line 1288
        do_debugf(3, "ifaddr: unexpected address family %d\n", (int )addr->ifa_family);
        }
      }
#line 1288
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1289
    return (-1);
#line 1290
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1292
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1294
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1296
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 1296
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 1298
  return (0);
}
}
#line 1301 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int filter_link(struct nlmsghdr *nh , void *data ) 
{ 
  struct ifinfomsg *info ;
  int len ;
  int ifindex ;
  char *ifname ;
  unsigned int ifflags ;
  struct interface *ifp ;
  long tmp ;
  int tmp___0 ;

  {
#line 1311
  len = (int )nh->nlmsg_len;
#line 1313
  if ((int )nh->nlmsg_type != 16) {
#line 1313
    if ((int )nh->nlmsg_type != 17) {
#line 1314
      return (0);
    }
  }
  {
#line 1316
  info = (struct ifinfomsg *)((void *)((char *)nh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 1317
  len -= (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
#line 1319
  ifindex = info->ifi_index;
#line 1320
  ifflags = info->ifi_flags;
#line 1322
  ifname = parse_ifname_rta(info, len);
  }
#line 1323
  if ((unsigned long )ifname == (unsigned long )((void *)0)) {
#line 1324
    return (0);
  }
  {
#line 1325
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1325
    tmp = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 1325
    if (tmp) {
      {
#line 1325
      do_debugf(3, "filter_interfaces: link change on if %s(%d): 0x%x\n", ifname,
                ifindex, ifflags);
      }
    }
#line 1325
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1327
  ifp = interfaces;
  {
#line 1327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1327
    if (! ifp) {
#line 1327
      goto while_break___0;
    }
    {
#line 1328
    tmp___0 = strcmp((char const   *)(ifp->name), (char const   *)ifname);
    }
#line 1328
    if (tmp___0 == 0) {
#line 1329
      return (1);
    }
#line 1327
    ifp = ifp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1331
  return (0);
}
}
#line 1334 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int filter_addresses(struct nlmsghdr *nh , void *data ) 
{ 
  int rc ;
  int maxroutes___0 ;
  struct kernel_route *routes___0 ;
  struct in6_addr addr ;
  int *found ;
  int len ;
  struct ifaddrmsg *ifa ;
  char ifname[16] ;
  int ifindex ;
  int ll ;
  void **args ;
  struct in6_addr  const  *__a ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  struct kernel_route *route ;

  {
#line 1338
  maxroutes___0 = 0;
#line 1339
  routes___0 = (struct kernel_route *)((void *)0);
#line 1341
  found = (int *)((void *)0);
#line 1345
  ifindex = 0;
#line 1346
  ll = 0;
#line 1348
  if (data) {
#line 1349
    args = (void **)data;
#line 1350
    maxroutes___0 = *((int *)*(args + 0));
#line 1351
    routes___0 = (struct kernel_route *)*(args + 1);
#line 1352
    found = (int *)*(args + 2);
#line 1353
    if (*(args + 3)) {
#line 1353
      ifindex = *((int *)*(args + 3));
    } else {
#line 1353
      ifindex = 0;
    }
#line 1354
    if (*(args + 4)) {
#line 1354
      ll = ! (! *((int *)*(args + 4)));
    } else {
#line 1354
      ll = 0;
    }
  }
#line 1357
  len = (int )nh->nlmsg_len;
#line 1359
  if (data) {
#line 1359
    if (*found >= maxroutes___0) {
#line 1360
      return (0);
    }
  }
#line 1362
  if ((int )nh->nlmsg_type != 20) {
#line 1362
    if (data) {
#line 1364
      return (0);
    } else
#line 1362
    if ((int )nh->nlmsg_type != 21) {
#line 1364
      return (0);
    }
  }
  {
#line 1366
  ifa = (struct ifaddrmsg *)((void *)((char *)nh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 1367
  len -= (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
#line 1369
  rc = parse_addr_rta(ifa, len, & addr);
  }
#line 1370
  if (rc < 0) {
#line 1371
    return (0);
  }
  {
#line 1373
  __a = (struct in6_addr  const  *)(& addr);
#line 1373
  tmp = htonl(4290772992U);
#line 1373
  tmp___0 = htonl(4269801472U);
  }
#line 1373
  if ((__a->__in6_u.__u6_addr32[0] & tmp) == tmp___0) {
#line 1373
    tmp___1 = 0;
  } else {
#line 1373
    tmp___1 = 1;
  }
#line 1373
  if (ll == tmp___1) {
#line 1374
    return (0);
  }
#line 1376
  if (ifindex) {
#line 1376
    if (ifa->ifa_index != (__u32 )ifindex) {
#line 1377
      return (0);
    }
  }
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1379
    tmp___4 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 1379
    if (tmp___4) {
      {
#line 1379
      tmp___2 = format_address((unsigned char const   *)(addr.__in6_u.__u6_addr8));
#line 1379
      tmp___3 = if_indextoname(ifa->ifa_index, ifname);
#line 1379
      do_debugf(3, "found address on interface %s(%d): %s\n", tmp___3, ifa->ifa_index,
                tmp___2);
      }
    }
#line 1379
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1383
  if (data) {
    {
#line 1384
    route = routes___0 + *found;
#line 1385
    memcpy((void */* __restrict  */)(route->prefix), (void const   */* __restrict  */)(addr.__in6_u.__u6_addr8),
           (size_t )16);
#line 1386
    route->plen = 128;
#line 1387
    route->metric = 0;
#line 1388
    route->ifindex = ifa->ifa_index;
#line 1389
    route->proto = -2;
#line 1390
    memset((void *)(route->gw), 0, (size_t )16);
#line 1391
    (*found) ++;
    }
  }
#line 1394
  return (1);
}
}
#line 1397 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
static int filter_netlink(struct nlmsghdr *nh , void *data ) 
{ 
  int rc ;
  int *changed ;
  long tmp ;

  {
#line 1401
  changed = (int *)data;
  {
#line 1405
  if ((int )nh->nlmsg_type == 25) {
#line 1405
    goto case_25;
  }
#line 1405
  if ((int )nh->nlmsg_type == 24) {
#line 1405
    goto case_25;
  }
#line 1411
  if ((int )nh->nlmsg_type == 17) {
#line 1411
    goto case_17;
  }
#line 1411
  if ((int )nh->nlmsg_type == 16) {
#line 1411
    goto case_17;
  }
#line 1417
  if ((int )nh->nlmsg_type == 21) {
#line 1417
    goto case_21;
  }
#line 1417
  if ((int )nh->nlmsg_type == 20) {
#line 1417
    goto case_21;
  }
#line 1422
  goto switch_default;
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  {
#line 1406
  rc = filter_kernel_routes(nh, (void *)0);
  }
#line 1407
  if (changed) {
#line 1407
    if (rc > 0) {
#line 1408
      *changed |= 1 << 1;
    }
  }
#line 1409
  return (rc);
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 1412
  rc = filter_link(nh, (void *)0);
  }
#line 1413
  if (changed) {
#line 1413
    if (rc > 0) {
#line 1414
      *changed |= 1;
    }
  }
#line 1415
  return (rc);
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 1418
  rc = filter_addresses(nh, (void *)0);
  }
#line 1419
  if (changed) {
#line 1419
    if (rc > 0) {
#line 1420
      *changed |= 1 << 2;
    }
  }
#line 1421
  return (rc);
  switch_default: /* CIL Label */ 
  {
#line 1423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1423
    tmp = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 1423
    if (tmp) {
      {
#line 1423
      do_debugf(3, "filter_netlink: unexpected message type %d\n", (int )nh->nlmsg_type);
      }
    }
#line 1423
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1427
  return (0);
}
}
#line 1430 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_addresses(char *ifname , int ifindex , int ll , struct kernel_route *routes___0 ,
                     int maxroutes___0 ) 
{ 
  int maxr ;
  int found ;
  void *data[6] ;
  struct rtgenmsg g ;
  int rc ;
  int *tmp ;
  int save ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1434
  maxr = maxroutes___0;
#line 1435
  found = 0;
#line 1436
  data[0] = (void *)(& maxr);
#line 1436
  data[1] = (void *)routes___0;
#line 1436
  data[2] = (void *)(& found);
#line 1436
  data[3] = (void *)(& ifindex);
#line 1436
  data[4] = (void *)(& ll);
#line 1436
  data[5] = (void *)0;
#line 1440
  if (! nl_setup) {
    {
#line 1441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"kernel_addresses: netlink not initialized.\n");
#line 1442
    tmp = __errno_location();
#line 1442
    *tmp = 38;
    }
#line 1443
    return (-1);
  }
#line 1446
  if (nl_command.sock < 0) {
    {
#line 1447
    rc = netlink_socket(& nl_command, (uint32_t )0);
    }
#line 1448
    if (rc < 0) {
      {
#line 1449
      tmp___0 = __errno_location();
#line 1449
      save = *tmp___0;
#line 1450
      perror("kernel_addresses: netlink_socket()");
#line 1451
      tmp___1 = __errno_location();
#line 1451
      *tmp___1 = save;
      }
#line 1452
      return (-1);
    }
  }
  {
#line 1456
  memset((void *)(& g), 0, sizeof(g));
#line 1457
  g.rtgen_family = (unsigned char)0;
#line 1458
  rc = netlink_send_dump(22, (void *)(& g), (int )sizeof(g));
  }
#line 1459
  if (rc < 0) {
#line 1460
    return (-1);
  }
  {
#line 1462
  rc = netlink_read(& nl_command, (struct netlink *)((void *)0), 1, & filter_addresses,
                    (void *)(data));
  }
#line 1464
  if (rc < 0) {
#line 1465
    return (-1);
  }
#line 1467
  return (found);
}
}
#line 1470 "/home/june/collector/temp/babeld-1.4.3/kernel_netlink.c"
int kernel_callback(int (*fn)(int  , void * ) , void *closure ) 
{ 
  int rc ;
  int changed ;
  long tmp ;
  int tmp___0 ;

  {
#line 1474
  changed = 0;
  {
#line 1476
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1476
    tmp = __builtin_expect((long )(! (! (debug >= 3))), 0L);
    }
#line 1476
    if (tmp) {
      {
#line 1476
      do_debugf(3, "\nReceived changes in kernel tables.\n");
      }
    }
#line 1476
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  if (nl_listen.sock < 0) {
    {
#line 1479
    rc = kernel_setup_socket(1);
    }
#line 1480
    if (rc < 0) {
      {
#line 1481
      perror("kernel_callback: kernel_setup_socket(1)");
      }
#line 1482
      return (-1);
    }
  }
  {
#line 1485
  rc = netlink_read(& nl_listen, & nl_command, 0, & filter_netlink, (void *)(& changed));
  }
#line 1487
  if (rc < 0) {
#line 1487
    if (nl_listen.sock < 0) {
      {
#line 1488
      kernel_setup_socket(1);
      }
    }
  }
#line 1492
  if (rc) {
    {
#line 1493
    tmp___0 = (*fn)(changed, closure);
    }
#line 1493
    return (tmp___0);
  }
#line 1495
  return (0);
}
}
#line 41 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
static time_t offset  =    (time_t )0;
#line 41 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
static time_t previous  =    (time_t )0;
#line 44 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
static int have_posix_clocks  =    -1;
#line 37 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
int gettime(struct timeval *tv ) 
{ 
  int rc ;
  struct timespec ts ;
  long tmp ;
  struct timespec ts___0 ;
  int rc___0 ;
  long tmp___0 ;

  {
  {
#line 46
  tmp = __builtin_expect((long )(! (! (have_posix_clocks < 0))), 0L);
  }
#line 46
  if (tmp) {
    {
#line 48
    rc = clock_gettime(1, & ts);
    }
#line 49
    if (rc < 0) {
#line 50
      have_posix_clocks = 0;
    } else {
#line 52
      have_posix_clocks = 1;
    }
  }
#line 56
  if (have_posix_clocks) {
    {
#line 59
    rc___0 = clock_gettime(1, & ts___0);
    }
#line 60
    if (rc___0 < 0) {
#line 61
      return (rc___0);
    }
#line 62
    tv->tv_sec = ts___0.tv_sec;
#line 63
    tv->tv_usec = ts___0.tv_nsec / 1000L;
#line 64
    return (rc___0);
  }
  {
#line 68
  rc = gettimeofday((struct timeval */* __restrict  */)tv, (__timezone_ptr_t )((void *)0));
  }
#line 69
  if (rc < 0) {
#line 70
    return (rc);
  }
  {
#line 71
  tv->tv_sec += offset;
#line 72
  tmp___0 = __builtin_expect((long )(! (! (previous > tv->tv_sec))), 0L);
  }
#line 72
  if (tmp___0) {
#line 73
    offset += previous - tv->tv_sec;
#line 74
    tv->tv_sec = previous;
  }
#line 76
  previous = tv->tv_sec;
#line 77
  return (rc);
}
}
#line 83 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
int read_random_bytes(void *buf___2 , size_t len ) 
{ 
  int fd ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 89
  fd = open("/dev/urandom", 0);
  }
#line 90
  if (fd < 0) {
#line 91
    rc = -1;
  } else {
    {
#line 93
    tmp = read(fd, buf___2, len);
#line 93
    rc = (int )tmp;
    }
#line 94
    if (rc < 0) {
#line 95
      rc = -1;
    } else
#line 94
    if ((size_t )((unsigned int )rc) < len) {
#line 95
      rc = -1;
    }
    {
#line 96
    close(fd);
    }
  }
#line 98
  return (rc);
}
}
#line 101 "/home/june/collector/temp/babeld-1.4.3/kernel.c"
int add_import_table(int table ) 
{ 
  int tmp ;

  {
#line 104
  if (table < 0) {
#line 104
    return (-1);
  } else
#line 104
  if (table > 65535) {
#line 104
    return (-1);
  }
#line 105
  if (import_table_count > 9) {
#line 105
    return (-2);
  }
#line 106
  tmp = import_table_count;
#line 106
  import_table_count ++;
#line 106
  import_tables[tmp] = table;
#line 107
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 667 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 40 "/home/june/collector/temp/babeld-1.4.3/util.c"
int roughly(int value ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 43
  if (value < 0) {
    {
#line 44
    tmp = roughly(- value);
    }
#line 44
    return (- tmp);
  } else
#line 45
  if (value <= 1) {
#line 46
    return (value);
  } else {
    {
#line 48
    tmp___0 = random();
    }
#line 48
    return ((int )((long )((value * 3) / 4) + tmp___0 % (long )(value / 2)));
  }
}
}
#line 51 "/home/june/collector/temp/babeld-1.4.3/util.c"
void timeval_minus(struct timeval *d , struct timeval  const  *s1 , struct timeval  const  *s2 ) 
{ 


  {
#line 55
  if (s1->tv_usec >= s2->tv_usec) {
#line 56
    d->tv_usec = (__suseconds_t )(s1->tv_usec - s2->tv_usec);
#line 57
    d->tv_sec = (__time_t )(s1->tv_sec - s2->tv_sec);
  } else {
#line 59
    d->tv_usec = (__suseconds_t )((s1->tv_usec + 1000000L) - s2->tv_usec);
#line 60
    d->tv_sec = (__time_t )((s1->tv_sec - s2->tv_sec) - 1L);
  }
#line 62
  return;
}
}
#line 64
unsigned int timeval_minus_msec(struct timeval  const  *s1 , struct timeval  const  *s2 )  __attribute__((__pure__)) ;
#line 64 "/home/june/collector/temp/babeld-1.4.3/util.c"
unsigned int timeval_minus_msec(struct timeval  const  *s1 , struct timeval  const  *s2 ) 
{ 


  {
#line 67
  if (s1->tv_sec < s2->tv_sec) {
#line 68
    return (0U);
  }
#line 71
  if (s1->tv_sec - s2->tv_sec > 2000000L) {
#line 72
    return (2000000000U);
  }
#line 74
  if (s1->tv_sec > s2->tv_sec) {
#line 75
    return ((unsigned int )((__suseconds_t const   )((unsigned int )(s1->tv_sec - s2->tv_sec) * 1000U) + ((__suseconds_t const   )((int )s1->tv_usec) - s2->tv_usec) / 1000L));
  }
#line 79
  if (s1->tv_usec <= s2->tv_usec) {
#line 80
    return (0U);
  }
#line 82
  return ((unsigned int )(s1->tv_usec - s2->tv_usec) / 1000U);
}
}
#line 85 "/home/june/collector/temp/babeld-1.4.3/util.c"
void timeval_add_msec(struct timeval *d , struct timeval  const  *s , int msecs ) 
{ 
  int usecs ;

  {
#line 89
  d->tv_sec = (__time_t )(s->tv_sec + (__time_t const   )(msecs / 1000));
#line 90
  usecs = (int )(s->tv_usec + (__suseconds_t const   )((msecs % 1000) * 1000));
#line 91
  if (usecs < 1000000) {
#line 92
    d->tv_usec = (__suseconds_t )usecs;
  } else {
#line 94
    d->tv_usec = (__suseconds_t )(usecs - 1000000);
#line 95
    (d->tv_sec) ++;
  }
#line 97
  return;
}
}
#line 99
int timeval_compare(struct timeval  const  *s1 , struct timeval  const  *s2 )  __attribute__((__pure__)) ;
#line 99 "/home/june/collector/temp/babeld-1.4.3/util.c"
int timeval_compare(struct timeval  const  *s1 , struct timeval  const  *s2 ) 
{ 


  {
#line 102
  if (s1->tv_sec < s2->tv_sec) {
#line 103
    return (-1);
  } else
#line 104
  if (s1->tv_sec > s2->tv_sec) {
#line 105
    return (1);
  } else
#line 106
  if (s1->tv_usec < s2->tv_usec) {
#line 107
    return (-1);
  } else
#line 108
  if (s1->tv_usec > s2->tv_usec) {
#line 109
    return (1);
  } else {
#line 111
    return (0);
  }
}
}
#line 115 "/home/june/collector/temp/babeld-1.4.3/util.c"
void timeval_min(struct timeval *d , struct timeval  const  *s ) 
{ 
  int tmp ;

  {
#line 118
  if (s->tv_sec == 0L) {
#line 119
    return;
  }
#line 121
  if (d->tv_sec == 0L) {
#line 122
    *d = (struct timeval )*s;
  } else {
    {
#line 121
    tmp = timeval_compare((struct timeval  const  *)d, s);
    }
#line 121
    if (tmp > 0) {
#line 122
      *d = (struct timeval )*s;
    }
  }
#line 124
  return;
}
}
#line 126 "/home/june/collector/temp/babeld-1.4.3/util.c"
void timeval_min_sec(struct timeval *d , time_t secs ) 
{ 
  long tmp ;

  {
#line 129
  if (d->tv_sec == 0L) {
    {
#line 130
    d->tv_sec = secs;
#line 131
    tmp = random();
#line 131
    d->tv_usec = tmp % 1000000L;
    }
  } else
#line 129
  if (d->tv_sec > secs) {
    {
#line 130
    d->tv_sec = secs;
#line 131
    tmp = random();
#line 131
    d->tv_usec = tmp % 1000000L;
    }
  }
#line 133
  return;
}
}
#line 136
int parse_nat(char const   *string )  __attribute__((__pure__)) ;
#line 136 "/home/june/collector/temp/babeld-1.4.3/util.c"
int parse_nat(char const   *string ) 
{ 
  long l ;
  char *end ;

  {
  {
#line 142
  l = strtol((char const   */* __restrict  */)string, (char **/* __restrict  */)(& end),
             0);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((int )*end == 32)) {
#line 144
      if (! ((int )*end == 9)) {
#line 144
        goto while_break;
      }
    }
#line 145
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  if ((int )*end != 0) {
#line 147
    return (-1);
  }
#line 149
  if (l < 0L) {
#line 150
    return (-1);
  } else
#line 149
  if (l > 2147483647L) {
#line 150
    return (-1);
  }
#line 152
  return ((int )l);
}
}
#line 155
int parse_msec(char const   *string )  __attribute__((__pure__)) ;
#line 155 "/home/june/collector/temp/babeld-1.4.3/util.c"
int parse_msec(char const   *string ) 
{ 
  unsigned int in ;
  unsigned int fl ;
  int i___2 ;
  int j ;

  {
#line 161
  fl = 0U;
#line 161
  in = fl;
#line 162
  i___2 = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! ((int const   )*(string + i___2) == 32)) {
#line 163
      if (! ((int const   )*(string + i___2) == 9)) {
#line 163
        goto while_break;
      }
    }
#line 164
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if ((int const   )*(string + i___2) >= 48) {
#line 165
      if (! ((int const   )*(string + i___2) <= 57)) {
#line 165
        goto while_break___0;
      }
    } else {
#line 165
      goto while_break___0;
    }
#line 166
    in = (in * 10U + (unsigned int )*(string + i___2)) - 48U;
#line 167
    i___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  if ((int const   )*(string + i___2) == 46) {
#line 170
    i___2 ++;
#line 171
    j = 0;
    {
#line 172
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 172
      if ((int const   )*(string + i___2) >= 48) {
#line 172
        if (! ((int const   )*(string + i___2) <= 57)) {
#line 172
          goto while_break___1;
        }
      } else {
#line 172
        goto while_break___1;
      }
#line 173
      fl = (fl * 10U + (unsigned int )*(string + i___2)) - 48U;
#line 174
      i___2 ++;
#line 175
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 178
      if (! (j > 3)) {
#line 178
        goto while_break___2;
      }
#line 179
      fl /= 10U;
#line 180
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 182
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 182
      if (! (j < 3)) {
#line 182
        goto while_break___3;
      }
#line 183
      fl *= 10U;
#line 184
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 188
    if (! ((int const   )*(string + i___2) == 32)) {
#line 188
      if (! ((int const   )*(string + i___2) == 9)) {
#line 188
        goto while_break___4;
      }
    }
#line 189
    i___2 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 191
  if ((int const   )*(string + i___2) == 0) {
#line 192
    return ((int )(in * 1000U + fl));
  }
#line 194
  return (-1);
}
}
#line 197
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...)  __attribute__((__cold__)) ;
#line 197 "/home/june/collector/temp/babeld-1.4.3/util.c"
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 201
  __builtin_va_start(args, format);
  }
#line 202
  if (debug >= level) {
    {
#line 203
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 204
    fflush(stderr);
    }
  }
  {
#line 206
  __builtin_va_end(args);
  }
#line 207
  return;
}
}
#line 209
int in_prefix(unsigned char const   * __restrict  address , unsigned char const   * __restrict  prefix ,
              unsigned char plen )  __attribute__((__pure__)) ;
#line 209 "/home/june/collector/temp/babeld-1.4.3/util.c"
int in_prefix(unsigned char const   * __restrict  address , unsigned char const   * __restrict  prefix ,
              unsigned char plen ) 
{ 
  unsigned char m ;
  int tmp ;

  {
#line 215
  if ((int )plen > 128) {
#line 216
    plen = (unsigned char)128;
  }
  {
#line 218
  tmp = memcmp((void const   *)address, (void const   *)prefix, (size_t )((int )plen / 8));
  }
#line 218
  if (tmp != 0) {
#line 219
    return (0);
  }
#line 221
  if ((int )plen % 8 == 0) {
#line 222
    return (1);
  }
#line 224
  m = (unsigned char )(255 << (8 - (int )plen % 8));
#line 226
  return (((int const   )*(address + (int )plen / 8) & (int const   )m) == ((int const   )*(prefix + (int )plen / 8) & (int const   )m));
}
}
#line 229 "/home/june/collector/temp/babeld-1.4.3/util.c"
unsigned char *mask_prefix(unsigned char * __restrict  ret , unsigned char const   * __restrict  prefix ,
                           unsigned char plen ) 
{ 


  {
#line 233
  if ((int )plen >= 128) {
    {
#line 234
    memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)prefix,
           (size_t )16);
    }
#line 235
    return ((unsigned char *)ret);
  }
  {
#line 238
  memset((void *)ret, 0, (size_t )16);
#line 239
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)prefix, (size_t )((int )plen / 8));
  }
#line 240
  if ((int )plen % 8 != 0) {
#line 241
    *(ret + (int )plen / 8) = (unsigned char )((int const   )*(prefix + (int )plen / 8) & (int const   )((255 << (8 - (int )plen % 8)) & 255));
  }
#line 243
  return ((unsigned char *)ret);
}
}
#line 246 "/home/june/collector/temp/babeld-1.4.3/util.c"
static unsigned char const   v4prefix___0[16]  = 
#line 246
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 249 "/home/june/collector/temp/babeld-1.4.3/util.c"
static unsigned char const   llprefix[16]  = {      (unsigned char const   )254,      (unsigned char const   )128};
#line 255 "/home/june/collector/temp/babeld-1.4.3/util.c"
static char buf[4][46]  ;
#line 256 "/home/june/collector/temp/babeld-1.4.3/util.c"
static int i  =    0;
#line 252 "/home/june/collector/temp/babeld-1.4.3/util.c"
char const   *format_address(unsigned char const   *address ) 
{ 
  int tmp ;

  {
  {
#line 257
  i = (i + 1) % 4;
#line 258
  tmp = v4mapped(address);
  }
#line 258
  if (tmp) {
    {
#line 259
    inet_ntop(2, (void const   */* __restrict  */)(address + 12), (char */* __restrict  */)(buf[i]),
              (socklen_t )46);
    }
  } else {
    {
#line 261
    inet_ntop(10, (void const   */* __restrict  */)address, (char */* __restrict  */)(buf[i]),
              (socklen_t )46);
    }
  }
#line 262
  return ((char const   *)(buf[i]));
}
}
#line 268 "/home/june/collector/temp/babeld-1.4.3/util.c"
static char buf___0[4][50]  ;
#line 269 "/home/june/collector/temp/babeld-1.4.3/util.c"
static int i___0  =    0;
#line 265 "/home/june/collector/temp/babeld-1.4.3/util.c"
char const   *format_prefix(unsigned char const   *prefix , unsigned char plen ) 
{ 
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 271
  i___0 = (i___0 + 1) % 4;
#line 272
  if ((int )plen >= 96) {
    {
#line 272
    tmp___1 = v4mapped(prefix);
    }
#line 272
    if (tmp___1) {
      {
#line 273
      inet_ntop(2, (void const   */* __restrict  */)(prefix + 12), (char */* __restrict  */)(buf___0[i___0]),
                (socklen_t )46);
#line 274
      tmp = strlen((char const   *)(buf___0[i___0]));
#line 274
      n = (int )tmp;
#line 275
      snprintf((char */* __restrict  */)(buf___0[i___0] + n), (size_t )(50 - n), (char const   */* __restrict  */)"/%d",
               (int )plen - 96);
      }
    } else {
      {
#line 277
      inet_ntop(10, (void const   */* __restrict  */)prefix, (char */* __restrict  */)(buf___0[i___0]),
                (socklen_t )46);
#line 278
      tmp___0 = strlen((char const   *)(buf___0[i___0]));
#line 278
      n = (int )tmp___0;
#line 279
      snprintf((char */* __restrict  */)(buf___0[i___0] + n), (size_t )(50 - n), (char const   */* __restrict  */)"/%d",
               (int )plen);
      }
    }
  } else {
    {
#line 277
    inet_ntop(10, (void const   */* __restrict  */)prefix, (char */* __restrict  */)(buf___0[i___0]),
              (socklen_t )46);
#line 278
    tmp___0 = strlen((char const   *)(buf___0[i___0]));
#line 278
    n = (int )tmp___0;
#line 279
    snprintf((char */* __restrict  */)(buf___0[i___0] + n), (size_t )(50 - n), (char const   */* __restrict  */)"/%d",
             (int )plen);
    }
  }
#line 281
  return ((char const   *)(buf___0[i___0]));
}
}
#line 287 "/home/june/collector/temp/babeld-1.4.3/util.c"
static char buf___1[4][28]  ;
#line 288 "/home/june/collector/temp/babeld-1.4.3/util.c"
static int i___1  =    0;
#line 284 "/home/june/collector/temp/babeld-1.4.3/util.c"
char const   *format_eui64(unsigned char const   *eui ) 
{ 


  {
  {
#line 289
  i___1 = (i___1 + 1) % 4;
#line 290
  snprintf((char */* __restrict  */)(buf___1[i___1]), (size_t )28, (char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           (int const   )*(eui + 0), (int const   )*(eui + 1), (int const   )*(eui + 2),
           (int const   )*(eui + 3), (int const   )*(eui + 4), (int const   )*(eui + 5),
           (int const   )*(eui + 6), (int const   )*(eui + 7));
  }
#line 293
  return ((char const   *)(buf___1[i___1]));
}
}
#line 296 "/home/june/collector/temp/babeld-1.4.3/util.c"
int parse_address(char const   *address , unsigned char *addr_r , int *af_r ) 
{ 
  struct in_addr ina ;
  struct in6_addr ina6 ;
  int rc ;

  {
  {
#line 303
  rc = inet_pton(2, (char const   */* __restrict  */)address, (void */* __restrict  */)(& ina));
  }
#line 304
  if (rc > 0) {
    {
#line 305
    memcpy((void */* __restrict  */)addr_r, (void const   */* __restrict  */)(v4prefix___0),
           (size_t )12);
#line 306
    memcpy((void */* __restrict  */)(addr_r + 12), (void const   */* __restrict  */)(& ina),
           (size_t )4);
    }
#line 307
    if (af_r) {
#line 307
      *af_r = 2;
    }
#line 308
    return (0);
  }
  {
#line 311
  rc = inet_pton(10, (char const   */* __restrict  */)address, (void */* __restrict  */)(& ina6));
  }
#line 312
  if (rc > 0) {
    {
#line 313
    memcpy((void */* __restrict  */)addr_r, (void const   */* __restrict  */)(& ina6),
           (size_t )16);
    }
#line 314
    if (af_r) {
#line 314
      *af_r = 10;
    }
#line 315
    return (0);
  }
#line 318
  return (-1);
}
}
#line 321 "/home/june/collector/temp/babeld-1.4.3/util.c"
int parse_net(char const   *net , unsigned char *prefix_r , unsigned char *plen_r ,
              int *af_r ) 
{ 
  char buf___2[46] ;
  char *slash ;
  char *end ;
  unsigned char prefix[16] ;
  long plen ;
  int af ;
  struct in_addr ina ;
  struct in6_addr ina6 ;
  int rc ;
  int tmp ;

  {
  {
#line 334
  tmp = strcmp(net, "default");
  }
#line 334
  if (tmp == 0) {
    {
#line 335
    memset((void *)(prefix), 0, (size_t )16);
#line 336
    plen = 0L;
#line 337
    af = 10;
    }
  } else {
    {
#line 339
    slash = strchr(net, '/');
    }
#line 340
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 341
      rc = parse_address(net, prefix, & af);
      }
#line 342
      if (rc < 0) {
#line 343
        return (rc);
      }
#line 344
      plen = 128L;
    } else {
#line 346
      if (slash - (char *)net >= 46L) {
#line 347
        return (-1);
      }
      {
#line 348
      memcpy((void */* __restrict  */)(buf___2), (void const   */* __restrict  */)net,
             (size_t )(slash - (char *)net));
#line 349
      buf___2[slash - (char *)net] = (char )'\000';
#line 350
      rc = inet_pton(2, (char const   */* __restrict  */)(buf___2), (void */* __restrict  */)(& ina));
      }
#line 351
      if (rc > 0) {
        {
#line 352
        memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)(v4prefix___0),
               (size_t )12);
#line 353
        memcpy((void */* __restrict  */)(prefix + 12), (void const   */* __restrict  */)(& ina),
               (size_t )4);
#line 354
        plen = strtol((char const   */* __restrict  */)(slash + 1), (char **/* __restrict  */)(& end),
                      0);
        }
#line 355
        if ((int )*end != 0) {
#line 356
          return (-1);
        } else
#line 355
        if (plen < 0L) {
#line 356
          return (-1);
        } else
#line 355
        if (plen > 32L) {
#line 356
          return (-1);
        }
#line 357
        plen += 96L;
#line 358
        af = 2;
      } else {
        {
#line 360
        rc = inet_pton(10, (char const   */* __restrict  */)(buf___2), (void */* __restrict  */)(& ina6));
        }
#line 361
        if (rc > 0) {
          {
#line 362
          memcpy((void */* __restrict  */)(prefix), (void const   */* __restrict  */)(& ina6),
                 (size_t )16);
#line 363
          plen = strtol((char const   */* __restrict  */)(slash + 1), (char **/* __restrict  */)(& end),
                        0);
          }
#line 364
          if ((int )*end != 0) {
#line 365
            return (-1);
          } else
#line 364
          if (plen < 0L) {
#line 365
            return (-1);
          } else
#line 364
          if (plen > 128L) {
#line 365
            return (-1);
          }
#line 366
          af = 10;
        } else {
#line 368
          return (-1);
        }
      }
    }
  }
  {
#line 373
  mask_prefix((unsigned char */* __restrict  */)prefix_r, (unsigned char const   */* __restrict  */)(prefix),
              (unsigned char )plen);
#line 374
  *plen_r = (unsigned char )plen;
  }
#line 375
  if (af_r) {
#line 375
    *af_r = af;
  }
#line 376
  return (0);
}
}
#line 379 "/home/june/collector/temp/babeld-1.4.3/util.c"
int parse_eui64(char const   *eui , unsigned char *eui_r ) 
{ 
  int n ;

  {
  {
#line 383
  n = sscanf((char const   */* __restrict  */)eui, (char const   */* __restrict  */)"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
             eui_r + 0, eui_r + 1, eui_r + 2, eui_r + 3, eui_r + 4, eui_r + 5, eui_r + 6,
             eui_r + 7);
  }
#line 386
  if (n == 8) {
#line 387
    return (0);
  }
  {
#line 389
  n = sscanf((char const   */* __restrict  */)eui, (char const   */* __restrict  */)"%02hhx-%02hhx-%02hhx-%02hhx-%02hhx-%02hhx-%02hhx-%02hhx",
             eui_r + 0, eui_r + 1, eui_r + 2, eui_r + 3, eui_r + 4, eui_r + 5, eui_r + 6,
             eui_r + 7);
  }
#line 392
  if (n == 8) {
#line 393
    return (0);
  }
  {
#line 395
  n = sscanf((char const   */* __restrict  */)eui, (char const   */* __restrict  */)"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
             eui_r + 0, eui_r + 1, eui_r + 2, eui_r + 5, eui_r + 6, eui_r + 7);
  }
#line 398
  if (n == 6) {
#line 399
    *(eui_r + 3) = (unsigned char)255;
#line 400
    *(eui_r + 4) = (unsigned char)254;
#line 401
    return (0);
  }
#line 403
  return (-1);
}
}
#line 406 "/home/june/collector/temp/babeld-1.4.3/util.c"
int wait_for_fd(int direction , int fd , int msecs ) 
{ 
  fd_set fds ;
  int rc ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;

  {
#line 413
  tv.tv_sec = (__time_t )(msecs / 1000);
#line 414
  tv.tv_usec = (__suseconds_t )((msecs % 1000) * 1000);
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 416
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 418
  if (direction) {
    {
#line 419
    rc = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
  } else {
    {
#line 421
    rc = select(fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
  }
#line 423
  return (rc);
}
}
#line 426
int martian_prefix(unsigned char const   *prefix , int plen )  __attribute__((__pure__)) ;
#line 426 "/home/june/collector/temp/babeld-1.4.3/util.c"
int martian_prefix(unsigned char const   *prefix , int plen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 429
  if (plen >= 8) {
#line 429
    if ((int const   )*(prefix + 0) == 255) {
#line 429
      tmp___1 = 1;
    } else {
#line 429
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 429
  if (plen >= 10) {
#line 429
    if ((int const   )*(prefix + 0) == 254) {
#line 429
      if (((int const   )*(prefix + 1) & 192) == 128) {
#line 429
        tmp___1 = 1;
      } else {
#line 429
        goto _L___3;
      }
    } else {
#line 429
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 429
  if (plen >= 128) {
    {
#line 429
    tmp = memcmp((void const   *)prefix, (void const   *)(zeroes), (size_t )15);
    }
#line 429
    if (tmp == 0) {
#line 429
      if ((int const   )*(prefix + 15) == 0) {
#line 429
        tmp___1 = 1;
      } else
#line 429
      if ((int const   )*(prefix + 15) == 1) {
#line 429
        tmp___1 = 1;
      } else {
#line 429
        goto _L___1;
      }
    } else {
#line 429
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 429
  if (plen >= 96) {
    {
#line 429
    tmp___0 = v4mapped(prefix);
    }
#line 429
    if (tmp___0) {
#line 429
      if (plen >= 104) {
#line 429
        if ((int const   )*(prefix + 12) == 127) {
#line 429
          tmp___1 = 1;
        } else
#line 429
        if ((int const   )*(prefix + 12) == 0) {
#line 429
          tmp___1 = 1;
        } else {
#line 429
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 429
      if (plen >= 100) {
#line 429
        if (((int const   )*(prefix + 12) & 224) == 224) {
#line 429
          tmp___1 = 1;
        } else {
#line 429
          tmp___1 = 0;
        }
      } else {
#line 429
        tmp___1 = 0;
      }
    } else {
#line 429
      tmp___1 = 0;
    }
  } else {
#line 429
    tmp___1 = 0;
  }
#line 429
  return (tmp___1);
}
}
#line 439
int linklocal(unsigned char const   *address )  __attribute__((__pure__)) ;
#line 439 "/home/june/collector/temp/babeld-1.4.3/util.c"
int linklocal(unsigned char const   *address ) 
{ 
  int tmp ;

  {
  {
#line 442
  tmp = memcmp((void const   *)address, (void const   *)(llprefix), (size_t )8);
  }
#line 442
  return (tmp == 0);
}
}
#line 445
int v4mapped(unsigned char const   *address )  __attribute__((__pure__)) ;
#line 445 "/home/june/collector/temp/babeld-1.4.3/util.c"
int v4mapped(unsigned char const   *address ) 
{ 
  int tmp ;

  {
  {
#line 448
  tmp = memcmp((void const   *)address, (void const   *)(v4prefix___0), (size_t )12);
  }
#line 448
  return (tmp == 0);
}
}
#line 451 "/home/june/collector/temp/babeld-1.4.3/util.c"
void v4tov6(unsigned char *dst , unsigned char const   *src ) 
{ 


  {
  {
#line 454
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(v4prefix___0),
         (size_t )12);
#line 455
  memcpy((void */* __restrict  */)(dst + 12), (void const   */* __restrict  */)src,
         (size_t )4);
  }
#line 456
  return;
}
}
#line 458 "/home/june/collector/temp/babeld-1.4.3/util.c"
int daemonise(void) 
{ 
  int rc ;

  {
  {
#line 463
  fflush(stdout);
#line 464
  fflush(stderr);
#line 466
  rc = fork();
  }
#line 467
  if (rc < 0) {
#line 468
    return (-1);
  }
#line 470
  if (rc > 0) {
    {
#line 471
    exit(0);
    }
  }
  {
#line 473
  rc = setsid();
  }
#line 474
  if (rc < 0) {
#line 475
    return (-1);
  }
#line 477
  return (1);
}
}
