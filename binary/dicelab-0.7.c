/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 4 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/roll.h"
struct roll_value {
   int count ;
   int *values ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.h"
struct result_node {
   int value ;
   int prob ;
   struct result_node *next ;
};
#line 12 "eval.tc"
struct val_list {
   double prob ;
   int count ;
   int *values ;
   struct val_list *next ;
};
#line 69 "tree.h"
enum __anonenum_filter_type_25 {
    drop = 0,
    keep = 1
} ;
#line 69 "tree.h"
typedef enum __anonenum_filter_type_25 filter_type;
#line 74
struct expression__;
#line 74 "tree.h"
typedef struct expression__ expression;
#line 111
enum __anonenum_ordering_type_26 {
    agnostic = 0,
    caring = 1
} ;
#line 111 "tree.h"
typedef enum __anonenum_ordering_type_26 ordering_type;
#line 116
enum __anonenum_comparison_type_27 {
    eq = 0,
    ne = 1,
    lt = 2,
    gt = 3,
    le = 4,
    ge = 5
} ;
#line 116 "tree.h"
typedef enum __anonenum_comparison_type_27 comparison_type;
#line 135
struct expression_vtable__;
#line 135
struct symtab;
#line 135 "tree.h"
struct expression__ {
   struct expression_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
};
#line 144 "tree.h"
struct expression_vtable__ {
   void const   *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 106 "par.y"
union YYSTYPE {
   int ival ;
   char *tval ;
   expression *expr ;
};
#line 106 "par.y"
typedef union YYSTYPE YYSTYPE;
#line 273 "par.c"
typedef unsigned char yytype_uint8;
#line 280 "par.c"
typedef signed char yytype_int8;
#line 294 "par.c"
typedef short yytype_int16;
#line 425 "par.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 52 "lex.c"
typedef short flex_int16_t;
#line 53 "lex.c"
typedef int flex_int32_t;
#line 162
struct yy_buffer_state;
#line 162 "lex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 206 "lex.c"
typedef size_t yy_size_t;
#line 211 "lex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 358 "lex.c"
typedef unsigned char YY_CHAR;
#line 362 "lex.c"
typedef int yy_state_type;
#line 75 "tree.h"
struct elist__;
#line 75 "tree.h"
typedef struct elist__ elist;
#line 76
struct binary__;
#line 76 "tree.h"
typedef struct binary__ binary;
#line 77
struct unary__;
#line 77 "tree.h"
typedef struct unary__ unary;
#line 78
struct number__;
#line 78 "tree.h"
typedef struct number__ number;
#line 79
struct ifthenelse__;
#line 79 "tree.h"
typedef struct ifthenelse__ ifthenelse;
#line 80
struct variable__;
#line 80 "tree.h"
typedef struct variable__ variable;
#line 81
struct sumrepdice__;
#line 81 "tree.h"
typedef struct sumrepdice__ sumrepdice;
#line 82
struct sumrepany__;
#line 82 "tree.h"
typedef struct sumrepany__ sumrepany;
#line 83
struct mathop__;
#line 83 "tree.h"
typedef struct mathop__ mathop;
#line 84
struct scat__;
#line 84 "tree.h"
typedef struct scat__ scat;
#line 85
struct rep__;
#line 85 "tree.h"
typedef struct rep__ rep;
#line 86
struct range__;
#line 86 "tree.h"
typedef struct range__ range;
#line 87
struct lcat__;
#line 87 "tree.h"
typedef struct lcat__ lcat;
#line 89
struct let__;
#line 89 "tree.h"
typedef struct let__ let;
#line 90
struct foreach__;
#line 90 "tree.h"
typedef struct foreach__ foreach;
#line 91
struct whiledo__;
#line 91 "tree.h"
typedef struct whiledo__ whiledo;
#line 92
struct plus__;
#line 92 "tree.h"
typedef struct plus__ plus;
#line 93
struct minus__;
#line 93 "tree.h"
typedef struct minus__ minus;
#line 94
struct multi__;
#line 94 "tree.h"
typedef struct multi__ multi;
#line 95
struct divi__;
#line 95 "tree.h"
typedef struct divi__ divi;
#line 96
struct mod__;
#line 96 "tree.h"
typedef struct mod__ mod;
#line 97
struct expo__;
#line 97 "tree.h"
typedef struct expo__ expo;
#line 98
struct first__;
#line 98 "tree.h"
typedef struct first__ first;
#line 99
struct last__;
#line 99 "tree.h"
typedef struct last__ last;
#line 100
struct high__;
#line 100 "tree.h"
typedef struct high__ high;
#line 101
struct low__;
#line 101 "tree.h"
typedef struct low__ low;
#line 102
struct comparison__;
#line 102 "tree.h"
typedef struct comparison__ comparison;
#line 103
struct negate__;
#line 103 "tree.h"
typedef struct negate__ negate;
#line 104
struct dice__;
#line 104 "tree.h"
typedef struct dice__ dice;
#line 105
struct sum__;
#line 105 "tree.h"
typedef struct sum__ sum;
#line 106
struct prod__;
#line 106 "tree.h"
typedef struct prod__ prod;
#line 107
struct count__;
#line 107 "tree.h"
typedef struct count__ count;
#line 108
struct perm__;
#line 108 "tree.h"
typedef struct perm__ perm;
#line 109
struct sort__;
#line 109 "tree.h"
typedef struct sort__ sort;
#line 110
struct rev__;
#line 110 "tree.h"
typedef struct rev__ rev;
#line 1 "c_skel.h"
struct YYNODESTATE_block;
#line 1
struct YYNODESTATE_push;
#line 1 "c_skel.h"
struct __anonstruct_YYNODESTATE_30 {
   struct YYNODESTATE_block *blocks__ ;
   struct YYNODESTATE_push *push_stack__ ;
   int used__ ;
};
#line 1 "c_skel.h"
typedef struct __anonstruct_YYNODESTATE_30 YYNODESTATE;
#line 185 "tree.h"
struct elist_vtable__;
#line 185 "tree.h"
struct elist__ {
   struct elist_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
};
#line 194 "tree.h"
struct elist_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 213
struct binary_vtable__;
#line 213 "tree.h"
struct binary__ {
   struct binary_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 224 "tree.h"
struct binary_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 242
struct unary_vtable__;
#line 242 "tree.h"
struct unary__ {
   struct unary_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 252 "tree.h"
struct unary_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 270
struct number_vtable__;
#line 270 "tree.h"
struct number__ {
   struct number_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   int num ;
};
#line 280 "tree.h"
struct number_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 299
struct ifthenelse_vtable__;
#line 299 "tree.h"
struct ifthenelse__ {
   struct ifthenelse_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *if_expr ;
   expression *then_expr ;
   expression *else_expr ;
};
#line 311 "tree.h"
struct ifthenelse_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 332
struct variable_vtable__;
#line 332 "tree.h"
struct variable__ {
   struct variable_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   char *varname ;
};
#line 342 "tree.h"
struct variable_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 362
struct sumrepdice_vtable__;
#line 362 "tree.h"
struct sumrepdice__ {
   struct sumrepdice_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   struct val_list *num_dice ;
   int num_sides ;
};
#line 373 "tree.h"
struct sumrepdice_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 392
struct sumrepany_vtable__;
#line 392 "tree.h"
struct sumrepany__ {
   struct sumrepany_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   struct val_list *number ;
   struct val_list *data ;
};
#line 403 "tree.h"
struct sumrepany_vtable__ {
   struct expression_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 422
struct mathop_vtable__;
#line 422 "tree.h"
struct mathop__ {
   struct mathop_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 433 "tree.h"
struct mathop_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 451
struct scat_vtable__;
#line 451 "tree.h"
struct scat__ {
   struct scat_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 462 "tree.h"
struct scat_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 480
struct rep_vtable__;
#line 480 "tree.h"
struct rep__ {
   struct rep_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 491 "tree.h"
struct rep_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 509
struct range_vtable__;
#line 509 "tree.h"
struct range__ {
   struct range_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 520 "tree.h"
struct range_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 538
struct lcat_vtable__;
#line 538 "tree.h"
struct lcat__ {
   struct lcat_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 549 "tree.h"
struct lcat_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 567
struct filter_vtable__;
#line 579 "tree.h"
struct filter_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 593
struct let_vtable__;
#line 593 "tree.h"
struct let__ {
   struct let_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   char *varname ;
};
#line 605 "tree.h"
struct let_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 624
struct foreach_vtable__;
#line 624 "tree.h"
struct foreach__ {
   struct foreach_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   char *varname ;
};
#line 636 "tree.h"
struct foreach_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 654
struct whiledo_vtable__;
#line 654 "tree.h"
struct whiledo__ {
   struct whiledo_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   char *varname ;
};
#line 666 "tree.h"
struct whiledo_vtable__ {
   struct binary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 684
struct plus_vtable__;
#line 684 "tree.h"
struct plus__ {
   struct plus_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 695 "tree.h"
struct plus_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 709
struct minus_vtable__;
#line 709 "tree.h"
struct minus__ {
   struct minus_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 720 "tree.h"
struct minus_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 734
struct multi_vtable__;
#line 734 "tree.h"
struct multi__ {
   struct multi_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 745 "tree.h"
struct multi_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 759
struct divi_vtable__;
#line 759 "tree.h"
struct divi__ {
   struct divi_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 770 "tree.h"
struct divi_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 784
struct mod_vtable__;
#line 784 "tree.h"
struct mod__ {
   struct mod_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 795 "tree.h"
struct mod_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 809
struct expo_vtable__;
#line 809 "tree.h"
struct expo__ {
   struct expo_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
};
#line 820 "tree.h"
struct expo_vtable__ {
   struct mathop_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 834
struct first_vtable__;
#line 834 "tree.h"
struct first__ {
   struct first_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   filter_type type ;
};
#line 846 "tree.h"
struct first_vtable__ {
   struct filter_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 865
struct last_vtable__;
#line 865 "tree.h"
struct last__ {
   struct last_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   filter_type type ;
};
#line 877 "tree.h"
struct last_vtable__ {
   struct filter_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 896
struct high_vtable__;
#line 896 "tree.h"
struct high__ {
   struct high_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   filter_type type ;
};
#line 908 "tree.h"
struct high_vtable__ {
   struct filter_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 926
struct low_vtable__;
#line 926 "tree.h"
struct low__ {
   struct low_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   filter_type type ;
};
#line 938 "tree.h"
struct low_vtable__ {
   struct filter_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 956
struct comparison_vtable__;
#line 956 "tree.h"
struct comparison__ {
   struct comparison_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr1 ;
   expression *expr2 ;
   filter_type type ;
   comparison_type comp ;
};
#line 969 "tree.h"
struct comparison_vtable__ {
   struct filter_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 987
struct negate_vtable__;
#line 987 "tree.h"
struct negate__ {
   struct negate_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 997 "tree.h"
struct negate_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1015
struct dice_vtable__;
#line 1015 "tree.h"
struct dice__ {
   struct dice_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1025 "tree.h"
struct dice_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1043
struct sum_vtable__;
#line 1043 "tree.h"
struct sum__ {
   struct sum_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1053 "tree.h"
struct sum_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1073
struct prod_vtable__;
#line 1073 "tree.h"
struct prod__ {
   struct prod_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1083 "tree.h"
struct prod_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1102
struct count_vtable__;
#line 1102 "tree.h"
struct count__ {
   struct count_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1112 "tree.h"
struct count_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1131
struct perm_vtable__;
#line 1131 "tree.h"
struct perm__ {
   struct perm_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1141 "tree.h"
struct perm_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1160
struct sort_vtable__;
#line 1160 "tree.h"
struct sort__ {
   struct sort_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1170 "tree.h"
struct sort_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 1189
struct rev_vtable__;
#line 1189 "tree.h"
struct rev__ {
   struct rev_vtable__  const  *vtable__ ;
   int kind__ ;
   char *filename__ ;
   long linenum__ ;
   struct symtab *symtab ;
   ordering_type ordering ;
   expression *expr ;
};
#line 1199 "tree.h"
struct rev_vtable__ {
   struct unary_vtable__  const  *parent__ ;
   int kind__ ;
   char const   *name__ ;
   void (*printtree_v__)(expression *this__ , int depth ) ;
   struct roll_value *(*roll_v__)(expression *this__ ) ;
   void (*set_symtab_v__)(expression *this__ , struct symtab *st ) ;
   void (*set_ordering_v__)(expression *this__ , ordering_type ordering ) ;
   struct val_list *(*eval_v__)(expression *this__ ) ;
   expression *(*optimize_v__)(expression *this__ ) ;
};
#line 6 "symtab.tc"
union __anonunion____missing_field_name_31 {
   struct roll_value *rvalue ;
   struct val_list *lvalue ;
   ordering_type ordering ;
};
#line 6 "symtab.tc"
struct symtab {
   char *name ;
   union __anonunion____missing_field_name_31 __annonCompField1 ;
   struct symtab *next ;
};
#line 33 "c_skel.c"
struct YYNODESTATE_block {
   char data__[2048] ;
   struct YYNODESTATE_block *next__ ;
};
#line 39 "c_skel.c"
struct YYNODESTATE_push {
   struct YYNODESTATE_push *next__ ;
   struct YYNODESTATE_block *saved_block__ ;
   int saved_used__ ;
};
#line 68 "c_skel.c"
struct _YYNODESTATE_align_int {
   char pad ;
   int field ;
};
#line 69 "c_skel.c"
struct _YYNODESTATE_align_long {
   char pad ;
   long field ;
};
#line 73 "c_skel.c"
struct _YYNODESTATE_align_long_long {
   char pad ;
   long long field ;
};
#line 75 "c_skel.c"
struct _YYNODESTATE_align_void_p {
   char pad ;
   void *field ;
};
#line 76 "c_skel.c"
struct _YYNODESTATE_align_float {
   char pad ;
   float field ;
};
#line 77 "c_skel.c"
struct _YYNODESTATE_align_double {
   char pad ;
   double field ;
};
#line 3744 "tree.c"
struct yy_vtable__ {
   struct yy_vtable__  const  *parent__ ;
   int kind__ ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 38 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 53
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/roll.h"
struct roll_value *new_roll_single(int num ) ;
#line 10
struct roll_value *new_roll_multi(int count ) ;
#line 11
void free_roll(struct roll_value *v ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/roll.c"
struct roll_value *new_roll_single(int num ) 
{ 
  struct roll_value *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 7
  tmp = malloc(sizeof(struct roll_value ));
#line 7
  ret = (struct roll_value *)tmp;
#line 9
  ret->count = 1;
#line 10
  tmp___0 = malloc(sizeof(int ));
#line 10
  ret->values = (int *)tmp___0;
#line 11
  *(ret->values + 0) = num;
  }
#line 12
  return (ret);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/roll.c"
struct roll_value *new_roll_multi(int count ) 
{ 
  struct roll_value *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 16
  tmp = malloc(sizeof(struct roll_value ));
#line 16
  ret = (struct roll_value *)tmp;
#line 18
  ret->count = count;
#line 19
  tmp___0 = malloc(sizeof(int ) * (unsigned long )count);
#line 19
  ret->values = (int *)tmp___0;
#line 20
  memset((void *)ret->values, 0, sizeof(int ) * (unsigned long )count);
  }
#line 21
  return (ret);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/roll.c"
void free_roll(struct roll_value *v ) 
{ 


  {
  {
#line 25
  free((void *)v->values);
#line 26
  free((void *)v);
  }
#line 27
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.h"
void result_add(struct result_node **list , int value ) ;
#line 19 "eval.tc"
void list_free(struct val_list *list ) ;
#line 1217 "tree.h"
expression *elist_create(void) ;
#line 1218
expression *number_create(int num ) ;
#line 1219
expression *ifthenelse_create(expression *if_expr , expression *then_expr , expression *else_expr ) ;
#line 1220
expression *variable_create(char *varname ) ;
#line 1223
expression *scat_create(expression *expr1 , expression *expr2 ) ;
#line 1224
expression *rep_create(expression *expr1 , expression *expr2 ) ;
#line 1225
expression *range_create(expression *expr1 , expression *expr2 ) ;
#line 1226
expression *lcat_create(expression *expr1 , expression *expr2 ) ;
#line 1227
expression *let_create(expression *expr1 , expression *expr2 , char *varname ) ;
#line 1228
expression *foreach_create(expression *expr1 , expression *expr2 , char *varname ) ;
#line 1229
expression *whiledo_create(expression *expr1 , expression *expr2 , char *varname ) ;
#line 1230
expression *plus_create(expression *expr1 , expression *expr2 ) ;
#line 1231
expression *minus_create(expression *expr1 , expression *expr2 ) ;
#line 1232
expression *multi_create(expression *expr1 , expression *expr2 ) ;
#line 1233
expression *divi_create(expression *expr1 , expression *expr2 ) ;
#line 1234
expression *mod_create(expression *expr1 , expression *expr2 ) ;
#line 1235
expression *expo_create(expression *expr1 , expression *expr2 ) ;
#line 1236
expression *first_create(expression *expr1 , expression *expr2 , filter_type type ) ;
#line 1237
expression *last_create(expression *expr1 , expression *expr2 , filter_type type ) ;
#line 1238
expression *high_create(expression *expr1 , expression *expr2 , filter_type type ) ;
#line 1239
expression *low_create(expression *expr1 , expression *expr2 , filter_type type ) ;
#line 1240
expression *comparison_create(expression *expr1 , expression *expr2 , filter_type type ,
                              comparison_type comp ) ;
#line 1241
expression *negate_create(expression *expr ) ;
#line 1242
expression *dice_create(expression *expr ) ;
#line 1243
expression *sum_create(expression *expr ) ;
#line 1244
expression *prod_create(expression *expr ) ;
#line 1245
expression *count_create(expression *expr ) ;
#line 1246
expression *perm_create(expression *expr ) ;
#line 1247
expression *sort_create(expression *expr ) ;
#line 1248
expression *rev_create(expression *expr ) ;
#line 1288
char *yycurrfilename(void) ;
#line 1289
long yycurrlinenum(void) ;
#line 1299
void yynodefailed(void) ;
#line 9 "par.y"
int yylex(void) ;
#line 10
int yyerror(char *s ) ;
#line 13 "par.y"
char *filename  =    (char *)"<stdin>";
#line 15
int cmd_parse_tree ;
#line 16
int cmd_roll ;
#line 17
int cmd_rolleval ;
#line 18
int cmd_calc ;
#line 19
int cmd_count ;
#line 21 "par.y"
int cmplist(void const   *p1 , void const   *p2 ) 
{ 


  {
#line 22
  return (*(((struct val_list *)p1)->values + 0) - *(((struct val_list *)p2)->values + 0));
}
}
#line 32 "par.y"
void list_quicksort(struct val_list **data , int start , int end ) 
{ 
  int i ;
  int j ;
  struct val_list *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 33
  if (end > start) {
#line 34
    i = start - 1;
#line 35
    j = end;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 38
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 38
        i ++;
#line 38
        tmp = cmplist((void const   *)*(data + i), (void const   *)*(data + end));
        }
#line 38
        if (! (tmp < 0)) {
#line 38
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 39
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 39
        j --;
#line 39
        if (j >= 0) {
#line 39
          tmp___0 = j;
        } else {
#line 39
          tmp___0 = end;
        }
        {
#line 39
        tmp___1 = cmplist((void const   *)*(data + tmp___0), (void const   *)*(data + end));
        }
#line 39
        if (! (tmp___1 > 0)) {
#line 39
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 40
      if (i >= j) {
#line 41
        goto while_break;
      }
#line 42
      t = *(data + i);
#line 43
      *(data + i) = *(data + j);
#line 44
      *(data + j) = t;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 47
    t = *(data + i);
#line 48
    *(data + i) = *(data + end);
#line 49
    *(data + end) = t;
#line 51
    list_quicksort(data, start, i - 1);
#line 52
    list_quicksort(data, i + 1, end);
    }
  }
#line 54
  return;
}
}
#line 56 "par.y"
struct val_list *list_sort(struct val_list *list ) 
{ 
  int count___0 ;
  struct val_list *cl ;
  struct val_list **hash ;
  void *tmp ;
  int i ;

  {
#line 57
  count___0 = 0;
#line 58
  cl = list;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! cl) {
#line 60
      goto while_break;
    }
#line 61
    count___0 ++;
#line 62
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp = malloc(sizeof(struct val_list *) * (unsigned long )count___0);
#line 65
  hash = (struct val_list **)tmp;
#line 67
  i = 0;
#line 68
  cl = list;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! cl) {
#line 69
      goto while_break___0;
    }
#line 70
    *(hash + i) = cl;
#line 71
    cl = cl->next;
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 75
  list_quicksort(hash, 0, count___0 - 1);
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 76
    if (! (i < count___0 - 1)) {
#line 76
      goto while_break___1;
    }
#line 77
    (*(hash + i))->next = *(hash + (i + 1));
#line 76
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 79
  (*(hash + (count___0 - 1)))->next = (struct val_list *)((void *)0);
#line 80
  cl = *(hash + 0);
#line 81
  free((void *)hash);
  }
#line 82
  return (cl);
}
}
#line 498 "par.c"
static yytype_uint8 const   yytranslate[288]  = 
#line 498 "par.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )22,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )20,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )45,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )29,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41};
#line 593 "par.c"
static char const   * const  yytname[54]  = 
#line 593
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"NUMBER", 
        (char const   */* const  */)"VARIABLE",      (char const   */* const  */)"IN",      (char const   */* const  */)"DO",      (char const   */* const  */)"WHILE", 
        (char const   */* const  */)"ELSE",      (char const   */* const  */)"RANGE",      (char const   */* const  */)"\',\'",      (char const   */* const  */)"EQ", 
        (char const   */* const  */)"NE",      (char const   */* const  */)"LT",      (char const   */* const  */)"GT",      (char const   */* const  */)"LE", 
        (char const   */* const  */)"GE",      (char const   */* const  */)"\'+\'",      (char const   */* const  */)"\'-\'",      (char const   */* const  */)"\'.\'", 
        (char const   */* const  */)"\'*\'",      (char const   */* const  */)"\'/\'",      (char const   */* const  */)"\'%\'",      (char const   */* const  */)"SUM", 
        (char const   */* const  */)"PROD",      (char const   */* const  */)"COUNT",      (char const   */* const  */)"LOW",      (char const   */* const  */)"HIGH", 
        (char const   */* const  */)"\'#\'",      (char const   */* const  */)"\'^\'",      (char const   */* const  */)"DICE",      (char const   */* const  */)"PERM", 
        (char const   */* const  */)"SORT",      (char const   */* const  */)"REV",      (char const   */* const  */)"DROP",      (char const   */* const  */)"KEEP", 
        (char const   */* const  */)"FIRST",      (char const   */* const  */)"LAST",      (char const   */* const  */)"LET",      (char const   */* const  */)"FOREACH", 
        (char const   */* const  */)"IF",      (char const   */* const  */)"THEN",      (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'(\'", 
        (char const   */* const  */)"\')\'",      (char const   */* const  */)"\'=\'",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input", 
        (char const   */* const  */)"pexpr",      (char const   */* const  */)"expr",      (char const   */* const  */)"scalar",      (char const   */* const  */)"list", 
        (char const   */* const  */)"filter",      (char const   */* const  */)0};
#line 618 "par.c"
static yytype_uint8 const   yyr1[66]  = 
#line 618
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52};
#line 630 "par.c"
static yytype_uint8 const   yyr2[66]  = 
#line 630
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3};
#line 644 "par.c"
static yytype_uint8 const   yydefact[173]  = 
#line 644
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )31,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )50,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )56,      (yytype_uint8 const   )65,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )47,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )63,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )42,      (yytype_uint8 const   )36,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )52,      (yytype_uint8 const   )58,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )61,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )33,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )32};
#line 667 "par.c"
static yytype_int8 const   yydefgoto[7]  = {      (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )30, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33};
#line 675 "par.c"
static yytype_int16 const   yypact[173]  = 
#line 675
  {      (yytype_int16 const   )237,      (yytype_int16 const   )-5,      (yytype_int16 const   )-5,      (yytype_int16 const   )2, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )275,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )275,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )115,      (yytype_int16 const   )270,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )22,      (yytype_int16 const   )26,      (yytype_int16 const   )237,      (yytype_int16 const   )142, 
        (yytype_int16 const   )28,      (yytype_int16 const   )-5,      (yytype_int16 const   )30,      (yytype_int16 const   )306, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )-5,      (yytype_int16 const   )-1,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )275,      (yytype_int16 const   )17,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )0,      (yytype_int16 const   )36, 
        (yytype_int16 const   )6,      (yytype_int16 const   )-5,      (yytype_int16 const   )30,      (yytype_int16 const   )292, 
        (yytype_int16 const   )33,      (yytype_int16 const   )-5,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )275,      (yytype_int16 const   )275,      (yytype_int16 const   )275,      (yytype_int16 const   )275, 
        (yytype_int16 const   )275,      (yytype_int16 const   )275,      (yytype_int16 const   )275,      (yytype_int16 const   )237, 
        (yytype_int16 const   )275,      (yytype_int16 const   )237,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )54,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199, 
        (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )199,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )-5,      (yytype_int16 const   )-5,      (yytype_int16 const   )30, 
        (yytype_int16 const   )320,      (yytype_int16 const   )17,      (yytype_int16 const   )17,      (yytype_int16 const   )17, 
        (yytype_int16 const   )49,      (yytype_int16 const   )49,      (yytype_int16 const   )49,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )49,      (yytype_int16 const   )14,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )7,      (yytype_int16 const   )15, 
        (yytype_int16 const   )19,      (yytype_int16 const   )237,      (yytype_int16 const   )237,      (yytype_int16 const   )237, 
        (yytype_int16 const   )237,      (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )30, 
        (yytype_int16 const   )30};
#line 698 "par.c"
static yytype_int8 const   yypgoto[7]  = {      (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )-2,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )109,      (yytype_int8 const   )55,      (yytype_int8 const   )-5};
#line 708 "par.c"
static yytype_uint8 const   yytable[350]  = 
#line 708
  {      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )167,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )74,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )83,      (yytype_uint8 const   )75,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )126,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )125,      (yytype_uint8 const   )92,      (yytype_uint8 const   )127, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )104,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )110, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )113,      (yytype_uint8 const   )114, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )82,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )129,      (yytype_uint8 const   )92,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )0,      (yytype_uint8 const   )80,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )141,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )128,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )148,      (yytype_uint8 const   )149,      (yytype_uint8 const   )150, 
        (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )153,      (yytype_uint8 const   )154, 
        (yytype_uint8 const   )155,      (yytype_uint8 const   )156,      (yytype_uint8 const   )157,      (yytype_uint8 const   )158, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )160,      (yytype_uint8 const   )161,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )162,      (yytype_uint8 const   )163,      (yytype_uint8 const   )164, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )48,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )100,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )169,      (yytype_uint8 const   )170,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )172,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )77,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )140,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )83,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )84,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )0,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )128,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )92};
#line 747 "par.c"
static yytype_int16 const   yycheck[350]  = 
#line 747
  {      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )4,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )5,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )10,      (yytype_int16 const   )10,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )6,      (yytype_int16 const   )6,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )10,      (yytype_int16 const   )10,      (yytype_int16 const   )4,      (yytype_int16 const   )8, 
        (yytype_int16 const   )0,      (yytype_int16 const   )10,      (yytype_int16 const   )4,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )10,      (yytype_int16 const   )5,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )29,      (yytype_int16 const   )41, 
        (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55, 
        (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )65,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )42,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )44,      (yytype_int16 const   )29,      (yytype_int16 const   )83, 
        (yytype_int16 const   )82,      (yytype_int16 const   )-1,      (yytype_int16 const   )27,      (yytype_int16 const   )29, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )91, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )93,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )44,      (yytype_int16 const   )103, 
        (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )106,      (yytype_int16 const   )107, 
        (yytype_int16 const   )108,      (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )111, 
        (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )115, 
        (yytype_int16 const   )116,      (yytype_int16 const   )117,      (yytype_int16 const   )118,      (yytype_int16 const   )119, 
        (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )122,      (yytype_int16 const   )10, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )125,      (yytype_int16 const   )126,      (yytype_int16 const   )127, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )16,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )41,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )18,      (yytype_int16 const   )165,      (yytype_int16 const   )166,      (yytype_int16 const   )167, 
        (yytype_int16 const   )168,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )84,      (yytype_int16 const   )85,      (yytype_int16 const   )86, 
        (yytype_int16 const   )87,      (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )90, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )92,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )43,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )7,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )-1,      (yytype_int16 const   )18, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )43,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )9,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )9, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )-1,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )44,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )29};
#line 788 "par.c"
static yytype_uint8 const   yystos[173]  = 
#line 788
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )4,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )43,      (yytype_uint8 const   )50,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )44,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )0,      (yytype_uint8 const   )42,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )45,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )45,      (yytype_uint8 const   )5,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49};
#line 1088 "par.c"
static unsigned long yystrlen(char const   *yystr ) 
{ 
  unsigned long yylen ;

  {
#line 1097
  yylen = 0UL;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! *(yystr + yylen)) {
#line 1097
      goto while_break;
    }
#line 1098
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1097
    yylen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  return (yylen);
}
}
#line 1112 "par.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1121
  yyd = yydest;
#line 1122
  yys = yysrc;
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1124
    tmp = yyd;
#line 1124
    yyd ++;
#line 1124
    tmp___1 = yys;
#line 1124
    yys ++;
#line 1124
    tmp___0 = (char )*tmp___1;
#line 1124
    *tmp = tmp___0;
#line 1124
    if (! ((int )tmp___0 != 0)) {
#line 1124
      goto while_break;
    }
#line 1125
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  return (yyd - 1);
}
}
#line 1140 "par.c"
static unsigned long yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned long yyn ;
  char const   *yyp ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 1143
  if ((int const   )*yystr == 34) {
#line 1145
    yyn = 0UL;
#line 1146
    yyp = yystr;
    {
#line 1148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1149
      yyp ++;
      {
#line 1152
      if ((int const   )*yyp == 44) {
#line 1152
        goto case_44;
      }
#line 1152
      if ((int const   )*yyp == 39) {
#line 1152
        goto case_44;
      }
#line 1155
      if ((int const   )*yyp == 92) {
#line 1155
        goto case_92;
      }
#line 1165
      if ((int const   )*yyp == 34) {
#line 1165
        goto case_34;
      }
#line 1159
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1153
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1156
      yyp ++;
#line 1156
      if ((int const   )*yyp != 92) {
#line 1157
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1160
      if (yyres) {
#line 1161
        *(yyres + yyn) = (char )*yyp;
      }
#line 1162
      yyn ++;
#line 1163
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1166
      if (yyres) {
#line 1167
        *(yyres + yyn) = (char )'\000';
      }
#line 1168
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1173
  if (! yyres) {
    {
#line 1174
    tmp = yystrlen(yystr);
    }
#line 1174
    return (tmp);
  }
  {
#line 1176
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 1176
  return ((unsigned long )(tmp___0 - yyres));
}
}
#line 1216
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar___0 ) ;
#line 1216 "par.c"
static char const   yyunexpected[28]  = 
#line 1216
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1217 "par.c"
static char const   yyexpecting[15]  = 
#line 1217
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1218 "par.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1187 "par.c"
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar___0 ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned long yysize0 ;
  unsigned long tmp___0 ;
  unsigned long yysize ;
  unsigned long yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char tmp___8 ;

  {
#line 1190
  yyn = (int )yypact[yystate];
#line 1192
  if (-5 < yyn) {
#line 1192
    if (yyn <= 349) {
#line 1196
      if ((unsigned int )yychar___0 <= 287U) {
#line 1196
        tmp = (int const   )yytranslate[yychar___0];
      } else {
#line 1196
        tmp = (int const   )2;
      }
      {
#line 1196
      yytype = (int )tmp;
#line 1197
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1197
      yysize0 = tmp___0;
#line 1198
      yysize = yysize0;
#line 1200
      yysize_overflow = 0;
#line 1223
      yyprefix = yyexpecting;
      }
#line 1227
      if (yyn < 0) {
#line 1227
        tmp___1 = - yyn;
      } else {
#line 1227
        tmp___1 = 0;
      }
#line 1227
      yyxbegin = tmp___1;
#line 1230
      yychecklim = (349 - yyn) + 1;
#line 1231
      if (yychecklim < 46) {
#line 1231
        tmp___2 = yychecklim;
      } else {
#line 1231
        tmp___2 = 46;
      }
      {
#line 1231
      yyxend = tmp___2;
#line 1232
      yycount = 1;
#line 1234
      yyarg[0] = (char const   *)yytname[yytype];
#line 1235
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1237
      yyx = yyxbegin;
      }
      {
#line 1237
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1237
        if (! (yyx < yyxend)) {
#line 1237
          goto while_break;
        }
#line 1238
        if ((int const   )yycheck[yyx + yyn] == (int const   )yyx) {
#line 1238
          if (yyx != 1) {
#line 1240
            if (yycount == 5) {
#line 1242
              yycount = 1;
#line 1243
              yysize = yysize0;
#line 1244
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1245
              goto while_break;
            }
            {
#line 1247
            tmp___3 = yycount;
#line 1247
            yycount ++;
#line 1247
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1248
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1248
            yysize1 = yysize + tmp___4;
#line 1249
            yysize_overflow |= yysize1 < yysize;
#line 1250
            yysize = yysize1;
#line 1251
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1252
            yyprefix = yyor;
            }
          }
        }
#line 1237
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1255
      yyf = (char const   *)(yyformat);
#line 1256
      tmp___5 = yystrlen(yyf);
#line 1256
      yysize1 = yysize + tmp___5;
#line 1257
      yysize_overflow |= yysize1 < yysize;
#line 1258
      yysize = yysize1;
      }
#line 1260
      if (yysize_overflow) {
#line 1261
        return (0xffffffffffffffffUL);
      }
#line 1263
      if (yyresult) {
#line 1268
        yyp = yyresult;
#line 1269
        yyi = 0;
        {
#line 1270
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1270
          tmp___8 = (char )*yyf;
#line 1270
          *yyp = tmp___8;
#line 1270
          if (! ((int )tmp___8 != 0)) {
#line 1270
            goto while_break___0;
          }
#line 1272
          if ((int )*yyp == 37) {
#line 1272
            if ((int const   )*(yyf + 1) == 115) {
#line 1272
              if (yyi < yycount) {
                {
#line 1274
                tmp___6 = yyi;
#line 1274
                yyi ++;
#line 1274
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1274
                yyp += tmp___7;
#line 1275
                yyf += 2;
                }
              } else {
#line 1279
                yyp ++;
#line 1280
                yyf ++;
              }
            } else {
#line 1279
              yyp ++;
#line 1280
              yyf ++;
            }
          } else {
#line 1279
            yyp ++;
#line 1280
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1284
      return (yysize);
    } else {
#line 1193
      return (0UL);
    }
  } else {
#line 1193
    return (0UL);
  }
}
}
#line 1297 "par.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1309
  if (! yymsg) {
#line 1310
    yymsg = "Deleting";
  }
  {
#line 1316
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1317
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1319
  return;
}
}
#line 1332
int yyparse(void) ;
#line 1341 "par.c"
int yychar  ;
#line 1344 "par.c"
YYSTYPE yylval  ;
#line 1347 "par.c"
int yynerrs  ;
#line 1368 "par.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned long yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int i ;
  struct symtab *st ;
  struct roll_value *rv ;
  struct roll_value *tmp___0 ;
  struct symtab *st___0 ;
  struct val_list *vl ;
  struct val_list *tmp___1 ;
  struct val_list *cl ;
  int i___0 ;
  struct result_node *rl ;
  struct symtab *st___1 ;
  struct roll_value *rv___0 ;
  struct roll_value *tmp___2 ;
  struct result_node *cl___0 ;
  int sum___0 ;
  float fprob ;
  struct result_node *old ;
  unsigned long yysize___0 ;
  unsigned long tmp___3 ;
  unsigned long yyalloc___0 ;
  void *tmp___4 ;

  {
#line 1384
  yytoken = 0;
#line 1388
  yymsg = yymsgbuf;
#line 1389
  yymsg_alloc = sizeof(yymsgbuf);
#line 1402
  yyss = yyssa;
#line 1407
  yyvs = yyvsa;
#line 1414
  yystacksize = 200UL;
#line 1423
  yylen = 0;
#line 1427
  yystate = 0;
#line 1428
  yyerrstatus = 0;
#line 1429
  yynerrs = 0;
#line 1430
  yychar = -2;
#line 1437
  yyssp = yyss;
#line 1438
  yyvsp = yyvs;
#line 1440
  goto yysetstate;
  yynewstate: 
#line 1448
  yyssp ++;
  yysetstate: 
#line 1451
  *yyssp = (yytype_int16 )yystate;
#line 1453
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1456
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1485
    if (10000UL <= yystacksize) {
#line 1486
      goto yyexhaustedlab;
    }
#line 1487
    yystacksize *= 2UL;
#line 1488
    if (10000UL < yystacksize) {
#line 1489
      yystacksize = 10000UL;
    }
    {
#line 1492
    yyss1 = yyss;
#line 1493
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1493
    yyptr = (union yyalloc *)tmp;
    }
#line 1495
    if (! yyptr) {
#line 1496
      goto yyexhaustedlab;
    }
    {
#line 1497
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1497
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1497
      yyss = & yyptr->yyss;
#line 1497
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1497
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1497
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1498
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1498
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1498
      yyvs = & yyptr->yyvs;
#line 1498
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1498
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1498
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1501
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1502
      free((void *)yyss1);
      }
    }
#line 1507
    yyssp = (yyss + yysize) - 1;
#line 1508
    yyvsp = (yyvs + yysize) - 1;
#line 1514
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1515
      goto yyabortlab;
    }
  }
#line 1520
  goto yybackup;
  yybackup: 
#line 1531
  yyn = (int )yypact[yystate];
#line 1532
  if (yyn == -5) {
#line 1533
    goto yydefault;
  }
#line 1538
  if (yychar == -2) {
    {
#line 1541
    yychar = yylex();
    }
  }
#line 1544
  if (yychar <= 0) {
#line 1546
    yytoken = 0;
#line 1546
    yychar = yytoken;
  } else
#line 1551
  if ((unsigned int )yychar <= 287U) {
#line 1551
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1551
    yytoken = 2;
  }
#line 1557
  yyn += yytoken;
#line 1558
  if (yyn < 0) {
#line 1559
    goto yydefault;
  } else
#line 1558
  if (349 < yyn) {
#line 1559
    goto yydefault;
  } else
#line 1558
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1559
    goto yydefault;
  }
#line 1560
  yyn = (int )yytable[yyn];
#line 1561
  if (yyn <= 0) {
#line 1563
    if (yyn == 0) {
#line 1564
      goto yyerrlab;
    } else
#line 1563
    if (yyn == -1) {
#line 1564
      goto yyerrlab;
    }
#line 1565
    yyn = - yyn;
#line 1566
    goto yyreduce;
  }
#line 1569
  if (yyn == 81) {
#line 1570
    goto yyacceptlab;
  }
#line 1574
  if (yyerrstatus) {
#line 1575
    yyerrstatus --;
  }
#line 1581
  if (yychar != 0) {
#line 1582
    yychar = -2;
  }
#line 1584
  yystate = yyn;
#line 1585
  yyvsp ++;
#line 1585
  *yyvsp = yylval;
#line 1587
  goto yynewstate;
  yydefault: 
#line 1594
  yyn = (int )yydefact[yystate];
#line 1595
  if (yyn == 0) {
#line 1596
    goto yyerrlab;
  }
#line 1597
  goto yyreduce;
  yyreduce: 
#line 1605
  yylen = (int )yyr2[yyn];
#line 1615
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1621
  if (yyn == 5) {
#line 1621
    goto case_5;
  }
#line 193
  if (yyn == 6) {
#line 193 "par.y"
    goto case_6;
  }
#line 196
  if (yyn == 7) {
#line 196
    goto case_7;
  }
#line 197
  if (yyn == 8) {
#line 197
    goto case_8;
  }
#line 200
  if (yyn == 9) {
#line 200
    goto case_9;
  }
#line 201
  if (yyn == 10) {
#line 201
    goto case_10;
  }
#line 202
  if (yyn == 11) {
#line 202
    goto case_11;
  }
#line 203
  if (yyn == 12) {
#line 203
    goto case_12;
  }
#line 204
  if (yyn == 13) {
#line 204
    goto case_13;
  }
#line 205
  if (yyn == 14) {
#line 205
    goto case_14;
  }
#line 206
  if (yyn == 15) {
#line 206
    goto case_15;
  }
#line 207
  if (yyn == 16) {
#line 207
    goto case_16;
  }
#line 208
  if (yyn == 17) {
#line 208
    goto case_17;
  }
#line 209
  if (yyn == 18) {
#line 209
    goto case_18;
  }
#line 210
  if (yyn == 19) {
#line 210
    goto case_19;
  }
#line 211
  if (yyn == 20) {
#line 211
    goto case_20;
  }
#line 212
  if (yyn == 21) {
#line 212
    goto case_21;
  }
#line 213
  if (yyn == 22) {
#line 213
    goto case_22;
  }
#line 214
  if (yyn == 23) {
#line 214
    goto case_23;
  }
#line 217
  if (yyn == 24) {
#line 217
    goto case_24;
  }
#line 218
  if (yyn == 25) {
#line 218
    goto case_25;
  }
#line 219
  if (yyn == 26) {
#line 219
    goto case_26;
  }
#line 220
  if (yyn == 27) {
#line 220
    goto case_27;
  }
#line 221
  if (yyn == 28) {
#line 221
    goto case_28;
  }
#line 222
  if (yyn == 29) {
#line 222
    goto case_29;
  }
#line 223
  if (yyn == 30) {
#line 223
    goto case_30;
  }
#line 224
  if (yyn == 31) {
#line 224
    goto case_31;
  }
#line 225
  if (yyn == 32) {
#line 225
    goto case_32;
  }
#line 226
  if (yyn == 33) {
#line 226
    goto case_33;
  }
#line 227
  if (yyn == 34) {
#line 227
    goto case_34;
  }
#line 228
  if (yyn == 35) {
#line 228
    goto case_35;
  }
#line 229
  if (yyn == 36) {
#line 229
    goto case_36;
  }
#line 232
  if (yyn == 37) {
#line 232
    goto case_37;
  }
#line 233
  if (yyn == 38) {
#line 233
    goto case_38;
  }
#line 234
  if (yyn == 39) {
#line 234
    goto case_39;
  }
#line 235
  if (yyn == 40) {
#line 235
    goto case_40;
  }
#line 236
  if (yyn == 41) {
#line 236
    goto case_41;
  }
#line 237
  if (yyn == 42) {
#line 237
    goto case_42;
  }
#line 238
  if (yyn == 43) {
#line 238
    goto case_43;
  }
#line 239
  if (yyn == 44) {
#line 239
    goto case_44;
  }
#line 240
  if (yyn == 45) {
#line 240
    goto case_45;
  }
#line 241
  if (yyn == 46) {
#line 241
    goto case_46;
  }
#line 242
  if (yyn == 47) {
#line 242
    goto case_47;
  }
#line 243
  if (yyn == 48) {
#line 243
    goto case_48;
  }
#line 244
  if (yyn == 49) {
#line 244
    goto case_49;
  }
#line 245
  if (yyn == 50) {
#line 245
    goto case_50;
  }
#line 246
  if (yyn == 51) {
#line 246
    goto case_51;
  }
#line 247
  if (yyn == 52) {
#line 247
    goto case_52;
  }
#line 248
  if (yyn == 53) {
#line 248
    goto case_53;
  }
#line 249
  if (yyn == 54) {
#line 249
    goto case_54;
  }
#line 250
  if (yyn == 55) {
#line 250
    goto case_55;
  }
#line 251
  if (yyn == 56) {
#line 251
    goto case_56;
  }
#line 252
  if (yyn == 57) {
#line 252
    goto case_57;
  }
#line 253
  if (yyn == 58) {
#line 253
    goto case_58;
  }
#line 254
  if (yyn == 59) {
#line 254
    goto case_59;
  }
#line 255
  if (yyn == 60) {
#line 255
    goto case_60;
  }
#line 256
  if (yyn == 61) {
#line 256
    goto case_61;
  }
#line 257
  if (yyn == 62) {
#line 257
    goto case_62;
  }
#line 258
  if (yyn == 63) {
#line 258
    goto case_63;
  }
#line 259
  if (yyn == 64) {
#line 259
    goto case_64;
  }
#line 260
  if (yyn == 65) {
#line 260
    goto case_65;
  }
#line 1997 "par.c"
  goto switch_default;
  case_5: /* CIL Label */ 
#line 123
  if (cmd_parse_tree) {
    {
#line 124 "par.y"
    (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->printtree_v__))((yyvsp + 0)->expr,
                                                                                      0);
    }
  }
#line 126
  if (cmd_roll) {
    {
#line 128
    st = (struct symtab *)((void *)0);
#line 129
    (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->set_symtab_v__))((yyvsp + 0)->expr,
                                                                                       st);
#line 130
    tmp___0 = (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->roll_v__))((yyvsp + 0)->expr);
#line 130
    rv = tmp___0;
#line 131
    i = 0;
    }
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      if (! (i < rv->count)) {
#line 131
        goto while_break___1;
      }
      {
#line 132
      printf((char const   */* __restrict  */)"%i ", *(rv->values + i));
#line 131
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 134
    printf((char const   */* __restrict  */)"\n");
#line 135
    free_roll(rv);
    }
  }
#line 137
  if (cmd_calc) {
    {
#line 138
    st___0 = (struct symtab *)((void *)0);
#line 139
    (yyvsp + 0)->expr = (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->optimize_v__))((yyvsp + 0)->expr);
#line 140
    (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->set_symtab_v__))((yyvsp + 0)->expr,
                                                                                       st___0);
#line 142
    (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->set_ordering_v__))((yyvsp + 0)->expr,
                                                                                         (ordering_type )0);
#line 143
    tmp___1 = (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->eval_v__))((yyvsp + 0)->expr);
#line 143
    vl = tmp___1;
#line 144
    vl = list_sort(vl);
#line 144
    cl = vl;
    }
    {
#line 145
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 145
      if (! cl) {
#line 145
        goto while_break___2;
      }
#line 146
      if (cl->count != 1) {
        {
#line 147
        yyerror((char *)"result is not scalar");
        }
#line 148
        goto while_break___2;
      }
      {
#line 151
      printf((char const   */* __restrict  */)"%3i\t%0.6f\t\n", *(cl->values + 0),
             cl->prob);
#line 152
      cl = cl->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 154
    list_free(vl);
    }
  }
#line 156
  if (cmd_rolleval) {
#line 158
    rl = (struct result_node *)((void *)0);
#line 159
    i___0 = 0;
    {
#line 159
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 159
      if (! (i___0 < cmd_count)) {
#line 159
        goto while_break___3;
      }
      {
#line 160
      st___1 = (struct symtab *)((void *)0);
#line 161
      (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->set_symtab_v__))((yyvsp + 0)->expr,
                                                                                         st___1);
#line 162
      tmp___2 = (*(((struct expression_vtable__ *)((yyvsp + 0)->expr)->vtable__)->roll_v__))((yyvsp + 0)->expr);
#line 162
      rv___0 = tmp___2;
      }
#line 163
      if (rv___0->count != 1) {
        {
#line 164
        yyerror((char *)"Result not a single value");
#line 165
        free_roll(rv___0);
        }
#line 166
        goto while_break___3;
      }
      {
#line 168
      result_add(& rl, *(rv___0->values + 0));
#line 169
      free_roll(rv___0);
#line 159
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 172
    cl___0 = rl;
#line 173
    sum___0 = 0;
    {
#line 174
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 174
      if (! ((unsigned long )cl___0 != (unsigned long )((void *)0))) {
#line 174
        goto while_break___4;
      }
#line 175
      sum___0 += cl___0->prob;
#line 176
      cl___0 = cl___0->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 178
    cl___0 = rl;
    {
#line 179
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 179
      if (! ((unsigned long )cl___0 != (unsigned long )((void *)0))) {
#line 179
        goto while_break___5;
      }
      {
#line 181
      fprob = (float )(1.0 * (double )cl___0->prob);
#line 182
      fprob /= (float )sum___0;
#line 184
      printf((char const   */* __restrict  */)"%3i\t%0.6f\n", cl___0->value, (double )fprob);
#line 185
      old = cl___0;
#line 186
      cl___0 = cl___0->next;
#line 187
      free((void *)old);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 191
  goto switch_break;
  case_6: /* CIL Label */ 
#line 193
  yyval.expr = (yyvsp + 0)->expr;
#line 194
  goto switch_break;
  case_7: /* CIL Label */ 
#line 194
  yyval.expr = (yyvsp + 0)->expr;
#line 195
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 197
  yyval.expr = number_create((yyvsp + 0)->ival);
  }
#line 198
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 198
  yyval.expr = variable_create((yyvsp + 0)->tval);
  }
#line 199
  goto switch_break;
  case_10: /* CIL Label */ 
#line 199
  yyval.expr = (yyvsp + -1)->expr;
#line 200
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 200
  yyval.expr = negate_create((yyvsp + 0)->expr);
  }
#line 201
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 201
  yyval.expr = plus_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 202
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 202
  yyval.expr = minus_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 203
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 203
  yyval.expr = multi_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 204
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 204
  yyval.expr = divi_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 205
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 205
  yyval.expr = mod_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 206
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 206
  yyval.expr = expo_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 207
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 207
  yyval.expr = scat_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 208
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 208
  yyval.expr = dice_create((yyvsp + 0)->expr);
  }
#line 209
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 209
  yyval.expr = sum_create((yyvsp + 0)->expr);
  }
#line 210
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 210
  yyval.expr = prod_create((yyvsp + 0)->expr);
  }
#line 211
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 211
  yyval.expr = count_create((yyvsp + 0)->expr);
  }
#line 212
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 214
  yyval.expr = rep_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 215
  goto switch_break;
  case_24: /* CIL Label */ 
#line 215
  yyval.expr = (yyvsp + -1)->expr;
#line 216
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 216
  yyval.expr = elist_create();
  }
#line 217
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 217
  yyval.expr = range_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 218
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 218
  yyval.expr = lcat_create((yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 219
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 219
  yyval.expr = perm_create((yyvsp + 0)->expr);
  }
#line 220
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 220
  yyval.expr = sort_create((yyvsp + 0)->expr);
  }
#line 221
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 221
  yyval.expr = rev_create((yyvsp + 0)->expr);
  }
#line 222
  goto switch_break;
  case_31: /* CIL Label */ 
#line 222
  yyval.expr = (yyvsp + 0)->expr;
#line 223
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 223
  yyval.expr = ifthenelse_create((yyvsp + -4)->expr, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 224
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 224
  yyval.expr = let_create((yyvsp + -2)->expr, (yyvsp + 0)->expr, (yyvsp + -4)->tval);
  }
#line 225
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 225
  yyval.expr = whiledo_create((yyvsp + -2)->expr, (yyvsp + 0)->expr, (yyvsp + -4)->tval);
  }
#line 226
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 226
  yyval.expr = foreach_create((yyvsp + -2)->expr, (yyvsp + 0)->expr, (yyvsp + -4)->tval);
  }
#line 227
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 229
  yyval.expr = first_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0);
  }
#line 230
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 230
  yyval.expr = first_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 231
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 231
  yyval.expr = first_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 232
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 232
  yyval.expr = last_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0);
  }
#line 233
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 233
  yyval.expr = last_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 234
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 234
  yyval.expr = last_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 235
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 235
  yyval.expr = high_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0);
  }
#line 236
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 236
  yyval.expr = high_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 237
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 237
  yyval.expr = high_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 238
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 238
  yyval.expr = low_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0);
  }
#line 239
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 239
  yyval.expr = low_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 240
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 240
  yyval.expr = low_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1);
  }
#line 241
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 241
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )0);
  }
#line 242
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 242
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )0);
  }
#line 243
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 243
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )0);
  }
#line 244
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 244
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )1);
  }
#line 245
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 245
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )1);
  }
#line 246
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 246
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )1);
  }
#line 247
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 247
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )3);
  }
#line 248
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 248
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )3);
  }
#line 249
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 249
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )3);
  }
#line 250
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 250
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )2);
  }
#line 251
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 251
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )2);
  }
#line 252
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 252
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )2);
  }
#line 253
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 253
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )5);
  }
#line 254
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 254
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )5);
  }
#line 255
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 255
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )5);
  }
#line 256
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 256
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )0,
                                 (comparison_type )4);
  }
#line 257
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 257
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )4);
  }
#line 258
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 258
  yyval.expr = comparison_create((yyvsp + -1)->expr, (yyvsp + 0)->expr, (filter_type )1,
                                 (comparison_type )4);
  }
#line 259
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1997 "par.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2001
  yyvsp -= yylen;
#line 2001
  yyssp -= yylen;
#line 2002
  yylen = 0;
#line 2005
  yyvsp ++;
#line 2005
  *yyvsp = yyval;
#line 2012
  yyn = (int )yyr1[yyn];
#line 2014
  yystate = (int )((int const   )yypgoto[yyn - 46] + (int const   )*yyssp);
#line 2015
  if (0 <= yystate) {
#line 2015
    if (yystate <= 349) {
#line 2015
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2016
        yystate = (int )yytable[yystate];
      } else {
#line 2018
        yystate = (int )yydefgoto[yyn - 46];
      }
    } else {
#line 2018
      yystate = (int )yydefgoto[yyn - 46];
    }
  } else {
#line 2018
    yystate = (int )yydefgoto[yyn - 46];
  }
#line 2020
  goto yynewstate;
  yyerrlab: 
#line 2028
  if (! yyerrstatus) {
    {
#line 2030
    yynerrs ++;
#line 2035
    tmp___3 = yysyntax_error((char *)0, yystate, yychar);
#line 2035
    yysize___0 = tmp___3;
    }
#line 2036
    if (yymsg_alloc < yysize___0) {
#line 2036
      if (yymsg_alloc < 0xffffffffffffffffUL) {
#line 2038
        yyalloc___0 = 2UL * yysize___0;
#line 2039
        if (yysize___0 <= yyalloc___0) {
#line 2039
          if (! (yyalloc___0 <= 0xffffffffffffffffUL)) {
#line 2040
            yyalloc___0 = 0xffffffffffffffffUL;
          }
        } else {
#line 2040
          yyalloc___0 = 0xffffffffffffffffUL;
        }
#line 2041
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 2042
          free((void *)yymsg);
          }
        }
        {
#line 2043
        tmp___4 = malloc(yyalloc___0);
#line 2043
        yymsg = (char *)tmp___4;
        }
#line 2044
        if (yymsg) {
#line 2045
          yymsg_alloc = yyalloc___0;
        } else {
#line 2048
          yymsg = yymsgbuf;
#line 2049
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 2053
    if (0UL < yysize___0) {
#line 2053
      if (yysize___0 <= yymsg_alloc) {
        {
#line 2055
        yysyntax_error(yymsg, yystate, yychar);
#line 2056
        yyerror(yymsg);
        }
      } else {
#line 2053
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2060
      yyerror((char *)"syntax error");
      }
#line 2061
      if (yysize___0 != 0UL) {
#line 2062
        goto yyexhaustedlab;
      }
    }
  }
#line 2070
  if (yyerrstatus == 3) {
#line 2075
    if (yychar <= 0) {
#line 2078
      if (yychar == 0) {
#line 2079
        goto yyabortlab;
      }
    } else {
      {
#line 2083
      yydestruct("Error: discarding", yytoken, & yylval);
#line 2085
      yychar = -2;
      }
    }
  }
#line 2091
  goto yyerrlab1;
#line 2107
  yyvsp -= yylen;
#line 2107
  yyssp -= yylen;
#line 2108
  yylen = 0;
#line 2110
  yystate = (int )*yyssp;
#line 2111
  goto yyerrlab1;
  yyerrlab1: 
#line 2118
  yyerrstatus = 3;
  {
#line 2120
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2122
    yyn = (int )yypact[yystate];
#line 2123
    if (yyn != -5) {
#line 2125
      yyn ++;
#line 2126
      if (0 <= yyn) {
#line 2126
        if (yyn <= 349) {
#line 2126
          if ((int const   )yycheck[yyn] == 1) {
#line 2128
            yyn = (int )yytable[yyn];
#line 2129
            if (0 < yyn) {
#line 2130
              goto while_break___6;
            }
          }
        }
      }
    }
#line 2135
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2136
      goto yyabortlab;
    }
    {
#line 2139
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2141
    yyvsp --;
#line 2141
    yyssp --;
#line 2142
    yystate = (int )*yyssp;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2146
  if (yyn == 81) {
#line 2147
    goto yyacceptlab;
  }
#line 2149
  yyvsp ++;
#line 2149
  *yyvsp = yylval;
#line 2155
  yystate = yyn;
#line 2156
  goto yynewstate;
  yyacceptlab: 
#line 2163
  yyresult = 0;
#line 2164
  goto yyreturn;
  yyabortlab: 
#line 2170
  yyresult = 1;
#line 2171
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2178
  yyerror((char *)"memory exhausted");
#line 2179
  yyresult = 2;
  }
  yyreturn: 
#line 2184
  if (yychar != 0) {
#line 2184
    if (yychar != -2) {
      {
#line 2185
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
#line 2189
  yyvsp -= yylen;
#line 2189
  yyssp -= yylen;
  {
#line 2191
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2191
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2191
      goto while_break___7;
    }
    {
#line 2193
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2195
    yyvsp --;
#line 2195
    yyssp --;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2198
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2199
    free((void *)yyss);
    }
  }
#line 2202
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2203
    free((void *)yymsg);
    }
  }
#line 2206
  return (yyresult);
}
}
#line 262 "par.y"
int yyerror(char *s ) 
{ 
  long tmp ;
  char *tmp___0 ;

  {
  {
#line 263
  tmp = yycurrlinenum();
#line 263
  tmp___0 = yycurrfilename();
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%li %s\n",
          tmp___0, tmp, s);
  }
#line 264
  return (1);
}
}
#line 267
int yylineno ;
#line 269 "par.y"
long yycurrlinenum(void) 
{ 


  {
#line 270
  return ((long )yylineno);
}
}
#line 273 "par.y"
char *yycurrfilename(void) 
{ 


  {
#line 274
  return (filename);
}
}
#line 277 "par.y"
void yynodefailed(void) 
{ 


  {
  {
#line 278
  exit(1);
  }
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 165 "lex.c"
int yyleng  ;
#line 167
FILE *yyin ;
#line 167
FILE *yyout ;
#line 275 "lex.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 276 "lex.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 277 "lex.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 295 "lex.c"
static char yy_hold_char  ;
#line 296 "lex.c"
static int yy_n_chars  ;
#line 300 "lex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 301 "lex.c"
static int yy_init  =    0;
#line 302 "lex.c"
static int yy_start  =    0;
#line 307 "lex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 309
void yyrestart(FILE *input_file ) ;
#line 310
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 311
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 312
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 313
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 314
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 315
void yypop_buffer_state(void) ;
#line 317
static void yyensure_buffer_stack(void) ;
#line 318
static void yy_load_buffer_state(void) ;
#line 319
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 323
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 324
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 325
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 327
void *yyalloc(yy_size_t size ) ;
#line 328
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 329
void yyfree(void *ptr ) ;
#line 360 "lex.c"
FILE *yyin  =    (FILE *)0;
#line 360 "lex.c"
FILE *yyout  =    (FILE *)0;
#line 366 "lex.c"
int yylineno  =    1;
#line 368 "lex.c"
char *yytext  ;
#line 371
static yy_state_type yy_get_previous_state(void) ;
#line 372
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 373
static int yy_get_next_buffer(void) ;
#line 374
static void yy_fatal_error(char const   *msg ) ;
#line 395 "lex.c"
static flex_int16_t const   yy_accept[102]  = 
#line 395
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )37, 
        (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )3, 
        (flex_int16_t const   )29,      (flex_int16_t const   )35,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )4,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )34,      (flex_int16_t const   )2,      (flex_int16_t const   )34, 
        (flex_int16_t const   )33,      (flex_int16_t const   )26,      (flex_int16_t const   )31,      (flex_int16_t const   )1, 
        (flex_int16_t const   )3,      (flex_int16_t const   )27,      (flex_int16_t const   )25,      (flex_int16_t const   )28, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )21,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )34,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )1,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )17,      (flex_int16_t const   )13,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )10,      (flex_int16_t const   )32,      (flex_int16_t const   )5, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )11, 
        (flex_int16_t const   )24,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )14, 
        (flex_int16_t const   )12,      (flex_int16_t const   )16,      (flex_int16_t const   )8,      (flex_int16_t const   )6, 
        (flex_int16_t const   )9,      (flex_int16_t const   )23,      (flex_int16_t const   )32,      (flex_int16_t const   )7, 
        (flex_int16_t const   )15,      (flex_int16_t const   )32,      (flex_int16_t const   )18,      (flex_int16_t const   )32, 
        (flex_int16_t const   )19,      (flex_int16_t const   )0};
#line 411 "lex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 411
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )15,      (flex_int32_t const   )14,      (flex_int32_t const   )16, 
        (flex_int32_t const   )17,      (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20, 
        (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )14,      (flex_int32_t const   )23, 
        (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )14,      (flex_int32_t const   )29,      (flex_int32_t const   )30, 
        (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )33,      (flex_int32_t const   )34, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 443 "lex.c"
static flex_int32_t const   yy_meta[35]  = 
#line 443
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3};
#line 451 "lex.c"
static flex_int16_t const   yy_base[105]  = 
#line 451
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )136, 
        (flex_int16_t const   )137,      (flex_int16_t const   )34,      (flex_int16_t const   )39,      (flex_int16_t const   )43, 
        (flex_int16_t const   )123,      (flex_int16_t const   )126,      (flex_int16_t const   )124,      (flex_int16_t const   )122, 
        (flex_int16_t const   )119,      (flex_int16_t const   )118,      (flex_int16_t const   )117,      (flex_int16_t const   )0, 
        (flex_int16_t const   )101,      (flex_int16_t const   )22,      (flex_int16_t const   )103,      (flex_int16_t const   )28, 
        (flex_int16_t const   )104,      (flex_int16_t const   )33,      (flex_int16_t const   )107,      (flex_int16_t const   )38, 
        (flex_int16_t const   )39,      (flex_int16_t const   )106,      (flex_int16_t const   )31,      (flex_int16_t const   )102, 
        (flex_int16_t const   )101,      (flex_int16_t const   )67,      (flex_int16_t const   )0,      (flex_int16_t const   )73, 
        (flex_int16_t const   )77,      (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )0, 
        (flex_int16_t const   )111,      (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )137, 
        (flex_int16_t const   )0,      (flex_int16_t const   )88,      (flex_int16_t const   )0,      (flex_int16_t const   )92, 
        (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )87,      (flex_int16_t const   )95, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )96,      (flex_int16_t const   )83, 
        (flex_int16_t const   )81,      (flex_int16_t const   )77,      (flex_int16_t const   )81,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )78,      (flex_int16_t const   )81,      (flex_int16_t const   )87, 
        (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )77,      (flex_int16_t const   )74,      (flex_int16_t const   )83, 
        (flex_int16_t const   )70,      (flex_int16_t const   )81,      (flex_int16_t const   )77,      (flex_int16_t const   )69, 
        (flex_int16_t const   )65,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )70, 
        (flex_int16_t const   )76,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )0, 
        (flex_int16_t const   )61,      (flex_int16_t const   )49,      (flex_int16_t const   )36,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )35,      (flex_int16_t const   )49,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )44,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )0,      (flex_int16_t const   )39, 
        (flex_int16_t const   )0,      (flex_int16_t const   )137,      (flex_int16_t const   )51,      (flex_int16_t const   )88, 
        (flex_int16_t const   )91};
#line 467 "lex.c"
static flex_int16_t const   yy_def[105]  = 
#line 467
  {      (flex_int16_t const   )0,      (flex_int16_t const   )101,      (flex_int16_t const   )1,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )101,      (flex_int16_t const   )103,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )104, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )101,      (flex_int16_t const   )103,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )0,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101};
#line 483 "lex.c"
static flex_int16_t const   yy_nxt[172]  = 
#line 483
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )5,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )4, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19, 
        (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22, 
        (flex_int16_t const   )23,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )28,      (flex_int16_t const   )29, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )42,      (flex_int16_t const   )45,      (flex_int16_t const   )43, 
        (flex_int16_t const   )48,      (flex_int16_t const   )51,      (flex_int16_t const   )40,      (flex_int16_t const   )46, 
        (flex_int16_t const   )52,      (flex_int16_t const   )54,      (flex_int16_t const   )57,      (flex_int16_t const   )49, 
        (flex_int16_t const   )100,      (flex_int16_t const   )99,      (flex_int16_t const   )98,      (flex_int16_t const   )58, 
        (flex_int16_t const   )97,      (flex_int16_t const   )53,      (flex_int16_t const   )96,      (flex_int16_t const   )95, 
        (flex_int16_t const   )55,      (flex_int16_t const   )61,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )94,      (flex_int16_t const   )62,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )61, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )93, 
        (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )92,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )91,      (flex_int16_t const   )64,      (flex_int16_t const   )90, 
        (flex_int16_t const   )89,      (flex_int16_t const   )88,      (flex_int16_t const   )87,      (flex_int16_t const   )86, 
        (flex_int16_t const   )85,      (flex_int16_t const   )84,      (flex_int16_t const   )83,      (flex_int16_t const   )82, 
        (flex_int16_t const   )81,      (flex_int16_t const   )80,      (flex_int16_t const   )79,      (flex_int16_t const   )78, 
        (flex_int16_t const   )77,      (flex_int16_t const   )76,      (flex_int16_t const   )75,      (flex_int16_t const   )74, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )71,      (flex_int16_t const   )70, 
        (flex_int16_t const   )69,      (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )66, 
        (flex_int16_t const   )65,      (flex_int16_t const   )36,      (flex_int16_t const   )60,      (flex_int16_t const   )59, 
        (flex_int16_t const   )56,      (flex_int16_t const   )50,      (flex_int16_t const   )47,      (flex_int16_t const   )44, 
        (flex_int16_t const   )41,      (flex_int16_t const   )39,      (flex_int16_t const   )38,      (flex_int16_t const   )37, 
        (flex_int16_t const   )36,      (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )33, 
        (flex_int16_t const   )101,      (flex_int16_t const   )3,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101};
#line 506 "lex.c"
static flex_int16_t const   yy_chk[172]  = 
#line 506
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )2, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )5, 
        (flex_int16_t const   )2,      (flex_int16_t const   )6,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )17,      (flex_int16_t const   )19,      (flex_int16_t const   )17, 
        (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )102,      (flex_int16_t const   )19, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )21, 
        (flex_int16_t const   )99,      (flex_int16_t const   )97,      (flex_int16_t const   )94,      (flex_int16_t const   )26, 
        (flex_int16_t const   )86,      (flex_int16_t const   )23,      (flex_int16_t const   )85,      (flex_int16_t const   )82, 
        (flex_int16_t const   )24,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )81,      (flex_int16_t const   )29,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )80, 
        (flex_int16_t const   )61,      (flex_int16_t const   )103,      (flex_int16_t const   )78,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )76,      (flex_int16_t const   )104,      (flex_int16_t const   )75, 
        (flex_int16_t const   )72,      (flex_int16_t const   )71,      (flex_int16_t const   )70,      (flex_int16_t const   )69, 
        (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )66,      (flex_int16_t const   )65, 
        (flex_int16_t const   )60,      (flex_int16_t const   )59,      (flex_int16_t const   )58,      (flex_int16_t const   )57, 
        (flex_int16_t const   )56,      (flex_int16_t const   )55,      (flex_int16_t const   )54,      (flex_int16_t const   )53, 
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )47, 
        (flex_int16_t const   )46,      (flex_int16_t const   )45,      (flex_int16_t const   )44,      (flex_int16_t const   )43, 
        (flex_int16_t const   )41,      (flex_int16_t const   )36,      (flex_int16_t const   )28,      (flex_int16_t const   )27, 
        (flex_int16_t const   )25,      (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )18, 
        (flex_int16_t const   )16,      (flex_int16_t const   )14,      (flex_int16_t const   )13,      (flex_int16_t const   )12, 
        (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )9,      (flex_int16_t const   )8, 
        (flex_int16_t const   )3,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101};
#line 530 "lex.c"
static flex_int32_t const   yy_rule_can_match_eol[37]  = 
#line 530
  {      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0};
#line 535 "lex.c"
static yy_state_type yy_last_accepting_state  ;
#line 536 "lex.c"
static char *yy_last_accepting_cpos  ;
#line 538
int yy_flex_debug ;
#line 539 "lex.c"
int yy_flex_debug  =    0;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 570 "lex.c"
static int yy_init_globals(void) ;
#line 575
int yylex_destroy(void) ;
#line 577
int yyget_debug(void) ;
#line 579
void yyset_debug(int bdebug ) ;
#line 585
FILE *yyget_in(void) ;
#line 587
void yyset_in(FILE *in_str ) ;
#line 589
FILE *yyget_out(void) ;
#line 591
void yyset_out(FILE *out_str ) ;
#line 593
int yyget_leng(void) ;
#line 595
char *yyget_text(void) ;
#line 597
int yyget_lineno(void) ;
#line 599
void yyset_lineno(int line_number ) ;
#line 736 "lex.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yyl ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___2 ;

  {
#line 747
  if (! yy_init) {
#line 749
    yy_init = 1;
#line 755
    if (! yy_start) {
#line 756
      yy_start = 1;
    }
#line 758
    if (! yyin) {
#line 759
      yyin = stdin;
    }
#line 761
    if (! yyout) {
#line 762
      yyout = stdout;
    }
#line 764
    if (yy_buffer_stack) {
#line 764
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 764
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 764
    if (! tmp) {
      {
#line 765
      yyensure_buffer_stack();
#line 766
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 770
    yy_load_buffer_state();
    }
  }
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    yy_cp = yy_c_buf_p;
#line 778
    *yy_cp = yy_hold_char;
#line 783
    yy_bp = yy_cp;
#line 785
    yy_current_state = yy_start;
#line 786
    yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
    yy_match: 
    {
#line 788
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 790
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 791
      if (yy_accept[yy_current_state]) {
#line 793
        yy_last_accepting_state = yy_current_state;
#line 794
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 796
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 796
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 796
          goto while_break___1;
        }
#line 798
        yy_current_state = (int )yy_def[yy_current_state];
#line 799
        if (yy_current_state >= 102) {
#line 800
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 802
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 803
      yy_cp ++;
#line 788
      if (! ((int const   )yy_base[yy_current_state] != 137)) {
#line 788
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 808
    yy_act = (int )yy_accept[yy_current_state];
#line 809
    if (yy_act == 0) {
#line 811
      yy_cp = yy_last_accepting_cpos;
#line 812
      yy_current_state = yy_last_accepting_state;
#line 813
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 816
    yytext = yy_bp;
#line 816
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 816
    yy_hold_char = *yy_cp;
#line 816
    *yy_cp = (char )'\000';
#line 816
    yy_c_buf_p = yy_cp;
#line 818
    if (yy_act != 37) {
#line 818
      if (yy_rule_can_match_eol[yy_act]) {
#line 821
        yyl = 0;
        {
#line 821
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 821
          if (! (yyl < yyleng)) {
#line 821
            goto while_break___2;
          }
#line 822
          if ((int )*(yytext + yyl) == 10) {
#line 824
            yylineno ++;
          }
#line 821
          yyl ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    do_action: 
    {
#line 832
    if (yy_act == 0) {
#line 832
      goto case_0;
    }
#line 839
    if (yy_act == 1) {
#line 839
      goto case_1;
    }
#line 14
    if (yy_act == 2) {
#line 14 "lex.l"
      goto case_2;
    }
#line 15
    if (yy_act == 3) {
#line 15
      goto case_3;
    }
#line 21
    if (yy_act == 4) {
#line 21
      goto case_4;
    }
#line 22
    if (yy_act == 5) {
#line 22
      goto case_5;
    }
#line 23
    if (yy_act == 6) {
#line 23
      goto case_6;
    }
#line 24
    if (yy_act == 7) {
#line 24
      goto case_7;
    }
#line 25
    if (yy_act == 8) {
#line 25
      goto case_8;
    }
#line 26
    if (yy_act == 9) {
#line 26
      goto case_9;
    }
#line 27
    if (yy_act == 10) {
#line 27
      goto case_10;
    }
#line 28
    if (yy_act == 11) {
#line 28
      goto case_11;
    }
#line 29
    if (yy_act == 12) {
#line 29
      goto case_12;
    }
#line 30
    if (yy_act == 13) {
#line 30
      goto case_13;
    }
#line 31
    if (yy_act == 14) {
#line 31
      goto case_14;
    }
#line 32
    if (yy_act == 15) {
#line 32
      goto case_15;
    }
#line 33
    if (yy_act == 16) {
#line 33
      goto case_16;
    }
#line 34
    if (yy_act == 17) {
#line 34
      goto case_17;
    }
#line 35
    if (yy_act == 18) {
#line 35
      goto case_18;
    }
#line 36
    if (yy_act == 19) {
#line 36
      goto case_19;
    }
#line 37
    if (yy_act == 20) {
#line 37
      goto case_20;
    }
#line 38
    if (yy_act == 21) {
#line 38
      goto case_21;
    }
#line 39
    if (yy_act == 22) {
#line 39
      goto case_22;
    }
#line 40
    if (yy_act == 23) {
#line 40
      goto case_23;
    }
#line 41
    if (yy_act == 24) {
#line 41
      goto case_24;
    }
#line 42
    if (yy_act == 25) {
#line 42
      goto case_25;
    }
#line 43
    if (yy_act == 26) {
#line 43
      goto case_26;
    }
#line 44
    if (yy_act == 27) {
#line 44
      goto case_27;
    }
#line 45
    if (yy_act == 28) {
#line 45
      goto case_28;
    }
#line 46
    if (yy_act == 29) {
#line 46
      goto case_29;
    }
#line 47
    if (yy_act == 30) {
#line 47
      goto case_30;
    }
#line 48
    if (yy_act == 31) {
#line 48
      goto case_31;
    }
#line 49
    if (yy_act == 32) {
#line 49
      goto case_32;
    }
#line 56
    if (yy_act == 33) {
#line 56
      goto case_33;
    }
#line 57
    if (yy_act == 34) {
#line 57
      goto case_34;
    }
#line 59
    if (yy_act == 35) {
#line 59
      goto case_35;
    }
#line 60
    if (yy_act == 36) {
#line 60
      goto case_36;
    }
#line 1032
    if (yy_act == 38) {
#line 1032 "lex.c"
      goto case_38;
    }
#line 1035
    if (yy_act == 37) {
#line 1035
      goto case_37;
    }
#line 1157
    goto switch_default;
    case_0: /* CIL Label */ 
#line 834
    *yy_cp = yy_hold_char;
#line 835
    yy_cp = yy_last_accepting_cpos;
#line 836
    yy_current_state = yy_last_accepting_state;
#line 837
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 840
    if (yyleng > 0) {
#line 840
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 13 "lex.l"
    goto switch_break;
    case_2: /* CIL Label */ 
#line 15
    if (yyleng > 0) {
#line 15
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 14
    goto switch_break;
    case_3: /* CIL Label */ 
#line 16
    if (yyleng > 0) {
#line 16
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 16
    yylval.ival = atoi((char const   *)yytext);
    }
#line 17
    return (258);
#line 19
    goto switch_break;
    case_4: /* CIL Label */ 
#line 22
    if (yyleng > 0) {
#line 22
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 20
    return (276);
#line 21
    goto switch_break;
    case_5: /* CIL Label */ 
#line 23
    if (yyleng > 0) {
#line 23
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 21
    return (271);
#line 22
    goto switch_break;
    case_6: /* CIL Label */ 
#line 24
    if (yyleng > 0) {
#line 24
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 22
    return (272);
#line 23
    goto switch_break;
    case_7: /* CIL Label */ 
#line 25
    if (yyleng > 0) {
#line 25
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 23
    return (273);
#line 24
    goto switch_break;
    case_8: /* CIL Label */ 
#line 26
    if (yyleng > 0) {
#line 26
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 24
    return (277);
#line 25
    goto switch_break;
    case_9: /* CIL Label */ 
#line 27
    if (yyleng > 0) {
#line 27
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 25
    return (278);
#line 26
    goto switch_break;
    case_10: /* CIL Label */ 
#line 28
    if (yyleng > 0) {
#line 28
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 26
    return (279);
#line 27
    goto switch_break;
    case_11: /* CIL Label */ 
#line 29
    if (yyleng > 0) {
#line 29
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 27
    return (280);
#line 28
    goto switch_break;
    case_12: /* CIL Label */ 
#line 30
    if (yyleng > 0) {
#line 30
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 28
    return (281);
#line 29
    goto switch_break;
    case_13: /* CIL Label */ 
#line 31
    if (yyleng > 0) {
#line 31
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 29
    return (274);
#line 30
    goto switch_break;
    case_14: /* CIL Label */ 
#line 32
    if (yyleng > 0) {
#line 32
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 30
    return (275);
#line 31
    goto switch_break;
    case_15: /* CIL Label */ 
#line 33
    if (yyleng > 0) {
#line 33
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 31
    return (282);
#line 32
    goto switch_break;
    case_16: /* CIL Label */ 
#line 34
    if (yyleng > 0) {
#line 34
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 32
    return (283);
#line 33
    goto switch_break;
    case_17: /* CIL Label */ 
#line 35
    if (yyleng > 0) {
#line 35
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 33
    return (284);
#line 34
    goto switch_break;
    case_18: /* CIL Label */ 
#line 36
    if (yyleng > 0) {
#line 36
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 34
    return (262);
#line 35
    goto switch_break;
    case_19: /* CIL Label */ 
#line 37
    if (yyleng > 0) {
#line 37
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 35
    return (285);
#line 36
    goto switch_break;
    case_20: /* CIL Label */ 
#line 38
    if (yyleng > 0) {
#line 38
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 36
    return (260);
#line 37
    goto switch_break;
    case_21: /* CIL Label */ 
#line 39
    if (yyleng > 0) {
#line 39
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 37
    return (261);
#line 38
    goto switch_break;
    case_22: /* CIL Label */ 
#line 40
    if (yyleng > 0) {
#line 40
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 38
    return (286);
#line 39
    goto switch_break;
    case_23: /* CIL Label */ 
#line 41
    if (yyleng > 0) {
#line 41
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 39
    return (287);
#line 40
    goto switch_break;
    case_24: /* CIL Label */ 
#line 42
    if (yyleng > 0) {
#line 42
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 40
    return (263);
#line 41
    goto switch_break;
    case_25: /* CIL Label */ 
#line 43
    if (yyleng > 0) {
#line 43
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 41
    return (265);
#line 42
    goto switch_break;
    case_26: /* CIL Label */ 
#line 44
    if (yyleng > 0) {
#line 44
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 42
    return (266);
#line 43
    goto switch_break;
    case_27: /* CIL Label */ 
#line 45
    if (yyleng > 0) {
#line 45
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 43
    return (269);
#line 44
    goto switch_break;
    case_28: /* CIL Label */ 
#line 46
    if (yyleng > 0) {
#line 46
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 44
    return (270);
#line 45
    goto switch_break;
    case_29: /* CIL Label */ 
#line 47
    if (yyleng > 0) {
#line 47
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 45
    return (267);
#line 46
    goto switch_break;
    case_30: /* CIL Label */ 
#line 48
    if (yyleng > 0) {
#line 48
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 46
    return (268);
#line 47
    goto switch_break;
    case_31: /* CIL Label */ 
#line 49
    if (yyleng > 0) {
#line 49
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 47
    return (264);
#line 48
    goto switch_break;
    case_32: /* CIL Label */ 
#line 50
    if (yyleng > 0) {
#line 50
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 50
    tmp___0 = strlen((char const   *)yytext);
#line 50
    tmp___1 = malloc((tmp___0 + 1UL) * sizeof(char ));
#line 50
    yylval.tval = (char *)tmp___1;
#line 51
    strcpy((char */* __restrict  */)yylval.tval, (char const   */* __restrict  */)yytext);
    }
#line 52
    return (259);
#line 54
    goto switch_break;
    case_33: /* CIL Label */ 
#line 58
    if (yyleng > 0) {
#line 58
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 56
    goto switch_break;
    case_34: /* CIL Label */ 
#line 59
    if (yyleng > 0) {
#line 59
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 57
    goto switch_break;
    case_35: /* CIL Label */ 
#line 60
    if (yyleng > 0) {
#line 60
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 58
    return ((int )*(yytext + 0));
#line 59
    goto switch_break;
    case_36: /* CIL Label */ 
#line 61
    if (yyleng > 0) {
#line 61
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 59
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 59
      fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1,
             (FILE */* __restrict  */)yyout);
      }
#line 59
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 60
    goto switch_break;
    case_38: /* CIL Label */ 
#line 1033 "lex.c"
    return (0);
    case_37: /* CIL Label */ 
#line 1038
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1041
    *yy_cp = yy_hold_char;
#line 1044
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1055
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1056
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1057
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1067
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1071
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1073
      yy_current_state = yy_get_previous_state();
#line 1084
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1086
      yy_bp = yytext + 0;
      }
#line 1088
      if (yy_next_state) {
#line 1091
        yy_c_buf_p ++;
#line 1091
        yy_cp = yy_c_buf_p;
#line 1092
        yy_current_state = yy_next_state;
#line 1093
        goto yy_match;
      } else {
#line 1098
        yy_cp = yy_c_buf_p;
#line 1099
        goto yy_find_action;
      }
    } else {
      {
#line 1103
      tmp___2 = yy_get_next_buffer();
      }
      {
#line 1105
      if (tmp___2 == 1) {
#line 1105
        goto case_1___0;
      }
#line 1134
      if (tmp___2 == 0) {
#line 1134
        goto case_0___0;
      }
#line 1144
      if (tmp___2 == 2) {
#line 1144
        goto case_2___0;
      }
#line 1103
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1107
      yy_did_buffer_switch_on_eof = 0;
#line 1120
      yy_c_buf_p = yytext + 0;
#line 1122
      yy_act = (37 + (yy_start - 1) / 2) + 1;
#line 1123
      goto do_action;
#line 1131
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1135
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1138
      yy_current_state = yy_get_previous_state();
#line 1140
      yy_cp = yy_c_buf_p;
#line 1141
      yy_bp = yytext + 0;
      }
#line 1142
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1145
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1148
      yy_current_state = yy_get_previous_state();
#line 1150
      yy_cp = yy_c_buf_p;
#line 1151
      yy_bp = yytext + 0;
      }
#line 1152
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1154
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1158
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1171 "lex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1173
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1174
  source = yytext;
#line 1178
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1179
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1182
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1184
    if (yy_c_buf_p - yytext == 1L) {
#line 1189
      return (1);
    } else {
#line 1197
      return (2);
    }
  }
#line 1204
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1206
  i = 0;
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (! (i < number_to_move)) {
#line 1206
      goto while_break;
    }
#line 1207
    tmp = dest;
#line 1207
    dest ++;
#line 1207
    tmp___0 = source;
#line 1207
    source ++;
#line 1207
    *tmp = *tmp___0;
#line 1206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1209
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1213
    yy_n_chars = 0;
#line 1213
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1217
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1220
      if (! (num_to_read <= 0)) {
#line 1220
        goto while_break___0;
      }
#line 1224
      if (yy_buffer_stack) {
#line 1224
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1224
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1224
      b = tmp___1;
#line 1226
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1229
      if (b->yy_is_our_buffer) {
#line 1231
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1233
        if (new_size <= 0) {
#line 1234
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1236
          b->yy_buf_size *= 2UL;
        }
        {
#line 1238
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1238
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1244
        b->yy_ch_buf = (char *)0;
      }
#line 1246
      if (! b->yy_ch_buf) {
        {
#line 1247
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1250
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1252
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1257
    if (num_to_read > 8192) {
#line 1258
      num_to_read = 8192;
    }
#line 1261
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1261
      c = '*';
#line 1261
      n = (size_t )0;
      {
#line 1261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1261
        if (n < (size_t )num_to_read) {
          {
#line 1261
          c = _IO_getc(yyin);
          }
#line 1261
          if (c != -1) {
#line 1261
            if (! (c != 10)) {
#line 1261
              goto while_break___1;
            }
          } else {
#line 1261
            goto while_break___1;
          }
        } else {
#line 1261
          goto while_break___1;
        }
#line 1261
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1261
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1261
      if (c == 10) {
#line 1261
        tmp___3 = n;
#line 1261
        n ++;
#line 1261
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1261
      if (c == -1) {
        {
#line 1261
        tmp___4 = ferror(yyin);
        }
#line 1261
        if (tmp___4) {
          {
#line 1261
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1261
      yy_n_chars = (int )n;
    } else {
      {
#line 1261
      tmp___5 = __errno_location();
#line 1261
      *tmp___5 = 0;
      }
      {
#line 1261
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1261
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1261
        yy_n_chars = (int )tmp___8;
        }
#line 1261
        if (yy_n_chars == 0) {
          {
#line 1261
          tmp___9 = ferror(yyin);
          }
#line 1261
          if (! tmp___9) {
#line 1261
            goto while_break___2;
          }
        } else {
#line 1261
          goto while_break___2;
        }
        {
#line 1261
        tmp___6 = __errno_location();
        }
#line 1261
        if (*tmp___6 != 4) {
          {
#line 1261
          yy_fatal_error("input in flex scanner failed");
          }
#line 1261
          goto while_break___2;
        }
        {
#line 1261
        tmp___7 = __errno_location();
#line 1261
        *tmp___7 = 0;
#line 1261
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1264
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1267
  if (yy_n_chars == 0) {
#line 1269
    if (number_to_move == 0) {
      {
#line 1271
      ret_val = 1;
#line 1272
      yyrestart(yyin);
      }
    } else {
#line 1277
      ret_val = 2;
#line 1278
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1284
    ret_val = 0;
  }
#line 1286
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1288
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1289
    tmp___10 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                         new_size___0);
#line 1289
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1290
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1291
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1294
  yy_n_chars += number_to_move;
#line 1295
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1296
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1298
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1300
  return (ret_val);
}
}
#line 1305 "lex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1310
  yy_current_state = yy_start;
#line 1311
  yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
#line 1313
  yy_cp = yytext + 0;
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1313
      goto while_break;
    }
#line 1315
    if (*yy_cp) {
#line 1315
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1315
      tmp = (flex_int32_t const   )1;
    }
#line 1315
    yy_c = (YY_CHAR )tmp;
#line 1316
    if (yy_accept[yy_current_state]) {
#line 1318
      yy_last_accepting_state = yy_current_state;
#line 1319
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1321
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1321
        goto while_break___0;
      }
#line 1323
      yy_current_state = (int )yy_def[yy_current_state];
#line 1324
      if (yy_current_state >= 102) {
#line 1325
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1327
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1313
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1330
  return (yy_current_state);
}
}
#line 1338 "lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1341
  yy_cp = yy_c_buf_p;
#line 1343
  yy_c = (YY_CHAR )1;
#line 1344
  if (yy_accept[yy_current_state]) {
#line 1346
    yy_last_accepting_state = yy_current_state;
#line 1347
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1349
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1349
      goto while_break;
    }
#line 1351
    yy_current_state = (int )yy_def[yy_current_state];
#line 1352
    if (yy_current_state >= 102) {
#line 1353
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1356
  yy_is_jam = yy_current_state == 101;
#line 1358
  if (yy_is_jam) {
#line 1358
    tmp = 0;
  } else {
#line 1358
    tmp = yy_current_state;
  }
#line 1358
  return (tmp);
}
}
#line 1446 "lex.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1449
  if (yy_buffer_stack) {
#line 1449
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1449
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1449
  if (! tmp) {
    {
#line 1450
    yyensure_buffer_stack();
#line 1451
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1455
  if (yy_buffer_stack) {
#line 1455
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1455
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1455
  yy_init_buffer(tmp___0, input_file);
#line 1456
  yy_load_buffer_state();
  }
#line 1457
  return;
}
}
#line 1463 "lex.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1471
  yyensure_buffer_stack();
  }
#line 1472
  if (yy_buffer_stack) {
#line 1472
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1472
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1472
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1473
    return;
  }
#line 1475
  if (yy_buffer_stack) {
#line 1475
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1475
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1475
  if (tmp___0) {
#line 1478
    *yy_c_buf_p = yy_hold_char;
#line 1479
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1480
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1483
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1484
  yy_load_buffer_state();
#line 1491
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1492
  return;
}
}
#line 1494 "lex.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1496
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1497
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1497
  yytext = yy_c_buf_p;
#line 1498
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1499
  yy_hold_char = *yy_c_buf_p;
#line 1500
  return;
}
}
#line 1508 "lex.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1512
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 1512
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1513
  if (! b) {
    {
#line 1514
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1516
  b->yy_buf_size = (yy_size_t )size;
#line 1521
  tmp___0 = yyalloc(b->yy_buf_size + 2UL);
#line 1521
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1522
  if (! b->yy_ch_buf) {
    {
#line 1523
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1525
  b->yy_is_our_buffer = 1;
#line 1527
  yy_init_buffer(b, file);
  }
#line 1529
  return (b);
}
}
#line 1536 "lex.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1539
  if (! b) {
#line 1540
    return;
  }
#line 1542
  if (yy_buffer_stack) {
#line 1542
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1542
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1542
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1543
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1545
  if (b->yy_is_our_buffer) {
    {
#line 1546
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1548
  yyfree((void *)b);
  }
#line 1549
  return;
}
}
#line 1559 "lex.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1562
  tmp = __errno_location();
#line 1562
  oerrno = *tmp;
#line 1564
  yy_flush_buffer(b);
#line 1566
  b->yy_input_file = file;
#line 1567
  b->yy_fill_buffer = 1;
  }
#line 1573
  if (yy_buffer_stack) {
#line 1573
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1573
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1573
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1574
    b->yy_bs_lineno = 1;
#line 1575
    b->yy_bs_column = 0;
  }
#line 1578
  if (file) {
    {
#line 1578
    tmp___1 = fileno(file);
#line 1578
    tmp___2 = isatty(tmp___1);
#line 1578
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1578
    b->yy_is_interactive = 0;
  }
  {
#line 1580
  tmp___3 = __errno_location();
#line 1580
  *tmp___3 = oerrno;
  }
#line 1581
  return;
}
}
#line 1587 "lex.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1589
  if (! b) {
#line 1590
    return;
  }
#line 1592
  b->yy_n_chars = 0;
#line 1598
  *(b->yy_ch_buf + 0) = (char)0;
#line 1599
  *(b->yy_ch_buf + 1) = (char)0;
#line 1601
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1603
  b->yy_at_bol = 1;
#line 1604
  b->yy_buffer_status = 0;
#line 1606
  if (yy_buffer_stack) {
#line 1606
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1606
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1606
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1607
    yy_load_buffer_state();
    }
  }
#line 1608
  return;
}
}
#line 1616 "lex.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1618
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1619
    return;
  }
  {
#line 1621
  yyensure_buffer_stack();
  }
#line 1624
  if (yy_buffer_stack) {
#line 1624
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1624
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1624
  if (tmp) {
#line 1627
    *yy_c_buf_p = yy_hold_char;
#line 1628
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1629
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1633
  if (yy_buffer_stack) {
#line 1633
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1633
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1633
  if (tmp___0) {
#line 1634
    yy_buffer_stack_top ++;
  }
  {
#line 1635
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1638
  yy_load_buffer_state();
#line 1639
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1640
  return;
}
}
#line 1646 "lex.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1648
  if (yy_buffer_stack) {
#line 1648
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1648
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1648
  if (! tmp) {
#line 1649
    return;
  }
#line 1651
  if (yy_buffer_stack) {
#line 1651
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1651
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1651
  yy_delete_buffer(tmp___0);
#line 1652
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1653
  if (yy_buffer_stack_top > 0UL) {
#line 1654
    yy_buffer_stack_top --;
  }
#line 1656
  if (yy_buffer_stack) {
#line 1656
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1656
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1656
  if (tmp___1) {
    {
#line 1657
    yy_load_buffer_state();
#line 1658
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1660
  return;
}
}
#line 1665 "lex.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1669
  if (! yy_buffer_stack) {
    {
#line 1675
    num_to_alloc = 1;
#line 1676
    tmp = yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1676
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1679
    if (! yy_buffer_stack) {
      {
#line 1680
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 1682
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1684
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1685
    yy_buffer_stack_top = (size_t )0;
    }
#line 1686
    return;
  }
#line 1689
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1692
    grow_size = 8;
#line 1694
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1695
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1695
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1699
    if (! yy_buffer_stack) {
      {
#line 1700
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 1703
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1704
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1706
  return;
}
}
#line 1714 "lex.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1718
  if (size < 2UL) {
#line 1722
    return ((YY_BUFFER_STATE )0);
  } else
#line 1718
  if ((int )*(base + (size - 2UL)) != 0) {
#line 1722
    return ((YY_BUFFER_STATE )0);
  } else
#line 1718
  if ((int )*(base + (size - 1UL)) != 0) {
#line 1722
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1724
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 1724
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1725
  if (! b) {
    {
#line 1726
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1728
  b->yy_buf_size = size - 2UL;
#line 1729
  tmp___0 = base;
#line 1729
  b->yy_ch_buf = tmp___0;
#line 1729
  b->yy_buf_pos = tmp___0;
#line 1730
  b->yy_is_our_buffer = 0;
#line 1731
  b->yy_input_file = (FILE *)0;
#line 1732
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1733
  b->yy_is_interactive = 0;
#line 1734
  b->yy_at_bol = 1;
#line 1735
  b->yy_fill_buffer = 0;
#line 1736
  b->yy_buffer_status = 0;
#line 1738
  yy_switch_to_buffer(b);
  }
#line 1740
  return (b);
}
}
#line 1751 "lex.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1754
  tmp = strlen(yystr);
#line 1754
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 1754
  return (tmp___0);
}
}
#line 1764 "lex.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1772
  n = (yy_size_t )(_yybytes_len + 2);
#line 1773
  tmp = yyalloc(n);
#line 1773
  buf = (char *)tmp;
  }
#line 1774
  if (! buf) {
    {
#line 1775
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1777
  i = 0;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (! (i < _yybytes_len)) {
#line 1777
      goto while_break;
    }
#line 1778
    *(buf + i) = (char )*(yybytes + i);
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1780
  tmp___0 = (char)0;
#line 1780
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1780
  *(buf + _yybytes_len) = tmp___0;
#line 1782
  b = yy_scan_buffer(buf, n);
  }
#line 1783
  if (! b) {
    {
#line 1784
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1789
  b->yy_is_our_buffer = 1;
#line 1791
  return (b);
}
}
#line 1798 "lex.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1800
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1801
  exit(2);
  }
}
}
#line 1826 "lex.c"
int yyget_lineno(void) 
{ 


  {
#line 1829
  return (yylineno);
}
}
#line 1835 "lex.c"
FILE *yyget_in(void) 
{ 


  {
#line 1837
  return (yyin);
}
}
#line 1843 "lex.c"
FILE *yyget_out(void) 
{ 


  {
#line 1845
  return (yyout);
}
}
#line 1851 "lex.c"
int yyget_leng(void) 
{ 


  {
#line 1853
  return (yyleng);
}
}
#line 1860 "lex.c"
char *yyget_text(void) 
{ 


  {
#line 1862
  return (yytext);
}
}
#line 1869 "lex.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 1872
  yylineno = line_number;
#line 1873
  return;
}
}
#line 1881 "lex.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 1883
  yyin = in_str;
#line 1884
  return;
}
}
#line 1886 "lex.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 1888
  yyout = out_str;
#line 1889
  return;
}
}
#line 1891 "lex.c"
int yyget_debug(void) 
{ 


  {
#line 1893
  return (yy_flex_debug);
}
}
#line 1896 "lex.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 1898
  yy_flex_debug = bdebug;
#line 1899
  return;
}
}
#line 1901 "lex.c"
static int yy_init_globals(void) 
{ 


  {
#line 1908
  yylineno = 1;
#line 1910
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 1911
  yy_buffer_stack_top = (size_t )0;
#line 1912
  yy_buffer_stack_max = (size_t )0;
#line 1913
  yy_c_buf_p = (char *)0;
#line 1914
  yy_init = 0;
#line 1915
  yy_start = 0;
#line 1922
  yyin = (FILE *)0;
#line 1923
  yyout = (FILE *)0;
#line 1929
  return (0);
}
}
#line 1933 "lex.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1937
    if (yy_buffer_stack) {
#line 1937
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1937
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1937
    if (! tmp___0) {
#line 1937
      goto while_break;
    }
#line 1938
    if (yy_buffer_stack) {
#line 1938
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1938
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1938
    yy_delete_buffer(tmp);
#line 1939
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 1940
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1944
  yyfree((void *)yy_buffer_stack);
#line 1945
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 1949
  yy_init_globals();
  }
#line 1951
  return (0);
}
}
#line 1978 "lex.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1980
  tmp = malloc(size);
  }
#line 1980
  return (tmp);
}
}
#line 1983 "lex.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1992
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 1992
  return (tmp);
}
}
#line 1995 "lex.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 1997
  free((void *)((char *)ptr));
  }
#line 1998
  return;
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.h"
void quicksort(int *data , int start , int end ) ;
#line 14
void reverse(int *data , int start , int end ) ;
#line 16
void permute(int *data , int count ) ;
#line 18
void all_permutations(int *data , int count , void (*callback)(int *data , int count ,
                                                               void *arg , float farg ) ,
                      void *arg , float farg ) ;
#line 22
long factorial(int n ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
int cmpint(void const   *p1 , void const   *p2 ) 
{ 


  {
#line 6
  return (*((int *)p1) - *((int *)p2));
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void quicksort(int *data , int start , int end ) 
{ 


  {
  {
#line 10
  qsort((void *)(data + start), (size_t )((end - start) + 1), sizeof(int ), & cmpint);
  }
#line 11
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void reverse(int *data , int start , int end ) 
{ 
  int temp ;

  {
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (start < end)) {
#line 15
      goto while_break;
    }
#line 16
    temp = *(data + start);
#line 17
    *(data + start) = *(data + end);
#line 18
    *(data + end) = temp;
#line 19
    start ++;
#line 19
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void permute(int *data , int count ) 
{ 
  int i ;
  int p ;
  int t ;
  int tmp ;

  {
#line 25
  i = count - 1;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i >= 0)) {
#line 25
      goto while_break;
    }
    {
#line 26
    tmp = rand();
#line 26
    p = (int )((double )(i + 1) * ((double )tmp / ((double )2147483647 + 1.0)));
#line 27
    t = *(data + i);
#line 28
    *(data + i) = *(data + p);
#line 29
    *(data + p) = t;
#line 25
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void result_add(struct result_node **list , int value ) 
{ 
  void *tmp ;
  struct result_node *cur ;
  struct result_node *last ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 35
  if ((unsigned long )*list == (unsigned long )((void *)0)) {
    {
#line 36
    tmp = malloc(sizeof(struct result_node ));
#line 36
    *list = (struct result_node *)tmp;
#line 37
    (*list)->value = value;
#line 38
    (*list)->prob = 1;
#line 39
    (*list)->next = (struct result_node *)((void *)0);
    }
#line 40
    return;
  }
#line 43
  cur = *list;
#line 43
  last = (struct result_node *)((void *)0);
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 44
      if (! (cur->value < value)) {
#line 44
        goto while_break;
      }
    } else {
#line 44
      goto while_break;
    }
#line 45
    last = cur;
#line 46
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
    {
#line 50
    tmp___0 = malloc(sizeof(struct result_node ));
#line 50
    cur = (struct result_node *)tmp___0;
#line 51
    cur->value = value;
#line 52
    cur->prob = 1;
#line 53
    cur->next = (struct result_node *)((void *)0);
#line 54
    last->next = cur;
    }
#line 55
    return;
  } else
#line 57
  if (cur->value == value) {
#line 58
    (cur->prob) ++;
#line 59
    return;
  } else
#line 61
  if ((unsigned long )last != (unsigned long )((void *)0)) {
    {
#line 62
    tmp___1 = malloc(sizeof(struct result_node ));
#line 62
    last->next = (struct result_node *)tmp___1;
#line 63
    (last->next)->value = value;
#line 64
    (last->next)->prob = 1;
#line 65
    (last->next)->next = cur;
    }
  } else {
    {
#line 68
    tmp___2 = malloc(sizeof(struct result_node ));
#line 68
    *list = (struct result_node *)tmp___2;
#line 69
    (*list)->value = value;
#line 70
    (*list)->prob = 1;
#line 71
    (*list)->next = cur;
    }
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
__inline void swapperm(int *data , int i , int j ) 
{ 


  {
#line 76
  if (i == j) {
#line 77
    return;
  }
#line 78
  *(data + i) ^= *(data + j);
#line 79
  *(data + j) ^= *(data + i);
#line 80
  *(data + i) ^= *(data + j);
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void _rec_all_permutations(int *data , int count , void (*callback)(int *data , int count ,
                                                                    void *arg , float farg ) ,
                           void *arg , float farg , int n ) 
{ 
  int c ;
  int tmp ;

  {
#line 86
  if (1 == n) {
    {
#line 87
    (*callback)(data, count, arg, farg);
    }
  } else {
#line 91
    c = 0;
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! (c < n)) {
#line 91
        goto while_break;
      }
      {
#line 92
      _rec_all_permutations(data, count, callback, arg, farg, n - 1);
      }
#line 93
      if (n % 2 == 1) {
#line 93
        tmp = 0;
      } else {
#line 93
        tmp = c;
      }
      {
#line 93
      swapperm(data, tmp, n - 1);
#line 91
      c ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
void all_permutations(int *data , int count , void (*callback)(int *data , int count ,
                                                               void *arg , float farg ) ,
                      void *arg , float farg ) 
{ 


  {
  {
#line 101
  _rec_all_permutations(data, count, callback, arg, farg, count);
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/util.c"
long factorial(int n ) 
{ 
  long fact ;
  int tmp ;

  {
#line 105
  fact = 1L;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (n > 0)) {
#line 106
      goto while_break;
    }
#line 107
    tmp = n;
#line 107
    n --;
#line 107
    fact *= (long )tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return (fact);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 10 "eval.tc"
float cmd_threshold ;
#line 156 "tree.h"
struct expression_vtable__  const  expression_vt__ ;
#line 182
void expression_set_ordering__(expression *this , ordering_type ordering ) ;
#line 183
expression *expression_optimize__(expression *this ) ;
#line 206
struct elist_vtable__  const  elist_vt__ ;
#line 208
void elist_printtree__(elist *this , int depth ) ;
#line 209
struct roll_value *elist_roll__(elist *this ) ;
#line 210
void elist_set_symtab__(elist *this , struct symtab *st ) ;
#line 211
struct val_list *elist_eval__(elist *this ) ;
#line 236
struct binary_vtable__  const  binary_vt__ ;
#line 238
void binary_set_symtab__(binary *this , struct symtab *st ) ;
#line 239
void binary_set_ordering__(binary *this , ordering_type ordering ) ;
#line 240
expression *binary_optimize__(binary *this ) ;
#line 264
struct unary_vtable__  const  unary_vt__ ;
#line 266
void unary_set_symtab__(unary *this , struct symtab *st ) ;
#line 267
void unary_set_ordering__(unary *this , ordering_type ordering ) ;
#line 268
expression *unary_optimize__(unary *this ) ;
#line 292
struct number_vtable__  const  number_vt__ ;
#line 294
void number_printtree__(number *this , int depth ) ;
#line 295
struct roll_value *number_roll__(number *this ) ;
#line 296
void number_set_symtab__(number *this , struct symtab *st ) ;
#line 297
struct val_list *number_eval__(number *this ) ;
#line 323
struct ifthenelse_vtable__  const  ifthenelse_vt__ ;
#line 325
void ifthenelse_printtree__(ifthenelse *this , int depth ) ;
#line 326
struct roll_value *ifthenelse_roll__(ifthenelse *this ) ;
#line 327
void ifthenelse_set_symtab__(ifthenelse *this , struct symtab *st ) ;
#line 328
void ifthenelse_set_ordering__(ifthenelse *this , ordering_type ordering ) ;
#line 329
struct val_list *ifthenelse_eval__(ifthenelse *this ) ;
#line 330
expression *ifthenelse_optimize__(ifthenelse *this ) ;
#line 354
struct variable_vtable__  const  variable_vt__ ;
#line 356
void variable_printtree__(variable *this , int depth ) ;
#line 357
struct roll_value *variable_roll__(variable *this ) ;
#line 358
void variable_set_symtab__(variable *this , struct symtab *st ) ;
#line 359
void variable_set_ordering__(variable *this , ordering_type ordering ) ;
#line 360
struct val_list *variable_eval__(variable *this ) ;
#line 385
struct sumrepdice_vtable__  const  sumrepdice_vt__ ;
#line 387
void sumrepdice_printtree__(sumrepdice *this , int depth ) ;
#line 388
struct roll_value *sumrepdice_roll__(sumrepdice *this ) ;
#line 389
void sumrepdice_set_symtab__(sumrepdice *this , struct symtab *st ) ;
#line 390
struct val_list *sumrepdice_eval__(sumrepdice *this ) ;
#line 415
struct sumrepany_vtable__  const  sumrepany_vt__ ;
#line 417
void sumrepany_printtree__(sumrepany *this , int depth ) ;
#line 418
struct roll_value *sumrepany_roll__(sumrepany *this ) ;
#line 419
void sumrepany_set_symtab__(sumrepany *this , struct symtab *st ) ;
#line 420
struct val_list *sumrepany_eval__(sumrepany *this ) ;
#line 445
struct mathop_vtable__  const  mathop_vt__ ;
#line 447
void mathop_printtree__(mathop *this , int depth ) ;
#line 448
struct roll_value *mathop_roll__(mathop *this ) ;
#line 449
struct val_list *mathop_eval__(mathop *this ) ;
#line 474
struct scat_vtable__  const  scat_vt__ ;
#line 476
void scat_printtree__(scat *this , int depth ) ;
#line 477
struct roll_value *scat_roll__(scat *this ) ;
#line 478
struct val_list *scat_eval__(scat *this ) ;
#line 503
struct rep_vtable__  const  rep_vt__ ;
#line 505
void rep_printtree__(rep *this , int depth ) ;
#line 506
struct roll_value *rep_roll__(rep *this ) ;
#line 507
struct val_list *rep_eval__(rep *this ) ;
#line 532
struct range_vtable__  const  range_vt__ ;
#line 534
void range_printtree__(range *this , int depth ) ;
#line 535
struct roll_value *range_roll__(range *this ) ;
#line 536
struct val_list *range_eval__(range *this ) ;
#line 561
struct lcat_vtable__  const  lcat_vt__ ;
#line 563
void lcat_printtree__(lcat *this , int depth ) ;
#line 564
struct roll_value *lcat_roll__(lcat *this ) ;
#line 565
struct val_list *lcat_eval__(lcat *this ) ;
#line 591
struct filter_vtable__  const  filter_vt__ ;
#line 617
struct let_vtable__  const  let_vt__ ;
#line 619
void let_printtree__(let *this , int depth ) ;
#line 620
struct roll_value *let_roll__(let *this ) ;
#line 621
void let_set_ordering__(let *this , ordering_type ordering ) ;
#line 622
struct val_list *let_eval__(let *this ) ;
#line 648
struct foreach_vtable__  const  foreach_vt__ ;
#line 650
void foreach_printtree__(foreach *this , int depth ) ;
#line 651
struct roll_value *foreach_roll__(foreach *this ) ;
#line 652
struct val_list *foreach_eval__(foreach *this ) ;
#line 678
struct whiledo_vtable__  const  whiledo_vt__ ;
#line 680
void whiledo_printtree__(whiledo *this , int depth ) ;
#line 681
struct roll_value *whiledo_roll__(whiledo *this ) ;
#line 682
struct val_list *whiledo_eval__(whiledo *this ) ;
#line 707
struct plus_vtable__  const  plus_vt__ ;
#line 732
struct minus_vtable__  const  minus_vt__ ;
#line 757
struct multi_vtable__  const  multi_vt__ ;
#line 782
struct divi_vtable__  const  divi_vt__ ;
#line 807
struct mod_vtable__  const  mod_vt__ ;
#line 832
struct expo_vtable__  const  expo_vt__ ;
#line 858
struct first_vtable__  const  first_vt__ ;
#line 860
void first_printtree__(first *this , int depth ) ;
#line 861
struct roll_value *first_roll__(first *this ) ;
#line 862
void first_set_ordering__(first *this , ordering_type ordering ) ;
#line 863
struct val_list *first_eval__(first *this ) ;
#line 889
struct last_vtable__  const  last_vt__ ;
#line 891
void last_printtree__(last *this , int depth ) ;
#line 892
struct roll_value *last_roll__(last *this ) ;
#line 893
void last_set_ordering__(last *this , ordering_type ordering ) ;
#line 894
struct val_list *last_eval__(last *this ) ;
#line 920
struct high_vtable__  const  high_vt__ ;
#line 922
void high_printtree__(high *this , int depth ) ;
#line 923
struct roll_value *high_roll__(high *this ) ;
#line 924
struct val_list *high_eval__(high *this ) ;
#line 950
struct low_vtable__  const  low_vt__ ;
#line 952
void low_printtree__(low *this , int depth ) ;
#line 953
struct roll_value *low_roll__(low *this ) ;
#line 954
struct val_list *low_eval__(low *this ) ;
#line 981
struct comparison_vtable__  const  comparison_vt__ ;
#line 983
void comparison_printtree__(comparison *this , int depth ) ;
#line 984
struct roll_value *comparison_roll__(comparison *this ) ;
#line 985
struct val_list *comparison_eval__(comparison *this ) ;
#line 1009
struct negate_vtable__  const  negate_vt__ ;
#line 1011
void negate_printtree__(negate *this , int depth ) ;
#line 1012
struct roll_value *negate_roll__(negate *this ) ;
#line 1013
struct val_list *negate_eval__(negate *this ) ;
#line 1037
struct dice_vtable__  const  dice_vt__ ;
#line 1039
void dice_printtree__(dice *this , int depth ) ;
#line 1040
struct roll_value *dice_roll__(dice *this ) ;
#line 1041
struct val_list *dice_eval__(dice *this ) ;
#line 1065
struct sum_vtable__  const  sum_vt__ ;
#line 1067
void sum_printtree__(sum *this , int depth ) ;
#line 1068
struct roll_value *sum_roll__(sum *this ) ;
#line 1069
void sum_set_ordering__(sum *this , ordering_type ordering ) ;
#line 1070
struct val_list *sum_eval__(sum *this ) ;
#line 1071
expression *sum_optimize__(sum *this ) ;
#line 1095
struct prod_vtable__  const  prod_vt__ ;
#line 1097
void prod_printtree__(prod *this , int depth ) ;
#line 1098
struct roll_value *prod_roll__(prod *this ) ;
#line 1099
void prod_set_ordering__(prod *this , ordering_type ordering ) ;
#line 1100
struct val_list *prod_eval__(prod *this ) ;
#line 1124
struct count_vtable__  const  count_vt__ ;
#line 1126
void count_printtree__(count *this , int depth ) ;
#line 1127
struct roll_value *count_roll__(count *this ) ;
#line 1128
void count_set_ordering__(count *this , ordering_type ordering ) ;
#line 1129
struct val_list *count_eval__(count *this ) ;
#line 1153
struct perm_vtable__  const  perm_vt__ ;
#line 1155
void perm_printtree__(perm *this , int depth ) ;
#line 1156
struct roll_value *perm_roll__(perm *this ) ;
#line 1157
void perm_set_ordering__(perm *this , ordering_type ordering ) ;
#line 1158
struct val_list *perm_eval__(perm *this ) ;
#line 1182
struct sort_vtable__  const  sort_vt__ ;
#line 1184
void sort_printtree__(sort *this , int depth ) ;
#line 1185
struct roll_value *sort_roll__(sort *this ) ;
#line 1186
void sort_set_ordering__(sort *this , ordering_type ordering ) ;
#line 1187
struct val_list *sort_eval__(sort *this ) ;
#line 1211
struct rev_vtable__  const  rev_vt__ ;
#line 1213
void rev_printtree__(rev *this , int depth ) ;
#line 1214
struct roll_value *rev_roll__(rev *this ) ;
#line 1215
struct val_list *rev_eval__(rev *this ) ;
#line 1221
expression *sumrepdice_create(struct val_list *num_dice , int num_sides ) ;
#line 1222
expression *sumrepany_create(struct val_list *number___0 , struct val_list *data ) ;
#line 1264
int yyisa__(void const   *vtable__ , int kind__ ) ;
#line 1294
void yynodeinit(void) ;
#line 1295
void *yynodealloc(unsigned int size__ ) ;
#line 1296
int yynodepush(void) ;
#line 1297
void yynodepop(void) ;
#line 1298
void yynodeclear(void) ;
#line 4 "printtree.tc"
void indent(int depth ) 
{ 
  int i ;

  {
#line 6
  i = 0;
  {
#line 6
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6
    if (! (i < depth)) {
#line 6
      goto while_break;
    }
    {
#line 7
    printf((char const   */* __restrict  */)"  ");
#line 6
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9
  return;
}
}
#line 24 "eval.tc"
struct val_list *list_new(size_t count___0 , double prob ) 
{ 
  struct val_list *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 25
  tmp = malloc(sizeof(struct val_list ));
#line 25
  ret = (struct val_list *)tmp;
#line 26
  ret->next = (struct val_list *)((void *)0);
#line 27
  ret->prob = prob;
#line 28
  ret->count = (int )count___0;
  }
#line 29
  if (count___0) {
    {
#line 29
    tmp___0 = malloc(count___0 * sizeof(int ));
#line 29
    ret->values = (int *)tmp___0;
    }
  } else {
#line 29
    ret->values = (int *)((void *)0);
  }
  {
#line 30
  memset((void *)ret->values, 0, count___0 * sizeof(int ));
  }
#line 31
  return (ret);
}
}
#line 35 "eval.tc"
void list_add(struct val_list **ret , struct val_list *cret , ordering_type ordering ) 
{ 
  struct val_list *search ;
  struct val_list *lsearch ;
  int tmp ;

  {
#line 38
  search = *ret;
#line 39
  lsearch = (struct val_list *)((void *)0);
#line 40
  if ((unsigned int )ordering == 0U) {
    {
#line 41
    quicksort(cret->values, 0, cret->count - 1);
    }
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! search) {
#line 43
      goto while_break;
    }
#line 44
    if (search->count == cret->count) {
      {
#line 44
      tmp = memcmp((void const   *)search->values, (void const   *)cret->values, (unsigned long )cret->count * sizeof(int ));
      }
#line 44
      if (tmp == 0) {
#line 47
        goto while_break;
      }
    }
#line 49
    lsearch = search;
#line 50
    search = search->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (search) {
    {
#line 54
    search->prob += cret->prob;
#line 55
    free((void *)cret->values);
#line 56
    free((void *)cret);
    }
  } else
#line 58
  if (lsearch) {
#line 59
    lsearch->next = cret;
  } else {
#line 62
    *ret = cret;
  }
#line 64
  return;
}
}
#line 66 "eval.tc"
struct val_list *error_val(void) 
{ 
  struct val_list *ret ;
  struct val_list *tmp ;

  {
  {
#line 67
  tmp = list_new((size_t )1, 1.0);
#line 67
  ret = tmp;
#line 68
  *(ret->values + 0) = 0;
  }
#line 69
  return (ret);
}
}
#line 72 "eval.tc"
void list_free(struct val_list *list ) 
{ 
  struct val_list *cur ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 73
      goto while_break;
    }
    {
#line 74
    cur = list;
#line 75
    list = list->next;
#line 76
    free((void *)cur->values);
#line 77
    free((void *)cur);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 771 "eval.tc"
void rec_whiledo(struct val_list *v , char *varname , struct symtab *symtab , expression *expr ,
                 int *data , int count___0 , struct val_list **ret , ordering_type ordering ) 
{ 
  struct val_list *cv ;
  int ccount ;
  int *cdata ;
  void *tmp ;
  struct symtab *nst ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct val_list *x ;
  struct val_list *tmp___3 ;
  struct val_list *cx ;
  struct val_list *cur ;
  struct val_list *tmp___4 ;

  {
#line 774
  cv = v;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! cv) {
#line 775
      goto while_break;
    }
    {
#line 777
    ccount = count___0 + cv->count;
#line 778
    tmp = malloc((unsigned long )ccount * sizeof(int ));
#line 778
    cdata = (int *)tmp;
#line 779
    memcpy((void */* __restrict  */)cdata, (void const   */* __restrict  */)data,
           (unsigned long )count___0 * sizeof(int ));
#line 780
    memcpy((void */* __restrict  */)(cdata + count___0), (void const   */* __restrict  */)cv->values,
           (unsigned long )cv->count * sizeof(int ));
    }
#line 782
    if (cv->count != 0) {
#line 782
      if (cv->prob >= (double )cmd_threshold) {
        {
#line 784
        tmp___0 = malloc(sizeof(struct symtab ));
#line 784
        nst = (struct symtab *)tmp___0;
#line 785
        nst->name = varname;
#line 786
        tmp___1 = malloc(sizeof(struct roll_value ));
#line 786
        nst->__annonCompField1.rvalue = (struct roll_value *)tmp___1;
#line 787
        (nst->__annonCompField1.rvalue)->count = cv->count;
#line 788
        tmp___2 = malloc(sizeof(int ) * (unsigned long )cv->count);
#line 788
        (nst->__annonCompField1.rvalue)->values = (int *)tmp___2;
#line 789
        memcpy((void */* __restrict  */)(nst->__annonCompField1.rvalue)->values, (void const   */* __restrict  */)cv->values,
               sizeof(int ) * (unsigned long )cv->count);
#line 790
        nst->next = symtab;
#line 791
        (*(((struct expression_vtable__ *)expr->vtable__)->set_symtab_v__))(expr,
                                                                            nst);
#line 793
        tmp___3 = (*(((struct expression_vtable__ *)expr->vtable__)->eval_v__))(expr);
#line 793
        x = tmp___3;
#line 795
        cx = x;
        }
        {
#line 796
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 796
          if (! cx) {
#line 796
            goto while_break___0;
          }
#line 797
          cx->prob *= cv->prob;
#line 798
          cx = cx->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 801
        rec_whiledo(x, varname, symtab, expr, cdata, ccount, ret, ordering);
#line 803
        free((void *)cdata);
#line 804
        free_roll(nst->__annonCompField1.rvalue);
#line 805
        free((void *)nst);
#line 806
        list_free(x);
        }
      } else {
        {
#line 810
        tmp___4 = list_new((size_t )ccount, cv->prob);
#line 810
        cur = tmp___4;
#line 811
        free((void *)cur->values);
#line 812
        cur->values = cdata;
#line 813
        list_add(ret, cur, ordering);
        }
      }
    } else {
      {
#line 810
      tmp___4 = list_new((size_t )ccount, cv->prob);
#line 810
      cur = tmp___4;
#line 811
      free((void *)cur->values);
#line 812
      cur->values = cdata;
#line 813
      list_add(ret, cur, ordering);
      }
    }
#line 816
    cv = cv->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  return;
}
}
#line 938 "eval.tc"
void cb_perm(int *data , int count___0 , void *arg , float farg ) 
{ 
  struct val_list **pret ;
  struct val_list *current ;
  struct val_list *tmp ;

  {
  {
#line 939
  pret = (struct val_list **)arg;
#line 940
  tmp = list_new((size_t )count___0, (double )farg);
#line 940
  current = tmp;
#line 941
  memcpy((void */* __restrict  */)current->values, (void const   */* __restrict  */)data,
         (unsigned long )current->count * sizeof(int ));
#line 945
  list_add(pret, current, (ordering_type )1);
  }
#line 946
  return;
}
}
#line 14 "optimize.tc"
double Fsumdice(double *cache , int mnum , int num , int sides , int pos ) 
{ 
  int i ;
  double ret ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
#line 15
  if (pos > (num * sides - num) / 2 + num) {
#line 16
    pos = (num * sides - pos) + num;
  }
#line 19
  if (num == 1) {
#line 20
    if (pos < 1) {
#line 21
      return (0.0);
    } else
#line 20
    if (pos > sides) {
#line 21
      return (0.0);
    }
#line 23
    return (1.0 / (double )sides);
  } else {
#line 26
    if (pos < num) {
#line 27
      return (0.0);
    }
#line 30
    if (*(cache + (mnum * (pos - num) + num)) < - 0.5) {
#line 31
      ret = (double )0;
#line 32
      i = 1;
      {
#line 32
      while (1) {
        while_continue: /* CIL Label */ ;
#line 32
        if (pos > sides + 1) {
#line 32
          tmp___1 = sides + 1;
        } else {
#line 32
          tmp___1 = pos;
        }
#line 32
        if (! (i < tmp___1)) {
#line 32
          goto while_break;
        }
        {
#line 33
        tmp = Fsumdice(cache, mnum, 1, sides, i);
#line 33
        tmp___0 = Fsumdice(cache, mnum, num - 1, sides, pos - i);
#line 33
        ret += tmp * tmp___0;
#line 32
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 36
      *(cache + (mnum * (pos - num) + num)) = ret;
#line 37
      return (ret);
    }
#line 39
    return (*(cache + (mnum * (pos - num) + num)));
  }
}
}
#line 45 "optimize.tc"
double Fsumany(double *cache , int mnum , int minval , int maxval , int num , struct val_list *dist ,
               int pos ) 
{ 
  struct val_list *cdist ;
  int cpos ;
  double ret ;
  double tmp ;

  {
#line 47
  cdist = dist;
#line 48
  if (num == 1) {
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      if (! cdist) {
#line 49
        goto while_break;
      }
#line 50
      if (*(cdist->values + 0) == pos) {
#line 51
        return (cdist->prob);
      }
#line 53
      cdist = cdist->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 55
    return (0.0);
  } else {
#line 58
    cpos = pos * mnum + num;
#line 59
    if (pos < minval * num) {
#line 60
      return (0.0);
    } else
#line 59
    if (pos > maxval * pos) {
#line 60
      return (0.0);
    }
#line 62
    if (*(cache + cpos) < - 0.5) {
#line 63
      ret = 0.0;
      {
#line 64
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 64
        if (! cdist) {
#line 64
          goto while_break___0;
        }
        {
#line 65
        tmp = Fsumany(cache, mnum, minval, maxval, num - 1, dist, pos - *(cdist->values + 0));
#line 65
        ret += cdist->prob * tmp;
#line 67
        cdist = cdist->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 69
      *(cache + cpos) = ret;
#line 70
      return (ret);
    }
#line 72
    return (*(cache + cpos));
  }
}
}
#line 50 "c_skel.c"
static YYNODESTATE fixed_state__  ;
#line 97 "c_skel.c"
void yynodeinit(void) 
{ 
  YYNODESTATE *state__ ;

  {
#line 99
  state__ = & fixed_state__;
#line 101
  state__->blocks__ = (struct YYNODESTATE_block *)0;
#line 102
  state__->push_stack__ = (struct YYNODESTATE_push *)0;
#line 103
  state__->used__ = 0;
#line 104
  return;
}
}
#line 115 "c_skel.c"
void *yynodealloc(unsigned int size__ ) 
{ 
  YYNODESTATE *state__ ;
  struct YYNODESTATE_block *block__ ;
  void *result__ ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  void *tmp___49 ;

  {
#line 118
  state__ = & fixed_state__;
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
    tmp___19 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
  } else {
#line 124
    tmp___19 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field) > tmp___19) {
#line 124
    tmp___18 = (unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field);
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
      tmp___17 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
    } else {
#line 124
      tmp___17 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
    }
#line 124
    tmp___18 = tmp___17;
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
    tmp___23 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
  } else {
#line 124
    tmp___23 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field) > tmp___23) {
#line 124
    tmp___22 = (unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field);
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
      tmp___21 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
    } else {
#line 124
      tmp___21 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
    }
#line 124
    tmp___22 = tmp___21;
  }
#line 124
  if (tmp___18 > tmp___22) {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
      tmp___10 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
    } else {
#line 124
      tmp___10 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
    }
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field) > tmp___10) {
#line 124
      tmp___9 = (unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field);
    } else {
#line 124
      if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
        tmp___8 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
      } else {
#line 124
        tmp___8 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
      }
#line 124
      tmp___9 = tmp___8;
    }
#line 124
    tmp___15 = tmp___9;
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
      tmp___14 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
    } else {
#line 124
      tmp___14 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
    }
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field) > tmp___14) {
#line 124
      tmp___13 = (unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field);
    } else {
#line 124
      if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
        tmp___12 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
      } else {
#line 124
        tmp___12 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
      }
#line 124
      tmp___13 = tmp___12;
    }
#line 124
    tmp___15 = tmp___13;
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
    tmp___44 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
  } else {
#line 124
    tmp___44 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field) > tmp___44) {
#line 124
    tmp___43 = (unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field);
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
      tmp___42 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
    } else {
#line 124
      tmp___42 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
    }
#line 124
    tmp___43 = tmp___42;
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
    tmp___48 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
  } else {
#line 124
    tmp___48 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
  }
#line 124
  if ((unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field) > tmp___48) {
#line 124
    tmp___47 = (unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field);
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
      tmp___46 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
    } else {
#line 124
      tmp___46 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
    }
#line 124
    tmp___47 = tmp___46;
  }
#line 124
  if (tmp___43 > tmp___47) {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
      tmp___35 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
    } else {
#line 124
      tmp___35 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
    }
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field) > tmp___35) {
#line 124
      tmp___34 = (unsigned int )(& ((struct _YYNODESTATE_align_int *)0)->field);
    } else {
#line 124
      if ((unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field)) {
#line 124
        tmp___33 = (unsigned int )(& ((struct _YYNODESTATE_align_long *)0)->field);
      } else {
#line 124
        tmp___33 = (unsigned int )(& ((struct _YYNODESTATE_align_long_long *)0)->field);
      }
#line 124
      tmp___34 = tmp___33;
    }
#line 124
    tmp___40 = tmp___34;
  } else {
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
      tmp___39 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
    } else {
#line 124
      tmp___39 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
    }
#line 124
    if ((unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field) > tmp___39) {
#line 124
      tmp___38 = (unsigned int )(& ((struct _YYNODESTATE_align_void_p *)0)->field);
    } else {
#line 124
      if ((unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field) > (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field)) {
#line 124
        tmp___37 = (unsigned int )(& ((struct _YYNODESTATE_align_float *)0)->field);
      } else {
#line 124
        tmp___37 = (unsigned int )(& ((struct _YYNODESTATE_align_double *)0)->field);
      }
#line 124
      tmp___38 = tmp___37;
    }
#line 124
    tmp___40 = tmp___38;
  }
#line 124
  size__ = ((size__ + tmp___15) - 1U) & ~ (tmp___40 - 1U);
#line 128
  block__ = state__->blocks__;
#line 129
  if (! block__) {
#line 129
    goto _L;
  } else
#line 129
  if ((unsigned int )state__->used__ + size__ > 2048U) {
    _L: /* CIL Label */ 
#line 131
    if (size__ > 2048U) {
#line 134
      return ((void *)0);
    }
    {
#line 136
    tmp___49 = malloc(sizeof(struct YYNODESTATE_block ));
#line 136
    block__ = (struct YYNODESTATE_block *)tmp___49;
    }
#line 138
    if (! block__) {
      {
#line 146
      yynodefailed();
      }
#line 148
      return ((void *)0);
    }
#line 150
    block__->next__ = state__->blocks__;
#line 151
    state__->blocks__ = block__;
#line 152
    state__->used__ = 0;
  }
#line 156
  result__ = (void *)(block__->data__ + state__->used__);
#line 157
  state__->used__ = (int )((unsigned int )state__->used__ + size__);
#line 158
  return (result__);
}
}
#line 169 "c_skel.c"
int yynodepush(void) 
{ 
  YYNODESTATE *state__ ;
  struct YYNODESTATE_block *saved_block__ ;
  int saved_used__ ;
  struct YYNODESTATE_push *push_item__ ;
  void *tmp ;

  {
  {
#line 171
  state__ = & fixed_state__;
#line 178
  saved_block__ = state__->blocks__;
#line 179
  saved_used__ = state__->used__;
#line 186
  tmp = yynodealloc((unsigned int )sizeof(struct YYNODESTATE_push ));
#line 186
  push_item__ = (struct YYNODESTATE_push *)tmp;
  }
#line 189
  if (! push_item__) {
#line 191
    return (0);
  }
#line 195
  push_item__->saved_block__ = saved_block__;
#line 196
  push_item__->saved_used__ = saved_used__;
#line 199
  push_item__->next__ = state__->push_stack__;
#line 200
  state__->push_stack__ = push_item__;
#line 201
  return (1);
}
}
#line 212 "c_skel.c"
void yynodepop(void) 
{ 
  YYNODESTATE *state__ ;
  struct YYNODESTATE_push *push_item__ ;
  struct YYNODESTATE_block *saved_block__ ;
  struct YYNODESTATE_block *temp_block__ ;

  {
#line 214
  state__ = & fixed_state__;
#line 221
  push_item__ = state__->push_stack__;
#line 222
  if ((unsigned long )push_item__ == (unsigned long )((struct YYNODESTATE_push *)0)) {
#line 224
    saved_block__ = (struct YYNODESTATE_block *)0;
#line 225
    state__->used__ = 0;
  } else {
#line 229
    saved_block__ = push_item__->saved_block__;
#line 230
    state__->used__ = push_item__->saved_used__;
#line 231
    state__->push_stack__ = push_item__->next__;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! ((unsigned long )state__->blocks__ != (unsigned long )saved_block__)) {
#line 235
      goto while_break;
    }
    {
#line 237
    temp_block__ = state__->blocks__;
#line 238
    state__->blocks__ = temp_block__->next__;
#line 239
    free((void *)temp_block__);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 251 "c_skel.c"
void yynodeclear(void) 
{ 
  YYNODESTATE *state__ ;
  struct YYNODESTATE_block *temp_block__ ;

  {
#line 253
  state__ = & fixed_state__;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned long )state__->blocks__ != (unsigned long )((struct YYNODESTATE_block *)0))) {
#line 256
      goto while_break;
    }
    {
#line 258
    temp_block__ = state__->blocks__;
#line 259
    state__->blocks__ = temp_block__->next__;
#line 260
    free((void *)temp_block__);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  state__->push_stack__ = (struct YYNODESTATE_push *)0;
#line 263
  state__->used__ = 0;
#line 264
  return;
}
}
#line 493 "tree.c"
void expression_set_ordering__(expression *this , ordering_type ordering ) 
{ 


  {
#line 8 "ordering.tc"
  this->ordering = ordering;
#line 9
  return;
}
}
#line 500 "tree.c"
expression *expression_optimize__(expression *this ) 
{ 


  {
#line 226 "optimize.tc"
  return (this);
}
}
#line 507 "tree.c"
struct expression_vtable__  const  expression_vt__  = 
#line 507 "tree.c"
     {(void const   *)0, 14, "expression", (void (*)(expression *this__ , int depth ))0,
    (struct roll_value *(*)(expression *this__ ))0, (void (*)(expression *this__ ,
                                                              struct symtab *st ))0,
    & expression_set_ordering__, (struct val_list *(*)(expression *this__ ))0, & expression_optimize__};
#line 519 "tree.c"
void elist_printtree__(elist *this , int depth ) 
{ 


  {
  {
#line 14 "printtree.tc"
  indent(depth);
#line 15
  printf((char const   */* __restrict  */)"empty list\n");
  }
#line 16
  return;
}
}
#line 527 "tree.c"
struct roll_value *elist_roll__(elist *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 5 "roll.tc"
  tmp = new_roll_single(0);
#line 5
  rv = tmp;
#line 6
  rv->count = 0;
  }
#line 7
  return (rv);
}
}
#line 536 "tree.c"
void elist_set_symtab__(elist *this , struct symtab *st ) 
{ 


  {
#line 21 "symtab.tc"
  return;
}
}
#line 542 "tree.c"
struct val_list *elist_eval__(elist *this ) 
{ 
  struct val_list *tmp ;

  {
  {
#line 84 "eval.tc"
  tmp = list_new((size_t )0, 1.0);
  }
#line 84
  return (tmp);
}
}
#line 549 "tree.c"
struct elist_vtable__  const  elist_vt__  = 
#line 549 "tree.c"
     {& expression_vt__, 15, "elist", (void (*)(expression *this__ , int depth ))(& elist_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& elist_roll__), (void (*)(expression *this__ ,
                                                                             struct symtab *st ))(& elist_set_symtab__),
    & expression_set_ordering__, (struct val_list *(*)(expression *this__ ))(& elist_eval__),
    & expression_optimize__};
#line 561 "tree.c"
void binary_set_symtab__(binary *this , struct symtab *st ) 
{ 


  {
  {
#line 40 "symtab.tc"
  this->symtab = st;
#line 41
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->set_symtab_v__))(this->expr1,
                                                                               st);
#line 42
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               st);
  }
#line 43
  return;
}
}
#line 570 "tree.c"
void binary_set_ordering__(binary *this , ordering_type ordering ) 
{ 


  {
  {
#line 19 "ordering.tc"
  this->ordering = ordering;
#line 20
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->set_ordering_v__))(this->expr1,
                                                                                 ordering);
#line 21
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_ordering_v__))(this->expr2,
                                                                                 ordering);
  }
#line 22
  return;
}
}
#line 579 "tree.c"
expression *binary_optimize__(binary *this ) 
{ 


  {
  {
#line 231 "optimize.tc"
  this->expr1 = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->optimize_v__))(this->expr1);
#line 232
  this->expr2 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->optimize_v__))(this->expr2);
  }
#line 233
  return ((expression *)this);
}
}
#line 588 "tree.c"
struct binary_vtable__  const  binary_vt__  = 
#line 588 "tree.c"
     {& expression_vt__, 16, "binary", (void (*)(expression *this__ , int depth ))0,
    (struct roll_value *(*)(expression *this__ ))0, (void (*)(expression *this__ ,
                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))0, (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 600 "tree.c"
void unary_set_symtab__(unary *this , struct symtab *st ) 
{ 


  {
  {
#line 34 "symtab.tc"
  this->symtab = st;
#line 35
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_symtab_v__))(this->expr,
                                                                              st);
  }
#line 36
  return;
}
}
#line 608 "tree.c"
void unary_set_ordering__(unary *this , ordering_type ordering ) 
{ 


  {
  {
#line 13 "ordering.tc"
  this->ordering = ordering;
#line 14
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                ordering);
  }
#line 15
  return;
}
}
#line 616 "tree.c"
expression *unary_optimize__(unary *this ) 
{ 


  {
  {
#line 238 "optimize.tc"
  this->expr = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->optimize_v__))(this->expr);
  }
#line 239
  return ((expression *)this);
}
}
#line 624 "tree.c"
struct unary_vtable__  const  unary_vt__  = 
#line 624 "tree.c"
     {& expression_vt__, 17, "unary", (void (*)(expression *this__ , int depth ))0,
    (struct roll_value *(*)(expression *this__ ))0, (void (*)(expression *this__ ,
                                                              struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& unary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))0, (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 636 "tree.c"
void number_printtree__(number *this , int depth ) 
{ 


  {
  {
#line 20 "printtree.tc"
  indent(depth);
#line 21
  printf((char const   */* __restrict  */)"%i\n", this->num);
  }
#line 22
  return;
}
}
#line 644 "tree.c"
struct roll_value *number_roll__(number *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 12 "roll.tc"
  tmp = new_roll_single(this->num);
#line 12
  rv = tmp;
  }
#line 13
  return (rv);
}
}
#line 652 "tree.c"
void number_set_symtab__(number *this , struct symtab *st ) 
{ 


  {
#line 25 "symtab.tc"
  return;
}
}
#line 658 "tree.c"
struct val_list *number_eval__(number *this ) 
{ 
  struct val_list *ret ;
  struct val_list *tmp ;

  {
  {
#line 1006 "eval.tc"
  tmp = list_new((size_t )1, 1.0);
#line 1006
  ret = tmp;
#line 1007
  *(ret->values + 0) = this->num;
  }
#line 1008
  return (ret);
}
}
#line 667 "tree.c"
struct number_vtable__  const  number_vt__  = 
#line 667 "tree.c"
     {& expression_vt__, 18, "number", (void (*)(expression *this__ , int depth ))(& number_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& number_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& number_set_symtab__),
    & expression_set_ordering__, (struct val_list *(*)(expression *this__ ))(& number_eval__),
    & expression_optimize__};
#line 679 "tree.c"
void ifthenelse_printtree__(ifthenelse *this , int depth ) 
{ 


  {
  {
#line 242 "printtree.tc"
  indent(depth);
#line 243
  printf((char const   */* __restrict  */)"if\n");
#line 244
  (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->printtree_v__))(this->if_expr,
                                                                                depth + 1);
#line 245
  indent(depth);
#line 246
  printf((char const   */* __restrict  */)"then\n");
#line 247
  (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->printtree_v__))(this->then_expr,
                                                                                  depth + 1);
#line 248
  indent(depth);
#line 249
  printf((char const   */* __restrict  */)"else\n");
#line 250
  (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->printtree_v__))(this->else_expr,
                                                                                  depth + 1);
  }
#line 251
  return;
}
}
#line 694 "tree.c"
struct roll_value *ifthenelse_roll__(ifthenelse *this ) 
{ 
  struct roll_value *if_expr ;
  struct roll_value *tmp ;
  struct roll_value *tmp___0 ;
  struct roll_value *tmp___1 ;

  {
  {
#line 487 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->roll_v__))(this->if_expr);
#line 487
  if_expr = tmp;
  }
#line 488
  if (if_expr->count > 0) {
    {
#line 489
    free_roll(if_expr);
#line 490
    tmp___0 = (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->roll_v__))(this->then_expr);
    }
#line 490
    return (tmp___0);
  } else {
    {
#line 493
    free_roll(if_expr);
#line 494
    tmp___1 = (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->roll_v__))(this->else_expr);
    }
#line 494
    return (tmp___1);
  }
}
}
#line 709 "tree.c"
void ifthenelse_set_symtab__(ifthenelse *this , struct symtab *st ) 
{ 


  {
  {
#line 47 "symtab.tc"
  this->symtab = st;
#line 48
  (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->set_symtab_v__))(this->if_expr,
                                                                                 st);
#line 49
  (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->set_symtab_v__))(this->then_expr,
                                                                                   st);
#line 50
  (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->set_symtab_v__))(this->else_expr,
                                                                                   st);
  }
#line 51
  return;
}
}
#line 719 "tree.c"
void ifthenelse_set_ordering__(ifthenelse *this , ordering_type ordering ) 
{ 


  {
  {
#line 70 "ordering.tc"
  this->ordering = ordering;
#line 71
  (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->set_ordering_v__))(this->if_expr,
                                                                                   (ordering_type )0);
#line 72
  (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->set_ordering_v__))(this->then_expr,
                                                                                     ordering);
#line 73
  (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->set_ordering_v__))(this->else_expr,
                                                                                     ordering);
  }
#line 74
  return;
}
}
#line 729 "tree.c"
struct val_list *ifthenelse_eval__(ifthenelse *this ) 
{ 
  struct val_list *cnt ;
  struct val_list *tmp ;
  struct val_list *ccnt ;
  struct val_list *ret ;
  struct val_list *cur ;
  struct val_list *temp ;

  {
  {
#line 1013 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->eval_v__))(this->if_expr);
#line 1013
  cnt = tmp;
#line 1014
  ccnt = cnt;
#line 1015
  ret = (struct val_list *)((void *)0);
  }
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    if (! ccnt) {
#line 1017
      goto while_break;
    }
#line 1019
    if (ccnt->count > 0) {
      {
#line 1020
      cur = (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->eval_v__))(this->then_expr);
      }
    } else {
      {
#line 1023
      cur = (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->eval_v__))(this->else_expr);
      }
    }
    {
#line 1026
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1026
      if (! cur) {
#line 1026
        goto while_break___0;
      }
      {
#line 1027
      temp = cur;
#line 1028
      cur = cur->next;
#line 1029
      temp->next = (struct val_list *)((void *)0);
#line 1030
      temp->prob *= ccnt->prob;
#line 1031
      list_add(& ret, temp, this->ordering);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1033
    ccnt = ccnt->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  list_free(cnt);
  }
#line 1036
  return (ret);
}
}
#line 759 "tree.c"
expression *ifthenelse_optimize__(ifthenelse *this ) 
{ 


  {
  {
#line 244 "optimize.tc"
  this->if_expr = (*(((struct expression_vtable__ *)(this->if_expr)->vtable__)->optimize_v__))(this->if_expr);
#line 245
  this->then_expr = (*(((struct expression_vtable__ *)(this->then_expr)->vtable__)->optimize_v__))(this->then_expr);
#line 246
  this->else_expr = (*(((struct expression_vtable__ *)(this->else_expr)->vtable__)->optimize_v__))(this->else_expr);
  }
#line 247
  return ((expression *)this);
}
}
#line 769 "tree.c"
struct ifthenelse_vtable__  const  ifthenelse_vt__  = 
#line 769 "tree.c"
     {& expression_vt__, 38, "ifthenelse", (void (*)(expression *this__ , int depth ))(& ifthenelse_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& ifthenelse_roll__), (void (*)(expression *this__ ,
                                                                                  struct symtab *st ))(& ifthenelse_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& ifthenelse_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& ifthenelse_eval__), (expression *(*)(expression *this__ ))(& ifthenelse_optimize__)};
#line 781 "tree.c"
void variable_printtree__(variable *this , int depth ) 
{ 


  {
  {
#line 26 "printtree.tc"
  indent(depth);
#line 27
  printf((char const   */* __restrict  */)"%s\n", this->varname);
  }
#line 28
  return;
}
}
#line 789 "tree.c"
struct roll_value *variable_roll__(variable *this ) 
{ 
  struct symtab *nst ;
  struct roll_value *ret ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *emsg ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 515 "roll.tc"
  nst = this->symtab;
#line 516
  ret = (struct roll_value *)((void *)0);
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! ((unsigned long )nst != (unsigned long )((void *)0))) {
#line 517
      goto while_break;
    }
    {
#line 518
    tmp___1 = strcmp((char const   *)this->varname, (char const   *)nst->name);
    }
#line 518
    if (tmp___1 == 0) {
      {
#line 520
      tmp = malloc(sizeof(struct roll_value ));
#line 520
      ret = (struct roll_value *)tmp;
#line 521
      tmp___0 = malloc(sizeof(int ) * (unsigned long )(nst->__annonCompField1.rvalue)->count);
#line 521
      ret->values = (int *)tmp___0;
#line 522
      memcpy((void */* __restrict  */)ret->values, (void const   */* __restrict  */)(nst->__annonCompField1.rvalue)->values,
             sizeof(int ) * (unsigned long )(nst->__annonCompField1.rvalue)->count);
#line 524
      ret->count = (nst->__annonCompField1.rvalue)->count;
      }
#line 525
      goto while_break;
    }
#line 527
    nst = nst->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 530
    tmp___2 = strlen((char const   *)this->varname);
#line 530
    tmp___3 = malloc(sizeof(char ) * 22UL + tmp___2);
#line 530
    emsg = (char *)tmp___3;
#line 531
    sprintf((char */* __restrict  */)emsg, (char const   */* __restrict  */)"Variable \"%s\" not found",
            this->varname);
#line 532
    yyerror(emsg);
#line 533
    free((void *)emsg);
#line 534
    tmp___4 = malloc(sizeof(struct roll_value ));
#line 534
    ret = (struct roll_value *)tmp___4;
#line 535
    tmp___5 = malloc(sizeof(int ));
#line 535
    ret->values = (int *)tmp___5;
#line 536
    *(ret->values + 0) = 0;
#line 537
    ret->count = 1;
    }
  }
#line 539
  return (ret);
}
}
#line 820 "tree.c"
void variable_set_symtab__(variable *this , struct symtab *st ) 
{ 


  {
#line 29 "symtab.tc"
  this->symtab = st;
#line 30
  return;
}
}
#line 827 "tree.c"
void variable_set_ordering__(variable *this , ordering_type ordering ) 
{ 
  struct symtab *nst ;
  int tmp ;

  {
#line 78 "ordering.tc"
  this->ordering = ordering;
#line 80
  nst = this->symtab;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )nst != (unsigned long )((void *)0))) {
#line 81
      goto while_break;
    }
    {
#line 82
    tmp = strcmp((char const   *)this->varname, (char const   *)nst->name);
    }
#line 82
    if (tmp == 0) {
#line 83
      goto while_break;
    }
#line 85
    nst = nst->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (nst) {
#line 88
    if ((unsigned int )nst->__annonCompField1.ordering == 0U) {
#line 89
      nst->__annonCompField1.ordering = ordering;
    }
  }
#line 91
  return;
}
}
#line 846 "tree.c"
struct val_list *variable_eval__(variable *this ) 
{ 
  struct symtab *nst ;
  struct val_list *ret ;
  int tmp ;
  char *emsg ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 1041 "eval.tc"
  nst = this->symtab;
#line 1042
  ret = (struct val_list *)((void *)0);
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! ((unsigned long )nst != (unsigned long )((void *)0))) {
#line 1043
      goto while_break;
    }
    {
#line 1044
    tmp = strcmp((char const   *)this->varname, (char const   *)nst->name);
    }
#line 1044
    if (tmp == 0) {
      {
#line 1045
      ret = list_new((size_t )(nst->__annonCompField1.rvalue)->count, 1.0);
#line 1046
      memcpy((void */* __restrict  */)ret->values, (void const   */* __restrict  */)(nst->__annonCompField1.rvalue)->values,
             sizeof(int ) * (unsigned long )(nst->__annonCompField1.rvalue)->count);
      }
#line 1047
      goto while_break;
    }
#line 1049
    nst = nst->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 1052
    tmp___0 = strlen((char const   *)this->varname);
#line 1052
    tmp___1 = malloc(sizeof(char ) * 22UL + tmp___0);
#line 1052
    emsg = (char *)tmp___1;
#line 1053
    sprintf((char */* __restrict  */)emsg, (char const   */* __restrict  */)"Variable \"%s\" not found",
            this->varname);
#line 1054
    yyerror(emsg);
#line 1055
    free((void *)emsg);
#line 1056
    ret = error_val();
    }
  }
#line 1058
  return (ret);
}
}
#line 870 "tree.c"
struct variable_vtable__  const  variable_vt__  = 
#line 870 "tree.c"
     {& expression_vt__, 48, "variable", (void (*)(expression *this__ , int depth ))(& variable_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& variable_roll__), (void (*)(expression *this__ ,
                                                                                struct symtab *st ))(& variable_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& variable_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& variable_eval__), & expression_optimize__};
#line 882 "tree.c"
void sumrepdice_printtree__(sumrepdice *this , int depth ) 
{ 


  {
#line 91 "optimize.tc"
  return;
}
}
#line 889 "tree.c"
struct roll_value *sumrepdice_roll__(sumrepdice *this ) 
{ 


  {
#line 87 "optimize.tc"
  return ((struct roll_value *)0);
}
}
#line 896 "tree.c"
void sumrepdice_set_symtab__(sumrepdice *this , struct symtab *st ) 
{ 


  {
#line 95 "optimize.tc"
  return;
}
}
#line 903 "tree.c"
struct val_list *sumrepdice_eval__(sumrepdice *this ) 
{ 
  int n ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *tmp ;
  int num_dice_val ;
  int expected ;
  double *cache ;
  void *tmp___0 ;
  struct val_list *cret ;
  void *tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  struct val_list *tmp___4 ;

  {
#line 99 "optimize.tc"
  ret = (struct val_list *)((void *)0);
#line 100
  cnum = this->num_dice;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! cnum) {
#line 101
      goto while_break;
    }
#line 102
    if (cnum->count != 1) {
      {
#line 103
      yyerror((char *)"Argument 1 to sumrep operator is not scalar");
#line 104
      list_free(this->num_dice);
#line 105
      list_free(ret);
#line 106
      tmp = error_val();
      }
#line 106
      return (tmp);
    }
#line 108
    num_dice_val = *(cnum->values + 0);
#line 109
    if (num_dice_val > 0) {
      {
#line 110
      expected = (num_dice_val * ((num_dice_val * this->num_sides - num_dice_val) / 2) + num_dice_val) + 1;
#line 113
      tmp___0 = malloc(sizeof(double ) * (unsigned long )expected);
#line 113
      cache = (double *)tmp___0;
#line 114
      n = 0;
      }
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        if (! (n < expected)) {
#line 114
          goto while_break___0;
        }
#line 115
        *(cache + n) = - 1.0;
#line 114
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 117
      n = num_dice_val * this->num_sides;
      {
#line 117
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 117
        if (! (n >= num_dice_val)) {
#line 117
          goto while_break___1;
        }
        {
#line 119
        tmp___1 = malloc(sizeof(struct val_list ));
#line 119
        cret = (struct val_list *)tmp___1;
#line 121
        cret->next = (struct val_list *)((void *)0);
#line 122
        cret->count = 1;
#line 123
        tmp___2 = Fsumdice(cache, num_dice_val, num_dice_val, this->num_sides, n);
#line 123
        cret->prob = tmp___2 * cnum->prob;
#line 125
        tmp___3 = malloc(sizeof(int ));
#line 125
        cret->values = (int *)tmp___3;
#line 126
        *(cret->values + 0) = n;
#line 127
        list_add(& ret, cret, this->ordering);
#line 117
        n --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 129
      free((void *)cache);
      }
    }
#line 131
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 134
    tmp___4 = list_new((size_t )1, 1.0);
    }
#line 134
    return (tmp___4);
  }
#line 136
  return (ret);
}
}
#line 948 "tree.c"
struct sumrepdice_vtable__  const  sumrepdice_vt__  = 
#line 948 "tree.c"
     {& expression_vt__, 49, "sumrepdice", (void (*)(expression *this__ , int depth ))(& sumrepdice_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& sumrepdice_roll__), (void (*)(expression *this__ ,
                                                                                  struct symtab *st ))(& sumrepdice_set_symtab__),
    & expression_set_ordering__, (struct val_list *(*)(expression *this__ ))(& sumrepdice_eval__),
    & expression_optimize__};
#line 960 "tree.c"
void sumrepany_printtree__(sumrepany *this , int depth ) 
{ 


  {
#line 151 "optimize.tc"
  return;
}
}
#line 967 "tree.c"
struct roll_value *sumrepany_roll__(sumrepany *this ) 
{ 


  {
#line 147 "optimize.tc"
  return ((struct roll_value *)0);
}
}
#line 974 "tree.c"
void sumrepany_set_symtab__(sumrepany *this , struct symtab *st ) 
{ 


  {
#line 155 "optimize.tc"
  return;
}
}
#line 981 "tree.c"
struct val_list *sumrepany_eval__(sumrepany *this ) 
{ 
  int n ;
  struct val_list *ret ;
  struct val_list *cnum ;
  int minval ;
  int maxval ;
  struct val_list *cval ;
  struct val_list *tmp ;
  struct val_list *cret ;
  void *tmp___0 ;
  void *tmp___1 ;
  int expected ;
  double *cache ;
  void *tmp___2 ;
  struct val_list *cret___0 ;
  void *tmp___3 ;
  double tmp___4 ;
  void *tmp___5 ;
  struct val_list *tmp___6 ;

  {
#line 159 "optimize.tc"
  ret = (struct val_list *)((void *)0);
#line 160
  cnum = this->number;
#line 161
  minval = -1;
#line 162
  maxval = 0;
#line 163
  cval = this->data;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! cval) {
#line 164
      goto while_break;
    }
#line 165
    if (minval == -1) {
#line 166
      minval = *(cval->values + 0);
    } else
#line 165
    if (*(cval->values + 0) < minval) {
#line 166
      minval = *(cval->values + 0);
    }
#line 168
    if (*(cval->values + 0) > maxval) {
#line 169
      maxval = *(cval->values + 0);
    }
#line 171
    cval = cval->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! cnum) {
#line 173
      goto while_break___0;
    }
#line 174
    if (cnum->count != 1) {
      {
#line 175
      yyerror((char *)"Argument 1 to sumrep operator is not scalar");
#line 176
      list_free(this->number);
#line 177
      list_free(this->data);
#line 178
      list_free(ret);
#line 179
      tmp = error_val();
      }
#line 179
      return (tmp);
    }
#line 181
    if (*(cnum->values + 0) == 0) {
      {
#line 182
      tmp___0 = malloc(sizeof(struct val_list ));
#line 182
      cret = (struct val_list *)tmp___0;
#line 184
      cret->next = (struct val_list *)((void *)0);
#line 185
      cret->count = 1;
#line 186
      cret->prob = cnum->prob;
#line 187
      tmp___1 = malloc(sizeof(int ));
#line 187
      cret->values = (int *)tmp___1;
#line 188
      *(cret->values + 0) = 0;
#line 189
      list_add(& ret, cret, this->ordering);
      }
    } else {
      {
#line 192
      expected = (*(cnum->values + 0) * maxval + 1) * *(cnum->values + 0) + 1;
#line 193
      tmp___2 = malloc(sizeof(double ) * (unsigned long )expected);
#line 193
      cache = (double *)tmp___2;
#line 194
      n = 0;
      }
      {
#line 194
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 194
        if (! (n < expected)) {
#line 194
          goto while_break___1;
        }
#line 195
        *(cache + n) = - 1.0;
#line 194
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 197
      n = *(cnum->values + 0) * minval;
      {
#line 197
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 197
        if (! (n <= *(cnum->values + 0) * maxval)) {
#line 197
          goto while_break___2;
        }
        {
#line 198
        tmp___3 = malloc(sizeof(struct val_list ));
#line 198
        cret___0 = (struct val_list *)tmp___3;
#line 200
        cret___0->next = (struct val_list *)((void *)0);
#line 201
        cret___0->count = 1;
#line 202
        tmp___4 = Fsumany(cache, *(cnum->values + 0), minval, maxval, *(cnum->values + 0),
                          this->data, n);
#line 202
        cret___0->prob = tmp___4 * cnum->prob;
#line 204
        tmp___5 = malloc(sizeof(int ));
#line 204
        cret___0->values = (int *)tmp___5;
#line 205
        *(cret___0->values + 0) = n;
        }
#line 206
        if (cret___0->prob > (double )1.17549435082228750797e-38F) {
          {
#line 207
          list_add(& ret, cret___0, this->ordering);
          }
        } else {
          {
#line 210
          list_free(cret___0);
          }
        }
#line 197
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 213
      free((void *)cache);
      }
    }
#line 215
    cnum = cnum->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 217
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 218
    tmp___6 = list_new((size_t )1, 1.0);
    }
#line 218
    return (tmp___6);
  }
#line 220
  return (ret);
}
}
#line 1050 "tree.c"
struct sumrepany_vtable__  const  sumrepany_vt__  = 
#line 1050 "tree.c"
     {& expression_vt__, 50, "sumrepany", (void (*)(expression *this__ , int depth ))(& sumrepany_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& sumrepany_roll__), (void (*)(expression *this__ ,
                                                                                 struct symtab *st ))(& sumrepany_set_symtab__),
    & expression_set_ordering__, (struct val_list *(*)(expression *this__ ))(& sumrepany_eval__),
    & expression_optimize__};
#line 1062 "tree.c"
void mathop_printtree__(mathop *this , int depth ) 
{ 


  {
  {
#line 39 "printtree.tc"
  indent(depth);
  }
  {
#line 41
  if (this->kind__ == 28) {
#line 41
    goto case_28;
  }
#line 44
  if (this->kind__ == 29) {
#line 44
    goto case_29;
  }
#line 47
  if (this->kind__ == 30) {
#line 47
    goto case_30;
  }
#line 50
  if (this->kind__ == 31) {
#line 50
    goto case_31;
  }
#line 53
  if (this->kind__ == 32) {
#line 53
    goto case_32;
  }
#line 56
  if (this->kind__ == 33) {
#line 56
    goto case_33;
  }
#line 59
  goto switch_default;
  case_28: /* CIL Label */ 
  {
#line 42
  printf((char const   */* __restrict  */)"+\n");
  }
#line 43
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 45
  printf((char const   */* __restrict  */)"-\n");
  }
#line 46
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 48
  printf((char const   */* __restrict  */)"*\n");
  }
#line 49
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 51
  printf((char const   */* __restrict  */)"/\n");
  }
#line 52
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 54
  printf((char const   */* __restrict  */)"%%\n");
  }
#line 55
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 57
  printf((char const   */* __restrict  */)"^\n");
  }
#line 58
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 60
  yyerror((char *)"Unknown math op");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 63
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 64
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 65
  return;
}
}
#line 1094 "tree.c"
struct roll_value *mathop_roll__(mathop *this ) 
{ 
  struct roll_value *rv1 ;
  struct roll_value *tmp ;
  struct roll_value *rv2 ;
  struct roll_value *tmp___0 ;
  double tmp___1 ;

  {
  {
#line 18 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 18
  rv1 = tmp;
#line 19
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 19
  rv2 = tmp___0;
  }
#line 20
  if (rv1->count != 1) {
    {
#line 21
    yyerror((char *)"Argument 1 to math op isn\'t scalar");
#line 22
    free_roll(rv2);
#line 23
    rv1->count = 1;
#line 24
    *(rv1->values + 0) = 0;
    }
#line 25
    return (rv1);
  }
#line 27
  if (rv2->count != 1) {
    {
#line 28
    yyerror((char *)"Argument 2 to math op isn\'t scalar");
#line 29
    free_roll(rv2);
#line 30
    rv1->count = 1;
#line 31
    *(rv1->values + 0) = 0;
    }
#line 32
    return (rv1);
  }
  {
#line 35
  if (this->kind__ == 28) {
#line 35
    goto case_28;
  }
#line 38
  if (this->kind__ == 29) {
#line 38
    goto case_29;
  }
#line 41
  if (this->kind__ == 30) {
#line 41
    goto case_30;
  }
#line 44
  if (this->kind__ == 31) {
#line 44
    goto case_31;
  }
#line 47
  if (this->kind__ == 32) {
#line 47
    goto case_32;
  }
#line 50
  if (this->kind__ == 33) {
#line 50
    goto case_33;
  }
#line 53
  goto switch_default;
  case_28: /* CIL Label */ 
#line 36
  *(rv1->values + 0) += *(rv2->values + 0);
#line 37
  goto switch_break;
  case_29: /* CIL Label */ 
#line 39
  *(rv1->values + 0) -= *(rv2->values + 0);
#line 40
  goto switch_break;
  case_30: /* CIL Label */ 
#line 42
  *(rv1->values + 0) *= *(rv2->values + 0);
#line 43
  goto switch_break;
  case_31: /* CIL Label */ 
#line 45
  *(rv1->values + 0) /= *(rv2->values + 0);
#line 46
  goto switch_break;
  case_32: /* CIL Label */ 
#line 48
  *(rv1->values + 0) %= *(rv2->values + 0);
#line 49
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 51
  tmp___1 = pow((double )*(rv1->values + 0), (double )*(rv2->values + 0));
#line 51
  *(rv1->values + 0) = (int )tmp___1;
  }
#line 52
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 54
  yyerror((char *)"Unknown math op");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 58
  free_roll(rv2);
  }
#line 59
  return (rv1);
}
}
#line 1142 "tree.c"
struct val_list *mathop_eval__(mathop *this ) 
{ 
  struct val_list *e1 ;
  struct val_list *tmp ;
  struct val_list *e2 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *ce1 ;
  struct val_list *ce2 ;
  struct val_list *tmp___1 ;
  struct val_list *tmp___2 ;
  struct val_list *cret ;
  struct val_list *tmp___3 ;
  double tmp___4 ;
  struct val_list *tmp___5 ;

  {
  {
#line 89 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 89
  e1 = tmp;
#line 90
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 90
  e2 = tmp___0;
#line 91
  ret = (struct val_list *)((void *)0);
#line 92
  ce1 = e1;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ce1) {
#line 95
      goto while_break;
    }
#line 96
    ce2 = e2;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! ce2) {
#line 97
        goto while_break___0;
      }
#line 98
      if (ce1->count != 1) {
        {
#line 99
        yyerror((char *)"Argument 1 to math operator is not scalar");
#line 100
        list_free(e1);
#line 101
        list_free(e2);
#line 102
        tmp___1 = error_val();
        }
#line 102
        return (tmp___1);
      }
#line 104
      if (ce2->count != 1) {
        {
#line 105
        yyerror((char *)"Argument 2 to math operator is not scalar");
#line 106
        list_free(e1);
#line 107
        list_free(e2);
#line 108
        tmp___2 = error_val();
        }
#line 108
        return (tmp___2);
      }
      {
#line 110
      tmp___3 = list_new((size_t )1, ce1->prob * ce2->prob);
#line 110
      cret = tmp___3;
      }
      {
#line 112
      if (this->kind__ == 28) {
#line 112
        goto case_28;
      }
#line 115
      if (this->kind__ == 29) {
#line 115
        goto case_29;
      }
#line 118
      if (this->kind__ == 30) {
#line 118
        goto case_30;
      }
#line 121
      if (this->kind__ == 31) {
#line 121
        goto case_31;
      }
#line 124
      if (this->kind__ == 32) {
#line 124
        goto case_32;
      }
#line 127
      if (this->kind__ == 33) {
#line 127
        goto case_33;
      }
#line 130
      goto switch_default;
      case_28: /* CIL Label */ 
#line 113
      *(cret->values + 0) = *(ce1->values + 0) + *(ce2->values + 0);
#line 114
      goto switch_break;
      case_29: /* CIL Label */ 
#line 116
      *(cret->values + 0) = *(ce1->values + 0) - *(ce2->values + 0);
#line 117
      goto switch_break;
      case_30: /* CIL Label */ 
#line 119
      *(cret->values + 0) = *(ce1->values + 0) * *(ce2->values + 0);
#line 120
      goto switch_break;
      case_31: /* CIL Label */ 
#line 122
      *(cret->values + 0) = *(ce1->values + 0) / *(ce2->values + 0);
#line 123
      goto switch_break;
      case_32: /* CIL Label */ 
#line 125
      *(cret->values + 0) = *(ce1->values + 0) % *(ce2->values + 0);
#line 126
      goto switch_break;
      case_33: /* CIL Label */ 
      {
#line 128
      tmp___4 = pow((double )*(ce1->values + 0), (double )*(ce2->values + 0));
#line 128
      *(cret->values + 0) = (int )tmp___4;
      }
#line 129
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 131
      yyerror((char *)"Unknown math op");
#line 132
      list_free(e1);
#line 133
      list_free(e2);
#line 134
      tmp___5 = error_val();
      }
#line 134
      return (tmp___5);
      switch_break: /* CIL Label */ ;
      }
      {
#line 136
      list_add(& ret, cret, this->ordering);
#line 137
      ce2 = ce2->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 139
    ce1 = ce1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  list_free(e1);
#line 142
  list_free(e2);
  }
#line 143
  return (ret);
}
}
#line 1203 "tree.c"
struct mathop_vtable__  const  mathop_vt__  = 
#line 1203 "tree.c"
     {& binary_vt__, 27, "mathop", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1215 "tree.c"
void scat_printtree__(scat *this , int depth ) 
{ 


  {
  {
#line 69 "printtree.tc"
  indent(depth);
#line 70
  printf((char const   */* __restrict  */)".\n");
#line 71
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 72
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 73
  return;
}
}
#line 1225 "tree.c"
struct roll_value *scat_roll__(scat *this ) 
{ 
  struct roll_value *rv1 ;
  struct roll_value *tmp ;
  struct roll_value *rv2 ;
  struct roll_value *tmp___0 ;
  int i ;

  {
  {
#line 65 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 65
  rv1 = tmp;
#line 66
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 66
  rv2 = tmp___0;
  }
#line 67
  if (rv1->count != 1) {
    {
#line 68
    yyerror((char *)"Argument 1 to scat (.) isn\'t scalar");
#line 69
    free_roll(rv2);
#line 70
    rv1->count = 1;
#line 71
    *(rv1->values + 0) = 0;
    }
#line 72
    return (rv1);
  }
#line 74
  if (rv2->count != 1) {
    {
#line 75
    yyerror((char *)"Argument 2 to scat (.) isn\'t scalar");
#line 76
    free_roll(rv2);
#line 77
    rv1->count = 1;
#line 78
    *(rv1->values + 0) = 0;
    }
#line 79
    return (rv1);
  }
#line 81
  i = 10;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < *(rv2->values + 0))) {
#line 82
      goto while_break;
    }
#line 83
    i *= 10;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  *(rv1->values + 0) *= i;
#line 86
  *(rv1->values + 0) += *(rv2->values + 0);
#line 87
  free_roll(rv2);
  }
#line 88
  return (rv1);
}
}
#line 1255 "tree.c"
struct val_list *scat_eval__(scat *this ) 
{ 
  struct val_list *e1 ;
  struct val_list *tmp ;
  struct val_list *e2 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *ce1 ;
  struct val_list *ce2 ;
  struct val_list *tmp___1 ;
  struct val_list *tmp___2 ;
  struct val_list *cret ;
  struct val_list *tmp___3 ;
  int i ;

  {
  {
#line 149 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 149
  e1 = tmp;
#line 150
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 150
  e2 = tmp___0;
#line 151
  ret = (struct val_list *)((void *)0);
#line 152
  ce1 = e1;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ce1) {
#line 155
      goto while_break;
    }
#line 156
    ce2 = e2;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! ce2) {
#line 157
        goto while_break___0;
      }
#line 158
      if (ce1->count != 1) {
        {
#line 159
        yyerror((char *)"Argument 1 to scalar concatenation is not scalar");
#line 160
        list_free(e1);
#line 161
        list_free(e2);
#line 162
        tmp___1 = error_val();
        }
#line 162
        return (tmp___1);
      }
#line 164
      if (ce2->count != 1) {
        {
#line 165
        yyerror((char *)"Argument 2 to scalar concatenation is not scalar");
#line 166
        list_free(e1);
#line 167
        list_free(e2);
#line 168
        tmp___2 = error_val();
        }
#line 168
        return (tmp___2);
      }
      {
#line 170
      tmp___3 = list_new((size_t )1, ce1->prob * ce2->prob);
#line 170
      cret = tmp___3;
#line 171
      i = 10;
      }
      {
#line 172
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 172
        if (! (i < *(ce2->values + 0))) {
#line 172
          goto while_break___1;
        }
#line 173
        i *= 10;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 175
      *(cret->values + 0) = *(ce1->values + 0);
#line 176
      *(cret->values + 0) *= i;
#line 177
      *(cret->values + 0) += *(ce2->values + 0);
#line 178
      list_add(& ret, cret, this->ordering);
#line 179
      ce2 = ce2->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    ce1 = ce1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  list_free(e1);
#line 184
  list_free(e2);
  }
#line 185
  return (ret);
}
}
#line 1298 "tree.c"
struct scat_vtable__  const  scat_vt__  = 
#line 1298 "tree.c"
     {& binary_vt__, 34, "scat", (void (*)(expression *this__ , int depth ))(& scat_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& scat_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& scat_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1310 "tree.c"
void rep_printtree__(rep *this , int depth ) 
{ 


  {
  {
#line 77 "printtree.tc"
  indent(depth);
#line 78
  printf((char const   */* __restrict  */)"#\n");
#line 79
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 80
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 81
  return;
}
}
#line 1320 "tree.c"
struct roll_value *rep_roll__(rep *this ) 
{ 
  struct roll_value *rep___0 ;
  struct roll_value *tmp ;
  struct roll_value *rv ;
  struct roll_value *tmp___0 ;
  int i ;
  struct roll_value *roll ;
  struct roll_value *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 133 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 133
  rep___0 = tmp;
  }
#line 134
  if (rep___0->count != 1) {
    {
#line 135
    yyerror((char *)"Argument 1 to rep (#) isn\'t scalar");
#line 136
    rep___0->count = 1;
#line 137
    *(rep___0->values + 0) = 0;
    }
#line 138
    return (rep___0);
  }
  {
#line 140
  tmp___0 = new_roll_single(*(rep___0->values + 0));
#line 140
  rv = tmp___0;
#line 141
  rv->count = 0;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < *(rep___0->values + 0))) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp___1 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 144
    roll = tmp___1;
#line 145
    tmp___2 = realloc((void *)rv->values, sizeof(int ) * (unsigned long )(rv->count + roll->count));
#line 145
    rv->values = (int *)tmp___2;
#line 147
    memcpy((void */* __restrict  */)(rv->values + rv->count), (void const   */* __restrict  */)roll->values,
           (unsigned long )roll->count * sizeof(int ));
#line 149
    rv->count += roll->count;
#line 150
    free_roll(roll);
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  free_roll(rep___0);
  }
#line 154
  return (rv);
}
}
#line 1348 "tree.c"
struct val_list *rep_eval__(rep *this ) 
{ 
  struct val_list *cnt ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *ccnt ;
  int i ;
  struct val_list *tmp___1 ;
  int icnt ;
  int expcnt ;
  struct val_list *cexp ;
  int *pos ;
  unsigned long __lengthofpos ;
  void *tmp___2 ;
  struct val_list **index___0 ;
  unsigned long __lengthofindex___0 ;
  void *tmp___3 ;
  int len ;
  double prob ;
  struct val_list *cret ;
  struct val_list *tmp___4 ;
  int cp ;
  struct val_list *tmp___5 ;
  struct val_list *cret___0 ;
  struct val_list *tmp___6 ;

  {
  {
#line 191 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 191
  cnt = tmp;
#line 192
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 192
  exp___0 = tmp___0;
#line 193
  ret = (struct val_list *)((void *)0);
#line 194
  ccnt = cnt;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! ccnt) {
#line 197
      goto while_break;
    }
#line 198
    if (ccnt->count != 1) {
      {
#line 199
      yyerror((char *)"Argument to repetition operator is not scalar");
#line 200
      list_free(cnt);
#line 201
      list_free(exp___0);
#line 202
      tmp___1 = error_val();
      }
#line 202
      return (tmp___1);
    }
#line 205
    icnt = *(ccnt->values + 0);
#line 206
    if (icnt > 0) {
#line 207
      expcnt = 0;
#line 208
      cexp = exp___0;
      {
#line 209
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 209
        if (! cexp) {
#line 209
          goto while_break___0;
        }
#line 210
        expcnt ++;
#line 211
        cexp = cexp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 213
      __lengthofpos = (unsigned long )icnt;
#line 213
      tmp___2 = __builtin_alloca(sizeof(*pos) * __lengthofpos);
#line 213
      pos = (int *)tmp___2;
#line 214
      memset((void *)pos, 0, (unsigned long )icnt * sizeof(int ));
#line 215
      __lengthofindex___0 = (unsigned long )expcnt;
#line 215
      tmp___3 = __builtin_alloca(sizeof(*index___0) * __lengthofindex___0);
#line 215
      index___0 = (struct val_list **)tmp___3;
#line 216
      i = 0;
#line 217
      cexp = exp___0;
      }
      {
#line 218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 218
        if (! cexp) {
#line 218
          goto while_break___1;
        }
#line 219
        *(index___0 + i) = cexp;
#line 220
        i ++;
#line 221
        cexp = cexp->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 224
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 226
        len = 0;
#line 227
        prob = ccnt->prob;
#line 228
        i = 0;
        {
#line 228
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 228
          if (! (i < icnt)) {
#line 228
            goto while_break___3;
          }
#line 229
          len += (*(index___0 + *(pos + i)))->count;
#line 230
          prob *= (*(index___0 + *(pos + i)))->prob;
#line 228
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 232
        tmp___4 = list_new((size_t )len, prob);
#line 232
        cret = tmp___4;
#line 233
        cp = 0;
#line 234
        i = 0;
        }
        {
#line 234
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 234
          if (! (i < icnt)) {
#line 234
            goto while_break___4;
          }
          {
#line 235
          memcpy((void */* __restrict  */)(cret->values + cp), (void const   */* __restrict  */)(*(index___0 + *(pos + i)))->values,
                 (unsigned long )(*(index___0 + *(pos + i)))->count * sizeof(int ));
#line 237
          cp += (*(index___0 + *(pos + i)))->count;
#line 234
          i ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 239
        list_add(& ret, cret, this->ordering);
#line 242
        (*(pos + 0)) ++;
#line 243
        i = 0;
        }
        {
#line 244
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 244
          if (*(pos + i) == expcnt) {
#line 244
            if (! (i < icnt - 1)) {
#line 244
              goto while_break___5;
            }
          } else {
#line 244
            goto while_break___5;
          }
#line 245
          *(pos + i) = 0;
#line 246
          i ++;
#line 247
          (*(pos + i)) ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 224
        if (! (*(pos + (icnt - 1)) < expcnt)) {
#line 224
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 251
      tmp___5 = list_new((size_t )0, ccnt->prob);
#line 251
      list_add(& ret, tmp___5, this->ordering);
      }
    }
#line 254
    ccnt = ccnt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 258
    tmp___6 = list_new((size_t )0, 1.0);
#line 258
    cret___0 = tmp___6;
#line 259
    list_add(& ret, cret___0, this->ordering);
    }
  }
  {
#line 261
  list_free(cnt);
#line 262
  list_free(exp___0);
  }
#line 263
  return (ret);
}
}
#line 1427 "tree.c"
struct rep_vtable__  const  rep_vt__  = 
#line 1427 "tree.c"
     {& binary_vt__, 35, "rep", (void (*)(expression *this__ , int depth ))(& rep_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& rep_roll__), (void (*)(expression *this__ ,
                                                                           struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& rep_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1439 "tree.c"
void range_printtree__(range *this , int depth ) 
{ 


  {
  {
#line 85 "printtree.tc"
  indent(depth);
#line 86
  printf((char const   */* __restrict  */)"..\n");
#line 87
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 88
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 89
  return;
}
}
#line 1449 "tree.c"
struct roll_value *range_roll__(range *this ) 
{ 
  int i ;
  int c ;
  struct roll_value *rv1 ;
  struct roll_value *tmp ;
  struct roll_value *rv2 ;
  struct roll_value *tmp___0 ;
  struct roll_value *rv ;
  int tmp___1 ;

  {
  {
#line 94 "roll.tc"
  c = 0;
#line 95
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 95
  rv1 = tmp;
#line 96
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 96
  rv2 = tmp___0;
  }
#line 97
  if (rv1->count != 1) {
    {
#line 98
    yyerror((char *)"Argument 1 to range (..) isn\'t scalar");
#line 99
    free_roll(rv2);
#line 100
    rv1->count = 1;
#line 101
    *(rv1->values + 0) = 0;
    }
#line 102
    return (rv1);
  }
#line 104
  if (rv2->count != 1) {
    {
#line 105
    yyerror((char *)"Argument 2 to range (..) isn\'t scalar");
#line 106
    free_roll(rv2);
#line 107
    rv1->count = 1;
#line 108
    *(rv1->values + 0) = 0;
    }
#line 109
    return (rv1);
  }
#line 112
  if (*(rv1->values + 0) <= *(rv2->values + 0)) {
    {
#line 113
    tmp___1 = abs(*(rv1->values + 0) - *(rv2->values + 0));
#line 113
    rv = new_roll_multi(tmp___1 + 1);
#line 115
    i = *(rv1->values + 0);
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! (i != *(rv2->values + 0))) {
#line 115
        goto while_break;
      }
#line 117
      *(rv->values + c) = i;
#line 118
      c ++;
#line 115
      if (*(rv1->values + 0) < *(rv2->values + 0)) {
#line 115
        i ++;
      } else {
#line 115
        i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 120
    *(rv->values + c) = *(rv2->values + 0);
  } else {
    {
#line 123
    rv = new_roll_single(0);
#line 124
    rv->count = 0;
    }
  }
  {
#line 126
  free_roll(rv1);
#line 127
  free_roll(rv2);
  }
#line 128
  return (rv);
}
}
#line 1491 "tree.c"
struct val_list *range_eval__(range *this ) 
{ 
  struct val_list *from ;
  struct val_list *tmp ;
  struct val_list *to ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cfrom ;
  struct val_list *cto ;
  struct val_list *tmp___1 ;
  struct val_list *tmp___2 ;
  int ifrom ;
  int ito ;
  int count___0 ;
  struct val_list *cret ;
  struct val_list *tmp___3 ;
  int i ;
  int c ;

  {
  {
#line 268 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 268
  from = tmp;
#line 269
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 269
  to = tmp___0;
#line 270
  ret = (struct val_list *)((void *)0);
#line 271
  cfrom = from;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! cfrom) {
#line 274
      goto while_break;
    }
#line 275
    cto = to;
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      if (! cto) {
#line 276
        goto while_break___0;
      }
#line 278
      if (cfrom->count != 1) {
        {
#line 279
        yyerror((char *)"Argument \"from\" to range operator is not scalar");
#line 280
        list_free(from);
#line 281
        list_free(to);
#line 282
        tmp___1 = error_val();
        }
#line 282
        return (tmp___1);
      }
#line 284
      if (cto->count != 1) {
        {
#line 285
        yyerror((char *)"Argument \"to\" to range operator is not scalar");
#line 286
        list_free(from);
#line 287
        list_free(to);
#line 288
        tmp___2 = error_val();
        }
#line 288
        return (tmp___2);
      }
#line 290
      ifrom = *(cfrom->values + 0);
#line 291
      ito = *(cto->values + 0);
#line 292
      count___0 = (ito - ifrom) + 1;
#line 293
      if (count___0 < 0) {
#line 294
        count___0 = 0;
      }
      {
#line 296
      tmp___3 = list_new((size_t )count___0, cfrom->prob * cto->prob);
#line 296
      cret = tmp___3;
#line 298
      i = ifrom;
#line 298
      c = 0;
      }
      {
#line 298
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 298
        if (! (i <= ito)) {
#line 298
          goto while_break___1;
        }
#line 299
        *(cret->values + c) = i;
#line 298
        i ++;
#line 298
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 301
      list_add(& ret, cret, this->ordering);
#line 303
      cto = cto->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 305
    cfrom = cfrom->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  list_free(from);
#line 308
  list_free(to);
  }
#line 309
  return (ret);
}
}
#line 1539 "tree.c"
struct range_vtable__  const  range_vt__  = 
#line 1539 "tree.c"
     {& binary_vt__, 36, "range", (void (*)(expression *this__ , int depth ))(& range_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& range_roll__), (void (*)(expression *this__ ,
                                                                             struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& range_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1551 "tree.c"
void lcat_printtree__(lcat *this , int depth ) 
{ 


  {
  {
#line 93 "printtree.tc"
  indent(depth);
#line 94
  printf((char const   */* __restrict  */)",\n");
#line 95
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 96
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 97
  return;
}
}
#line 1561 "tree.c"
struct roll_value *lcat_roll__(lcat *this ) 
{ 
  struct roll_value *rv1 ;
  struct roll_value *tmp ;
  struct roll_value *rv2 ;
  struct roll_value *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 159 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 159
  rv1 = tmp;
#line 160
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 160
  rv2 = tmp___0;
#line 161
  tmp___1 = realloc((void *)rv1->values, sizeof(int ) * (unsigned long )(rv1->count + rv2->count));
#line 161
  rv1->values = (int *)tmp___1;
#line 163
  memcpy((void */* __restrict  */)(rv1->values + rv1->count), (void const   */* __restrict  */)rv2->values,
         (unsigned long )rv2->count * sizeof(int ));
#line 165
  rv1->count += rv2->count;
#line 166
  free_roll(rv2);
  }
#line 167
  return (rv1);
}
}
#line 1576 "tree.c"
struct val_list *lcat_eval__(lcat *this ) 
{ 
  struct val_list *e1 ;
  struct val_list *tmp ;
  struct val_list *e2 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *ce1 ;
  struct val_list *ce2 ;
  struct val_list *cret ;
  struct val_list *tmp___1 ;

  {
  {
#line 314 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 314
  e1 = tmp;
#line 315
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 315
  e2 = tmp___0;
#line 316
  ret = (struct val_list *)((void *)0);
#line 317
  ce1 = e1;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ce1) {
#line 320
      goto while_break;
    }
#line 321
    ce2 = e2;
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if (! ce2) {
#line 322
        goto while_break___0;
      }
      {
#line 323
      tmp___1 = list_new((size_t )(ce1->count + ce2->count), ce1->prob * ce2->prob);
#line 323
      cret = tmp___1;
#line 325
      memcpy((void */* __restrict  */)cret->values, (void const   */* __restrict  */)ce1->values,
             (unsigned long )ce1->count * sizeof(int ));
#line 326
      memcpy((void */* __restrict  */)(cret->values + ce1->count), (void const   */* __restrict  */)ce2->values,
             (unsigned long )ce2->count * sizeof(int ));
#line 328
      list_add(& ret, cret, this->ordering);
#line 329
      ce2 = ce2->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 331
    ce1 = ce1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  list_free(e1);
#line 334
  list_free(e2);
  }
#line 335
  return (ret);
}
}
#line 1604 "tree.c"
struct lcat_vtable__  const  lcat_vt__  = 
#line 1604 "tree.c"
     {& binary_vt__, 37, "lcat", (void (*)(expression *this__ , int depth ))(& lcat_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& lcat_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& lcat_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1616 "tree.c"
struct filter_vtable__  const  filter_vt__  = 
#line 1616
     {& binary_vt__, 39, "filter", (void (*)(expression *this__ , int depth ))0, (struct roll_value *(*)(expression *this__ ))0,
    (void (*)(expression *this__ , struct symtab *st ))(& binary_set_symtab__), (void (*)(expression *this__ ,
                                                                                          ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))0, (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1628 "tree.c"
void let_printtree__(let *this , int depth ) 
{ 


  {
  {
#line 254 "printtree.tc"
  indent(depth);
#line 255
  printf((char const   */* __restrict  */)"let %s = \n", this->varname);
#line 256
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 257
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 258
  return;
}
}
#line 1638 "tree.c"
struct roll_value *let_roll__(let *this ) 
{ 
  struct symtab *nst ;
  void *tmp ;
  struct roll_value *ret ;
  struct roll_value *tmp___0 ;

  {
  {
#line 501 "roll.tc"
  tmp = malloc(sizeof(struct symtab ));
#line 501
  nst = (struct symtab *)tmp;
#line 502
  nst->name = this->varname;
#line 503
  nst->__annonCompField1.rvalue = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 504
  nst->next = this->symtab;
#line 505
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               nst);
#line 506
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 506
  ret = tmp___0;
#line 508
  free_roll(nst->__annonCompField1.rvalue);
#line 509
  free((void *)nst);
  }
#line 510
  return (ret);
}
}
#line 1655 "tree.c"
void let_set_ordering__(let *this , ordering_type ordering ) 
{ 
  struct symtab *nst ;
  void *tmp ;

  {
  {
#line 95 "ordering.tc"
  this->ordering = ordering;
#line 96
  tmp = malloc(sizeof(struct symtab ));
#line 96
  nst = (struct symtab *)tmp;
#line 97
  nst->name = this->varname;
#line 98
  nst->__annonCompField1.ordering = (ordering_type )0;
#line 99
  nst->next = this->symtab;
#line 100
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               nst);
#line 101
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_ordering_v__))(this->expr2,
                                                                                 ordering);
#line 102
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->set_ordering_v__))(this->expr1,
                                                                                 nst->__annonCompField1.ordering);
#line 103
  free((void *)nst);
  }
#line 104
  return;
}
}
#line 1670 "tree.c"
struct val_list *let_eval__(let *this ) 
{ 
  struct val_list *cnt ;
  struct val_list *tmp ;
  struct val_list *ret ;
  struct val_list *ccnt ;
  struct symtab *nst ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct val_list *cur ;
  struct val_list *tmp___3 ;
  struct val_list *ccur ;
  struct val_list *temp ;

  {
  {
#line 673 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 673
  cnt = tmp;
#line 674
  ret = (struct val_list *)((void *)0);
#line 675
  ccnt = cnt;
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! ccnt) {
#line 677
      goto while_break;
    }
    {
#line 678
    tmp___0 = malloc(sizeof(struct symtab ));
#line 678
    nst = (struct symtab *)tmp___0;
#line 679
    nst->name = this->varname;
#line 680
    tmp___1 = malloc(sizeof(struct roll_value ));
#line 680
    nst->__annonCompField1.rvalue = (struct roll_value *)tmp___1;
#line 681
    (nst->__annonCompField1.rvalue)->count = ccnt->count;
#line 682
    tmp___2 = malloc(sizeof(int ) * (unsigned long )ccnt->count);
#line 682
    (nst->__annonCompField1.rvalue)->values = (int *)tmp___2;
#line 683
    memcpy((void */* __restrict  */)(nst->__annonCompField1.rvalue)->values, (void const   */* __restrict  */)ccnt->values,
           sizeof(int ) * (unsigned long )ccnt->count);
#line 684
    nst->next = this->symtab;
#line 685
    (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                                 nst);
#line 687
    tmp___3 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 687
    cur = tmp___3;
#line 688
    ccur = cur;
    }
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 689
      if (! ccur) {
#line 689
        goto while_break___0;
      }
      {
#line 690
      temp = ccur;
#line 691
      ccur = ccur->next;
#line 692
      temp->next = (struct val_list *)((void *)0);
#line 693
      temp->prob *= ccnt->prob;
#line 694
      list_add(& ret, temp, this->ordering);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 697
    free_roll(nst->__annonCompField1.rvalue);
#line 698
    free((void *)nst);
#line 699
    ccnt = ccnt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 701
  list_free(cnt);
  }
#line 702
  return (ret);
}
}
#line 1706 "tree.c"
struct let_vtable__  const  let_vt__  = 
#line 1706 "tree.c"
     {& binary_vt__, 45, "let", (void (*)(expression *this__ , int depth ))(& let_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& let_roll__), (void (*)(expression *this__ ,
                                                                           struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& let_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& let_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1718 "tree.c"
void foreach_printtree__(foreach *this , int depth ) 
{ 


  {
  {
#line 262 "printtree.tc"
  indent(depth);
#line 263
  printf((char const   */* __restrict  */)"foreach %s \n", this->varname);
#line 264
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 265
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 266
  return;
}
}
#line 1728 "tree.c"
struct roll_value *foreach_roll__(foreach *this ) 
{ 
  struct roll_value *list ;
  struct roll_value *tmp ;
  struct roll_value *ret ;
  void *tmp___0 ;
  struct symtab *nst ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int i ;
  struct roll_value *cur ;
  struct roll_value *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 544 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 544
  list = tmp;
#line 545
  tmp___0 = malloc(sizeof(struct roll_value ));
#line 545
  ret = (struct roll_value *)tmp___0;
#line 547
  ret->count = 0;
#line 548
  ret->values = (int *)((void *)0);
#line 549
  tmp___1 = malloc(sizeof(struct symtab ));
#line 549
  nst = (struct symtab *)tmp___1;
#line 550
  nst->name = this->varname;
#line 551
  tmp___2 = malloc(sizeof(struct roll_value ));
#line 551
  nst->__annonCompField1.rvalue = (struct roll_value *)tmp___2;
#line 552
  (nst->__annonCompField1.rvalue)->count = 1;
#line 553
  tmp___3 = malloc(sizeof(int ));
#line 553
  (nst->__annonCompField1.rvalue)->values = (int *)tmp___3;
#line 554
  nst->next = this->symtab;
#line 555
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               nst);
#line 557
  i = 0;
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (i < list->count)) {
#line 557
      goto while_break;
    }
    {
#line 558
    *((nst->__annonCompField1.rvalue)->values + 0) = *(list->values + i);
#line 559
    tmp___4 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 559
    cur = tmp___4;
#line 561
    tmp___5 = realloc((void *)ret->values, (unsigned long )(ret->count + cur->count) * sizeof(int ));
#line 561
    ret->values = (int *)tmp___5;
#line 563
    memcpy((void */* __restrict  */)(ret->values + ret->count), (void const   */* __restrict  */)cur->values,
           (unsigned long )cur->count * sizeof(int ));
#line 565
    ret->count += cur->count;
#line 566
    free_roll(cur);
#line 557
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 568
  free_roll(list);
#line 569
  free_roll(nst->__annonCompField1.rvalue);
#line 570
  free((void *)nst);
  }
#line 571
  return (ret);
}
}
#line 1762 "tree.c"
struct val_list *foreach_eval__(foreach *this ) 
{ 
  struct val_list *cnt ;
  struct val_list *tmp ;
  struct val_list *ccnt ;
  int i ;
  struct val_list *tret ;
  struct symtab *nst ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct val_list *ret ;
  struct val_list *tmp___3 ;
  struct val_list *cur ;
  struct val_list *tmp___4 ;
  struct val_list *cret ;
  struct val_list *nret ;
  struct val_list *ccur ;
  struct val_list *item ;
  struct val_list *tmp___5 ;
  struct val_list *cret___0 ;
  struct val_list *temp ;

  {
  {
#line 707 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 707
  cnt = tmp;
#line 708
  ccnt = cnt;
#line 711
  tret = (struct val_list *)((void *)0);
#line 713
  tmp___0 = malloc(sizeof(struct symtab ));
#line 713
  nst = (struct symtab *)tmp___0;
#line 714
  nst->name = this->varname;
#line 715
  tmp___1 = malloc(sizeof(struct roll_value ));
#line 715
  nst->__annonCompField1.rvalue = (struct roll_value *)tmp___1;
#line 716
  (nst->__annonCompField1.rvalue)->count = 1;
#line 717
  tmp___2 = malloc(sizeof(int ));
#line 717
  (nst->__annonCompField1.rvalue)->values = (int *)tmp___2;
#line 718
  nst->next = this->symtab;
#line 719
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               nst);
  }
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    if (! ccnt) {
#line 722
      goto while_break;
    }
    {
#line 723
    tmp___3 = list_new((size_t )0, 1.0);
#line 723
    ret = tmp___3;
#line 724
    i = 0;
    }
    {
#line 724
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 724
      if (! (i < ccnt->count)) {
#line 724
        goto while_break___0;
      }
      {
#line 725
      *((nst->__annonCompField1.rvalue)->values + 0) = *(ccnt->values + i);
#line 726
      tmp___4 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 726
      cur = tmp___4;
#line 729
      cret = ret;
#line 730
      nret = (struct val_list *)((void *)0);
      }
      {
#line 732
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 732
        if (! cret) {
#line 732
          goto while_break___1;
        }
#line 733
        ccur = cur;
        {
#line 734
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 734
          if (! ccur) {
#line 734
            goto while_break___2;
          }
          {
#line 735
          tmp___5 = list_new((size_t )(ccur->count + cret->count), ccur->prob * cret->prob);
#line 735
          item = tmp___5;
#line 738
          memcpy((void */* __restrict  */)item->values, (void const   */* __restrict  */)cret->values,
                 sizeof(int ) * (unsigned long )cret->count);
#line 740
          memcpy((void */* __restrict  */)(item->values + cret->count), (void const   */* __restrict  */)ccur->values,
                 sizeof(int ) * (unsigned long )ccur->count);
#line 743
          list_add(& nret, item, this->ordering);
#line 745
          ccur = ccur->next;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 747
        cret = cret->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 749
      list_free(cur);
#line 750
      list_free(ret);
#line 751
      ret = nret;
#line 752
      nret = (struct val_list *)((void *)0);
#line 724
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 754
    cret___0 = ret;
    {
#line 755
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 755
      if (! cret___0) {
#line 755
        goto while_break___3;
      }
      {
#line 756
      cret___0->prob *= ccnt->prob;
#line 757
      temp = cret___0;
#line 758
      cret___0 = cret___0->next;
#line 759
      temp->next = (struct val_list *)((void *)0);
#line 760
      list_add(& tret, temp, this->ordering);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 762
    ccnt = ccnt->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  free_roll(nst->__annonCompField1.rvalue);
#line 765
  free((void *)nst);
#line 766
  list_free(cnt);
  }
#line 767
  return (tret);
}
}
#line 1829 "tree.c"
struct foreach_vtable__  const  foreach_vt__  = 
#line 1829 "tree.c"
     {& binary_vt__, 46, "foreach", (void (*)(expression *this__ , int depth ))(& foreach_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& foreach_roll__), (void (*)(expression *this__ ,
                                                                               struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& foreach_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1841 "tree.c"
void whiledo_printtree__(whiledo *this , int depth ) 
{ 


  {
  {
#line 270 "printtree.tc"
  indent(depth);
#line 271
  printf((char const   */* __restrict  */)"while %s \n", this->varname);
#line 272
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 273
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 274
  return;
}
}
#line 1851 "tree.c"
struct roll_value *whiledo_roll__(whiledo *this ) 
{ 
  struct roll_value *cur ;
  struct roll_value *ret ;
  void *tmp ;
  struct symtab *nst ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 577 "roll.tc"
  tmp = malloc(sizeof(struct roll_value ));
#line 577
  ret = (struct roll_value *)tmp;
#line 579
  ret->count = 0;
#line 580
  ret->values = (int *)((void *)0);
#line 581
  tmp___0 = malloc(sizeof(struct symtab ));
#line 581
  nst = (struct symtab *)tmp___0;
#line 582
  nst->name = this->varname;
#line 583
  nst->next = this->symtab;
#line 585
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_symtab_v__))(this->expr2,
                                                                               nst);
#line 586
  cur = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 587
  nst->__annonCompField1.rvalue = cur;
#line 589
  tmp___1 = realloc((void *)ret->values, sizeof(int ) * (unsigned long )(cur->count + ret->count));
#line 589
  ret->values = (int *)tmp___1;
#line 591
  memcpy((void */* __restrict  */)(ret->values + ret->count), (void const   */* __restrict  */)cur->values,
         sizeof(int ) * (unsigned long )cur->count);
#line 592
  ret->count += cur->count;
  }
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! (cur->count > 0)) {
#line 593
      goto while_break;
    }
    {
#line 595
    cur = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 596
    free_roll(nst->__annonCompField1.rvalue);
#line 597
    nst->__annonCompField1.rvalue = cur;
#line 599
    tmp___2 = realloc((void *)ret->values, sizeof(int ) * (unsigned long )(cur->count + ret->count));
#line 599
    ret->values = (int *)tmp___2;
#line 601
    memcpy((void */* __restrict  */)(ret->values + ret->count), (void const   */* __restrict  */)cur->values,
           sizeof(int ) * (unsigned long )cur->count);
#line 603
    ret->count += cur->count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605
  free_roll(cur);
#line 606
  free((void *)nst);
  }
#line 607
  return (ret);
}
}
#line 1889 "tree.c"
struct val_list *whiledo_eval__(whiledo *this ) 
{ 
  struct val_list *expe ;
  struct val_list *tmp ;
  struct val_list *ret ;

  {
  {
#line 823 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 823
  expe = tmp;
#line 824
  ret = (struct val_list *)((void *)0);
#line 825
  rec_whiledo(expe, this->varname, this->symtab, this->expr2, (int *)((void *)0),
              0, & ret, this->ordering);
#line 827
  list_free(expe);
  }
#line 828
  return (ret);
}
}
#line 1901 "tree.c"
struct whiledo_vtable__  const  whiledo_vt__  = 
#line 1901 "tree.c"
     {& binary_vt__, 47, "whiledo", (void (*)(expression *this__ , int depth ))(& whiledo_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& whiledo_roll__), (void (*)(expression *this__ ,
                                                                               struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& whiledo_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1913 "tree.c"
struct plus_vtable__  const  plus_vt__  = 
#line 1913
     {& mathop_vt__, 28, "plus", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1925 "tree.c"
struct minus_vtable__  const  minus_vt__  = 
#line 1925
     {& mathop_vt__, 29, "minus", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1937 "tree.c"
struct multi_vtable__  const  multi_vt__  = 
#line 1937
     {& mathop_vt__, 30, "multi", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1949 "tree.c"
struct divi_vtable__  const  divi_vt__  = 
#line 1949
     {& mathop_vt__, 31, "divi", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1961 "tree.c"
struct mod_vtable__  const  mod_vt__  = 
#line 1961
     {& mathop_vt__, 32, "mod", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1973 "tree.c"
struct expo_vtable__  const  expo_vt__  = 
#line 1973
     {& mathop_vt__, 33, "expo", (void (*)(expression *this__ , int depth ))(& mathop_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& mathop_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& mathop_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 1985 "tree.c"
void first_printtree__(first *this , int depth ) 
{ 


  {
  {
#line 150 "printtree.tc"
  indent(depth);
  }
#line 151
  if ((unsigned int )this->type == 0U) {
    {
#line 152
    printf((char const   */* __restrict  */)"drop ");
    }
  } else {
    {
#line 155
    printf((char const   */* __restrict  */)"keep ");
    }
  }
  {
#line 157
  printf((char const   */* __restrict  */)"first\n");
#line 158
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 159
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 160
  return;
}
}
#line 2001 "tree.c"
struct roll_value *first_roll__(first *this ) 
{ 
  struct roll_value *num ;
  struct roll_value *tmp ;
  struct roll_value *exp___0 ;
  struct roll_value *tmp___0 ;
  int i ;

  {
  {
#line 267 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 267
  num = tmp;
#line 268
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 268
  exp___0 = tmp___0;
  }
#line 269
  if (num->count != 1) {
    {
#line 270
    yyerror((char *)"Argument 1 to first isn\'t scalar");
#line 271
    free_roll(num);
#line 272
    exp___0->count = 1;
#line 273
    *(exp___0->values + 0) = 0;
    }
#line 274
    return (exp___0);
  }
#line 276
  if ((unsigned int )this->type == 0U) {
#line 277
    i = exp___0->count - *(num->values + 0);
#line 278
    if (i <= 0) {
#line 279
      i = 0;
#line 280
      exp___0->count = 0;
    } else {
      {
#line 283
      memcpy((void */* __restrict  */)(exp___0->values + 0), (void const   */* __restrict  */)(exp___0->values + (exp___0->count - i)),
             (unsigned long )i * sizeof(int ));
#line 285
      exp___0->count = i;
      }
    }
  } else
#line 289
  if (exp___0->count > *(num->values + 0)) {
#line 289
    exp___0->count = *(num->values + 0);
  } else {
#line 289
    exp___0->count = exp___0->count;
  }
  {
#line 291
  free_roll(num);
  }
#line 292
  return (exp___0);
}
}
#line 2033 "tree.c"
void first_set_ordering__(first *this , ordering_type ordering ) 
{ 


  {
  {
#line 56 "ordering.tc"
  this->ordering = ordering;
#line 57
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->set_ordering_v__))(this->expr1,
                                                                                 (ordering_type )0);
#line 58
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_ordering_v__))(this->expr2,
                                                                                 (ordering_type )1);
  }
#line 59
  return;
}
}
#line 2042 "tree.c"
struct val_list *first_eval__(first *this ) 
{ 
  struct val_list *num ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *cexp ;
  struct val_list *tmp___1 ;
  struct val_list *cret ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 340 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 340
  num = tmp;
#line 341
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 341
  exp___0 = tmp___0;
#line 342
  ret = (struct val_list *)((void *)0);
#line 343
  cnum = num;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! cnum) {
#line 346
      goto while_break;
    }
#line 348
    if (cnum->count != 1) {
      {
#line 349
      yyerror((char *)"Argument 1 to \"first\" operator is not scalar");
#line 350
      list_free(exp___0);
#line 351
      list_free(num);
#line 352
      tmp___1 = error_val();
      }
#line 352
      return (tmp___1);
    }
#line 354
    cexp = exp___0;
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! cexp) {
#line 355
        goto while_break___0;
      }
      {
#line 356
      tmp___2 = malloc(sizeof(struct val_list ));
#line 356
      cret = (struct val_list *)tmp___2;
#line 358
      cret->next = (struct val_list *)((void *)0);
      }
#line 359
      if ((unsigned int )this->type == 0U) {
#line 360
        cret->count = cexp->count - *(cnum->values + 0);
#line 361
        if (cret->count <= 0) {
#line 362
          cret->count = 0;
        }
        {
#line 364
        tmp___3 = malloc((unsigned long )cret->count * sizeof(int ));
#line 364
        cret->values = (int *)tmp___3;
#line 365
        memcpy((void */* __restrict  */)cret->values, (void const   */* __restrict  */)(cexp->values + (cexp->count - cret->count)),
               (unsigned long )cret->count * sizeof(int ));
        }
      } else {
#line 369
        if (cexp->count > *(cnum->values + 0)) {
#line 369
          cret->count = *(cnum->values + 0);
        } else {
#line 369
          cret->count = cexp->count;
        }
        {
#line 370
        tmp___4 = malloc((unsigned long )cret->count * sizeof(int ));
#line 370
        cret->values = (int *)tmp___4;
#line 371
        memcpy((void */* __restrict  */)cret->values, (void const   */* __restrict  */)cexp->values,
               (unsigned long )cret->count * sizeof(int ));
        }
      }
      {
#line 373
      cret->prob = cexp->prob * cnum->prob;
#line 374
      list_add(& ret, cret, this->ordering);
#line 375
      cexp = cexp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 377
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  list_free(exp___0);
#line 380
  list_free(num);
  }
#line 381
  return (ret);
}
}
#line 2090 "tree.c"
struct first_vtable__  const  first_vt__  = 
#line 2090 "tree.c"
     {& filter_vt__, 40, "first", (void (*)(expression *this__ , int depth ))(& first_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& first_roll__), (void (*)(expression *this__ ,
                                                                             struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& first_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& first_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 2102 "tree.c"
void last_printtree__(last *this , int depth ) 
{ 


  {
  {
#line 164 "printtree.tc"
  indent(depth);
  }
#line 165
  if ((unsigned int )this->type == 0U) {
    {
#line 166
    printf((char const   */* __restrict  */)"drop ");
    }
  } else {
    {
#line 169
    printf((char const   */* __restrict  */)"keep ");
    }
  }
  {
#line 171
  printf((char const   */* __restrict  */)"last\n");
#line 172
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 173
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 174
  return;
}
}
#line 2118 "tree.c"
struct roll_value *last_roll__(last *this ) 
{ 
  struct roll_value *num ;
  struct roll_value *tmp ;
  struct roll_value *exp___0 ;
  struct roll_value *tmp___0 ;

  {
  {
#line 296 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 296
  num = tmp;
#line 297
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 297
  exp___0 = tmp___0;
  }
#line 298
  if (num->count != 1) {
    {
#line 299
    yyerror((char *)"Argument 1 to last isn\'t scalar");
#line 300
    free_roll(num);
#line 301
    exp___0->count = 1;
#line 302
    *(exp___0->values + 0) = 0;
    }
#line 303
    return (exp___0);
  }
#line 305
  if ((unsigned int )this->type == 0U) {
#line 306
    exp___0->count -= *(num->values + 0);
#line 307
    if (exp___0->count < 0) {
#line 308
      exp___0->count = 0;
    }
  } else
#line 312
  if (*(num->values + 0) < exp___0->count) {
    {
#line 313
    memcpy((void */* __restrict  */)(exp___0->values + 0), (void const   */* __restrict  */)(exp___0->values + (exp___0->count - *(num->values + 0))),
           (unsigned long )*(num->values + 0) * sizeof(int ));
#line 315
    exp___0->count = *(num->values + 0);
    }
  }
  {
#line 318
  free_roll(num);
  }
#line 319
  return (exp___0);
}
}
#line 2148 "tree.c"
void last_set_ordering__(last *this , ordering_type ordering ) 
{ 


  {
  {
#line 63 "ordering.tc"
  this->ordering = ordering;
#line 64
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->set_ordering_v__))(this->expr1,
                                                                                 (ordering_type )0);
#line 65
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->set_ordering_v__))(this->expr2,
                                                                                 (ordering_type )1);
  }
#line 66
  return;
}
}
#line 2157 "tree.c"
struct val_list *last_eval__(last *this ) 
{ 
  struct val_list *num ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *cexp ;
  struct val_list *tmp___1 ;
  struct val_list *cret ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 386 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 386
  num = tmp;
#line 387
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 387
  exp___0 = tmp___0;
#line 388
  ret = (struct val_list *)((void *)0);
#line 389
  cnum = num;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! cnum) {
#line 392
      goto while_break;
    }
#line 394
    if (cnum->count != 1) {
      {
#line 395
      yyerror((char *)"Argument 1 to \"last\" operator is not scalar");
#line 396
      list_free(exp___0);
#line 397
      list_free(num);
#line 398
      tmp___1 = error_val();
      }
#line 398
      return (tmp___1);
    }
#line 400
    cexp = exp___0;
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! cexp) {
#line 401
        goto while_break___0;
      }
      {
#line 402
      tmp___2 = malloc(sizeof(struct val_list ));
#line 402
      cret = (struct val_list *)tmp___2;
#line 404
      cret->next = (struct val_list *)((void *)0);
      }
#line 405
      if ((unsigned int )this->type == 0U) {
#line 406
        if (cexp->count - *(cnum->values + 0) > 0) {
#line 406
          cret->count = cexp->count - *(cnum->values + 0);
        } else {
#line 406
          cret->count = 0;
        }
        {
#line 407
        tmp___3 = malloc((unsigned long )cret->count * sizeof(int ));
#line 407
        cret->values = (int *)tmp___3;
#line 408
        memcpy((void */* __restrict  */)cret->values, (void const   */* __restrict  */)cexp->values,
               (unsigned long )cret->count * sizeof(int ));
        }
      } else {
#line 411
        if (cexp->count > *(cnum->values + 0)) {
#line 411
          cret->count = *(cnum->values + 0);
        } else {
#line 411
          cret->count = cexp->count;
        }
        {
#line 412
        tmp___4 = malloc((unsigned long )cret->count * sizeof(int ));
#line 412
        cret->values = (int *)tmp___4;
#line 413
        memcpy((void */* __restrict  */)cret->values, (void const   */* __restrict  */)(cexp->values + (cexp->count - cret->count)),
               (unsigned long )cret->count * sizeof(int ));
        }
      }
      {
#line 423
      cret->prob = cexp->prob * cnum->prob;
#line 424
      list_add(& ret, cret, this->ordering);
#line 425
      cexp = cexp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 429
  list_free(exp___0);
#line 430
  list_free(num);
  }
#line 431
  return (ret);
}
}
#line 2209 "tree.c"
struct last_vtable__  const  last_vt__  = 
#line 2209 "tree.c"
     {& filter_vt__, 41, "last", (void (*)(expression *this__ , int depth ))(& last_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& last_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& last_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& last_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 2221 "tree.c"
void high_printtree__(high *this , int depth ) 
{ 


  {
  {
#line 178 "printtree.tc"
  indent(depth);
  }
#line 179
  if ((unsigned int )this->type == 0U) {
    {
#line 180
    printf((char const   */* __restrict  */)"drop ");
    }
  } else {
    {
#line 183
    printf((char const   */* __restrict  */)"keep ");
    }
  }
  {
#line 185
  printf((char const   */* __restrict  */)"high\n");
#line 186
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 187
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 188
  return;
}
}
#line 2237 "tree.c"
struct roll_value *high_roll__(high *this ) 
{ 
  struct roll_value *num ;
  struct roll_value *tmp ;
  struct roll_value *exp___0 ;
  struct roll_value *tmp___0 ;
  int *slist ;
  void *tmp___1 ;
  int *mask ;
  void *tmp___2 ;
  int p ;
  int i ;
  int c ;
  int j ;
  int found ;
  int tmp___3 ;
  int j___0 ;
  int found___0 ;
  int tmp___4 ;

  {
  {
#line 382 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 382
  num = tmp;
#line 383
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 383
  exp___0 = tmp___0;
  }
#line 384
  if (num->count != 1) {
    {
#line 385
    yyerror((char *)"Argument 1 to last isn\'t scalar");
#line 386
    free_roll(num);
#line 387
    exp___0->count = 1;
#line 388
    *(exp___0->values + 0) = 0;
    }
#line 389
    return (exp___0);
  }
  {
#line 391
  tmp___1 = malloc(sizeof(int ) * (unsigned long )exp___0->count);
#line 391
  slist = (int *)tmp___1;
#line 392
  tmp___2 = malloc(sizeof(int ) * (unsigned long )exp___0->count);
#line 392
  mask = (int *)tmp___2;
#line 393
  memcpy((void */* __restrict  */)slist, (void const   */* __restrict  */)exp___0->values,
         sizeof(int ) * (unsigned long )exp___0->count);
#line 394
  memset((void *)mask, 0, sizeof(int ) * (unsigned long )exp___0->count);
#line 395
  quicksort(slist, 0, exp___0->count - 1);
#line 396
  p = 0;
#line 396
  c = 0;
  }
#line 398
  if ((unsigned int )this->type == 1U) {
#line 399
    i = 0;
    {
#line 399
    while (1) {
      while_continue: /* CIL Label */ ;
#line 399
      if (i < exp___0->count) {
#line 399
        if (! (c < *(num->values + 0))) {
#line 399
          goto while_break;
        }
      } else {
#line 399
        goto while_break;
      }
#line 400
      found = 0;
#line 401
      j = exp___0->count - 1;
      {
#line 401
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 401
        if (! (j >= exp___0->count - *(num->values + 0))) {
#line 401
          goto while_break___0;
        }
#line 402
        if (*(exp___0->values + i) == *(slist + j)) {
#line 402
          if (! *(mask + j)) {
#line 403
            found = 1;
#line 404
            *(mask + j) = 1;
#line 405
            goto while_break___0;
          }
        }
#line 401
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 408
      if (found) {
#line 409
        tmp___3 = p;
#line 409
        p ++;
#line 409
        *(exp___0->values + tmp___3) = *(exp___0->values + i);
#line 410
        c ++;
      }
#line 399
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 415
    i = 0;
    {
#line 415
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 415
      if (i < exp___0->count) {
#line 415
        if (! (c < exp___0->count - *(num->values + 0))) {
#line 415
          goto while_break___1;
        }
      } else {
#line 415
        goto while_break___1;
      }
#line 417
      found___0 = 0;
#line 418
      j___0 = 0;
      {
#line 418
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 418
        if (! (j___0 < exp___0->count - *(num->values + 0))) {
#line 418
          goto while_break___2;
        }
#line 419
        if (*(exp___0->values + i) == *(slist + j___0)) {
#line 419
          if (! *(mask + j___0)) {
#line 420
            found___0 = 1;
#line 421
            *(mask + j___0) = 1;
#line 422
            goto while_break___2;
          }
        }
#line 418
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 425
      if (found___0) {
#line 426
        tmp___4 = p;
#line 426
        p ++;
#line 426
        *(exp___0->values + tmp___4) = *(exp___0->values + i);
#line 427
        c ++;
      }
#line 415
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 431
  exp___0->count = c;
#line 432
  free_roll(num);
#line 433
  free((void *)slist);
#line 434
  free((void *)mask);
  }
#line 435
  return (exp___0);
}
}
#line 2297 "tree.c"
struct val_list *high_eval__(high *this ) 
{ 
  struct val_list *num ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *cexp ;
  struct val_list *tmp___1 ;
  struct val_list *cret ;
  void *tmp___2 ;
  int *slist ;
  void *tmp___3 ;
  int *mask ;
  void *tmp___4 ;
  int p ;
  int i ;
  void *tmp___5 ;
  int j ;
  int found ;
  int tmp___6 ;
  void *tmp___7 ;
  int j___0 ;
  int found___0 ;
  int tmp___8 ;

  {
  {
#line 436 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 436
  num = tmp;
#line 437
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 437
  exp___0 = tmp___0;
#line 438
  ret = (struct val_list *)((void *)0);
#line 439
  cnum = num;
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! cnum) {
#line 442
      goto while_break;
    }
#line 444
    if (cnum->count != 1) {
      {
#line 445
      yyerror((char *)"Argument 1 to \"high\" operator is not scalar");
#line 446
      list_free(exp___0);
#line 447
      list_free(num);
#line 448
      tmp___1 = error_val();
      }
#line 448
      return (tmp___1);
    }
#line 450
    cexp = exp___0;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! cexp) {
#line 451
        goto while_break___0;
      }
      {
#line 452
      tmp___2 = malloc(sizeof(struct val_list ));
#line 452
      cret = (struct val_list *)tmp___2;
#line 454
      cret->next = (struct val_list *)((void *)0);
#line 459
      tmp___3 = malloc(sizeof(int ) * (unsigned long )cexp->count);
#line 459
      slist = (int *)tmp___3;
#line 460
      tmp___4 = malloc(sizeof(int ) * (unsigned long )cexp->count);
#line 460
      mask = (int *)tmp___4;
#line 461
      memcpy((void */* __restrict  */)slist, (void const   */* __restrict  */)cexp->values,
             sizeof(int ) * (unsigned long )cexp->count);
#line 462
      memset((void *)mask, 0, sizeof(int ) * (unsigned long )cexp->count);
#line 463
      quicksort(slist, 0, cexp->count - 1);
#line 464
      reverse(slist, 0, cexp->count - 1);
#line 466
      p = 0;
      }
#line 467
      if ((unsigned int )this->type == 1U) {
#line 469
        if (cexp->count > *(cnum->values + 0)) {
#line 469
          cret->count = *(cnum->values + 0);
        } else {
#line 469
          cret->count = cexp->count;
        }
        {
#line 470
        tmp___5 = malloc(sizeof(int ) * (unsigned long )cret->count);
#line 470
        cret->values = (int *)tmp___5;
#line 472
        i = 0;
        }
        {
#line 472
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 472
          if (i < cexp->count) {
#line 472
            if (! (p < *(cnum->values + 0))) {
#line 472
              goto while_break___1;
            }
          } else {
#line 472
            goto while_break___1;
          }
#line 473
          found = 0;
#line 474
          j = 0;
          {
#line 474
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 474
            if (! (j < *(cnum->values + 0))) {
#line 474
              goto while_break___2;
            }
#line 475
            if (*(cexp->values + i) == *(slist + j)) {
#line 475
              if (! *(mask + j)) {
#line 476
                found = 1;
#line 477
                *(mask + j) = 1;
#line 478
                goto while_break___2;
              }
            }
#line 474
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 481
          if (found) {
#line 482
            tmp___6 = p;
#line 482
            p ++;
#line 482
            *(cret->values + tmp___6) = *(cexp->values + i);
          }
#line 472
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 487
        if (cexp->count - *(cnum->values + 0) > 0) {
#line 487
          cret->count = cexp->count - *(cnum->values + 0);
        } else {
#line 487
          cret->count = 0;
        }
        {
#line 488
        tmp___7 = malloc(sizeof(int ) * (unsigned long )cret->count);
#line 488
        cret->values = (int *)tmp___7;
#line 489
        i = 0;
        }
        {
#line 489
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 489
          if (i < cexp->count) {
#line 489
            if (! (p < cexp->count - *(cnum->values + 0))) {
#line 489
              goto while_break___3;
            }
          } else {
#line 489
            goto while_break___3;
          }
#line 492
          found___0 = 0;
#line 493
          j___0 = cexp->count - 1;
          {
#line 493
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 493
            if (! (j___0 >= *(cnum->values + 0))) {
#line 493
              goto while_break___4;
            }
#line 494
            if (*(cexp->values + i) == *(slist + j___0)) {
#line 494
              if (! *(mask + j___0)) {
#line 495
                found___0 = 1;
#line 498
                *(mask + j___0) = 1;
#line 499
                goto while_break___4;
              }
            }
#line 493
            j___0 --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 502
          if (found___0) {
#line 503
            tmp___8 = p;
#line 503
            p ++;
#line 503
            *(cret->values + tmp___8) = *(cexp->values + i);
          }
#line 489
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 507
      free((void *)slist);
#line 508
      free((void *)mask);
#line 509
      cret->prob = cexp->prob * cnum->prob;
#line 510
      list_add(& ret, cret, this->ordering);
#line 511
      cexp = cexp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 513
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 515
  list_free(exp___0);
#line 516
  list_free(num);
  }
#line 517
  return (ret);
}
}
#line 2385 "tree.c"
struct high_vtable__  const  high_vt__  = 
#line 2385 "tree.c"
     {& filter_vt__, 42, "high", (void (*)(expression *this__ , int depth ))(& high_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& high_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& high_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 2397 "tree.c"
void low_printtree__(low *this , int depth ) 
{ 


  {
  {
#line 192 "printtree.tc"
  indent(depth);
  }
#line 193
  if ((unsigned int )this->type == 0U) {
    {
#line 194
    printf((char const   */* __restrict  */)"drop ");
    }
  } else {
    {
#line 197
    printf((char const   */* __restrict  */)"keep ");
    }
  }
  {
#line 199
  printf((char const   */* __restrict  */)"low\n");
#line 200
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 201
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 202
  return;
}
}
#line 2413 "tree.c"
struct roll_value *low_roll__(low *this ) 
{ 
  struct roll_value *num ;
  struct roll_value *tmp ;
  struct roll_value *exp___0 ;
  struct roll_value *tmp___0 ;
  int *slist ;
  void *tmp___1 ;
  int *mask ;
  void *tmp___2 ;
  int p ;
  int i ;
  int c ;
  int j ;
  int found ;
  int tmp___3 ;
  int j___0 ;
  int found___0 ;
  int tmp___4 ;

  {
  {
#line 323 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 323
  num = tmp;
#line 324
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 324
  exp___0 = tmp___0;
  }
#line 325
  if (num->count != 1) {
    {
#line 326
    yyerror((char *)"Argument 1 to last isn\'t scalar");
#line 327
    free_roll(num);
#line 328
    exp___0->count = 1;
#line 329
    *(exp___0->values + 0) = 0;
    }
#line 330
    return (exp___0);
  }
  {
#line 332
  tmp___1 = malloc(sizeof(int ) * (unsigned long )exp___0->count);
#line 332
  slist = (int *)tmp___1;
#line 333
  tmp___2 = malloc(sizeof(int ) * (unsigned long )exp___0->count);
#line 333
  mask = (int *)tmp___2;
#line 334
  memcpy((void */* __restrict  */)slist, (void const   */* __restrict  */)exp___0->values,
         sizeof(int ) * (unsigned long )exp___0->count);
#line 335
  memset((void *)mask, 0, sizeof(int ) * (unsigned long )exp___0->count);
#line 336
  quicksort(slist, 0, exp___0->count - 1);
#line 337
  p = 0;
#line 337
  c = 0;
  }
#line 339
  if ((unsigned int )this->type == 1U) {
#line 340
    i = 0;
    {
#line 340
    while (1) {
      while_continue: /* CIL Label */ ;
#line 340
      if (i < exp___0->count) {
#line 340
        if (! (c < *(num->values + 0))) {
#line 340
          goto while_break;
        }
      } else {
#line 340
        goto while_break;
      }
#line 341
      found = 0;
#line 342
      j = 0;
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 342
        if (! (j < *(num->values + 0))) {
#line 342
          goto while_break___0;
        }
#line 343
        if (*(exp___0->values + i) == *(slist + j)) {
#line 343
          if (! *(mask + j)) {
#line 344
            found = 1;
#line 345
            *(mask + j) = 1;
#line 346
            goto while_break___0;
          }
        }
#line 342
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 349
      if (found) {
#line 350
        tmp___3 = p;
#line 350
        p ++;
#line 350
        *(exp___0->values + tmp___3) = *(exp___0->values + i);
#line 351
        c ++;
      }
#line 340
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 356
    i = 0;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (i < exp___0->count) {
#line 356
        if (! (c < exp___0->count - *(num->values + 0))) {
#line 356
          goto while_break___1;
        }
      } else {
#line 356
        goto while_break___1;
      }
#line 358
      found___0 = 0;
#line 359
      j___0 = exp___0->count - 1;
      {
#line 359
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 359
        if (! (j___0 >= *(num->values + 0))) {
#line 359
          goto while_break___2;
        }
#line 360
        if (*(exp___0->values + i) == *(slist + j___0)) {
#line 360
          if (! *(mask + j___0)) {
#line 361
            found___0 = 1;
#line 362
            *(mask + j___0) = 1;
#line 363
            goto while_break___2;
          }
        }
#line 359
        j___0 --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 368
      if (found___0) {
#line 369
        tmp___4 = p;
#line 369
        p ++;
#line 369
        *(exp___0->values + tmp___4) = *(exp___0->values + i);
#line 370
        c ++;
      }
#line 356
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 374
  exp___0->count = c;
#line 375
  free_roll(num);
#line 376
  free((void *)slist);
#line 377
  free((void *)mask);
  }
#line 378
  return (exp___0);
}
}
#line 2475 "tree.c"
struct val_list *low_eval__(low *this ) 
{ 
  struct val_list *num ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *cexp ;
  struct val_list *tmp___1 ;
  struct val_list *cret ;
  void *tmp___2 ;
  int *slist ;
  void *tmp___3 ;
  int *mask ;
  void *tmp___4 ;
  int p ;
  int i ;
  void *tmp___5 ;
  int j ;
  int found ;
  int tmp___6 ;
  void *tmp___7 ;
  int j___0 ;
  int found___0 ;
  int tmp___8 ;

  {
  {
#line 522 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 522
  num = tmp;
#line 523
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 523
  exp___0 = tmp___0;
#line 524
  ret = (struct val_list *)((void *)0);
#line 525
  cnum = num;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! cnum) {
#line 528
      goto while_break;
    }
#line 530
    if (cnum->count != 1) {
      {
#line 531
      yyerror((char *)"Argument 1 to \"low\" operator is not scalar");
#line 532
      list_free(exp___0);
#line 533
      list_free(num);
#line 534
      tmp___1 = error_val();
      }
#line 534
      return (tmp___1);
    }
#line 536
    cexp = exp___0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! cexp) {
#line 537
        goto while_break___0;
      }
      {
#line 538
      tmp___2 = malloc(sizeof(struct val_list ));
#line 538
      cret = (struct val_list *)tmp___2;
#line 540
      cret->next = (struct val_list *)((void *)0);
#line 545
      tmp___3 = malloc(sizeof(int ) * (unsigned long )cexp->count);
#line 545
      slist = (int *)tmp___3;
#line 546
      tmp___4 = malloc(sizeof(int ) * (unsigned long )cexp->count);
#line 546
      mask = (int *)tmp___4;
#line 547
      memcpy((void */* __restrict  */)slist, (void const   */* __restrict  */)cexp->values,
             sizeof(int ) * (unsigned long )cexp->count);
#line 548
      memset((void *)mask, 0, sizeof(int ) * (unsigned long )cexp->count);
#line 549
      quicksort(slist, 0, cexp->count - 1);
#line 551
      p = 0;
      }
#line 552
      if ((unsigned int )this->type == 1U) {
#line 554
        if (cexp->count > *(cnum->values + 0)) {
#line 554
          cret->count = *(cnum->values + 0);
        } else {
#line 554
          cret->count = cexp->count;
        }
        {
#line 555
        tmp___5 = malloc(sizeof(int ) * (unsigned long )cret->count);
#line 555
        cret->values = (int *)tmp___5;
#line 557
        i = 0;
        }
        {
#line 557
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 557
          if (i < cexp->count) {
#line 557
            if (! (p < *(cnum->values + 0))) {
#line 557
              goto while_break___1;
            }
          } else {
#line 557
            goto while_break___1;
          }
#line 558
          found = 0;
#line 559
          j = 0;
          {
#line 559
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 559
            if (! (j < *(cnum->values + 0))) {
#line 559
              goto while_break___2;
            }
#line 560
            if (*(cexp->values + i) == *(slist + j)) {
#line 560
              if (! *(mask + j)) {
#line 561
                found = 1;
#line 562
                *(mask + j) = 1;
#line 563
                goto while_break___2;
              }
            }
#line 559
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 566
          if (found) {
#line 567
            tmp___6 = p;
#line 567
            p ++;
#line 567
            *(cret->values + tmp___6) = *(cexp->values + i);
          }
#line 557
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 572
        if (cexp->count - *(cnum->values + 0) > 0) {
#line 572
          cret->count = cexp->count - *(cnum->values + 0);
        } else {
#line 572
          cret->count = 0;
        }
        {
#line 573
        tmp___7 = malloc(sizeof(int ) * (unsigned long )cret->count);
#line 573
        cret->values = (int *)tmp___7;
#line 574
        i = 0;
        }
        {
#line 574
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 574
          if (i < cexp->count) {
#line 574
            if (! (p < cexp->count - *(cnum->values + 0))) {
#line 574
              goto while_break___3;
            }
          } else {
#line 574
            goto while_break___3;
          }
#line 577
          found___0 = 0;
#line 578
          j___0 = cexp->count - 1;
          {
#line 578
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 578
            if (! (j___0 >= *(cnum->values + 0))) {
#line 578
              goto while_break___4;
            }
#line 579
            if (*(cexp->values + i) == *(slist + j___0)) {
#line 579
              if (! *(mask + j___0)) {
#line 580
                found___0 = 1;
#line 583
                *(mask + j___0) = 1;
#line 584
                goto while_break___4;
              }
            }
#line 578
            j___0 --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 587
          if (found___0) {
#line 588
            tmp___8 = p;
#line 588
            p ++;
#line 588
            *(cret->values + tmp___8) = *(cexp->values + i);
          }
#line 574
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 592
      free((void *)slist);
#line 593
      free((void *)mask);
#line 594
      cret->prob = cexp->prob * cnum->prob;
#line 595
      list_add(& ret, cret, this->ordering);
#line 596
      cexp = cexp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 598
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 600
  list_free(exp___0);
#line 601
  list_free(num);
  }
#line 602
  return (ret);
}
}
#line 2562 "tree.c"
struct low_vtable__  const  low_vt__  = 
#line 2562 "tree.c"
     {& filter_vt__, 43, "low", (void (*)(expression *this__ , int depth ))(& low_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& low_roll__), (void (*)(expression *this__ ,
                                                                           struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& low_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 2574 "tree.c"
void comparison_printtree__(comparison *this , int depth ) 
{ 


  {
  {
#line 206 "printtree.tc"
  indent(depth);
  }
#line 207
  if ((unsigned int )this->type == 0U) {
    {
#line 208
    printf((char const   */* __restrict  */)"drop ");
    }
  } else {
    {
#line 211
    printf((char const   */* __restrict  */)"keep ");
    }
  }
  {
#line 213
  printf((char const   */* __restrict  */)"comparison ");
  }
  {
#line 215
  if ((unsigned int )this->comp == 0U) {
#line 215
    goto case_0;
  }
#line 218
  if ((unsigned int )this->comp == 1U) {
#line 218
    goto case_1;
  }
#line 221
  if ((unsigned int )this->comp == 3U) {
#line 221
    goto case_3;
  }
#line 224
  if ((unsigned int )this->comp == 2U) {
#line 224
    goto case_2;
  }
#line 227
  if ((unsigned int )this->comp == 5U) {
#line 227
    goto case_5;
  }
#line 230
  if ((unsigned int )this->comp == 4U) {
#line 230
    goto case_4;
  }
#line 233
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 216
  printf((char const   */* __restrict  */)"eq\n");
  }
#line 217
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 219
  printf((char const   */* __restrict  */)"ne\n");
  }
#line 220
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 222
  printf((char const   */* __restrict  */)"gt\n");
  }
#line 223
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 225
  printf((char const   */* __restrict  */)"lt\n");
  }
#line 226
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 228
  printf((char const   */* __restrict  */)"ge\n");
  }
#line 229
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 231
  printf((char const   */* __restrict  */)"le\n");
  }
#line 232
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 234
  yyerror((char *)"Unexpected comparison (really bad)");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->printtree_v__))(this->expr1,
                                                                              depth + 1);
#line 237
  (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->printtree_v__))(this->expr2,
                                                                              depth + 1);
  }
#line 238
  return;
}
}
#line 2612 "tree.c"
struct roll_value *comparison_roll__(comparison *this ) 
{ 
  struct roll_value *num ;
  struct roll_value *tmp ;
  struct roll_value *exp___0 ;
  struct roll_value *tmp___0 ;
  int o ;
  int n ;
  int c ;
  int tmp___1 ;

  {
  {
#line 439 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->roll_v__))(this->expr1);
#line 439
  num = tmp;
#line 440
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->roll_v__))(this->expr2);
#line 440
  exp___0 = tmp___0;
  }
#line 441
  if (num->count != 1) {
    {
#line 442
    yyerror((char *)"Argument 1 to comparison isn\'t scalar");
#line 443
    free_roll(num);
#line 444
    exp___0->count = 1;
#line 445
    *(exp___0->values + 0) = 0;
    }
#line 446
    return (exp___0);
  }
#line 448
  n = 0;
#line 449
  o = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (o < exp___0->count)) {
#line 449
      goto while_break;
    }
#line 450
    c = 0;
    {
#line 452
    if ((unsigned int )this->comp == 0U) {
#line 452
      goto case_0;
    }
#line 455
    if ((unsigned int )this->comp == 1U) {
#line 455
      goto case_1;
    }
#line 458
    if ((unsigned int )this->comp == 3U) {
#line 458
      goto case_3;
    }
#line 461
    if ((unsigned int )this->comp == 2U) {
#line 461
      goto case_2;
    }
#line 464
    if ((unsigned int )this->comp == 5U) {
#line 464
      goto case_5;
    }
#line 467
    if ((unsigned int )this->comp == 4U) {
#line 467
      goto case_4;
    }
#line 470
    goto switch_default;
    case_0: /* CIL Label */ 
#line 453
    c = *(exp___0->values + o) == *(num->values + 0);
#line 454
    goto switch_break;
    case_1: /* CIL Label */ 
#line 456
    c = *(exp___0->values + o) != *(num->values + 0);
#line 457
    goto switch_break;
    case_3: /* CIL Label */ 
#line 459
    c = *(exp___0->values + o) > *(num->values + 0);
#line 460
    goto switch_break;
    case_2: /* CIL Label */ 
#line 462
    c = *(exp___0->values + o) < *(num->values + 0);
#line 463
    goto switch_break;
    case_5: /* CIL Label */ 
#line 465
    c = *(exp___0->values + o) >= *(num->values + 0);
#line 466
    goto switch_break;
    case_4: /* CIL Label */ 
#line 468
    c = *(exp___0->values + o) <= *(num->values + 0);
#line 469
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 471
    yyerror((char *)"Unexpected comparison (really bad)");
    }
    switch_break: /* CIL Label */ ;
    }
#line 473
    if ((unsigned int )this->type == 0U) {
#line 474
      c = ! c;
    }
#line 476
    if (c) {
#line 477
      tmp___1 = n;
#line 477
      n ++;
#line 477
      *(exp___0->values + tmp___1) = *(exp___0->values + o);
    }
#line 449
    o ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  exp___0->count = n;
#line 481
  free_roll(num);
  }
#line 482
  return (exp___0);
}
}
#line 2662 "tree.c"
struct val_list *comparison_eval__(comparison *this ) 
{ 
  struct val_list *num ;
  struct val_list *tmp ;
  struct val_list *exp___0 ;
  struct val_list *tmp___0 ;
  struct val_list *ret ;
  struct val_list *cnum ;
  struct val_list *cexp ;
  struct val_list *tmp___1 ;
  struct val_list *cret ;
  struct val_list *tmp___2 ;
  int o ;
  int c ;
  struct val_list *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 607 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr1)->vtable__)->eval_v__))(this->expr1);
#line 607
  num = tmp;
#line 608
  tmp___0 = (*(((struct expression_vtable__ *)(this->expr2)->vtable__)->eval_v__))(this->expr2);
#line 608
  exp___0 = tmp___0;
#line 609
  ret = (struct val_list *)((void *)0);
#line 610
  cnum = num;
  }
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! cnum) {
#line 613
      goto while_break;
    }
#line 615
    if (cnum->count != 1) {
      {
#line 616
      yyerror((char *)"Argument 1 to comparison operator is not scalar");
#line 617
      list_free(exp___0);
#line 618
      list_free(num);
#line 619
      tmp___1 = error_val();
      }
#line 619
      return (tmp___1);
    }
#line 621
    cexp = exp___0;
    {
#line 622
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 622
      if (! cexp) {
#line 622
        goto while_break___0;
      }
      {
#line 623
      tmp___2 = list_new((size_t )cexp->count, cexp->prob * cnum->prob);
#line 623
      cret = tmp___2;
#line 625
      cret->count = 0;
#line 627
      o = 0;
      }
      {
#line 627
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 627
        if (! (o < cexp->count)) {
#line 627
          goto while_break___1;
        }
#line 628
        c = 0;
        {
#line 630
        if ((unsigned int )this->comp == 0U) {
#line 630
          goto case_0;
        }
#line 633
        if ((unsigned int )this->comp == 1U) {
#line 633
          goto case_1;
        }
#line 636
        if ((unsigned int )this->comp == 3U) {
#line 636
          goto case_3;
        }
#line 639
        if ((unsigned int )this->comp == 2U) {
#line 639
          goto case_2;
        }
#line 642
        if ((unsigned int )this->comp == 5U) {
#line 642
          goto case_5;
        }
#line 645
        if ((unsigned int )this->comp == 4U) {
#line 645
          goto case_4;
        }
#line 648
        goto switch_default;
        case_0: /* CIL Label */ 
#line 631
        c = *(cexp->values + o) == *(cnum->values + 0);
#line 632
        goto switch_break;
        case_1: /* CIL Label */ 
#line 634
        c = *(cexp->values + o) != *(cnum->values + 0);
#line 635
        goto switch_break;
        case_3: /* CIL Label */ 
#line 637
        c = *(cexp->values + o) > *(cnum->values + 0);
#line 638
        goto switch_break;
        case_2: /* CIL Label */ 
#line 640
        c = *(cexp->values + o) < *(cnum->values + 0);
#line 641
        goto switch_break;
        case_5: /* CIL Label */ 
#line 643
        c = *(cexp->values + o) >= *(cnum->values + 0);
#line 644
        goto switch_break;
        case_4: /* CIL Label */ 
#line 646
        c = *(cexp->values + o) <= *(cnum->values + 0);
#line 647
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 649
        yyerror((char *)"Unexpected comparison (really bad)");
#line 650
        list_free(exp___0);
#line 651
        list_free(num);
#line 652
        tmp___3 = error_val();
        }
#line 652
        return (tmp___3);
        switch_break: /* CIL Label */ ;
        }
#line 654
        if ((unsigned int )this->type == 0U) {
#line 655
          c = ! c;
        }
#line 657
        if (c) {
#line 658
          tmp___4 = cret->count;
#line 658
          (cret->count) ++;
#line 658
          *(cret->values + tmp___4) = *(cexp->values + o);
        }
#line 627
        o ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      list_add(& ret, cret, this->ordering);
#line 662
      cexp = cexp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 664
    cnum = cnum->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  list_free(exp___0);
#line 667
  list_free(num);
  }
#line 668
  return (ret);
}
}
#line 2730 "tree.c"
struct comparison_vtable__  const  comparison_vt__  = 
#line 2730 "tree.c"
     {& filter_vt__, 44, "comparison", (void (*)(expression *this__ , int depth ))(& comparison_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& comparison_roll__), (void (*)(expression *this__ ,
                                                                                  struct symtab *st ))(& binary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& binary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& comparison_eval__), (expression *(*)(expression *this__ ))(& binary_optimize__)};
#line 2742 "tree.c"
void negate_printtree__(negate *this , int depth ) 
{ 


  {
  {
#line 32 "printtree.tc"
  indent(depth);
#line 33
  printf((char const   */* __restrict  */)"-\n");
#line 34
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 35
  return;
}
}
#line 2751 "tree.c"
struct roll_value *negate_roll__(negate *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 172 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 172
  rv = tmp;
  }
#line 173
  if (rv->count != 1) {
    {
#line 174
    yyerror((char *)"Argument 1 to negate (-) isn\'t scalar");
#line 175
    rv->count = 1;
#line 176
    *(rv->values + 0) = 0;
    }
#line 177
    return (rv);
  }
#line 179
  *(rv->values + 0) *= -1;
#line 180
  return (rv);
}
}
#line 2766 "tree.c"
struct val_list *negate_eval__(negate *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *cside ;
  struct val_list *tmp___0 ;

  {
  {
#line 833 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 833
  sides = tmp;
#line 834
  cside = sides;
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! cside) {
#line 836
      goto while_break;
    }
#line 838
    if (cside->count != 1) {
      {
#line 839
      yyerror((char *)"Argument to negate operator is not scalar");
#line 840
      tmp___0 = error_val();
      }
#line 840
      return (tmp___0);
    }
#line 842
    *(cside->values + 0) *= -1;
#line 843
    cside = cside->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  return (sides);
}
}
#line 2785 "tree.c"
struct negate_vtable__  const  negate_vt__  = 
#line 2785 "tree.c"
     {& unary_vt__, 19, "negate", (void (*)(expression *this__ , int depth ))(& negate_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& negate_roll__), (void (*)(expression *this__ ,
                                                                              struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& unary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& negate_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 2797 "tree.c"
void dice_printtree__(dice *this , int depth ) 
{ 


  {
  {
#line 101 "printtree.tc"
  indent(depth);
#line 102
  printf((char const   */* __restrict  */)"d\n");
#line 103
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 104
  return;
}
}
#line 2806 "tree.c"
struct roll_value *dice_roll__(dice *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;
  int tmp___0 ;

  {
  {
#line 185 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 185
  rv = tmp;
  }
#line 186
  if (rv->count != 1) {
    {
#line 187
    yyerror((char *)"Argument 1 to dice (d) isn\'t scalar");
#line 188
    rv->count = 1;
#line 189
    *(rv->values + 0) = 0;
    }
#line 190
    return (rv);
  }
#line 192
  if (*(rv->values + 0) < 1) {
    {
#line 193
    yyerror((char *)"Argument 1 to dice (d) isn\'t >= 1");
#line 194
    rv->count = 1;
#line 195
    *(rv->values + 0) = 0;
    }
#line 196
    return (rv);
  }
  {
#line 198
  tmp___0 = rand();
#line 198
  *(rv->values + 0) = 1 + (int )((double )*(rv->values + 0) * ((double )tmp___0 / ((double )2147483647 + 1.0)));
  }
#line 199
  return (rv);
}
}
#line 2827 "tree.c"
struct val_list *dice_eval__(dice *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *ret ;
  struct val_list *cside ;
  struct val_list *tmp___0 ;
  struct val_list *tmp___1 ;
  int i ;
  struct val_list *cret ;
  struct val_list *tmp___2 ;

  {
  {
#line 850 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 850
  sides = tmp;
#line 851
  ret = (struct val_list *)((void *)0);
#line 853
  cside = sides;
  }
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! cside) {
#line 854
      goto while_break;
    }
#line 856
    if (cside->count != 1) {
      {
#line 857
      yyerror((char *)"Argument to \"dice\" operator is not scalar");
#line 858
      list_free(sides);
#line 859
      tmp___0 = error_val();
      }
#line 859
      return (tmp___0);
    }
#line 861
    if (*(cside->values + 0) <= 0) {
      {
#line 862
      yyerror((char *)"Argument to \"dice\" operator is not > 0");
#line 863
      list_free(sides);
#line 864
      tmp___1 = error_val();
      }
#line 864
      return (tmp___1);
    }
#line 867
    i = 1;
    {
#line 867
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 867
      if (! (i <= *(cside->values + 0))) {
#line 867
        goto while_break___0;
      }
      {
#line 869
      tmp___2 = list_new((size_t )1, cside->prob / (double )*(cside->values + 0));
#line 869
      cret = tmp___2;
#line 870
      *(cret->values + 0) = i;
#line 871
      list_add(& ret, cret, this->ordering);
#line 867
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 873
    cside = cside->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  list_free(sides);
  }
#line 876
  return (ret);
}
}
#line 2860 "tree.c"
struct dice_vtable__  const  dice_vt__  = 
#line 2860 "tree.c"
     {& unary_vt__, 20, "dice", (void (*)(expression *this__ , int depth ))(& dice_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& dice_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& unary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& dice_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 2872 "tree.c"
void sum_printtree__(sum *this , int depth ) 
{ 


  {
  {
#line 108 "printtree.tc"
  indent(depth);
#line 109
  printf((char const   */* __restrict  */)"sum\n");
#line 110
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 111
  return;
}
}
#line 2881 "tree.c"
struct roll_value *sum_roll__(sum *this ) 
{ 
  int s ;
  int i ;
  struct roll_value *rv ;
  struct roll_value *tmp ;
  void *tmp___0 ;

  {
  {
#line 204 "roll.tc"
  s = 0;
#line 206
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 206
  rv = tmp;
#line 207
  i = 0;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i < rv->count)) {
#line 207
      goto while_break;
    }
#line 208
    s += *(rv->values + i);
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  rv->count = 1;
#line 211
  tmp___0 = realloc((void *)rv->values, sizeof(int ) * (unsigned long )rv->count);
#line 211
  rv->values = (int *)tmp___0;
#line 212
  *(rv->values + 0) = s;
  }
#line 213
  return (rv);
}
}
#line 2897 "tree.c"
void sum_set_ordering__(sum *this , ordering_type ordering ) 
{ 


  {
  {
#line 26 "ordering.tc"
  this->ordering = ordering;
#line 27
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                (ordering_type )0);
  }
#line 28
  return;
}
}
#line 2905 "tree.c"
struct val_list *sum_eval__(sum *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *ret ;
  struct val_list *cside ;
  int sum___0 ;
  int i ;
  struct val_list *cret ;
  struct val_list *tmp___0 ;

  {
  {
#line 881 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 881
  sides = tmp;
#line 882
  ret = (struct val_list *)((void *)0);
#line 883
  cside = sides;
  }
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! cside) {
#line 885
      goto while_break;
    }
#line 886
    sum___0 = 0;
#line 888
    i = 0;
    {
#line 888
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 888
      if (! (i < cside->count)) {
#line 888
        goto while_break___0;
      }
#line 889
      sum___0 += *(cside->values + i);
#line 888
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 891
    tmp___0 = list_new((size_t )1, cside->prob);
#line 891
    cret = tmp___0;
#line 892
    *(cret->values + 0) = sum___0;
#line 893
    list_add(& ret, cret, this->ordering);
#line 894
    cside = cside->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 896
  list_free(sides);
  }
#line 897
  return (ret);
}
}
#line 2928 "tree.c"
expression *sum_optimize__(sum *this ) 
{ 
  rep *crep ;
  dice *cdice ;
  expression *replace ;
  struct val_list *tmp ;
  expression *tmp___0 ;
  expression *replace___0 ;
  expression *tmp___1 ;
  expression *tmp___2 ;
  struct val_list *tmp___3 ;
  struct val_list *tmp___4 ;
  expression *tmp___5 ;

  {
#line 252
  if ((this->expr)->kind__ == 35) {
#line 253 "optimize.tc"
    crep = (rep *)this->expr;
#line 254
    if ((crep->expr2)->kind__ == 20) {
#line 255
      cdice = (dice *)crep->expr2;
#line 256
      if ((cdice->expr)->kind__ == 18) {
        {
#line 258
        tmp = (*(((struct expression_vtable__ *)(crep->expr1)->vtable__)->eval_v__))(crep->expr1);
#line 258
        tmp___0 = sumrepdice_create(tmp, ((number *)cdice->expr)->num);
#line 258
        replace = tmp___0;
        }
#line 261
        return (replace);
      }
    } else {
      {
#line 266
      tmp___1 = sum_create(crep->expr2);
#line 266
      tmp___2 = sum_create(crep->expr2);
#line 266
      tmp___3 = (*(((struct expression_vtable__ *)tmp___1->vtable__)->eval_v__))(tmp___2);
#line 266
      tmp___4 = (*(((struct expression_vtable__ *)(crep->expr1)->vtable__)->eval_v__))(crep->expr1);
#line 266
      tmp___5 = sumrepany_create(tmp___4, tmp___3);
#line 266
      replace___0 = tmp___5;
      }
#line 269
      return (replace___0);
    }
  }
#line 272
  return ((expression *)this);
}
}
#line 2955 "tree.c"
struct sum_vtable__  const  sum_vt__  = 
#line 2955 "tree.c"
     {& unary_vt__, 21, "sum", (void (*)(expression *this__ , int depth ))(& sum_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& sum_roll__), (void (*)(expression *this__ ,
                                                                           struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& sum_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& sum_eval__), (expression *(*)(expression *this__ ))(& sum_optimize__)};
#line 2967 "tree.c"
void prod_printtree__(prod *this , int depth ) 
{ 


  {
  {
#line 115 "printtree.tc"
  indent(depth);
#line 116
  printf((char const   */* __restrict  */)"prod\n");
#line 117
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 118
  return;
}
}
#line 2976 "tree.c"
struct roll_value *prod_roll__(prod *this ) 
{ 
  int s ;
  int i ;
  struct roll_value *rv ;
  struct roll_value *tmp ;
  void *tmp___0 ;

  {
  {
#line 218 "roll.tc"
  s = 1;
#line 220
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 220
  rv = tmp;
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < rv->count)) {
#line 221
      goto while_break;
    }
#line 222
    s *= *(rv->values + i);
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  rv->count = 1;
#line 225
  tmp___0 = realloc((void *)rv->values, sizeof(int ) * (unsigned long )rv->count);
#line 225
  rv->values = (int *)tmp___0;
#line 226
  *(rv->values + 0) = s;
  }
#line 227
  return (rv);
}
}
#line 2992 "tree.c"
void prod_set_ordering__(prod *this , ordering_type ordering ) 
{ 


  {
  {
#line 32 "ordering.tc"
  this->ordering = ordering;
#line 33
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                (ordering_type )0);
  }
#line 34
  return;
}
}
#line 3000 "tree.c"
struct val_list *prod_eval__(prod *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *ret ;
  struct val_list *cside ;
  int prod___0 ;
  int i ;
  struct val_list *cret ;
  struct val_list *tmp___0 ;

  {
  {
#line 902 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 902
  sides = tmp;
#line 903
  ret = (struct val_list *)((void *)0);
#line 904
  cside = sides;
  }
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! cside) {
#line 906
      goto while_break;
    }
#line 907
    prod___0 = 1;
#line 909
    i = 0;
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! (i < cside->count)) {
#line 909
        goto while_break___0;
      }
#line 910
      prod___0 *= *(cside->values + i);
#line 909
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 912
    tmp___0 = list_new((size_t )1, cside->prob);
#line 912
    cret = tmp___0;
#line 913
    *(cret->values + 0) = prod___0;
#line 914
    list_add(& ret, cret, this->ordering);
#line 915
    cside = cside->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 917
  list_free(sides);
  }
#line 918
  return (ret);
}
}
#line 3023 "tree.c"
struct prod_vtable__  const  prod_vt__  = 
#line 3023 "tree.c"
     {& unary_vt__, 22, "prod", (void (*)(expression *this__ , int depth ))(& prod_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& prod_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& prod_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& prod_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 3035 "tree.c"
void count_printtree__(count *this , int depth ) 
{ 


  {
  {
#line 122 "printtree.tc"
  indent(depth);
#line 123
  printf((char const   */* __restrict  */)"count\n");
#line 124
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 125
  return;
}
}
#line 3044 "tree.c"
struct roll_value *count_roll__(count *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;
  void *tmp___0 ;

  {
  {
#line 259 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 259
  rv = tmp;
#line 260
  tmp___0 = realloc((void *)rv->values, sizeof(int ));
#line 260
  rv->values = (int *)tmp___0;
#line 261
  *(rv->values + 0) = rv->count;
#line 262
  rv->count = 1;
  }
#line 263
  return (rv);
}
}
#line 3055 "tree.c"
void count_set_ordering__(count *this , ordering_type ordering ) 
{ 


  {
  {
#line 38 "ordering.tc"
  this->ordering = ordering;
#line 39
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                (ordering_type )0);
  }
#line 40
  return;
}
}
#line 3063 "tree.c"
struct val_list *count_eval__(count *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *ret ;
  struct val_list *cside ;
  struct val_list *cret ;
  struct val_list *tmp___0 ;

  {
  {
#line 923 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 923
  sides = tmp;
#line 924
  ret = (struct val_list *)((void *)0);
#line 925
  cside = sides;
  }
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    if (! cside) {
#line 927
      goto while_break;
    }
    {
#line 928
    tmp___0 = list_new((size_t )1, cside->prob);
#line 928
    cret = tmp___0;
#line 929
    *(cret->values + 0) = cside->count;
#line 930
    list_add(& ret, cret, this->ordering);
#line 931
    cside = cside->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 933
  list_free(sides);
  }
#line 934
  return (ret);
}
}
#line 3081 "tree.c"
struct count_vtable__  const  count_vt__  = 
#line 3081 "tree.c"
     {& unary_vt__, 23, "count", (void (*)(expression *this__ , int depth ))(& count_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& count_roll__), (void (*)(expression *this__ ,
                                                                             struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& count_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& count_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 3093 "tree.c"
void perm_printtree__(perm *this , int depth ) 
{ 


  {
  {
#line 129 "printtree.tc"
  indent(depth);
#line 130
  printf((char const   */* __restrict  */)"perm\n");
#line 131
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 132
  return;
}
}
#line 3102 "tree.c"
struct roll_value *perm_roll__(perm *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 232 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 232
  rv = tmp;
#line 233
  permute(rv->values, rv->count);
  }
#line 234
  return (rv);
}
}
#line 3111 "tree.c"
void perm_set_ordering__(perm *this , ordering_type ordering ) 
{ 


  {
  {
#line 50 "ordering.tc"
  this->ordering = ordering;
#line 51
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                (ordering_type )0);
  }
#line 52
  return;
}
}
#line 3119 "tree.c"
struct val_list *perm_eval__(perm *this ) 
{ 
  struct val_list *exp___0 ;
  struct val_list *tmp ;
  struct val_list *cexp ;
  struct val_list *ret ;
  long tmp___0 ;

  {
  {
#line 951 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 951
  exp___0 = tmp;
#line 952
  cexp = exp___0;
#line 953
  ret = (struct val_list *)((void *)0);
  }
#line 955
  if ((unsigned int )this->ordering == 0U) {
#line 956
    return (exp___0);
  }
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! cexp) {
#line 959
      goto while_break;
    }
    {
#line 960
    tmp___0 = factorial(cexp->count);
#line 960
    all_permutations(cexp->values, cexp->count, & cb_perm, (void *)(& ret), (float )(cexp->prob / (double )tmp___0));
#line 962
    cexp = cexp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 964
  list_free(exp___0);
  }
#line 965
  return (ret);
}
}
#line 3140 "tree.c"
struct perm_vtable__  const  perm_vt__  = 
#line 3140 "tree.c"
     {& unary_vt__, 24, "perm", (void (*)(expression *this__ , int depth ))(& perm_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& perm_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& perm_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& perm_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 3152 "tree.c"
void sort_printtree__(sort *this , int depth ) 
{ 


  {
  {
#line 136 "printtree.tc"
  indent(depth);
#line 137
  printf((char const   */* __restrict  */)"sort\n");
#line 138
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 139
  return;
}
}
#line 3161 "tree.c"
struct roll_value *sort_roll__(sort *this ) 
{ 
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 239 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 239
  rv = tmp;
#line 241
  quicksort(rv->values, 0, rv->count - 1);
  }
#line 242
  return (rv);
}
}
#line 3171 "tree.c"
void sort_set_ordering__(sort *this , ordering_type ordering ) 
{ 


  {
  {
#line 44 "ordering.tc"
  this->ordering = ordering;
#line 45
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->set_ordering_v__))(this->expr,
                                                                                (ordering_type )0);
  }
#line 46
  return;
}
}
#line 3179 "tree.c"
struct val_list *sort_eval__(sort *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *cside ;

  {
  {
#line 970 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 970
  sides = tmp;
#line 971
  cside = sides;
  }
#line 973
  if ((unsigned int )this->ordering != 0U) {
    {
#line 974
    while (1) {
      while_continue: /* CIL Label */ ;
#line 974
      if (! cside) {
#line 974
        goto while_break;
      }
      {
#line 975
      quicksort(cside->values, 0, cside->count - 1);
#line 976
      cside = cside->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 979
  return (sides);
}
}
#line 3195 "tree.c"
struct sort_vtable__  const  sort_vt__  = 
#line 3195 "tree.c"
     {& unary_vt__, 25, "sort", (void (*)(expression *this__ , int depth ))(& sort_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& sort_roll__), (void (*)(expression *this__ ,
                                                                            struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& sort_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& sort_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 3207 "tree.c"
void rev_printtree__(rev *this , int depth ) 
{ 


  {
  {
#line 143 "printtree.tc"
  indent(depth);
#line 144
  printf((char const   */* __restrict  */)"rev\n");
#line 145
  (*(((struct expression_vtable__ *)(this->expr)->vtable__)->printtree_v__))(this->expr,
                                                                             depth + 1);
  }
#line 146
  return;
}
}
#line 3216 "tree.c"
struct roll_value *rev_roll__(rev *this ) 
{ 
  int i ;
  struct roll_value *rv ;
  struct roll_value *tmp ;

  {
  {
#line 248 "roll.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->roll_v__))(this->expr);
#line 248
  rv = tmp;
#line 249
  i = 0;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i < rv->count / 2)) {
#line 249
      goto while_break;
    }
#line 250
    *(rv->values + i) ^= *(rv->values + ((rv->count - 1) - i));
#line 251
    *(rv->values + ((rv->count - 1) - i)) ^= *(rv->values + i);
#line 252
    *(rv->values + i) ^= *(rv->values + ((rv->count - 1) - i));
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (rv);
}
}
#line 3230 "tree.c"
struct val_list *rev_eval__(rev *this ) 
{ 
  struct val_list *sides ;
  struct val_list *tmp ;
  struct val_list *cside ;
  int i ;
  int j ;
  int t ;

  {
  {
#line 984 "eval.tc"
  tmp = (*(((struct expression_vtable__ *)(this->expr)->vtable__)->eval_v__))(this->expr);
#line 984
  sides = tmp;
#line 985
  cside = sides;
  }
#line 987
  if ((unsigned int )this->ordering != 0U) {
    {
#line 988
    while (1) {
      while_continue: /* CIL Label */ ;
#line 988
      if (! cside) {
#line 988
        goto while_break;
      }
#line 990
      i = 0;
#line 990
      j = cside->count - 1;
      {
#line 991
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 991
        if (! (i < j)) {
#line 991
          goto while_break___0;
        }
#line 992
        t = *(cside->values + i);
#line 993
        *(cside->values + i) = *(cside->values + j);
#line 994
        *(cside->values + j) = t;
#line 995
        i ++;
#line 995
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 997
      cside = cside->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1001
  return (sides);
}
}
#line 3254 "tree.c"
struct rev_vtable__  const  rev_vt__  = 
#line 3254 "tree.c"
     {& unary_vt__, 26, "rev", (void (*)(expression *this__ , int depth ))(& rev_printtree__),
    (struct roll_value *(*)(expression *this__ ))(& rev_roll__), (void (*)(expression *this__ ,
                                                                           struct symtab *st ))(& unary_set_symtab__),
    (void (*)(expression *this__ , ordering_type ordering ))(& unary_set_ordering__),
    (struct val_list *(*)(expression *this__ ))(& rev_eval__), (expression *(*)(expression *this__ ))(& unary_optimize__)};
#line 3266 "tree.c"
expression *elist_create(void) 
{ 
  elist *node__ ;
  void *tmp ;

  {
  {
#line 3268
  tmp = yynodealloc((unsigned int )sizeof(struct elist__ ));
#line 3268
  node__ = (elist *)tmp;
  }
#line 3269
  if ((unsigned long )node__ == (unsigned long )((elist *)0)) {
#line 3269
    return ((expression *)0);
  }
  {
#line 3270
  node__->vtable__ = & elist_vt__;
#line 3271
  node__->kind__ = 15;
#line 3272
  node__->filename__ = yycurrfilename();
#line 3273
  node__->linenum__ = yycurrlinenum();
#line 3274
  node__->symtab = (struct symtab *)((void *)0);
#line 3275
  node__->ordering = (ordering_type )1;
  }
#line 3276
  return ((expression *)node__);
}
}
#line 3279 "tree.c"
expression *number_create(int num ) 
{ 
  number *node__ ;
  void *tmp ;

  {
  {
#line 3281
  tmp = yynodealloc((unsigned int )sizeof(struct number__ ));
#line 3281
  node__ = (number *)tmp;
  }
#line 3282
  if ((unsigned long )node__ == (unsigned long )((number *)0)) {
#line 3282
    return ((expression *)0);
  }
  {
#line 3283
  node__->vtable__ = & number_vt__;
#line 3284
  node__->kind__ = 18;
#line 3285
  node__->filename__ = yycurrfilename();
#line 3286
  node__->linenum__ = yycurrlinenum();
#line 3287
  node__->symtab = (struct symtab *)((void *)0);
#line 3288
  node__->ordering = (ordering_type )1;
#line 3289
  node__->num = num;
  }
#line 3290
  return ((expression *)node__);
}
}
#line 3293 "tree.c"
expression *ifthenelse_create(expression *if_expr , expression *then_expr , expression *else_expr ) 
{ 
  ifthenelse *node__ ;
  void *tmp ;

  {
  {
#line 3295
  tmp = yynodealloc((unsigned int )sizeof(struct ifthenelse__ ));
#line 3295
  node__ = (ifthenelse *)tmp;
  }
#line 3296
  if ((unsigned long )node__ == (unsigned long )((ifthenelse *)0)) {
#line 3296
    return ((expression *)0);
  }
  {
#line 3297
  node__->vtable__ = & ifthenelse_vt__;
#line 3298
  node__->kind__ = 38;
#line 3299
  node__->filename__ = yycurrfilename();
#line 3300
  node__->linenum__ = yycurrlinenum();
#line 3301
  node__->symtab = (struct symtab *)((void *)0);
#line 3302
  node__->ordering = (ordering_type )1;
#line 3303
  node__->if_expr = if_expr;
#line 3304
  node__->then_expr = then_expr;
#line 3305
  node__->else_expr = else_expr;
  }
#line 3306
  return ((expression *)node__);
}
}
#line 3309 "tree.c"
expression *variable_create(char *varname ) 
{ 
  variable *node__ ;
  void *tmp ;

  {
  {
#line 3311
  tmp = yynodealloc((unsigned int )sizeof(struct variable__ ));
#line 3311
  node__ = (variable *)tmp;
  }
#line 3312
  if ((unsigned long )node__ == (unsigned long )((variable *)0)) {
#line 3312
    return ((expression *)0);
  }
  {
#line 3313
  node__->vtable__ = & variable_vt__;
#line 3314
  node__->kind__ = 48;
#line 3315
  node__->filename__ = yycurrfilename();
#line 3316
  node__->linenum__ = yycurrlinenum();
#line 3317
  node__->symtab = (struct symtab *)((void *)0);
#line 3318
  node__->ordering = (ordering_type )1;
#line 3319
  node__->varname = varname;
  }
#line 3320
  return ((expression *)node__);
}
}
#line 3323 "tree.c"
expression *sumrepdice_create(struct val_list *num_dice , int num_sides ) 
{ 
  sumrepdice *node__ ;
  void *tmp ;

  {
  {
#line 3325
  tmp = yynodealloc((unsigned int )sizeof(struct sumrepdice__ ));
#line 3325
  node__ = (sumrepdice *)tmp;
  }
#line 3326
  if ((unsigned long )node__ == (unsigned long )((sumrepdice *)0)) {
#line 3326
    return ((expression *)0);
  }
  {
#line 3327
  node__->vtable__ = & sumrepdice_vt__;
#line 3328
  node__->kind__ = 49;
#line 3329
  node__->filename__ = yycurrfilename();
#line 3330
  node__->linenum__ = yycurrlinenum();
#line 3331
  node__->symtab = (struct symtab *)((void *)0);
#line 3332
  node__->ordering = (ordering_type )1;
#line 3333
  node__->num_dice = num_dice;
#line 3334
  node__->num_sides = num_sides;
  }
#line 3335
  return ((expression *)node__);
}
}
#line 3338 "tree.c"
expression *sumrepany_create(struct val_list *number___0 , struct val_list *data ) 
{ 
  sumrepany *node__ ;
  void *tmp ;

  {
  {
#line 3340
  tmp = yynodealloc((unsigned int )sizeof(struct sumrepany__ ));
#line 3340
  node__ = (sumrepany *)tmp;
  }
#line 3341
  if ((unsigned long )node__ == (unsigned long )((sumrepany *)0)) {
#line 3341
    return ((expression *)0);
  }
  {
#line 3342
  node__->vtable__ = & sumrepany_vt__;
#line 3343
  node__->kind__ = 50;
#line 3344
  node__->filename__ = yycurrfilename();
#line 3345
  node__->linenum__ = yycurrlinenum();
#line 3346
  node__->symtab = (struct symtab *)((void *)0);
#line 3347
  node__->ordering = (ordering_type )1;
#line 3348
  node__->number = number___0;
#line 3349
  node__->data = data;
  }
#line 3350
  return ((expression *)node__);
}
}
#line 3353 "tree.c"
expression *scat_create(expression *expr1 , expression *expr2 ) 
{ 
  scat *node__ ;
  void *tmp ;

  {
  {
#line 3355
  tmp = yynodealloc((unsigned int )sizeof(struct scat__ ));
#line 3355
  node__ = (scat *)tmp;
  }
#line 3356
  if ((unsigned long )node__ == (unsigned long )((scat *)0)) {
#line 3356
    return ((expression *)0);
  }
  {
#line 3357
  node__->vtable__ = & scat_vt__;
#line 3358
  node__->kind__ = 34;
#line 3359
  node__->filename__ = yycurrfilename();
#line 3360
  node__->linenum__ = yycurrlinenum();
#line 3361
  node__->symtab = (struct symtab *)((void *)0);
#line 3362
  node__->ordering = (ordering_type )1;
#line 3363
  node__->expr1 = expr1;
#line 3364
  node__->expr2 = expr2;
  }
#line 3365
  return ((expression *)node__);
}
}
#line 3368 "tree.c"
expression *rep_create(expression *expr1 , expression *expr2 ) 
{ 
  rep *node__ ;
  void *tmp ;

  {
  {
#line 3370
  tmp = yynodealloc((unsigned int )sizeof(struct rep__ ));
#line 3370
  node__ = (rep *)tmp;
  }
#line 3371
  if ((unsigned long )node__ == (unsigned long )((rep *)0)) {
#line 3371
    return ((expression *)0);
  }
  {
#line 3372
  node__->vtable__ = & rep_vt__;
#line 3373
  node__->kind__ = 35;
#line 3374
  node__->filename__ = yycurrfilename();
#line 3375
  node__->linenum__ = yycurrlinenum();
#line 3376
  node__->symtab = (struct symtab *)((void *)0);
#line 3377
  node__->ordering = (ordering_type )1;
#line 3378
  node__->expr1 = expr1;
#line 3379
  node__->expr2 = expr2;
  }
#line 3380
  return ((expression *)node__);
}
}
#line 3383 "tree.c"
expression *range_create(expression *expr1 , expression *expr2 ) 
{ 
  range *node__ ;
  void *tmp ;

  {
  {
#line 3385
  tmp = yynodealloc((unsigned int )sizeof(struct range__ ));
#line 3385
  node__ = (range *)tmp;
  }
#line 3386
  if ((unsigned long )node__ == (unsigned long )((range *)0)) {
#line 3386
    return ((expression *)0);
  }
  {
#line 3387
  node__->vtable__ = & range_vt__;
#line 3388
  node__->kind__ = 36;
#line 3389
  node__->filename__ = yycurrfilename();
#line 3390
  node__->linenum__ = yycurrlinenum();
#line 3391
  node__->symtab = (struct symtab *)((void *)0);
#line 3392
  node__->ordering = (ordering_type )1;
#line 3393
  node__->expr1 = expr1;
#line 3394
  node__->expr2 = expr2;
  }
#line 3395
  return ((expression *)node__);
}
}
#line 3398 "tree.c"
expression *lcat_create(expression *expr1 , expression *expr2 ) 
{ 
  lcat *node__ ;
  void *tmp ;

  {
  {
#line 3400
  tmp = yynodealloc((unsigned int )sizeof(struct lcat__ ));
#line 3400
  node__ = (lcat *)tmp;
  }
#line 3401
  if ((unsigned long )node__ == (unsigned long )((lcat *)0)) {
#line 3401
    return ((expression *)0);
  }
  {
#line 3402
  node__->vtable__ = & lcat_vt__;
#line 3403
  node__->kind__ = 37;
#line 3404
  node__->filename__ = yycurrfilename();
#line 3405
  node__->linenum__ = yycurrlinenum();
#line 3406
  node__->symtab = (struct symtab *)((void *)0);
#line 3407
  node__->ordering = (ordering_type )1;
#line 3408
  node__->expr1 = expr1;
#line 3409
  node__->expr2 = expr2;
  }
#line 3410
  return ((expression *)node__);
}
}
#line 3413 "tree.c"
expression *let_create(expression *expr1 , expression *expr2 , char *varname ) 
{ 
  let *node__ ;
  void *tmp ;

  {
  {
#line 3415
  tmp = yynodealloc((unsigned int )sizeof(struct let__ ));
#line 3415
  node__ = (let *)tmp;
  }
#line 3416
  if ((unsigned long )node__ == (unsigned long )((let *)0)) {
#line 3416
    return ((expression *)0);
  }
  {
#line 3417
  node__->vtable__ = & let_vt__;
#line 3418
  node__->kind__ = 45;
#line 3419
  node__->filename__ = yycurrfilename();
#line 3420
  node__->linenum__ = yycurrlinenum();
#line 3421
  node__->symtab = (struct symtab *)((void *)0);
#line 3422
  node__->ordering = (ordering_type )1;
#line 3423
  node__->expr1 = expr1;
#line 3424
  node__->expr2 = expr2;
#line 3425
  node__->varname = varname;
  }
#line 3426
  return ((expression *)node__);
}
}
#line 3429 "tree.c"
expression *foreach_create(expression *expr1 , expression *expr2 , char *varname ) 
{ 
  foreach *node__ ;
  void *tmp ;

  {
  {
#line 3431
  tmp = yynodealloc((unsigned int )sizeof(struct foreach__ ));
#line 3431
  node__ = (foreach *)tmp;
  }
#line 3432
  if ((unsigned long )node__ == (unsigned long )((foreach *)0)) {
#line 3432
    return ((expression *)0);
  }
  {
#line 3433
  node__->vtable__ = & foreach_vt__;
#line 3434
  node__->kind__ = 46;
#line 3435
  node__->filename__ = yycurrfilename();
#line 3436
  node__->linenum__ = yycurrlinenum();
#line 3437
  node__->symtab = (struct symtab *)((void *)0);
#line 3438
  node__->ordering = (ordering_type )1;
#line 3439
  node__->expr1 = expr1;
#line 3440
  node__->expr2 = expr2;
#line 3441
  node__->varname = varname;
  }
#line 3442
  return ((expression *)node__);
}
}
#line 3445 "tree.c"
expression *whiledo_create(expression *expr1 , expression *expr2 , char *varname ) 
{ 
  whiledo *node__ ;
  void *tmp ;

  {
  {
#line 3447
  tmp = yynodealloc((unsigned int )sizeof(struct whiledo__ ));
#line 3447
  node__ = (whiledo *)tmp;
  }
#line 3448
  if ((unsigned long )node__ == (unsigned long )((whiledo *)0)) {
#line 3448
    return ((expression *)0);
  }
  {
#line 3449
  node__->vtable__ = & whiledo_vt__;
#line 3450
  node__->kind__ = 47;
#line 3451
  node__->filename__ = yycurrfilename();
#line 3452
  node__->linenum__ = yycurrlinenum();
#line 3453
  node__->symtab = (struct symtab *)((void *)0);
#line 3454
  node__->ordering = (ordering_type )1;
#line 3455
  node__->expr1 = expr1;
#line 3456
  node__->expr2 = expr2;
#line 3457
  node__->varname = varname;
  }
#line 3458
  return ((expression *)node__);
}
}
#line 3461 "tree.c"
expression *plus_create(expression *expr1 , expression *expr2 ) 
{ 
  plus *node__ ;
  void *tmp ;

  {
  {
#line 3463
  tmp = yynodealloc((unsigned int )sizeof(struct plus__ ));
#line 3463
  node__ = (plus *)tmp;
  }
#line 3464
  if ((unsigned long )node__ == (unsigned long )((plus *)0)) {
#line 3464
    return ((expression *)0);
  }
  {
#line 3465
  node__->vtable__ = & plus_vt__;
#line 3466
  node__->kind__ = 28;
#line 3467
  node__->filename__ = yycurrfilename();
#line 3468
  node__->linenum__ = yycurrlinenum();
#line 3469
  node__->symtab = (struct symtab *)((void *)0);
#line 3470
  node__->ordering = (ordering_type )1;
#line 3471
  node__->expr1 = expr1;
#line 3472
  node__->expr2 = expr2;
  }
#line 3473
  return ((expression *)node__);
}
}
#line 3476 "tree.c"
expression *minus_create(expression *expr1 , expression *expr2 ) 
{ 
  minus *node__ ;
  void *tmp ;

  {
  {
#line 3478
  tmp = yynodealloc((unsigned int )sizeof(struct minus__ ));
#line 3478
  node__ = (minus *)tmp;
  }
#line 3479
  if ((unsigned long )node__ == (unsigned long )((minus *)0)) {
#line 3479
    return ((expression *)0);
  }
  {
#line 3480
  node__->vtable__ = & minus_vt__;
#line 3481
  node__->kind__ = 29;
#line 3482
  node__->filename__ = yycurrfilename();
#line 3483
  node__->linenum__ = yycurrlinenum();
#line 3484
  node__->symtab = (struct symtab *)((void *)0);
#line 3485
  node__->ordering = (ordering_type )1;
#line 3486
  node__->expr1 = expr1;
#line 3487
  node__->expr2 = expr2;
  }
#line 3488
  return ((expression *)node__);
}
}
#line 3491 "tree.c"
expression *multi_create(expression *expr1 , expression *expr2 ) 
{ 
  multi *node__ ;
  void *tmp ;

  {
  {
#line 3493
  tmp = yynodealloc((unsigned int )sizeof(struct multi__ ));
#line 3493
  node__ = (multi *)tmp;
  }
#line 3494
  if ((unsigned long )node__ == (unsigned long )((multi *)0)) {
#line 3494
    return ((expression *)0);
  }
  {
#line 3495
  node__->vtable__ = & multi_vt__;
#line 3496
  node__->kind__ = 30;
#line 3497
  node__->filename__ = yycurrfilename();
#line 3498
  node__->linenum__ = yycurrlinenum();
#line 3499
  node__->symtab = (struct symtab *)((void *)0);
#line 3500
  node__->ordering = (ordering_type )1;
#line 3501
  node__->expr1 = expr1;
#line 3502
  node__->expr2 = expr2;
  }
#line 3503
  return ((expression *)node__);
}
}
#line 3506 "tree.c"
expression *divi_create(expression *expr1 , expression *expr2 ) 
{ 
  divi *node__ ;
  void *tmp ;

  {
  {
#line 3508
  tmp = yynodealloc((unsigned int )sizeof(struct divi__ ));
#line 3508
  node__ = (divi *)tmp;
  }
#line 3509
  if ((unsigned long )node__ == (unsigned long )((divi *)0)) {
#line 3509
    return ((expression *)0);
  }
  {
#line 3510
  node__->vtable__ = & divi_vt__;
#line 3511
  node__->kind__ = 31;
#line 3512
  node__->filename__ = yycurrfilename();
#line 3513
  node__->linenum__ = yycurrlinenum();
#line 3514
  node__->symtab = (struct symtab *)((void *)0);
#line 3515
  node__->ordering = (ordering_type )1;
#line 3516
  node__->expr1 = expr1;
#line 3517
  node__->expr2 = expr2;
  }
#line 3518
  return ((expression *)node__);
}
}
#line 3521 "tree.c"
expression *mod_create(expression *expr1 , expression *expr2 ) 
{ 
  mod *node__ ;
  void *tmp ;

  {
  {
#line 3523
  tmp = yynodealloc((unsigned int )sizeof(struct mod__ ));
#line 3523
  node__ = (mod *)tmp;
  }
#line 3524
  if ((unsigned long )node__ == (unsigned long )((mod *)0)) {
#line 3524
    return ((expression *)0);
  }
  {
#line 3525
  node__->vtable__ = & mod_vt__;
#line 3526
  node__->kind__ = 32;
#line 3527
  node__->filename__ = yycurrfilename();
#line 3528
  node__->linenum__ = yycurrlinenum();
#line 3529
  node__->symtab = (struct symtab *)((void *)0);
#line 3530
  node__->ordering = (ordering_type )1;
#line 3531
  node__->expr1 = expr1;
#line 3532
  node__->expr2 = expr2;
  }
#line 3533
  return ((expression *)node__);
}
}
#line 3536 "tree.c"
expression *expo_create(expression *expr1 , expression *expr2 ) 
{ 
  expo *node__ ;
  void *tmp ;

  {
  {
#line 3538
  tmp = yynodealloc((unsigned int )sizeof(struct expo__ ));
#line 3538
  node__ = (expo *)tmp;
  }
#line 3539
  if ((unsigned long )node__ == (unsigned long )((expo *)0)) {
#line 3539
    return ((expression *)0);
  }
  {
#line 3540
  node__->vtable__ = & expo_vt__;
#line 3541
  node__->kind__ = 33;
#line 3542
  node__->filename__ = yycurrfilename();
#line 3543
  node__->linenum__ = yycurrlinenum();
#line 3544
  node__->symtab = (struct symtab *)((void *)0);
#line 3545
  node__->ordering = (ordering_type )1;
#line 3546
  node__->expr1 = expr1;
#line 3547
  node__->expr2 = expr2;
  }
#line 3548
  return ((expression *)node__);
}
}
#line 3551 "tree.c"
expression *first_create(expression *expr1 , expression *expr2 , filter_type type ) 
{ 
  first *node__ ;
  void *tmp ;

  {
  {
#line 3553
  tmp = yynodealloc((unsigned int )sizeof(struct first__ ));
#line 3553
  node__ = (first *)tmp;
  }
#line 3554
  if ((unsigned long )node__ == (unsigned long )((first *)0)) {
#line 3554
    return ((expression *)0);
  }
  {
#line 3555
  node__->vtable__ = & first_vt__;
#line 3556
  node__->kind__ = 40;
#line 3557
  node__->filename__ = yycurrfilename();
#line 3558
  node__->linenum__ = yycurrlinenum();
#line 3559
  node__->symtab = (struct symtab *)((void *)0);
#line 3560
  node__->ordering = (ordering_type )1;
#line 3561
  node__->expr1 = expr1;
#line 3562
  node__->expr2 = expr2;
#line 3563
  node__->type = type;
  }
#line 3564
  return ((expression *)node__);
}
}
#line 3567 "tree.c"
expression *last_create(expression *expr1 , expression *expr2 , filter_type type ) 
{ 
  last *node__ ;
  void *tmp ;

  {
  {
#line 3569
  tmp = yynodealloc((unsigned int )sizeof(struct last__ ));
#line 3569
  node__ = (last *)tmp;
  }
#line 3570
  if ((unsigned long )node__ == (unsigned long )((last *)0)) {
#line 3570
    return ((expression *)0);
  }
  {
#line 3571
  node__->vtable__ = & last_vt__;
#line 3572
  node__->kind__ = 41;
#line 3573
  node__->filename__ = yycurrfilename();
#line 3574
  node__->linenum__ = yycurrlinenum();
#line 3575
  node__->symtab = (struct symtab *)((void *)0);
#line 3576
  node__->ordering = (ordering_type )1;
#line 3577
  node__->expr1 = expr1;
#line 3578
  node__->expr2 = expr2;
#line 3579
  node__->type = type;
  }
#line 3580
  return ((expression *)node__);
}
}
#line 3583 "tree.c"
expression *high_create(expression *expr1 , expression *expr2 , filter_type type ) 
{ 
  high *node__ ;
  void *tmp ;

  {
  {
#line 3585
  tmp = yynodealloc((unsigned int )sizeof(struct high__ ));
#line 3585
  node__ = (high *)tmp;
  }
#line 3586
  if ((unsigned long )node__ == (unsigned long )((high *)0)) {
#line 3586
    return ((expression *)0);
  }
  {
#line 3587
  node__->vtable__ = & high_vt__;
#line 3588
  node__->kind__ = 42;
#line 3589
  node__->filename__ = yycurrfilename();
#line 3590
  node__->linenum__ = yycurrlinenum();
#line 3591
  node__->symtab = (struct symtab *)((void *)0);
#line 3592
  node__->ordering = (ordering_type )1;
#line 3593
  node__->expr1 = expr1;
#line 3594
  node__->expr2 = expr2;
#line 3595
  node__->type = type;
  }
#line 3596
  return ((expression *)node__);
}
}
#line 3599 "tree.c"
expression *low_create(expression *expr1 , expression *expr2 , filter_type type ) 
{ 
  low *node__ ;
  void *tmp ;

  {
  {
#line 3601
  tmp = yynodealloc((unsigned int )sizeof(struct low__ ));
#line 3601
  node__ = (low *)tmp;
  }
#line 3602
  if ((unsigned long )node__ == (unsigned long )((low *)0)) {
#line 3602
    return ((expression *)0);
  }
  {
#line 3603
  node__->vtable__ = & low_vt__;
#line 3604
  node__->kind__ = 43;
#line 3605
  node__->filename__ = yycurrfilename();
#line 3606
  node__->linenum__ = yycurrlinenum();
#line 3607
  node__->symtab = (struct symtab *)((void *)0);
#line 3608
  node__->ordering = (ordering_type )1;
#line 3609
  node__->expr1 = expr1;
#line 3610
  node__->expr2 = expr2;
#line 3611
  node__->type = type;
  }
#line 3612
  return ((expression *)node__);
}
}
#line 3615 "tree.c"
expression *comparison_create(expression *expr1 , expression *expr2 , filter_type type ,
                              comparison_type comp ) 
{ 
  comparison *node__ ;
  void *tmp ;

  {
  {
#line 3617
  tmp = yynodealloc((unsigned int )sizeof(struct comparison__ ));
#line 3617
  node__ = (comparison *)tmp;
  }
#line 3618
  if ((unsigned long )node__ == (unsigned long )((comparison *)0)) {
#line 3618
    return ((expression *)0);
  }
  {
#line 3619
  node__->vtable__ = & comparison_vt__;
#line 3620
  node__->kind__ = 44;
#line 3621
  node__->filename__ = yycurrfilename();
#line 3622
  node__->linenum__ = yycurrlinenum();
#line 3623
  node__->symtab = (struct symtab *)((void *)0);
#line 3624
  node__->ordering = (ordering_type )1;
#line 3625
  node__->expr1 = expr1;
#line 3626
  node__->expr2 = expr2;
#line 3627
  node__->type = type;
#line 3628
  node__->comp = comp;
  }
#line 3629
  return ((expression *)node__);
}
}
#line 3632 "tree.c"
expression *negate_create(expression *expr ) 
{ 
  negate *node__ ;
  void *tmp ;

  {
  {
#line 3634
  tmp = yynodealloc((unsigned int )sizeof(struct negate__ ));
#line 3634
  node__ = (negate *)tmp;
  }
#line 3635
  if ((unsigned long )node__ == (unsigned long )((negate *)0)) {
#line 3635
    return ((expression *)0);
  }
  {
#line 3636
  node__->vtable__ = & negate_vt__;
#line 3637
  node__->kind__ = 19;
#line 3638
  node__->filename__ = yycurrfilename();
#line 3639
  node__->linenum__ = yycurrlinenum();
#line 3640
  node__->symtab = (struct symtab *)((void *)0);
#line 3641
  node__->ordering = (ordering_type )1;
#line 3642
  node__->expr = expr;
  }
#line 3643
  return ((expression *)node__);
}
}
#line 3646 "tree.c"
expression *dice_create(expression *expr ) 
{ 
  dice *node__ ;
  void *tmp ;

  {
  {
#line 3648
  tmp = yynodealloc((unsigned int )sizeof(struct dice__ ));
#line 3648
  node__ = (dice *)tmp;
  }
#line 3649
  if ((unsigned long )node__ == (unsigned long )((dice *)0)) {
#line 3649
    return ((expression *)0);
  }
  {
#line 3650
  node__->vtable__ = & dice_vt__;
#line 3651
  node__->kind__ = 20;
#line 3652
  node__->filename__ = yycurrfilename();
#line 3653
  node__->linenum__ = yycurrlinenum();
#line 3654
  node__->symtab = (struct symtab *)((void *)0);
#line 3655
  node__->ordering = (ordering_type )1;
#line 3656
  node__->expr = expr;
  }
#line 3657
  return ((expression *)node__);
}
}
#line 3660 "tree.c"
expression *sum_create(expression *expr ) 
{ 
  sum *node__ ;
  void *tmp ;

  {
  {
#line 3662
  tmp = yynodealloc((unsigned int )sizeof(struct sum__ ));
#line 3662
  node__ = (sum *)tmp;
  }
#line 3663
  if ((unsigned long )node__ == (unsigned long )((sum *)0)) {
#line 3663
    return ((expression *)0);
  }
  {
#line 3664
  node__->vtable__ = & sum_vt__;
#line 3665
  node__->kind__ = 21;
#line 3666
  node__->filename__ = yycurrfilename();
#line 3667
  node__->linenum__ = yycurrlinenum();
#line 3668
  node__->symtab = (struct symtab *)((void *)0);
#line 3669
  node__->ordering = (ordering_type )1;
#line 3670
  node__->expr = expr;
  }
#line 3671
  return ((expression *)node__);
}
}
#line 3674 "tree.c"
expression *prod_create(expression *expr ) 
{ 
  prod *node__ ;
  void *tmp ;

  {
  {
#line 3676
  tmp = yynodealloc((unsigned int )sizeof(struct prod__ ));
#line 3676
  node__ = (prod *)tmp;
  }
#line 3677
  if ((unsigned long )node__ == (unsigned long )((prod *)0)) {
#line 3677
    return ((expression *)0);
  }
  {
#line 3678
  node__->vtable__ = & prod_vt__;
#line 3679
  node__->kind__ = 22;
#line 3680
  node__->filename__ = yycurrfilename();
#line 3681
  node__->linenum__ = yycurrlinenum();
#line 3682
  node__->symtab = (struct symtab *)((void *)0);
#line 3683
  node__->ordering = (ordering_type )1;
#line 3684
  node__->expr = expr;
  }
#line 3685
  return ((expression *)node__);
}
}
#line 3688 "tree.c"
expression *count_create(expression *expr ) 
{ 
  count *node__ ;
  void *tmp ;

  {
  {
#line 3690
  tmp = yynodealloc((unsigned int )sizeof(struct count__ ));
#line 3690
  node__ = (count *)tmp;
  }
#line 3691
  if ((unsigned long )node__ == (unsigned long )((count *)0)) {
#line 3691
    return ((expression *)0);
  }
  {
#line 3692
  node__->vtable__ = & count_vt__;
#line 3693
  node__->kind__ = 23;
#line 3694
  node__->filename__ = yycurrfilename();
#line 3695
  node__->linenum__ = yycurrlinenum();
#line 3696
  node__->symtab = (struct symtab *)((void *)0);
#line 3697
  node__->ordering = (ordering_type )1;
#line 3698
  node__->expr = expr;
  }
#line 3699
  return ((expression *)node__);
}
}
#line 3702 "tree.c"
expression *perm_create(expression *expr ) 
{ 
  perm *node__ ;
  void *tmp ;

  {
  {
#line 3704
  tmp = yynodealloc((unsigned int )sizeof(struct perm__ ));
#line 3704
  node__ = (perm *)tmp;
  }
#line 3705
  if ((unsigned long )node__ == (unsigned long )((perm *)0)) {
#line 3705
    return ((expression *)0);
  }
  {
#line 3706
  node__->vtable__ = & perm_vt__;
#line 3707
  node__->kind__ = 24;
#line 3708
  node__->filename__ = yycurrfilename();
#line 3709
  node__->linenum__ = yycurrlinenum();
#line 3710
  node__->symtab = (struct symtab *)((void *)0);
#line 3711
  node__->ordering = (ordering_type )1;
#line 3712
  node__->expr = expr;
  }
#line 3713
  return ((expression *)node__);
}
}
#line 3716 "tree.c"
expression *sort_create(expression *expr ) 
{ 
  sort *node__ ;
  void *tmp ;

  {
  {
#line 3718
  tmp = yynodealloc((unsigned int )sizeof(struct sort__ ));
#line 3718
  node__ = (sort *)tmp;
  }
#line 3719
  if ((unsigned long )node__ == (unsigned long )((sort *)0)) {
#line 3719
    return ((expression *)0);
  }
  {
#line 3720
  node__->vtable__ = & sort_vt__;
#line 3721
  node__->kind__ = 25;
#line 3722
  node__->filename__ = yycurrfilename();
#line 3723
  node__->linenum__ = yycurrlinenum();
#line 3724
  node__->symtab = (struct symtab *)((void *)0);
#line 3725
  node__->ordering = (ordering_type )1;
#line 3726
  node__->expr = expr;
  }
#line 3727
  return ((expression *)node__);
}
}
#line 3730 "tree.c"
expression *rev_create(expression *expr ) 
{ 
  rev *node__ ;
  void *tmp ;

  {
  {
#line 3732
  tmp = yynodealloc((unsigned int )sizeof(struct rev__ ));
#line 3732
  node__ = (rev *)tmp;
  }
#line 3733
  if ((unsigned long )node__ == (unsigned long )((rev *)0)) {
#line 3733
    return ((expression *)0);
  }
  {
#line 3734
  node__->vtable__ = & rev_vt__;
#line 3735
  node__->kind__ = 26;
#line 3736
  node__->filename__ = yycurrfilename();
#line 3737
  node__->linenum__ = yycurrlinenum();
#line 3738
  node__->symtab = (struct symtab *)((void *)0);
#line 3739
  node__->ordering = (ordering_type )1;
#line 3740
  node__->expr = expr;
  }
#line 3741
  return ((expression *)node__);
}
}
#line 3749 "tree.c"
int yyisa__(void const   *vtable__ , int kind__ ) 
{ 
  struct yy_vtable__  const  *vt ;

  {
#line 3752
  vt = (struct yy_vtable__  const  *)vtable__;
  {
#line 3753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3753
    if (! ((unsigned long )vt != (unsigned long )((struct yy_vtable__  const  *)0))) {
#line 3753
      goto while_break;
    }
#line 3754
    if (vt->kind__ == (int const   )kind__) {
#line 3755
      return (1);
    }
#line 3756
    vt = (struct yy_vtable__  const  *)vt->parent__;
  }
  while_break: /* CIL Label */ ;
  }
#line 3758
  return (0);
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int cmd_parse_tree  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int cmd_roll  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int cmd_rolleval  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int cmd_calc  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int cmd_count  =    10000;
#line 31 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
float cmd_threshold  =    (float )0.000001;
#line 35 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
static struct option long_options[10]  = 
#line 35
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"print-tree", 0, (int *)0, 'p'}, 
        {"roll", 0, (int *)0, 'r'}, 
        {"eval", 0, (int *)0, 'e'}, 
        {"calc", 0, (int *)0, 'c'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"count", 1, (int *)0, 'n'}, 
        {"threshold", 1, (int *)0, 't'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 49 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
void usage(void) 
{ 


  {
  {
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: dicelab [options] [-f <file>]\nOptions:\n  --help -h -?     print this text\n  --version -v     print the program version\n  --print-tree -p  print the parse tree (for debugging)\n  --eval -e        evaluate the statistical distribution by\n                   re-rolling\n  --calc -c        calculate the distribution\n  --count -n       specify the number of rolls used with --eval\n                   default is %i\n  --roll -r        roll the dice as specified, will also be used\n                   if no other action is requested\n  --threshold -t   cutoff threshold, results with a probability less\n                   than this value will be discarded by some operations\n                   when using --calc\nFile:\n  --file -f        read the dice rolling specs from the file\n                   specified, use stdin if not supplied\n\n",
          10000);
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
void splitargv(int argc , char **argv , int *margc , char ***margv ) 
{ 
  int i ;
  char *tok ;
  int first ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 72
  *margc = 0;
#line 73
  *margv = (char **)((void *)0);
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < argc)) {
#line 75
      goto while_break;
    }
#line 77
    first = 1;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (first) {
#line 78
        tmp___0 = *(argv + i);
      } else {
#line 78
        tmp___0 = (char *)((void *)0);
      }
      {
#line 78
      tok = strtok((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)" ");
      }
#line 78
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 78
        goto while_break___0;
      }
      {
#line 79
      first = 0;
#line 80
      (*margc) ++;
#line 81
      tmp = realloc((void *)*margv, sizeof(char *) * (unsigned long )*margc);
#line 81
      *margv = (char **)tmp;
#line 82
      *(*margv + (*margc - 1)) = tok;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/dicelab-0.7/main.c"
int main(int argc , char **argv ) 
{ 
  time_t tmp ;
  char *fname ;
  int option_index ;
  int c ;
  int margc ;
  char **margv ;
  double tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 88
  tmp = time((time_t *)((void *)0));
#line 88
  srand((unsigned int )tmp);
#line 89
  fname = (char *)((void *)0);
#line 91
  option_index = 0;
#line 97
  splitargv(argc, argv, & margc, & margv);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    c = getopt_long(margc, (char * const  *)margv, "?hvprecn:f:t:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 102
    if (c == -1) {
#line 103
      goto while_break;
    }
    {
#line 107
    if (c == 118) {
#line 107
      goto case_118;
    }
#line 112
    if (c == 112) {
#line 112
      goto case_112;
    }
#line 115
    if (c == 114) {
#line 115
      goto case_114;
    }
#line 118
    if (c == 101) {
#line 118
      goto case_101;
    }
#line 121
    if (c == 99) {
#line 121
      goto case_99;
    }
#line 124
    if (c == 110) {
#line 124
      goto case_110;
    }
#line 136
    if (c == 116) {
#line 136
      goto case_116;
    }
#line 147
    if (c == 102) {
#line 147
      goto case_102;
    }
#line 152
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 108
    printf((char const   */* __restrict  */)"%s v%s by %s\n", "dicelab", "0.7", "Robert Lemmen <robertle@semistable.com>");
    }
#line 110
    return (0);
#line 111
    goto switch_break;
    case_112: /* CIL Label */ 
#line 113
    cmd_parse_tree = 1;
#line 114
    goto switch_break;
    case_114: /* CIL Label */ 
#line 116
    cmd_roll = 1;
#line 117
    goto switch_break;
    case_101: /* CIL Label */ 
#line 119
    cmd_rolleval = 1;
#line 120
    goto switch_break;
    case_99: /* CIL Label */ 
#line 122
    cmd_calc = 1;
#line 123
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 126
    cmd_count = atoi((char const   *)optarg);
    }
#line 127
    if (cmd_count < 1) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Value for --count too low, adjusted to %i\n",
              1);
#line 129
      cmd_count = 1;
      }
    }
#line 131
    if (cmd_count > 100000000) {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Value for --count too high, adjusted to %i\n",
              100000000);
#line 133
      cmd_count = 100000000;
      }
    }
#line 135
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 137
    tmp___0 = atof((char const   *)optarg);
#line 137
    cmd_threshold = (float )tmp___0;
    }
#line 138
    if (cmd_threshold < 1.17549435082228750797e-38F) {
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Value for --threshold too low, adjusted\n");
#line 140
      cmd_threshold = 1.17549435082228750797e-38F;
      }
    }
#line 142
    if ((double )cmd_threshold > 0.01) {
      {
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Value for --threshold too high, adjusted to %f\n",
              0.01);
#line 144
      cmd_threshold = (float )0.01;
      }
    }
#line 146
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 148
    tmp___1 = strlen((char const   *)optarg);
#line 148
    tmp___2 = malloc((tmp___1 + 1UL) * sizeof(char ));
#line 148
    fname = (char *)tmp___2;
#line 149
    filename = fname;
#line 150
    strcpy((char */* __restrict  */)fname, (char const   */* __restrict  */)optarg);
    }
#line 151
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 153
    usage();
    }
#line 154
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (optind < margc) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"useless argument \"%s\"\n",
            *(margv + optind));
#line 159
    usage();
    }
#line 160
    return (1);
  }
#line 163
  if (cmd_parse_tree == 0) {
#line 163
    if (cmd_roll == 0) {
#line 163
      if (cmd_rolleval == 0) {
#line 163
        if (cmd_calc == 0) {
#line 165
          cmd_roll = 1;
        }
      }
    }
  }
  {
#line 169
  free((void *)margv);
#line 170
  margv = (char **)((void *)0);
#line 172
  yyin = stdin;
  }
#line 173
  if (fname) {
    {
#line 174
    yyin = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 175
    if ((unsigned long )yyin == (unsigned long )((void *)0)) {
      {
#line 176
      tmp___3 = __errno_location();
#line 176
      tmp___4 = strerror(*tmp___3);
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open file \"%s\": %s\n",
              fname, tmp___4);
#line 178
      free((void *)fname);
      }
#line 179
      return (1);
    }
  }
  {
#line 183
  yyparse();
  }
#line 185
  if (fname) {
    {
#line 186
    free((void *)fname);
    }
  }
#line 188
  return (0);
}
}
