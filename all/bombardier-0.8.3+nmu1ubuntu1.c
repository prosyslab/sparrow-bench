/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 390 "/usr/include/curses.h"
struct __anonstruct_cchar_t_7 {
   attr_t attr ;
   wchar_t chars[5] ;
};
#line 390 "/usr/include/curses.h"
typedef struct __anonstruct_cchar_t_7 cchar_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_17 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_17 fd_set;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/structs.h"
struct struc_state {
   unsigned char houses[80] ;
   int houses_text[80] ;
   unsigned char line ;
   unsigned char x ;
   unsigned char bombx ;
   unsigned char bomby ;
   unsigned char willbebombed ;
   unsigned char crashed ;
   unsigned int city ;
   unsigned int blocks ;
   unsigned int numofblocks ;
   unsigned char exit ;
   unsigned int delay ;
   int score ;
   char *text ;
   struct timeval tvusleeputan ;
   struct timeval szamolashoz ;
   struct timeval uu ;
   struct timeval ue ;
   long bombsleep ;
   long usleepelni ;
   int shouldpause ;
};
#line 28 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/structs.h"
struct struc_texts {
   unsigned char minfloor ;
   unsigned char maxfloor ;
   char *text ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 21 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
int gx(int x ) ;
#line 22
int gy(int y ) ;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/extern.h"
int maxx ;
#line 6
int maxy ;
#line 8 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/gcurses.c"
int gx(int x ) 
{ 


  {
#line 10
  return (x + (maxx - 80) / 2);
}
}
#line 13 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/gcurses.c"
int gy(int y ) 
{ 


  {
#line 15
  return (y + (maxy - 24) / 2);
}
}
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 597
extern int curs_set(int  ) ;
#line 611
extern int endwin(void) ;
#line 615
extern int flushinp(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
int initdsp(void) ;
#line 7
int resizedsp(int start ) ;
#line 8
void closedsp(void) ;
#line 11
void display_state(struct struc_state *state___0 , struct struc_texts *texts___0 ) ;
#line 13
void welcomescreen(void) ;
#line 14
int winlosewindow(struct struc_state *state___0 ) ;
#line 16
void hof(struct struc_state *state___0 ) ;
#line 20
int dropsignal(void) ;
#line 23
void gerase(void) ;
#line 24
void fillspace(void) ;
#line 8 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
void fillspace(void) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 12
  i = 0;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! (i < maxx)) {
#line 12
      goto while_break;
    }
#line 13
    j = 0;
    {
#line 13
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 13
      if (! (j < maxy)) {
#line 13
        goto while_break___0;
      }
#line 13
      if (i < maxx / 2 - 40) {
#line 13
        goto _L;
      } else
#line 13
      if (i >= maxx / 2 + 40) {
#line 13
        goto _L;
      } else
#line 13
      if (j < maxy / 2 - 12) {
#line 13
        goto _L;
      } else
#line 13
      if (j > maxy / 2 + 12) {
        _L: /* CIL Label */ 
        {
#line 13
        tmp = wmove(stdscr, j, i);
        }
#line 13
        if (! (tmp == -1)) {
          {
#line 13
          waddch(stdscr, (chtype const   )'.');
          }
        }
      }
#line 13
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 12
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return;
}
}
#line 16 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
void gerase(void) 
{ 


  {
  {
#line 18
  werase(stdscr);
#line 19
  fillspace();
  }
#line 20
  return;
}
}
#line 22 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
int resizedsp(int start ) 
{ 
  int getret ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;

  {
#line 27
  if (start) {
#line 27
    getret = ' ';
  } else {
#line 28
    getret = 'a';
  }
  {
#line 29
  dropsignal();
#line 30
  wrefresh(stdscr);
  }
#line 31
  if (stdscr) {
#line 31
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 31
    maxy = -1;
  }
#line 31
  if (stdscr) {
#line 31
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 31
    maxx = -1;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (maxy < 25)) {
#line 32
      if (! (maxx < 80)) {
#line 32
        if (! (getret != 32)) {
#line 32
          goto while_break;
        }
      }
    }
    {
#line 34
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 34
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 34
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 34
    fds.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 35
    werase(stdscr);
#line 36
    printw("Current size: %dx%d. Wanted size: %dx%d.\n", maxx, maxy, 80, 25);
    }
#line 37
    if (maxy >= 25) {
#line 37
      if (maxx >= 80) {
        {
#line 37
        printw("Press SPACE to continue!\n");
        }
      }
    }
    {
#line 38
    wrefresh(stdscr);
#line 39
    select(1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 40
    getret = wgetch(stdscr);
#line 41
    endwin();
#line 42
    wrefresh(stdscr);
    }
#line 43
    if (stdscr) {
#line 43
      maxy = (int )stdscr->_maxy + 1;
    } else {
#line 43
      maxy = -1;
    }
#line 43
    if (stdscr) {
#line 43
      maxx = (int )stdscr->_maxx + 1;
    } else {
#line 43
      maxx = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  gerase();
#line 46
  wrefresh(stdscr);
  }
#line 47
  return (1);
}
}
#line 50 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
int initdsp(void) 
{ 


  {
  {
#line 52
  initscr();
#line 53
  cbreak();
#line 54
  noecho();
#line 55
  nodelay(stdscr, (_Bool)1);
#line 56
  scrollok(stdscr, (_Bool)0);
#line 57
  curs_set(0);
  }
#line 59
  return (1);
}
}
#line 62 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
void closedsp(void) 
{ 


  {
  {
#line 64
  flushinp();
#line 65
  werase(stdscr);
#line 66
  wrefresh(stdscr);
#line 67
  endwin();
  }
#line 68
  return;
}
}
#line 70 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
void welcomescreen(void) 
{ 
  int l ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
  {
#line 75
  nodelay(stdscr, (_Bool)1);
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 78
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 79
    fds.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 80
    endwin();
#line 81
    resizedsp(1);
#line 82
    gerase();
#line 83
    tmp = gx(0);
#line 83
    tmp___0 = gy(0);
#line 83
    mvprintw(tmp___0, tmp, "Version: %s", "0.8.3");
#line 84
    tmp___1 = gx(0);
#line 84
    tmp___2 = gy(5);
#line 84
    mvprintw(tmp___2, tmp___1, "              /----------------------------------------------\\");
#line 85
    tmp___3 = gx(0);
#line 85
    tmp___4 = gy(6);
#line 85
    mvprintw(tmp___4, tmp___3, "              |                  Bombardier                  |");
#line 86
    tmp___5 = gx(0);
#line 86
    tmp___6 = gy(7);
#line 86
    mvprintw(tmp___6, tmp___5, "              |            The GNU Bombing utility           |");
#line 87
    tmp___7 = gx(0);
#line 87
    tmp___8 = gy(8);
#line 87
    mvprintw(tmp___8, tmp___7, "              |----------------------------------------------|");
#line 88
    tmp___9 = gx(0);
#line 88
    tmp___10 = gy(9);
#line 88
    mvprintw(tmp___10, tmp___9, "              |     (C) Gergely Risko  <gergely@risko.hu>    |");
#line 89
    tmp___11 = gx(0);
#line 89
    tmp___12 = gy(10);
#line 89
    mvprintw(tmp___12, tmp___11, "              |                  2001 - 2009                 |");
#line 90
    tmp___13 = gx(0);
#line 90
    tmp___14 = gy(11);
#line 90
    mvprintw(tmp___14, tmp___13, "              |                                              |");
#line 91
    tmp___15 = gx(0);
#line 91
    tmp___16 = gy(12);
#line 91
    mvprintw(tmp___16, tmp___15, "              |This program is free software. Can be licensed|");
#line 92
    tmp___17 = gx(0);
#line 92
    tmp___18 = gy(13);
#line 92
    mvprintw(tmp___18, tmp___17, "              |   under the terms of the GNU General Public  |");
#line 93
    tmp___19 = gx(0);
#line 93
    tmp___20 = gy(14);
#line 93
    mvprintw(tmp___20, tmp___19, "              |             License v2 or above.             |");
#line 94
    tmp___21 = gx(0);
#line 94
    tmp___22 = gy(15);
#line 94
    mvprintw(tmp___22, tmp___21, "              |----------------------------------------------|");
#line 95
    tmp___23 = gx(0);
#line 95
    tmp___24 = gy(16);
#line 95
    mvprintw(tmp___24, tmp___23, "              |                    Thanks                    |");
#line 96
    tmp___25 = gx(0);
#line 96
    tmp___26 = gy(17);
#line 96
    mvprintw(tmp___26, tmp___25, "              |                                              |");
#line 97
    tmp___27 = gx(0);
#line 97
    tmp___28 = gy(18);
#line 97
    mvprintw(tmp___28, tmp___27, "              |  Jochen Voss, Janos Lenart, Thimo Neubauer,  |");
#line 98
    tmp___29 = gx(0);
#line 98
    tmp___30 = gy(19);
#line 98
    mvprintw(tmp___30, tmp___29, "              |  Peter Risko, Linus Torvalds, debian people  |");
#line 99
    tmp___31 = gx(0);
#line 99
    tmp___32 = gy(20);
#line 99
    mvprintw(tmp___32, tmp___31, "              \\----------------------------------------------/");
#line 100
    flushinp();
#line 101
    wrefresh(stdscr);
#line 102
    select(1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 103
    l = wgetch(stdscr);
    }
#line 104
    if (l == 113) {
      {
#line 106
      closedsp();
#line 107
      exit(1);
      }
    }
#line 76
    if (! (l != 32)) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
int winlosewindow(struct struc_state *state___0 ) 
{ 
  int retval ;
  int getret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 116
  if (state___0->crashed) {
#line 116
    goto _L;
  } else
#line 116
  if (state___0->exit) {
    _L: /* CIL Label */ 
    {
#line 120
    gerase();
#line 121
    wrefresh(stdscr);
#line 122
    hof(state___0);
    }
#line 123
    if (! state___0->exit) {
      {
#line 125
      tmp = gx(25);
#line 125
      tmp___0 = gy(22);
#line 125
      mvprintw(tmp___0, tmp, "/-----------------------------\\");
#line 126
      tmp___1 = gx(25);
#line 126
      tmp___2 = gy(23);
#line 126
      mvprintw(tmp___2, tmp___1, "|      Try again?([y]/n)      |");
#line 127
      tmp___3 = gx(25);
#line 127
      tmp___4 = gy(24);
#line 127
      mvprintw(tmp___4, tmp___3, "\\-----------------------------/");
#line 128
      nodelay(stdscr, (_Bool)0);
      }
      {
#line 129
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 131
        getret = wgetch(stdscr);
        }
#line 129
        if (getret == 110) {
#line 129
          goto while_break;
        } else
#line 129
        if (getret == 78) {
#line 129
          goto while_break;
        } else
#line 129
        if (getret == 89) {
#line 129
          goto while_break;
        } else
#line 129
        if (getret == 121) {
#line 129
          goto while_break;
        } else
#line 129
        if (getret == 10) {
#line 129
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 133
      nodelay(stdscr, (_Bool)1);
      }
    } else {
      {
#line 137
      nodelay(stdscr, (_Bool)0);
#line 138
      tmp___5 = gx(35);
#line 138
      tmp___6 = gy(24);
#line 138
      mvprintw(tmp___6, tmp___5, "Any key to quit");
#line 139
      wgetch(stdscr);
#line 140
      getret = 'n';
      }
    }
#line 142
    if (getret == 110) {
#line 144
      retval = 0;
    } else
#line 142
    if (getret == 78) {
#line 144
      retval = 0;
    } else {
#line 148
      state___0->city = 1U;
#line 149
      state___0->score = 0;
#line 150
      state___0->delay = 120000U;
#line 151
      retval = 1;
    }
  } else {
    {
#line 156
    tmp___7 = gx(22);
#line 156
    tmp___8 = gy(10);
#line 156
    mvprintw(tmp___8, tmp___7, "/-----------------------------------\\");
#line 157
    tmp___9 = gx(22);
#line 157
    tmp___10 = gy(11);
#line 157
    mvprintw(tmp___10, tmp___9, "| You won! Press a key to continue! |");
#line 158
    tmp___11 = gx(22);
#line 158
    tmp___12 = gy(12);
#line 158
    mvprintw(tmp___12, tmp___11, "\\-----------------------------------/");
#line 159
    nodelay(stdscr, (_Bool)0);
#line 160
    wgetch(stdscr);
#line 161
    nodelay(stdscr, (_Bool)1);
#line 162
    (state___0->city) ++;
#line 163
    retval = 1;
    }
  }
#line 166
  return (retval);
}
}
#line 171 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
static char *ret  ;
#line 169 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
char *citycompute(unsigned char citynum ) 
{ 
  void *tmp ;

  {
  {
#line 173
  tmp = malloc((size_t )16);
#line 173
  ret = (char *)tmp;
  }
  {
#line 176
  if ((int )citynum == 1) {
#line 176
    goto case_1;
  }
#line 179
  if ((int )citynum == 2) {
#line 179
    goto case_2;
  }
#line 182
  if ((int )citynum == 3) {
#line 182
    goto case_3;
  }
#line 185
  if ((int )citynum == 4) {
#line 185
    goto case_4;
  }
#line 188
  if ((int )citynum == 5) {
#line 188
    goto case_5;
  }
#line 191
  if ((int )citynum == 6) {
#line 191
    goto case_6;
  }
#line 194
  if ((int )citynum == 7) {
#line 194
    goto case_7;
  }
#line 197
  if ((int )citynum == 8) {
#line 197
    goto case_8;
  }
#line 200
  if ((int )citynum == 9) {
#line 200
    goto case_9;
  }
#line 203
  if ((int )citynum == 10) {
#line 203
    goto case_10;
  }
#line 206
  if ((int )citynum == 11) {
#line 206
    goto case_11;
  }
#line 209
  goto switch_default;
  case_1: /* CIL Label */ 
#line 177
  ret = (char *)"Wien";
#line 178
  goto switch_break;
  case_2: /* CIL Label */ 
#line 180
  ret = (char *)"Lion";
#line 181
  goto switch_break;
  case_3: /* CIL Label */ 
#line 183
  ret = (char *)"Budapest";
#line 184
  goto switch_break;
  case_4: /* CIL Label */ 
#line 186
  ret = (char *)"London";
#line 187
  goto switch_break;
  case_5: /* CIL Label */ 
#line 189
  ret = (char *)"Paris";
#line 190
  goto switch_break;
  case_6: /* CIL Label */ 
#line 192
  ret = (char *)"Madrid";
#line 193
  goto switch_break;
  case_7: /* CIL Label */ 
#line 195
  ret = (char *)"Helsinki";
#line 196
  goto switch_break;
  case_8: /* CIL Label */ 
#line 198
  ret = (char *)"Chicago";
#line 199
  goto switch_break;
  case_9: /* CIL Label */ 
#line 201
  ret = (char *)"Las Vegas";
#line 202
  goto switch_break;
  case_10: /* CIL Label */ 
#line 204
  ret = (char *)"Washington";
#line 205
  goto switch_break;
  case_11: /* CIL Label */ 
#line 207
  ret = (char *)"New York";
#line 208
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 210
  free((void *)ret);
#line 211
  asprintf((char **/* __restrict  */)(& ret), (char const   */* __restrict  */)"Unnamed %d",
           (int )citynum);
  }
  switch_break: /* CIL Label */ ;
  }
#line 213
  return (ret);
}
}
#line 216 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/display.c"
void display_state(struct struc_state *state___0 , struct struc_texts *texts___0 ) 
{ 
  char *statusstr ;
  char earth[81] ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
  {
#line 222
  gerase();
  }
#line 223
  if (state___0->text) {
    {
#line 223
    tmp = gx(0);
#line 223
    tmp___0 = gy(24);
#line 223
    mvprintw(tmp___0, tmp, (char const   *)state___0->text);
    }
  }
  {
#line 224
  memset((void *)(earth), '=', (size_t )80);
#line 225
  earth[80] = (char)0;
#line 226
  tmp___1 = gx(0);
#line 226
  tmp___2 = gy(23);
#line 226
  mvprintw(tmp___2, tmp___1, (char const   *)(earth));
  }
#line 227
  if (state___0->willbebombed) {
#line 229
    if (((int )state___0->bomby - (int )state___0->line) - (int )state___0->x / 79 > 1) {
      {
#line 229
      tmp___3 = gx((int )state___0->bombx);
#line 229
      tmp___4 = gy((int )state___0->bomby - 2);
#line 229
      mvprintw(tmp___4, tmp___3, "_");
      }
    }
#line 230
    if (((int )state___0->bomby - (int )state___0->line) - (int )state___0->x / 79 > 0) {
      {
#line 230
      tmp___5 = gx((int )state___0->bombx);
#line 230
      tmp___6 = gy((int )state___0->bomby - 1);
#line 230
      mvprintw(tmp___6, tmp___5, "|");
      }
    }
    {
#line 231
    tmp___7 = gx((int )state___0->bombx);
#line 231
    tmp___8 = gy((int )state___0->bomby);
#line 231
    mvprintw(tmp___8, tmp___7, "W");
    }
  }
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < 80)) {
#line 233
      goto while_break;
    }
#line 235
    j = 1;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (j < (int )state___0->houses[i])) {
#line 235
        goto while_break___0;
      }
      {
#line 237
      tmp___9 = gx(i);
#line 237
      tmp___10 = gy((24 - j) - 1);
#line 237
      tmp___11 = wmove(stdscr, tmp___10, tmp___9);
      }
#line 237
      if (! (tmp___11 == -1)) {
        {
#line 237
        waddch(stdscr, (chtype const   )'#');
        }
      }
#line 235
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 239
    if (state___0->houses[i]) {
      {
#line 239
      tmp___12 = gx(i);
#line 239
      tmp___13 = gy((24 - j) - 1);
#line 239
      tmp___14 = wmove(stdscr, tmp___13, tmp___12);
      }
#line 239
      if (! (tmp___14 == -1)) {
        {
#line 239
        waddch(stdscr, (chtype const   )(j + 64));
        }
      }
    }
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  if (state___0->willbebombed) {
#line 241
    if ((int )state___0->bomby <= (int )state___0->line + 5) {
      {
#line 242
      tmp___15 = gx(((int )state___0->x + 1) % 80);
#line 242
      tmp___16 = gy((int )state___0->line + ((int )state___0->x + 1) / 80);
#line 242
      tmp___17 = wmove(stdscr, tmp___16, tmp___15);
      }
#line 242
      if (! (tmp___17 == -1)) {
        {
#line 242
        waddch(stdscr, (chtype const   )'v');
        }
      }
    } else {
#line 241
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 243
    tmp___18 = gx(((int )state___0->x + 1) % 80);
#line 243
    tmp___19 = gy((int )state___0->line + ((int )state___0->x + 1) / 80);
#line 243
    tmp___20 = wmove(stdscr, tmp___19, tmp___18);
    }
#line 243
    if (! (tmp___20 == -1)) {
      {
#line 243
      waddch(stdscr, (chtype const   )'-');
      }
    }
  }
  {
#line 244
  tmp___21 = gx(((int )state___0->x + 2) % 80);
#line 244
  tmp___22 = gy((int )state___0->line + ((int )state___0->x + 2) / 80);
#line 244
  tmp___23 = wmove(stdscr, tmp___22, tmp___21);
  }
#line 244
  if (! (tmp___23 == -1)) {
    {
#line 244
    waddch(stdscr, (chtype const   )'O');
    }
  }
  {
#line 247
  if ((int )state___0->x % 4 == 0) {
#line 247
    goto case_0;
  }
#line 250
  if ((int )state___0->x % 4 == 1) {
#line 250
    goto case_1;
  }
#line 253
  if ((int )state___0->x % 4 == 2) {
#line 253
    goto case_2;
  }
#line 256
  if ((int )state___0->x % 4 == 3) {
#line 256
    goto case_3;
  }
#line 245
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 248
  tmp___24 = gx((int )state___0->x);
#line 248
  tmp___25 = gy((int )state___0->line);
#line 248
  tmp___26 = wmove(stdscr, tmp___25, tmp___24);
  }
#line 248
  if (! (tmp___26 == -1)) {
    {
#line 248
    waddch(stdscr, (chtype const   )'-');
    }
  }
#line 249
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 251
  tmp___27 = gx((int )state___0->x);
#line 251
  tmp___28 = gy((int )state___0->line);
#line 251
  tmp___29 = wmove(stdscr, tmp___28, tmp___27);
  }
#line 251
  if (! (tmp___29 == -1)) {
    {
#line 251
    waddch(stdscr, (chtype const   )'\\');
    }
  }
#line 252
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 254
  tmp___30 = gx((int )state___0->x);
#line 254
  tmp___31 = gy((int )state___0->line);
#line 254
  tmp___32 = wmove(stdscr, tmp___31, tmp___30);
  }
#line 254
  if (! (tmp___32 == -1)) {
    {
#line 254
    waddch(stdscr, (chtype const   )'|');
    }
  }
#line 255
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 257
  tmp___33 = gx((int )state___0->x);
#line 257
  tmp___34 = gy((int )state___0->line);
#line 257
  tmp___35 = wmove(stdscr, tmp___34, tmp___33);
  }
#line 257
  if (! (tmp___35 == -1)) {
    {
#line 257
    waddch(stdscr, (chtype const   )'/');
    }
  }
#line 258
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 260
  tmp___36 = citycompute((unsigned char )state___0->city);
#line 260
  asprintf((char **/* __restrict  */)(& statusstr), (char const   */* __restrict  */)"Blocks: %.4d/%.4d, City: %15s (%.2d), Score: %7d",
           state___0->blocks, state___0->numofblocks, tmp___36, state___0->city, state___0->score);
#line 261
  tmp___37 = strlen((char const   *)statusstr);
#line 261
  tmp___38 = gx((int )(40UL - tmp___37 / 2UL));
#line 261
  tmp___39 = gy(23);
#line 261
  mvprintw(tmp___39, tmp___38, (char const   *)statusstr);
#line 262
  free((void *)statusstr);
#line 263
  wrefresh(stdscr);
  }
#line 264
  return;
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 12 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
void rh(unsigned int numofblocks , unsigned char min , unsigned char max , unsigned char *houses ,
        unsigned int *sum ) ;
#line 8 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/randomhouse.c"
void rh(unsigned int numofblocks , unsigned char min , unsigned char max , unsigned char *houses ,
        unsigned int *sum ) 
{ 
  int i ;
  int sum___0 ;
  int diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 12
  *sum = 0U;
#line 14
  if (numofblocks >= (unsigned int )((int )max * 80)) {
#line 16
    i = 0;
    {
#line 16
    while (1) {
      while_continue: /* CIL Label */ ;
#line 16
      if (! (i < 80)) {
#line 16
        goto while_break;
      }
#line 16
      *(houses + i) = max;
#line 16
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 18
  if (numofblocks <= (unsigned int )((int )min * 80)) {
#line 20
    i = 0;
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 20
      if (! (i < 80)) {
#line 20
        goto while_break___0;
      }
#line 20
      *(houses + i) = min;
#line 20
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 24
    sum___0 = 0;
#line 27
    i = 0;
    {
#line 27
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 27
      if (! (i < 80)) {
#line 27
        goto while_break___1;
      }
      {
#line 29
      tmp = rand();
#line 29
      *(houses + i) = (unsigned char )((int )min + (int )(((float )((int )max + 1) * (float )tmp) / ((float )2147483647 + (float )min)));
#line 30
      sum___0 += (int )*(houses + i);
#line 27
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 32
    diff = (int )((unsigned int )sum___0 - numofblocks);
    {
#line 33
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 33
      if (! (diff != 0)) {
#line 33
        goto while_break___2;
      }
      {
#line 35
      tmp___0 = rand();
#line 35
      i = (int )(((float )80 * (float )tmp___0) / (float )2147483647);
      }
#line 36
      if (diff < 0) {
#line 38
        if ((int )*(houses + i) < (int )max) {
#line 40
          *(houses + i) = (unsigned char )((int )*(houses + i) + 1);
#line 41
          diff ++;
        }
      } else
#line 46
      if ((int )*(houses + i) > (int )min) {
#line 48
        *(houses + i) = (unsigned char )((int )*(houses + i) - 1);
#line 49
        diff --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 54
    if (! (i < 80)) {
#line 54
      goto while_break___3;
    }
#line 54
    *sum += (unsigned int )*(houses + i);
#line 54
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 18 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
void resizehandler(int signum ) ;
#line 19
int initsignal(void) ;
#line 8 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/signal.c"
struct struc_state state ;
#line 10 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/signal.c"
void resizehandler(int signum ) 
{ 


  {
  {
#line 12
  state.shouldpause = 1;
#line 13
  endwin();
  }
#line 14
  return;
}
}
#line 16 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/signal.c"
int initsignal(void) 
{ 


  {
  {
#line 18
  signal(28, & resizehandler);
  }
#line 20
  return (1);
}
}
#line 23 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/signal.c"
void ungetchhandler(int signum ) 
{ 


  {
  {
#line 25
  endwin();
#line 26
  wrefresh(stdscr);
  }
#line 27
  return;
}
}
#line 29 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/signal.c"
int dropsignal(void) 
{ 


  {
  {
#line 31
  signal(28, & ungetchhandler);
  }
#line 33
  return (1);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 803 "/usr/include/curses.h"
extern int wclrtoeol(WINDOW * ) ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 9 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
void step_state_bomb(struct struc_state *state___0 , struct struc_texts *texts___0 ) ;
#line 10
void step_state_plane(struct struc_state *state___0 ) ;
#line 17
int seltext(int *houses_text , struct struc_texts *texts___0 , int houselen ) ;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/extern.h"
int maxx  ;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/extern.h"
int maxy  ;
#line 1 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/texts.h"
struct struc_texts texts[29]  = 
#line 1 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/texts.h"
  {      {(unsigned char)0, (unsigned char)0, (char *)"Here were the hans of aunt Mary."}, 
        {(unsigned char)0,
      (unsigned char)0, (char *)"Ouch! Lake Balaton!"}, 
        {(unsigned char)0, (unsigned char)0, (char *)"It was a dog, it\'s proprietor was a bitch."}, 
        {(unsigned char)0,
      (unsigned char)0, (char *)"Russian precision!"}, 
        {(unsigned char)0, (unsigned char)0, (char *)"Subway."}, 
        {(unsigned char)0, (unsigned char)0, (char *)"Submarines. Blugy."}, 
        {(unsigned char)0, (unsigned char)0, (char *)"Trafalgar square!!"}, 
        {(unsigned char)0, (unsigned char)0, (char *)"The \"server\" room in NJSZKI."}, 
        {(unsigned char)0,
      (unsigned char)0, (char *)"Segmentation fault"}, 
        {(unsigned char)0, (unsigned char)0, (char *)"Kernel panic!"}, 
        {(unsigned char)0, (unsigned char)0, (char *)"AN NT WORKSTATION!"}, 
        {(unsigned char)1, (unsigned char)1, (char *)"This was as high as your IQ."}, 
        {(unsigned char)1,
      (unsigned char)1, (char *)"This was the children garden."}, 
        {(unsigned char)1, (unsigned char)2, (char *)"This was a primary school."}, 
        {(unsigned char)1, (unsigned char)23, (char *)"Happy birthday!"}, 
        {(unsigned char)2, (unsigned char)2, (char *)"A little boy\'s house, who wanted to be the president of Micros*ft Inc."}, 
        {(unsigned char)2,
      (unsigned char)3, (char *)"This was the hospital of the city."}, 
        {(unsigned char)3, (unsigned char)3, (char *)"You hit the worst school in Budapest. Congratulations!"}, 
        {(unsigned char)3,
      (unsigned char)3, (char *)"They will be quiet."}, 
        {(unsigned char)3, (unsigned char)3, (char *)"The end of the traffic jam."}, 
        {(unsigned char)4, (unsigned char)4, (char *)"A manufacturer\'s office who didn\'t give documentation for him hardware."}, 
        {(unsigned char)4,
      (unsigned char)4, (char *)"Knock-knock... Please open the door!"}, 
        {(unsigned char)7, (unsigned char)7, (char *)"The number of the floors in this house was prime."}, 
        {(unsigned char)12,
      (unsigned char)15, (char *)"The value of this was $ 1000000, now it only costs 1000000 HUF."}, 
        {(unsigned char)13,
      (unsigned char)17, (char *)"Build cost was $ 10000000, demolish cost just was a button."}, 
        {(unsigned char)16,
      (unsigned char)16, (char *)"The residence of Bill Gates. Thank YOU!!"}, 
        {(unsigned char)18, (unsigned char)23, (char *)"Target destroyed."}, 
        {(unsigned char)17, (unsigned char)23, (char *)"Your ultimate bombing URL: http://www.atom.hu/~risko/bombardier"}, 
        {(unsigned char)22,
      (unsigned char)22, (char *)"WOW!"}};
#line 19 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/bombardier.c"
struct struc_state state  ;
#line 22 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/bombardier.c"
void init_state(struct struc_state *state___0 ) 
{ 
  int i ;

  {
#line 26
  i = 0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (i < 80)) {
#line 26
      goto while_break;
    }
#line 28
    state___0->houses_text[i] = -1;
#line 26
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 30
  rh((unsigned int )((int )((state___0->city * 400U) / (state___0->city + 1U)) + 500),
     (unsigned char)0, (unsigned char)20, (unsigned char *)(state___0->houses), & state___0->blocks);
#line 31
  state___0->numofblocks = state___0->blocks;
#line 32
  state___0->line = (unsigned char)0;
#line 33
  state___0->willbebombed = (unsigned char)0;
#line 34
  state___0->crashed = (unsigned char)0;
#line 35
  state___0->text = (char *)((void *)0);
  }
#line 36
  return;
}
}
#line 38 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/bombardier.c"
int seltext(int *houses_text , struct struc_texts *texts___0 , int houselen ) 
{ 
  int i ;
  int retval ;
  unsigned char busytexts[29] ;
  int randtexts[29] ;
  int howmany ;
  int sorsolt ;
  int tmp ;

  {
#line 40
  retval = -1;
#line 43
  howmany = 0;
#line 46
  i = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < 29)) {
#line 46
      goto while_break;
    }
#line 46
    busytexts[i] = (unsigned char)0;
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! (i < 80)) {
#line 47
      goto while_break___0;
    }
#line 47
    if (*(houses_text + i) != -1) {
#line 47
      busytexts[*(houses_text + i)] = (unsigned char)1;
    }
#line 47
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! (i < 29)) {
#line 48
      goto while_break___1;
    }
#line 50
    if ((int )(texts___0 + i)->minfloor <= houselen) {
#line 50
      if ((int )(texts___0 + i)->maxfloor >= houselen) {
#line 50
        if (! busytexts[i]) {
#line 53
          randtexts[howmany] = i;
#line 54
          howmany ++;
        }
      }
    }
#line 48
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 57
  if (howmany) {
    {
#line 59
    tmp = rand();
#line 59
    sorsolt = randtexts[(int )(((float )howmany * (float )tmp) / (float )2147483647)];
#line 60
    retval = sorsolt;
    }
  } else {
#line 64
    retval = -1;
  }
#line 66
  return (retval);
}
}
#line 69 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/bombardier.c"
void events(int getret , struct struc_state *state___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char speed ;

  {
#line 71
  if (getret == 32) {
#line 71
    if (! state___0->willbebombed) {
#line 71
      if ((int )state___0->line < 22) {
        {
#line 73
        (state___0->score) --;
#line 74
        state___0->willbebombed = (unsigned char)7;
#line 75
        state___0->bombx = (unsigned char )(((int )state___0->x + 1) % 80);
#line 76
        state___0->bomby = (unsigned char )((int )state___0->line + ((int )state___0->x + 1) / 80);
#line 77
        flushinp();
        }
      } else {
#line 71
        goto _L___2;
      }
    } else {
#line 71
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 79
  if (getret == 112) {
#line 79
    goto _L___0;
  } else
#line 79
  if (getret == 80) {
#line 79
    goto _L___0;
  } else
#line 79
  if (state___0->shouldpause) {
    _L___0: /* CIL Label */ 
#line 81
    if (state___0->shouldpause) {
      {
#line 83
      nodelay(stdscr, (_Bool)0);
#line 84
      resizedsp(0);
#line 85
      nodelay(stdscr, (_Bool)1);
      }
    }
    {
#line 87
    display_state(state___0, texts);
#line 88
    tmp = gx(0);
#line 88
    tmp___0 = gy(23);
#line 88
    mvprintw(tmp___0, tmp, "PAUSED! Any key to continue!");
#line 88
    wclrtoeol(stdscr);
#line 89
    wrefresh(stdscr);
#line 90
    initsignal();
#line 91
    nodelay(stdscr, (_Bool)0);
#line 92
    wgetch(stdscr);
#line 93
    nodelay(stdscr, (_Bool)1);
#line 94
    state___0->shouldpause = 0;
    }
  } else
#line 96
  if (getret == 113) {
#line 96
    goto _L;
  } else
#line 96
  if (getret == 81) {
    _L: /* CIL Label */ 
    {
#line 98
    nodelay(stdscr, (_Bool)0);
#line 99
    tmp___1 = gx(0);
#line 99
    tmp___2 = gy(23);
#line 99
    mvprintw(tmp___2, tmp___1, "If you really want to quit, press \'q\' once again! Another key will continue!");
#line 99
    wclrtoeol(stdscr);
#line 100
    getret = wgetch(stdscr);
#line 101
    nodelay(stdscr, (_Bool)1);
    }
#line 102
    if (getret == 113) {
#line 102
      state___0->exit = (unsigned char)1;
    } else
#line 102
    if (getret == 81) {
#line 102
      state___0->exit = (unsigned char)1;
    }
  } else
#line 104
  if (getret >= 49) {
#line 104
    if (getret <= 57) {
#line 108
      speed = (unsigned char )(getret - 48);
#line 109
      state___0->delay = (unsigned int )(120000 / (int )speed);
    }
  }
#line 111
  return;
}
}
#line 113 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/bombardier.c"
int main(void) 
{ 
  struct timeval tv ;
  struct timeval ue ;
  struct timeval uu ;
  struct timeval forbomb ;
  unsigned char k ;
  int getret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 118
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 119
  srand((unsigned int )(tv.tv_sec * tv.tv_usec));
#line 120
  state.score = 0;
#line 121
  state.delay = 120000U;
#line 122
  state.exit = (unsigned char)0;
#line 123
  state.city = 1U;
#line 124
  state.text = (char *)((void *)0);
#line 125
  state.shouldpause = 0;
#line 126
  tmp___0 = initdsp();
  }
#line 126
  if (tmp___0) {
    {
#line 133
    welcomescreen();
#line 134
    initsignal();
    }
    {
#line 135
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! state.text) {
        {
#line 139
        free((void *)state.text);
#line 139
        state.text = (char *)((void *)0);
        }
      }
      {
#line 141
      init_state(& state);
      }
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 142
        if (! state.crashed) {
#line 142
          if ((int )state.line < 22) {
#line 142
            goto _L___0;
          } else
#line 142
          if (state.blocks) {
            _L___0: /* CIL Label */ 
#line 142
            if (! (! state.exit)) {
#line 142
              goto while_break___0;
            }
          } else {
#line 142
            goto while_break___0;
          }
        } else {
#line 142
          goto while_break___0;
        }
#line 144
        k = (unsigned char)1;
#line 146
        state.x = (unsigned char)0;
        {
#line 147
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 147
          if ((int )state.x < 80) {
#line 147
            if ((int )state.line < 22) {
#line 147
              goto _L;
            } else
#line 147
            if (state.blocks) {
              _L: /* CIL Label */ 
#line 147
              if (! state.crashed) {
#line 147
                if (! (! state.exit)) {
#line 147
                  goto while_break___1;
                }
              } else {
#line 147
                goto while_break___1;
              }
            } else {
#line 147
              goto while_break___1;
            }
          } else {
#line 147
            goto while_break___1;
          }
          {
#line 151
          getret = wgetch(stdscr);
          }
#line 152
          if (getret != -1) {
            {
#line 152
            events(getret, & state);
            }
          }
          {
#line 153
          gettimeofday((struct timeval */* __restrict  */)(& state.tvusleeputan),
                       (__timezone_ptr_t )((void *)0));
#line 154
          step_state_plane(& state);
          }
#line 155
          if (state.willbebombed) {
            {
#line 157
            gettimeofday((struct timeval */* __restrict  */)(& forbomb), (__timezone_ptr_t )((void *)0));
#line 158
            forbomb.tv_usec += 1000000L * (forbomb.tv_sec - state.tvusleeputan.tv_sec);
#line 159
            k = (unsigned char)0;
            }
            {
#line 159
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 159
              if ((int )k < 2) {
#line 159
                if (! state.willbebombed) {
#line 159
                  goto while_break___2;
                }
              } else {
#line 159
                goto while_break___2;
              }
              {
#line 161
              step_state_bomb(& state, texts);
#line 162
              display_state(& state, texts);
#line 163
              state.bombsleep = (((__suseconds_t )state.delay - (forbomb.tv_usec - state.tvusleeputan.tv_usec)) / 2L) / 2L;
#line 164
              wrefresh(stdscr);
              }
#line 165
              if (state.bombsleep > 20000L) {
                {
#line 167
                usleep((__useconds_t )state.bombsleep);
                }
              }
#line 159
              k = (unsigned char )((int )k + 1);
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 172
            display_state(& state, texts);
            }
          }
          {
#line 173
          gettimeofday((struct timeval */* __restrict  */)(& state.szamolashoz), (__timezone_ptr_t )((void *)0));
#line 174
          state.szamolashoz.tv_usec += 1000000L * (state.szamolashoz.tv_sec - state.tvusleeputan.tv_sec);
#line 175
          state.usleepelni += (__suseconds_t )state.delay - (state.szamolashoz.tv_usec - state.tvusleeputan.tv_usec);
          }
#line 176
          if (state.usleepelni > 0L) {
            {
#line 178
            gettimeofday((struct timeval */* __restrict  */)(& ue), (__timezone_ptr_t )((void *)0));
#line 179
            usleep((__useconds_t )state.usleepelni);
#line 180
            gettimeofday((struct timeval */* __restrict  */)(& uu), (__timezone_ptr_t )((void *)0));
#line 181
            state.usleepelni -= (uu.tv_sec - ue.tv_sec) * 1000000L + (uu.tv_usec - ue.tv_usec);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 184
        state.line = (unsigned char )((int )state.line + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 186
      if (! state.crashed) {
#line 186
        if (! state.exit) {
#line 188
          state.line = (unsigned char)22;
#line 189
          state.text = (char *)"THE LANDING WAS SUCCESSFULL!!! CONGRATULATIONS!";
          {
#line 190
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 190
            if (! ((int )state.x < 78)) {
#line 190
              goto while_break___3;
            }
            {
#line 192
            display_state(& state, texts);
#line 193
            usleep(state.delay);
#line 190
            state.x = (unsigned char )((int )state.x + 1);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 195
          flushinp();
          }
        }
      }
      {
#line 135
      tmp = winlosewindow(& state);
      }
#line 135
      if (! tmp) {
#line 135
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 198
    closedsp();
    }
  } else {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The initialization of display was unsuccessfull! Exiting!\n");
    }
#line 129
    return (1);
  }
#line 201
  return (0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 14 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/date.c"
static char *retstr  ;
#line 10 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/date.c"
char *ascdate(void) 
{ 
  time_t timet ;
  struct tm *tm ;
  void *tmp ;

  {
  {
#line 16
  tmp = malloc((size_t )11);
#line 16
  retstr = (char *)tmp;
#line 17
  timet = time((time_t *)((void *)0));
#line 18
  tm = localtime((time_t const   *)(& timet));
#line 19
  sprintf((char */* __restrict  */)retstr, (char const   */* __restrict  */)"%4d-%.2d-%.2d",
          tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday);
  }
#line 21
  return (retstr);
}
}
#line 8 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/step.c"
void step_state_plane(struct struc_state *state___0 ) 
{ 


  {
#line 10
  if ((23 - ((int )state___0->x + 2) / 80) - (int )state___0->houses[((int )state___0->x + 2) % 80] == (int )state___0->line) {
#line 11
    state___0->crashed = (unsigned char)1;
  } else {
#line 14
    state___0->x = (unsigned char )((int )state___0->x + 1);
#line 15
    if ((int )state___0->x < 77) {
#line 15
      if (state___0->blocks == 0U) {
#line 15
        if ((int )state___0->line < 22) {
#line 15
          if ((int )state___0->x % 3 == 0) {
#line 16
            state___0->line = (unsigned char )((int )state___0->line + 1);
          }
        }
      }
    }
#line 17
    if ((int )state___0->line == 23) {
#line 17
      if ((int )state___0->x == 77) {
#line 18
        state___0->x = (unsigned char)80;
      }
    }
  }
#line 20
  return;
}
}
#line 22 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/step.c"
void step_state_bomb(struct struc_state *state___0 , struct struc_texts *texts___0 ) 
{ 


  {
#line 24
  if (state___0->willbebombed) {
#line 26
    state___0->bomby = (unsigned char )((int )state___0->bomby + 1);
#line 27
    if ((int )state___0->bomby > 22) {
#line 28
      state___0->willbebombed = (unsigned char)0;
    } else
#line 29
    if (23 - (int )state___0->houses[state___0->bombx] == (int )state___0->bomby) {
#line 31
      if (state___0->houses_text[state___0->bombx] == -1) {
        {
#line 32
        state___0->houses_text[state___0->bombx] = seltext((int *)(state___0->houses_text),
                                                           texts___0, (int )state___0->houses[state___0->bombx]);
        }
      }
#line 33
      if (! state___0->text) {
        {
#line 35
        free((void *)state___0->text);
#line 36
        state___0->text = (char *)((void *)0);
        }
      }
#line 38
      if (state___0->houses_text[state___0->bombx] != -1) {
        {
#line 39
        asprintf((char **/* __restrict  */)(& state___0->text), (char const   */* __restrict  */)(texts___0 + state___0->houses_text[state___0->bombx])->text);
        }
      }
#line 40
      state___0->houses[state___0->bombx] = (unsigned char )((int )state___0->houses[state___0->bombx] - 1);
#line 41
      (state___0->blocks) --;
#line 42
      state___0->willbebombed = (unsigned char )((int )state___0->willbebombed - 1);
#line 43
      if ((int )state___0->willbebombed == 0) {
#line 43
        state___0->houses_text[state___0->bombx] = -1;
      }
#line 44
      (state___0->score) ++;
    }
  }
#line 47
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 603 "/usr/include/curses.h"
extern int delwin(WINDOW * ) ;
#line 605
extern WINDOW *derwin(WINDOW * , int  , int  , int  , int  ) ;
#line 608
extern int echo(void) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 956
extern int fsync(int __fd ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 15 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/funcs.h"
char *printhof(char (*names)[21] , char (*dates)[11] , int *scores , unsigned char numoffame ,
               unsigned char nowres , int score ) ;
#line 6 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/fdgetline.c"
char *fdgetline(int fd ) 
{ 
  char *newline ;
  char buf[1] ;
  int i ;
  int eol ;
  void *tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;

  {
#line 8
  newline = (char *)((void *)0);
#line 10
  i = 0;
#line 11
  eol = 0;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! eol) {
      {
#line 13
      tmp___0 = read(fd, (void *)(buf), (size_t )1);
      }
#line 13
      if (! (tmp___0 == 1L)) {
#line 13
        goto while_break;
      }
    } else {
#line 13
      goto while_break;
    }
    {
#line 15
    i ++;
#line 15
    tmp = realloc((void *)newline, (size_t )i);
#line 15
    newline = (char *)tmp;
#line 16
    *(newline + (i - 1)) = buf[0];
    }
#line 17
    if ((int )*(newline + (i - 1)) == 10) {
#line 19
      *(newline + (i - 1)) = (char)0;
#line 20
      eol = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  if (newline) {
#line 23
    if ((int )*(newline + (i - 1)) != 0) {
      {
#line 25
      i ++;
#line 25
      tmp___1 = realloc((void *)newline, (size_t )i);
#line 25
      newline = (char *)tmp___1;
#line 26
      *(newline + (i - 1)) = (char)0;
      }
    }
  }
#line 28
  return (newline);
}
}
#line 14 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/hof.c"
static char *name  ;
#line 10 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/hof.c"
char *printhof(char (*names)[21] , char (*dates)[11] , int *scores , unsigned char numoffame ,
               unsigned char nowres , int score ) 
{ 
  unsigned char i ;
  WINDOW *act ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 16
  name = (char *)((void *)0);
#line 17
  tmp = gx(0);
#line 17
  tmp___0 = gy(0);
#line 17
  mvprintw(tmp___0, tmp, "Your score is: %7d\n", score);
#line 18
  tmp___1 = gx(15);
#line 18
  tmp___2 = gy(5);
#line 18
  mvprintw(tmp___2, tmp___1, "/----------------- HALL OF FAME -------------------\\");
#line 19
  i = (unsigned char)0;
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! ((int )i < (int )numoffame)) {
#line 19
      goto while_break;
    }
    {
#line 20
    tmp___3 = gx(15);
#line 20
    tmp___4 = gy((int )i + 6);
#line 20
    mvprintw(tmp___4, tmp___3, "| %d. | %-20s | %10s | %7d |", (int )i + 1, *(names + i),
             *(dates + i), *(scores + i));
#line 19
    i = (unsigned char )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 21
  tmp___5 = gx(15);
#line 21
  tmp___6 = gy((int )i + 6);
#line 21
  mvprintw(tmp___6, tmp___5, "\\--------------------------------------------------/");
#line 22
  fillspace();
  }
#line 23
  if (nowres) {
    {
#line 25
    tmp___7 = malloc((size_t )21);
#line 25
    name = (char *)tmp___7;
#line 26
    tmp___8 = gx(22);
#line 26
    tmp___9 = gy((int )nowres + 5);
#line 26
    act = derwin(stdscr, 1, 20, tmp___9, tmp___8);
#line 27
    wclrtoeol(act);
#line 28
    fillspace();
#line 29
    wrefresh(stdscr);
#line 30
    echo();
#line 31
    curs_set(1);
#line 32
    wgetnstr(act, name, 20);
#line 33
    curs_set(0);
#line 34
    noecho();
#line 35
    delwin(act);
    }
  }
#line 37
  if (! name) {
#line 38
    return ((char *)"Someone");
  } else {
    {
#line 37
    tmp___10 = strlen((char const   *)name);
    }
#line 37
    if (tmp___10 == 0UL) {
#line 38
      return ((char *)"Someone");
    }
  }
#line 39
  return (name);
}
}
#line 42 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/hof.c"
void defhof(int fd ) 
{ 


  {
  {
#line 44
  write(fd, (void const   *)"Teller Ede          |1908-01-15|  16384\n", (size_t )40);
#line 45
  write(fd, (void const   *)"Szil\341rd Le\363         |1898-02-11|   8192\n", (size_t )40);
#line 46
  write(fd, (void const   *)"Neumann J\341nos       |1903-12-28|   4096\n", (size_t )40);
#line 47
  write(fd, (void const   *)"G\341bor D\351nes         |1900-06-05|   2048\n", (size_t )40);
#line 48
  write(fd, (void const   *)"Bolyai J\341nos        |1802-12-15|   1024\n", (size_t )40);
#line 49
  write(fd, (void const   *)"E\366tv\366s Lor\341nd       |1848-07-27|    512\n",
        (size_t )40);
#line 50
  write(fd, (void const   *)"Horthy Mikl\363s       |1800-00-00|    256\n", (size_t )40);
#line 51
  write(fd, (void const   *)"K\341d\341r J\341nos         |1800-00-00|    128\n",
        (size_t )40);
#line 52
  write(fd, (void const   *)"R\341kosi M\341ty\341s       |1892-00-00|     64\n",
        (size_t )40);
  }
#line 53
  return;
}
}
#line 55 "/home/june/collector/temp/bombardier-0.8.3+nmu1ubuntu1/hof.c"
void hof(struct struc_state *state___0 ) 
{ 
  int fd ;
  struct flock lock ;
  char names[9][21] ;
  char dates[9][11] ;
  int scores[9] ;
  char *line ;
  unsigned char numoffame ;
  unsigned char shift ;
  unsigned char nowres ;
  unsigned char i ;
  char *tmp ;
  char *tmp___0 ;
  char linewrite[40] ;
  char *tmp___1 ;
  char linewrite___0[40] ;
  int tmp___2 ;

  {
  {
#line 62
  numoffame = (unsigned char)0;
#line 63
  shift = (unsigned char)0;
#line 64
  nowres = (unsigned char)0;
#line 66
  fd = open("/var/games/bombardier/bdscore", 2);
  }
#line 67
  if (fd < 0) {
    {
#line 69
    fd = open("/var/games/bombardier/bdscore", 66, ((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3));
    }
#line 70
    if (fd > 0) {
      {
#line 72
      defhof(fd);
#line 73
      close(fd);
      }
    }
  }
  {
#line 76
  fd = open("/var/games/bombardier/bdscore", 2);
  }
#line 77
  if (fd > 0) {
    {
#line 79
    wrefresh(stdscr);
#line 80
    lock.l_type = (short)1;
#line 81
    lock.l_whence = (short)0;
#line 82
    lock.l_start = (__off_t )0;
#line 83
    lock.l_len = (__off_t )0;
#line 84
    lock.l_pid = getpid();
#line 85
    tmp___2 = fcntl(fd, 7, & lock);
    }
#line 85
    if (tmp___2 != -1) {
      {
#line 89
      wrefresh(stdscr);
#line 90
      line = fdgetline(fd);
      }
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
#line 91
        if (line) {
#line 91
          if (! ((int )numoffame + (int )shift < 9)) {
#line 91
            goto while_break;
          }
        } else {
#line 91
          goto while_break;
        }
        {
#line 93
        gerase();
#line 94
        strncpy((char */* __restrict  */)(names[(int )numoffame + (int )shift]), (char const   */* __restrict  */)line,
                (size_t )20);
#line 95
        strncpy((char */* __restrict  */)(dates[(int )numoffame + (int )shift]), (char const   */* __restrict  */)(line + 21),
                (size_t )10);
#line 96
        names[(int )numoffame + (int )shift][20] = (char)0;
#line 97
        dates[(int )numoffame + (int )shift][10] = (char)0;
#line 98
        sscanf((char const   */* __restrict  */)(line + 32), (char const   */* __restrict  */)"%d",
               & scores[(int )numoffame + (int )shift]);
        }
#line 99
        if (! shift) {
#line 99
          if (scores[numoffame] < state___0->score) {
#line 101
            if ((int )numoffame < 8) {
              {
#line 103
              strcpy((char */* __restrict  */)(names[(int )numoffame + 1]), (char const   */* __restrict  */)(names[numoffame]));
#line 104
              strcpy((char */* __restrict  */)(dates[(int )numoffame + 1]), (char const   */* __restrict  */)(dates[numoffame]));
#line 105
              scores[(int )numoffame + 1] = scores[numoffame];
#line 106
              shift = (unsigned char)1;
              }
            }
            {
#line 108
            scores[numoffame] = state___0->score;
#line 109
            tmp = ascdate();
#line 109
            strcpy((char */* __restrict  */)(dates[numoffame]), (char const   */* __restrict  */)tmp);
#line 110
            strcpy((char */* __restrict  */)(names[numoffame]), (char const   */* __restrict  */)"Someone");
#line 111
            nowres = (unsigned char )((int )numoffame + 1);
            }
          }
        }
        {
#line 113
        numoffame = (unsigned char )((int )numoffame + 1);
#line 114
        free((void *)line);
#line 115
        line = fdgetline(fd);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 117
      numoffame = (unsigned char )((int )numoffame + (int )shift);
#line 118
      if (! shift) {
#line 118
        if ((int )numoffame < 9) {
          {
#line 120
          scores[numoffame] = state___0->score;
#line 121
          tmp___0 = ascdate();
#line 121
          strcpy((char */* __restrict  */)(dates[numoffame]), (char const   */* __restrict  */)tmp___0);
#line 122
          strcpy((char */* __restrict  */)(names[numoffame]), (char const   */* __restrict  */)"Someone");
#line 123
          numoffame = (unsigned char )((int )numoffame + 1);
#line 123
          nowres = numoffame;
          }
        }
      }
#line 125
      if (nowres) {
        {
#line 129
        lseek(fd, (__off_t )0, 0);
#line 130
        i = (unsigned char)0;
        }
        {
#line 130
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 130
          if (! ((int )i < (int )numoffame)) {
#line 130
            goto while_break___0;
          }
          {
#line 134
          sprintf((char */* __restrict  */)(linewrite), (char const   */* __restrict  */)"%-20s|%10s|%7d",
                  names[i], dates[i], scores[i]);
#line 135
          linewrite[39] = (char)10;
#line 136
          write(fd, (void const   *)(linewrite), (size_t )40);
#line 130
          i = (unsigned char )((int )i + 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 138
        lseek(fd, (__off_t )0, 0);
#line 139
        fsync(fd);
#line 140
        tmp___1 = printhof((char (*)[21])(names), (char (*)[11])(dates), (int *)(scores),
                           numoffame, nowres, state___0->score);
#line 140
        strcpy((char */* __restrict  */)(names[(int )nowres - 1]), (char const   */* __restrict  */)tmp___1);
#line 142
        i = (unsigned char)0;
        }
        {
#line 142
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 142
          if (! ((int )i < (int )numoffame)) {
#line 142
            goto while_break___1;
          }
          {
#line 146
          sprintf((char */* __restrict  */)(linewrite___0), (char const   */* __restrict  */)"%-20s|%10s|%7d",
                  names[i], dates[i], scores[i]);
#line 147
          linewrite___0[39] = (char)10;
#line 148
          write(fd, (void const   *)(linewrite___0), (size_t )40);
#line 142
          i = (unsigned char )((int )i + 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 150
        lock.l_type = (short)2;
#line 151
        fcntl(fd, 7, & lock);
#line 152
        close(fd);
        }
      } else {
        {
#line 156
        lock.l_type = (short)2;
#line 157
        fcntl(fd, 7, & lock);
#line 158
        close(fd);
#line 159
        printhof((char (*)[21])(names), (char (*)[11])(dates), (int *)(scores), numoffame,
                 nowres, state___0->score);
        }
      }
    } else {
      {
#line 164
      close(fd);
      }
    }
  }
#line 167
  return;
}
}
