/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
struct bitmask {
   unsigned long size ;
   unsigned long *maskp ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
struct policy {
   char *name ;
   int policy ;
   int noarg ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 99 "/usr/include/linux/netlink.h"
struct nlmsgerr {
   int error ;
   struct nlmsghdr msg ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_57 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_57 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 40 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
struct __anonstruct_nodemask_t_32 {
   unsigned long n[128UL / (sizeof(unsigned long ) * 8UL)] ;
};
#line 40 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
typedef struct __anonstruct_nodemask_t_32 nodemask_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_43 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_44 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_43 ifr_ifrn ;
   union __anonunion_ifr_ifru_44 ifr_ifru ;
};
#line 175 "/usr/include/linux/rtnetlink.h"
struct rtmsg {
   unsigned char rtm_family ;
   unsigned char rtm_dst_len ;
   unsigned char rtm_src_len ;
   unsigned char rtm_tos ;
   unsigned char rtm_table ;
   unsigned char rtm_protocol ;
   unsigned char rtm_scope ;
   unsigned char rtm_type ;
   unsigned int rtm_flags ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_86 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_86 regmatch_t;
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct handler {
   char first ;
   char *name ;
   char *cls ;
   int (*handler)(struct bitmask *mask , char *cls , char const   *desc ) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 40 "/usr/include/stdint.h"
typedef long int64_t;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
struct meminfo {
   int index ;
   char *token ;
   char *label ;
};
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct meminfo meminfo_t;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct meminfo *meminfo_p;
#line 152 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
struct hash_entry {
   char *name ;
   int index ;
};
#line 236 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
union __anonunion____missing_field_name_30 {
   char *s ;
   double d ;
   int64_t l ;
   char c[8] ;
};
#line 236 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
struct cell {
   uint32_t type ;
   uint32_t flags ;
   union __anonunion____missing_field_name_30 __annonCompField1 ;
};
#line 236 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct cell cell_t;
#line 236 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct cell *cell_p;
#line 247 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
struct vtab {
   int header_rows ;
   int header_cols ;
   int data_rows ;
   int data_cols ;
   cell_p cell ;
   int *row_ix_map ;
   uint8_t *row_flags ;
   uint8_t *col_flags ;
   uint8_t *col_width ;
   uint8_t *col_decimal_places ;
};
#line 247 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct vtab vtab_t;
#line 247 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
typedef struct vtab *vtab_p;
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___0 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___1 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___2 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___3 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___4 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___5 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___6 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___7 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___8 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___9 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___10 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_15 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_16 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_15 __wait_terminated ;
   struct __anonstruct___wait_stopped_16 __wait_stopped ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___11 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___12 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___13 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___14 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___15 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___16 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 49 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
enum test {
    MEMSET = 0,
    MEMCPY = 1,
    FORWARD = 2,
    BACKWARD = 3,
    STREAM = 4,
    RANDOM2 = 5,
    PTRCHASE = 6
} ;
#line 111 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
struct __anonstruct____missing_field_name_29 {
   unsigned int nexti ;
   unsigned int val ;
};
#line 111 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
union node {
   union node *next ;
   struct __anonstruct____missing_field_name_29 __annonCompField1 ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___17 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___18 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 194 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
struct __anonstruct_req_89___19 {
   struct nlmsghdr msg ;
   struct rtmsg rt ;
   char buf[256] ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
int numa_bitmask_isbitset(struct bitmask  const  *bmp , unsigned int i ) ;
#line 1 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.h"
void printmask(char *name , struct bitmask *mask ) ;
#line 2
void printcpumask(char *name , struct bitmask *mask ) ;
#line 6
void complain(char *fmt  , ...) ;
#line 7
void nerror(char *fmt  , ...) ;
#line 10
void usage(void) ;
#line 12
long memsize(char *s ) ;
#line 13
int parse_policy(char *name , char *arg ) ;
#line 14
void print_policies(void) ;
#line 15
char *policy_name(int policy___0 ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 28 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
void printmask(char *name , struct bitmask *mask ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 32
  printf((char const   */* __restrict  */)"%s: ", name);
#line 33
  i = 0;
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ((unsigned long )i <= mask->size)) {
#line 33
      goto while_break;
    }
    {
#line 34
    tmp = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i);
    }
#line 34
    if (tmp) {
      {
#line 35
      printf((char const   */* __restrict  */)"%d ", i);
      }
    }
#line 33
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  putchar('\n');
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
void printcpumask(char *name , struct bitmask *mask ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 42
  printf((char const   */* __restrict  */)"%s: ", name);
#line 43
  i = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! ((unsigned long )i < mask->size)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i);
    }
#line 44
    if (tmp) {
      {
#line 45
      printf((char const   */* __restrict  */)"%d ", i);
      }
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  putchar('\n');
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
void complain(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 53
  __builtin_va_start(ap, fmt);
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: ");
#line 55
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 56
  putchar('\n');
#line 57
  __builtin_va_end(ap);
#line 58
  exit(1);
  }
}
}
#line 61 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
void nerror(char *fmt  , ...) 
{ 
  int err ;
  int *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
  {
#line 63
  tmp = __errno_location();
#line 63
  err = *tmp;
#line 65
  __builtin_va_start(ap, fmt);
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: ");
#line 67
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 68
  __builtin_va_end(ap);
  }
#line 69
  if (err) {
    {
#line 70
    tmp___0 = strerror(err);
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
            tmp___0);
    }
  } else {
    {
#line 72
    fputc('\n', stderr);
    }
  }
  {
#line 73
  exit(1);
  }
}
}
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
long memsize(char *s ) 
{ 
  char *end___0 ;
  long length___0 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 79
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                0);
#line 79
  length___0 = (long )tmp;
#line 80
  tmp___0 = toupper((int )*end___0);
  }
  {
#line 81
  if (tmp___0 == 71) {
#line 81
    goto case_71;
  }
#line 82
  if (tmp___0 == 77) {
#line 82
    goto case_77;
  }
#line 83
  if (tmp___0 == 75) {
#line 83
    goto case_75;
  }
#line 80
  goto switch_break;
  case_71: /* CIL Label */ 
#line 81
  length___0 *= 1024L;
  case_77: /* CIL Label */ 
#line 82
  length___0 *= 1024L;
  case_75: /* CIL Label */ 
#line 83
  length___0 *= 1024L;
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  return (length___0);
}
}
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf[32]  ;
#line 103 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
char *policy_name(int policy___0 ) 
{ 


  {
#line 106
  if ((unsigned long )policy___0 >= sizeof(policy_names) / sizeof(policy_names[0])) {
    {
#line 107
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"[%d]",
            policy___0);
    }
#line 108
    return (buf);
  }
#line 110
  return (policy_names[policy___0]);
}
}
#line 113 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
int parse_policy(char *name , char *arg ) 
{ 
  int k ;
  struct policy *p ;
  int tmp ;

  {
#line 116
  p = (struct policy *)((void *)0);
#line 117
  if (! name) {
#line 118
    return (0);
  }
#line 119
  k = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! policies[k].name) {
#line 119
      goto while_break;
    }
    {
#line 120
    p = & policies[k];
#line 121
    tmp = strcmp((char const   *)p->name, (char const   *)name);
    }
#line 121
    if (! tmp) {
#line 122
      goto while_break;
    }
#line 119
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (! p) {
    {
#line 125
    usage();
    }
  } else
#line 124
  if (! p->name) {
    {
#line 125
    usage();
    }
  } else
#line 124
  if (! arg) {
#line 124
    if (! p->noarg) {
      {
#line 125
      usage();
      }
    }
  }
#line 126
  return (p->policy);
}
}
#line 129 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
void print_policies(void) 
{ 
  int i ;

  {
  {
#line 132
  printf((char const   */* __restrict  */)"Policies:");
#line 133
  i = 0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! policies[i].name) {
#line 133
      goto while_break;
    }
    {
#line 134
    printf((char const   */* __restrict  */)" %s", policies[i].name);
#line 133
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  printf((char const   */* __restrict  */)"\n");
  }
#line 136
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 1 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/rtnetlink.h"
int __attribute__((__visibility__("hidden")))  rta_put_address(struct nlmsghdr *msg ,
                                                               int type , struct sockaddr *adr ) ;
#line 3
struct rtattr  __attribute__((__visibility__("hidden"))) *rta_get(struct nlmsghdr *m ,
                                                                  struct rtattr *p ,
                                                                  int offset ) ;
#line 4
void __attribute__((__visibility__("hidden")))  *rta_put(struct nlmsghdr *m , int type ,
                                                         int len ) ;
#line 5
int __attribute__((__visibility__("hidden")))  rtnetlink_request(struct nlmsghdr *msg ,
                                                                 int buflen , struct sockaddr_nl *adr ) ;
#line 12 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/rtnetlink.c"
void __attribute__((__visibility__("hidden")))  *rta_put(struct nlmsghdr *m , int type ,
                                                         int len ) 
{ 
  struct rtattr *rta ;
  int rtalen ;

  {
#line 14
  rta = (struct rtattr *)((void *)m + (((m->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 15
  rtalen = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + (unsigned long )len);
#line 17
  rta->rta_type = (unsigned short )type;
#line 18
  rta->rta_len = (unsigned short )rtalen;
#line 19
  m->nlmsg_len = (((m->nlmsg_len + 4U) - 1U) & 4294967292U) + (unsigned int )(((rtalen + 4) - 1) & -4);
#line 20
  return ((void __attribute__((__visibility__("hidden")))  *)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
}
}
#line 23 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/rtnetlink.c"
struct rtattr  __attribute__((__visibility__("hidden"))) *rta_get(struct nlmsghdr *m ,
                                                                  struct rtattr *p ,
                                                                  int offset ) 
{ 
  struct rtattr *rta ;

  {
#line 27
  if (p) {
#line 28
    m->nlmsg_len -= (__u32 )((((int )p->rta_len + 4) - 1) & -4);
#line 28
    rta = (struct rtattr *)((char *)p + ((((int )p->rta_len + 4) - 1) & -4));
#line 29
    if (m->nlmsg_len >= (__u32 )((int )sizeof(struct rtattr ))) {
#line 29
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 29
        if (! ((__u32 )rta->rta_len <= m->nlmsg_len)) {
#line 30
          return ((struct rtattr  __attribute__((__visibility__("hidden"))) *)((void *)0));
        }
      } else {
#line 30
        return ((struct rtattr  __attribute__((__visibility__("hidden"))) *)((void *)0));
      }
    } else {
#line 30
      return ((struct rtattr  __attribute__((__visibility__("hidden"))) *)((void *)0));
    }
  } else {
#line 32
    rta = (struct rtattr *)((void *)m + ((((unsigned int )offset + 4U) - 1U) & 4294967292U));
  }
#line 34
  return ((struct rtattr  __attribute__((__visibility__("hidden"))) *)rta);
}
}
#line 37 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/rtnetlink.c"
int __attribute__((__visibility__("hidden")))  rta_put_address(struct nlmsghdr *msg ,
                                                               int type , struct sockaddr *adr ) 
{ 
  struct in_addr *i ;
  void __attribute__((__visibility__("hidden")))  *tmp ;
  struct in6_addr *i6 ;
  void __attribute__((__visibility__("hidden")))  *tmp___0 ;

  {
  {
#line 41
  if ((int )adr->sa_family == 2) {
#line 41
    goto case_2;
  }
#line 46
  if ((int )adr->sa_family == 10) {
#line 46
    goto case_10;
  }
#line 51
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 42
  tmp = rta_put(msg, type, 4);
#line 42
  i = (struct in_addr *)tmp;
#line 43
  *i = ((struct sockaddr_in *)adr)->sin_addr;
  }
#line 44
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 47
  tmp___0 = rta_put(msg, type, 16);
#line 47
  i6 = (struct in6_addr *)tmp___0;
#line 48
  *i6 = ((struct sockaddr_in6 *)adr)->sin6_addr;
  }
#line 49
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 52
  return ((int __attribute__((__visibility__("hidden")))  )-1);
  switch_break: /* CIL Label */ ;
  }
#line 54
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/rtnetlink.c"
int __attribute__((__visibility__("hidden")))  rtnetlink_request(struct nlmsghdr *msg ,
                                                                 int buflen , struct sockaddr_nl *adr ) 
{ 
  int rsk ;
  int n ;
  int e ;
  ssize_t tmp ;
  socklen_t adrlen ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  struct nlmsgerr *err ;
  int *tmp___3 ;

  {
  {
#line 67
  rsk = socket(16, 3, 0);
  }
#line 68
  if (rsk < 0) {
#line 69
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
  {
#line 70
  tmp = sendto(rsk, (void const   *)msg, (size_t )msg->nlmsg_len, 0, (struct sockaddr  const  *)((struct sockaddr *)adr),
               (socklen_t )sizeof(struct sockaddr_nl ));
#line 70
  n = (int )tmp;
  }
#line 72
  if (n >= 0) {
    {
#line 73
    adrlen = (socklen_t )sizeof(struct sockaddr_nl );
#line 74
    tmp___0 = recvfrom(rsk, (void */* __restrict  */)msg, (size_t )buflen, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)adr),
                       (socklen_t */* __restrict  */)(& adrlen));
#line 74
    n = (int )tmp___0;
    }
  }
  {
#line 77
  tmp___1 = __errno_location();
#line 77
  e = *tmp___1;
#line 78
  close(rsk);
#line 79
  tmp___2 = __errno_location();
#line 79
  *tmp___2 = e;
  }
#line 80
  if (n < 0) {
#line 81
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
#line 84
  if ((int )msg->nlmsg_type == 2) {
    {
#line 85
    err = (struct nlmsgerr *)((void *)((char *)msg + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 86
    tmp___3 = __errno_location();
#line 86
    *tmp___3 = - err->error;
    }
#line 87
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
#line 89
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 139 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
int numa_max_node(void) ;
#line 295
void numa_error(char *where )  __attribute__((__weak__)) ;
#line 299
int numa_exit_on_error ;
#line 316
struct bitmask *numa_parse_nodestring(char const   *s ) ;
#line 13 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numaif.h"
long mbind(void *start___0 , unsigned long len , int mode , unsigned long const   *nmask ,
           unsigned long maxnode , unsigned int flags )  __attribute__((__weak__)) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 59 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) memalign)(size_t __alignment ,
                                                                                 size_t __size )  __attribute__((__malloc__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 978 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 17 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
char *memory  ;
#line 19 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
unsigned long pages  =    1000UL;
#line 21 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
unsigned long pagesize  ;
#line 23 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
char const   *optstr  =    "hvp:";
#line 25 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
char *cmd  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
int verbose  ;
#line 28 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
struct timespec start  ;
#line 28 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
struct timespec end  ;
#line 30 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
void usage(void) 
{ 


  {
  {
#line 32
  printf((char const   */* __restrict  */)"usage %s [-p pages] [-h] [-v] from-nodes to-nodes\n",
         cmd);
#line 33
  printf((char const   */* __restrict  */)"      from and to nodes may specified in form N or N-N\n");
#line 34
  printf((char const   */* __restrict  */)"      -p pages  number of pages to try (defaults to %ld)\n",
         pages);
#line 36
  printf((char const   */* __restrict  */)"      -v        verbose\n");
#line 37
  printf((char const   */* __restrict  */)"      -h        usage\n");
#line 38
  exit(1);
  }
}
}
#line 41 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
void displaymap(void) 
{ 
  FILE *f ;
  FILE *tmp ;
  char buffer[2000] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 43
  tmp = fopen((char const   */* __restrict  */)"/proc/self/numa_maps", (char const   */* __restrict  */)"r");
#line 43
  f = tmp;
  }
#line 45
  if (! f) {
    {
#line 46
    printf((char const   */* __restrict  */)"/proc/self/numa_maps not accessible.\n");
#line 47
    exit(1);
    }
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    tmp___2 = feof(f);
    }
#line 50
    if (tmp___2) {
#line 50
      goto while_break;
    }
    {
#line 54
    tmp___0 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)f);
    }
#line 54
    if (! tmp___0) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___1 = strstr((char const   *)(buffer), "bind");
    }
#line 56
    if (! tmp___1) {
#line 57
      goto while_continue;
    }
    {
#line 58
    printf((char const   */* __restrict  */)"%s", buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  fclose(f);
  }
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/migspeed.c"
int main(int argc , char **argv ) 
{ 
  char *p ;
  int option ;
  int error ;
  struct timespec result ;
  unsigned long bytes___1 ;
  double duration ;
  double mbytes ;
  struct bitmask *from ;
  struct bitmask *to ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 68
  error = 0;
#line 75
  tmp = getpagesize();
#line 75
  pagesize = (unsigned long )tmp;
#line 78
  opterr = 1;
#line 79
  cmd = *(argv + 0);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    option = getopt(argc, (char * const  *)argv, optstr);
    }
#line 81
    if (! (option != -1)) {
#line 81
      goto while_break;
    }
    {
#line 84
    if (option == 63) {
#line 84
      goto case_63;
    }
#line 84
    if (option == 104) {
#line 84
      goto case_63;
    }
#line 87
    if (option == 118) {
#line 87
      goto case_118;
    }
#line 90
    if (option == 112) {
#line 90
      goto case_112;
    }
#line 82
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 85
    error = 1;
#line 86
    goto switch_break;
    case_118: /* CIL Label */ 
#line 88
    verbose ++;
#line 89
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 91
    pages = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                    0);
    }
#line 92
    if ((unsigned long )p == (unsigned long )optarg) {
      {
#line 93
      usage();
      }
    } else
#line 92
    if (*p) {
      {
#line 93
      usage();
      }
    }
#line 94
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (! *(argv + optind)) {
    {
#line 98
    usage();
    }
  }
#line 100
  if (verbose > 1) {
    {
#line 101
    tmp___0 = numa_max_node();
#line 101
    printf((char const   */* __restrict  */)"numa_max_node = %d\n", tmp___0);
    }
  }
  {
#line 103
  numa_exit_on_error = 1;
#line 105
  from = numa_parse_nodestring((char const   *)*(argv + optind));
  }
#line 106
  if (! from) {
    {
#line 107
    printf((char const   */* __restrict  */)"<%s> is invalid\n", *(argv + optind));
#line 108
    exit(1);
    }
  }
  {
#line 110
  tmp___1 = __errno_location();
  }
#line 110
  if (*tmp___1) {
    {
#line 111
    perror("from mask");
#line 112
    exit(1);
    }
  }
#line 115
  if (verbose) {
    {
#line 116
    printmask((char *)"From", from);
    }
  }
#line 118
  if (! *(argv + (optind + 1))) {
    {
#line 119
    usage();
    }
  }
  {
#line 121
  to = numa_parse_nodestring((char const   *)*(argv + (optind + 1)));
  }
#line 122
  if (! to) {
    {
#line 123
    printf((char const   */* __restrict  */)"<%s> is invalid\n", *(argv + (optind + 1)));
#line 124
    exit(1);
    }
  }
  {
#line 126
  tmp___2 = __errno_location();
  }
#line 126
  if (*tmp___2) {
    {
#line 127
    perror("to mask");
#line 128
    exit(1);
    }
  }
#line 131
  if (verbose) {
    {
#line 132
    printmask((char *)"To", to);
    }
  }
#line 134
  bytes___1 = pages * pagesize;
#line 136
  if (verbose) {
    {
#line 137
    printf((char const   */* __restrict  */)"Allocating %lu pages of %lu bytes of memory\n",
           pages, pagesize);
    }
  }
  {
#line 140
  tmp___3 = memalign(pagesize, bytes___1);
#line 140
  memory = (char *)tmp___3;
  }
#line 142
  if (! memory) {
    {
#line 143
    printf((char const   */* __restrict  */)"Out of Memory\n");
#line 144
    exit(2);
    }
  }
  {
#line 147
  tmp___4 = mbind((void *)memory, bytes___1, 2, (unsigned long const   *)from->maskp,
                  from->size, 0U);
  }
#line 147
  if (tmp___4 < 0L) {
    {
#line 148
    numa_error((char *)"mbind");
    }
  }
#line 150
  if (verbose) {
    {
#line 151
    printf((char const   */* __restrict  */)"Dirtying memory....\n");
    }
  }
#line 153
  p = memory;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! ((unsigned long )p <= (unsigned long )(memory + bytes___1))) {
#line 153
      goto while_break___0;
    }
#line 154
    *p = (char)1;
#line 153
    p += pagesize;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  if (verbose) {
    {
#line 157
    printf((char const   */* __restrict  */)"Starting test\n");
    }
  }
  {
#line 159
  displaymap();
#line 160
  clock_gettime(0, & start);
#line 162
  tmp___5 = mbind((void *)memory, bytes___1, 2, (unsigned long const   *)to->maskp,
                  to->size, (unsigned int )(1 << 1));
  }
#line 162
  if (tmp___5 < 0L) {
    {
#line 163
    numa_error((char *)"memory move");
    }
  }
  {
#line 165
  clock_gettime(0, & end);
#line 166
  displaymap();
#line 168
  result.tv_sec = end.tv_sec - start.tv_sec;
#line 169
  result.tv_nsec = end.tv_nsec - start.tv_nsec;
  }
#line 171
  if (result.tv_nsec < 0L) {
#line 172
    (result.tv_sec) --;
#line 173
    result.tv_nsec += 1000000000L;
  }
#line 176
  if (result.tv_nsec >= 1000000000L) {
#line 177
    (result.tv_sec) ++;
#line 178
    result.tv_nsec -= 1000000000L;
  }
  {
#line 181
  duration = (double )result.tv_sec + (double )result.tv_nsec / 1000000000.0;
#line 182
  mbytes = (double )bytes___1 / ((double )1024 * 1024.0);
#line 184
  printf((char const   */* __restrict  */)"%1.1f Mbyte migrated in %1.2f secs. %3.1f Mbytes/second\n",
         mbytes, duration, mbytes / duration);
  }
#line 188
  return (0);
}
}
#line 668 "/usr/include/stdio.h"
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 155 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
struct bitmask *numa_nodes_ptr ;
#line 289
int numa_distance(int a___1 , int b___1 ) ;
#line 302
void numa_warn(int num , char *fmt  , ...)  __attribute__((__weak__)) ;
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes = maxnode;
#line 106
  distance_table = table;
#line 107
  return (0);
}
}
#line 110 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
int numa_distance(int a___1 , int b___1 ) 
{ 
  int err ;
  int tmp ;

  {
#line 112
  if (! distance_table) {
    {
#line 113
    tmp = read_distance_table();
#line 113
    err = tmp;
    }
#line 114
    if (err < 0) {
#line 115
      return (0);
    }
  }
#line 117
  return (*(distance_table + (a___1 * distance_numnodes + b___1)));
}
}
#line 1058 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) syscall)(long __sysno 
                                                                               , ...) ;
#line 55 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
unsigned int numa_bitmask_nbytes(struct bitmask *bmp ) ;
#line 11 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numaif.h"
long get_mempolicy(int *policy___0 , unsigned long const   *nmask , unsigned long maxnode ,
                   void *addr , int flags )  __attribute__((__weak__)) ;
#line 15
long set_mempolicy(int mode , unsigned long const   *nmask , unsigned long maxnode )  __attribute__((__weak__)) ;
#line 17
long migrate_pages(int pid , unsigned long maxnode , unsigned long const   *frommask ,
                   unsigned long const   *tomask )  __attribute__((__weak__)) ;
#line 21
long move_pages(int pid , unsigned long count , void **pages___0 , int const   *nodes ,
                int *status , int flags )  __attribute__((__weak__)) ;
#line 4 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numaint.h"
int numa_sched_setaffinity_v1(pid_t pid , unsigned int len , unsigned long const   *mask ) ;
#line 5
int numa_sched_getaffinity_v1(pid_t pid , unsigned int len , unsigned long const   *mask ) ;
#line 6
extern int numa_sched_setaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask )  __attribute__((__visibility__("hidden"))) ;
#line 7
extern int numa_sched_getaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask )  __attribute__((__visibility__("hidden"))) ;
#line 8
int numa_sched_setaffinity_v2(pid_t pid , struct bitmask *mask ) ;
#line 9
int numa_sched_getaffinity_v2(pid_t pid , struct bitmask *mask ) ;
#line 10
extern int numa_sched_setaffinity_v2_int(pid_t pid , struct bitmask *mask )  __attribute__((__visibility__("hidden"))) ;
#line 11
extern int numa_sched_getaffinity_v2_int(pid_t pid , struct bitmask *mask )  __attribute__((__visibility__("hidden"))) ;
#line 184 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long get_mempolicy(int *policy___0 , unsigned long const   *nmask , unsigned long maxnode ,
                   void *addr , int flags )  __attribute__((__weak__)) ;
#line 184 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long get_mempolicy(int *policy___0 , unsigned long const   *nmask , unsigned long maxnode ,
                   void *addr , int flags ) 
{ 
  long tmp ;

  {
  {
#line 187
  tmp = syscall(239L, policy___0, nmask, maxnode, addr, flags);
  }
#line 187
  return (tmp);
}
}
#line 191
long mbind(void *start___0 , unsigned long len , int mode , unsigned long const   *nmask ,
           unsigned long maxnode , unsigned int flags )  __attribute__((__weak__)) ;
#line 191 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long mbind(void *start___0 , unsigned long len , int mode , unsigned long const   *nmask ,
           unsigned long maxnode , unsigned int flags ) 
{ 
  long tmp ;

  {
  {
#line 194
  tmp = syscall(237L, (long )start___0, len, mode, (long )nmask, maxnode, flags);
  }
#line 194
  return (tmp);
}
}
#line 198
long set_mempolicy(int mode , unsigned long const   *nmask , unsigned long maxnode )  __attribute__((__weak__)) ;
#line 198 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long set_mempolicy(int mode , unsigned long const   *nmask , unsigned long maxnode ) 
{ 
  long i ;

  {
  {
#line 202
  i = syscall(238L, mode, nmask, maxnode);
  }
#line 203
  return (i);
}
}
#line 206
long migrate_pages(int pid , unsigned long maxnode , unsigned long const   *frommask ,
                   unsigned long const   *tomask )  __attribute__((__weak__)) ;
#line 206 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long migrate_pages(int pid , unsigned long maxnode , unsigned long const   *frommask ,
                   unsigned long const   *tomask ) 
{ 
  long tmp ;

  {
  {
#line 209
  tmp = syscall(256L, pid, maxnode, frommask, tomask);
  }
#line 209
  return (tmp);
}
}
#line 212
long move_pages(int pid , unsigned long count , void **pages___0 , int const   *nodes ,
                int *status , int flags )  __attribute__((__weak__)) ;
#line 212 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
long move_pages(int pid , unsigned long count , void **pages___0 , int const   *nodes ,
                int *status , int flags ) 
{ 
  long tmp ;

  {
  {
#line 215
  tmp = syscall(279L, pid, count, pages___0, nodes, status, flags);
  }
#line 215
  return (tmp);
}
}
#line 219 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
int numa_sched_setaffinity_v1(pid_t pid , unsigned int len , unsigned long const   *mask ) 
{ 
  long tmp ;

  {
  {
#line 221
  tmp = syscall(203L, pid, len, mask);
  }
#line 221
  return ((int )tmp);
}
}
#line 223
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 225 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
int numa_sched_setaffinity_v2(pid_t pid , struct bitmask *mask ) 
{ 
  unsigned int tmp ;
  long tmp___0 ;

  {
  {
#line 227
  tmp = numa_bitmask_nbytes(mask);
#line 227
  tmp___0 = syscall(203L, pid, tmp, mask->maskp);
  }
#line 227
  return ((int )tmp___0);
}
}
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 232 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
int numa_sched_getaffinity_v1(pid_t pid , unsigned int len , unsigned long const   *mask ) 
{ 
  long tmp ;

  {
  {
#line 234
  tmp = syscall(204L, pid, len, mask);
  }
#line 234
  return ((int )tmp);
}
}
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 239 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
int numa_sched_getaffinity_v2(pid_t pid , struct bitmask *mask ) 
{ 
  unsigned int tmp ;
  long tmp___0 ;

  {
  {
#line 242
  tmp = numa_bitmask_nbytes(mask);
#line 242
  tmp___0 = syscall(204L, pid, tmp, mask->maskp);
  }
#line 242
  return ((int )tmp___0);
}
}
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 249
extern int numa_sched_getaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask )  __attribute__((__visibility__("hidden"))) ;
#line 249 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
extern int numa_sched_getaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask ) 
{ 
  int tmp ;

  {
  {
#line 249
  tmp = numa_sched_getaffinity_v1(pid, len, mask);
  }
#line 249
  return (tmp);
}
}
#line 250
extern int numa_sched_getaffinity_v2_int(pid_t pid , struct bitmask *mask )  __attribute__((__visibility__("hidden"))) ;
#line 250 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
extern int numa_sched_getaffinity_v2_int(pid_t pid , struct bitmask *mask ) 
{ 
  int tmp ;

  {
  {
#line 250
  tmp = numa_sched_getaffinity_v2(pid, mask);
  }
#line 250
  return (tmp);
}
}
#line 251
extern int numa_sched_setaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask )  __attribute__((__visibility__("hidden"))) ;
#line 251 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
extern int numa_sched_setaffinity_v1_int(pid_t pid , unsigned int len , unsigned long const   *mask ) 
{ 
  int tmp ;

  {
  {
#line 251
  tmp = numa_sched_setaffinity_v1(pid, len, mask);
  }
#line 251
  return (tmp);
}
}
#line 252
extern int numa_sched_setaffinity_v2_int(pid_t pid , struct bitmask *mask )  __attribute__((__visibility__("hidden"))) ;
#line 252 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
extern int numa_sched_setaffinity_v2_int(pid_t pid , struct bitmask *mask ) 
{ 
  int tmp ;

  {
  {
#line 252
  tmp = numa_sched_setaffinity_v2(pid, mask);
  }
#line 252
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 214 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 678 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 133
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mremap)(void *__addr ,
                                                                               size_t __old_len ,
                                                                               size_t __new_len ,
                                                                               int __flags 
                                                                               , ...) ;
#line 51 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
struct bitmask *numa_bitmask_setall(struct bitmask *bmp ) ;
#line 52
struct bitmask *numa_bitmask_clearall(struct bitmask *bmp ) ;
#line 53
struct bitmask *numa_bitmask_setbit(struct bitmask *bmp , unsigned int i ) ;
#line 54
struct bitmask *numa_bitmask_clearbit(struct bitmask *bmp , unsigned int i ) ;
#line 56
unsigned int numa_bitmask_weight(struct bitmask  const  *bmp ) ;
#line 57
struct bitmask *numa_bitmask_alloc(unsigned int n ) ;
#line 58
void numa_bitmask_free(struct bitmask *bmp ) ;
#line 59
int numa_bitmask_equal(struct bitmask  const  *bmp1 , struct bitmask  const  *bmp2 ) ;
#line 60
void copy_nodemask_to_bitmask(nodemask_t *nmp , struct bitmask *bmp ) ;
#line 61
void copy_bitmask_to_nodemask(struct bitmask *bmp , nodemask_t *nmp ) ;
#line 62
void copy_bitmask_to_bitmask(struct bitmask *bmpfrom , struct bitmask *bmpto ) ;
#line 84 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
__inline static void nodemask_set_compat(nodemask_t *mask , int node ) 
{ 


  {
#line 86
  mask->n[(unsigned long )node / (8UL * sizeof(unsigned long ))] |= 1UL << (unsigned long )node % (8UL * sizeof(unsigned long ));
#line 88
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
__inline static int nodemask_isset_compat(nodemask_t const   *mask , int node ) 
{ 


  {
#line 98
  if ((unsigned int )node >= 128U) {
#line 99
    return (0);
  }
#line 100
  if (mask->n[(unsigned long )node / (8UL * sizeof(unsigned long ))] & (1UL << (unsigned long )node % (8UL * sizeof(unsigned long )))) {
#line 102
    return (1);
  }
#line 103
  return (0);
}
}
#line 134
int numa_available(void) ;
#line 142
int numa_preferred(void) ;
#line 145
long long numa_node_size64(int node , long long *freep ) ;
#line 146
long numa_node_size(int node , long *freep ) ;
#line 148
int numa_pagesize(void) ;
#line 152
struct bitmask *numa_all_nodes_ptr ;
#line 158 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
nodemask_t numa_all_nodes  ;
#line 161
struct bitmask *numa_all_cpus_ptr ;
#line 164
struct bitmask *numa_no_nodes_ptr ;
#line 167 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
nodemask_t numa_no_nodes  ;
#line 179
struct bitmask *numa_allocate_nodemask(void) ;
#line 187
void numa_set_preferred(int node ) ;
#line 190
void numa_set_localalloc(void) ;
#line 199
struct bitmask *numa_get_mems_allowed(void) ;
#line 201
int numa_get_interleave_node(void) ;
#line 209
void *numa_alloc_interleaved(size_t size___20 ) ;
#line 211
void *numa_alloc_onnode(size_t size___20 , int node ) ;
#line 213
void *numa_alloc_local(size_t size___20 ) ;
#line 215
void *numa_alloc(size_t size___20 ) ;
#line 217
void *numa_realloc(void *old_addr , size_t old_size , size_t new_size ) ;
#line 219
void numa_free(void *mem___0 , size_t size___20 ) ;
#line 228
void numa_tonode_memory(void *mem___0 , size_t size___20 , int node ) ;
#line 234
void numa_setlocal_memory(void *mem___0 , size_t size___20 ) ;
#line 237
void numa_police_memory(void *mem___0 , size_t size___20 ) ;
#line 242
int numa_run_on_node_mask_all(struct bitmask *bmp ) ;
#line 244
int numa_run_on_node(int node ) ;
#line 249
void numa_set_bind_policy(int strict ) ;
#line 252
void numa_set_strict(int flag ) ;
#line 255
int numa_num_possible_nodes(void) ;
#line 258
int numa_num_possible_cpus(void) ;
#line 261
int numa_num_configured_nodes(void) ;
#line 264
int numa_num_configured_cpus(void) ;
#line 267
int numa_num_task_cpus(void) ;
#line 268
int numa_num_thread_cpus(void) ;
#line 271
int numa_num_task_nodes(void) ;
#line 272
int numa_num_thread_nodes(void) ;
#line 275
struct bitmask *numa_allocate_cpumask(void) ;
#line 286
int numa_node_of_cpu(int cpu ) ;
#line 305
int numa_exit_on_warn ;
#line 307
int numa_migrate_pages(int pid , struct bitmask *fromnodes , struct bitmask *tonodes ) ;
#line 309
int numa_move_pages(int pid , unsigned long count , void **pages___0 , int const   *nodes ,
                    int *status , int flags ) ;
#line 320
struct bitmask *numa_parse_nodestring_all(char const   *s ) ;
#line 323
struct bitmask *numa_parse_cpustring(char const   *s ) ;
#line 327
struct bitmask *numa_parse_cpustring_all(char const   *s ) ;
#line 5 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.h"
int __attribute__((__visibility__("hidden")))  resolve_affinity(char const   *id ,
                                                                struct bitmask *mask ) ;
#line 48 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_no_nodes_ptr  =    (struct bitmask *)((void *)0);
#line 49 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_all_nodes_ptr  =    (struct bitmask *)((void *)0);
#line 50 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_possible_nodes_ptr  =    (struct bitmask *)((void *)0);
#line 51 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_all_cpus_ptr  =    (struct bitmask *)((void *)0);
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_possible_cpus_ptr  =    (struct bitmask *)((void *)0);
#line 57 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_nodes_ptr  =    (struct bitmask *)((void *)0);
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1[128]  ;
#line 60 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask **node_cpu_mask_v2  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz  =    0;
#line 78 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_exit_on_error  =    0;
#line 79 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_exit_on_warn  =    0;
#line 80
static void set_sizes(void) ;
#line 88
void numa_init(void)  __attribute__((__constructor__)) ;
#line 88 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_init(void) 
{ 
  int max ;
  int i ;

  {
#line 93
  if (sizes_set) {
#line 94
    return;
  }
  {
#line 96
  set_sizes();
#line 98
  max = numa_num_configured_nodes();
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < max)) {
#line 99
      goto while_break;
    }
    {
#line 100
    nodemask_set_compat(& numa_all_nodes, i);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  memset((void *)(& numa_no_nodes), 0, sizeof(numa_no_nodes));
  }
#line 102
  return;
}
}
#line 109
void numa_fini(void)  __attribute__((__destructor__)) ;
#line 109 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_fini(void) 
{ 


  {
#line 112
  if (numa_all_cpus_ptr) {
    {
#line 112
    numa_bitmask_free(numa_all_cpus_ptr);
#line 112
    numa_all_cpus_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 113
  if (numa_possible_cpus_ptr) {
    {
#line 113
    numa_bitmask_free(numa_possible_cpus_ptr);
#line 113
    numa_possible_cpus_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 114
  if (numa_all_nodes_ptr) {
    {
#line 114
    numa_bitmask_free(numa_all_nodes_ptr);
#line 114
    numa_all_nodes_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 115
  if (numa_possible_nodes_ptr) {
    {
#line 115
    numa_bitmask_free(numa_possible_nodes_ptr);
#line 115
    numa_possible_nodes_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 116
  if (numa_no_nodes_ptr) {
    {
#line 116
    numa_bitmask_free(numa_no_nodes_ptr);
#line 116
    numa_no_nodes_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 117
  if (numa_memnode_ptr) {
    {
#line 117
    numa_bitmask_free(numa_memnode_ptr);
#line 117
    numa_memnode_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 118
  if (numa_nodes_ptr) {
    {
#line 118
    numa_bitmask_free(numa_nodes_ptr);
#line 118
    numa_nodes_ptr = (struct bitmask *)((void *)0);
    }
  }
#line 119
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_bitmask_isbitset(struct bitmask  const  *bmp , unsigned int i ) 
{ 
  unsigned int tmp ;

  {
  {
#line 151
  tmp = _getbit(bmp, i);
  }
#line 151
  return ((int )tmp);
}
}
#line 154 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_bitmask_setall(struct bitmask *bmp ) 
{ 
  unsigned int i ;

  {
#line 158
  i = 0U;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )i < bmp->size)) {
#line 158
      goto while_break;
    }
    {
#line 159
    _setbit(bmp, i, 1U);
#line 158
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return (bmp);
}
}
#line 163 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_bitmask_clearall(struct bitmask *bmp ) 
{ 
  unsigned int i ;

  {
#line 167
  i = 0U;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )i < bmp->size)) {
#line 167
      goto while_break;
    }
    {
#line 168
    _setbit(bmp, i, 0U);
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (bmp);
}
}
#line 172 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_bitmask_setbit(struct bitmask *bmp , unsigned int i ) 
{ 


  {
  {
#line 175
  _setbit(bmp, i, 1U);
  }
#line 176
  return (bmp);
}
}
#line 179 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_bitmask_clearbit(struct bitmask *bmp , unsigned int i ) 
{ 


  {
  {
#line 182
  _setbit(bmp, i, 0U);
  }
#line 183
  return (bmp);
}
}
#line 186 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
unsigned int numa_bitmask_nbytes(struct bitmask *bmp ) 
{ 


  {
#line 189
  return ((unsigned int )(((bmp->size + (8UL * sizeof(unsigned long ) - 1UL)) / (8UL * sizeof(unsigned long ))) * sizeof(unsigned long )));
}
}
#line 195 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_bitmask_alloc(unsigned int n ) 
{ 
  struct bitmask *bmp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 200
  if (n < 1U) {
    {
#line 201
    numa_error((char *)"request to allocate mask for invalid number; abort\n");
#line 202
    exit(1);
    }
  }
  {
#line 204
  tmp = malloc(sizeof(*bmp));
#line 204
  bmp = (struct bitmask *)tmp;
  }
#line 205
  if ((unsigned long )bmp == (unsigned long )((struct bitmask *)0)) {
#line 206
    goto oom;
  }
  {
#line 207
  bmp->size = (unsigned long )n;
#line 208
  tmp___0 = calloc(((unsigned long )n + (8UL * sizeof(unsigned long ) - 1UL)) / (8UL * sizeof(unsigned long )),
                   sizeof(unsigned long ));
#line 208
  bmp->maskp = (unsigned long *)tmp___0;
  }
#line 209
  if ((unsigned long )bmp->maskp == (unsigned long )((unsigned long *)0)) {
    {
#line 210
    free((void *)bmp);
    }
#line 211
    goto oom;
  }
#line 213
  return (bmp);
  oom: 
  {
#line 216
  numa_error((char *)"Out of memory allocating bitmask");
#line 217
  exit(1);
  }
}
}
#line 220 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_bitmask_free(struct bitmask *bmp ) 
{ 


  {
#line 223
  if ((unsigned long )bmp == (unsigned long )((struct bitmask *)0)) {
#line 224
    return;
  }
  {
#line 225
  free((void *)bmp->maskp);
#line 226
  bmp->maskp = (unsigned long *)3735932399U;
#line 227
  free((void *)bmp);
  }
#line 228
  return;
}
}
#line 232 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_bitmask_equal(struct bitmask  const  *bmp1 , struct bitmask  const  *bmp2 ) 
{ 
  unsigned int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 236
  i = 0U;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long const   )i < bmp1->size)) {
#line 236
      if (! ((unsigned long const   )i < bmp2->size)) {
#line 236
        goto while_break;
      }
    }
    {
#line 237
    tmp = _getbit(bmp1, i);
#line 237
    tmp___0 = _getbit(bmp2, i);
    }
#line 237
    if (tmp != tmp___0) {
#line 238
      return (0);
    }
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (1);
}
}
#line 243 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
unsigned int numa_bitmask_weight(struct bitmask  const  *bmp ) 
{ 
  unsigned int i ;
  unsigned int w ;
  unsigned int tmp ;

  {
#line 246
  w = 0U;
#line 247
  i = 0U;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! ((unsigned long const   )i < bmp->size)) {
#line 247
      goto while_break;
    }
    {
#line 248
    tmp = _getbit(bmp, i);
    }
#line 248
    if (tmp) {
#line 249
      w ++;
    }
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return (w);
}
}
#line 256
void numa_error(char *where )  __attribute__((__weak__)) ;
#line 256 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_error(char *where ) 
{ 
  int olde ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 258
  tmp = __errno_location();
#line 258
  olde = *tmp;
#line 259
  perror((char const   *)where);
  }
#line 260
  if (numa_exit_on_error) {
    {
#line 261
    exit(1);
    }
  }
  {
#line 262
  tmp___0 = __errno_location();
#line 262
  *tmp___0 = olde;
  }
#line 263
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned  ;
#line 265
void numa_warn(int num , char *fmt  , ...)  __attribute__((__weak__)) ;
#line 265 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_warn(int num , char *fmt  , ...) 
{ 
  va_list ap ;
  int olde ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 269
  tmp = __errno_location();
#line 269
  olde = *tmp;
  }
#line 272
  if ((unsigned int )(1 << num) & warned) {
#line 273
    return;
  }
  {
#line 274
  warned |= (unsigned int )(1 << num);
#line 276
  __builtin_va_start(ap, fmt);
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libnuma: Warning: ");
#line 278
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 279
  fputc('\n', stderr);
#line 280
  __builtin_va_end(ap);
#line 282
  tmp___0 = __errno_location();
#line 282
  *tmp___0 = olde;
  }
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___0  ;
#line 306 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_pagesize(void) 
{ 


  {
#line 309
  if (pagesize___0 > 0) {
#line 310
    return (pagesize___0);
  }
  {
#line 311
  pagesize___0 = getpagesize();
  }
#line 312
  return (pagesize___0);
}
}
#line 315
extern int numa_pagesize_int(void)  __attribute__((__visibility__("hidden"))) ;
#line 315 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_pagesize_int(void) 
{ 
  int tmp ;

  {
  {
#line 315
  tmp = numa_pagesize();
  }
#line 315
  return (tmp);
}
}
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode < nd) {
#line 344
        maxconfigurednode = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix((char const   *)buf___7, nodemask_prefix);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix);
#line 385
      nodemask_sz = s2nbits((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu = read_mask(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode = read_mask(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu = hicpu + 1;
  }
#line 520
  if (numproccpu > hicpu + 1) {
#line 521
    numproccpu = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode = maxconfigurednode + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes(void) 
{ 


  {
  {
#line 582
  sizes_set ++;
#line 583
  set_nodemask_size();
#line 584
  set_configured_nodes();
#line 585
  set_numa_max_cpu();
#line 586
  set_configured_cpus();
#line 587
  set_task_constraints();
  }
#line 588
  return;
}
}
#line 590 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_configured_nodes(void) 
{ 
  int memnodecount ;
  int i ;
  int tmp ;

  {
#line 601
  memnodecount = 0;
#line 603
  i = 0;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i <= maxconfigurednode)) {
#line 603
      goto while_break;
    }
    {
#line 604
    tmp = numa_bitmask_isbitset((struct bitmask  const  *)numa_memnode_ptr, (unsigned int )i);
    }
#line 604
    if (tmp) {
#line 605
      memnodecount ++;
    }
#line 603
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  return (memnodecount);
}
}
#line 610 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_configured_cpus(void) 
{ 


  {
#line 614
  return (maxconfiguredcpu + 1);
}
}
#line 617 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_possible_nodes(void) 
{ 


  {
#line 620
  return (nodemask_sz);
}
}
#line 623 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_possible_cpus(void) 
{ 


  {
#line 626
  return (cpumask_sz);
}
}
#line 629 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_task_nodes(void) 
{ 


  {
#line 632
  return (numprocnode);
}
}
#line 638 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_thread_nodes(void) 
{ 
  int tmp ;

  {
  {
#line 641
  tmp = numa_num_task_nodes();
  }
#line 641
  return (tmp);
}
}
#line 644 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_task_cpus(void) 
{ 


  {
#line 647
  return (numproccpu);
}
}
#line 653 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_num_thread_cpus(void) 
{ 
  int tmp ;

  {
  {
#line 656
  tmp = numa_num_task_cpus();
  }
#line 656
  return (tmp);
}
}
#line 662 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_max_node(void) 
{ 


  {
#line 665
  return (maxconfigurednode);
}
}
#line 668
extern int numa_max_node_int(void)  __attribute__((__visibility__("hidden"))) ;
#line 668 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_max_node_int(void) 
{ 
  int tmp ;

  {
  {
#line 668
  tmp = numa_max_node();
  }
#line 668
  return (tmp);
}
}
#line 675 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_max_possible_node_v1(void) 
{ 


  {
#line 678
  return ((int )(sizeof(nodemask_t ) * 8UL - 1UL));
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 682 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_max_possible_node_v2(void) 
{ 
  int tmp ;

  {
  {
#line 685
  tmp = numa_num_possible_nodes();
  }
#line 685
  return (tmp - 1);
}
}
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 689
extern int numa_max_possible_node_v1_int(void)  __attribute__((__visibility__("hidden"))) ;
#line 689 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_max_possible_node_v1_int(void) 
{ 
  int tmp ;

  {
  {
#line 689
  tmp = numa_max_possible_node_v1();
  }
#line 689
  return (tmp);
}
}
#line 690
extern int numa_max_possible_node_v2_int(void)  __attribute__((__visibility__("hidden"))) ;
#line 690 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_max_possible_node_v2_int(void) 
{ 
  int tmp ;

  {
  {
#line 690
  tmp = numa_max_possible_node_v2();
  }
#line 690
  return (tmp);
}
}
#line 696 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_allocate_cpumask(void) 
{ 
  int ncpus ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 699
  tmp = numa_num_possible_cpus();
#line 699
  ncpus = tmp;
#line 701
  tmp___0 = numa_bitmask_alloc((unsigned int )ncpus);
  }
#line 701
  return (tmp___0);
}
}
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 719 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_allocate_nodemask(void) 
{ 
  struct bitmask *bmp ;
  int nnodes ;
  int tmp ;

  {
  {
#line 723
  tmp = numa_max_possible_node_v2_int();
#line 723
  nnodes = tmp + 1;
#line 725
  bmp = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 726
  return (bmp);
}
}
#line 730 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
long long numa_node_size64(int node , long long *freep ) 
{ 
  size_t len ;
  char *line ;
  long long size___20 ;
  FILE *f ;
  char fn[64] ;
  int ok ;
  int required ;
  int tmp ;
  char *end___0 ;
  char *s ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long long tmp___3 ;
  char *tmp___4 ;
  unsigned long long tmp___5 ;
  char *tmp___6 ;
  __ssize_t tmp___7 ;

  {
#line 732
  len = (size_t )0;
#line 733
  line = (char *)((void *)0);
#line 734
  size___20 = -1LL;
#line 737
  ok = 0;
#line 738
  if (freep) {
#line 738
    tmp = 2;
  } else {
#line 738
    tmp = 1;
  }
#line 738
  required = tmp;
#line 740
  if (freep) {
#line 741
    *freep = -1LL;
  }
  {
#line 742
  sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/meminfo",
          node);
#line 743
  f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
  }
#line 744
  if (! f) {
#line 745
    return (-1LL);
  }
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 746
    tmp___7 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                       '\n', (FILE */* __restrict  */)f);
    }
#line 746
    if (! (tmp___7 > 0L)) {
#line 746
      goto while_break;
    }
    {
#line 748
    tmp___0 = strcasestr((char const   *)line, "kB");
#line 748
    s = tmp___0;
    }
#line 749
    if (! s) {
#line 750
      goto while_continue;
    }
#line 751
    s --;
    {
#line 752
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 752
      if ((unsigned long )s > (unsigned long )line) {
        {
#line 752
        tmp___1 = __ctype_b_loc();
        }
#line 752
        if (! ((int const   )*(*tmp___1 + (int )*s) & 8192)) {
#line 752
          goto while_break___0;
        }
      } else {
#line 752
        goto while_break___0;
      }
#line 753
      s --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 754
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 754
      if ((unsigned long )s > (unsigned long )line) {
        {
#line 754
        tmp___2 = __ctype_b_loc();
        }
#line 754
        if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 754
          goto while_break___1;
        }
      } else {
#line 754
        goto while_break___1;
      }
#line 755
      s --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 756
    tmp___4 = strstr((char const   *)line, "MemTotal");
    }
#line 756
    if (tmp___4) {
      {
#line 757
      tmp___3 = strtoull((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                         0);
#line 757
      size___20 = (long long )(tmp___3 << 10);
      }
#line 758
      if ((unsigned long )end___0 == (unsigned long )s) {
#line 759
        size___20 = -1LL;
      } else {
#line 761
        ok ++;
      }
    }
#line 763
    if (freep) {
      {
#line 763
      tmp___6 = strstr((char const   *)line, "MemFree");
      }
#line 763
      if (tmp___6) {
        {
#line 764
        tmp___5 = strtoull((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                           0);
#line 764
        *freep = (long long )(tmp___5 << 10);
        }
#line 765
        if ((unsigned long )end___0 == (unsigned long )s) {
#line 766
          *freep = -1LL;
        } else {
#line 768
          ok ++;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 771
  fclose(f);
#line 772
  free((void *)line);
  }
#line 773
  if (ok != required) {
    {
#line 774
    numa_warn(2, (char *)"Cannot parse sysfs meminfo (%d)", ok);
    }
  }
#line 775
  return (size___20);
}
}
#line 778
extern long long numa_node_size64_int(int node , long long *freep )  __attribute__((__visibility__("hidden"))) ;
#line 778 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern long long numa_node_size64_int(int node , long long *freep ) 
{ 
  long long tmp ;

  {
  {
#line 778
  tmp = numa_node_size64(node, freep);
  }
#line 778
  return (tmp);
}
}
#line 780 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
long numa_node_size(int node , long *freep ) 
{ 
  long long f2 ;
  long sz ;
  long long tmp ;

  {
  {
#line 783
  tmp = numa_node_size64_int(node, & f2);
#line 783
  sz = (long )tmp;
  }
#line 784
  if (freep) {
#line 785
    *freep = (long )f2;
  }
#line 786
  return (sz);
}
}
#line 789 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_available(void) 
{ 
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 791
  tmp = get_mempolicy((int *)((void *)0), (unsigned long const   *)((void *)0), 0UL,
                      (void *)0, 0);
  }
#line 791
  if (tmp < 0L) {
    {
#line 791
    tmp___0 = __errno_location();
    }
#line 791
    if (*tmp___0 == 38) {
#line 792
      return (-1);
    }
  }
#line 793
  return (0);
}
}
#line 796 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_interleave_memory_v1(void *mem___0 , size_t size___20 , nodemask_t const   *mask ) 
{ 
  struct bitmask bitmask ;

  {
  {
#line 801
  bitmask.size = sizeof(nodemask_t ) * 8UL;
#line 802
  bitmask.maskp = (unsigned long *)mask;
#line 803
  dombind(mem___0, size___20, 3, & bitmask);
  }
#line 804
  return;
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 807 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_interleave_memory_v2(void *mem___0 , size_t size___20 , struct bitmask *bmp ) 
{ 


  {
  {
#line 810
  dombind(mem___0, size___20, 3, bmp);
  }
#line 811
  return;
}
}
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 814 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_tonode_memory(void *mem___0 , size_t size___20 , int node ) 
{ 
  struct bitmask *nodes ;

  {
  {
#line 818
  nodes = numa_allocate_nodemask();
#line 819
  numa_bitmask_setbit(nodes, (unsigned int )node);
#line 820
  dombind(mem___0, size___20, bind_policy, nodes);
#line 821
  numa_bitmask_free(nodes);
  }
#line 822
  return;
}
}
#line 824 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_tonodemask_memory_v1(void *mem___0 , size_t size___20 , nodemask_t const   *mask ) 
{ 
  struct bitmask bitmask ;

  {
  {
#line 829
  bitmask.maskp = (unsigned long *)mask;
#line 830
  bitmask.size = sizeof(nodemask_t );
#line 831
  dombind(mem___0, size___20, bind_policy, & bitmask);
  }
#line 832
  return;
}
}
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 835 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_tonodemask_memory_v2(void *mem___0 , size_t size___20 , struct bitmask *bmp ) 
{ 


  {
  {
#line 838
  dombind(mem___0, size___20, bind_policy, bmp);
  }
#line 839
  return;
}
}
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 842 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_setlocal_memory(void *mem___0 , size_t size___20 ) 
{ 


  {
  {
#line 844
  dombind(mem___0, size___20, 1, (struct bitmask *)((void *)0));
  }
#line 845
  return;
}
}
#line 847 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_police_memory(void *mem___0 , size_t size___20 ) 
{ 
  int pagesize___21 ;
  int tmp ;
  unsigned long i ;

  {
  {
#line 849
  tmp = numa_pagesize_int();
#line 849
  pagesize___21 = tmp;
#line 851
  i = 0UL;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (i < size___20)) {
#line 851
      goto while_break;
    }
#line 852
    __asm__  volatile   ("": : "r" (*((unsigned char volatile   *)mem___0 + i)));
#line 851
    i += (unsigned long )pagesize___21;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  return;
}
}
#line 855
extern void numa_police_memory_int(void *mem___0 , size_t size___20 )  __attribute__((__visibility__("hidden"))) ;
#line 855 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern void numa_police_memory_int(void *mem___0 , size_t size___20 ) 
{ 


  {
  {
#line 855
  numa_police_memory(mem___0, size___20);
  }
#line 855
  return;
}
}
#line 857 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc(size_t size___20 ) 
{ 
  char *mem___0 ;
  void *tmp ;

  {
  {
#line 860
  tmp = mmap((void *)0, size___20, 3, 34, 0, (__off_t )0);
#line 860
  mem___0 = (char *)tmp;
  }
#line 862
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 863
    return ((void *)0);
  }
  {
#line 864
  numa_police_memory_int((void *)mem___0, size___20);
  }
#line 865
  return ((void *)mem___0);
}
}
#line 868 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_realloc(void *old_addr , size_t old_size , size_t new_size ) 
{ 
  char *mem___0 ;
  void *tmp ;

  {
  {
#line 871
  tmp = mremap(old_addr, old_size, new_size, 1);
#line 871
  mem___0 = (char *)tmp;
  }
#line 872
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 873
    return ((void *)0);
  }
#line 882
  return ((void *)mem___0);
}
}
#line 885 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc_interleaved_subset_v1(size_t size___20 , nodemask_t const   *mask ) 
{ 
  char *mem___0 ;
  struct bitmask bitmask ;
  void *tmp ;

  {
  {
#line 890
  tmp = mmap((void *)0, size___20, 3, 34, 0, (__off_t )0);
#line 890
  mem___0 = (char *)tmp;
  }
#line 892
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 893
    return ((void *)0);
  }
  {
#line 894
  bitmask.maskp = (unsigned long *)mask;
#line 895
  bitmask.size = sizeof(nodemask_t );
#line 896
  dombind((void *)mem___0, size___20, 3, & bitmask);
  }
#line 897
  return ((void *)mem___0);
}
}
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 901 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc_interleaved_subset_v2(size_t size___20 , struct bitmask *bmp ) 
{ 
  char *mem___0 ;
  void *tmp ;

  {
  {
#line 905
  tmp = mmap((void *)0, size___20, 3, 34, 0, (__off_t )0);
#line 905
  mem___0 = (char *)tmp;
  }
#line 907
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 908
    return ((void *)0);
  }
  {
#line 909
  dombind((void *)mem___0, size___20, 3, bmp);
  }
#line 910
  return ((void *)mem___0);
}
}
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 914
extern void *numa_alloc_interleaved_subset_v1_int(size_t size___20 , nodemask_t const   *mask )  __attribute__((__visibility__("hidden"))) ;
#line 914 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern void *numa_alloc_interleaved_subset_v1_int(size_t size___20 , nodemask_t const   *mask ) 
{ 
  void *tmp ;

  {
  {
#line 914
  tmp = numa_alloc_interleaved_subset_v1(size___20, mask);
  }
#line 914
  return (tmp);
}
}
#line 915
extern void *numa_alloc_interleaved_subset_v2_int(size_t size___20 , struct bitmask *bmp )  __attribute__((__visibility__("hidden"))) ;
#line 915 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern void *numa_alloc_interleaved_subset_v2_int(size_t size___20 , struct bitmask *bmp ) 
{ 
  void *tmp ;

  {
  {
#line 915
  tmp = numa_alloc_interleaved_subset_v2(size___20, bmp);
  }
#line 915
  return (tmp);
}
}
#line 917 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc_interleaved(size_t size___20 ) 
{ 
  void *tmp ;

  {
  {
#line 920
  tmp = numa_alloc_interleaved_subset_v2_int(size___20, numa_all_nodes_ptr);
  }
#line 920
  return (tmp);
}
}
#line 926 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_interleave_mask_v1(nodemask_t *mask ) 
{ 
  struct bitmask *bmp ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 930
  tmp = numa_max_possible_node_v1_int();
#line 930
  nnodes = tmp + 1;
#line 932
  bmp = numa_bitmask_alloc((unsigned int )nnodes);
#line 933
  copy_nodemask_to_bitmask(mask, bmp);
#line 934
  tmp___0 = numa_bitmask_equal((struct bitmask  const  *)bmp, (struct bitmask  const  *)numa_no_nodes_ptr);
  }
#line 934
  if (tmp___0) {
    {
#line 935
    setpol(0, bmp);
    }
  } else {
    {
#line 937
    setpol(3, bmp);
    }
  }
  {
#line 938
  numa_bitmask_free(bmp);
  }
#line 939
  return;
}
}
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 943 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_interleave_mask_v2(struct bitmask *bmp ) 
{ 
  int tmp ;

  {
  {
#line 946
  tmp = numa_bitmask_equal((struct bitmask  const  *)bmp, (struct bitmask  const  *)numa_no_nodes_ptr);
  }
#line 946
  if (tmp) {
    {
#line 947
    setpol(0, bmp);
    }
  } else {
    {
#line 949
    setpol(3, bmp);
    }
  }
#line 950
  return;
}
}
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 953 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
nodemask_t numa_get_interleave_mask_v1(void) 
{ 
  int oldpolicy ;
  struct bitmask *bmp ;
  nodemask_t mask ;

  {
  {
#line 960
  bmp = allocate_nodemask_v1();
#line 961
  getpol(& oldpolicy, bmp);
  }
#line 962
  if (oldpolicy == 3) {
    {
#line 963
    copy_bitmask_to_nodemask(bmp, & mask);
    }
  } else {
    {
#line 965
    copy_bitmask_to_nodemask(numa_no_nodes_ptr, & mask);
    }
  }
  {
#line 966
  numa_bitmask_free(bmp);
  }
#line 967
  return (mask);
}
}
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 971 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_get_interleave_mask_v2(void) 
{ 
  int oldpolicy ;
  struct bitmask *bmp ;

  {
  {
#line 977
  bmp = numa_allocate_nodemask();
#line 978
  getpol(& oldpolicy, bmp);
  }
#line 979
  if (oldpolicy != 3) {
    {
#line 980
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, bmp);
    }
  }
#line 981
  return (bmp);
}
}
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 986 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_get_interleave_node(void) 
{ 
  int nd ;
  long tmp ;

  {
  {
#line 989
  tmp = get_mempolicy(& nd, (unsigned long const   *)((void *)0), 0UL, (void *)0,
                      1);
  }
#line 989
  if (tmp == 0L) {
#line 990
    return (nd);
  }
#line 991
  return (0);
}
}
#line 994 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc_onnode(size_t size___20 , int node ) 
{ 
  char *mem___0 ;
  struct bitmask *bmp ;
  void *tmp ;

  {
  {
#line 999
  bmp = numa_allocate_nodemask();
#line 1000
  numa_bitmask_setbit(bmp, (unsigned int )node);
#line 1001
  tmp = mmap((void *)0, size___20, 3, 34, 0, (__off_t )0);
#line 1001
  mem___0 = (char *)tmp;
  }
#line 1003
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 1004
    mem___0 = (char *)((void *)0);
  } else {
    {
#line 1006
    dombind((void *)mem___0, size___20, bind_policy, bmp);
    }
  }
  {
#line 1007
  numa_bitmask_free(bmp);
  }
#line 1008
  return ((void *)mem___0);
}
}
#line 1011 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void *numa_alloc_local(size_t size___20 ) 
{ 
  char *mem___0 ;
  void *tmp ;

  {
  {
#line 1014
  tmp = mmap((void *)0, size___20, 3, 34, 0, (__off_t )0);
#line 1014
  mem___0 = (char *)tmp;
  }
#line 1016
  if ((unsigned long )mem___0 == (unsigned long )((char *)-1)) {
#line 1017
    mem___0 = (char *)((void *)0);
  } else {
    {
#line 1019
    dombind((void *)mem___0, size___20, 1, (struct bitmask *)((void *)0));
    }
  }
#line 1020
  return ((void *)mem___0);
}
}
#line 1023 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_bind_policy(int strict ) 
{ 


  {
#line 1025
  if (strict) {
#line 1026
    bind_policy = 2;
  } else {
#line 1028
    bind_policy = 1;
  }
#line 1029
  return;
}
}
#line 1031 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_membind_v1(nodemask_t const   *mask ) 
{ 
  struct bitmask bitmask ;

  {
  {
#line 1036
  bitmask.maskp = (unsigned long *)mask;
#line 1037
  bitmask.size = sizeof(nodemask_t );
#line 1038
  setpol(2, & bitmask);
  }
#line 1039
  return;
}
}
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1042 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_membind_v2(struct bitmask *bmp ) 
{ 


  {
  {
#line 1045
  setpol(2, bmp);
  }
#line 1046
  return;
}
}
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1049
extern void numa_set_membind_v2_int(struct bitmask *bmp )  __attribute__((__visibility__("hidden"))) ;
#line 1049 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern void numa_set_membind_v2_int(struct bitmask *bmp ) 
{ 


  {
  {
#line 1049
  numa_set_membind_v2(bmp);
  }
#line 1049
  return;
}
}
#line 1054 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void copy_bitmask_to_nodemask(struct bitmask *bmp , nodemask_t *nmp ) 
{ 
  int max ;
  int i ;
  int tmp ;

  {
  {
#line 1059
  memset((void *)nmp, 0, sizeof(nodemask_t ));
#line 1060
  max = (int )(sizeof(nodemask_t ) * 8UL);
#line 1061
  i = 0;
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    if (! ((unsigned long )i < bmp->size)) {
#line 1061
      goto while_break;
    }
#line 1062
    if (i >= max) {
#line 1063
      goto while_break;
    }
    {
#line 1064
    tmp = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1064
    if (tmp) {
      {
#line 1065
      nodemask_set_compat(nmp, i);
      }
    }
#line 1061
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  return;
}
}
#line 1073 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void copy_bitmask_to_bitmask(struct bitmask *bmpfrom , struct bitmask *bmpto ) 
{ 
  int bytes___1 ;

  {
#line 1078
  if (bmpfrom->size >= bmpto->size) {
    {
#line 1079
    memcpy((void */* __restrict  */)bmpto->maskp, (void const   */* __restrict  */)bmpfrom->maskp,
           (((bmpto->size + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
    }
  } else
#line 1080
  if (bmpfrom->size < bmpto->size) {
    {
#line 1081
    bytes___1 = (int )((((bmpfrom->size + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
#line 1082
    memcpy((void */* __restrict  */)bmpto->maskp, (void const   */* __restrict  */)bmpfrom->maskp,
           (size_t )bytes___1);
#line 1083
    memset((void *)((char *)bmpto->maskp + bytes___1), 0, (((bmpto->size + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL - (unsigned long )bytes___1);
    }
  }
#line 1086
  return;
}
}
#line 1091 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void copy_nodemask_to_bitmask(nodemask_t *nmp , struct bitmask *bmp ) 
{ 
  int max ;
  int i ;
  int tmp ;

  {
  {
#line 1096
  numa_bitmask_clearall(bmp);
#line 1097
  max = (int )(sizeof(nodemask_t ) * 8UL);
  }
#line 1098
  if ((unsigned long )max > bmp->size) {
#line 1099
    max = (int )bmp->size;
  }
#line 1100
  i = 0;
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! (i < max)) {
#line 1100
      goto while_break;
    }
    {
#line 1101
    tmp = nodemask_isset_compat((nodemask_t const   *)nmp, i);
    }
#line 1101
    if (tmp) {
      {
#line 1102
      numa_bitmask_setbit(bmp, (unsigned int )i);
      }
    }
#line 1100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  return;
}
}
#line 1106 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
nodemask_t numa_get_membind_v1(void) 
{ 
  int oldpolicy ;
  struct bitmask *bmp ;
  nodemask_t nmp ;

  {
  {
#line 1113
  bmp = allocate_nodemask_v1();
#line 1114
  getpol(& oldpolicy, bmp);
  }
#line 1115
  if (oldpolicy == 2) {
    {
#line 1116
    copy_bitmask_to_nodemask(bmp, & nmp);
    }
  } else {
    {
#line 1119
    copy_bitmask_to_nodemask(bmp, & numa_all_nodes);
#line 1120
    nmp = numa_all_nodes;
    }
  }
  {
#line 1122
  numa_bitmask_free(bmp);
  }
#line 1123
  return (nmp);
}
}
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1127 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_get_membind_v2(void) 
{ 
  int oldpolicy ;
  struct bitmask *bmp ;

  {
  {
#line 1133
  bmp = numa_allocate_nodemask();
#line 1134
  getpol(& oldpolicy, bmp);
  }
#line 1135
  if (oldpolicy != 2) {
    {
#line 1136
    copy_bitmask_to_bitmask(numa_all_nodes_ptr, bmp);
    }
  }
#line 1137
  return (bmp);
}
}
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1142 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_get_mems_allowed(void) 
{ 
  struct bitmask *bmp ;
  long tmp ;

  {
  {
#line 1149
  bmp = numa_allocate_nodemask();
#line 1150
  tmp = get_mempolicy((int *)((void *)0), (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 1 << 2);
  }
#line 1150
  if (tmp < 0L) {
    {
#line 1152
    numa_error((char *)"get_mempolicy");
    }
  }
#line 1153
  return (bmp);
}
}
#line 1155
extern struct bitmask *numa_get_mems_allowed_int(void)  __attribute__((__visibility__("hidden"))) ;
#line 1155 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern struct bitmask *numa_get_mems_allowed_int(void) 
{ 
  struct bitmask *tmp ;

  {
  {
#line 1155
  tmp = numa_get_mems_allowed();
  }
#line 1155
  return (tmp);
}
}
#line 1158 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_free(void *mem___0 , size_t size___20 ) 
{ 


  {
  {
#line 1160
  munmap(mem___0, size___20);
  }
#line 1161
  return;
}
}
#line 1163 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_parse_bitmap_v1(char *line , unsigned long *mask , int ncpus ) 
{ 
  int i ;
  char *p ;
  char *tmp ;
  char *oldp ;
  char *endp ;

  {
  {
#line 1167
  tmp = strchr((char const   *)line, '\n');
#line 1167
  p = tmp;
  }
#line 1168
  if (! p) {
#line 1169
    return (-1);
  }
#line 1171
  i = 0;
  {
#line 1171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1171
    if (! ((unsigned long )p > (unsigned long )line)) {
#line 1171
      goto while_break;
    }
#line 1173
    oldp = p;
#line 1174
    if ((int )*p == 44) {
#line 1175
      p --;
    }
    {
#line 1176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1176
      if ((unsigned long )p > (unsigned long )line) {
#line 1176
        if (! ((int )*p != 44)) {
#line 1176
          goto while_break___0;
        }
      } else {
#line 1176
        goto while_break___0;
      }
#line 1177
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1179
    if ((unsigned long )p > (unsigned long )line) {
#line 1179
      if (sizeof(unsigned long ) == 8UL) {
        {
#line 1180
        oldp --;
#line 1181
        memmove((void *)p, (void const   *)(p + 1), (size_t )((oldp - p) + 1L));
        }
        {
#line 1182
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1182
          if ((unsigned long )p > (unsigned long )line) {
#line 1182
            if (! ((int )*p != 44)) {
#line 1182
              goto while_break___1;
            }
          } else {
#line 1182
            goto while_break___1;
          }
#line 1183
          p --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1185
    if ((int )*p == 44) {
#line 1186
      p ++;
    }
#line 1187
    if ((unsigned long )i >= (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long )) {
#line 1188
      return (-1);
    }
    {
#line 1189
    *(mask + i) = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& endp),
                          16);
    }
#line 1190
    if ((unsigned long )endp != (unsigned long )oldp) {
#line 1191
      return (-1);
    }
#line 1192
    p --;
#line 1171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1194
  return (0);
}
}
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1198 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_parse_bitmap_v2(char *line , struct bitmask *mask ) 
{ 
  int i ;
  int ncpus ;
  char *p ;
  char *tmp ;
  char *oldp ;
  char *endp ;

  {
  {
#line 1202
  tmp = strchr((char const   *)line, '\n');
#line 1202
  p = tmp;
  }
#line 1203
  if (! p) {
#line 1204
    return (-1);
  }
#line 1205
  ncpus = (int )mask->size;
#line 1207
  i = 0;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! ((unsigned long )p > (unsigned long )line)) {
#line 1207
      goto while_break;
    }
#line 1209
    oldp = p;
#line 1210
    if ((int )*p == 44) {
#line 1211
      p --;
    }
    {
#line 1212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1212
      if ((unsigned long )p > (unsigned long )line) {
#line 1212
        if (! ((int )*p != 44)) {
#line 1212
          goto while_break___0;
        }
      } else {
#line 1212
        goto while_break___0;
      }
#line 1213
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1215
    if ((unsigned long )p > (unsigned long )line) {
#line 1215
      if (sizeof(unsigned long ) == 8UL) {
        {
#line 1216
        oldp --;
#line 1217
        memmove((void *)p, (void const   *)(p + 1), (size_t )((oldp - p) + 1L));
        }
        {
#line 1218
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1218
          if ((unsigned long )p > (unsigned long )line) {
#line 1218
            if (! ((int )*p != 44)) {
#line 1218
              goto while_break___1;
            }
          } else {
#line 1218
            goto while_break___1;
          }
#line 1219
          p --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1221
    if ((int )*p == 44) {
#line 1222
      p ++;
    }
#line 1223
    if ((unsigned long )i >= (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long )) {
#line 1224
      return (-1);
    }
    {
#line 1225
    *(mask->maskp + i) = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& endp),
                                 16);
    }
#line 1226
    if ((unsigned long )endp != (unsigned long )oldp) {
#line 1227
      return (-1);
    }
#line 1228
    p --;
#line 1207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1230
  return (0);
}
}
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1234 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void init_node_cpu_mask_v2(void) 
{ 
  int nnodes ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1237
  tmp = numa_max_possible_node_v2_int();
#line 1237
  nnodes = tmp + 1;
#line 1238
  tmp___0 = calloc((size_t )nnodes, sizeof(struct bitmask *));
#line 1238
  node_cpu_mask_v2 = (struct bitmask **)tmp___0;
  }
#line 1239
  return;
}
}
#line 1243 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_node_to_cpus_v1(int node , unsigned long *buffer , int bufferlen ) 
{ 
  int err ;
  char fn[64] ;
  FILE *f ;
  char *line ;
  size_t len ;
  struct bitmask bitmask ;
  int buflen_needed ;
  unsigned long *mask ;
  int ncpus ;
  int tmp ;
  int maxnode ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1246
  err = 0;
#line 1249
  line = (char *)((void *)0);
#line 1250
  len = (size_t )0;
#line 1254
  tmp = numa_num_possible_cpus();
#line 1254
  ncpus = tmp;
#line 1255
  tmp___0 = numa_max_node_int();
#line 1255
  maxnode = tmp___0;
#line 1257
  buflen_needed = (int )(((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
  }
#line 1258
  if ((unsigned int )node > (unsigned int )maxnode) {
    {
#line 1259
    tmp___1 = __errno_location();
#line 1259
    *tmp___1 = 34;
    }
#line 1260
    return (-1);
  } else
#line 1258
  if (bufferlen < buflen_needed) {
    {
#line 1259
    tmp___1 = __errno_location();
#line 1259
    *tmp___1 = 34;
    }
#line 1260
    return (-1);
  }
#line 1262
  if (bufferlen > buflen_needed) {
    {
#line 1263
    memset((void *)buffer, 0, (size_t )bufferlen);
    }
  }
#line 1264
  if (node_cpu_mask_v1[node]) {
    {
#line 1265
    memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)node_cpu_mask_v1[node],
           (size_t )buflen_needed);
    }
#line 1266
    return (0);
  }
  {
#line 1269
  tmp___2 = malloc((size_t )buflen_needed);
#line 1269
  mask = (unsigned long *)tmp___2;
  }
#line 1270
  if (! mask) {
#line 1271
    mask = buffer;
  }
  {
#line 1272
  memset((void *)mask, 0, (size_t )buflen_needed);
#line 1274
  sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/cpumap",
          node);
#line 1275
  f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
  }
#line 1276
  if (! f) {
#line 1276
    goto _L;
  } else {
    {
#line 1276
    tmp___5 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                       '\n', (FILE */* __restrict  */)f);
    }
#line 1276
    if (tmp___5 < 1L) {
      _L: /* CIL Label */ 
      {
#line 1277
      tmp___3 = __errno_location();
#line 1277
      tmp___4 = strerror(*tmp___3);
#line 1277
      numa_warn(3, (char *)"/sys not mounted or invalid. Assuming one node: %s", tmp___4);
#line 1280
      numa_warn(3, (char *)"(cannot open or correctly parse %s)", fn);
#line 1282
      bitmask.maskp = mask;
#line 1283
      bitmask.size = (unsigned long )(buflen_needed * 8);
#line 1284
      numa_bitmask_setall(& bitmask);
#line 1285
      err = -1;
      }
    }
  }
#line 1287
  if (f) {
    {
#line 1288
    fclose(f);
    }
  }
#line 1290
  if (line) {
    {
#line 1290
    tmp___6 = numa_parse_bitmap_v1(line, mask, ncpus);
    }
#line 1290
    if (tmp___6 < 0) {
      {
#line 1291
      numa_warn(4, (char *)"Cannot parse cpumap. Assuming one node");
#line 1292
      bitmask.maskp = mask;
#line 1293
      bitmask.size = (unsigned long )(buflen_needed * 8);
#line 1294
      numa_bitmask_setall(& bitmask);
#line 1295
      err = -1;
      }
    }
  }
  {
#line 1298
  free((void *)line);
#line 1299
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)mask, (size_t )buflen_needed);
  }
#line 1302
  if (node_cpu_mask_v1[node]) {
#line 1303
    if ((unsigned long )mask != (unsigned long )buffer) {
      {
#line 1304
      free((void *)mask);
      }
    }
  } else {
#line 1306
    node_cpu_mask_v1[node] = mask;
  }
#line 1308
  return (err);
}
}
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1320 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_node_to_cpus_v2(int node , struct bitmask *buffer ) 
{ 
  int err ;
  int nnodes ;
  int tmp ;
  char fn[64] ;
  char *line ;
  FILE *f ;
  size_t len ;
  struct bitmask *mask ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __ssize_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1323
  err = 0;
#line 1324
  tmp = numa_max_node();
#line 1324
  nnodes = tmp;
#line 1325
  line = (char *)((void *)0);
#line 1327
  len = (size_t )0;
  }
#line 1330
  if (! node_cpu_mask_v2) {
    {
#line 1331
    init_node_cpu_mask_v2();
    }
  }
#line 1333
  if (node > nnodes) {
    {
#line 1334
    tmp___0 = __errno_location();
#line 1334
    *tmp___0 = 34;
    }
#line 1335
    return (-1);
  }
  {
#line 1337
  numa_bitmask_clearall(buffer);
  }
#line 1339
  if (*(node_cpu_mask_v2 + node)) {
#line 1341
    if (buffer->size < (*(node_cpu_mask_v2 + node))->size) {
      {
#line 1342
      numa_error((char *)"map size mismatch; abort\n");
      }
#line 1343
      return (-1);
    }
    {
#line 1345
    copy_bitmask_to_bitmask(*(node_cpu_mask_v2 + node), buffer);
    }
#line 1346
    return (0);
  }
  {
#line 1350
  mask = numa_allocate_cpumask();
#line 1353
  sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/cpumap",
          node);
#line 1354
  f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
  }
#line 1355
  if (! f) {
#line 1355
    goto _L;
  } else {
    {
#line 1355
    tmp___3 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                       '\n', (FILE */* __restrict  */)f);
    }
#line 1355
    if (tmp___3 < 1L) {
      _L: /* CIL Label */ 
      {
#line 1356
      tmp___1 = __errno_location();
#line 1356
      tmp___2 = strerror(*tmp___1);
#line 1356
      numa_warn(3, (char *)"/sys not mounted or invalid. Assuming one node: %s", tmp___2);
#line 1359
      numa_warn(3, (char *)"(cannot open or correctly parse %s)", fn);
#line 1361
      numa_bitmask_setall(mask);
#line 1362
      err = -1;
      }
    }
  }
#line 1364
  if (f) {
    {
#line 1365
    fclose(f);
    }
  }
#line 1367
  if (line) {
    {
#line 1367
    tmp___4 = numa_parse_bitmap_v2(line, mask);
    }
#line 1367
    if (tmp___4 < 0) {
      {
#line 1368
      numa_warn(4, (char *)"Cannot parse cpumap. Assuming one node");
#line 1369
      numa_bitmask_setall(mask);
#line 1370
      err = -1;
      }
    }
  }
  {
#line 1373
  free((void *)line);
#line 1374
  copy_bitmask_to_bitmask(mask, buffer);
  }
#line 1378
  if (*(node_cpu_mask_v2 + node)) {
#line 1380
    if ((unsigned long )mask != (unsigned long )buffer) {
      {
#line 1381
      numa_bitmask_free(mask);
      }
    }
  } else {
#line 1383
    *(node_cpu_mask_v2 + node) = mask;
  }
#line 1385
  return (err);
}
}
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1389
extern int numa_node_to_cpus_v1_int(int node , unsigned long *buffer , int bufferlen )  __attribute__((__visibility__("hidden"))) ;
#line 1389 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_node_to_cpus_v1_int(int node , unsigned long *buffer , int bufferlen ) 
{ 
  int tmp ;

  {
  {
#line 1389
  tmp = numa_node_to_cpus_v1(node, buffer, bufferlen);
  }
#line 1389
  return (tmp);
}
}
#line 1390
extern int numa_node_to_cpus_v2_int(int node , struct bitmask *buffer )  __attribute__((__visibility__("hidden"))) ;
#line 1390 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_node_to_cpus_v2_int(int node , struct bitmask *buffer ) 
{ 
  int tmp ;

  {
  {
#line 1390
  tmp = numa_node_to_cpus_v2(node, buffer);
  }
#line 1390
  return (tmp);
}
}
#line 1393 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_node_of_cpu(int cpu ) 
{ 
  struct bitmask *bmp ;
  int ncpus ;
  int nnodes ;
  int node ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1398
  ncpus = numa_num_possible_cpus();
  }
#line 1399
  if (cpu > ncpus) {
    {
#line 1400
    tmp = __errno_location();
#line 1400
    *tmp = 22;
    }
#line 1401
    return (-1);
  }
  {
#line 1403
  bmp = numa_bitmask_alloc((unsigned int )ncpus);
#line 1404
  nnodes = numa_max_node();
#line 1405
  node = 0;
  }
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (node <= nnodes)) {
#line 1405
      goto while_break;
    }
    {
#line 1406
    numa_node_to_cpus_v2_int(node, bmp);
#line 1407
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )cpu);
    }
#line 1407
    if (tmp___0) {
#line 1408
      ret = node;
#line 1409
      goto end;
    }
#line 1405
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1412
  ret = -1;
#line 1413
  tmp___1 = __errno_location();
#line 1413
  *tmp___1 = 22;
  }
  end: 
  {
#line 1415
  numa_bitmask_free(bmp);
  }
#line 1416
  return (ret);
}
}
#line 1448
int numa_run_on_node_mask_v1(nodemask_t const   *mask ) ;
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size  =    -1;
#line 1420 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_run_on_node_mask_v1(nodemask_t const   *mask ) 
{ 
  int ncpus ;
  int tmp ;
  int i ;
  int k ;
  int err ;
  unsigned long *cpus ;
  unsigned long __lengthofcpus ;
  void *tmp___0 ;
  unsigned long *nodecpus ;
  unsigned long __lengthofnodecpus ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int savederrno ;
  int *tmp___4 ;
  char *bigbuf ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
  {
#line 1423
  tmp = numa_num_possible_cpus();
#line 1423
  ncpus = tmp;
#line 1425
  __lengthofcpus = (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long );
#line 1425
  tmp___0 = __builtin_alloca(sizeof(*cpus) * __lengthofcpus);
#line 1425
  cpus = (unsigned long *)tmp___0;
#line 1425
  __lengthofnodecpus = (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long );
#line 1425
  tmp___1 = __builtin_alloca(sizeof(*nodecpus) * __lengthofnodecpus);
#line 1425
  nodecpus = (unsigned long *)tmp___1;
#line 1426
  memset((void *)cpus, 0, ((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
#line 1427
  i = 0;
  }
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (i < 128)) {
#line 1427
      goto while_break;
    }
#line 1428
    if (mask->n[(unsigned long )i / (sizeof(unsigned long ) * 8UL)] == 0UL) {
#line 1429
      goto __Cont;
    }
    {
#line 1430
    tmp___3 = nodemask_isset_compat(mask, i);
    }
#line 1430
    if (tmp___3) {
      {
#line 1431
      tmp___2 = numa_node_to_cpus_v1_int(i, nodecpus, (int )(((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL));
      }
#line 1431
      if (tmp___2 < 0) {
        {
#line 1432
        numa_warn(6, (char *)"Cannot read node cpumask from sysfs");
        }
#line 1434
        goto __Cont;
      }
#line 1436
      k = 0;
      {
#line 1436
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1436
        if (! ((unsigned long )k < (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long ))) {
#line 1436
          goto while_break___0;
        }
#line 1437
        *(cpus + k) |= *(nodecpus + k);
#line 1436
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1440
  err = numa_sched_setaffinity_v1(0, (unsigned int )(((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL),
                                  (unsigned long const   *)cpus);
  }
#line 1445
  if (err < 0) {
    {
#line 1445
    tmp___11 = __errno_location();
    }
#line 1445
    if (*tmp___11 == 22) {
      {
#line 1446
      tmp___4 = __errno_location();
#line 1446
      savederrno = *tmp___4;
      }
#line 1449
      if (size == -1) {
#line 1450
        size = (int )((((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) * 2UL);
      }
      {
#line 1451
      tmp___5 = malloc((size_t )4096);
#line 1451
      bigbuf = (char *)tmp___5;
      }
#line 1452
      if (! bigbuf) {
        {
#line 1453
        tmp___6 = __errno_location();
#line 1453
        *tmp___6 = 12;
        }
#line 1454
        return (-1);
      }
      {
#line 1456
      tmp___7 = __errno_location();
#line 1456
      *tmp___7 = savederrno;
      }
      {
#line 1457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1457
        if (! (size <= 4096)) {
#line 1457
          goto while_break___1;
        }
        {
#line 1458
        memcpy((void */* __restrict  */)bigbuf, (void const   */* __restrict  */)cpus,
               ((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
#line 1459
        memset((void *)(bigbuf + ((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL),
               0, 4096UL - ((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL);
#line 1461
        err = numa_sched_setaffinity_v1_int(0, (unsigned int )size, (unsigned long const   *)((unsigned long *)bigbuf));
        }
#line 1462
        if (err == 0) {
#line 1463
          goto while_break___1;
        } else {
          {
#line 1462
          tmp___8 = __errno_location();
          }
#line 1462
          if (*tmp___8 != 22) {
#line 1463
            goto while_break___1;
          }
        }
#line 1464
        size *= 2;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1466
      tmp___9 = __errno_location();
#line 1466
      savederrno = *tmp___9;
#line 1467
      free((void *)bigbuf);
#line 1468
      tmp___10 = __errno_location();
#line 1468
      *tmp___10 = savederrno;
      }
    }
  }
#line 1470
  return (err);
}
}
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1479 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_run_on_node_mask_v2(struct bitmask *bmp ) 
{ 
  int ncpus ;
  int i ;
  int k ;
  int err ;
  struct bitmask *cpus ;
  struct bitmask *nodecpus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1485
  cpus = numa_allocate_cpumask();
#line 1486
  ncpus = (int )cpus->size;
#line 1487
  nodecpus = numa_allocate_cpumask();
#line 1489
  i = 0;
  }
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1489
    if (! ((unsigned long )i < bmp->size)) {
#line 1489
      goto while_break;
    }
#line 1490
    if (*(bmp->maskp + (unsigned long )i / (sizeof(unsigned long ) * 8UL)) == 0UL) {
#line 1491
      goto __Cont;
    }
    {
#line 1492
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1492
    if (tmp___1) {
      {
#line 1497
      tmp = numa_bitmask_isbitset((struct bitmask  const  *)numa_all_nodes_ptr, (unsigned int )i);
      }
#line 1497
      if (! tmp) {
        {
#line 1498
        numa_warn(6, (char *)"node %d not allowed", i);
        }
#line 1500
        goto __Cont;
      }
      {
#line 1502
      tmp___0 = numa_node_to_cpus_v2_int(i, nodecpus);
      }
#line 1502
      if (tmp___0 < 0) {
        {
#line 1503
        numa_warn(6, (char *)"Cannot read node cpumask from sysfs");
        }
#line 1505
        goto __Cont;
      }
#line 1507
      k = 0;
      {
#line 1507
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1507
        if (! ((unsigned long )k < (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long ))) {
#line 1507
          goto while_break___0;
        }
#line 1508
        *(cpus->maskp + k) |= *(nodecpus->maskp + k);
#line 1507
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1511
  err = numa_sched_setaffinity_v2_int(0, cpus);
#line 1513
  numa_bitmask_free(cpus);
#line 1514
  numa_bitmask_free(nodecpus);
  }
#line 1517
  if (err < 0) {
    {
#line 1518
    numa_error((char *)"numa_sched_setaffinity_v2_int() failed; abort\n");
    }
  }
#line 1521
  return (err);
}
}
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1525
extern int numa_run_on_node_mask_v2_int(struct bitmask *bmp )  __attribute__((__visibility__("hidden"))) ;
#line 1525 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
extern int numa_run_on_node_mask_v2_int(struct bitmask *bmp ) 
{ 
  int tmp ;

  {
  {
#line 1525
  tmp = numa_run_on_node_mask_v2(bmp);
  }
#line 1525
  return (tmp);
}
}
#line 1532 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_run_on_node_mask_all(struct bitmask *bmp ) 
{ 
  int ncpus ;
  int i ;
  int k ;
  int err ;
  struct bitmask *cpus ;
  struct bitmask *nodecpus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1538
  cpus = numa_allocate_cpumask();
#line 1539
  ncpus = (int )cpus->size;
#line 1540
  nodecpus = numa_allocate_cpumask();
#line 1542
  i = 0;
  }
  {
#line 1542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1542
    if (! ((unsigned long )i < bmp->size)) {
#line 1542
      goto while_break;
    }
#line 1543
    if (*(bmp->maskp + (unsigned long )i / (sizeof(unsigned long ) * 8UL)) == 0UL) {
#line 1544
      goto __Cont;
    }
    {
#line 1545
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1545
    if (tmp___1) {
      {
#line 1546
      tmp = numa_bitmask_isbitset((struct bitmask  const  *)numa_possible_nodes_ptr,
                                  (unsigned int )i);
      }
#line 1546
      if (! tmp) {
        {
#line 1547
        numa_warn(6, (char *)"node %d not allowed", i);
        }
#line 1549
        goto __Cont;
      }
      {
#line 1551
      tmp___0 = numa_node_to_cpus_v2_int(i, nodecpus);
      }
#line 1551
      if (tmp___0 < 0) {
        {
#line 1552
        numa_warn(6, (char *)"Cannot read node cpumask from sysfs");
        }
#line 1554
        goto __Cont;
      }
#line 1556
      k = 0;
      {
#line 1556
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1556
        if (! ((unsigned long )k < (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long ))) {
#line 1556
          goto while_break___0;
        }
#line 1557
        *(cpus->maskp + k) |= *(nodecpus->maskp + k);
#line 1556
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1542
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1560
  err = numa_sched_setaffinity_v2_int(0, cpus);
#line 1562
  numa_bitmask_free(cpus);
#line 1563
  numa_bitmask_free(nodecpus);
  }
#line 1566
  if (err < 0) {
    {
#line 1567
    numa_error((char *)"numa_sched_setaffinity_v2_int() failed; abort\n");
    }
  }
#line 1570
  return (err);
}
}
#line 1573 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
nodemask_t numa_get_run_node_mask_v1(void) 
{ 
  int ncpus ;
  int tmp ;
  int i ;
  int k ;
  int max ;
  int tmp___0 ;
  struct bitmask *bmp ;
  struct bitmask *cpus ;
  struct bitmask *nodecpus ;
  nodemask_t nmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1576
  tmp = numa_num_configured_cpus();
#line 1576
  ncpus = tmp;
#line 1578
  tmp___0 = numa_max_node_int();
#line 1578
  max = tmp___0;
#line 1582
  cpus = numa_allocate_cpumask();
#line 1583
  tmp___1 = numa_sched_getaffinity_v2_int(0, cpus);
  }
#line 1583
  if (tmp___1 < 0) {
#line 1584
    nmp = numa_no_nodes;
#line 1585
    goto free_cpus;
  }
  {
#line 1588
  nodecpus = numa_allocate_cpumask();
#line 1589
  bmp = allocate_nodemask_v1();
#line 1590
  i = 0;
  }
  {
#line 1590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1590
    if (! (i <= max)) {
#line 1590
      goto while_break;
    }
    {
#line 1591
    tmp___2 = numa_node_to_cpus_v2_int(i, nodecpus);
    }
#line 1591
    if (tmp___2 < 0) {
#line 1593
      goto __Cont;
    }
#line 1595
    k = 0;
    {
#line 1595
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1595
      if (! ((unsigned long )k < (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long ))) {
#line 1595
        goto while_break___0;
      }
#line 1596
      if (*(nodecpus->maskp + k) & *(cpus->maskp + k)) {
        {
#line 1597
        numa_bitmask_setbit(bmp, (unsigned int )i);
        }
      }
#line 1595
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1590
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1600
  copy_bitmask_to_nodemask(bmp, & nmp);
#line 1601
  numa_bitmask_free(bmp);
#line 1602
  numa_bitmask_free(nodecpus);
  }
  free_cpus: 
  {
#line 1604
  numa_bitmask_free(cpus);
  }
#line 1605
  return (nmp);
}
}
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1609 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_get_run_node_mask_v2(void) 
{ 
  int i ;
  int k ;
  int ncpus ;
  int tmp ;
  int max ;
  int tmp___0 ;
  struct bitmask *bmp ;
  struct bitmask *cpus ;
  struct bitmask *nodecpus ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1613
  tmp = numa_num_configured_cpus();
#line 1613
  ncpus = tmp;
#line 1614
  tmp___0 = numa_max_node_int();
#line 1614
  max = tmp___0;
#line 1618
  bmp = numa_allocate_cpumask();
#line 1619
  cpus = numa_allocate_cpumask();
#line 1620
  tmp___1 = numa_sched_getaffinity_v2_int(0, cpus);
  }
#line 1620
  if (tmp___1 < 0) {
    {
#line 1621
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, bmp);
    }
#line 1622
    goto free_cpus;
  }
  {
#line 1625
  nodecpus = numa_allocate_cpumask();
#line 1626
  i = 0;
  }
  {
#line 1626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1626
    if (! (i <= max)) {
#line 1626
      goto while_break;
    }
    {
#line 1631
    tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_all_nodes_ptr,
                                    (unsigned int )i);
    }
#line 1631
    if (! tmp___2) {
#line 1632
      goto __Cont;
    }
    {
#line 1634
    tmp___3 = numa_node_to_cpus_v2_int(i, nodecpus);
    }
#line 1634
    if (tmp___3 < 0) {
#line 1636
      goto __Cont;
    }
#line 1638
    k = 0;
    {
#line 1638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1638
      if (! ((unsigned long )k < (((((unsigned long )ncpus + sizeof(unsigned long ) * 8UL) - 1UL) & ~ (sizeof(unsigned long ) * 8UL - 1UL)) / 8UL) / sizeof(long ))) {
#line 1638
        goto while_break___0;
      }
#line 1639
      if (*(nodecpus->maskp + k) & *(cpus->maskp + k)) {
        {
#line 1640
        numa_bitmask_setbit(bmp, (unsigned int )i);
        }
      }
#line 1638
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1626
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1643
  numa_bitmask_free(nodecpus);
  }
  free_cpus: 
  {
#line 1645
  numa_bitmask_free(cpus);
  }
#line 1646
  return (bmp);
}
}
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1650 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_migrate_pages(int pid , struct bitmask *fromnodes , struct bitmask *tonodes ) 
{ 
  int numa_num_nodes ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 1653
  tmp = numa_num_possible_nodes();
#line 1653
  numa_num_nodes = tmp;
#line 1655
  tmp___0 = migrate_pages(pid, (unsigned long )(numa_num_nodes + 1), (unsigned long const   *)fromnodes->maskp,
                          (unsigned long const   *)tonodes->maskp);
  }
#line 1655
  return ((int )tmp___0);
}
}
#line 1659 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_move_pages(int pid , unsigned long count , void **pages___0 , int const   *nodes ,
                    int *status , int flags ) 
{ 
  long tmp ;

  {
  {
#line 1662
  tmp = move_pages(pid, count, pages___0, nodes, status, flags);
  }
#line 1662
  return ((int )tmp);
}
}
#line 1665 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_run_on_node(int node ) 
{ 
  int numa_num_nodes ;
  int tmp ;
  int ret ;
  struct bitmask *cpus ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1667
  tmp = numa_num_possible_nodes();
#line 1667
  numa_num_nodes = tmp;
#line 1668
  ret = -1;
  }
#line 1671
  if (node >= numa_num_nodes) {
    {
#line 1672
    tmp___0 = __errno_location();
#line 1672
    *tmp___0 = 22;
    }
#line 1673
    goto out;
  }
  {
#line 1676
  cpus = numa_allocate_cpumask();
  }
#line 1678
  if (node == -1) {
    {
#line 1679
    numa_bitmask_setall(cpus);
    }
  } else {
    {
#line 1680
    tmp___1 = numa_node_to_cpus_v2_int(node, cpus);
    }
#line 1680
    if (tmp___1 < 0) {
      {
#line 1681
      numa_warn(6, (char *)"Cannot read node cpumask from sysfs");
      }
#line 1682
      goto free;
    }
  }
  {
#line 1685
  ret = numa_sched_setaffinity_v2_int(0, cpus);
  }
  free: 
  {
#line 1687
  numa_bitmask_free(cpus);
  }
  out: 
#line 1689
  return (ret);
}
}
#line 1692 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
int numa_preferred(void) 
{ 
  int policy___0 ;
  int ret ;
  struct bitmask *bmp ;
  int i ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1698
  bmp = numa_allocate_nodemask();
#line 1699
  getpol(& policy___0, bmp);
  }
#line 1700
  if (policy___0 == 1) {
#line 1700
    goto _L;
  } else
#line 1700
  if (policy___0 == 2) {
    _L: /* CIL Label */ 
    {
#line 1702
    tmp = numa_num_possible_nodes();
#line 1702
    max = tmp;
#line 1703
    i = 0;
    }
    {
#line 1703
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1703
      if (! (i < max)) {
#line 1703
        goto while_break;
      }
      {
#line 1704
      tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
      }
#line 1704
      if (tmp___0) {
#line 1705
        ret = i;
#line 1706
        goto end;
      }
#line 1703
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1711
  ret = 0;
  end: 
  {
#line 1713
  numa_bitmask_free(bmp);
  }
#line 1714
  return (ret);
}
}
#line 1717 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_preferred(int node ) 
{ 
  struct bitmask *bmp ;

  {
  {
#line 1721
  bmp = numa_allocate_nodemask();
  }
#line 1722
  if (node >= 0) {
    {
#line 1723
    numa_bitmask_setbit(bmp, (unsigned int )node);
#line 1724
    setpol(1, bmp);
    }
  } else {
    {
#line 1726
    setpol(0, bmp);
    }
  }
  {
#line 1727
  numa_bitmask_free(bmp);
  }
#line 1728
  return;
}
}
#line 1730 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_localalloc(void) 
{ 


  {
  {
#line 1732
  setpol(0, numa_no_nodes_ptr);
  }
#line 1733
  return;
}
}
#line 1735 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_bind_v1(nodemask_t const   *nodemask___0 ) 
{ 
  struct bitmask bitmask ;

  {
  {
#line 1739
  bitmask.maskp = (unsigned long *)nodemask___0;
#line 1740
  bitmask.size = sizeof(nodemask_t );
#line 1741
  numa_run_on_node_mask_v2_int(& bitmask);
#line 1742
  numa_set_membind_v2_int(& bitmask);
  }
#line 1743
  return;
}
}
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1746 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_bind_v2(struct bitmask *bmp ) 
{ 


  {
  {
#line 1748
  numa_run_on_node_mask_v2_int(bmp);
#line 1749
  numa_set_membind_v2_int(bmp);
  }
#line 1750
  return;
}
}
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1753 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
void numa_set_strict(int flag ) 
{ 


  {
#line 1755
  if (flag) {
#line 1756
    mbind_flags |= 1U;
  } else {
#line 1758
    mbind_flags &= 4294967294U;
  }
#line 1759
  return;
}
}
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr(char const   *s , char **end___0 , struct bitmask *bmp ,
                            int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1891 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_parse_nodestring(char const   *s ) 
{ 
  struct bitmask *tmp ;

  {
  {
#line 1893
  tmp = __numa_parse_nodestring(s, numa_all_nodes_ptr);
  }
#line 1893
  return (tmp);
}
}
#line 1901 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_parse_nodestring_all(char const   *s ) 
{ 
  struct bitmask *tmp ;

  {
  {
#line 1903
  tmp = __numa_parse_nodestring(s, numa_possible_nodes_ptr);
  }
#line 1903
  return (tmp);
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 2004 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_parse_cpustring(char const   *s ) 
{ 
  struct bitmask *tmp ;

  {
  {
#line 2006
  tmp = __numa_parse_cpustring(s, numa_all_cpus_ptr);
  }
#line 2006
  return (tmp);
}
}
#line 2014 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
struct bitmask *numa_parse_cpustring_all(char const   *s ) 
{ 
  struct bitmask *tmp ;

  {
  {
#line 2016
  tmp = __numa_parse_cpustring(s, numa_possible_cpus_ptr);
  }
#line 2016
  return (tmp);
}
}
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 809 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 183 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 2 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/sysfs.h"
char __attribute__((__visibility__("hidden")))  *sysfs_read(char *name ) ;
#line 3
int __attribute__((__visibility__("hidden")))  sysfs_node_read(struct bitmask *mask ,
                                                               char *fmt  , ...) ;
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 324 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
int __attribute__((__visibility__("hidden")))  resolve_affinity(char const   *id ,
                                                                struct bitmask *mask ) 
{ 
  struct handler *h ;
  int len ;
  size_t tmp ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 328
  h = & handlers[0];
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! h->first) {
#line 328
      goto while_break;
    }
#line 330
    if ((int const   )*(id + 0) != (int const   )h->first) {
#line 331
      goto __Cont;
    }
    {
#line 332
    tmp = strlen((char const   *)h->name);
#line 332
    len = (int )tmp;
#line 333
    tmp___1 = strncmp(id, (char const   *)h->name, (size_t )len);
    }
#line 333
    if (! tmp___1) {
      {
#line 334
      tmp___0 = (*(h->handler))(mask, h->cls, id + len);
#line 334
      ret = tmp___0;
      }
#line 335
      if (ret == -2) {
        {
#line 336
        numa_warn(27, (char *)"Kernel does not know node for %s\n", id + len);
        }
      }
#line 339
      return ((int __attribute__((__visibility__("hidden")))  )ret);
    }
    __Cont: /* CIL Label */ 
#line 328
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((int __attribute__((__visibility__("hidden")))  )-2);
}
}
#line 399 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 14 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/sysfs.c"
char __attribute__((__visibility__("hidden")))  *sysfs_read(char *name ) 
{ 
  char *buf___7 ;
  int n ;
  int fd ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 20
  fd = open((char const   *)name, 0);
#line 21
  tmp = malloc((size_t )4096);
#line 21
  buf___7 = (char *)tmp;
  }
#line 22
  if (! buf___7) {
#line 23
    return ((char __attribute__((__visibility__("hidden")))  *)((void *)0));
  }
  {
#line 24
  tmp___0 = read(fd, (void *)buf___7, (size_t )4095);
#line 24
  n = (int )tmp___0;
#line 25
  close(fd);
  }
#line 26
  if (n <= 0) {
    {
#line 27
    free((void *)buf___7);
    }
#line 28
    return ((char __attribute__((__visibility__("hidden")))  *)((void *)0));
  }
#line 30
  *(buf___7 + n) = (char)0;
#line 31
  return ((char __attribute__((__visibility__("hidden")))  *)buf___7);
}
}
#line 34 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/sysfs.c"
int __attribute__((__visibility__("hidden")))  sysfs_node_read(struct bitmask *mask ,
                                                               char *fmt  , ...) 
{ 
  int n ;
  va_list ap ;
  char *p ;
  char *fn ;
  char *m ;
  char *end___0 ;
  int num ;
  char __attribute__((__visibility__("hidden")))  *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 41
  __builtin_va_start(ap, fmt);
#line 42
  n = vasprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)fmt,
                ap);
#line 43
  __builtin_va_end(ap);
  }
#line 44
  if (n < 0) {
#line 45
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
  {
#line 46
  tmp = sysfs_read(fn);
#line 46
  p = (char *)tmp;
#line 47
  free((void *)fn);
  }
#line 48
  if (! p) {
#line 49
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
#line 51
  m = p;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    tmp___0 = strtol((char const   */* __restrict  */)m, (char **/* __restrict  */)(& end___0),
                     0);
#line 53
    num = (int )tmp___0;
    }
#line 54
    if ((unsigned long )m == (unsigned long )end___0) {
#line 55
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 56
    if (num < 0) {
#line 57
      return ((int __attribute__((__visibility__("hidden")))  )-2);
    }
    {
#line 58
    tmp___1 = numa_num_task_nodes();
    }
#line 58
    if (num >= tmp___1) {
#line 59
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
    {
#line 60
    numa_bitmask_setbit(mask, (unsigned int )num);
#line 63
    m = end___0;
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 64
      tmp___2 = __ctype_b_loc();
      }
#line 64
      if (! ((int const   )*(*tmp___2 + (int )*m) & 8192)) {
#line 64
        if (! ((int )*m == 44)) {
#line 64
          goto while_break___0;
        }
      }
#line 65
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 52
    tmp___3 = __ctype_b_loc();
    }
#line 52
    if (! ((int const   )*(*tmp___3 + (int )*m) & 2048)) {
#line 52
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  free((void *)p);
  }
#line 68
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 63 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int *node_ix_map  =    (int *)((void *)0);
#line 64 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
char **node_header  ;
#line 80 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
meminfo_t process_meminfo[4]  = {      {0, (char *)"huge", (char *)"Huge"}, 
        {1, (char *)"heap", (char *)"Heap"}, 
        {2, (char *)"stack", (char *)"Stack"}, 
        {3, (char *)"N", (char *)"Private"}};
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
meminfo_t numastat_meminfo[6]  = {      {0, (char *)"numa_hit", (char *)"Numa_Hit"}, 
        {1, (char *)"numa_miss", (char *)"Numa_Miss"}, 
        {2, (char *)"numa_foreign", (char *)"Numa_Foreign"}, 
        {3, (char *)"interleave_hit", (char *)"Interleave_Hit"}, 
        {4, (char *)"local_node", (char *)"Local_Node"}, 
        {5, (char *)"other_node", (char *)"Other_Node"}};
#line 100 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
meminfo_t system_meminfo[33]  = 
#line 100
  {      {0, (char *)"MemTotal", (char *)"MemTotal"}, 
        {1, (char *)"MemFree", (char *)"MemFree"}, 
        {2, (char *)"MemUsed", (char *)"MemUsed"}, 
        {3, (char *)"HighTotal", (char *)"HighTotal"}, 
        {4, (char *)"HighFree", (char *)"HighFree"}, 
        {5, (char *)"LowTotal", (char *)"LowTotal"}, 
        {6, (char *)"LowFree", (char *)"LowFree"}, 
        {7, (char *)"Active", (char *)"Active"}, 
        {8, (char *)"Inactive", (char *)"Inactive"}, 
        {9, (char *)"Active(anon)", (char *)"Active(anon)"}, 
        {10, (char *)"Inactive(anon)", (char *)"Inactive(anon)"}, 
        {11, (char *)"Active(file)", (char *)"Active(file)"}, 
        {12, (char *)"Inactive(file)", (char *)"Inactive(file)"}, 
        {13, (char *)"Unevictable", (char *)"Unevictable"}, 
        {14, (char *)"Mlocked", (char *)"Mlocked"}, 
        {15, (char *)"Dirty", (char *)"Dirty"}, 
        {16, (char *)"Writeback", (char *)"Writeback"}, 
        {17, (char *)"FilePages", (char *)"FilePages"}, 
        {18, (char *)"Mapped", (char *)"Mapped"}, 
        {19, (char *)"AnonPages", (char *)"AnonPages"}, 
        {20, (char *)"Shmem", (char *)"Shmem"}, 
        {21, (char *)"KernelStack", (char *)"KernelStack"}, 
        {22, (char *)"PageTables", (char *)"PageTables"}, 
        {23, (char *)"NFS_Unstable", (char *)"NFS_Unstable"}, 
        {24, (char *)"Bounce", (char *)"Bounce"}, 
        {25, (char *)"WritebackTmp", (char *)"WritebackTmp"}, 
        {26, (char *)"Slab", (char *)"Slab"}, 
        {27, (char *)"SReclaimable", (char *)"SReclaimable"}, 
        {28, (char *)"SUnreclaim", (char *)"SUnreclaim"}, 
        {29, (char *)"AnonHugePages", (char *)"AnonHugePages"}, 
        {30, (char *)"HugePages_Total", (char *)"HugePages_Total"}, 
        {31, (char *)"HugePages_Free", (char *)"HugePages_Free"}, 
        {32, (char *)"HugePages_Surp", (char *)"HugePages_Surp"}};
#line 150 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int hash_collisions  =    0;
#line 152 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
struct hash_entry hash_table[151]  ;
#line 158 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void init_hash_table(void) 
{ 


  {
  {
#line 159
  memset((void *)(hash_table), 0, sizeof(hash_table));
  }
#line 160
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int hash_ix(char *s ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 164
  h = 17U;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! *s) {
#line 165
      goto while_break;
    }
#line 167
    tmp = s;
#line 167
    s ++;
#line 167
    h = ((h << 5) + h) + (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return ((int )(h % 151U));
}
}
#line 173 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int hash_lookup(char *s ) 
{ 
  int ix ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 174
  tmp = hash_ix(s);
#line 174
  ix = tmp;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! hash_table[ix].name) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp___0 = strcmp((char const   *)s, (char const   *)hash_table[ix].name);
    }
#line 176
    if (! tmp___0) {
#line 177
      return (hash_table[ix].index);
    }
#line 179
    ix ++;
#line 180
    if (ix >= 151) {
#line 181
      ix = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (-1);
}
}
#line 188 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int hash_insert(char *s , int i ) 
{ 
  int ix ;
  int tmp ;

  {
  {
#line 189
  tmp = hash_ix(s);
#line 189
  ix = tmp;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! hash_table[ix].name) {
#line 190
      goto while_break;
    }
#line 191
    hash_collisions ++;
#line 192
    ix ++;
#line 193
    if (ix >= 151) {
#line 194
      ix = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  hash_table[ix].name = s;
#line 198
  hash_table[ix].index = i;
#line 199
  return (ix);
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_row_flag(vtab_p table , int row , int flag ) 
{ 


  {
#line 268
  *(table->row_flags + row) = (uint8_t )((int )*(table->row_flags + row) | (int )((uint8_t )flag));
#line 269
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_col_flag(vtab_p table , int col , int flag ) 
{ 


  {
#line 272
  *(table->col_flags + col) = (uint8_t )((int )*(table->col_flags + col) | (int )((uint8_t )flag));
#line 273
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void clear_row_flag(vtab_p table , int row , int flag ) 
{ 


  {
#line 276
  *(table->row_flags + row) = (uint8_t )((int )*(table->row_flags + row) & (int )((uint8_t )(~ flag)));
#line 277
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void clear_col_flag(vtab_p table , int col , int flag ) 
{ 


  {
#line 280
  *(table->col_flags + col) = (uint8_t )((int )*(table->col_flags + col) & (int )((uint8_t )(~ flag)));
#line 281
  return;
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int test_row_flag(vtab_p table , int row , int flag ) 
{ 


  {
#line 284
  return (((int )*(table->row_flags + row) & (int )((uint8_t )flag)) != 0);
}
}
#line 287 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int test_col_flag(vtab_p table , int col , int flag ) 
{ 


  {
#line 288
  return (((int )*(table->col_flags + col) & (int )((uint8_t )flag)) != 0);
}
}
#line 292 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_col_justification(vtab_p table , int col , int justify ) 
{ 


  {
#line 293
  *(table->col_flags + col) = (uint8_t )((int )*(table->col_flags + col) & 252);
#line 294
  *(table->col_flags + col) = (uint8_t )((int )*(table->col_flags + col) | (int )((uint8_t )(justify & 3)));
#line 295
  return;
}
}
#line 298 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_col_width(vtab_p table , int col , uint8_t width ) 
{ 


  {
#line 299
  if ((int )width >= 128) {
#line 300
    width = (uint8_t )127;
  }
#line 302
  *(table->col_width + col) = width;
#line 303
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_col_decimal_places(vtab_p table , int col , uint8_t places ) 
{ 


  {
#line 307
  *(table->col_decimal_places + col) = places;
#line 308
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void set_cell_flag(vtab_p table , int row , int col , int flag ) 
{ 
  cell_p c_ptr ;

  {
#line 312
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 313
  c_ptr->flags |= (uint32_t )flag;
#line 314
  return;
}
}
#line 317 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void clear_cell_flag(vtab_p table , int row , int col , int flag ) 
{ 
  cell_p c_ptr ;

  {
#line 318
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 319
  c_ptr->flags &= (uint32_t )(~ flag);
#line 320
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int test_cell_flag(vtab_p table , int row , int col , int flag ) 
{ 
  cell_p c_ptr ;

  {
#line 324
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 325
  return ((c_ptr->flags & (uint32_t )flag) != 0U);
}
}
#line 329 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void string_assign(vtab_p table , int row , int col , char *s ) 
{ 
  cell_p c_ptr ;

  {
#line 330
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 331
  c_ptr->type = (uint32_t )3;
#line 332
  c_ptr->__annonCompField1.s = s;
#line 333
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void repchar_assign(vtab_p table , int row , int col , char c___1 ) 
{ 
  cell_p c_ptr ;

  {
#line 337
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 338
  c_ptr->type = (uint32_t )5;
#line 339
  c_ptr->__annonCompField1.c[0] = c___1;
#line 340
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void double_assign(vtab_p table , int row , int col , double d ) 
{ 
  cell_p c_ptr ;

  {
#line 344
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 345
  c_ptr->type = (uint32_t )2;
#line 346
  c_ptr->__annonCompField1.d = d;
#line 347
  return;
}
}
#line 350 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void long_assign(vtab_p table , int row , int col , int64_t l ) 
{ 
  cell_p c_ptr ;

  {
#line 351
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 352
  c_ptr->type = (uint32_t )1;
#line 353
  c_ptr->__annonCompField1.l = l;
#line 354
  return;
}
}
#line 357 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void double_addto(vtab_p table , int row , int col , double d ) 
{ 
  cell_p c_ptr ;

  {
#line 358
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 359
  c_ptr->type = (uint32_t )2;
#line 360
  c_ptr->__annonCompField1.d += d;
#line 361
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void long_addto(vtab_p table , int row , int col , int64_t l ) 
{ 
  cell_p c_ptr ;

  {
#line 365
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 366
  c_ptr->type = (uint32_t )1;
#line 367
  c_ptr->__annonCompField1.l += l;
#line 368
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void clear_assign(vtab_p table , int row , int col ) 
{ 
  cell_p c_ptr ;

  {
  {
#line 372
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 373
  memset((void *)c_ptr, 0, sizeof(cell_t ));
  }
#line 374
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void zero_table_data(vtab_p table , int type ) 
{ 
  int row ;
  int col ;
  cell_p c_ptr ;

  {
#line 379
  row = table->header_rows;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (row < table->header_rows + table->data_rows)) {
#line 379
      goto while_break;
    }
#line 380
    col = table->header_cols;
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! (col < table->header_cols + table->data_cols)) {
#line 380
        goto while_break___0;
      }
      {
#line 381
      c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 382
      memset((void *)c_ptr, 0, sizeof(cell_t ));
#line 383
      c_ptr->type = (uint32_t )type;
#line 380
      col ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 379
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void sort_rows_descending_by_col(vtab_p table , int start_row , int stop_row , int col ) 
{ 
  int ix ;
  int biggest_ix ;
  cell_p biggest_ix_c_ptr ;
  int iy ;
  cell_p iy_c_ptr ;
  int tmp ;

  {
#line 392
  ix = start_row;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (ix <= stop_row)) {
#line 392
      goto while_break;
    }
#line 393
    biggest_ix = ix;
#line 394
    biggest_ix_c_ptr = table->cell + (*(table->row_ix_map + ix) * (table->header_cols + table->data_cols) + col);
#line 395
    iy = ix + 1;
    {
#line 395
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 395
      if (! (iy <= stop_row)) {
#line 395
        goto while_break___0;
      }
#line 396
      iy_c_ptr = table->cell + (*(table->row_ix_map + iy) * (table->header_cols + table->data_cols) + col);
#line 397
      if (biggest_ix_c_ptr->__annonCompField1.d < iy_c_ptr->__annonCompField1.d) {
#line 398
        biggest_ix_c_ptr = iy_c_ptr;
#line 399
        biggest_ix = iy;
      }
#line 395
      iy ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 402
    if (biggest_ix != ix) {
#line 403
      tmp = *(table->row_ix_map + ix);
#line 404
      *(table->row_ix_map + ix) = *(table->row_ix_map + biggest_ix);
#line 405
      *(table->row_ix_map + biggest_ix) = tmp;
    }
#line 392
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void span(vtab_p table , int first_row , int first_col , int last_row , int last_col ) 
{ 


  {
#line 413
  return;
}
}
#line 416 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void init_table(vtab_p table , int header_rows , int header_cols , int data_rows ,
                int data_cols ) 
{ 
  int alloc_size ;
  void *tmp ;
  void *tmp___0 ;
  int row ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 418
  table->header_rows = header_rows;
#line 419
  table->header_cols = header_cols;
#line 420
  table->data_rows = data_rows;
#line 421
  table->data_cols = data_cols;
#line 423
  alloc_size = (int )((unsigned long )((table->header_rows + table->data_rows) * (table->header_cols + table->data_cols)) * sizeof(cell_t ));
#line 424
  tmp = malloc((size_t )alloc_size);
#line 424
  table->cell = (cell_p )tmp;
  }
#line 425
  if ((unsigned long )table->cell == (unsigned long )((void *)0)) {
    {
#line 426
    perror("malloc failed line: 426");
#line 427
    exit(1);
    }
  }
  {
#line 429
  memset((void *)table->cell, 0, (size_t )alloc_size);
#line 431
  alloc_size = (int )((unsigned long )(table->header_rows + table->data_rows) * sizeof(int ));
#line 432
  tmp___0 = malloc((size_t )alloc_size);
#line 432
  table->row_ix_map = (int *)tmp___0;
  }
#line 433
  if ((unsigned long )table->row_ix_map == (unsigned long )((void *)0)) {
    {
#line 434
    perror("malloc failed line: 434");
#line 435
    exit(1);
    }
  }
#line 437
  row = 0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! (row < table->header_rows + table->data_rows)) {
#line 437
      goto while_break;
    }
#line 438
    *(table->row_ix_map + row) = row;
#line 437
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  alloc_size = (int )((unsigned long )(table->header_rows + table->data_rows) * sizeof(uint8_t ));
#line 442
  tmp___1 = malloc((size_t )alloc_size);
#line 442
  table->row_flags = (uint8_t *)tmp___1;
  }
#line 443
  if ((unsigned long )table->row_flags == (unsigned long )((void *)0)) {
    {
#line 444
    perror("malloc failed line: 444");
#line 445
    exit(1);
    }
  }
  {
#line 447
  memset((void *)table->row_flags, 0, (size_t )alloc_size);
#line 449
  alloc_size = (int )((unsigned long )(table->header_cols + table->data_cols) * sizeof(uint8_t ));
#line 450
  tmp___2 = malloc((size_t )alloc_size);
#line 450
  table->col_flags = (uint8_t *)tmp___2;
  }
#line 451
  if ((unsigned long )table->col_flags == (unsigned long )((void *)0)) {
    {
#line 452
    perror("malloc failed line: 452");
#line 453
    exit(1);
    }
  }
  {
#line 455
  memset((void *)table->col_flags, 0, (size_t )alloc_size);
#line 457
  alloc_size = (int )((unsigned long )(table->header_cols + table->data_cols) * sizeof(uint8_t ));
#line 458
  tmp___3 = malloc((size_t )alloc_size);
#line 458
  table->col_width = (uint8_t *)tmp___3;
  }
#line 459
  if ((unsigned long )table->col_width == (unsigned long )((void *)0)) {
    {
#line 460
    perror("malloc failed line: 460");
#line 461
    exit(1);
    }
  }
  {
#line 463
  memset((void *)table->col_width, 0, (size_t )alloc_size);
#line 465
  alloc_size = (int )((unsigned long )(table->header_cols + table->data_cols) * sizeof(uint8_t ));
#line 466
  tmp___4 = malloc((size_t )alloc_size);
#line 466
  table->col_decimal_places = (uint8_t *)tmp___4;
  }
#line 467
  if ((unsigned long )table->col_decimal_places == (unsigned long )((void *)0)) {
    {
#line 468
    perror("malloc failed line: 468");
#line 469
    exit(1);
    }
  }
  {
#line 471
  memset((void *)table->col_decimal_places, 0, (size_t )alloc_size);
  }
#line 472
  return;
}
}
#line 475 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void free_cell(vtab_p table , int row , int col ) 
{ 
  cell_p c_ptr ;

  {
#line 476
  c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 477
  if (c_ptr->type == 3U) {
#line 477
    if (c_ptr->flags & 1U) {
#line 477
      if ((unsigned long )c_ptr->__annonCompField1.s != (unsigned long )((void *)0)) {
        {
#line 480
        free((void *)c_ptr->__annonCompField1.s);
        }
      }
    }
  }
  {
#line 482
  memset((void *)c_ptr, 0, sizeof(cell_t ));
  }
#line 483
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void free_table(vtab_p table ) 
{ 
  int row ;
  int col ;

  {
#line 487
  if ((unsigned long )table->cell != (unsigned long )((void *)0)) {
#line 488
    row = 0;
    {
#line 488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 488
      if (! (row < table->header_rows + table->data_rows)) {
#line 488
        goto while_break;
      }
#line 489
      col = 0;
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 489
        if (! (col < table->header_cols + table->data_cols)) {
#line 489
          goto while_break___0;
        }
        {
#line 490
        free_cell(table, row, col);
#line 489
        col ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 488
      row ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 493
    free((void *)table->cell);
    }
  }
#line 495
  if ((unsigned long )table->row_ix_map != (unsigned long )((void *)0)) {
    {
#line 496
    free((void *)table->row_ix_map);
    }
  }
#line 498
  if ((unsigned long )table->row_flags != (unsigned long )((void *)0)) {
    {
#line 499
    free((void *)table->row_flags);
    }
  }
#line 501
  if ((unsigned long )table->col_flags != (unsigned long )((void *)0)) {
    {
#line 502
    free((void *)table->col_flags);
    }
  }
#line 504
  if ((unsigned long )table->col_width != (unsigned long )((void *)0)) {
    {
#line 505
    free((void *)table->col_width);
    }
  }
#line 507
  if ((unsigned long )table->col_decimal_places != (unsigned long )((void *)0)) {
    {
#line 508
    free((void *)table->col_decimal_places);
    }
  }
#line 510
  return;
}
}
#line 517 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
static char buf___0[128]  ;
#line 513 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
char *fmt_cell_data(cell_p c_ptr , int max_width , int decimal_places ) 
{ 
  int rep_width ;

  {
#line 516
  rep_width = max_width - 1;
  {
#line 519
  if (c_ptr->type == 0U) {
#line 519
    goto case_0;
  }
#line 522
  if (c_ptr->type == 1U) {
#line 522
    goto case_1;
  }
#line 525
  if (c_ptr->type == 2U) {
#line 525
    goto case_2;
  }
#line 528
  if (c_ptr->type == 3U) {
#line 528
    goto case_3;
  }
#line 531
  if (c_ptr->type == 4U) {
#line 531
    goto case_4;
  }
#line 535
  if (c_ptr->type == 5U) {
#line 535
    goto case_5;
  }
#line 539
  goto switch_default;
  case_0: /* CIL Label */ 
#line 520
  buf___0[0] = (char )'\000';
#line 521
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 523
  snprintf((char */* __restrict  */)(buf___0), (size_t )128, (char const   */* __restrict  */)"%ld",
           c_ptr->__annonCompField1.l);
  }
#line 524
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 526
  snprintf((char */* __restrict  */)(buf___0), (size_t )128, (char const   */* __restrict  */)"%.*f",
           decimal_places, c_ptr->__annonCompField1.d);
  }
#line 527
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 529
  snprintf((char */* __restrict  */)(buf___0), (size_t )128, (char const   */* __restrict  */)"%s",
           c_ptr->__annonCompField1.s);
  }
#line 530
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 532
  strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)(c_ptr->__annonCompField1.c),
          (size_t )8);
#line 533
  buf___0[8] = (char )'\000';
  }
#line 534
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 536
  memset((void *)(buf___0), (int )c_ptr->__annonCompField1.c[0], (size_t )rep_width);
#line 537
  buf___0[rep_width] = (char )'\000';
  }
#line 538
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 540
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Unknown");
  }
#line 541
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 543
  buf___0[max_width] = (char )'\000';
#line 544
  return (buf___0);
}
}
#line 548 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void auto_set_col_width(vtab_p table , int col , int min_width , int max_width ) 
{ 
  int width ;
  int row ;
  cell_p c_ptr ;
  char *p ;
  char *tmp ;
  int l ;
  size_t tmp___0 ;

  {
#line 549
  width = min_width;
#line 550
  row = 0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (row < table->header_rows + table->data_rows)) {
#line 550
      goto while_break;
    }
#line 551
    c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 552
    if (c_ptr->type == 5U) {
#line 553
      goto __Cont;
    }
    {
#line 555
    tmp = fmt_cell_data(c_ptr, max_width, (int )*(table->col_decimal_places + col));
#line 555
    p = tmp;
#line 556
    tmp___0 = strlen((char const   *)p);
#line 556
    l = (int )tmp___0;
    }
#line 557
    if (width < l) {
#line 558
      width = l;
    }
    __Cont: /* CIL Label */ 
#line 550
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  width ++;
#line 562
  if (width > max_width) {
#line 563
    width = max_width;
  }
#line 565
  *(table->col_width + col) = (uint8_t )width;
#line 566
  return;
}
}
#line 569 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void display_justified_cell(cell_p c_ptr , int row_flags , int col_flags , int width ,
                            int decimal_places ) 
{ 
  char *p ;
  char *tmp ;
  int l ;
  size_t tmp___0 ;
  char buf___7[128] ;

  {
  {
#line 570
  tmp = fmt_cell_data(c_ptr, width, decimal_places);
#line 570
  p = tmp;
#line 571
  tmp___0 = strlen((char const   *)p);
#line 571
  l = (int )tmp___0;
  }
  {
#line 574
  if ((col_flags & 3) == 1) {
#line 574
    goto case_1;
  }
#line 580
  if ((col_flags & 3) == 1 << 1) {
#line 580
    goto case_exp;
  }
#line 587
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 575
  memcpy((void */* __restrict  */)(buf___7), (void const   */* __restrict  */)p, (size_t )l);
  }
#line 576
  if (l < width) {
    {
#line 577
    memset((void *)(& buf___7[l]), ' ', (size_t )(width - l));
    }
  }
#line 579
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 581
  if (l < width) {
    {
#line 582
    memset((void *)(buf___7), ' ', (size_t )(width - l));
    }
  }
  {
#line 584
  memcpy((void */* __restrict  */)(& buf___7[width - l]), (void const   */* __restrict  */)p,
         (size_t )l);
  }
#line 585
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 588
  memset((void *)(buf___7), ' ', (size_t )width);
#line 589
  memcpy((void */* __restrict  */)(& buf___7[((width - l) + 1) / 2]), (void const   */* __restrict  */)p,
         (size_t )l);
  }
#line 590
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 592
  buf___7[width] = (char )'\000';
#line 593
  printf((char const   */* __restrict  */)"%s", buf___7);
  }
#line 594
  return;
}
}
#line 597 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void display_table(vtab_p table , int screen_width___0 , int show_unseen_rows , int show_unseen_cols ,
                   int show_zero_rows , int show_zero_cols ) 
{ 
  int some_seen_data ;
  int some_non_zero_data ;
  int row ;
  int col ;
  cell_p c_ptr ;
  int col___0 ;
  int data_col ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int row_ix ;
  int row___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int cur_line_width ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 606
  some_seen_data = 0;
#line 607
  some_non_zero_data = 0;
#line 608
  row = table->header_rows;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! (row < table->header_rows + table->data_rows)) {
#line 608
      goto while_break;
    }
#line 609
    col = table->header_cols;
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! (col < table->header_cols + table->data_cols)) {
#line 609
        goto while_break___0;
      }
#line 610
      c_ptr = table->cell + (row * (table->header_cols + table->data_cols) + col);
#line 613
      if (c_ptr->type != 0U) {
#line 613
        if (c_ptr->type != 5U) {
          {
#line 614
          some_seen_data = 1;
#line 615
          set_row_flag(table, row, 1 << 2);
#line 616
          set_col_flag(table, col, 1 << 2);
          }
#line 622
          if (c_ptr->__annonCompField1.l != 0L) {
            {
#line 623
            some_non_zero_data = 1;
#line 624
            set_row_flag(table, row, 1 << 3);
#line 625
            set_col_flag(table, col, 1 << 3);
            }
          }
        }
      }
#line 609
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 608
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  if (! some_seen_data) {
    {
#line 631
    printf((char const   */* __restrict  */)"Table has no data.\n");
    }
#line 632
    return;
  }
#line 634
  if (! some_non_zero_data) {
#line 634
    if (! show_zero_rows) {
#line 634
      if (! show_zero_cols) {
        {
#line 635
        printf((char const   */* __restrict  */)"Table has no non-zero data.\n");
        }
#line 636
        return;
      }
    }
  }
#line 640
  col___0 = -1;
#line 641
  data_col = table->header_cols;
  {
#line 642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 642
    if (! (data_col < table->header_cols + table->data_cols)) {
#line 642
      goto while_break___1;
    }
    {
#line 644
    tmp = test_col_flag(table, data_col, 1 << 4);
    }
#line 644
    if (! tmp) {
#line 644
      if (! show_unseen_cols) {
        {
#line 644
        tmp___0 = test_col_flag(table, data_col, 1 << 2);
        }
#line 644
        if (tmp___0) {
#line 644
          goto _L;
        } else {
#line 647
          data_col ++;
#line 648
          goto while_continue___1;
        }
      } else
      _L: /* CIL Label */ 
#line 644
      if (! show_zero_cols) {
        {
#line 644
        tmp___1 = test_col_flag(table, data_col, 1 << 3);
        }
#line 644
        if (! tmp___1) {
#line 647
          data_col ++;
#line 648
          goto while_continue___1;
        }
      }
    }
#line 651
    if (col___0 > 0) {
      {
#line 652
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 655
    row_ix = 0;
    {
#line 655
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 655
      if (! (row_ix < table->header_rows + table->data_rows)) {
#line 655
        goto while_break___2;
      }
#line 656
      row___0 = *(table->row_ix_map + row_ix);
#line 658
      if (row___0 >= table->header_rows) {
        {
#line 658
        tmp___4 = test_row_flag(table, row___0, 1 << 4);
        }
#line 658
        if (! tmp___4) {
#line 660
          if (! show_unseen_rows) {
            {
#line 660
            tmp___2 = test_row_flag(table, row___0, 1 << 2);
            }
#line 660
            if (tmp___2) {
#line 660
              goto _L___0;
            } else {
#line 662
              goto __Cont;
            }
          } else
          _L___0: /* CIL Label */ 
#line 660
          if (! show_zero_rows) {
            {
#line 660
            tmp___3 = test_row_flag(table, row___0, 1 << 3);
            }
#line 660
            if (! tmp___3) {
#line 662
              goto __Cont;
            }
          }
        }
      }
#line 666
      cur_line_width = 0;
#line 668
      col___0 = 0;
      {
#line 668
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 668
        if (! (col___0 < table->header_cols)) {
#line 668
          goto while_break___3;
        }
        {
#line 669
        display_justified_cell(table->cell + (row___0 * (table->header_cols + table->data_cols) + col___0),
                               (int )*(table->row_flags + row___0), (int )*(table->col_flags + col___0),
                               (int )*(table->col_width + col___0), (int )*(table->col_decimal_places + col___0));
#line 674
        cur_line_width += (int )*(table->col_width + col___0);
#line 668
        col___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 677
      col___0 = data_col;
      {
#line 679
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 681
        tmp___5 = test_col_flag(table, col___0, 1 << 4);
        }
#line 681
        if (tmp___5) {
          {
#line 684
          display_justified_cell(table->cell + (row___0 * (table->header_cols + table->data_cols) + col___0),
                                 (int )*(table->row_flags + row___0), (int )*(table->col_flags + col___0),
                                 (int )*(table->col_width + col___0), (int )*(table->col_decimal_places + col___0));
#line 689
          cur_line_width += (int )*(table->col_width + col___0);
          }
        } else
#line 681
        if (show_unseen_cols) {
#line 681
          goto _L___1;
        } else {
          {
#line 681
          tmp___6 = test_col_flag(table, col___0, 1 << 2);
          }
#line 681
          if (tmp___6) {
            _L___1: /* CIL Label */ 
#line 681
            if (show_zero_cols) {
              {
#line 684
              display_justified_cell(table->cell + (row___0 * (table->header_cols + table->data_cols) + col___0),
                                     (int )*(table->row_flags + row___0), (int )*(table->col_flags + col___0),
                                     (int )*(table->col_width + col___0), (int )*(table->col_decimal_places + col___0));
#line 689
              cur_line_width += (int )*(table->col_width + col___0);
              }
            } else {
              {
#line 681
              tmp___7 = test_col_flag(table, col___0, 1 << 3);
              }
#line 681
              if (tmp___7) {
                {
#line 684
                display_justified_cell(table->cell + (row___0 * (table->header_cols + table->data_cols) + col___0),
                                       (int )*(table->row_flags + row___0), (int )*(table->col_flags + col___0),
                                       (int )*(table->col_width + col___0), (int )*(table->col_decimal_places + col___0));
#line 689
                cur_line_width += (int )*(table->col_width + col___0);
                }
              }
            }
          }
        }
#line 691
        col___0 ++;
#line 693
        if (col___0 >= table->header_cols + table->data_cols) {
#line 695
          goto while_break___4;
        } else
#line 693
        if (cur_line_width + (int )*(table->col_width + col___0) > screen_width___0) {
#line 695
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 698
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 655
      row_ix ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 701
    data_col = col___0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 703
  return;
}
}
#line 710 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int verbose  =    0;
#line 711 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int num_pids  =    0;
#line 712 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int num_nodes  =    0;
#line 713 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int screen_width  =    0;
#line 714 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int show_zero_data  =    1;
#line 715 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int compress_display  =    0;
#line 716 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int sort_table  =    0;
#line 717 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int sort_table_node  =    -1;
#line 718 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int compatibility_mode  =    0;
#line 719 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int pid_array_max_pids  =    0;
#line 720 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int *pid_array  =    (int *)((void *)0);
#line 721 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
char *prog_name  =    (char *)((void *)0);
#line 722 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
double page_size_in_bytes  =    (double )0;
#line 723 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
double huge_page_size_in_bytes  =    (double )0;
#line 726 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void display_version_and_exit(void) 
{ 
  char *version_string ;

  {
  {
#line 727
  version_string = (char *)"20130723";
#line 728
  printf((char const   */* __restrict  */)"%s version: %s: %s\n", prog_name, version_string,
         "Mar  4 2016");
#line 729
  exit(0);
  }
}
}
#line 733 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void display_usage_and_exit(void) 
{ 


  {
  {
#line 734
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-c] [-m] [-n] [-p <PID>|<pattern>] [-s[<node>]] [-v] [-V] [-z] [ <PID>|<pattern>... ]\n",
          prog_name);
#line 735
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c to minimize column widths\n");
#line 736
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-m to show meminfo-like system-wide memory usage\n");
#line 737
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-n to show the numastat statistics info\n");
#line 738
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-p <PID>|<pattern> to show process info\n");
#line 739
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-s[<node>] to sort data by total column or <node>\n");
#line 740
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-v to make some reports more verbose\n");
#line 741
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-V to show the %s code version\n",
          prog_name);
#line 742
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-z to skip rows and columns of zeros\n");
#line 743
  exit(1);
  }
}
}
#line 747 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int get_screen_width(void) 
{ 
  int width ;
  char *p ;
  char *tmp ;
  FILE *fs ;
  FILE *tmp___0 ;
  char columns[72] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 748
  width = 80;
#line 749
  tmp = getenv("NUMASTAT_WIDTH");
#line 749
  p = tmp;
  }
#line 750
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 751
    width = atoi((char const   *)p);
    }
#line 752
    if (width < 1) {
#line 753
      width = 80;
    } else
#line 752
    if (width > 10000000) {
#line 753
      width = 80;
    }
  } else {
    {
#line 755
    tmp___2 = fileno(stdout);
#line 755
    tmp___3 = isatty(tmp___2);
    }
#line 755
    if (tmp___3) {
      {
#line 756
      tmp___0 = popen("resize 2>/dev/null", "r");
#line 756
      fs = tmp___0;
      }
#line 757
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
        {
#line 759
        fgets((char */* __restrict  */)(columns), (int )sizeof(columns), (FILE */* __restrict  */)fs);
#line 760
        pclose(fs);
#line 761
        tmp___1 = strncmp((char const   *)(columns), "COLUMNS=", (size_t )8);
        }
#line 761
        if (tmp___1 == 0) {
          {
#line 762
          width = atoi((char const   *)(& columns[8]));
          }
#line 763
          if (width < 1) {
#line 764
            width = 80;
          } else
#line 763
          if (width > 10000000) {
#line 764
            width = 80;
          }
        }
      }
    } else {
#line 770
      width = 10000000;
    }
  }
#line 772
  if (width < 32) {
#line 773
    width = 32;
  }
#line 775
  return (width);
}
}
#line 782 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
static char buf___1[128]  ;
#line 779 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
char *command_name_for_pid(int pid ) 
{ 
  char fname[64] ;
  FILE *fs ;
  FILE *tmp ;
  char *p ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 784
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/proc/%d/status",
           pid);
#line 785
  tmp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
#line 785
  fs = tmp;
  }
#line 786
  if (! fs) {
#line 787
    return ((char *)((void *)0));
  } else {
    {
#line 789
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 789
      tmp___4 = fgets((char */* __restrict  */)(buf___1), 128, (FILE */* __restrict  */)fs);
      }
#line 789
      if (! tmp___4) {
#line 789
        goto while_break;
      }
      {
#line 790
      tmp___3 = strstr((char const   *)(buf___1), "Name:");
      }
#line 790
      if ((unsigned long )tmp___3 == (unsigned long )(buf___1)) {
#line 791
        p = & buf___1[5];
        {
#line 792
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 792
          tmp___0 = __ctype_b_loc();
          }
#line 792
          if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 792
            goto while_break___0;
          }
#line 793
          p ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 795
        tmp___2 = strlen((char const   *)p);
        }
#line 795
        if ((int )*(p + (tmp___2 - 1UL)) == 10) {
          {
#line 796
          tmp___1 = strlen((char const   *)p);
#line 796
          *(p + (tmp___1 - 1UL)) = (char )'\000';
          }
        }
        {
#line 798
        fclose(fs);
        }
#line 799
        return (p);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 802
    fclose(fs);
    }
  }
#line 804
  return ((char *)((void *)0));
}
}
#line 808 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void show_info_from_system_file(char *file , meminfo_p meminfo , int meminfo_rows ,
                                int tok_offset ) 
{ 
  vtab_t table ;
  int header_rows ;
  int header_cols ;
  int total_col_ix ;
  int row ;
  int node_ix ;
  int col ;
  int decimal_places ;
  char buf___7[128] ;
  char fname[64] ;
  FILE *fs ;
  FILE *tmp ;
  char *tok[64] ;
  int tokens ;
  char const   *delimiters ;
  char *p ;
  char *tmp___0 ;
  int tmp___1 ;
  int index___0 ;
  int tmp___2 ;
  double value ;
  long tmp___3 ;
  double multiplier ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int col___0 ;
  int sort_col ;

  {
  {
#line 811
  header_rows = 2 - compatibility_mode;
#line 812
  header_cols = 1;
#line 814
  init_table(& table, header_rows, header_cols, meminfo_rows, num_nodes + 1);
#line 815
  total_col_ix = header_cols + num_nodes;
#line 817
  init_hash_table();
#line 818
  row = 0;
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (row < meminfo_rows)) {
#line 818
      goto while_break;
    }
    {
#line 819
    hash_insert((meminfo + row)->token, (meminfo + row)->index);
    }
#line 820
    if (compatibility_mode) {
      {
#line 821
      string_assign(& table, header_rows + row, 0, (meminfo + row)->token);
      }
    } else {
      {
#line 823
      string_assign(& table, header_rows + row, 0, (meminfo + row)->label);
      }
    }
#line 818
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 828
  set_col_width(& table, 0, (uint8_t )16);
#line 829
  set_col_justification(& table, 0, 1);
#line 833
  node_ix = 0;
  }
  {
#line 833
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 833
    if (! (node_ix < num_nodes + (1 - compatibility_mode))) {
#line 833
      goto while_break___0;
    }
    {
#line 834
    col = header_cols + node_ix;
#line 836
    string_assign(& table, 0, col, *(node_header + node_ix));
    }
#line 837
    if (! compatibility_mode) {
      {
#line 838
      repchar_assign(& table, 1, col, (char )'-');
#line 839
      decimal_places = 2;
      }
#line 840
      if (compress_display) {
#line 841
        decimal_places = 0;
      }
      {
#line 843
      set_col_decimal_places(& table, col, (uint8_t )decimal_places);
      }
    }
    {
#line 846
    set_col_width(& table, col, (uint8_t )16);
#line 847
    set_col_justification(& table, col, 1 << 1);
    }
#line 848
    if (node_ix == num_nodes) {
#line 849
      goto while_break___0;
    }
    {
#line 854
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/%s",
             *(node_ix_map + node_ix), file);
#line 855
    tmp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
#line 855
    fs = tmp;
    }
#line 856
    if (! fs) {
      {
#line 857
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"cannot open %s",
              fname);
#line 858
      perror((char const   *)(buf___7));
#line 859
      exit(1);
      }
    }
    {
#line 862
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 862
      tmp___6 = fgets((char */* __restrict  */)(buf___7), 128, (FILE */* __restrict  */)fs);
      }
#line 862
      if (! tmp___6) {
#line 862
        goto while_break___1;
      }
      {
#line 864
      tokens = 0;
#line 865
      delimiters = " \t\r\n:";
#line 866
      tmp___0 = strtok((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)delimiters);
#line 866
      p = tmp___0;
      }
#line 867
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 868
        goto while_continue___1;
      }
      {
#line 870
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 870
        if (! p) {
#line 870
          goto while_break___2;
        }
        {
#line 871
        tmp___1 = tokens;
#line 871
        tokens ++;
#line 871
        tok[tmp___1] = p;
#line 872
        p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delimiters);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 876
      tmp___2 = hash_lookup(tok[tok_offset]);
#line 876
      index___0 = tmp___2;
      }
#line 877
      if (index___0 < 0) {
        {
#line 878
        printf((char const   */* __restrict  */)"Token %s not in hash table.\n", tok[0]);
        }
      } else {
        {
#line 880
        tmp___3 = atol((char const   *)tok[1 + tok_offset]);
#line 880
        value = (double )tmp___3;
        }
#line 881
        if (! compatibility_mode) {
#line 882
          multiplier = 1.0;
#line 883
          if (tokens < 4) {
#line 884
            multiplier = page_size_in_bytes;
          } else {
            {
#line 885
            tmp___5 = strncmp("HugePages", (char const   *)tok[2], (size_t )9);
            }
#line 885
            if (tmp___5) {
              {
#line 887
              tmp___4 = strncmp("kB", (char const   *)tok[4], (size_t )2);
              }
#line 887
              if (! tmp___4) {
#line 888
                multiplier = (double )1024;
              }
            } else {
#line 886
              multiplier = huge_page_size_in_bytes;
            }
          }
#line 890
          value *= multiplier;
#line 891
          value /= (double )1048576;
        }
        {
#line 893
        double_assign(& table, header_rows + index___0, col, value);
#line 894
        double_addto(& table, header_rows + index___0, total_col_ix, value);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 897
    fclose(fs);
#line 833
    node_ix ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 900
  if (compress_display) {
#line 901
    col___0 = 0;
    {
#line 901
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 901
      if (! (col___0 < (header_cols + num_nodes) + 1)) {
#line 901
        goto while_break___3;
      }
      {
#line 902
      auto_set_col_width(& table, col___0, 4, 16);
#line 901
      col___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 906
  if (sort_table) {
#line 908
    if (sort_table_node < 0) {
#line 909
      sort_col = total_col_ix;
    } else
#line 908
    if (sort_table_node >= num_nodes) {
#line 909
      sort_col = total_col_ix;
    } else {
#line 911
      sort_col = header_cols + *(node_ix_map + sort_table_node);
    }
    {
#line 913
    sort_rows_descending_by_col(& table, header_rows, (header_rows + meminfo_rows) - 1,
                                sort_col);
    }
  }
  {
#line 916
  display_table(& table, screen_width, 0, 0, show_zero_data, show_zero_data);
#line 917
  free_table(& table);
  }
#line 918
  return;
}
}
#line 921 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void show_numastat_info(void) 
{ 


  {
#line 922
  if (! compatibility_mode) {
    {
#line 923
    printf((char const   */* __restrict  */)"\nPer-node numastat info (in MBs):\n");
    }
  }
  {
#line 925
  show_info_from_system_file((char *)"numastat", numastat_meminfo, (int )(sizeof(numastat_meminfo) / sizeof(numastat_meminfo[0])),
                             0);
  }
#line 926
  return;
}
}
#line 929 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void show_system_info(void) 
{ 


  {
  {
#line 930
  printf((char const   */* __restrict  */)"\nPer-node system memory usage (in MBs):\n");
#line 931
  show_info_from_system_file((char *)"meminfo", system_meminfo, (int )(sizeof(system_meminfo) / sizeof(system_meminfo[0])),
                             2);
  }
#line 932
  return;
}
}
#line 935 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void show_process_info(void) 
{ 
  vtab_t table ;
  int header_rows ;
  int header_cols ;
  int data_rows ;
  int show_sub_categories ;
  int tmp ;
  int total_col_ix ;
  int total_row_ix ;
  int row ;
  int node_ix ;
  int col ;
  int decimal_places ;
  int pid_ix ;
  int pid ;
  char *tmp___0 ;
  char tmp_buf[64] ;
  char *tmp___1 ;
  char *p ;
  char *tmp___2 ;
  char fname[64] ;
  char buf___7[2048] ;
  FILE *fs ;
  FILE *tmp___3 ;
  int category ;
  char const   *delimiters ;
  char *p___0 ;
  char *tmp___4 ;
  int ix ;
  size_t tmp___5 ;
  int tmp___6 ;
  int node_num ;
  long tmp___7 ;
  double value ;
  long tmp___8 ;
  double multiplier ;
  int tmp_row ;
  int tmp_col ;
  char *tmp___9 ;
  int tmp___10 ;
  int col___0 ;
  int col___1 ;
  int sort_col ;

  {
#line 937
  header_rows = 2;
#line 938
  header_cols = 1;
#line 940
  if (verbose) {
#line 940
    tmp = 1;
  } else
#line 940
  if (num_pids == 1) {
#line 940
    tmp = 1;
  } else {
#line 940
    tmp = 0;
  }
#line 940
  show_sub_categories = tmp;
#line 941
  if (show_sub_categories) {
#line 942
    data_rows = (int )(sizeof(process_meminfo) / sizeof(process_meminfo[0]));
  } else {
#line 944
    data_rows = num_pids;
  }
  {
#line 948
  init_table(& table, header_rows, header_cols, data_rows + 2, num_nodes + 1);
#line 949
  total_col_ix = header_cols + num_nodes;
#line 950
  total_row_ix = (header_rows + data_rows) + 1;
#line 951
  string_assign(& table, total_row_ix, 0, (char *)"Total");
  }
#line 952
  if (show_sub_categories) {
#line 954
    row = 0;
    {
#line 954
    while (1) {
      while_continue: /* CIL Label */ ;
#line 954
      if (! ((unsigned long )row < sizeof(process_meminfo) / sizeof(process_meminfo[0]))) {
#line 954
        goto while_break;
      }
      {
#line 955
      string_assign(& table, header_rows + row, 0, process_meminfo[row].label);
#line 954
      row ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 958
    string_assign(& table, 0, 0, (char *)"PID");
#line 959
    repchar_assign(& table, 1, 0, (char )'-');
#line 960
    printf((char const   */* __restrict  */)"\nPer-node process memory usage (in MBs)\n");
    }
  }
  {
#line 963
  set_col_width(& table, 0, (uint8_t )16);
#line 964
  set_col_justification(& table, 0, 1);
#line 966
  node_ix = 0;
  }
  {
#line 966
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 966
    if (! (node_ix <= num_nodes)) {
#line 966
      goto while_break___0;
    }
    {
#line 967
    col = header_cols + node_ix;
#line 969
    string_assign(& table, 0, col, *(node_header + node_ix));
#line 970
    repchar_assign(& table, 1, col, (char )'-');
#line 972
    set_col_width(& table, col, (uint8_t )16);
#line 973
    decimal_places = 2;
    }
#line 974
    if (compress_display) {
#line 975
      decimal_places = 0;
    }
    {
#line 977
    set_col_decimal_places(& table, col, (uint8_t )decimal_places);
#line 978
    set_col_justification(& table, col, 1 << 1);
#line 966
    node_ix ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 981
  zero_table_data(& table, 2);
#line 984
  pid_ix = 0;
  }
  {
#line 984
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 984
    if (! (pid_ix < num_pids)) {
#line 984
      goto while_break___1;
    }
#line 985
    pid = *(pid_array + pid_ix);
#line 986
    if (show_sub_categories) {
      {
#line 987
      tmp___0 = command_name_for_pid(pid);
#line 987
      printf((char const   */* __restrict  */)"\nPer-node process memory usage (in MBs) for PID %d (%s)\n",
             pid, tmp___0);
      }
#line 988
      if (pid_ix > 0) {
        {
#line 990
        zero_table_data(& table, 2);
        }
      }
    } else {
      {
#line 995
      tmp___1 = command_name_for_pid(pid);
#line 995
      snprintf((char */* __restrict  */)(tmp_buf), sizeof(tmp_buf), (char const   */* __restrict  */)"%d (%s)",
               pid, tmp___1);
#line 996
      tmp___2 = strdup((char const   *)(tmp_buf));
#line 996
      p = tmp___2;
      }
#line 997
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 998
        perror("malloc failed line: 998");
#line 999
        exit(1);
        }
      }
      {
#line 1001
      string_assign(& table, header_rows + pid_ix, 0, p);
#line 1002
      set_cell_flag(& table, header_rows + pid_ix, 0, 1);
      }
    }
    {
#line 1006
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/proc/%d/numa_maps",
             pid);
#line 1008
    tmp___3 = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
#line 1008
    fs = tmp___3;
    }
#line 1009
    if (! fs) {
      {
#line 1010
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"Can\'t read /proc/%d/numa_maps",
              pid);
#line 1011
      perror((char const   *)(buf___7));
      }
#line 1012
      goto __Cont;
    }
    {
#line 1017
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1017
      tmp___9 = fgets((char */* __restrict  */)(buf___7), 2048, (FILE */* __restrict  */)fs);
      }
#line 1017
      if (! tmp___9) {
#line 1017
        goto while_break___2;
      }
      {
#line 1018
      category = 3;
#line 1019
      delimiters = " \t\r\n";
#line 1020
      tmp___4 = strtok((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)delimiters);
#line 1020
      p___0 = tmp___4;
      }
      {
#line 1021
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1021
        if (! p___0) {
#line 1021
          goto while_break___3;
        }
#line 1025
        if (category == 3) {
#line 1026
          ix = 0;
          {
#line 1026
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1026
            if (! (ix < 3)) {
#line 1026
              goto while_break___4;
            }
            {
#line 1027
            tmp___5 = strlen((char const   *)process_meminfo[ix].token);
#line 1027
            tmp___6 = strncmp((char const   *)p___0, (char const   *)process_meminfo[ix].token,
                              tmp___5);
            }
#line 1027
            if (! tmp___6) {
#line 1028
              category = ix;
#line 1029
              goto while_break___4;
            }
#line 1026
            ix ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 1036
        if ((int )*(p___0 + 0) == 78) {
          {
#line 1037
          tmp___7 = strtol((char const   */* __restrict  */)(p___0 + 1), (char **/* __restrict  */)(& p___0),
                           10);
#line 1037
          node_num = (int )tmp___7;
          }
#line 1038
          if ((int )*(p___0 + 0) != 61) {
            {
#line 1039
            perror("node value parse error");
#line 1040
            exit(1);
            }
          }
          {
#line 1042
          tmp___8 = strtol((char const   */* __restrict  */)(p___0 + 1), (char **/* __restrict  */)(& p___0),
                           10);
#line 1042
          value = (double )tmp___8;
#line 1043
          multiplier = page_size_in_bytes;
          }
#line 1044
          if (category == 0) {
#line 1045
            multiplier = huge_page_size_in_bytes;
          }
#line 1047
          value *= multiplier;
#line 1048
          value /= (double )1048576;
#line 1051
          if (show_sub_categories) {
#line 1052
            tmp_row = header_rows + category;
          } else {
#line 1054
            tmp_row = header_rows + pid_ix;
          }
          {
#line 1056
          tmp_col = header_cols + node_num;
#line 1057
          double_addto(& table, tmp_row, tmp_col, value);
#line 1058
          double_addto(& table, tmp_row, total_col_ix, value);
#line 1059
          double_addto(& table, total_row_ix, tmp_col, value);
#line 1060
          double_addto(& table, total_row_ix, total_col_ix, value);
          }
        }
        {
#line 1063
        p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delimiters);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1071
    tmp___10 = ferror(fs);
    }
#line 1071
    if (tmp___10) {
      {
#line 1072
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"Can\'t read /proc/%d/numa_maps",
              pid);
#line 1073
      perror((char const   *)(buf___7));
      }
    }
    {
#line 1075
    fclose(fs);
    }
#line 1078
    if (show_sub_categories) {
#line 1078
      goto _L;
    } else
#line 1078
    if (pid_ix + 1 == num_pids) {
      _L: /* CIL Label */ 
#line 1080
      if (compress_display) {
#line 1081
        col___0 = 0;
        {
#line 1081
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1081
          if (! (col___0 < (header_cols + num_nodes) + 1)) {
#line 1081
            goto while_break___5;
          }
          {
#line 1082
          auto_set_col_width(& table, col___0, 4, 16);
#line 1081
          col___0 ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 1088
        auto_set_col_width(& table, 0, 16, 24);
        }
      }
      {
#line 1091
      set_row_flag(& table, total_row_ix - 1, 1 << 4);
#line 1092
      col___1 = 0;
      }
      {
#line 1092
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1092
        if (! (col___1 < (header_cols + num_nodes) + 1)) {
#line 1092
          goto while_break___6;
        }
        {
#line 1093
        repchar_assign(& table, total_row_ix - 1, col___1, (char )'-');
#line 1092
        col___1 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1096
      if (sort_table) {
#line 1098
        if (sort_table_node < 0) {
#line 1099
          sort_col = total_col_ix;
        } else
#line 1098
        if (sort_table_node >= num_nodes) {
#line 1099
          sort_col = total_col_ix;
        } else {
#line 1101
          sort_col = header_cols + *(node_ix_map + sort_table_node);
        }
        {
#line 1103
        sort_rows_descending_by_col(& table, header_rows, (header_rows + data_rows) - 1,
                                    sort_col);
        }
      }
      {
#line 1106
      display_table(& table, screen_width, 0, 0, show_zero_data, show_zero_data);
      }
    }
    __Cont: /* CIL Label */ 
#line 984
    pid_ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1109
  free_table(& table);
  }
#line 1110
  return;
}
}
#line 1113 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int node_and_digits(struct dirent  const  *dptr ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 1114
  p = (char *)(dptr->d_name);
#line 1115
  tmp = p;
#line 1115
  p ++;
#line 1115
  if ((int )*tmp != 110) {
#line 1115
    return (0);
  }
#line 1116
  tmp___0 = p;
#line 1116
  p ++;
#line 1116
  if ((int )*tmp___0 != 111) {
#line 1116
    return (0);
  }
#line 1117
  tmp___1 = p;
#line 1117
  p ++;
#line 1117
  if ((int )*tmp___1 != 100) {
#line 1117
    return (0);
  }
#line 1118
  tmp___2 = p;
#line 1118
  p ++;
#line 1118
  if ((int )*tmp___2 != 101) {
#line 1118
    return (0);
  }
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1120
    tmp___3 = __ctype_b_loc();
#line 1120
    tmp___4 = p;
#line 1120
    p ++;
    }
#line 1120
    if (! ((int const   )*(*tmp___3 + (int )*tmp___4) & 2048)) {
#line 1120
      return (0);
    }
#line 1119
    if (! ((int )*p != 0)) {
#line 1119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return (1);
}
}
#line 1126 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void init_node_ix_map_and_header(int compatibility_mode___0 ) 
{ 
  struct dirent **namelist ;
  void *tmp ;
  int ix ;
  int ix___0 ;
  int smallest_ix ;
  int iy ;
  int tmp___0 ;
  void *tmp___1 ;
  int node_ix ;
  char node_label[64] ;
  char *s ;
  char *tmp___2 ;

  {
  {
#line 1129
  num_nodes = scandir((char const   */* __restrict  */)"/sys/devices/system/node",
                      (struct dirent ***/* __restrict  */)(& namelist), & node_and_digits,
                      (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 1130
  if (num_nodes < 1) {
#line 1131
    if (compatibility_mode___0) {
      {
#line 1132
      perror("sysfs not mounted or system not NUMA aware");
      }
    } else {
      {
#line 1134
      perror("Couldn\'t open /sys/devices/system/node");
      }
    }
    {
#line 1136
    exit(1);
    }
  } else {
    {
#line 1138
    tmp = malloc((unsigned long )num_nodes * sizeof(int ));
#line 1138
    node_ix_map = (int *)tmp;
    }
#line 1139
    if ((unsigned long )node_ix_map == (unsigned long )((void *)0)) {
      {
#line 1140
      perror("malloc failed line: 1140");
#line 1141
      exit(1);
      }
    }
#line 1144
    ix = 0;
    {
#line 1144
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1144
      if (! (ix < num_nodes)) {
#line 1144
        goto while_break;
      }
      {
#line 1145
      *(node_ix_map + ix) = atoi((char const   *)(& (*(namelist + ix))->d_name[4]));
#line 1146
      free((void *)*(namelist + ix));
#line 1144
      ix ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1148
    free((void *)namelist);
#line 1151
    ix___0 = 0;
    }
    {
#line 1151
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1151
      if (! (ix___0 < num_nodes)) {
#line 1151
        goto while_break___0;
      }
#line 1152
      smallest_ix = ix___0;
#line 1153
      iy = ix___0 + 1;
      {
#line 1153
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1153
        if (! (iy < num_nodes)) {
#line 1153
          goto while_break___1;
        }
#line 1154
        if (*(node_ix_map + smallest_ix) > *(node_ix_map + iy)) {
#line 1155
          smallest_ix = iy;
        }
#line 1153
        iy ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1158
      if (smallest_ix != ix___0) {
#line 1159
        tmp___0 = *(node_ix_map + ix___0);
#line 1160
        *(node_ix_map + ix___0) = *(node_ix_map + smallest_ix);
#line 1161
        *(node_ix_map + smallest_ix) = tmp___0;
      }
#line 1151
      ix___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1166
    tmp___1 = malloc((unsigned long )(num_nodes + 1) * sizeof(char *));
#line 1166
    node_header = (char **)tmp___1;
    }
#line 1167
    if ((unsigned long )node_header == (unsigned long )((void *)0)) {
      {
#line 1168
      perror("malloc failed line: 1168");
#line 1169
      exit(1);
      }
    }
#line 1171
    node_ix = 0;
    {
#line 1171
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1171
      if (! (node_ix <= num_nodes)) {
#line 1171
        goto while_break___2;
      }
#line 1173
      if (node_ix == num_nodes) {
        {
#line 1174
        strcpy((char */* __restrict  */)(node_label), (char const   */* __restrict  */)"Total");
        }
      } else
#line 1175
      if (compatibility_mode___0) {
        {
#line 1176
        snprintf((char */* __restrict  */)(node_label), sizeof(node_label), (char const   */* __restrict  */)"node%d",
                 *(node_ix_map + node_ix));
        }
      } else {
        {
#line 1178
        snprintf((char */* __restrict  */)(node_label), sizeof(node_label), (char const   */* __restrict  */)"Node %d",
                 *(node_ix_map + node_ix));
        }
      }
      {
#line 1180
      tmp___2 = strdup((char const   *)(node_label));
#line 1180
      s = tmp___2;
      }
#line 1181
      if ((unsigned long )s == (unsigned long )((void *)0)) {
        {
#line 1182
        perror("malloc failed line: 1182");
#line 1183
        exit(1);
        }
      }
#line 1185
      *(node_header + node_ix) = s;
#line 1171
      node_ix ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1188
  return;
}
}
#line 1191 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void free_node_ix_map_and_header(void) 
{ 
  int ix ;

  {
#line 1192
  if ((unsigned long )node_ix_map != (unsigned long )((void *)0)) {
    {
#line 1193
    free((void *)node_ix_map);
#line 1194
    node_ix_map = (int *)((void *)0);
    }
  }
#line 1196
  if ((unsigned long )node_header != (unsigned long )((void *)0)) {
#line 1197
    ix = 0;
    {
#line 1197
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1197
      if (! (ix <= num_nodes)) {
#line 1197
        goto while_break;
      }
      {
#line 1198
      free((void *)*(node_header + ix));
#line 1197
      ix ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1200
    free((void *)node_header);
#line 1201
    node_header = (char **)((void *)0);
    }
  }
#line 1203
  return;
}
}
#line 1206 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
double get_huge_page_size_in_bytes(void) 
{ 
  double huge_page_size___0 ;
  FILE *fs ;
  FILE *tmp ;
  char buf___7[128] ;
  char *p ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1207
  huge_page_size___0 = (double )0;
#line 1208
  tmp = fopen((char const   */* __restrict  */)"/proc/meminfo", (char const   */* __restrict  */)"r");
#line 1208
  fs = tmp;
  }
#line 1209
  if (! fs) {
    {
#line 1210
    perror("Can\'t open /proc/meminfo");
#line 1211
    exit(1);
    }
  }
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1214
    tmp___2 = fgets((char */* __restrict  */)(buf___7), 128, (FILE */* __restrict  */)fs);
    }
#line 1214
    if (! tmp___2) {
#line 1214
      goto while_break;
    }
    {
#line 1215
    tmp___1 = strncmp("Hugepagesize", (char const   *)(buf___7), (size_t )12);
    }
#line 1215
    if (! tmp___1) {
#line 1216
      p = & buf___7[12];
      {
#line 1217
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1217
        tmp___0 = __ctype_b_loc();
        }
#line 1217
        if ((int const   )*(*tmp___0 + (int )*p) & 2048) {
#line 1217
          goto while_break___0;
        } else
#line 1217
        if (! ((unsigned long )p < (unsigned long )(buf___7 + 128))) {
#line 1217
          goto while_break___0;
        }
#line 1218
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1220
      huge_page_size___0 = strtod((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0));
      }
#line 1221
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1224
  fclose(fs);
  }
#line 1225
  return (huge_page_size___0 * (double )1024);
}
}
#line 1229 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int all_digits(char *p ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 1230
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1231
    return (0);
  }
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if (! ((int )*p != 0)) {
#line 1233
      goto while_break;
    }
    {
#line 1234
    tmp = __ctype_b_loc();
#line 1234
    tmp___0 = p;
#line 1234
    p ++;
    }
#line 1234
    if (! ((int const   )*(*tmp + (int )*tmp___0) & 2048)) {
#line 1234
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  return (1);
}
}
#line 1240 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int starts_with_digit(struct dirent  const  *dptr ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 1241
  tmp = __ctype_b_loc();
  }
#line 1241
  return ((int )((int const   )*(*tmp + (int )dptr->d_name[0]) & 2048));
}
}
#line 1245 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void add_pid_to_list(int pid ) 
{ 
  int tmp ;
  int *tmp_int_ptr ;
  void *tmp___0 ;
  char buf___7[128] ;
  int tmp___1 ;

  {
#line 1246
  if (num_pids < pid_array_max_pids) {
#line 1247
    tmp = num_pids;
#line 1247
    num_pids ++;
#line 1247
    *(pid_array + tmp) = pid;
  } else {
#line 1249
    if (pid_array_max_pids == 0) {
#line 1250
      pid_array_max_pids = 32;
    }
    {
#line 1252
    tmp___0 = realloc((void *)pid_array, (unsigned long )(2 * pid_array_max_pids) * sizeof(int ));
#line 1252
    tmp_int_ptr = (int *)tmp___0;
    }
#line 1253
    if ((unsigned long )tmp_int_ptr == (unsigned long )((void *)0)) {
      {
#line 1255
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"Too many PIDs, skipping %d",
              pid);
#line 1256
      perror((char const   *)(buf___7));
      }
    } else {
#line 1258
      pid_array = tmp_int_ptr;
#line 1259
      pid_array_max_pids *= 2;
#line 1260
      tmp___1 = num_pids;
#line 1260
      num_pids ++;
#line 1260
      *(pid_array + tmp___1) = pid;
    }
  }
#line 1263
  return;
}
}
#line 1266 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
int ascending(void const   *p1 , void const   *p2 ) 
{ 


  {
#line 1267
  return (*((int *)p1) - *((int *)p2));
}
}
#line 1270 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void sort_pids_and_remove_duplicates(void) 
{ 
  int ix1 ;
  int ix2 ;

  {
#line 1271
  if (num_pids > 1) {
    {
#line 1272
    qsort((void *)pid_array, (size_t )num_pids, sizeof(int ), & ascending);
#line 1273
    ix1 = 0;
#line 1274
    ix2 = 1;
    }
    {
#line 1274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1274
      if (! (ix2 < num_pids)) {
#line 1274
        goto while_break;
      }
#line 1275
      if (*(pid_array + ix2) == *(pid_array + ix1)) {
#line 1276
        goto __Cont;
      }
#line 1278
      ix1 ++;
#line 1279
      if (ix2 > ix1) {
#line 1280
        *(pid_array + ix1) = *(pid_array + ix2);
      }
      __Cont: /* CIL Label */ 
#line 1274
      ix2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1283
    num_pids = ix1 + 1;
  }
#line 1285
  return;
}
}
#line 1288 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
void add_pids_from_pattern_search(char *pattern ) 
{ 
  int num_matches_found ;
  struct dirent **namelist ;
  int files ;
  int tmp ;
  int ix ;
  char buf___7[2048] ;
  int pid ;
  int tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char fname[64] ;
  FILE *fs ;
  FILE *tmp___2 ;
  char *tmp___3 ;
  int c___1 ;
  char *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1291
  num_matches_found = 0;
#line 1293
  tmp = scandir((char const   */* __restrict  */)"/proc", (struct dirent ***/* __restrict  */)(& namelist),
                & starts_with_digit, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
#line 1293
  files = tmp;
  }
#line 1294
  if (files < 0) {
    {
#line 1295
    perror("Couldn\'t open /proc");
    }
  }
#line 1297
  ix = 0;
  {
#line 1297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1297
    if (! (ix < files)) {
#line 1297
      goto while_break;
    }
    {
#line 1300
    tmp___0 = atoi((char const   *)((*(namelist + ix))->d_name));
#line 1300
    pid = tmp___0;
#line 1301
    tmp___1 = command_name_for_pid(pid);
#line 1301
    p = tmp___1;
    }
#line 1302
    if (p) {
      {
#line 1303
      strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)p);
      }
    } else {
#line 1305
      buf___7[0] = (char )'\000';
    }
    {
#line 1310
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/proc/%s/cmdline",
             (*(namelist + ix))->d_name);
#line 1311
    tmp___2 = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
#line 1311
    fs = tmp___2;
    }
#line 1312
    if (fs) {
#line 1313
      p = buf___7;
      {
#line 1314
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1314
        if (! ((int )*p != 0)) {
#line 1314
          goto while_break___0;
        }
#line 1315
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1317
      tmp___3 = p;
#line 1317
      p ++;
#line 1317
      *tmp___3 = (char )' ';
      {
#line 1319
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1319
        c___1 = fgetc(fs);
        }
#line 1319
        if (c___1 != -1) {
#line 1319
          if (! ((unsigned long )p < (unsigned long )((buf___7 + 2048) - 1))) {
#line 1319
            goto while_break___1;
          }
        } else {
#line 1319
          goto while_break___1;
        }
#line 1320
        if (c___1 == 0) {
#line 1321
          c___1 = ' ';
        }
#line 1323
        tmp___4 = p;
#line 1323
        p ++;
#line 1323
        *tmp___4 = (char )c___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1325
      tmp___5 = p;
#line 1325
      p ++;
#line 1325
      *tmp___5 = (char )'\000';
#line 1326
      fclose(fs);
      }
    }
    {
#line 1328
    tmp___7 = strstr((char const   *)(buf___7), (char const   *)pattern);
    }
#line 1328
    if (tmp___7) {
      {
#line 1329
      tmp___6 = getpid();
      }
#line 1329
      if (pid != tmp___6) {
        {
#line 1330
        add_pid_to_list(pid);
#line 1331
        num_matches_found ++;
        }
      }
    }
    {
#line 1334
    free((void *)*(namelist + ix));
#line 1297
    ix ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1336
  free((void *)namelist);
  }
#line 1337
  if (num_matches_found == 0) {
    {
#line 1338
    printf((char const   */* __restrict  */)"Found no processes containing pattern: \"%s\"\n",
           pattern);
    }
  }
#line 1340
  return;
}
}
#line 1347 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numastat.c"
static struct option long_options[2]  = {      {"help", 0, (int *)0, '?'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___0(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___0(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___0(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___0(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___0(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___0(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___0(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___0(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___0(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___0 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___0(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___0(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___0(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___0(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___0(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___0(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___0(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___0[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___0}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___0}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___0}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___0}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___0}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___0  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___0[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___0  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___0  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___0  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___0  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___0  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___0  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___0  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___0  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___0  =    0;
#line 80
static void set_sizes___0(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___0(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___0(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___0  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___0(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___0(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___0(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___0);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___1  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___0(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___0 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___0 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___0, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___0 < nd) {
#line 344
        maxconfigurednode___0 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___0(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___0(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___0  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___0  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___0(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___0, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___0((char const   *)buf___7, nodemask_prefix___0);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___0);
#line 385
      nodemask_sz___0 = s2nbits___0((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___0 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___0 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___0 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___0 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___0 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___0 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___0(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___0(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___0;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___0, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___0 = read_mask___0(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___0 = read_mask___0(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___0)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___0 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___0 = hicpu + 1;
  }
#line 520
  if (numproccpu___0 > hicpu + 1) {
#line 521
    numproccpu___0 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___0 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___0)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___0 = maxconfigurednode___0 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___0(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___0 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___0(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___0 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___0 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___0(void) 
{ 


  {
  {
#line 582
  sizes_set___0 ++;
#line 583
  set_nodemask_size___0();
#line 584
  set_configured_nodes___0();
#line 585
  set_numa_max_cpu___0();
#line 586
  set_configured_cpus___0();
#line 587
  set_task_constraints___0();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___0(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___0  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___0(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___0(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___0(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___0(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___0(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___0(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___0(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___0  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___0  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___0(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___0(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___0(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___0) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___0 = maxnode;
#line 106
  distance_table___0 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___1  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___1[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___1  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___1  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___1  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___1  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___1  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___1  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___1  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___1  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___1  =    0;
#line 80
static void set_sizes___1(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___1(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___1(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___1  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___1(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___1(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___1(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___1);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___2  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___1(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___1 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___1 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___1, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___1 < nd) {
#line 344
        maxconfigurednode___1 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___1(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___1(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___1  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___1  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___1(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___1, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___1((char const   *)buf___7, nodemask_prefix___1);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___1);
#line 385
      nodemask_sz___1 = s2nbits___1((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___1 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___1 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___1 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___1 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___1 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___1 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___1(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___1(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___1;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___1, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___1 = read_mask___1(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___1 = read_mask___1(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___1)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___1 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___1 = hicpu + 1;
  }
#line 520
  if (numproccpu___1 > hicpu + 1) {
#line 521
    numproccpu___1 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___1 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___1)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___1 = maxconfigurednode___1 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___1(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___1 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___1(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___1 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___1 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___1(void) 
{ 


  {
  {
#line 582
  sizes_set___1 ++;
#line 583
  set_nodemask_size___1();
#line 584
  set_configured_nodes___1();
#line 585
  set_numa_max_cpu___1();
#line 586
  set_configured_cpus___1();
#line 587
  set_task_constraints___1();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___1(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___1  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___1(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___1(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___1(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___1(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___1(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___1(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___1(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___1(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___1(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___1(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___1(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___1(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___1(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___1(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___1(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___1(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___1 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___1(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___1(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___1(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___1(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___1(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___1(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___1(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___1[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___1}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___1}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___1}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___1}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___1}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___1  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___1  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___1(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___1(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___1(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___1) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___1 = maxnode;
#line 106
  distance_table___1 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___2  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___2[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___2  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___2  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___2  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___2  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___2  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___2  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___2  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___2  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___2  =    0;
#line 80
static void set_sizes___2(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___2(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___2(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___2  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___2(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___2(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___2(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___2);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___3  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___2(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___2 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___2 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___2, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___2 < nd) {
#line 344
        maxconfigurednode___2 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___2(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___2(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___2  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___2  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___2(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___2, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___2((char const   *)buf___7, nodemask_prefix___2);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___2);
#line 385
      nodemask_sz___2 = s2nbits___2((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___2 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___2 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___2 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___2 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___2 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___2 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___2(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___2(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___2;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___2, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___2 = read_mask___2(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___2 = read_mask___2(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___2)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___2 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___2 = hicpu + 1;
  }
#line 520
  if (numproccpu___2 > hicpu + 1) {
#line 521
    numproccpu___2 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___2 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___2)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___2 = maxconfigurednode___2 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___2(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___2 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___2(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___2 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___2 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___2(void) 
{ 


  {
  {
#line 582
  sizes_set___2 ++;
#line 583
  set_nodemask_size___2();
#line 584
  set_configured_nodes___2();
#line 585
  set_numa_max_cpu___2();
#line 586
  set_configured_cpus___2();
#line 587
  set_task_constraints___2();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___2(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___2  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___2(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___2(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___2(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___2(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___2(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___2(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___2(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___2(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___2(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___2(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___2(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___2(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___2(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___2(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___2(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___2(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___2 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___2(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___2(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___2(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___2(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___2(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___2(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___2(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___2[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___2}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___2}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___2}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___2}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___2}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___2  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___2  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___2(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___2(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___2(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___2) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___2 = maxnode;
#line 106
  distance_table___2 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___3  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___3[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___3  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___3  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___3  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___3  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___3  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___3  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___3  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___3  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___3  =    0;
#line 80
static void set_sizes___3(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___3(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___3(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___3  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___3(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___3(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___3(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___3);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___4  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___3(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___3 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___3 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___3, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___3 < nd) {
#line 344
        maxconfigurednode___3 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___3(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___3(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___3  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___3  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___3(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___3, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___3((char const   *)buf___7, nodemask_prefix___3);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___3);
#line 385
      nodemask_sz___3 = s2nbits___3((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___3 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___3 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___3 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___3 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___3 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___3 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___3(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___3(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___3;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___3, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___3 = read_mask___3(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___3 = read_mask___3(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___3)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___3 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___3 = hicpu + 1;
  }
#line 520
  if (numproccpu___3 > hicpu + 1) {
#line 521
    numproccpu___3 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___3 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___3)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___3 = maxconfigurednode___3 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___3(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___3 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___3(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___3 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___3 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___3(void) 
{ 


  {
  {
#line 582
  sizes_set___3 ++;
#line 583
  set_nodemask_size___3();
#line 584
  set_configured_nodes___3();
#line 585
  set_numa_max_cpu___3();
#line 586
  set_configured_cpus___3();
#line 587
  set_task_constraints___3();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___3(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___3  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___3(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___3(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___3(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___3(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___3(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___3(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___3(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___3(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___3(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___3(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___3(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___3(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___3(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___3(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___3(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___3(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___3 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___3(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___3(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___3(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___3(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___3(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___3(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___3(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___3[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___3}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___3}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___3}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___3}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___3}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___3  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___3  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___3(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___3(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___3(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___3) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___3 = maxnode;
#line 106
  distance_table___3 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___4  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___4[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___4  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___4  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___4  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___4  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___4  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___4  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___4  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___4  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___4  =    0;
#line 80
static void set_sizes___4(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___4(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___4(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___4  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___4(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___4(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___4(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___4);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___5  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___4(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___4 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___4 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___4, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___4 < nd) {
#line 344
        maxconfigurednode___4 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___4(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___4(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___4  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___4  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___4(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___4, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___4((char const   *)buf___7, nodemask_prefix___4);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___4);
#line 385
      nodemask_sz___4 = s2nbits___4((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___4 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___4 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___4 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___4 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___4 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___4 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___4(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___4(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___4;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___4, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___4 = read_mask___4(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___4 = read_mask___4(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___4)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___4 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___4 = hicpu + 1;
  }
#line 520
  if (numproccpu___4 > hicpu + 1) {
#line 521
    numproccpu___4 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___4 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___4)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___4 = maxconfigurednode___4 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___4(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___4 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___4(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___4 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___4 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___4(void) 
{ 


  {
  {
#line 582
  sizes_set___4 ++;
#line 583
  set_nodemask_size___4();
#line 584
  set_configured_nodes___4();
#line 585
  set_numa_max_cpu___4();
#line 586
  set_configured_cpus___4();
#line 587
  set_task_constraints___4();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___4(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___4  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___4(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___4(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___4(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___4(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___4(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___4(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___4(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___4(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___4(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___4(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___4(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___4(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___4(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___4(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___4(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___4(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___4 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___4(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___4(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___4(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___4(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___4(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___4(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___4(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___4[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___4}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___4}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___4}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___4}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___4}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___4  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___4  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___4(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___4(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___4(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___4) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___4 = maxnode;
#line 106
  distance_table___4 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___5  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___5[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___5  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___5  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___5  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___5  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___5  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___5  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___5  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___5  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___5  =    0;
#line 80
static void set_sizes___5(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___5(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___5(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___5  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___5(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___5(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___5(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___5);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___6  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___5(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___5 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___5 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___5, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___5 < nd) {
#line 344
        maxconfigurednode___5 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___5(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___5(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___5  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___5  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___5(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___5, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___5((char const   *)buf___7, nodemask_prefix___5);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___5);
#line 385
      nodemask_sz___5 = s2nbits___5((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___5 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___5 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___5 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___5 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___5 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___5 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___5(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___5(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___5;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___5, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___5 = read_mask___5(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___5 = read_mask___5(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___5)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___5 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___5 = hicpu + 1;
  }
#line 520
  if (numproccpu___5 > hicpu + 1) {
#line 521
    numproccpu___5 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___5 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___5)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___5 = maxconfigurednode___5 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___5(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___5 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___5(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___5 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___5 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___5(void) 
{ 


  {
  {
#line 582
  sizes_set___5 ++;
#line 583
  set_nodemask_size___5();
#line 584
  set_configured_nodes___5();
#line 585
  set_numa_max_cpu___5();
#line 586
  set_configured_cpus___5();
#line 587
  set_task_constraints___5();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___5(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___5  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___5(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___5(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___5(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___5(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___5(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___5(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___5(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___5(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___5(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___5(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___5(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___5(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___5(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___5(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___5(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___5(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___5 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___5(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___5(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___5(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___5(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___5(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___5(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___5(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___5[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___5}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___5}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___5}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___5}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___5}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___5  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___5  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___5(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___5(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___5(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___5) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___5 = maxnode;
#line 106
  distance_table___5 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___6  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___6[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___6  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___6  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___6  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___6  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___6  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___6  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___6  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___6  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___6  =    0;
#line 80
static void set_sizes___6(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___6(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___6(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___6  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___6(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___6(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___6(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___6);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___7  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___6(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___6 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___6 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___6, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___6 < nd) {
#line 344
        maxconfigurednode___6 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___6(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___6(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___6  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___6  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___6(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___6, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___6((char const   *)buf___7, nodemask_prefix___6);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___6);
#line 385
      nodemask_sz___6 = s2nbits___6((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___6 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___6 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___6 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___6 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___6 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___6 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___6(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___6(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___6;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___6, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___6 = read_mask___6(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___6 = read_mask___6(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___6)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___6 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___6 = hicpu + 1;
  }
#line 520
  if (numproccpu___6 > hicpu + 1) {
#line 521
    numproccpu___6 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___6 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___6)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___6 = maxconfigurednode___6 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___6(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___6 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___6(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___6 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___6 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___6(void) 
{ 


  {
  {
#line 582
  sizes_set___6 ++;
#line 583
  set_nodemask_size___6();
#line 584
  set_configured_nodes___6();
#line 585
  set_numa_max_cpu___6();
#line 586
  set_configured_cpus___6();
#line 587
  set_task_constraints___6();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___6(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___6  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___6(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___6(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___6(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___6(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___6(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___6(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___6(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___6(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___6(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___6(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___6(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___6(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___6(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___6(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___6(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___6(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___6 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___6(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___6(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___6(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___6(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___6(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___6(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___6(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___6[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___6}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___6}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___6}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___6}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___6}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___6  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___6  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___6(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___6(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___6(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___6) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___6 = maxnode;
#line 106
  distance_table___6 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___7  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___7[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___7  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___7  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___7  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___7  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___7  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___7  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___7  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___7  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___7  =    0;
#line 80
static void set_sizes___7(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___7(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___7(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___7  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___7(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___7(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___7(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___7);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___8  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___7(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___7 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___7 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___7, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___7 < nd) {
#line 344
        maxconfigurednode___7 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___7(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___7(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___7  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___7  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___7(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___7, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___7((char const   *)buf___7, nodemask_prefix___7);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___7);
#line 385
      nodemask_sz___7 = s2nbits___7((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___7 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___7 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___7 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___7 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___7 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___7 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___7(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___7(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___7;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___7, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___7 = read_mask___7(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___7 = read_mask___7(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___7)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___7 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___7 = hicpu + 1;
  }
#line 520
  if (numproccpu___7 > hicpu + 1) {
#line 521
    numproccpu___7 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___7 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___7)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___7 = maxconfigurednode___7 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___7(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___7 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___7(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___7 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___7 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___7(void) 
{ 


  {
  {
#line 582
  sizes_set___7 ++;
#line 583
  set_nodemask_size___7();
#line 584
  set_configured_nodes___7();
#line 585
  set_numa_max_cpu___7();
#line 586
  set_configured_cpus___7();
#line 587
  set_task_constraints___7();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___7(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___7  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___7(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___7(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___7(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___7(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___7(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___7(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___7(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___7(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___7(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___7(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___7(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___7(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___7(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___7(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___7(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___7(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___7 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___7(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___7(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___7(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___7(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___7(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___7(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___7(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___7[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___7}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___7}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___7}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___7}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___7}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___7  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___7  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___7(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___7(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___7(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___7) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___7 = maxnode;
#line 106
  distance_table___7 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___8  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___8[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___8  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___8  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___8  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___8  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___8  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___8  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___8  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___8  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___8  =    0;
#line 80
static void set_sizes___8(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___8(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___8(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___8  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___8(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___8(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___8(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___8);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___9  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___8(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___8 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___8 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___8, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___8 < nd) {
#line 344
        maxconfigurednode___8 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___8(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___8(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___8  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___8  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___8(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___8, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___8((char const   *)buf___7, nodemask_prefix___8);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___8);
#line 385
      nodemask_sz___8 = s2nbits___8((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___8 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___8 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___8 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___8 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___8 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___8 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___8(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___8(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___8;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___8, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___8 = read_mask___8(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___8 = read_mask___8(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___8)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___8 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___8 = hicpu + 1;
  }
#line 520
  if (numproccpu___8 > hicpu + 1) {
#line 521
    numproccpu___8 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___8 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___8)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___8 = maxconfigurednode___8 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___8(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___8 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___8(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___8 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___8 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___8(void) 
{ 


  {
  {
#line 582
  sizes_set___8 ++;
#line 583
  set_nodemask_size___8();
#line 584
  set_configured_nodes___8();
#line 585
  set_numa_max_cpu___8();
#line 586
  set_configured_cpus___8();
#line 587
  set_task_constraints___8();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___8(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___8  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___8(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___8(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___8(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___8(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___8(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___8(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___8(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___8(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___8(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___8(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___8(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___8(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___8(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___8(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___8(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___8(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___8 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___8(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___8(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___8(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___8(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___8(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___8(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___8(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___8[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___8}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___8}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___8}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___8}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___8}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___8  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___8  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___8(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___8(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___8(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___8) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___8 = maxnode;
#line 106
  distance_table___8 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___9  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___9[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___9  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___9  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___9  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___9  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___9  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___9  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___9  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___9  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___9  =    0;
#line 80
static void set_sizes___9(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___9(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___9(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___9  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___9(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___9(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___9(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___9);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___10  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___9(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___9 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___9 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___9, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___9 < nd) {
#line 344
        maxconfigurednode___9 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___9(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___9(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___9  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___9  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___9(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___9, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___9((char const   *)buf___7, nodemask_prefix___9);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___9);
#line 385
      nodemask_sz___9 = s2nbits___9((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___9 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___9 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___9 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___9 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___9 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___9 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___9(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___9(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___9;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___9, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___9 = read_mask___9(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___9 = read_mask___9(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___9)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___9 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___9 = hicpu + 1;
  }
#line 520
  if (numproccpu___9 > hicpu + 1) {
#line 521
    numproccpu___9 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___9 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___9)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___9 = maxconfigurednode___9 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___9(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___9 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___9(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___9 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___9 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___9(void) 
{ 


  {
  {
#line 582
  sizes_set___9 ++;
#line 583
  set_nodemask_size___9();
#line 584
  set_configured_nodes___9();
#line 585
  set_numa_max_cpu___9();
#line 586
  set_configured_cpus___9();
#line 587
  set_task_constraints___9();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___9(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___9  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___9(char const   *s , char **end___0 , struct bitmask *bmp ,
                                int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___9(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___9(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___9(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___9(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___9(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___9(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___9(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___9(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___9(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___9(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___9(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___9(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___9(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___9(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___9(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___9 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___9(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___9(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___9(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___9(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___9(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___9(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___9(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___9[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___9}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___9}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___9}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___9}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___9}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___9  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___9  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___9(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___9(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___9(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___9) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___9 = maxnode;
#line 106
  distance_table___9 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___10  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___10[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___10  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___10  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___10  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___10  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___10  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___10  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___10  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___10  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___10  =    0;
#line 80
static void set_sizes___10(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___10(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___10(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___10  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___10(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___10(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___10(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___10);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___11  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___10(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___10 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___10 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___10, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___10 < nd) {
#line 344
        maxconfigurednode___10 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___10(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___10(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___10  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___10  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___10(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___10, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___10((char const   *)buf___7, nodemask_prefix___10);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___10);
#line 385
      nodemask_sz___10 = s2nbits___10((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___10 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___10 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___10 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___10 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___10 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___10 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___10(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___10(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___10;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___10, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___10 = read_mask___10(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___10 = read_mask___10(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___10)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___10 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___10 = hicpu + 1;
  }
#line 520
  if (numproccpu___10 > hicpu + 1) {
#line 521
    numproccpu___10 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___10 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___10)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___10 = maxconfigurednode___10 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___10(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___10 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___10(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___10 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___10 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___10(void) 
{ 


  {
  {
#line 582
  sizes_set___10 ++;
#line 583
  set_nodemask_size___10();
#line 584
  set_configured_nodes___10();
#line 585
  set_numa_max_cpu___10();
#line 586
  set_configured_cpus___10();
#line 587
  set_task_constraints___10();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___10(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___10  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___10(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___10(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___10(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___10(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___10(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___10(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___10(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___10(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___10(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___10(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___10(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___10(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___10(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___10(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___10(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___10(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___10 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___10(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___10(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___10(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___10(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___10(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___10(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___10(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___10[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___10}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___10}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___10}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___10}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___10}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___10  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___10  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___10(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___10(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___10(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___10) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___10 = maxnode;
#line 106
  distance_table___10 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___11  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___11[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___11  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___11  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___11  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___11  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___11  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___11  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___11  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___11  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___11  =    0;
#line 80
static void set_sizes___11(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___11(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___11(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___11  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___11(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___11(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___11(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___11);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___12  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___11(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___11 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___11 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___11, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___11 < nd) {
#line 344
        maxconfigurednode___11 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___11(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___11(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___11  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___11  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___11(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___11, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___11((char const   *)buf___7, nodemask_prefix___11);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___11);
#line 385
      nodemask_sz___11 = s2nbits___11((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___11 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___11 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___11 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___11 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___11 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___11 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___11(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___11(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___11;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___11, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___11 = read_mask___11(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___11 = read_mask___11(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___11)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___11 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___11 = hicpu + 1;
  }
#line 520
  if (numproccpu___11 > hicpu + 1) {
#line 521
    numproccpu___11 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___11 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___11)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___11 = maxconfigurednode___11 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___11(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___11 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___11(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___11 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___11 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___11(void) 
{ 


  {
  {
#line 582
  sizes_set___11 ++;
#line 583
  set_nodemask_size___11();
#line 584
  set_configured_nodes___11();
#line 585
  set_numa_max_cpu___11();
#line 586
  set_configured_cpus___11();
#line 587
  set_task_constraints___11();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___11(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___11  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___11(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___11(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___11(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___11(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___11(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___11(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___11(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___11(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___11(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___11(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___11(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___11(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___11(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___11(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___11(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___11(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___11 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___11(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___11(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___11(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___11(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___11(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___11(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___11(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___11[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___11}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___11}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___11}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___11}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___11}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies___0[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names___0[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf___2[32]  ;
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___11  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___11  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___11(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___11(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___11(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___11) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___11 = maxnode;
#line 106
  distance_table___11 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___12  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___12[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___12  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___12  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___12  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___12  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___12  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___12  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___12  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___12  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___12  =    0;
#line 80
static void set_sizes___12(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___12(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___12(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___12  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___12(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___12(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___12(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___12);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___13  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___12(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___12 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___12 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___12, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___12 < nd) {
#line 344
        maxconfigurednode___12 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___12(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___12(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___12  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___12  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___12(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___12, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___12((char const   *)buf___7, nodemask_prefix___12);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___12);
#line 385
      nodemask_sz___12 = s2nbits___12((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___12 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___12 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___12 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___12 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___12 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___12 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___12(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___12(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___12;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___12, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___12 = read_mask___12(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___12 = read_mask___12(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___12)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___12 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___12 = hicpu + 1;
  }
#line 520
  if (numproccpu___12 > hicpu + 1) {
#line 521
    numproccpu___12 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___12 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___12)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___12 = maxconfigurednode___12 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___12(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___12 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___12(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___12 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___12 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___12(void) 
{ 


  {
  {
#line 582
  sizes_set___12 ++;
#line 583
  set_nodemask_size___12();
#line 584
  set_configured_nodes___12();
#line 585
  set_numa_max_cpu___12();
#line 586
  set_configured_cpus___12();
#line 587
  set_task_constraints___12();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___12(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___12  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___12(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___12(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___12(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___12(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___12(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___12(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___12(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___12(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___12(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___12(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___12(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___12(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___12(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___12(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___12(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___12(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___12 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___12(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___12(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___12(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___12(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___12(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___12(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___12(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___12[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___12}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___12}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___12}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___12}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___12}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___12  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___12  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___12(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___12(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___12(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___12) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___12 = maxnode;
#line 106
  distance_table___12 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___13  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___13[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___13  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___13  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___13  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___13  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___13  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___13  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___13  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___13  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___13  =    0;
#line 80
static void set_sizes___13(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___13(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___13(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___13  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___13(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___13(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___13(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___13);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___14  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___13(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___13 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___13 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___13, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___13 < nd) {
#line 344
        maxconfigurednode___13 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___13(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___13(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___13  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___13  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___13(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___13, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___13((char const   *)buf___7, nodemask_prefix___13);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___13);
#line 385
      nodemask_sz___13 = s2nbits___13((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___13 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___13 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___13 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___13 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___13 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___13 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___13(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___13(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___13;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___13, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___13 = read_mask___13(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___13 = read_mask___13(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___13)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___13 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___13 = hicpu + 1;
  }
#line 520
  if (numproccpu___13 > hicpu + 1) {
#line 521
    numproccpu___13 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___13 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___13)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___13 = maxconfigurednode___13 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___13(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___13 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___13(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___13 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___13 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___13(void) 
{ 


  {
  {
#line 582
  sizes_set___13 ++;
#line 583
  set_nodemask_size___13();
#line 584
  set_configured_nodes___13();
#line 585
  set_numa_max_cpu___13();
#line 586
  set_configured_cpus___13();
#line 587
  set_task_constraints___13();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___13(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___13  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___13(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___13(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___13(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___13(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___13(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___13(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___13(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___13(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___13(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___13(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___13(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___13(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___13(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___13(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___13(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___13(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___13 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___13(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___13(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___13(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___13(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___13(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___13(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___13(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___13[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___13}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___13}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___13}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___13}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___13}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___13  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___13  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___13(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___13(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___13(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___13) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___13 = maxnode;
#line 106
  distance_table___13 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___14  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___14[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___14  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___14  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___14  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___14  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___14  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___14  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___14  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___14  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___14  =    0;
#line 80
static void set_sizes___14(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___14(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___14(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___14  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___14(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___14(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___14(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___14);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___15  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___14(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___14 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___14 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___14, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___14 < nd) {
#line 344
        maxconfigurednode___14 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___14(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___14(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___14  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___14  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___14(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___14, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___14((char const   *)buf___7, nodemask_prefix___14);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___14);
#line 385
      nodemask_sz___14 = s2nbits___14((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___14 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___14 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___14 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___14 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___14 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___14 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___14(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___14(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___14;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___14, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___14 = read_mask___14(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___14 = read_mask___14(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___14)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___14 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___14 = hicpu + 1;
  }
#line 520
  if (numproccpu___14 > hicpu + 1) {
#line 521
    numproccpu___14 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___14 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___14)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___14 = maxconfigurednode___14 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___14(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___14 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___14(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___14 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___14 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___14(void) 
{ 


  {
  {
#line 582
  sizes_set___14 ++;
#line 583
  set_nodemask_size___14();
#line 584
  set_configured_nodes___14();
#line 585
  set_numa_max_cpu___14();
#line 586
  set_configured_cpus___14();
#line 587
  set_task_constraints___14();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___14(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___14  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___14(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___14(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___14(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___14(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___14(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___14(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___14(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___14(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___14(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___14(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___14(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___14(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___14(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___14(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___14(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___14(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___14 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___14(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___14(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___14(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___14(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___14(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___14(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___14(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___14[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___14}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___14}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___14}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___14}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___14}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___14  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___14  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___14(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___14(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___14(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___14) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___14 = maxnode;
#line 106
  distance_table___14 = table;
#line 107
  return (0);
}
}
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 376 "/usr/include/unistd.h"
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 156 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open64)(char const   *__file , int __oflag 
                                                     , ...) ;
#line 34 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
static int mem[3]  = {      168,      152,      104};
#line 35 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
static int io[3]  = {      164,      148,      100};
#line 36 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
static int *masks  =    mem;
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
int force  =    0;
#line 60 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
int msrfd[8]  ;
#line 61 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
int delay  ;
#line 62 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
int absolute  ;
#line 63 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
char *cfilter  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void Vprintf(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 71
  __builtin_va_start(ap, fmt);
  }
#line 72
  if (verbose) {
    {
#line 73
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
    }
  }
  {
#line 74
  __builtin_va_end(ap);
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
unsigned long long rdmsr(int cpu , unsigned long msr ) 
{ 
  unsigned long long val ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 80
  tmp___1 = pread(msrfd[cpu], (void *)(& val), (size_t )8, (__off_t )msr);
  }
#line 80
  if (tmp___1 != 8L) {
    {
#line 81
    tmp = __errno_location();
#line 81
    tmp___0 = strerror(*tmp);
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rdmsr of %lx failed: %s\n",
            msr, tmp___0);
#line 82
    exit(1);
    }
  }
#line 84
  return (val);
}
}
#line 87 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void wrmsr(int cpu , unsigned long msr , unsigned long long value ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 89
  tmp___1 = pwrite(msrfd[cpu], (void const   *)(& value), (size_t )8, (__off_t )msr);
  }
#line 89
  if (tmp___1 != 8L) {
    {
#line 90
    tmp = __errno_location();
#line 90
    tmp___0 = strerror(*tmp);
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wdmsr of %lx failed: %s\n",
            msr, tmp___0);
#line 91
    exit(1);
    }
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
int cpufilter(int cpu ) 
{ 
  long num ;
  char *end___0 ;
  char *s ;
  unsigned long tmp ;

  {
#line 101
  if (! cfilter) {
#line 102
    return (1);
  }
#line 103
  s = cfilter;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                  0);
#line 104
    num = (long )tmp;
    }
#line 105
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 106
      usage();
      }
    }
#line 107
    if ((long )cpu == num) {
#line 108
      return (1);
    }
#line 109
    if ((int )*end___0 == 44) {
#line 110
      s = end___0 + 1;
    } else
#line 111
    if ((int )*end___0 == 0) {
#line 112
      goto while_break;
    } else {
      {
#line 114
      usage();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (0);
}
}
#line 119 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void checkcounter(int cpu , int clear ) 
{ 
  int i ;
  int clear_this ;
  unsigned long long evtsel ;
  unsigned long long tmp ;

  {
#line 122
  i = 1;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < 4)) {
#line 122
      goto while_break;
    }
    {
#line 123
    clear_this = clear;
#line 124
    tmp = rdmsr(cpu, (unsigned long )(3221291008U + (unsigned int )i));
#line 124
    evtsel = tmp;
#line 125
    Vprintf((char *)"%d: %x %Lx\n", cpu, 3221291008U + (unsigned int )i, evtsel);
    }
#line 126
    if (! (evtsel & (unsigned long long )(1 << 22))) {
      {
#line 127
      Vprintf((char *)"reinit %d\n", cpu);
#line 128
      wrmsr(cpu, (unsigned long )(3221291008U + (unsigned int )i), (unsigned long long )((((233 | (1 << 22)) | (1 << 17)) | (1 << 16)) | *(masks + (i - 1))));
#line 129
      clear_this = 1;
      }
    } else
#line 130
    if (! (evtsel == (unsigned long long )((((233 | (1 << 22)) | (1 << 17)) | (1 << 16)) | (*(masks + (i - 1)) << 8)))) {
#line 132
      if (force) {
        {
#line 133
        Vprintf((char *)"reinit force %d\n", cpu);
#line 134
        wrmsr(cpu, (unsigned long )(3221291008U + (unsigned int )i), (unsigned long long )((((233 | (1 << 22)) | (1 << 17)) | (1 << 16)) | (*(masks + (i - 1)) << 8)));
#line 135
        clear_this = 1;
        }
      } else {
        {
#line 137
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"perfctr %d cpu %d already used with %Lx\n",
                i, cpu, evtsel);
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Consider using -f if you know what you\'re doing.\n");
#line 140
        exit(1);
        }
      }
    }
#line 142
    if (clear_this) {
      {
#line 143
      Vprintf((char *)"clearing %d\n", cpu);
#line 144
      wrmsr(cpu, (unsigned long )(3221291012U + (unsigned int )i), 0ULL);
      }
    }
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void setup(int clear ) 
{ 
  DIR *dir ;
  struct dirent *d ;
  int numcpus ;
  char buf___7[64] ;
  char *end___0 ;
  long cpunum ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 153
  numcpus = 0;
#line 155
  memset((void *)(msrfd), -1, sizeof(msrfd));
#line 156
  dir = opendir("/dev/cpu");
  }
#line 157
  if (! dir) {
    {
#line 158
    perror("cannot open /dev/cpu");
#line 158
    exit(1);
    }
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    d = readdir(dir);
    }
#line 159
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 159
      goto while_break;
    }
    {
#line 162
    tmp = strtoul((char const   */* __restrict  */)(d->d_name), (char **/* __restrict  */)(& end___0),
                  0);
#line 162
    cpunum = (long )tmp;
    }
#line 163
    if ((int )*end___0 != 0) {
#line 164
      goto while_continue;
    }
#line 165
    if (cpunum > 8L) {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many cpus %ld %s\n",
              cpunum, d->d_name);
      }
#line 167
      goto while_continue;
    }
    {
#line 169
    tmp___0 = cpufilter((int )cpunum);
    }
#line 169
    if (! tmp___0) {
#line 170
      goto while_continue;
    }
    {
#line 171
    snprintf((char */* __restrict  */)(buf___7), (size_t )63, (char const   */* __restrict  */)"/dev/cpu/%ld/msr",
             cpunum);
#line 172
    msrfd[cpunum] = open64((char const   *)(buf___7), 2);
    }
#line 173
    if (msrfd[cpunum] < 0) {
#line 174
      goto while_continue;
    }
    {
#line 175
    numcpus ++;
#line 176
    checkcounter((int )cpunum, clear);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  closedir(dir);
  }
#line 179
  if (numcpus == 0) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No CPU found using MSR driver.\n");
#line 181
    exit(1);
    }
  }
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void printf_padded(int pad , char *fmt  , ...) 
{ 
  char *buf___7 ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  va_list ap ;

  {
  {
#line 187
  __lengthofbuf = (unsigned long )(pad + 1);
#line 187
  tmp = __builtin_alloca(sizeof(*buf___7) * __lengthofbuf);
#line 187
  buf___7 = (char *)tmp;
#line 189
  __builtin_va_start(ap, fmt);
#line 190
  vsnprintf((char */* __restrict  */)buf___7, (size_t )pad, (char const   */* __restrict  */)fmt,
            ap);
#line 191
  printf((char const   */* __restrict  */)"%-*s", pad, buf___7);
#line 192
  __builtin_va_end(ap);
  }
#line 193
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void print_header(void) 
{ 


  {
  {
#line 197
  printf_padded(4, (char *)"CPU ");
#line 198
  printf_padded(16, (char *)"LOCAL");
#line 199
  printf_padded(16, (char *)"LOCAL->REMOTE");
#line 200
  printf_padded(16, (char *)"REMOTE->LOCAL");
#line 201
  putchar('\n');
  }
#line 202
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
static unsigned long long lastval[4]  ;
#line 204 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void print_cpu(int cpu ) 
{ 
  int i ;
  unsigned long long val ;
  unsigned long long tmp ;

  {
  {
#line 208
  printf_padded(4, (char *)"%d", cpu);
#line 209
  i = 1;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < 4)) {
#line 209
      goto while_break;
    }
    {
#line 210
    tmp = rdmsr(cpu, (unsigned long )(3221291012U + (unsigned int )i));
#line 210
    val = tmp;
    }
#line 211
    if (absolute) {
      {
#line 212
      printf_padded(16, (char *)"%Lu", val);
      }
    } else {
      {
#line 214
      printf_padded(16, (char *)"%Lu", val - lastval[i]);
      }
    }
#line 215
    lastval[i] = val;
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  putchar('\n');
  }
#line 218
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void dumpall(void) 
{ 
  int cnt ;
  int cpu ;

  {
  {
#line 222
  cnt = 0;
#line 224
  print_header();
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    cpu = 0;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (cpu < 8)) {
#line 226
        goto while_break___0;
      }
#line 227
      if (msrfd[cpu] < 0) {
#line 228
        goto __Cont;
      }
      {
#line 229
      print_cpu(cpu);
      }
      __Cont: /* CIL Label */ 
#line 226
      cpu ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 231
    if (! delay) {
#line 232
      goto while_break;
    }
    {
#line 233
    sleep((unsigned int )delay);
#line 234
    cnt ++;
    }
#line 234
    if (cnt > 40) {
      {
#line 235
      cnt = 0;
#line 236
      print_header();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numamon.c"
void checkk8(void) 
{ 
  char *line ;
  size_t size___20 ;
  int bad ;
  FILE *f ;
  FILE *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *s ;
  size_t tmp___2 ;
  int family ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  __ssize_t tmp___5 ;

  {
  {
#line 243
  line = (char *)((void *)0);
#line 244
  size___20 = (size_t )0;
#line 245
  bad = 0;
#line 246
  tmp = fopen((char const   */* __restrict  */)"/proc/cpuinfo", (char const   */* __restrict  */)"r");
#line 246
  f = tmp;
  }
#line 247
  if (! f) {
#line 248
    return;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    tmp___5 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& size___20),
                      (FILE */* __restrict  */)f);
    }
#line 249
    if (! (tmp___5 > 0L)) {
#line 249
      goto while_break;
    }
    {
#line 250
    tmp___1 = strncmp("vendor_id", (char const   *)line, (size_t )9);
    }
#line 250
    if (! tmp___1) {
      {
#line 251
      tmp___0 = strstr((char const   *)line, "AMD");
      }
#line 251
      if (! tmp___0) {
#line 252
        bad ++;
      }
    }
    {
#line 254
    tmp___4 = strncmp("cpu family", (char const   *)line, (size_t )10);
    }
#line 254
    if (! tmp___4) {
      {
#line 255
      tmp___2 = strcspn((char const   *)line, ":");
#line 255
      s = line + tmp___2;
      }
#line 257
      if ((int )*s == 58) {
#line 257
        s ++;
      }
      {
#line 258
      tmp___3 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                        0);
#line 258
      family = (int )tmp___3;
      }
#line 259
      if (family != 15) {
#line 260
        bad ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bad) {
    {
#line 264
    printf((char const   */* __restrict  */)"not a opteron cpu\n");
#line 265
    exit(1);
    }
  }
  {
#line 267
  free((void *)line);
#line 268
  fclose(f);
  }
#line 269
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies___1[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names___1[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf___3[32]  ;
#line 1 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.h"
long stream_memsize(void) ;
#line 2
long stream_init(void *mem___0 ) ;
#line 4
void stream_test(double *res ) ;
#line 14 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_main.c"
char *policy  =    (char *)"default";
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___15  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___15  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___15(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___15(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___15(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___15) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___15 = maxnode;
#line 106
  distance_table___15 = table;
#line 107
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___15  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___15[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___15  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___15  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___15  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___15  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___15  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___15  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___15  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___15  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___15  =    0;
#line 80
static void set_sizes___15(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___15(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___15(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___15  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___15(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___15(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___15(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___15);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___16  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___15(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___15 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___15 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___15, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___15 < nd) {
#line 344
        maxconfigurednode___15 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___15(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___15(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___15  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___15  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___15(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___15, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___15((char const   *)buf___7, nodemask_prefix___15);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___15);
#line 385
      nodemask_sz___15 = s2nbits___15((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___15 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___15 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___15 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___15 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___15 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___15 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___15(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___15(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___15;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___15, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___15 = read_mask___15(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___15 = read_mask___15(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___15)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___15 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___15 = hicpu + 1;
  }
#line 520
  if (numproccpu___15 > hicpu + 1) {
#line 521
    numproccpu___15 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___15 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___15)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___15 = maxconfigurednode___15 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___15(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___15 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___15(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___15 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___15 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___15(void) 
{ 


  {
  {
#line 582
  sizes_set___15 ++;
#line 583
  set_nodemask_size___15();
#line 584
  set_configured_nodes___15();
#line 585
  set_numa_max_cpu___15();
#line 586
  set_configured_cpus___15();
#line 587
  set_task_constraints___15();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___15(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___15  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___15(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___15(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___15(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___15(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___15(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___15(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___15(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x )  __asm__("__sqrt_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gamma)(double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) lgamma_r)(double  ,
                                                                                  int *__signgamp )  __asm__("__lgamma_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammaf)(float __d ) ;
#line 271
extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__)) lgammaf_r)(float  ,
                                                                                  int *__signgamp )  __asm__("__lgammaf_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammal)(long double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) lgammal_r)(long double  ,
                                                                                        int *__signgamp )  __asm__("__lgammal_r_finite")  ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) 
{ 
  int __local_signgam ;
  double tmp ;

  {
  {
#line 259
  __local_signgam = 0;
#line 260
  tmp = lgamma_r(__d, & __local_signgam);
  }
#line 260
  return ((double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 265
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float tmp ;

  {
  {
#line 268
  __local_signgam = 0;
#line 269
  tmp = lgammaf_r(__d, & __local_signgam);
  }
#line 269
  return ((float __attribute__((__gnu_inline__))  )tmp);
}
}
#line 275
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 275 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double tmp ;

  {
  {
#line 278
  __local_signgam = 0;
#line 279
  tmp = lgammal_r(__d, & __local_signgam);
  }
#line 279
  return ((long double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 427
extern double __gamma_r_finite(double  , int * ) ;
#line 428
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 428 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) 
{ 
  int __local_signgam ;
  double __res ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 430
  __local_signgam = 0;
#line 431
  tmp = __gamma_r_finite(__d, & __local_signgam);
#line 431
  __res = tmp;
  }
#line 432
  if (__local_signgam < 0) {
#line 432
    tmp___0 = - __res;
  } else {
#line 432
    tmp___0 = __res;
  }
#line 432
  return ((double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 434
extern float __gammaf_r_finite(float  , int * ) ;
#line 435
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 435 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float __res ;
  float tmp ;
  float tmp___0 ;

  {
  {
#line 437
  __local_signgam = 0;
#line 438
  tmp = __gammaf_r_finite(__d, & __local_signgam);
#line 438
  __res = tmp;
  }
#line 439
  if (__local_signgam < 0) {
#line 439
    tmp___0 = - __res;
  } else {
#line 439
    tmp___0 = __res;
  }
#line 439
  return ((float __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 442
extern long double __gammal_r_finite(long double  , int * ) ;
#line 443
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 443 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double __res ;
  long double tmp ;
  long double tmp___0 ;

  {
  {
#line 445
  __local_signgam = 0;
#line 449
  tmp = __gammal_r_finite(__d, & __local_signgam);
#line 449
  __res = tmp;
  }
#line 451
  if (__local_signgam < 0) {
#line 451
    tmp___0 = - __res;
  } else {
#line 451
    tmp___0 = __res;
  }
#line 451
  return ((long double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 5 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.h"
void stream_check(void) ;
#line 6
void stream_setmem(unsigned long size___20 ) ;
#line 7
int stream_verbose ;
#line 8
char *stream_names[4] ;
#line 9 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
__inline static double mysecond(void) 
{ 
  struct timeval tv ;

  {
  {
#line 12
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 13
  return ((double )tv.tv_sec + (double )tv.tv_usec * 1.e-6);
}
}
#line 38 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
long N  =    8000000L;
#line 63
int checktick(void) ;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *a  ;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *b  ;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *c  ;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double rmstime[4]  = {      (double )0};
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double maxtime[4]  = {      (double )0};
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double mintime[4]  = {      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F};
#line 80 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static char *label[4]  = {      (char *)"Copy:      ",      (char *)"Scale:     ",      (char *)"Add:       ",      (char *)"Triad:     "};
#line 83 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
char *stream_names[4]  = {      (char *)"Copy",      (char *)"Scale",      (char *)"Add",      (char *)"Triad"};
#line 85 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double bytes[4]  ;
#line 87 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
int stream_verbose  =    1;
#line 91 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
void stream_check(void) 
{ 
  int quantum ;
  int BytesPerWord ;
  register int j ;
  double t ;
  double tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (stream_verbose) {
      {
#line 100
      printf((char const   */* __restrict  */)"-------------------------------------------------------------\n");
      }
    }
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  BytesPerWord = (int )sizeof(double );
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (stream_verbose) {
      {
#line 102
      printf((char const   */* __restrict  */)"This system uses %d bytes per DOUBLE PRECISION word.\n",
             BytesPerWord);
      }
    }
#line 102
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (stream_verbose) {
      {
#line 105
      printf((char const   */* __restrict  */)"-------------------------------------------------------------\n");
      }
    }
#line 105
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (stream_verbose) {
      {
#line 106
      printf((char const   */* __restrict  */)"Array size = %lu, Offset = %d\n", N,
             0);
      }
    }
#line 106
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 107
    if (stream_verbose) {
      {
#line 107
      printf((char const   */* __restrict  */)"Total memory required = %.1f MB.\n",
             (double )((3L * N) * (long )BytesPerWord) / 1048576.0);
      }
    }
#line 107
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 109
    if (stream_verbose) {
      {
#line 109
      printf((char const   */* __restrict  */)"Each test is run %d times, but only\n",
             10);
      }
    }
#line 109
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 110
    if (stream_verbose) {
      {
#line 110
      printf((char const   */* __restrict  */)"the *best* time for each is used.\n");
      }
    }
#line 110
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 114
  j = 0;
  {
#line 114
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 114
    if (! ((long )j < N)) {
#line 114
      goto while_break___6;
    }
#line 115
    *(a + j) = 1.0;
#line 116
    *(b + j) = 2.0;
#line 117
    *(c + j) = 0.0;
#line 114
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 120
    if (stream_verbose) {
      {
#line 120
      printf((char const   */* __restrict  */)"-------------------------------------------------------------\n");
      }
    }
#line 120
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 122
  quantum = checktick();
  }
#line 122
  if (quantum >= 1) {
    {
#line 123
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 123
      if (stream_verbose) {
        {
#line 123
        printf((char const   */* __restrict  */)"Your clock granularity/precision appears to be %d microseconds.\n",
               quantum);
        }
      }
#line 123
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  } else {
    {
#line 126
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 126
      if (stream_verbose) {
        {
#line 126
        printf((char const   */* __restrict  */)"Your clock granularity appears to be less than one microsecond.\n");
        }
      }
#line 126
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 129
  t = mysecond();
#line 130
  j = 0;
  }
  {
#line 130
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 130
    if (! ((long )j < N)) {
#line 130
      goto while_break___10;
    }
#line 131
    *(a + j) = 2.0E0 * *(a + j);
#line 130
    j ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 132
  tmp = mysecond();
#line 132
  t = 1.0E6 * (tmp - t);
  }
  {
#line 134
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 134
    if (stream_verbose) {
      {
#line 134
      printf((char const   */* __restrict  */)"Each test below will take on the order of %d microseconds.\n",
             (int )t);
      }
    }
#line 134
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 136
    if (stream_verbose) {
      {
#line 136
      printf((char const   */* __restrict  */)"   (= %d clock ticks)\n", (int )(t / (double )quantum));
      }
    }
#line 136
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 137
    if (stream_verbose) {
      {
#line 137
      printf((char const   */* __restrict  */)"Increase the size of the arrays if this shows that\n");
      }
    }
#line 137
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 138
    if (stream_verbose) {
      {
#line 138
      printf((char const   */* __restrict  */)"you are not getting at least 20 clock ticks per test.\n");
      }
    }
#line 138
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 140
    if (stream_verbose) {
      {
#line 140
      printf((char const   */* __restrict  */)"-------------------------------------------------------------\n");
      }
    }
#line 140
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 142
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 142
    if (stream_verbose) {
      {
#line 142
      printf((char const   */* __restrict  */)"WARNING -- The above is only a rough guideline.\n");
      }
    }
#line 142
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 143
    if (stream_verbose) {
      {
#line 143
      printf((char const   */* __restrict  */)"For best results, please be sure you know the\n");
      }
    }
#line 143
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 144
    if (stream_verbose) {
      {
#line 144
      printf((char const   */* __restrict  */)"precision of your system timer.\n");
      }
    }
#line 144
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 145
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 145
    if (stream_verbose) {
      {
#line 145
      printf((char const   */* __restrict  */)"-------------------------------------------------------------\n");
      }
    }
#line 145
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
void stream_test(double *res ) 
{ 
  register int j ;
  register int k ;
  double scalar ;
  double times[4][10] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double speed ;

  {
#line 155
  scalar = 3.0;
#line 156
  k = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (k < 10)) {
#line 156
      goto while_break;
    }
    {
#line 157
    times[0][k] = mysecond();
#line 158
    j = 0;
    }
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! ((long )j < N)) {
#line 158
        goto while_break___0;
      }
#line 159
      *(c + j) = *(a + j);
#line 158
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 160
    tmp = mysecond();
#line 160
    times[0][k] = tmp - times[0][k];
#line 162
    times[1][k] = mysecond();
#line 163
    j = 0;
    }
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 163
      if (! ((long )j < N)) {
#line 163
        goto while_break___1;
      }
#line 164
      *(b + j) = scalar * *(c + j);
#line 163
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 165
    tmp___0 = mysecond();
#line 165
    times[1][k] = tmp___0 - times[1][k];
#line 167
    times[2][k] = mysecond();
#line 168
    j = 0;
    }
    {
#line 168
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 168
      if (! ((long )j < N)) {
#line 168
        goto while_break___2;
      }
#line 169
      *(c + j) = *(a + j) + *(b + j);
#line 168
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 170
    tmp___1 = mysecond();
#line 170
    times[2][k] = tmp___1 - times[2][k];
#line 172
    times[3][k] = mysecond();
#line 173
    j = 0;
    }
    {
#line 173
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 173
      if (! ((long )j < N)) {
#line 173
        goto while_break___3;
      }
#line 174
      *(a + j) = *(b + j) + scalar * *(c + j);
#line 173
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 175
    tmp___2 = mysecond();
#line 175
    times[3][k] = tmp___2 - times[3][k];
#line 156
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 180
    if (! (k < 10)) {
#line 180
      goto while_break___4;
    }
#line 181
    j = 0;
    {
#line 181
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 181
      if (! (j < 4)) {
#line 181
        goto while_break___5;
      }
#line 182
      rmstime[j] += times[j][k] * times[j][k];
#line 184
      if (mintime[j] < times[j][k]) {
#line 184
        mintime[j] = mintime[j];
      } else {
#line 184
        mintime[j] = times[j][k];
      }
#line 185
      if (maxtime[j] > times[j][k]) {
#line 185
        maxtime[j] = maxtime[j];
      } else {
#line 185
        maxtime[j] = times[j][k];
      }
#line 181
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 180
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 189
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 189
    if (stream_verbose) {
      {
#line 189
      printf((char const   */* __restrict  */)"Function      Rate (MB/s)   RMS time     Min time     Max time\n");
      }
    }
#line 189
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 191
  j = 0;
  {
#line 191
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 191
    if (! (j < 4)) {
#line 191
      goto while_break___7;
    }
    {
#line 192
    speed = (1.0E-06 * bytes[j]) / mintime[j];
#line 194
    rmstime[j] = sqrt(rmstime[j] / (double )10);
    }
    {
#line 196
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 196
      if (stream_verbose) {
        {
#line 196
        printf((char const   */* __restrict  */)"%s%11.4f  %11.4f  %11.4f  %11.4f\n",
               label[j], speed, rmstime[j], mintime[j], maxtime[j]);
        }
      }
#line 196
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 200
    if (res) {
#line 201
      *(res + j) = speed;
    }
#line 191
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
int checktick(void) 
{ 
  int i ;
  int minDelta ;
  int Delta ;
  double t1 ;
  double t2 ;
  double timesfound[20] ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 20)) {
#line 215
      goto while_break;
    }
    {
#line 216
    t1 = mysecond();
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      t2 = mysecond();
      }
#line 217
      if (! (t2 - t1 < 1.0E-6)) {
#line 217
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    t1 = t2;
#line 218
    timesfound[i] = t1;
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  minDelta = 1000000;
#line 228
  i = 1;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (! (i < 20)) {
#line 228
      goto while_break___1;
    }
#line 229
    Delta = (int )(1.0E6 * (timesfound[i] - timesfound[i - 1]));
#line 231
    if (Delta > 0) {
#line 231
      tmp___1 = Delta;
    } else {
#line 231
      tmp___1 = 0;
    }
#line 231
    if (minDelta < tmp___1) {
#line 231
      minDelta = minDelta;
    } else {
#line 231
      if (Delta > 0) {
#line 231
        tmp___0 = Delta;
      } else {
#line 231
        tmp___0 = 0;
      }
#line 231
      minDelta = tmp___0;
    }
#line 228
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 234
  return (minDelta);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
void stream_setmem(unsigned long size___20 ) 
{ 


  {
#line 239
  N = (long )(size___20 / (3UL * sizeof(double )));
#line 240
  return;
}
}
#line 242 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
long stream_memsize(void) 
{ 


  {
#line 244
  return ((long )(3UL * (sizeof(double ) * (unsigned long )N)));
}
}
#line 247 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
long stream_init(void *mem___0 ) 
{ 
  int i ;

  {
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < 4)) {
#line 251
      goto while_break;
    }
#line 252
    rmstime[i] = (double )0;
#line 253
    maxtime[i] = (double )0;
#line 254
    mintime[i] = (double )3.40282346638528859812e+38F;
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  bytes[0] = (double )((2UL * sizeof(double )) * (unsigned long )N);
#line 258
  bytes[1] = (double )((2UL * sizeof(double )) * (unsigned long )N);
#line 259
  bytes[2] = (double )((3UL * sizeof(double )) * (unsigned long )N);
#line 260
  bytes[3] = (double )((3UL * sizeof(double )) * (unsigned long )N);
#line 262
  a = (double *)mem___0;
#line 263
  b = (double *)mem___0 + N;
#line 264
  c = (double *)mem___0 + 2L * N;
#line 265
  stream_check();
  }
#line 266
  return (0L);
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___15(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___15(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___15(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___15(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___15(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___15(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___15(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___15(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___15(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___15 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___15(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___15(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___15(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___15(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___15(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___15(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___15(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___15[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___15}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___15}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___15}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___15}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___15}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 3 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.h"
void mt_init(void) ;
#line 4
void mt_refill(void) ;
#line 6 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.h"
int mt_index  ;
#line 7 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.h"
unsigned int mt_buffer[624]  ;
#line 10 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.c"
void mt_init(void) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 13
  srand(1U);
#line 14
  i = 0;
  }
  {
#line 14
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14
    if (! (i < 624)) {
#line 14
      goto while_break;
    }
    {
#line 15
    tmp = rand();
#line 15
    mt_buffer[i] = (unsigned int )tmp;
#line 14
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  mt_index = 0;
#line 17
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.c"
void mt_refill(void) 
{ 
  int i ;
  unsigned int s ;
  unsigned int *b___1 ;

  {
#line 31
  b___1 = mt_buffer;
#line 33
  mt_index = 0;
#line 34
  i = 0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < 227)) {
#line 35
      goto while_break;
    }
#line 36
    s = (*(b___1 + i) & 2147483648U) | (*(b___1 + (i + 1)) & 2147483647U);
#line 37
    *(b___1 + i) = (*(b___1 + (i + 397)) ^ (s >> 1)) ^ (s & 1U) * 2567483615U;
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! (i < 623)) {
#line 39
      goto while_break___0;
    }
#line 40
    s = (*(b___1 + i) & 2147483648U) | (*(b___1 + (i + 1)) & 2147483647U);
#line 41
    *(b___1 + i) = (*(b___1 + (i - 227)) ^ (s >> 1)) ^ (s & 1U) * 2567483615U;
#line 39
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 44
  s = (*(b___1 + 623) & 2147483648U) | (*(b___1 + 0) & 2147483647U);
#line 45
  *(b___1 + 623) = (*(b___1 + 396) ^ (s >> 1)) ^ (s & 1U) * 2567483615U;
#line 46
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___16(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___16(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___16(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___16(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___16(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___16(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___16(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___16(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___16(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___16 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___16(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___16(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___16(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___16(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___16(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___16(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___16(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___16[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___16}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___16}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___16}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___16}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___16}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 173 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
extern void numa_set_interleave_mask(struct bitmask *nodemask ) ;
#line 193
extern void numa_set_membind(struct bitmask *nodemask ) ;
#line 207
extern void *numa_alloc_interleaved_subset(size_t size , struct bitmask *nodemask ) ;
#line 9 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/mt.h"
__inline static unsigned int mt_random(void) 
{ 
  unsigned int *b___1 ;
  int idx ;

  {
#line 11
  b___1 = mt_buffer;
#line 12
  idx = mt_index;
#line 14
  if ((unsigned long )idx == 624UL * sizeof(unsigned int )) {
    {
#line 15
    mt_refill();
#line 16
    idx = 0;
    }
  }
#line 18
  mt_index = (int )((unsigned long )mt_index + sizeof(unsigned int ));
#line 19
  return (*((unsigned int *)((unsigned char *)b___1 + idx)));
}
}
#line 1 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.h"
void clearcache(unsigned char *mem___0 , unsigned int size___20 ) ;
#line 40 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
int fract_nodes  ;
#line 42 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
unsigned long msize  ;
#line 49 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
enum test thistest  ;
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
char *delim  =    (char *)" ";
#line 61 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
int regression_testing  =    0;
#line 63 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
char *testname[8]  = 
#line 63
  {      (char *)"memset",      (char *)"memcpy",      (char *)"forward",      (char *)"backward", 
        (char *)"stream",      (char *)"random2",      (char *)"ptrchase",      (char *)((void *)0)};
#line 78 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
void output(char *title , char *result ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 80
  tmp = __ctype_b_loc();
  }
#line 80
  if ((int const   )*(*tmp + (int )*(delim + 0)) & 8192) {
    {
#line 83
    printf((char const   */* __restrict  */)"%-42s%s\n", title, result);
    }
  } else {
    {
#line 81
    printf((char const   */* __restrict  */)"%s%s%s\n", title, delim, result);
    }
  }
#line 84
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
void do_stream(char *name , unsigned char *mem___0 ) 
{ 
  int i ;
  char title[100] ;
  char buf___7[100] ;
  double res[4] ;
  size_t tmp ;

  {
  {
#line 93
  stream_verbose = 0;
#line 94
  clearcache(mem___0, (unsigned int )msize);
#line 95
  stream_init((void *)mem___0);
#line 96
  stream_test(res);
#line 97
  sprintf((char */* __restrict  */)(title), (char const   */* __restrict  */)"%s%s%s",
          name, delim, "STREAM");
#line 98
  buf___7[0] = (char )'\000';
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 4)) {
#line 99
      goto while_break;
    }
#line 100
    if (buf___7[0]) {
      {
#line 101
      strcat((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)delim);
      }
    }
    {
#line 102
    tmp = strlen((char const   *)(buf___7));
#line 102
    sprintf((char */* __restrict  */)(buf___7 + tmp), (char const   */* __restrict  */)"%s%s%.2f%sMB/s",
            stream_names[i], delim, res[i], delim);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  output(title, buf___7);
#line 106
  clearcache(mem___0, (unsigned int )msize);
  }
#line 107
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
static int cmp_node(void const   *ap , void const   *bp ) 
{ 
  union node *a___1 ;
  union node *b___1 ;

  {
#line 121
  a___1 = (union node *)ap;
#line 122
  b___1 = (union node *)bp;
#line 123
  return ((int )(a___1->__annonCompField1.val - b___1->__annonCompField1.val));
}
}
#line 126 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
void **ptrchase_init(unsigned char *mem___0 ) 
{ 
  long i ;
  union node *nodes ;
  long nmemb ;
  int tmp ;
  union node *n ;

  {
  {
#line 129
  nodes = (union node *)mem___0;
#line 130
  nmemb = (long )(msize / sizeof(union node ));
#line 131
  srand(1234U);
#line 132
  i = 0L;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < nmemb)) {
#line 132
      goto while_break;
    }
    {
#line 133
    tmp = rand();
#line 133
    (nodes + i)->__annonCompField1.val = (unsigned int )tmp;
#line 134
    (nodes + i)->__annonCompField1.nexti = (unsigned int )(i + 1L);
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  qsort((void *)nodes, (size_t )nmemb, sizeof(union node ), & cmp_node);
#line 137
  i = 0L;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! (i < nmemb)) {
#line 137
      goto while_break___0;
    }
#line 138
    n = nodes + i;
#line 139
    if ((long )n->__annonCompField1.nexti >= nmemb) {
#line 139
      n->next = (union node *)((void *)0);
    } else {
#line 139
      n->next = nodes + n->__annonCompField1.nexti;
    }
#line 137
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  return ((void **)nodes);
}
}
#line 144 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
__inline static unsigned long long timerfold(struct timeval *tv ) 
{ 


  {
#line 146
  return ((unsigned long long )tv->tv_sec * 1000000ULL + (unsigned long long )tv->tv_usec);
}
}
#line 151 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
void memtest(char *name , unsigned char *mem___0 ) 
{ 
  long k ;
  struct timeval start___0 ;
  struct timeval end___0 ;
  struct timeval res ;
  unsigned long long max ;
  unsigned long long min ;
  unsigned long long sum ;
  unsigned long long r ;
  int i ;
  char title[128] ;
  char result[128] ;
  void **ptr ;
  unsigned int * __restrict  m ;
  unsigned int max___0 ;
  unsigned int mask ;
  unsigned int idx ;
  unsigned int tmp ;

  {
#line 159
  if (! mem___0) {
    {
#line 160
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to allocate %lu bytes of memory. Test \"%s\" exits.\n",
            msize, name);
    }
#line 163
    return;
  }
#line 167
  if ((unsigned int )thistest == 4U) {
    {
#line 168
    do_stream(name, mem___0);
    }
#line 169
    goto out;
  }
#line 173
  max = 0ULL;
#line 174
  min = (unsigned long long )(~ 0UL);
#line 175
  sum = 0ULL;
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < 11)) {
#line 180
      goto while_break;
    }
    {
#line 181
    clearcache(mem___0, (unsigned int )msize);
    }
    {
#line 183
    if ((unsigned int )thistest == 6U) {
#line 183
      goto case_6;
    }
#line 196
    if ((unsigned int )thistest == 0U) {
#line 196
      goto case_0;
    }
#line 202
    if ((unsigned int )thistest == 1U) {
#line 202
      goto case_1;
    }
#line 208
    if ((unsigned int )thistest == 2U) {
#line 208
      goto case_2;
    }
#line 217
    if ((unsigned int )thistest == 3U) {
#line 217
      goto case_3;
    }
#line 225
    if ((unsigned int )thistest == 5U) {
#line 225
      goto case_5;
    }
#line 251
    goto switch_default;
    case_6: /* CIL Label */ 
    {
#line 186
    ptr = ptrchase_init(mem___0);
#line 187
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
    }
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! *ptr) {
#line 188
        goto while_break___0;
      }
#line 189
      ptr = (void **)*ptr;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 190
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
#line 192
    *ptr = (void *)"bla";
    }
#line 193
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 197
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
#line 198
    memset((void *)mem___0, 255, msize);
#line 199
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
    }
#line 200
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 203
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
#line 204
    memcpy((void */* __restrict  */)mem___0, (void const   */* __restrict  */)(mem___0 + msize / 2UL),
           msize / 2UL);
#line 205
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
    }
#line 206
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 211
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
#line 212
    k = 0L;
    }
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 212
      if (! ((unsigned long )k < msize)) {
#line 212
        goto while_break___1;
      }
#line 213
      *(mem___0 + k) = (unsigned char )((int )*(mem___0 + k) + 1);
#line 212
      k += 64L;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 214
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
    }
#line 215
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 218
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
#line 219
    k = (long )(msize - 5UL);
    }
    {
#line 219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 219
      if (! (k > 0L)) {
#line 219
        goto while_break___2;
      }
#line 220
      *(mem___0 + k) = (unsigned char )((int )*(mem___0 + k) - 1);
#line 219
      k -= 64L;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 221
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
    }
#line 222
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 227
    m = (unsigned int */* __restrict  */)((unsigned int *)mem___0);
#line 228
    max___0 = (unsigned int )(msize / sizeof(unsigned int ));
#line 231
    mt_init();
#line 232
    mask = 1U;
    }
    {
#line 233
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 233
      if (! (mask < max___0)) {
#line 233
        goto while_break___3;
      }
#line 234
      mask = (mask << 1) | 1U;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 240
    gettimeofday((struct timeval */* __restrict  */)(& start___0), (__timezone_ptr_t )((void *)0));
#line 241
    k = 0L;
    }
    {
#line 241
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 241
      if (! (k < (long )max___0)) {
#line 241
        goto while_break___4;
      }
      {
#line 242
      tmp = mt_random();
#line 242
      idx = tmp & mask;
      }
#line 243
      if (idx >= max___0) {
#line 244
        idx -= max___0;
      }
#line 245
      (*(m + idx)) ++;
#line 241
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 247
    gettimeofday((struct timeval */* __restrict  */)(& end___0), (__timezone_ptr_t )((void *)0));
    }
    switch_default: /* CIL Label */ 
#line 252
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 255
    if (! i) {
#line 256
      goto __Cont;
    }
    {
#line 258
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 258
      res.tv_sec = end___0.tv_sec - start___0.tv_sec;
#line 258
      res.tv_usec = end___0.tv_usec - start___0.tv_usec;
#line 258
      if (res.tv_usec < 0L) {
#line 258
        (res.tv_sec) --;
#line 258
        res.tv_usec += 1000000L;
      }
#line 258
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 259
    r = timerfold(& res);
    }
#line 260
    if (r > max) {
#line 260
      max = r;
    }
#line 261
    if (r < min) {
#line 261
      min = r;
    }
#line 262
    sum += r;
    __Cont: /* CIL Label */ 
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  sprintf((char */* __restrict  */)(title), (char const   */* __restrict  */)"%s%s%s",
          name, delim, testname[thistest]);
#line 267
  sprintf((char */* __restrict  */)(result), (char const   */* __restrict  */)"Avg%s%.2f%sMB/s%sMax%s%.2f%sMB/s%sMin%s%.2f%sMB/s",
          delim, (double )msize / ((double )sum / (double )10), delim, delim, delim,
          (double )msize / (double )min, delim, delim, delim, (double )msize / (double )max,
          delim);
#line 277
  output(title, result);
  }
  out: 
  {
#line 284
  clearcache(mem___0, (unsigned int )msize);
#line 286
  numa_free((void *)mem___0, msize);
  }
#line 287
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
int popcnt(unsigned long val ) 
{ 
  int i ;
  int cnt ;

  {
#line 291
  i = 0;
#line 291
  cnt = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (val >> i)) {
#line 292
      goto while_break;
    }
#line 293
    if ((1UL << i) & val) {
#line 294
      cnt ++;
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (cnt);
}
}
#line 300 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
int max_node  ;
#line 302 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numademo.c"
void test(enum test type ) 
{ 
  unsigned long mask ;
  int i ;
  int k ;
  char buf___7[512] ;
  struct bitmask *nodes ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int w ;
  char buf2[10] ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int oldhn ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;

  {
  {
#line 309
  nodes = numa_allocate_nodemask();
#line 310
  thistest = type;
  }
#line 312
  if (regression_testing) {
    {
#line 313
    printf((char const   */* __restrict  */)"\nTest %s doing 1 of %d nodes and 1 of %d masks.\n",
           testname[thistest], fract_nodes, 32);
    }
  }
  {
#line 317
  tmp = numa_alloc(msize);
#line 317
  memtest((char *)"memory with no policy", (unsigned char *)tmp);
#line 318
  tmp___0 = numa_alloc_local(msize);
#line 318
  memtest((char *)"local memory", (unsigned char *)tmp___0);
#line 320
  tmp___1 = numa_alloc_interleaved(msize);
#line 320
  memtest((char *)"memory interleaved on all nodes", (unsigned char *)tmp___1);
#line 321
  i = 0;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i <= max_node)) {
#line 321
      goto while_break;
    }
#line 322
    if (regression_testing) {
#line 322
      if (i % fract_nodes) {
#line 324
        goto __Cont;
      }
    }
    {
#line 326
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"memory on node %d",
            i);
#line 327
    tmp___2 = numa_alloc_onnode(msize, i);
#line 327
    memtest(buf___7, (unsigned char *)tmp___2);
    }
    __Cont: /* CIL Label */ 
#line 321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  mask = 1UL;
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (! (mask < 1UL << (max_node + 1))) {
#line 330
      goto while_break___0;
    }
    {
#line 333
    tmp___3 = popcnt(mask);
    }
#line 333
    if (tmp___3 == 1) {
#line 334
      goto __Cont___0;
    }
#line 335
    if (regression_testing) {
#line 335
      if (i > 50) {
#line 336
        goto while_break___0;
      }
    }
#line 338
    if (regression_testing) {
#line 338
      if (i % 32) {
#line 341
        goto __Cont___0;
      }
    }
    {
#line 343
    numa_bitmask_clearall(nodes);
#line 344
    w = 0;
    }
    {
#line 344
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 344
      if (! (mask >> w)) {
#line 344
        goto while_break___1;
      }
#line 345
      if ((mask >> w) & 1UL) {
        {
#line 346
        numa_bitmask_setbit(nodes, (unsigned int )w);
        }
      }
#line 344
      w ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 349
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"memory interleaved on");
#line 350
    k = 0;
    }
    {
#line 350
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 350
      if (! (k <= max_node)) {
#line 350
        goto while_break___2;
      }
#line 351
      if ((1UL << k) & mask) {
        {
#line 352
        sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)" %d",
                k);
#line 353
        strcat((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)(buf2));
        }
      }
#line 350
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 355
    tmp___4 = numa_alloc_interleaved_subset(msize, nodes);
#line 355
    memtest(buf___7, (unsigned char *)tmp___4);
    }
    __Cont___0: /* CIL Label */ 
#line 330
    mask ++;
#line 330
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  i = 0;
  {
#line 358
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 358
    if (! (i <= max_node)) {
#line 358
      goto while_break___3;
    }
#line 359
    if (regression_testing) {
#line 359
      if (i % fract_nodes) {
#line 361
        goto __Cont___1;
      }
    }
    {
#line 363
    printf((char const   */* __restrict  */)"setting preferred node to %d\n", i);
#line 364
    numa_set_preferred(i);
#line 365
    tmp___5 = numa_alloc(msize);
#line 365
    memtest((char *)"memory without policy", (unsigned char *)tmp___5);
    }
    __Cont___1: /* CIL Label */ 
#line 358
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 368
  numa_set_interleave_mask(numa_all_nodes_ptr);
#line 369
  tmp___6 = numa_alloc(msize);
#line 369
  memtest((char *)"manual interleaving to all nodes", (unsigned char *)tmp___6);
  }
#line 371
  if (max_node > 0) {
    {
#line 372
    numa_bitmask_clearall(nodes);
#line 373
    numa_bitmask_setbit(nodes, 0U);
#line 374
    numa_bitmask_setbit(nodes, 1U);
#line 375
    numa_set_interleave_mask(nodes);
#line 376
    tmp___7 = numa_alloc(msize);
#line 376
    memtest((char *)"manual interleaving on node 0/1", (unsigned char *)tmp___7);
#line 377
    tmp___8 = numa_get_interleave_node();
#line 377
    printf((char const   */* __restrict  */)"current interleave node %d\n", tmp___8);
    }
  }
  {
#line 380
  numa_set_interleave_mask(numa_no_nodes_ptr);
#line 382
  nodes = numa_allocate_nodemask();
#line 384
  i = 0;
  }
  {
#line 384
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 384
    if (! (i <= max_node)) {
#line 384
      goto while_break___4;
    }
    {
#line 385
    tmp___9 = numa_preferred();
#line 385
    oldhn = tmp___9;
    }
#line 387
    if (regression_testing) {
#line 387
      if (i % fract_nodes) {
#line 389
        goto __Cont___2;
      }
    }
    {
#line 391
    numa_run_on_node(i);
#line 392
    printf((char const   */* __restrict  */)"running on node %d, preferred node %d\n",
           i, oldhn);
#line 394
    tmp___10 = numa_alloc_local(msize);
#line 394
    memtest((char *)"local memory", (unsigned char *)tmp___10);
#line 396
    tmp___11 = numa_alloc_interleaved(msize);
#line 396
    memtest((char *)"memory interleaved on all nodes", (unsigned char *)tmp___11);
    }
#line 399
    if (max_node >= 1) {
      {
#line 400
      numa_bitmask_clearall(nodes);
#line 401
      numa_bitmask_setbit(nodes, 0U);
#line 402
      numa_bitmask_setbit(nodes, 1U);
#line 403
      tmp___12 = numa_alloc_interleaved_subset(msize, nodes);
#line 403
      memtest((char *)"memory interleaved on node 0/1", (unsigned char *)tmp___12);
      }
    }
#line 407
    k = 0;
    {
#line 407
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 407
      if (! (k <= max_node)) {
#line 407
        goto while_break___5;
      }
#line 408
      if (k == i) {
#line 409
        goto __Cont___3;
      }
#line 410
      if (regression_testing) {
#line 410
        if (k % fract_nodes) {
#line 413
          goto __Cont___3;
        }
      }
      {
#line 415
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"alloc on node %d",
              k);
#line 416
      numa_bitmask_clearall(nodes);
#line 417
      numa_bitmask_setbit(nodes, (unsigned int )k);
#line 418
      numa_set_membind(nodes);
#line 419
      tmp___13 = numa_alloc(msize);
#line 419
      memtest(buf___7, (unsigned char *)tmp___13);
#line 420
      numa_set_membind(numa_all_nodes_ptr);
      }
      __Cont___3: /* CIL Label */ 
#line 407
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 423
    numa_set_localalloc();
#line 424
    tmp___14 = numa_alloc(msize);
#line 424
    memtest((char *)"local allocation", (unsigned char *)tmp___14);
#line 426
    numa_set_preferred((i + 1) % (1 + max_node));
#line 427
    tmp___15 = numa_alloc(msize);
#line 427
    memtest((char *)"setting wrong preferred node", (unsigned char *)tmp___15);
#line 428
    numa_set_preferred(i);
#line 429
    tmp___16 = numa_alloc(msize);
#line 429
    memtest((char *)"setting correct preferred node", (unsigned char *)tmp___16);
#line 430
    numa_set_preferred(-1);
    }
#line 431
    if (! *(delim + 0)) {
      {
#line 432
      printf((char const   */* __restrict  */)"\n\n\n");
      }
    }
    __Cont___2: /* CIL Label */ 
#line 384
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___16  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___16  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___16(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___16(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___16(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___16) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___16 = maxnode;
#line 106
  distance_table___16 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___16  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___16[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___16  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___16  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___16  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___16  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___16  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___16  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___16  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___16  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___16  =    0;
#line 80
static void set_sizes___16(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___16(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___16(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___16  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___16(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___16(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___16(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___16);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___17  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___16(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___16 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___16 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___16, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___16 < nd) {
#line 344
        maxconfigurednode___16 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___16(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___16(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___16  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___16  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___16(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___16, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___16((char const   *)buf___7, nodemask_prefix___16);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___16);
#line 385
      nodemask_sz___16 = s2nbits___16((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___16 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___16 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___16 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___16 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___16 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___16 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___16(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___16(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___16;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___16, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___16 = read_mask___16(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___16 = read_mask___16(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___16)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___16 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___16 = hicpu + 1;
  }
#line 520
  if (numproccpu___16 > hicpu + 1) {
#line 521
    numproccpu___16 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___16 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___16)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___16 = maxconfigurednode___16 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___16(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___16 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___16(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___16 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___16 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___16(void) 
{ 


  {
  {
#line 582
  sizes_set___16 ++;
#line 583
  set_nodemask_size___16();
#line 584
  set_configured_nodes___16();
#line 585
  set_numa_max_cpu___16();
#line 586
  set_configured_cpus___16();
#line 587
  set_task_constraints___16();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___16(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___16  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___16(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___16(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___16(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___16(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___16(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___16(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___16(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *a___0  ;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *b___0  ;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double *c___0  ;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double rmstime___0[4]  = {      (double )0};
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double maxtime___0[4]  = {      (double )0};
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double mintime___0[4]  = {      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F,      (double )3.40282346638528859812e+38F};
#line 80 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static char *label___0[4]  = {      (char *)"Copy:      ",      (char *)"Scale:     ",      (char *)"Add:       ",      (char *)"Triad:     "};
#line 85 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/stream_lib.c"
static double bytes___0[4]  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.c"
static int warned___17  ;
#line 11 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.c"
unsigned int cache_size(void) 
{ 
  unsigned int cs ;
  long tmp ;

  {
  {
#line 13
  cs = 0U;
#line 15
  tmp = sysconf(188);
#line 15
  cs = (unsigned int )((long )cs + tmp);
  }
#line 26
  if (cs == 0U) {
#line 28
    if (! warned___17) {
      {
#line 29
      printf((char const   */* __restrict  */)"Cannot determine CPU cache size\n");
#line 30
      warned___17 = 1;
      }
    }
#line 32
    cs = 67108864U;
  }
#line 34
  cs *= 2U;
#line 36
  return (cs);
}
}
#line 41 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.c"
static unsigned char *clearmem  ;
#line 39 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.c"
void fallback_clearcache(void) 
{ 
  unsigned int cs ;
  unsigned int tmp ;
  unsigned int i ;
  void *tmp___0 ;

  {
  {
#line 42
  tmp = cache_size();
#line 42
  cs = tmp;
  }
#line 45
  if (! clearmem) {
    {
#line 46
    tmp___0 = malloc((size_t )cs);
#line 46
    clearmem = (unsigned char *)tmp___0;
    }
  }
#line 47
  if (! clearmem) {
    {
#line 48
    printf((char const   */* __restrict  */)"Warning: cannot allocate %u bytes of clear cache buffer\n",
           cs);
    }
#line 49
    return;
  }
#line 51
  i = 0U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < cs)) {
#line 51
      goto while_break;
    }
#line 52
    *(clearmem + i) = (unsigned char)1;
#line 51
    i += 32U;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/clearcache.c"
void clearcache(unsigned char *mem___0 , unsigned int size___20 ) 
{ 
  unsigned int i ;
  unsigned int cl ;
  unsigned int eax ;
  unsigned int feat ;

  {
#line 60
  __asm__  ("cpuid": "=a" (eax), "=b" (cl), "=d" (feat): "0" (1): "cx");
#line 61
  if (! (feat & (unsigned int )(1 << 19))) {
    {
#line 62
    fallback_clearcache();
    }
  }
#line 63
  cl = ((cl >> 8) & 255U) * 8U;
#line 64
  i = 0U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < size___20)) {
#line 64
      goto while_break;
    }
#line 65
    __asm__  ("clflush %0": : "m" (*(mem___0 + i)));
#line 64
    i += cl;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___17(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___17(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___17(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___17(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___17(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___17(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___17(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___17(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___17(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___17 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___17(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___17(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___17(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___17(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___17(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___17(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___17(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___17[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___17}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___17}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___17}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___17}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___17}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 11 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/bitops.h"
int find_first_bit(void *m , int max ) ;
#line 4 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/bitops.c"
int find_first_bit(void *m , int max ) 
{ 
  unsigned long *mask ;
  int i ;

  {
#line 6
  mask = (unsigned long *)m;
#line 8
  i = 0;
  {
#line 8
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8
    if (! (i < max)) {
#line 8
      goto while_break;
    }
#line 9
    if (*(mask + (unsigned long )i / (sizeof(unsigned long ) * 8UL)) & (1UL << (unsigned long )i % (sizeof(unsigned long ) * 8UL))) {
#line 10
      goto while_break;
    }
#line 8
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12
  return (i);
}
}
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies___2[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names___2[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf___4[32]  ;
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___17  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___17  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___17(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___17(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___17(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___17) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___17 = maxnode;
#line 106
  distance_table___17 = table;
#line 107
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___17  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___17[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___17  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___17  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___17  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___17  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___17  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___17  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___17  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___17  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___17  =    0;
#line 80
static void set_sizes___17(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___17(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___17(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___18  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___17(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___17(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___17(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___17);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___18  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___17(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___17 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___17 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___17, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___17 < nd) {
#line 344
        maxconfigurednode___17 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___17(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___17(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___17  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___17  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___17(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___17, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___17((char const   *)buf___7, nodemask_prefix___17);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___17);
#line 385
      nodemask_sz___17 = s2nbits___17((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___17 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___17 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___17 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___17 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___17 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___17 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___17(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___17(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___17;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___17, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___17 = read_mask___17(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___17 = read_mask___17(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___17)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___17 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___17 = hicpu + 1;
  }
#line 520
  if (numproccpu___17 > hicpu + 1) {
#line 521
    numproccpu___17 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___17 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___17)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___17 = maxconfigurednode___17 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___17(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___17 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___17(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___17 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___17 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___17(void) 
{ 


  {
  {
#line 582
  sizes_set___17 ++;
#line 583
  set_nodemask_size___17();
#line 584
  set_configured_nodes___17();
#line 585
  set_numa_max_cpu___17();
#line 586
  set_configured_cpus___17();
#line 587
  set_task_constraints___17();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___17(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___17  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___17(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___17(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___17(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___17(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___17(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___17(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___17(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___18  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___18  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___18(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___18(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___18(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___18) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___18 = maxnode;
#line 106
  distance_table___18 = table;
#line 107
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies___3[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names___3[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf___5[32]  ;
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___18  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___18[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___18  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___18  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___18  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___18  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___18  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___18  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___18  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___18  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___18  =    0;
#line 80
static void set_sizes___18(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___18(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___18(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___19  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___18(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___18(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___18(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___18);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___19  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___18(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___18 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___18 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___18, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___18 < nd) {
#line 344
        maxconfigurednode___18 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___18(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___18(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___18  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___18  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___18(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___18, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___18((char const   *)buf___7, nodemask_prefix___18);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___18);
#line 385
      nodemask_sz___18 = s2nbits___18((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___18 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___18 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___18 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___18 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___18 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___18 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___18(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___18(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___18;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___18, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___18 = read_mask___18(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___18 = read_mask___18(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___18)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___18 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___18 = hicpu + 1;
  }
#line 520
  if (numproccpu___18 > hicpu + 1) {
#line 521
    numproccpu___18 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___18 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___18)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___18 = maxconfigurednode___18 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___18(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___18 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___18(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___18 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___18 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___18(void) 
{ 


  {
  {
#line 582
  sizes_set___18 ++;
#line 583
  set_nodemask_size___18();
#line 584
  set_configured_nodes___18();
#line 585
  set_numa_max_cpu___18();
#line 586
  set_configured_cpus___18();
#line 587
  set_task_constraints___18();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___18(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___18  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___18(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___18(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___18(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___18(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___18(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___18(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___18(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 176 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numa.h"
extern struct bitmask *numa_get_interleave_mask(void) ;
#line 196
extern struct bitmask *numa_get_membind(void) ;
#line 225
extern void numa_interleave_memory(void *mem , size_t size , struct bitmask *mask ) ;
#line 231
extern void numa_tonodemask_memory(void *mem , size_t size , struct bitmask *mask ) ;
#line 246
extern struct bitmask *numa_get_run_node_mask(void) ;
#line 283
extern int numa_node_to_cpus(int  , struct bitmask * ) ;
#line 312
extern int numa_sched_getaffinity(pid_t  , struct bitmask * ) ;
#line 313
extern int numa_sched_setaffinity(pid_t  , struct bitmask * ) ;
#line 2 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
int shmfd ;
#line 3
long shmid ;
#line 4
char *shmptr ;
#line 5
unsigned long long shmlen ;
#line 6
mode_t shmmode ;
#line 7
unsigned long long shmoffset ;
#line 8
int shmflags ;
#line 10
void dump_shm(void) ;
#line 11
void dump_shm_nodes(void) ;
#line 12
void attach_shared(char *name , char *opt ) ;
#line 13
void attach_sysvshm(char *name , char *opt ) ;
#line 14
void verify_shm(int policy___0 , struct bitmask *nodes ) ;
#line 17 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
int exitcode  ;
#line 37 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
struct option opts[23]  = 
#line 37 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
  {      {"all", 0, (int *)0, 'a'}, 
        {"interleave", 1, (int *)0, 'i'}, 
        {"preferred", 1, (int *)0, 'p'}, 
        {"cpubind", 1, (int *)0, 'c'}, 
        {"cpunodebind", 1, (int *)0, 'N'}, 
        {"physcpubind", 1, (int *)0, 'C'}, 
        {"membind", 1, (int *)0, 'm'}, 
        {"show", 0, (int *)0, 's'}, 
        {"localalloc", 0, (int *)0, 'l'}, 
        {"hardware", 0, (int *)0, 'H'}, 
        {"shm", 1, (int *)0, 'S'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"offset", 1, (int *)0, 'o'}, 
        {"length", 1, (int *)0, 'L'}, 
        {"strict", 0, (int *)0, 't'}, 
        {"shmmode", 1, (int *)0, 'M'}, 
        {"dump", 0, (int *)0, 'd'}, 
        {"dump-nodes", 0, (int *)0, 'D'}, 
        {"shmid", 1, (int *)0, 'I'}, 
        {"huge", 0, (int *)0, 'u'}, 
        {"touch", 0, (int *)0, 'T'}, 
        {"verify", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 96 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void usage_msg(char *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 99
  __builtin_va_start(ap, msg);
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: ");
#line 101
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           ap);
#line 102
  putchar('\n');
#line 103
  usage();
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void show_physcpubind(void) 
{ 
  int ncpus ;
  int tmp ;
  struct bitmask *cpubuf ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 108
  tmp = numa_num_configured_cpus();
#line 108
  ncpus = tmp;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    cpubuf = numa_bitmask_alloc((unsigned int )ncpus);
#line 115
    tmp___1 = numa_sched_getaffinity(0, cpubuf);
    }
#line 115
    if (tmp___1 < 0) {
      {
#line 116
      tmp___0 = __errno_location();
      }
#line 116
      if (*tmp___0 == 22) {
#line 116
        if (ncpus < 1048576) {
#line 117
          ncpus *= 2;
#line 118
          goto __Cont;
        }
      }
      {
#line 120
      perror("numactl: sched_get_affinity");
#line 120
      exit(1);
      }
    }
    {
#line 122
    printcpumask((char *)"physcpubind", cpubuf);
    }
#line 123
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void show(void) 
{ 
  unsigned long prefnode ;
  struct bitmask *membind ;
  struct bitmask *interleave ;
  struct bitmask *cpubind ;
  unsigned long cur ;
  int policy___0 ;
  int numa_num_nodes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 133
  tmp = numa_num_possible_nodes();
#line 133
  numa_num_nodes = tmp;
#line 135
  tmp___0 = numa_available();
  }
#line 135
  if (tmp___0 < 0) {
    {
#line 136
    show_physcpubind();
#line 137
    printf((char const   */* __restrict  */)"No NUMA support available on this system.\n");
#line 138
    exit(1);
    }
  }
  {
#line 141
  cpubind = numa_get_run_node_mask();
#line 143
  tmp___1 = numa_preferred();
#line 143
  prefnode = (unsigned long )tmp___1;
#line 144
  interleave = numa_get_interleave_mask();
#line 145
  membind = numa_get_membind();
#line 146
  tmp___2 = numa_get_interleave_node();
#line 146
  cur = (unsigned long )tmp___2;
#line 148
  policy___0 = 0;
#line 149
  tmp___3 = get_mempolicy(& policy___0, (unsigned long const   *)((void *)0), 0UL,
                          (void *)0, 0);
  }
#line 149
  if (tmp___3 < 0L) {
    {
#line 150
    perror("get_mempolicy");
    }
  }
  {
#line 152
  tmp___4 = policy_name(policy___0);
#line 152
  printf((char const   */* __restrict  */)"policy: %s\n", tmp___4);
#line 154
  printf((char const   */* __restrict  */)"preferred node: ");
  }
  {
#line 156
  if (policy___0 == 1) {
#line 156
    goto case_1;
  }
#line 162
  if (policy___0 == 0) {
#line 162
    goto case_0;
  }
#line 165
  if (policy___0 == 3) {
#line 165
    goto case_3;
  }
#line 168
  if (policy___0 == 2) {
#line 168
    goto case_2;
  }
#line 155
  goto switch_break;
  case_1: /* CIL Label */ 
#line 157
  if (prefnode != 0xffffffffffffffffUL) {
    {
#line 158
    printf((char const   */* __restrict  */)"%ld\n", prefnode);
    }
#line 159
    goto switch_break;
  }
  case_0: /* CIL Label */ 
  {
#line 163
  printf((char const   */* __restrict  */)"current\n");
  }
#line 164
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"%ld (interleave next)\n", cur);
  }
#line 167
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 169
  tmp___5 = find_first_bit((void *)(& membind), numa_num_nodes);
#line 169
  printf((char const   */* __restrict  */)"%d\n", tmp___5);
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 172
  if (policy___0 == 3) {
    {
#line 173
    printmask((char *)"interleavemask", interleave);
#line 174
    printf((char const   */* __restrict  */)"interleavenode: %ld\n", cur);
    }
  }
  {
#line 176
  show_physcpubind();
#line 177
  printmask((char *)"cpubind", cpubind);
#line 178
  printmask((char *)"nodebind", cpubind);
#line 179
  printmask((char *)"membind", membind);
  }
#line 180
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
char *fmt_mem(unsigned long long mem___0 , char *buf___7 ) 
{ 


  {
#line 184
  if (mem___0 == 0xffffffffffffffffULL) {
    {
#line 185
    sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"<not available>");
    }
  } else {
    {
#line 187
    sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%Lu MB",
            mem___0 >> 20);
    }
  }
#line 188
  return (buf___7);
}
}
#line 191 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
static void print_distances(int maxnode ) 
{ 
  int i ;
  int k ;
  int fst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 194
  fst = 0;
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i <= maxnode)) {
#line 196
      goto while_break;
    }
    {
#line 197
    tmp = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 197
    if (tmp) {
#line 198
      fst = i;
#line 199
      goto while_break;
    }
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___0 = numa_distance(maxnode, fst);
  }
#line 201
  if (tmp___0 == 0) {
    {
#line 202
    printf((char const   */* __restrict  */)"No distance information available.\n");
    }
#line 203
    return;
  }
  {
#line 205
  printf((char const   */* __restrict  */)"node distances:\n");
#line 206
  printf((char const   */* __restrict  */)"node ");
#line 207
  i = 0;
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! (i <= maxnode)) {
#line 207
      goto while_break___0;
    }
    {
#line 208
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 208
    if (tmp___1) {
      {
#line 209
      printf((char const   */* __restrict  */)"% 3d ", i);
      }
    }
#line 207
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  printf((char const   */* __restrict  */)"\n");
#line 211
  i = 0;
  }
  {
#line 211
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 211
    if (! (i <= maxnode)) {
#line 211
      goto while_break___1;
    }
    {
#line 212
    tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 212
    if (! tmp___2) {
#line 213
      goto __Cont;
    }
    {
#line 214
    printf((char const   */* __restrict  */)"% 3d: ", i);
#line 215
    k = 0;
    }
    {
#line 215
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 215
      if (! (k <= maxnode)) {
#line 215
        goto while_break___2;
      }
      {
#line 216
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
      }
#line 216
      if (tmp___4) {
        {
#line 216
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )k);
        }
#line 216
        if (tmp___5) {
          {
#line 218
          tmp___3 = numa_distance(i, k);
#line 218
          printf((char const   */* __restrict  */)"% 3d ", tmp___3);
          }
        }
      }
#line 215
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 219
    printf((char const   */* __restrict  */)"\n");
    }
    __Cont: /* CIL Label */ 
#line 211
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void print_node_cpus(int node ) 
{ 
  int i ;
  int err ;
  struct bitmask *cpus ;
  int tmp ;

  {
  {
#line 228
  cpus = numa_allocate_cpumask();
#line 229
  err = numa_node_to_cpus(node, cpus);
  }
#line 230
  if (err >= 0) {
#line 231
    i = 0;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! ((unsigned long )i < cpus->size)) {
#line 231
        goto while_break;
      }
      {
#line 232
      tmp = numa_bitmask_isbitset((struct bitmask  const  *)cpus, (unsigned int )i);
      }
#line 232
      if (tmp) {
        {
#line 233
        printf((char const   */* __restrict  */)" %d", i);
        }
      }
#line 231
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 235
  putchar('\n');
  }
#line 236
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void hardware(void) 
{ 
  int i ;
  int numnodes ;
  int prevnode ;
  int skip ;
  int maxnode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char buf___7[64] ;
  long long fr ;
  unsigned long long sz ;
  long long tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 241
  numnodes = 0;
#line 242
  prevnode = -1;
#line 243
  skip = 0;
#line 244
  tmp = numa_max_node();
#line 244
  maxnode = tmp;
#line 246
  i = 0;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i <= maxnode)) {
#line 246
      goto while_break;
    }
    {
#line 247
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 247
    if (tmp___0) {
#line 248
      numnodes ++;
    }
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  printf((char const   */* __restrict  */)"available: %d nodes (", numnodes);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! (i <= maxnode)) {
#line 250
      goto while_break___0;
    }
    {
#line 251
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 251
    if (tmp___1) {
#line 252
      if (prevnode == -1) {
        {
#line 253
        printf((char const   */* __restrict  */)"%d", i);
#line 254
        prevnode = i;
        }
#line 255
        goto __Cont;
      }
#line 258
      if (i > prevnode + 1) {
#line 259
        if (skip) {
          {
#line 260
          printf((char const   */* __restrict  */)"%d", prevnode);
#line 261
          skip = 0;
          }
        }
        {
#line 263
        printf((char const   */* __restrict  */)",%d", i);
#line 264
        prevnode = i;
        }
#line 265
        goto __Cont;
      }
#line 268
      if (i == prevnode + 1) {
#line 269
        if (! skip) {
          {
#line 270
          printf((char const   */* __restrict  */)"-");
#line 271
          skip = 1;
          }
        }
#line 273
        prevnode = i;
      }
#line 276
      if (i == maxnode) {
#line 276
        if (skip) {
          {
#line 277
          printf((char const   */* __restrict  */)"%d", prevnode);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  printf((char const   */* __restrict  */)")\n");
#line 282
  i = 0;
  }
  {
#line 282
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 282
    if (! (i <= maxnode)) {
#line 282
      goto while_break___1;
    }
    {
#line 285
    tmp___2 = numa_node_size64(i, & fr);
#line 285
    sz = (unsigned long long )tmp___2;
#line 286
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 286
    if (! tmp___3) {
#line 287
      goto __Cont___0;
    }
    {
#line 289
    printf((char const   */* __restrict  */)"node %d cpus:", i);
#line 290
    print_node_cpus(i);
#line 291
    tmp___4 = fmt_mem(sz, buf___7);
#line 291
    printf((char const   */* __restrict  */)"node %d size: %s\n", i, tmp___4);
#line 292
    tmp___5 = fmt_mem((unsigned long long )fr, buf___7);
#line 292
    printf((char const   */* __restrict  */)"node %d free: %s\n", i, tmp___5);
    }
    __Cont___0: /* CIL Label */ 
#line 282
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 294
  print_distances(maxnode);
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void checkerror(char *s ) 
{ 
  int *tmp ;

  {
  {
#line 299
  tmp = __errno_location();
  }
#line 299
  if (*tmp) {
    {
#line 300
    perror((char const   *)s);
#line 301
    exit(1);
    }
  }
#line 303
  return;
}
}
#line 307
void checknuma(void) ;
#line 307 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
static int numa  =    -1;
#line 305 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void checknuma(void) 
{ 
  int tmp ;

  {
#line 308
  if (numa < 0) {
    {
#line 309
    tmp = numa_available();
    }
#line 309
    if (tmp < 0) {
      {
#line 310
      complain((char *)"This system does not support NUMA policy");
      }
    }
  }
#line 312
  numa = 0;
#line 313
  return;
}
}
#line 315 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int set_policy  =    -1;
#line 317 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void setpolicy(int pol ) 
{ 


  {
#line 319
  if (set_policy != -1) {
    {
#line 320
    usage_msg((char *)"Conflicting policies");
    }
  }
#line 321
  set_policy = pol;
#line 322
  return;
}
}
#line 324 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void nopolicy(void) 
{ 


  {
#line 326
  if (set_policy >= 0) {
    {
#line 327
    usage_msg((char *)"specify policy after --shm/--file");
    }
  }
#line 328
  return;
}
}
#line 330 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int did_cpubind  =    0;
#line 331 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int did_strict  =    0;
#line 332 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int do_shm  =    0;
#line 333 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int do_dump  =    0;
#line 334 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int shmattached  =    0;
#line 335 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int did_node_cpu_parse  =    0;
#line 336 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
int parse_all  =    0;
#line 337 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
char *shmoption  ;
#line 339 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void check_cpubind(int flag ) 
{ 


  {
#line 341
  if (flag) {
    {
#line 342
    usage_msg((char *)"cannot do --cpubind on shared memory\n");
    }
  }
#line 343
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void noshm(char *opt ) 
{ 


  {
#line 347
  if (shmattached) {
    {
#line 348
    usage_msg((char *)"%s must be before shared memory specification", opt);
    }
  }
#line 349
  shmoption = opt;
#line 350
  return;
}
}
#line 352 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void dontshm(char *opt ) 
{ 


  {
#line 354
  if (shmoption) {
    {
#line 355
    usage_msg((char *)"%s shm option is not allowed before %s", shmoption, opt);
    }
  }
#line 356
  return;
}
}
#line 358 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void needshm(char *opt ) 
{ 


  {
#line 360
  if (! shmattached) {
    {
#line 361
    usage_msg((char *)"%s must be after shared memory specification", opt);
    }
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void check_all_parse(int flag ) 
{ 


  {
#line 366
  if (did_node_cpu_parse) {
    {
#line 367
    usage_msg((char *)"--all/-a option must be before all cpu/node specifications");
    }
  }
#line 368
  return;
}
}
#line 370 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void get_short_opts(struct option *o , char *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 372
  tmp = s;
#line 372
  s ++;
#line 372
  *tmp = (char )'+';
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! o->name) {
#line 373
      goto while_break;
    }
    {
#line 374
    tmp___2 = __ctype_b_loc();
    }
#line 374
    if ((int const   )*(*tmp___2 + o->val) & 16384) {
#line 375
      tmp___0 = s;
#line 375
      s ++;
#line 375
      *tmp___0 = (char )o->val;
#line 376
      if (o->has_arg) {
#line 377
        tmp___1 = s;
#line 377
        s ++;
#line 377
        *tmp___1 = (char )':';
      }
    }
#line 379
    o ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  *s = (char )'\000';
#line 382
  return;
}
}
#line 384 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
void check_shmbeyond(char *msg ) 
{ 


  {
#line 386
  if (shmoffset >= shmlen) {
    {
#line 387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: region offset %#llx beyond its length %#llx at %s\n",
            shmoffset, shmlen, msg);
#line 390
    exit(1);
    }
  }
#line 392
  return;
}
}
#line 396 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
static char *last  ;
#line 394 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/numactl.c"
static struct bitmask *numactl_parse_nodestring(char *s , int flag ) 
{ 
  int tmp ;
  struct bitmask *tmp___0 ;
  struct bitmask *tmp___1 ;

  {
#line 398
  if ((int )*(s + 0) == 115) {
    {
#line 398
    tmp = strcmp((char const   *)s, "same");
    }
#line 398
    if (tmp) {
#line 403
      last = s;
    } else {
#line 399
      if (! last) {
        {
#line 400
        usage_msg((char *)"same needs previous node specification");
        }
      }
#line 401
      s = last;
    }
  } else {
#line 403
    last = s;
  }
#line 406
  if (flag == 1) {
    {
#line 407
    tmp___0 = numa_parse_nodestring_all((char const   *)s);
    }
#line 407
    return (tmp___0);
  } else {
    {
#line 409
    tmp___1 = numa_parse_nodestring((char const   *)s);
    }
#line 409
    return (tmp___1);
  }
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___18(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___18(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___18(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___18(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___18(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___18(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___18(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___18(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___18(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___18 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___18(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___18(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___18(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___18(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___18(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___18(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___18(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___18[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___18}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___18}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___18}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___18}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___18}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap64)(void *__addr ,
                                                                               size_t __len ,
                                                                               int __prot ,
                                                                               int __flags ,
                                                                               int __fd ,
                                                                               __off64_t __offset ) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname ,
                                                                             int __proj_id ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmctl)(int __shmid ,
                                                                             int __cmd ,
                                                                             struct shmid_ds *__buf ) ;
#line 53
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 192 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 230 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat64)(int __fd ,
                                                                                              struct stat64 *__buf ) ;
#line 1026 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate64)(int __fd ,
                                                                                  __off64_t __length ) ;
#line 4 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
char *shmptr  ;
#line 5 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
unsigned long long shmlen  ;
#line 7 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
unsigned long long shmoffset  ;
#line 8 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.h"
int shmflags  ;
#line 38 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
int shmfd  =    -1;
#line 39 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
long shmid  =    0L;
#line 42 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
mode_t shmmode  =    (mode_t )384;
#line 45 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static int shm_pagesize  ;
#line 47 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
long huge_page_size(void) 
{ 
  size_t len ;
  char *line ;
  FILE *f ;
  FILE *tmp ;
  int ps ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 49
  len = (size_t )0;
#line 50
  line = (char *)((void *)0);
#line 51
  tmp = fopen((char const   */* __restrict  */)"/proc/meminfo", (char const   */* __restrict  */)"r");
#line 51
  f = tmp;
  }
#line 52
  if ((unsigned long )f != (unsigned long )((void *)0)) {
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                         '\n', (FILE */* __restrict  */)f);
      }
#line 53
      if (! (tmp___1 > 0L)) {
#line 53
        goto while_break;
      }
      {
#line 55
      tmp___0 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"Hugepagesize: %d kB",
                       & ps);
      }
#line 55
      if (tmp___0 == 1) {
#line 56
        return ((long )(ps * 1024));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 58
    free((void *)line);
#line 59
    fclose(f);
    }
  }
  {
#line 61
  tmp___2 = getpagesize();
  }
#line 61
  return ((long )tmp___2);
}
}
#line 64 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static void check_region(char *opt ) 
{ 


  {
#line 66
  if ((unsigned long )shmptr % (unsigned long )shm_pagesize) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: policy region not page aligned\n");
#line 68
    exit(1);
    }
  } else
#line 66
  if (shmlen % (unsigned long long )shm_pagesize) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: policy region not page aligned\n");
#line 68
    exit(1);
    }
  }
#line 70
  if (! shmlen) {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: policy region length not specified before %s\n",
            opt);
#line 74
    exit(1);
    }
  }
#line 76
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static key_t sysvkey(char *name ) 
{ 
  int fd ;
  key_t key ;
  key_t tmp ;

  {
  {
#line 81
  tmp = ftok((char const   *)name, (int )shmid);
#line 81
  key = tmp;
  }
#line 82
  if (key >= 0) {
#line 83
    return (key);
  }
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: Creating shm key file %s mode %04o\n",
          name, shmmode);
#line 87
  fd = creat((char const   *)name, shmmode);
  }
#line 88
  if (fd < 0) {
    {
#line 89
    nerror((char *)"cannot create key for shm %s\n", name);
    }
  }
  {
#line 90
  key = ftok((char const   *)name, (int )shmid);
  }
#line 91
  if (key < 0) {
    {
#line 92
    nerror((char *)"cannot get key for newly created shm key file %s", name);
    }
  }
#line 94
  return (key);
}
}
#line 98 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
void attach_sysvshm(char *name , char *opt ) 
{ 
  struct shmid_ds s ;
  key_t key ;
  key_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  {
#line 101
  tmp = sysvkey(name);
#line 101
  key = tmp;
#line 103
  shmfd = shmget(key, (size_t )shmlen, shmflags);
  }
#line 104
  if (shmfd < 0) {
    {
#line 104
    tmp___0 = __errno_location();
    }
#line 104
    if (*tmp___0 == 2) {
#line 105
      if (shmlen == 0ULL) {
        {
#line 106
        complain((char *)"need a --length to create a sysv shared memory segment");
        }
      }
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numactl: Creating shared memory segment %s id %ld mode %04o length %.fMB\n",
              name, shmid, shmmode, (double )shmlen / (double )1048576);
#line 111
      shmfd = shmget(key, (size_t )shmlen, (int )((512U | shmmode) | (unsigned int )shmflags));
      }
#line 112
      if (shmfd < 0) {
        {
#line 113
        nerror((char *)"cannot create shared memory segment");
        }
      }
    }
  }
#line 116
  if (shmlen == 0ULL) {
    {
#line 117
    tmp___1 = shmctl(shmfd, 2, & s);
    }
#line 117
    if (tmp___1 < 0) {
      {
#line 118
      perror("numactl: shmctl IPC_STAT");
#line 118
      exit(1);
      }
    }
#line 119
    shmlen = (unsigned long long )s.shm_segsz;
  }
  {
#line 122
  tmp___2 = shmat(shmfd, (void const   *)((void *)0), 4096);
#line 122
  shmptr = (char *)tmp___2;
  }
#line 123
  if ((unsigned long )shmptr == (unsigned long )((void *)-1)) {
    {
#line 124
    perror("numactl: shmat");
#line 124
    exit(1);
    }
  }
#line 125
  shmptr += shmoffset;
#line 127
  if (shmflags & 2048) {
    {
#line 127
    tmp___3 = huge_page_size();
#line 127
    shm_pagesize = (int )tmp___3;
    }
  } else {
    {
#line 127
    tmp___4 = getpagesize();
#line 127
    shm_pagesize = tmp___4;
    }
  }
  {
#line 129
  check_region(opt);
  }
#line 130
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
void attach_shared(char *name , char *opt ) 
{ 
  struct stat64 st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 137
  shmfd = open((char const   *)name, 0);
  }
#line 138
  if (shmfd < 0) {
    {
#line 139
    tmp = __errno_location();
#line 139
    *tmp = 0;
    }
#line 140
    if (shmlen == 0ULL) {
      {
#line 141
      complain((char *)"need a --length to create a shared file");
      }
    }
    {
#line 142
    shmfd = open((char const   *)name, 66, shmmode);
    }
#line 143
    if (shmfd < 0) {
      {
#line 144
      nerror((char *)"cannot create file %s", name);
      }
    }
  }
  {
#line 146
  tmp___0 = fstat64(shmfd, & st);
  }
#line 146
  if (tmp___0 < 0) {
    {
#line 147
    perror("numactl: shm stat");
#line 147
    exit(1);
    }
  }
#line 148
  if (shmlen > (unsigned long long )st.st_size) {
    {
#line 149
    tmp___1 = ftruncate64(shmfd, (__off64_t )shmlen);
    }
#line 149
    if (tmp___1 < 0) {
      {
#line 153
      perror("ftruncate");
      }
    }
  }
  {
#line 157
  shm_pagesize = (int )st.st_blksize;
#line 159
  check_region(opt);
#line 163
  tmp___2 = mmap64((void *)0, (size_t )shmlen, 1, 1, shmfd, (__off64_t )shmoffset);
#line 163
  shmptr = (char *)tmp___2;
  }
#line 164
  if ((unsigned long )shmptr == (unsigned long )((char *)-1)) {
    {
#line 165
    perror("numactl: shm mmap");
#line 165
    exit(1);
    }
  }
#line 167
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static void dumppol(unsigned long long start___0 , unsigned long long end___0 , int pol ,
                    struct bitmask *mask ) 
{ 
  char *tmp ;

  {
#line 172
  if (pol == 0) {
#line 173
    return;
  }
  {
#line 174
  tmp = policy_name(pol);
#line 174
  printf((char const   */* __restrict  */)"%016Lx-%016Lx: %s ", shmoffset + start___0,
         shmoffset + end___0, tmp);
#line 178
  printmask((char *)"", mask);
  }
#line 179
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
void dump_shm(void) 
{ 
  struct bitmask *nodes ;
  struct bitmask *prevnodes ;
  int prevpol ;
  int pol ;
  unsigned long long c___1 ;
  unsigned long long start___0 ;
  long tmp ;

  {
#line 185
  prevpol = -1;
#line 188
  start___0 = 0ULL;
#line 189
  if (shmlen == 0ULL) {
    {
#line 190
    printf((char const   */* __restrict  */)"nothing to dump\n");
    }
#line 191
    return;
  }
  {
#line 194
  nodes = numa_allocate_nodemask();
#line 195
  prevnodes = numa_allocate_nodemask();
#line 197
  c___1 = 0ULL;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (c___1 < shmlen)) {
#line 197
      goto while_break;
    }
    {
#line 198
    tmp = get_mempolicy(& pol, (unsigned long const   *)nodes->maskp, nodes->size,
                        (void *)(shmptr + c___1), 1 << 1);
    }
#line 198
    if (tmp < 0L) {
      {
#line 200
      perror("numactl: get_mempolicy on shm");
#line 200
      exit(1);
      }
    }
#line 201
    if (pol == prevpol) {
#line 202
      goto __Cont;
    }
#line 203
    if (prevpol != -1) {
      {
#line 204
      dumppol(start___0, c___1, prevpol, prevnodes);
      }
    }
#line 205
    prevnodes = nodes;
#line 206
    prevpol = pol;
#line 207
    start___0 = c___1;
    __Cont: /* CIL Label */ 
#line 197
    c___1 += (unsigned long long )shm_pagesize;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  dumppol(start___0, c___1, prevpol, prevnodes);
  }
#line 210
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static void dumpnode(unsigned long long start___0 , unsigned long long end___0 , int node ) 
{ 


  {
  {
#line 214
  printf((char const   */* __restrict  */)"%016Lx-%016Lx: %d\n", shmoffset + start___0,
         shmoffset + end___0, node);
  }
#line 215
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
void dump_shm_nodes(void) 
{ 
  int prevnode ;
  int node ;
  unsigned long long c___1 ;
  unsigned long long start___0 ;
  long tmp ;

  {
#line 220
  prevnode = -1;
#line 223
  start___0 = 0ULL;
#line 224
  if (shmlen == 0ULL) {
    {
#line 225
    printf((char const   */* __restrict  */)"nothing to dump\n");
    }
#line 226
    return;
  }
#line 229
  c___1 = 0ULL;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (c___1 < shmlen)) {
#line 229
      goto while_break;
    }
    {
#line 230
    tmp = get_mempolicy(& node, (unsigned long const   *)((void *)0), 0UL, (void *)(shmptr + c___1),
                        (1 << 1) | 1);
    }
#line 230
    if (tmp < 0L) {
      {
#line 232
      perror("numactl: get_mempolicy on shm");
#line 232
      exit(1);
      }
    }
#line 233
    if (node == prevnode) {
#line 234
      goto __Cont;
    }
#line 235
    if (prevnode != -1) {
      {
#line 236
      dumpnode(start___0, c___1, prevnode);
      }
    }
#line 237
    prevnode = node;
#line 238
    start___0 = c___1;
    __Cont: /* CIL Label */ 
#line 229
    c___1 += (unsigned long long )shm_pagesize;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  dumpnode(start___0, c___1, prevnode);
  }
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static void vwarn(char *ptr , char *fmt  , ...) 
{ 
  va_list ap ;
  unsigned long off ;

  {
  {
#line 246
  off = (unsigned long )ptr - (unsigned long )shmptr;
#line 247
  __builtin_va_start(ap, fmt);
#line 248
  printf((char const   */* __restrict  */)"numactl verify %lx(%lx): ", (unsigned long )ptr,
         off);
#line 249
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 250
  __builtin_va_end(ap);
#line 251
  exitcode = 1;
  }
#line 252
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
static unsigned int interleave_next(unsigned int cur , struct bitmask *mask ) 
{ 
  int numa_num_nodes ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 256
  tmp = numa_num_possible_nodes();
#line 256
  numa_num_nodes = tmp;
#line 258
  cur ++;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)mask, cur);
    }
#line 259
    if (tmp___0) {
#line 259
      goto while_break;
    }
#line 260
    cur = (cur + 1U) % (unsigned int )numa_num_nodes;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (cur);
}
}
#line 266 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/shm.c"
void verify_shm(int policy___0 , struct bitmask *nodes ) 
{ 
  char *p ;
  int ilnode ;
  int node ;
  int pol2 ;
  struct bitmask *nodes2 ;
  long tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 273
  nodes2 = numa_allocate_nodemask();
  }
#line 275
  if (policy___0 == 3) {
    {
#line 276
    tmp = get_mempolicy(& ilnode, (unsigned long const   *)((void *)0), 0UL, (void *)shmptr,
                        (1 << 1) | 1);
    }
#line 276
    if (tmp < 0L) {
      {
#line 279
      perror("numactl: get_mempolicy");
#line 279
      exit(1);
      }
    }
  }
#line 282
  p = shmptr;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! ((unsigned long long )(p - shmptr) < shmlen)) {
#line 282
      goto while_break;
    }
    {
#line 283
    tmp___0 = get_mempolicy(& pol2, (unsigned long const   *)nodes2->maskp, nodes2->size,
                            (void *)p, 1 << 1);
    }
#line 283
    if (tmp___0 < 0L) {
      {
#line 285
      perror("numactl: get_mempolicy");
#line 285
      exit(1);
      }
    }
#line 286
    if (pol2 != policy___0) {
      {
#line 287
      tmp___1 = policy_name(policy___0);
#line 287
      tmp___2 = policy_name(pol2);
#line 287
      vwarn(p, (char *)"wrong policy %s, expected %s\n", tmp___2, tmp___1);
      }
#line 289
      return;
    }
    {
#line 291
    tmp___3 = numa_bitmask_nbytes(nodes);
#line 291
    tmp___4 = memcmp((void const   *)nodes2, (void const   *)nodes, (size_t )tmp___3);
    }
#line 291
    if (tmp___4) {
      {
#line 292
      vwarn(p, (char *)"mismatched node mask\n");
#line 293
      printmask((char *)"expected", nodes);
#line 294
      printmask((char *)"real", nodes2);
      }
    }
    {
#line 297
    tmp___5 = get_mempolicy(& node, (unsigned long const   *)((void *)0), 0UL, (void *)p,
                            (1 << 1) | 1);
    }
#line 297
    if (tmp___5 < 0L) {
      {
#line 298
      perror("numactl: get_mempolicy");
#line 298
      exit(1);
      }
    }
    {
#line 301
    if (policy___0 == 3) {
#line 301
      goto case_3;
    }
#line 312
    if (policy___0 == 2) {
#line 312
      goto case_2;
    }
#line 312
    if (policy___0 == 1) {
#line 312
      goto case_2;
    }
#line 319
    if (policy___0 == 0) {
#line 319
      goto case_0;
    }
#line 300
    goto switch_break;
    case_3: /* CIL Label */ 
#line 302
    if (node < 0) {
      {
#line 303
      vwarn(p, (char *)"interleave node out of range %d\n", node);
      }
    } else {
      {
#line 302
      tmp___6 = numa_bitmask_isbitset((struct bitmask  const  *)nodes2, (unsigned int )node);
      }
#line 302
      if (! tmp___6) {
        {
#line 303
        vwarn(p, (char *)"interleave node out of range %d\n", node);
        }
      }
    }
#line 304
    if (node != ilnode) {
      {
#line 305
      vwarn(p, (char *)"expected interleave node %d, got %d\n", ilnode, node);
      }
#line 307
      return;
    }
    {
#line 309
    tmp___7 = interleave_next((unsigned int )ilnode, nodes2);
#line 309
    ilnode = (int )tmp___7;
    }
#line 310
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 313
    tmp___8 = numa_bitmask_isbitset((struct bitmask  const  *)nodes2, (unsigned int )node);
    }
#line 313
    if (! tmp___8) {
      {
#line 314
      vwarn(p, (char *)"unexpected node %d\n", node);
#line 315
      printmask((char *)"expected", nodes2);
      }
    }
#line 317
    goto switch_break;
    case_0: /* CIL Label */ 
#line 320
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 282
    p += shm_pagesize;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 94 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 38 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/memhog.c"
int repeat  =    1;
#line 49 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/memhog.c"
long length  ;
#line 51 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/memhog.c"
void hog(void *map ) 
{ 
  long i ;
  long left ;

  {
#line 54
  i = 0L;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < length)) {
#line 54
      goto while_break;
    }
#line 55
    left = length - i;
#line 56
    if (left > 10485760L) {
#line 57
      left = 10485760L;
    }
    {
#line 58
    putchar('.');
#line 59
    fflush(stdout);
#line 60
    memset(map + i, 255, (size_t )left);
#line 54
    i += 10485760L;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  putchar('\n');
  }
#line 63
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static struct policy policies___4[5]  = {      {(char *)"interleave", 3, 0}, 
        {(char *)"membind", 2, 0}, 
        {(char *)"preferred", 1, 0}, 
        {(char *)"default", 0, 1}, 
        {(char *)((void *)0), 0, 0}};
#line 101 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char *policy_names___4[4]  = {      (char *)"default",      (char *)"preferred",      (char *)"bind",      (char *)"interleave"};
#line 105 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/util.c"
static char buf___6[32]  ;
#line 26 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int distance_numnodes___19  ;
#line 27 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int *distance_table___19  ;
#line 29 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static void parse_numbers___19(char *s , int *iptr ) 
{ 
  int i ;
  int d ;
  int j ;
  char *end___0 ;
  int maxnode ;
  int tmp ;
  int numnodes ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  tmp = numa_max_node();
#line 33
  maxnode = tmp;
#line 34
  numnodes = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= maxnode)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp___0 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr, (unsigned int )i);
    }
#line 37
    if (tmp___0) {
#line 38
      numnodes ++;
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  i = 0;
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (i <= maxnode)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                      0);
#line 41
    d = (int )tmp___1;
    }
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (j <= maxnode) {
        {
#line 43
        tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)numa_nodes_ptr,
                                        (unsigned int )j);
        }
#line 43
        if (tmp___2) {
#line 43
          goto while_break___1;
        }
      } else {
#line 43
        goto while_break___1;
      }
#line 44
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    *(iptr + j) = d;
#line 46
    if ((unsigned long )s == (unsigned long )end___0) {
#line 47
      goto while_break___0;
    }
#line 48
    s = end___0;
#line 40
    i ++;
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/distance.c"
static int read_distance_table___19(void) 
{ 
  int nd ;
  int len ;
  char *line ;
  size_t linelen ;
  int maxnode ;
  int tmp ;
  int *table ;
  int err ;
  char fn[100] ;
  FILE *dfh ;
  int *tmp___0 ;
  __ssize_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 55
  line = (char *)((void *)0);
#line 56
  linelen = (size_t )0;
#line 57
  tmp = numa_max_node();
#line 57
  maxnode = tmp + 1;
#line 58
  table = (int *)((void *)0);
#line 59
  err = -1;
#line 61
  nd = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    sprintf((char */* __restrict  */)(fn), (char const   */* __restrict  */)"/sys/devices/system/node/node%d/distance",
            nd);
#line 65
    dfh = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 66
    if (! dfh) {
      {
#line 67
      tmp___0 = __errno_location();
      }
#line 67
      if (*tmp___0 == 2) {
#line 68
        err = 0;
      }
#line 69
      if (! err) {
#line 69
        if (nd < maxnode) {
#line 70
          goto __Cont;
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    }
    {
#line 74
    tmp___1 = getdelim((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& linelen),
                       '\n', (FILE */* __restrict  */)dfh);
#line 74
    len = (int )tmp___1;
#line 75
    fclose(dfh);
    }
#line 76
    if (len <= 0) {
#line 77
      goto while_break;
    }
#line 79
    if (! table) {
      {
#line 80
      tmp___2 = calloc((size_t )(maxnode * maxnode), sizeof(int ));
#line 80
      table = (int *)tmp___2;
      }
#line 81
      if (! table) {
        {
#line 82
        tmp___3 = __errno_location();
#line 82
        *tmp___3 = 12;
        }
#line 83
        goto while_break;
      }
    }
    {
#line 87
    parse_numbers___19(line, table + nd * maxnode);
    }
    __Cont: /* CIL Label */ 
#line 61
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)line);
  }
#line 90
  if (err) {
    {
#line 91
    tmp___4 = __errno_location();
#line 91
    tmp___5 = strerror(*tmp___4);
#line 91
    numa_warn(7, (char *)"Cannot parse distance information in sysfs: %s", tmp___5);
#line 94
    free((void *)table);
    }
#line 95
    return (err);
  }
#line 101
  if (distance_table___19) {
    {
#line 102
    free((void *)table);
    }
#line 103
    return (0);
  }
#line 105
  distance_numnodes___19 = maxnode;
#line 106
  distance_table___19 = table;
#line 107
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/syscall.c"
__asm__(".symver numa_sched_setaffinity_v1,numa_sched_setaffinity@libnuma_1.1");
#line 230
__asm__(".symver numa_sched_setaffinity_v2,numa_sched_setaffinity@@libnuma_1.2");
#line 237
__asm__(".symver numa_sched_getaffinity_v1,numa_sched_getaffinity@libnuma_1.1");
#line 247
__asm__(".symver numa_sched_getaffinity_v2,numa_sched_getaffinity@@libnuma_1.2");
#line 58 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *numa_memnode_ptr___19  =    (struct bitmask *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long *node_cpu_mask_v1___19[128]  ;
#line 68 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  int bind_policy___19  =    2;
#line 69 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static  __thread  unsigned int mbind_flags___19  =    0U;
#line 70 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int sizes_set___19  =    0;
#line 71 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfigurednode___19  =    -1;
#line 72 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int maxconfiguredcpu___19  =    -1;
#line 73 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numprocnode___19  =    -1;
#line 74 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int numproccpu___19  =    -1;
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int nodemask_sz___19  =    0;
#line 76 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int cpumask_sz___19  =    0;
#line 80
static void set_sizes___19(void) ;
#line 128 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int _getbit___19(struct bitmask  const  *bmp , unsigned int n ) 
{ 


  {
#line 131
  if ((unsigned long const   )n < bmp->size) {
#line 132
    return ((unsigned int )((*(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) >> (unsigned long )n % (8UL * sizeof(unsigned long ))) & 1UL));
  } else {
#line 134
    return (0U);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void _setbit___19(struct bitmask *bmp , unsigned int n , unsigned int v ) 
{ 


  {
#line 140
  if ((unsigned long )n < bmp->size) {
#line 141
    if (v) {
#line 142
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) |= 1UL << (unsigned long )n % (8UL * sizeof(unsigned long ));
    } else {
#line 144
      *(bmp->maskp + (unsigned long )n / (8UL * sizeof(unsigned long ))) &= ~ (1UL << (unsigned long )n % (8UL * sizeof(unsigned long )));
    }
  }
#line 146
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned int warned___20  ;
#line 285 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void setpol___19(int policy___0 , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 287
  tmp = set_mempolicy(policy___0, (unsigned long const   *)bmp->maskp, bmp->size + 1UL);
  }
#line 287
  if (tmp < 0L) {
    {
#line 288
    numa_error((char *)"set_mempolicy");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void getpol___19(int *oldpolicy , struct bitmask *bmp ) 
{ 
  long tmp ;

  {
  {
#line 293
  tmp = get_mempolicy(oldpolicy, (unsigned long const   *)bmp->maskp, bmp->size + 1UL,
                      (void *)0, 0);
  }
#line 293
  if (tmp < 0L) {
    {
#line 294
    numa_error((char *)"get_mempolicy");
    }
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void dombind___19(void *mem___0 , size_t size___20 , int pol , struct bitmask *bmp ) 
{ 
  unsigned long tmp ;
  unsigned long *tmp___0 ;
  long tmp___1 ;

  {
#line 299
  if (bmp) {
#line 299
    tmp = bmp->size + 1UL;
  } else {
#line 299
    tmp = 0UL;
  }
#line 299
  if (bmp) {
#line 299
    tmp___0 = bmp->maskp;
  } else {
#line 299
    tmp___0 = (unsigned long *)((void *)0);
  }
  {
#line 299
  tmp___1 = mbind(mem___0, size___20, pol, (unsigned long const   *)tmp___0, tmp,
                  mbind_flags___19);
  }
#line 299
  if (tmp___1 < 0L) {
    {
#line 301
    numa_error((char *)"mbind");
    }
  }
#line 302
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int pagesize___20  ;
#line 321 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_nodes___19(void) 
{ 
  DIR *d ;
  struct dirent *de ;
  long long freep ;
  int nd ;
  int tmp ;
  unsigned long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 328
  numa_memnode_ptr___19 = numa_allocate_nodemask();
#line 329
  numa_nodes_ptr = numa_allocate_nodemask();
#line 331
  d = opendir("/sys/devices/system/node");
  }
#line 332
  if (! d) {
#line 333
    maxconfigurednode___19 = 0;
  } else {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      de = readdir(d);
      }
#line 335
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 335
        goto while_break;
      }
      {
#line 337
      tmp = strncmp((char const   *)(de->d_name), "node", (size_t )4);
      }
#line 337
      if (tmp) {
#line 338
        goto while_continue;
      }
      {
#line 339
      tmp___0 = strtoul((char const   */* __restrict  */)(de->d_name + 4), (char **/* __restrict  */)((void *)0),
                        0);
#line 339
      nd = (int )tmp___0;
#line 340
      numa_bitmask_setbit(numa_nodes_ptr, (unsigned int )nd);
#line 341
      tmp___1 = numa_node_size64(nd, & freep);
      }
#line 341
      if (tmp___1 > 0LL) {
        {
#line 342
        numa_bitmask_setbit(numa_memnode_ptr___19, (unsigned int )nd);
        }
      }
#line 343
      if (maxconfigurednode___19 < nd) {
#line 344
        maxconfigurednode___19 = nd;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    closedir(d);
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int s2nbits___19(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 356
  tmp = strlen(s);
  }
#line 356
  return ((int )((tmp * 32UL) / 9UL));
}
}
#line 360 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int strprefix___19(char const   *s , char const   *pre ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  tmp = strlen(pre);
#line 362
  tmp___0 = strncmp(s, pre, tmp);
  }
#line 362
  return (tmp___0 == 0);
}
}
#line 365 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *mask_size_file___19  =    "/proc/self/status";
#line 366 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static char const   *nodemask_prefix___19  =    "Mems_allowed:\t";
#line 373 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_nodemask_size___19(void) 
{ 
  FILE *fp ;
  char *buf___7 ;
  size_t bufsize ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;
  int pol ;
  unsigned long *mask ;
  void *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 377
  buf___7 = (char *)((void *)0);
#line 378
  bufsize = (size_t )0;
#line 380
  fp = fopen((char const   */* __restrict  */)mask_size_file___19, (char const   */* __restrict  */)"r");
  }
#line 380
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 381
    goto done;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    tmp___1 = getline((char **/* __restrict  */)(& buf___7), (size_t */* __restrict  */)(& bufsize),
                      (FILE */* __restrict  */)fp);
    }
#line 383
    if (! (tmp___1 > 0L)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strprefix___19((char const   *)buf___7, nodemask_prefix___19);
    }
#line 384
    if (tmp___0) {
      {
#line 385
      tmp = strlen(nodemask_prefix___19);
#line 385
      nodemask_sz___19 = s2nbits___19((char const   *)(buf___7 + tmp));
      }
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  free((void *)buf___7);
#line 390
  fclose(fp);
  }
  done: 
#line 392
  if (nodemask_sz___19 == 0) {
#line 394
    mask = (unsigned long *)((void *)0);
#line 395
    nodemask_sz___19 = 16;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 397
      nodemask_sz___19 <<= 1;
#line 398
      tmp___2 = realloc((void *)mask, (size_t )(nodemask_sz___19 / 8));
#line 398
      mask = (unsigned long *)tmp___2;
      }
#line 399
      if (! mask) {
#line 400
        return;
      }
      {
#line 396
      tmp___3 = get_mempolicy(& pol, (unsigned long const   *)mask, (unsigned long )(nodemask_sz___19 + 1),
                              (void *)0, 0);
      }
#line 396
      if (tmp___3 < 0L) {
        {
#line 396
        tmp___4 = __errno_location();
        }
#line 396
        if (*tmp___4 == 22) {
#line 396
          if (! (nodemask_sz___19 < 32768)) {
#line 396
            goto while_break___0;
          }
        } else {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 403
    free((void *)mask);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int read_mask___19(char *s , struct bitmask *bmp ) 
{ 
  char *end___0 ;
  int tmplen ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  unsigned int *start___0 ;
  unsigned int i ;
  unsigned int n ;
  unsigned int m ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  int w ;
  unsigned long x ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 414
  end___0 = s;
#line 415
  tmplen = (int )(((bmp->size + 8UL * sizeof(unsigned int )) - 1UL) / (8UL * sizeof(unsigned int )));
#line 416
  __lengthoftmp = (unsigned long )tmplen;
#line 416
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 416
  tmp = (unsigned int *)tmp___0;
#line 417
  start___0 = tmp;
#line 418
  n = 0U;
#line 418
  m = 0U;
  }
#line 420
  if (! s) {
#line 421
    return (0);
  }
  {
#line 423
  tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& end___0),
                    16);
#line 423
  i = (unsigned int )tmp___1;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! i) {
#line 426
      tmp___3 = end___0;
#line 426
      end___0 ++;
#line 426
      if (! ((int )*tmp___3 == 44)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 427
    i = (unsigned int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (! i) {
#line 432
    return (-1);
  }
#line 434
  tmp___4 = n;
#line 434
  n ++;
#line 434
  *(start___0 + tmp___4) = i;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    tmp___7 = end___0;
#line 436
    end___0 ++;
#line 436
    if (! ((int )*tmp___7 == 44)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    tmp___5 = strtoul((char const   */* __restrict  */)end___0, (char **/* __restrict  */)(& end___0),
                      16);
#line 437
    i = (unsigned int )tmp___5;
#line 438
    tmp___6 = n;
#line 438
    n ++;
#line 438
    *(start___0 + tmp___6) = i;
    }
#line 441
    if (n > (unsigned int )tmplen) {
#line 442
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! n) {
#line 449
      goto while_break___1;
    }
#line 451
    x = 0UL;
#line 453
    w = 0;
    {
#line 453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 453
      if (n) {
#line 453
        if (! ((unsigned long )w < 8UL * sizeof(unsigned long ))) {
#line 453
          goto while_break___2;
        }
      } else {
#line 453
        goto while_break___2;
      }
#line 454
      tmp___8 = n;
#line 454
      n --;
#line 454
      x |= (unsigned long )*(start___0 + (tmp___8 - 1U)) << w;
#line 453
      w = (int )((unsigned long )w + 8UL * sizeof(unsigned int ));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 456
    tmp___9 = m;
#line 456
    m ++;
#line 456
    *(bmp->maskp + tmp___9) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  tmp___10 = numa_bitmask_weight((struct bitmask  const  *)bmp);
  }
#line 461
  return ((int )tmp___10);
}
}
#line 468 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_task_constraints___19(void) 
{ 
  int hicpu ;
  int i ;
  char *buffer ;
  size_t buflen ;
  FILE *f ;
  char *mask ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;

  {
  {
#line 471
  hicpu = maxconfiguredcpu___19;
#line 473
  buffer = (char *)((void *)0);
#line 474
  buflen = (size_t )0;
#line 477
  numa_all_cpus_ptr = numa_allocate_cpumask();
#line 478
  numa_possible_cpus_ptr = numa_allocate_cpumask();
#line 479
  numa_all_nodes_ptr = numa_allocate_nodemask();
#line 480
  numa_possible_nodes_ptr = numa_allocate_cpumask();
#line 481
  numa_no_nodes_ptr = numa_allocate_nodemask();
#line 483
  f = fopen((char const   */* __restrict  */)mask_size_file___19, (char const   */* __restrict  */)"r");
  }
#line 484
  if (! f) {
#line 486
    return;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 489
    tmp___2 = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& buflen),
                      (FILE */* __restrict  */)f);
    }
#line 489
    if (! (tmp___2 > 0L)) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp = strrchr((char const   *)buffer, '\t');
#line 491
    mask = tmp + 1;
#line 493
    tmp___0 = strncmp((char const   *)buffer, "Cpus_allowed:", (size_t )13);
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 494
      numproccpu___19 = read_mask___19(mask, numa_all_cpus_ptr);
      }
    }
    {
#line 496
    tmp___1 = strncmp((char const   *)buffer, "Mems_allowed:", (size_t )13);
    }
#line 496
    if (tmp___1 == 0) {
      {
#line 497
      numprocnode___19 = read_mask___19(mask, numa_all_nodes_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  fclose(f);
#line 501
  free((void *)buffer);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (i <= hicpu)) {
#line 503
      goto while_break___0;
    }
    {
#line 504
    numa_bitmask_setbit(numa_possible_cpus_ptr, (unsigned int )i);
#line 503
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= maxconfigurednode___19)) {
#line 505
      goto while_break___1;
    }
    {
#line 506
    numa_bitmask_setbit(numa_possible_nodes_ptr, (unsigned int )i);
#line 505
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (numproccpu___19 <= 0) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (i <= hicpu)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      numa_bitmask_setbit(numa_all_cpus_ptr, (unsigned int )i);
#line 515
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 517
    numproccpu___19 = hicpu + 1;
  }
#line 520
  if (numproccpu___19 > hicpu + 1) {
#line 521
    numproccpu___19 = hicpu + 1;
#line 522
    i = hicpu + 1;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (! ((unsigned long )i < numa_all_cpus_ptr->size)) {
#line 522
        goto while_break___3;
      }
      {
#line 523
      numa_bitmask_clearbit(numa_all_cpus_ptr, (unsigned int )i);
#line 522
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 527
  if (numprocnode___19 <= 0) {
#line 528
    i = 0;
    {
#line 528
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 528
      if (! (i <= maxconfigurednode___19)) {
#line 528
        goto while_break___4;
      }
      {
#line 529
      numa_bitmask_setbit(numa_all_nodes_ptr, (unsigned int )i);
#line 528
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 530
    numprocnode___19 = maxconfigurednode___19 + 1;
  }
#line 533
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_numa_max_cpu___19(void) 
{ 
  int len ;
  int n ;
  int olde ;
  int *tmp ;
  struct bitmask *buffer ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 543
  len = 4096;
#line 545
  tmp = __errno_location();
#line 545
  olde = *tmp;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    buffer = numa_bitmask_alloc((unsigned int )len);
#line 550
    n = numa_sched_getaffinity_v2_int(0, buffer);
    }
#line 552
    if (n < 0) {
      {
#line 552
      tmp___0 = __errno_location();
      }
#line 552
      if (*tmp___0 == 22) {
#line 553
        if (len >= 1048576) {
#line 554
          goto while_break;
        }
        {
#line 555
        len *= 2;
#line 556
        numa_bitmask_free(buffer);
        }
#line 557
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 548
    if (! (n < 0)) {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  numa_bitmask_free(buffer);
#line 561
  tmp___1 = __errno_location();
#line 561
  *tmp___1 = olde;
#line 562
  cpumask_sz___19 = n * 8;
  }
#line 563
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_configured_cpus___19(void) 
{ 
  long tmp ;

  {
  {
#line 571
  tmp = sysconf(83);
#line 571
  maxconfiguredcpu___19 = (int )(tmp - 1L);
  }
#line 572
  if (maxconfiguredcpu___19 == -1) {
    {
#line 573
    numa_error((char *)"sysconf(NPROCESSORS_CONF) failed.\n");
    }
  }
#line 574
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static void set_sizes___19(void) 
{ 


  {
  {
#line 582
  sizes_set___19 ++;
#line 583
  set_nodemask_size___19();
#line 584
  set_configured_nodes___19();
#line 585
  set_numa_max_cpu___19();
#line 586
  set_configured_cpus___19();
#line 587
  set_task_constraints___19();
  }
#line 588
  return;
}
}
#line 680
__asm__(".symver numa_max_possible_node_v1,numa_max_possible_node@libnuma_1.1");
#line 687
__asm__(".symver numa_max_possible_node_v2,numa_max_possible_node@@libnuma_1.2");
#line 707 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *allocate_nodemask_v1___19(void) 
{ 
  int nnodes ;
  int tmp ;
  struct bitmask *tmp___0 ;

  {
  {
#line 710
  tmp = numa_max_possible_node_v1_int();
#line 710
  nnodes = tmp + 1;
#line 712
  tmp___0 = numa_bitmask_alloc((unsigned int )nnodes);
  }
#line 712
  return (tmp___0);
}
}
#line 805
__asm__(".symver numa_interleave_memory_v1,numa_interleave_memory@libnuma_1.1");
#line 812
__asm__(".symver numa_interleave_memory_v2,numa_interleave_memory@@libnuma_1.2");
#line 833
__asm__(".symver numa_tonodemask_memory_v1,numa_tonodemask_memory@libnuma_1.1");
#line 840
__asm__(".symver numa_tonodemask_memory_v2,numa_tonodemask_memory@@libnuma_1.2");
#line 899
__asm__(".symver numa_alloc_interleaved_subset_v1,numa_alloc_interleaved_subset@libnuma_1.1");
#line 912
__asm__(".symver numa_alloc_interleaved_subset_v2,numa_alloc_interleaved_subset@@libnuma_1.2");
#line 941
__asm__(".symver numa_set_interleave_mask_v1,numa_set_interleave_mask@libnuma_1.1");
#line 951
__asm__(".symver numa_set_interleave_mask_v2,numa_set_interleave_mask@@libnuma_1.2");
#line 969
__asm__(".symver numa_get_interleave_mask_v1,numa_get_interleave_mask@libnuma_1.1");
#line 983
__asm__(".symver numa_get_interleave_mask_v2,numa_get_interleave_mask@@libnuma_1.2");
#line 1040
__asm__(".symver numa_set_membind_v1,numa_set_membind@libnuma_1.1");
#line 1047
__asm__(".symver numa_set_membind_v2,numa_set_membind@@libnuma_1.2");
#line 1125
__asm__(".symver numa_get_membind_v1,numa_get_membind@libnuma_1.1");
#line 1139
__asm__(".symver numa_get_membind_v2,numa_get_membind@@libnuma_1.2");
#line 1196
__asm__(".symver numa_parse_bitmap_v1,numa_parse_bitmap@libnuma_1.1");
#line 1232
__asm__(".symver numa_parse_bitmap_v2,numa_parse_bitmap@@libnuma_1.2");
#line 1310
__asm__(".symver numa_node_to_cpus_v1,numa_node_to_cpus@libnuma_1.1");
#line 1387
__asm__(".symver numa_node_to_cpus_v2,numa_node_to_cpus@@libnuma_1.2");
#line 1448 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static int size___19  =    -1;
#line 1472
__asm__(".symver numa_run_on_node_mask_v1,numa_run_on_node_mask@libnuma_1.1");
#line 1523
__asm__(".symver numa_run_on_node_mask_v2,numa_run_on_node_mask@@libnuma_1.2");
#line 1607
__asm__(".symver numa_get_run_node_mask_v1,numa_get_run_node_mask@libnuma_1.1");
#line 1648
__asm__(".symver numa_get_run_node_mask_v2,numa_get_run_node_mask@@libnuma_1.2");
#line 1744
__asm__(".symver numa_bind_v1,numa_bind@libnuma_1.1");
#line 1751
__asm__(".symver numa_bind_v2,numa_bind@@libnuma_1.2");
#line 1766 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static unsigned long get_nr___19(char const   *s , char **end___0 , struct bitmask *bmp ,
                                 int relative ) 
{ 
  long i ;
  long nr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1770
  if (! relative) {
    {
#line 1771
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                  0);
    }
#line 1771
    return (tmp);
  }
  {
#line 1773
  tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)end___0,
                    0);
#line 1773
  nr = (long )tmp___0;
  }
#line 1774
  if ((unsigned long )s == (unsigned long )*end___0) {
#line 1775
    return ((unsigned long )nr);
  }
#line 1777
  i = 0L;
  {
#line 1777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1777
    if (nr >= 0L) {
#line 1777
      if (! ((unsigned long )i <= bmp->size)) {
#line 1777
        goto while_break;
      }
    } else {
#line 1777
      goto while_break;
    }
    {
#line 1778
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)bmp, (unsigned int )i);
    }
#line 1778
    if (tmp___1) {
#line 1779
      nr --;
    }
#line 1777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  return ((unsigned long )(i - 1L));
}
}
#line 1794 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_nodestring___19(char const   *s , struct bitmask *allowed_nodes_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_nodes ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *end2 ;
  unsigned long arg2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int i___0 ;
  int tmp___7 ;

  {
  {
#line 1797
  invert = 0;
#line 1797
  relative = 0;
#line 1798
  tmp = numa_num_configured_nodes();
#line 1798
  conf_nodes = tmp;
#line 1802
  mask = numa_allocate_nodemask();
  }
#line 1804
  if ((int const   )*(s + 0) == 0) {
    {
#line 1805
    copy_bitmask_to_bitmask(numa_no_nodes_ptr, mask);
    }
#line 1806
    return (mask);
  }
#line 1808
  if ((int const   )*s == 33) {
#line 1809
    invert = 1;
#line 1810
    s ++;
  }
#line 1812
  if ((int const   )*s == 43) {
#line 1813
    relative ++;
#line 1814
    s ++;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1819
    tmp___2 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___2 + (int )*s) & 1024) {
      {
#line 1821
      tmp___0 = strcmp(s, "all");
      }
#line 1821
      if (! tmp___0) {
        {
#line 1822
        copy_bitmask_to_bitmask(allowed_nodes_ptr, mask);
#line 1824
        s += 4;
        }
#line 1825
        goto while_break;
      }
      {
#line 1827
      n = (int )resolve_affinity(s, mask);
      }
#line 1828
      if (n != -2) {
#line 1829
        if (n < 0) {
#line 1830
          goto err;
        }
        {
#line 1831
        tmp___1 = strlen(s);
#line 1831
        s += tmp___1 + 1UL;
        }
#line 1832
        goto while_break;
      }
    }
    {
#line 1835
    arg = get_nr___19(s, & end___0, allowed_nodes_ptr, relative);
    }
#line 1836
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1837
      numa_warn(10, (char *)"unparseable node description `%s\'\n", s);
      }
#line 1838
      goto err;
    }
    {
#line 1840
    tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr, (unsigned int )arg);
    }
#line 1840
    if (! tmp___3) {
      {
#line 1841
      numa_warn(10, (char *)"node argument %d is out of range\n", arg);
      }
#line 1842
      goto err;
    }
    {
#line 1844
    i = (int )arg;
#line 1845
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1846
    s = (char const   *)end___0;
    }
#line 1847
    if ((int const   )*s == 45) {
      {
#line 1850
      s ++;
#line 1850
      arg2 = get_nr___19(s, & end2, allowed_nodes_ptr, relative);
      }
#line 1851
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1852
        numa_warn(10, (char *)"missing node argument %s\n", s);
        }
#line 1853
        goto err;
      }
      {
#line 1855
      tmp___4 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                      (unsigned int )arg2);
      }
#line 1855
      if (! tmp___4) {
        {
#line 1856
        numa_warn(10, (char *)"node argument %d out of range\n", arg2);
        }
#line 1857
        goto err;
      }
      {
#line 1859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1859
        if (! (arg <= arg2)) {
#line 1859
          goto while_break___0;
        }
        {
#line 1860
        i = (int )arg;
#line 1861
        tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_nodes_ptr,
                                        (unsigned int )i);
        }
#line 1861
        if (tmp___5) {
          {
#line 1862
          numa_bitmask_setbit(mask, (unsigned int )i);
          }
        }
#line 1863
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1865
      s = (char const   *)end2;
    }
#line 1816
    tmp___6 = s;
#line 1816
    s ++;
#line 1816
    if (! ((int const   )*tmp___6 == 44)) {
#line 1816
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1868
  if ((int const   )*(s + -1) != 0) {
#line 1869
    goto err;
  }
#line 1870
  if (invert) {
#line 1872
    i___0 = 0;
    {
#line 1872
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1872
      if (! (i___0 < conf_nodes)) {
#line 1872
        goto while_break___1;
      }
      {
#line 1873
      tmp___7 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___0);
      }
#line 1873
      if (tmp___7) {
        {
#line 1874
        numa_bitmask_clearbit(mask, (unsigned int )i___0);
        }
      } else {
        {
#line 1876
        numa_bitmask_setbit(mask, (unsigned int )i___0);
        }
      }
#line 1872
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1879
  return (mask);
  err: 
  {
#line 1882
  numa_bitmask_free(mask);
  }
#line 1883
  return ((struct bitmask *)((void *)0));
}
}
#line 1918 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/libnuma.c"
static struct bitmask *__numa_parse_cpustring___19(char const   *s , struct bitmask *allowed_cpus_ptr ) 
{ 
  int invert ;
  int relative ;
  int conf_cpus ;
  int tmp ;
  char *end___0 ;
  struct bitmask *mask ;
  unsigned long arg ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  char *end2 ;
  unsigned long arg2 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int i___1 ;
  int tmp___5 ;

  {
  {
#line 1921
  invert = 0;
#line 1921
  relative = 0;
#line 1922
  tmp = numa_num_configured_cpus();
#line 1922
  conf_cpus = tmp;
#line 1926
  mask = numa_allocate_cpumask();
  }
#line 1928
  if ((int const   )*(s + 0) == 0) {
#line 1929
    return (mask);
  }
#line 1930
  if ((int const   )*s == 33) {
#line 1931
    invert = 1;
#line 1932
    s ++;
  }
#line 1934
  if ((int const   )*s == 43) {
#line 1935
    relative ++;
#line 1936
    s ++;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    tmp___0 = strcmp(s, "all");
    }
#line 1942
    if (! tmp___0) {
      {
#line 1943
      copy_bitmask_to_bitmask(allowed_cpus_ptr, mask);
#line 1944
      s += 4;
      }
#line 1945
      goto while_break;
    }
    {
#line 1947
    arg = get_nr___19(s, & end___0, allowed_cpus_ptr, relative);
    }
#line 1948
    if ((unsigned long )end___0 == (unsigned long )s) {
      {
#line 1949
      numa_warn(9, (char *)"unparseable cpu description `%s\'\n", s);
      }
#line 1950
      goto err;
    }
    {
#line 1952
    tmp___1 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr, (unsigned int )arg);
    }
#line 1952
    if (! tmp___1) {
      {
#line 1953
      numa_warn(9, (char *)"cpu argument %s is out of range\n", s);
      }
#line 1954
      goto err;
    }
    {
#line 1956
    i = (int )arg;
#line 1957
    numa_bitmask_setbit(mask, (unsigned int )i);
#line 1958
    s = (char const   *)end___0;
    }
#line 1959
    if ((int const   )*s == 45) {
      {
#line 1963
      s ++;
#line 1963
      arg2 = get_nr___19(s, & end2, allowed_cpus_ptr, relative);
      }
#line 1964
      if ((unsigned long )end2 == (unsigned long )s) {
        {
#line 1965
        numa_warn(9, (char *)"missing cpu argument %s\n", s);
        }
#line 1966
        goto err;
      }
      {
#line 1968
      tmp___2 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                      (unsigned int )arg2);
      }
#line 1968
      if (! tmp___2) {
        {
#line 1969
        numa_warn(9, (char *)"cpu argument %s out of range\n", s);
        }
#line 1970
        goto err;
      }
      {
#line 1972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1972
        if (! (arg <= arg2)) {
#line 1972
          goto while_break___0;
        }
        {
#line 1973
        i___0 = (int )arg;
#line 1974
        tmp___3 = numa_bitmask_isbitset((struct bitmask  const  *)allowed_cpus_ptr,
                                        (unsigned int )i___0);
        }
#line 1974
        if (tmp___3) {
          {
#line 1975
          numa_bitmask_setbit(mask, (unsigned int )i___0);
          }
        }
#line 1976
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1978
      s = (char const   *)end2;
    }
#line 1938
    tmp___4 = s;
#line 1938
    s ++;
#line 1938
    if (! ((int const   )*tmp___4 == 44)) {
#line 1938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  if ((int const   )*(s + -1) != 0) {
#line 1982
    goto err;
  }
#line 1983
  if (invert) {
#line 1985
    i___1 = 0;
    {
#line 1985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1985
      if (! (i___1 < conf_cpus)) {
#line 1985
        goto while_break___1;
      }
      {
#line 1986
      tmp___5 = numa_bitmask_isbitset((struct bitmask  const  *)mask, (unsigned int )i___1);
      }
#line 1986
      if (tmp___5) {
        {
#line 1987
        numa_bitmask_clearbit(mask, (unsigned int )i___1);
        }
      } else {
        {
#line 1989
        numa_bitmask_setbit(mask, (unsigned int )i___1);
        }
      }
#line 1985
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1992
  return (mask);
  err: 
  {
#line 1995
  numa_bitmask_free(mask);
  }
#line 1996
  return ((struct bitmask *)((void *)0));
}
}
#line 52 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int badchar___19(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 54
  tmp = strpbrk(s, "/.");
  }
#line 54
  if (tmp) {
#line 55
    return (1);
  }
#line 56
  return (0);
}
}
#line 59 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int node_parse_failure___19(int ret , char *cls , char const   *dev ) 
{ 
  char const   *tmp ;

  {
#line 61
  if (! cls) {
#line 62
    cls = (char *)"";
  }
#line 63
  if (ret == -2) {
#line 64
    if (*cls) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    numa_warn(25, (char *)"Kernel does not know node mask for%s%s device `%s\'", tmp,
              cls, dev);
    }
  } else {
    {
#line 68
    numa_warn(26, (char *)"Cannot read node mask for %s device `%s\'", cls, dev);
    }
  }
#line 71
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_class___19(struct bitmask *mask , char *cls , char const   *dev ) 
{ 
  int ret ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char path[1024] ;
  char *fn ;
  regex_t re ;
  regmatch_t match[2] ;
  char *p ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = __ctype_b_loc();
    }
#line 79
    if (! ((int const   )*(*tmp + (int )*dev) & 8192)) {
#line 79
      goto while_break;
    }
#line 80
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___0 = badchar___19(dev);
  }
#line 81
  if (tmp___0) {
    {
#line 82
    numa_warn(28, (char *)"Illegal characters in `%s\' specification", dev);
    }
#line 84
    return (-1);
  }
  {
#line 91
  fn = (char *)((void *)0);
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"/sys/class/%s/%s",
                     cls, dev);
  }
#line 92
  if (tmp___3 > 0) {
    {
#line 92
    tmp___4 = readlink((char const   */* __restrict  */)fn, (char */* __restrict  */)(path),
                       sizeof(path));
    }
#line 92
    if (tmp___4 > 0L) {
      {
#line 98
      regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)"(/devices/pci[0-9a-fA-F:/]+\\.[0-9]+)/",
              1);
#line 100
      ret = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(path),
                    (size_t )2, (regmatch_t */* __restrict  */)(match), 0);
#line 101
      regfree(& re);
      }
#line 102
      if (ret == 0) {
        {
#line 103
        free((void *)fn);
        }
#line 104
        if (! (match[0].rm_so > 0)) {
          {
#line 104
          __assert_fail("match[0].rm_so > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        104U, "affinity_class");
          }
        }
#line 105
        if (! (match[0].rm_eo > 0)) {
          {
#line 105
          __assert_fail("match[0].rm_eo > 0", "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c",
                        105U, "affinity_class");
          }
        }
        {
#line 106
        path[match[1].rm_eo + 1] = (char)0;
#line 107
        p = path + match[0].rm_so;
#line 108
        tmp___1 = sysfs_node_read(mask, (char *)"/sys/%s/numa_node", p);
#line 108
        ret = (int )tmp___1;
        }
#line 109
        if (ret < 0) {
          {
#line 110
          tmp___2 = node_parse_failure___19(ret, (char *)((void *)0), (char const   *)p);
          }
#line 110
          return (tmp___2);
        }
#line 111
        return (ret);
      }
    }
  }
  {
#line 114
  free((void *)fn);
#line 116
  tmp___5 = sysfs_node_read(mask, (char *)"/sys/class/%s/%s/device/numa_node", cls,
                            dev);
#line 116
  ret = (int )tmp___5;
  }
#line 118
  if (ret < 0) {
    {
#line 119
    tmp___6 = node_parse_failure___19(ret, cls, dev);
    }
#line 119
    return (tmp___6);
  }
#line 120
  return (0);
}
}
#line 125 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_file___19(struct bitmask *mask , char *cls , char const   *file ) 
{ 
  struct stat st ;
  DIR *dir ;
  int n ;
  unsigned int maj ;
  unsigned int min ;
  dev_t d ;
  struct dirent de ;
  struct dirent *dep ;
  size_t tmp ;
  char *fn ;
  unsigned long __lengthoffn ;
  void *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *dev ;
  size_t tmp___2 ;
  char *fn2 ;
  unsigned long __lengthoffn2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char __attribute__((__visibility__("hidden")))  *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 130
  maj = 0U;
#line 130
  min = 0U;
#line 134
  cls = (char *)"block";
#line 135
  tmp = strlen((char const   *)cls);
#line 135
  __lengthoffn = sizeof("/sys/class/") + tmp;
#line 135
  tmp___0 = __builtin_alloca(sizeof(*fn) * __lengthoffn);
#line 135
  fn = (char *)tmp___0;
#line 136
  tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 136
  if (tmp___1 < 0) {
    {
#line 137
    numa_warn(11, (char *)"Cannot stat file %s", file);
    }
#line 138
    return (-1);
  }
#line 140
  d = st.st_dev;
#line 141
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    cls = (char *)"misc";
#line 145
    d = st.st_rdev;
  } else
#line 146
  if ((st.st_mode & 61440U) == 24576U) {
#line 147
    d = st.st_rdev;
  }
  {
#line 149
  sprintf((char */* __restrict  */)fn, (char const   */* __restrict  */)"/sys/class/%s",
          cls);
#line 150
  dir = opendir((char const   *)fn);
  }
#line 151
  if (! dir) {
    {
#line 152
    numa_warn(12, (char *)"Cannot enumerate %s devices in sysfs", cls);
    }
#line 154
    return (-1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___9 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& de),
                        (struct dirent **/* __restrict  */)(& dep));
    }
#line 156
    if (tmp___9 == 0) {
#line 156
      if (! dep) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    name = dep->d_name;
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    }
    {
#line 161
    tmp___2 = strlen((char const   *)name);
#line 161
    __lengthoffn2 = sizeof("/sys/class/block//dev") + tmp___2;
#line 161
    tmp___3 = __builtin_alloca(sizeof(*fn2) * __lengthoffn2);
#line 161
    fn2 = (char *)tmp___3;
#line 163
    n = -1;
#line 164
    tmp___4 = sprintf((char */* __restrict  */)fn2, (char const   */* __restrict  */)"/sys/class/block/%s/dev",
                      name);
    }
#line 164
    if (tmp___4 < 0) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = sysfs_read(fn2);
#line 166
    dev = (char *)tmp___5;
    }
#line 167
    if (dev) {
      {
#line 168
      n = sscanf((char const   */* __restrict  */)dev, (char const   */* __restrict  */)"%u:%u",
                 & maj, & min);
#line 169
      free((void *)dev);
      }
    }
#line 171
    if (n != 2) {
      {
#line 172
      numa_warn(13, (char *)"Cannot parse sysfs device %s", name);
      }
#line 174
      goto while_continue;
    }
    {
#line 177
    tmp___6 = gnu_dev_major((unsigned long long )d);
    }
#line 177
    if (tmp___6 != maj) {
#line 178
      goto while_continue;
    } else {
      {
#line 177
      tmp___7 = gnu_dev_minor((unsigned long long )d);
      }
#line 177
      if (tmp___7 != min) {
#line 178
        goto while_continue;
      }
    }
    {
#line 180
    closedir(dir);
#line 181
    tmp___8 = affinity_class___19(mask, (char *)"block", (char const   *)name);
    }
#line 181
    return (tmp___8);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
#line 184
  numa_warn(15, (char *)"Cannot find block device %x:%x in sysfs for `%s\'", maj,
            min, file);
  }
#line 186
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int find_route___19(struct sockaddr *dst , int *iifp ) 
{ 
  struct rtattr *rta ;
  int hdrlen ;
  struct __anonstruct_req_89___19 req ;
  struct sockaddr_nl adr ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int __attribute__((__visibility__("hidden")))  tmp___2 ;
  struct rtattr  __attribute__((__visibility__("hidden"))) *tmp___3 ;

  {
  {
#line 193
  hdrlen = (int )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
  req.msg.nlmsg_len = (__u32 )hdrlen;
#line 194
  req.msg.nlmsg_type = (__u16 )26;
#line 194
  req.msg.nlmsg_flags = (__u16 )1;
#line 194
  req.msg.nlmsg_seq = 0U;
#line 194
  req.msg.nlmsg_pid = 0U;
#line 194
  req.rt.rtm_family = (unsigned char )dst->sa_family;
#line 194
  req.rt.rtm_dst_len = (unsigned char)0;
#line 194
  req.rt.rtm_src_len = (unsigned char)0;
#line 194
  req.rt.rtm_tos = (unsigned char)0;
#line 194
  req.rt.rtm_table = (unsigned char)0;
#line 194
  req.rt.rtm_protocol = (unsigned char)0;
#line 194
  req.rt.rtm_scope = (unsigned char)0;
#line 194
  req.rt.rtm_type = (unsigned char)0;
#line 194
  req.rt.rtm_flags = 0U;
#line 194
  req.buf[0] = (char)0;
#line 194
  req.buf[1] = (char)0;
#line 194
  req.buf[2] = (char)0;
#line 194
  req.buf[3] = (char)0;
#line 194
  req.buf[4] = (char)0;
#line 194
  req.buf[5] = (char)0;
#line 194
  req.buf[6] = (char)0;
#line 194
  req.buf[7] = (char)0;
#line 194
  req.buf[8] = (char)0;
#line 194
  req.buf[9] = (char)0;
#line 194
  req.buf[10] = (char)0;
#line 194
  req.buf[11] = (char)0;
#line 194
  req.buf[12] = (char)0;
#line 194
  req.buf[13] = (char)0;
#line 194
  req.buf[14] = (char)0;
#line 194
  req.buf[15] = (char)0;
#line 194
  req.buf[16] = (char)0;
#line 194
  req.buf[17] = (char)0;
#line 194
  req.buf[18] = (char)0;
#line 194
  req.buf[19] = (char)0;
#line 194
  req.buf[20] = (char)0;
#line 194
  req.buf[21] = (char)0;
#line 194
  req.buf[22] = (char)0;
#line 194
  req.buf[23] = (char)0;
#line 194
  req.buf[24] = (char)0;
#line 194
  req.buf[25] = (char)0;
#line 194
  req.buf[26] = (char)0;
#line 194
  req.buf[27] = (char)0;
#line 194
  req.buf[28] = (char)0;
#line 194
  req.buf[29] = (char)0;
#line 194
  req.buf[30] = (char)0;
#line 194
  req.buf[31] = (char)0;
#line 194
  req.buf[32] = (char)0;
#line 194
  req.buf[33] = (char)0;
#line 194
  req.buf[34] = (char)0;
#line 194
  req.buf[35] = (char)0;
#line 194
  req.buf[36] = (char)0;
#line 194
  req.buf[37] = (char)0;
#line 194
  req.buf[38] = (char)0;
#line 194
  req.buf[39] = (char)0;
#line 194
  req.buf[40] = (char)0;
#line 194
  req.buf[41] = (char)0;
#line 194
  req.buf[42] = (char)0;
#line 194
  req.buf[43] = (char)0;
#line 194
  req.buf[44] = (char)0;
#line 194
  req.buf[45] = (char)0;
#line 194
  req.buf[46] = (char)0;
#line 194
  req.buf[47] = (char)0;
#line 194
  req.buf[48] = (char)0;
#line 194
  req.buf[49] = (char)0;
#line 194
  req.buf[50] = (char)0;
#line 194
  req.buf[51] = (char)0;
#line 194
  req.buf[52] = (char)0;
#line 194
  req.buf[53] = (char)0;
#line 194
  req.buf[54] = (char)0;
#line 194
  req.buf[55] = (char)0;
#line 194
  req.buf[56] = (char)0;
#line 194
  req.buf[57] = (char)0;
#line 194
  req.buf[58] = (char)0;
#line 194
  req.buf[59] = (char)0;
#line 194
  req.buf[60] = (char)0;
#line 194
  req.buf[61] = (char)0;
#line 194
  req.buf[62] = (char)0;
#line 194
  req.buf[63] = (char)0;
#line 194
  req.buf[64] = (char)0;
#line 194
  req.buf[65] = (char)0;
#line 194
  req.buf[66] = (char)0;
#line 194
  req.buf[67] = (char)0;
#line 194
  req.buf[68] = (char)0;
#line 194
  req.buf[69] = (char)0;
#line 194
  req.buf[70] = (char)0;
#line 194
  req.buf[71] = (char)0;
#line 194
  req.buf[72] = (char)0;
#line 194
  req.buf[73] = (char)0;
#line 194
  req.buf[74] = (char)0;
#line 194
  req.buf[75] = (char)0;
#line 194
  req.buf[76] = (char)0;
#line 194
  req.buf[77] = (char)0;
#line 194
  req.buf[78] = (char)0;
#line 194
  req.buf[79] = (char)0;
#line 194
  req.buf[80] = (char)0;
#line 194
  req.buf[81] = (char)0;
#line 194
  req.buf[82] = (char)0;
#line 194
  req.buf[83] = (char)0;
#line 194
  req.buf[84] = (char)0;
#line 194
  req.buf[85] = (char)0;
#line 194
  req.buf[86] = (char)0;
#line 194
  req.buf[87] = (char)0;
#line 194
  req.buf[88] = (char)0;
#line 194
  req.buf[89] = (char)0;
#line 194
  req.buf[90] = (char)0;
#line 194
  req.buf[91] = (char)0;
#line 194
  req.buf[92] = (char)0;
#line 194
  req.buf[93] = (char)0;
#line 194
  req.buf[94] = (char)0;
#line 194
  req.buf[95] = (char)0;
#line 194
  req.buf[96] = (char)0;
#line 194
  req.buf[97] = (char)0;
#line 194
  req.buf[98] = (char)0;
#line 194
  req.buf[99] = (char)0;
#line 194
  req.buf[100] = (char)0;
#line 194
  req.buf[101] = (char)0;
#line 194
  req.buf[102] = (char)0;
#line 194
  req.buf[103] = (char)0;
#line 194
  req.buf[104] = (char)0;
#line 194
  req.buf[105] = (char)0;
#line 194
  req.buf[106] = (char)0;
#line 194
  req.buf[107] = (char)0;
#line 194
  req.buf[108] = (char)0;
#line 194
  req.buf[109] = (char)0;
#line 194
  req.buf[110] = (char)0;
#line 194
  req.buf[111] = (char)0;
#line 194
  req.buf[112] = (char)0;
#line 194
  req.buf[113] = (char)0;
#line 194
  req.buf[114] = (char)0;
#line 194
  req.buf[115] = (char)0;
#line 194
  req.buf[116] = (char)0;
#line 194
  req.buf[117] = (char)0;
#line 194
  req.buf[118] = (char)0;
#line 194
  req.buf[119] = (char)0;
#line 194
  req.buf[120] = (char)0;
#line 194
  req.buf[121] = (char)0;
#line 194
  req.buf[122] = (char)0;
#line 194
  req.buf[123] = (char)0;
#line 194
  req.buf[124] = (char)0;
#line 194
  req.buf[125] = (char)0;
#line 194
  req.buf[126] = (char)0;
#line 194
  req.buf[127] = (char)0;
#line 194
  req.buf[128] = (char)0;
#line 194
  req.buf[129] = (char)0;
#line 194
  req.buf[130] = (char)0;
#line 194
  req.buf[131] = (char)0;
#line 194
  req.buf[132] = (char)0;
#line 194
  req.buf[133] = (char)0;
#line 194
  req.buf[134] = (char)0;
#line 194
  req.buf[135] = (char)0;
#line 194
  req.buf[136] = (char)0;
#line 194
  req.buf[137] = (char)0;
#line 194
  req.buf[138] = (char)0;
#line 194
  req.buf[139] = (char)0;
#line 194
  req.buf[140] = (char)0;
#line 194
  req.buf[141] = (char)0;
#line 194
  req.buf[142] = (char)0;
#line 194
  req.buf[143] = (char)0;
#line 194
  req.buf[144] = (char)0;
#line 194
  req.buf[145] = (char)0;
#line 194
  req.buf[146] = (char)0;
#line 194
  req.buf[147] = (char)0;
#line 194
  req.buf[148] = (char)0;
#line 194
  req.buf[149] = (char)0;
#line 194
  req.buf[150] = (char)0;
#line 194
  req.buf[151] = (char)0;
#line 194
  req.buf[152] = (char)0;
#line 194
  req.buf[153] = (char)0;
#line 194
  req.buf[154] = (char)0;
#line 194
  req.buf[155] = (char)0;
#line 194
  req.buf[156] = (char)0;
#line 194
  req.buf[157] = (char)0;
#line 194
  req.buf[158] = (char)0;
#line 194
  req.buf[159] = (char)0;
#line 194
  req.buf[160] = (char)0;
#line 194
  req.buf[161] = (char)0;
#line 194
  req.buf[162] = (char)0;
#line 194
  req.buf[163] = (char)0;
#line 194
  req.buf[164] = (char)0;
#line 194
  req.buf[165] = (char)0;
#line 194
  req.buf[166] = (char)0;
#line 194
  req.buf[167] = (char)0;
#line 194
  req.buf[168] = (char)0;
#line 194
  req.buf[169] = (char)0;
#line 194
  req.buf[170] = (char)0;
#line 194
  req.buf[171] = (char)0;
#line 194
  req.buf[172] = (char)0;
#line 194
  req.buf[173] = (char)0;
#line 194
  req.buf[174] = (char)0;
#line 194
  req.buf[175] = (char)0;
#line 194
  req.buf[176] = (char)0;
#line 194
  req.buf[177] = (char)0;
#line 194
  req.buf[178] = (char)0;
#line 194
  req.buf[179] = (char)0;
#line 194
  req.buf[180] = (char)0;
#line 194
  req.buf[181] = (char)0;
#line 194
  req.buf[182] = (char)0;
#line 194
  req.buf[183] = (char)0;
#line 194
  req.buf[184] = (char)0;
#line 194
  req.buf[185] = (char)0;
#line 194
  req.buf[186] = (char)0;
#line 194
  req.buf[187] = (char)0;
#line 194
  req.buf[188] = (char)0;
#line 194
  req.buf[189] = (char)0;
#line 194
  req.buf[190] = (char)0;
#line 194
  req.buf[191] = (char)0;
#line 194
  req.buf[192] = (char)0;
#line 194
  req.buf[193] = (char)0;
#line 194
  req.buf[194] = (char)0;
#line 194
  req.buf[195] = (char)0;
#line 194
  req.buf[196] = (char)0;
#line 194
  req.buf[197] = (char)0;
#line 194
  req.buf[198] = (char)0;
#line 194
  req.buf[199] = (char)0;
#line 194
  req.buf[200] = (char)0;
#line 194
  req.buf[201] = (char)0;
#line 194
  req.buf[202] = (char)0;
#line 194
  req.buf[203] = (char)0;
#line 194
  req.buf[204] = (char)0;
#line 194
  req.buf[205] = (char)0;
#line 194
  req.buf[206] = (char)0;
#line 194
  req.buf[207] = (char)0;
#line 194
  req.buf[208] = (char)0;
#line 194
  req.buf[209] = (char)0;
#line 194
  req.buf[210] = (char)0;
#line 194
  req.buf[211] = (char)0;
#line 194
  req.buf[212] = (char)0;
#line 194
  req.buf[213] = (char)0;
#line 194
  req.buf[214] = (char)0;
#line 194
  req.buf[215] = (char)0;
#line 194
  req.buf[216] = (char)0;
#line 194
  req.buf[217] = (char)0;
#line 194
  req.buf[218] = (char)0;
#line 194
  req.buf[219] = (char)0;
#line 194
  req.buf[220] = (char)0;
#line 194
  req.buf[221] = (char)0;
#line 194
  req.buf[222] = (char)0;
#line 194
  req.buf[223] = (char)0;
#line 194
  req.buf[224] = (char)0;
#line 194
  req.buf[225] = (char)0;
#line 194
  req.buf[226] = (char)0;
#line 194
  req.buf[227] = (char)0;
#line 194
  req.buf[228] = (char)0;
#line 194
  req.buf[229] = (char)0;
#line 194
  req.buf[230] = (char)0;
#line 194
  req.buf[231] = (char)0;
#line 194
  req.buf[232] = (char)0;
#line 194
  req.buf[233] = (char)0;
#line 194
  req.buf[234] = (char)0;
#line 194
  req.buf[235] = (char)0;
#line 194
  req.buf[236] = (char)0;
#line 194
  req.buf[237] = (char)0;
#line 194
  req.buf[238] = (char)0;
#line 194
  req.buf[239] = (char)0;
#line 194
  req.buf[240] = (char)0;
#line 194
  req.buf[241] = (char)0;
#line 194
  req.buf[242] = (char)0;
#line 194
  req.buf[243] = (char)0;
#line 194
  req.buf[244] = (char)0;
#line 194
  req.buf[245] = (char)0;
#line 194
  req.buf[246] = (char)0;
#line 194
  req.buf[247] = (char)0;
#line 194
  req.buf[248] = (char)0;
#line 194
  req.buf[249] = (char)0;
#line 194
  req.buf[250] = (char)0;
#line 194
  req.buf[251] = (char)0;
#line 194
  req.buf[252] = (char)0;
#line 194
  req.buf[253] = (char)0;
#line 194
  req.buf[254] = (char)0;
#line 194
  req.buf[255] = (char)0;
#line 208
  adr.nl_family = (__kernel_sa_family_t )16;
#line 208
  adr.nl_pad = (unsigned short)0;
#line 208
  adr.nl_pid = 0U;
#line 208
  adr.nl_groups = 0U;
#line 212
  tmp = rta_put_address(& req.msg, 1, dst);
  }
#line 212
  if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 213
    numa_warn(16, (char *)"Cannot handle network family %x", (int )dst->sa_family);
    }
#line 215
    return (-1);
  }
  {
#line 218
  tmp___2 = rtnetlink_request(& req.msg, (int )sizeof(req), & adr);
  }
#line 218
  if (tmp___2 < (int __attribute__((__visibility__("hidden")))  )0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    tmp___1 = strerror(*tmp___0);
#line 219
    numa_warn(17, (char *)"Cannot request rtnetlink route: %s", tmp___1);
    }
#line 221
    return (-1);
  }
#line 225
  rta = (struct rtattr *)((void *)0);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp___3 = rta_get(& req.msg, rta, hdrlen);
#line 226
    rta = (struct rtattr *)tmp___3;
    }
#line 226
    if (! ((unsigned long )rta != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
#line 227
    if ((int )rta->rta_type == 4) {
      {
#line 228
      memcpy((void */* __restrict  */)iifp, (void const   */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             sizeof(int ));
      }
#line 229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  numa_warn(18, (char *)"rtnetlink query did not return interface");
  }
#line 234
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int iif_to_name___19(int iif , struct ifreq *ifr ) 
{ 
  int n ;
  int sk ;
  int tmp ;

  {
  {
#line 240
  tmp = socket(2, 2, 0);
#line 240
  sk = tmp;
  }
#line 241
  if (sk < 0) {
#line 242
    return (-1);
  }
  {
#line 243
  ifr->ifr_ifru.ifru_ivalue = iif;
#line 244
  n = ioctl(sk, 35088UL, ifr);
#line 245
  close(sk);
  }
#line 246
  return (n);
}
}
#line 253 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_ip___19(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  struct addrinfo *ai ;
  int n ;
  int iif ;
  struct ifreq ifr ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  n = getaddrinfo((char const   */* __restrict  */)id, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 260
  if (n != 0) {
    {
#line 261
    tmp = gai_strerror(n);
#line 261
    numa_warn(19, (char *)"Cannot resolve %s: %s", id, tmp);
    }
#line 263
    return (-1);
  }
  {
#line 266
  tmp___0 = find_route___19(ai->ai_addr + 0, & iif);
  }
#line 266
  if (tmp___0 < 0) {
#line 267
    goto out_ai;
  }
  {
#line 269
  tmp___1 = iif_to_name___19(iif, & ifr);
  }
#line 269
  if (tmp___1 < 0) {
    {
#line 270
    numa_warn(20, (char *)"Cannot resolve network interface %d", iif);
    }
#line 271
    goto out_ai;
  }
  {
#line 274
  freeaddrinfo(ai);
#line 275
  tmp___2 = affinity_class___19(mask, (char *)"net", (char const   *)(ifr.ifr_ifrn.ifrn_name));
  }
#line 275
  return (tmp___2);
  out_ai: 
  {
#line 278
  freeaddrinfo(ai);
  }
#line 279
  return (-1);
}
}
#line 283 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static int affinity_pci___19(struct bitmask *mask , char *cls , char const   *id ) 
{ 
  unsigned int seg ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int n ;
  int ret ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int tmp___0 ;

  {
  {
#line 289
  n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x:%x.%x",
             & seg, & bus, & dev, & func);
  }
#line 289
  if (n == 4) {
#line 289
    goto _L___0;
  } else
#line 289
  if (n == 3) {
    _L___0: /* CIL Label */ 
#line 290
    if (n == 3) {
#line 291
      func = 0U;
    }
  } else {
    {
#line 294
    n = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%x:%x.%x",
               & bus, & dev, & func);
    }
#line 294
    if (n == 3) {
#line 294
      goto _L;
    } else
#line 294
    if (n == 2) {
      _L: /* CIL Label */ 
#line 295
      seg = 0U;
#line 296
      if (n == 2) {
#line 297
        func = 0U;
      }
    } else {
      {
#line 299
      numa_warn(23, (char *)"Cannot parse PCI device `%s\'", id);
      }
#line 300
      return (-1);
    }
  }
  {
#line 302
  tmp = sysfs_node_read(mask, (char *)"/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%x/numa_node",
                        seg, bus, seg, bus, dev, func);
#line 302
  ret = (int )tmp;
  }
#line 305
  if (ret < 0) {
    {
#line 306
    tmp___0 = node_parse_failure___19(ret, cls, id);
    }
#line 306
    return (tmp___0);
  }
#line 307
  return (0);
}
}
#line 310 "/home/wheatley/newnew/temp/numactl-2.0.9~rc5/affinity.c"
static struct handler handlers___19[6]  = {      {(char )'n', (char *)"netdev:", (char *)"net", & affinity_class___19}, 
        {(char )'i', (char *)"ip:", (char *)((void *)0), & affinity_ip___19}, 
        {(char )'f', (char *)"file:", (char *)((void *)0), & affinity_file___19}, 
        {(char )'b', (char *)"block:", (char *)"block", & affinity_class___19}, 
        {(char )'p', (char *)"pci:", (char *)((void *)0), & affinity_pci___19}, 
        {(char)0, (char *)0, (char *)0, (int (*)(struct bitmask *mask , char *cls , char const   *desc ))0}};
