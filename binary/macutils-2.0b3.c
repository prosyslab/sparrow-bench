/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
struct macheader {
   char m_name[128] ;
   char m_type[4] ;
   char m_author[4] ;
   short m_flags ;
   long m_datalen ;
   long m_rsrclen ;
   long m_createtime ;
   long m_modifytime ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.h"
struct real_time {
   int year ;
   int month ;
   int day ;
   int hours ;
   int minutes ;
   int seconds ;
};
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.h"
typedef struct real_time real_time;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/appledouble.h"
struct __anonstruct_FileInfo_19 {
   char fi_magic[4] ;
   char fi_version[2] ;
   char fi_fill1[4] ;
   char fi_fill2[4] ;
   char fi_fill3[4] ;
   char fi_fill4[4] ;
   char fi_fill5[4] ;
   char fi_fill6[4] ;
   char fi_hlen[4] ;
   char fi_rsrc[4] ;
   char fi_fill7[4] ;
   char fi_namptr[4] ;
   char fi_namlen[4] ;
   char fi_fill9[4] ;
   char fi_commptr[4] ;
   char fi_commsize[4] ;
   char fi_fill12[4] ;
   char fi_timeptr[4] ;
   char fi_timesize[4] ;
   char fi_fill15[4] ;
   char fi_infoptr[4] ;
   char fi_infosize[4] ;
   char fi_name[255] ;
   char fi_comment[200] ;
   char fi_ctime[4] ;
   char fi_mtime[4] ;
   char fi_fill19[4] ;
   char fi_fill20[4] ;
   char fi_type[4] ;
   char fi_auth[4] ;
   char fi_finfo[24] ;
};
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/appledouble.h"
typedef struct __anonstruct_FileInfo_19 FileInfo;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 63 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
struct filelist {
   int nfiles ;
   char **files ;
   int *kind ;
   struct filelist *previous ;
   int current ;
   int shared_dir ;
};
#line 63 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
typedef struct filelist filelist;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
struct node {
   int flag ;
   int byte ;
   struct node *one ;
   struct node *zero ;
};
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
struct __anonstruct_table_struct_18 {
   int num ;
   int next ;
};
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
typedef struct __anonstruct_table_struct_18 table_struct;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
typedef struct node node;
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.h"
struct pit_header {
   unsigned char nlen ;
   char name[63] ;
   char type[4] ;
   char auth[4] ;
   unsigned short flags ;
   unsigned short lock ;
   unsigned long dlen ;
   unsigned long rlen ;
   unsigned long ctim ;
   unsigned long mtim ;
   unsigned short hdrCRC ;
};
#line 33 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.h"
struct fileHdr {
   unsigned char hsize ;
   unsigned char hcrc ;
   char method[5] ;
   unsigned long psize ;
   unsigned long upsize ;
   unsigned long lastmod ;
   unsigned short attribute ;
   unsigned char nlength ;
   char name[32] ;
   unsigned short crc ;
   unsigned char etype ;
   unsigned char extendsize ;
   char *extend ;
   char *data ;
};
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
struct methodinfo {
   char *name ;
   int number ;
};
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.h"
typedef long OSType;
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.h"
struct sitHdr {
   OSType signature ;
   unsigned short numFiles ;
   unsigned long arcLength ;
   OSType signature2 ;
   unsigned char version ;
   char reserved[7] ;
};
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.h"
struct fileHdr___0 {
   unsigned char compRMethod ;
   unsigned char compDMethod ;
   unsigned char fName[64] ;
   OSType fType ;
   OSType fCreator ;
   unsigned short FndrFlags ;
   unsigned long creationDate ;
   unsigned long modDate ;
   unsigned long rsrcLength ;
   unsigned long dataLength ;
   unsigned long compRLength ;
   unsigned long compDLength ;
   unsigned short rsrcCRC ;
   unsigned short dataCRC ;
   char reserved[6] ;
   unsigned short hdrCRC ;
};
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.h"
struct fileHdr___1 {
   char deleted ;
   char what ;
   unsigned char hlen ;
   unsigned short boolFlags ;
   unsigned long next ;
   unsigned long compRLength ;
   unsigned long compDLength ;
   unsigned long rsrcLength ;
   unsigned long dataLength ;
   unsigned long fType ;
   unsigned long fCreator ;
   unsigned long modDate ;
   unsigned long comment ;
   unsigned short FndrFlags ;
   unsigned short dataCRC ;
   unsigned short rsrcCRC ;
   unsigned char fName[32] ;
   unsigned long conts ;
};
#line 34 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.h"
struct cptHdr {
   unsigned char signature ;
   unsigned char volume ;
   unsigned short xmagic ;
   unsigned long offset ;
   unsigned long hdrcrc ;
   unsigned short entries ;
   unsigned char commentsize ;
};
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.h"
struct fileHdr___2 {
   unsigned char fName[32] ;
   unsigned char folder ;
   unsigned short foldersize ;
   unsigned char volume ;
   unsigned long filepos ;
   OSType fType ;
   OSType fCreator ;
   unsigned long creationDate ;
   unsigned long modDate ;
   unsigned short FndrFlags ;
   unsigned long fileCRC ;
   unsigned short cptFlag ;
   unsigned long rsrcLength ;
   unsigned long dataLength ;
   unsigned long compRLength ;
   unsigned long compDLength ;
};
#line 554 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
struct sf_entry {
   int Value ;
   int BitLength ;
};
#line 554 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
typedef struct sf_entry sf_entry;
#line 55 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.h"
struct fileHdr___3 {
   unsigned char magic[4] ;
   unsigned char fill1[4] ;
   unsigned char fName[64] ;
   unsigned char isdir ;
   unsigned char enddir ;
   unsigned long dataLength ;
   unsigned long rsrcLength ;
   unsigned long creationDate ;
   unsigned long modDate ;
   OSType fType ;
   OSType fCreator ;
   unsigned short FndrFlags ;
   unsigned char fill2[18] ;
   unsigned short datacrc ;
   unsigned short rsrccrc ;
   unsigned short hdrcrc ;
};
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.h"
struct fileCHdr {
   unsigned char magic[4] ;
   unsigned long dataLength ;
   unsigned long dataCLength ;
   unsigned long rsrcLength ;
   unsigned long rsrcCLength ;
   unsigned char datamethod ;
   unsigned char rsrcmethod ;
   unsigned char info1 ;
   unsigned char fill3 ;
   unsigned long modDate ;
   unsigned long creationDate ;
   OSType fType ;
   OSType fCreator ;
   unsigned short FndrFlags ;
   unsigned char fill1[6] ;
   unsigned short datacrc ;
   unsigned short rsrccrc ;
   unsigned char info2 ;
   unsigned char fill4 ;
   unsigned short datainfo ;
   unsigned short rsrcinfo ;
   unsigned char fill2[20] ;
   unsigned short datacrc2 ;
   unsigned short rsrccrc2 ;
   unsigned short hdrcrc ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/fileglob.c"
int bytes_read  ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/fileglob.c"
int bytes_written  ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
void transname(char *name , char *namebuf , int n ) ;
#line 13
char info[128] ;
#line 14
char trname[64] ;
#line 27
struct macheader mh ;
#line 29
int listmode ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.h"
unsigned long crc ;
#line 9
void verify_crc(unsigned long calc_crc___0 , unsigned long file_crc___0 ) ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/readline.h"
char line[1024] ;
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../util/util.h"
void put4(char *dest , unsigned long value ) ;
#line 18
void put2(char *dest , unsigned long value ) ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../fileio/wrfile.h"
void define_name(char *text___0 ) ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
void put_byte(char c ) ;
#line 4
void set_put(int data ) ;
#line 5
void end_put(void) ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/printhdr.h"
void print_header0(int skip ) ;
#line 2
void print_header1(int skip1 , int skip2 ) ;
#line 3
void print_header2(int skip ) ;
#line 13 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 15
static void do_o_forks(void) ;
#line 16
static long make_file(int compressed___0 ) ;
#line 17
static void comp_c_crc(unsigned char c ) ;
#line 18
static void comp_e_crc(unsigned char c ) ;
#line 19
static int comp_to_bin(void) ;
#line 20
static int hex_to_bin(void) ;
#line 21
static int hexit(int c ) ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static int compressed  ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
void hecx(char *macname , char *filename___2 ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 31
  n = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (n < 128)) {
#line 31
      goto while_break;
    }
#line 32
    info[n] = (char)0;
#line 31
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  compressed = 0;
#line 36
  if ((int )*(macname + 0) == 0) {
    {
#line 38
    macname = rindex((char const   *)filename___2, '/');
    }
#line 39
    if ((unsigned long )macname == (unsigned long )((void *)0)) {
#line 40
      macname = filename___2;
    } else {
#line 42
      macname ++;
    }
    {
#line 46
    tmp = strlen((char const   *)macname);
#line 46
    n = (int )tmp;
    }
#line 47
    if (n > 4) {
      {
#line 48
      n -= 4;
#line 49
      tmp___0 = strncmp((char const   *)(macname + n), ".hex", (size_t )4);
      }
#line 49
      if (tmp___0) {
        {
#line 49
        tmp___1 = strncmp((char const   *)(macname + n), ".hcx", (size_t )4);
        }
#line 49
        if (! tmp___1) {
#line 51
          *(macname + n) = (char )'\000';
        }
      } else {
#line 51
        *(macname + n) = (char )'\000';
      }
    }
  }
  {
#line 55
  tmp___2 = strlen((char const   *)macname);
#line 55
  n = (int )tmp___2;
  }
#line 56
  if (n > 63) {
#line 57
    n = 63;
  }
  {
#line 59
  strncpy((char */* __restrict  */)(mh.m_name), (char const   */* __restrict  */)macname,
          (size_t )n);
#line 60
  mh.m_name[n] = (char )'\000';
#line 63
  tmp___3 = strlen((char const   *)(line));
#line 63
  n = (int )tmp___3;
  }
#line 64
  if (n >= 6) {
#line 64
    if ((int )line[0] == 35) {
#line 64
      if ((int )line[n - 5] == 36) {
#line 65
        if (n >= 10) {
          {
#line 66
          strncpy((char */* __restrict  */)(mh.m_type), (char const   */* __restrict  */)(& line[1]),
                  (size_t )4);
          }
        }
#line 68
        if (n >= 14) {
          {
#line 69
          strncpy((char */* __restrict  */)(mh.m_author), (char const   */* __restrict  */)(& line[5]),
                  (size_t )4);
          }
        }
        {
#line 71
        sscanf((char const   */* __restrict  */)(& line[n - 4]), (char const   */* __restrict  */)"%4hx",
               & mh.m_flags);
        }
      }
    }
  }
  {
#line 73
  transname(mh.m_name, trname, n);
#line 74
  define_name(trname);
#line 75
  do_o_forks();
  }
#line 76
  if (listmode) {
#line 77
    if (! compressed) {
      {
#line 78
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is in \"hex\" format.\n");
      }
    } else {
      {
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is in \"hcx\" format.\n");
      }
    }
  }
  {
#line 83
  print_header0(0);
#line 84
  print_header1(0, 0);
#line 85
  info[1] = (char )n;
#line 86
  strncpy((char */* __restrict  */)((info + 1) + 1), (char const   */* __restrict  */)(mh.m_name),
          (size_t )n);
#line 87
  strncpy((char */* __restrict  */)(info + 65), (char const   */* __restrict  */)(mh.m_type),
          (size_t )4);
#line 88
  strncpy((char */* __restrict  */)(info + 69), (char const   */* __restrict  */)(mh.m_author),
          (size_t )4);
#line 89
  put2(info + 73, (unsigned long )mh.m_flags);
#line 90
  put4(info + 83, (unsigned long )mh.m_datalen);
#line 91
  put4(info + 87, (unsigned long )mh.m_rsrclen);
#line 92
  put4(info + 91, (unsigned long )mh.m_createtime);
#line 93
  put4(info + 95, (unsigned long )mh.m_modifytime);
#line 94
  print_header2(0);
#line 95
  end_put();
  }
#line 96
  return;
}
}
#line 107
int readline(void) ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static void do_o_forks(void) 
{ 
  int forks ;
  int found_crc ;
  unsigned long calc_crc___0 ;
  unsigned long file_crc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 100
  forks = 0;
#line 100
  found_crc = 0;
#line 103
  crc = 0UL;
#line 105
  set_put(0);
#line 106
  set_put(1);
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! found_crc) {
      {
#line 107
      tmp___4 = readline();
      }
#line 107
      if (! tmp___4) {
#line 107
        goto while_break;
      }
    } else {
#line 107
      goto while_break;
    }
#line 108
    if ((int )line[0] == 0) {
#line 109
      goto while_continue;
    }
#line 111
    if (forks == 0) {
      {
#line 111
      tmp = strncmp((char const   *)(line), "***COMPRESSED", (size_t )13);
      }
#line 111
      if (tmp == 0) {
#line 112
        compressed ++;
#line 113
        goto while_continue;
      }
    }
    {
#line 115
    tmp___0 = strncmp((char const   *)(line), "***DATA", (size_t )7);
    }
#line 115
    if (tmp___0 == 0) {
      {
#line 116
      set_put(1);
#line 117
      mh.m_datalen = make_file(compressed);
#line 118
      forks ++;
      }
#line 119
      goto while_continue;
    }
    {
#line 121
    tmp___1 = strncmp((char const   *)(line), "***RESOURCE", (size_t )11);
    }
#line 121
    if (tmp___1 == 0) {
      {
#line 122
      set_put(0);
#line 123
      mh.m_rsrclen = make_file(compressed);
#line 124
      forks ++;
      }
#line 125
      goto while_continue;
    }
#line 127
    if (compressed) {
      {
#line 127
      tmp___2 = strncmp((char const   *)(line), "***CRC:", (size_t )7);
      }
#line 127
      if (tmp___2 == 0) {
        {
#line 128
        found_crc ++;
#line 129
        calc_crc___0 = crc;
#line 130
        sscanf((char const   */* __restrict  */)(& line[7]), (char const   */* __restrict  */)"%lx",
               & file_crc___0);
        }
#line 131
        goto while_break;
      }
    }
#line 133
    if (! compressed) {
      {
#line 133
      tmp___3 = strncmp((char const   *)(line), "***CHECKSUM:", (size_t )12);
      }
#line 133
      if (tmp___3 == 0) {
        {
#line 134
        found_crc ++;
#line 135
        calc_crc___0 = crc & 255UL;
#line 136
        sscanf((char const   */* __restrict  */)(& line[12]), (char const   */* __restrict  */)"%lx",
               & file_crc___0);
#line 137
        file_crc___0 &= 255UL;
        }
#line 138
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (found_crc) {
    {
#line 143
    verify_crc(calc_crc___0, file_crc___0);
    }
  } else {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing CRC\n");
#line 149
    exit(1);
    }
  }
#line 151
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static long make_file(int compressed___0 ) 
{ 
  register long nbytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 156
  nbytes = 0L;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 158
    tmp___2 = readline();
    }
#line 158
    if (! tmp___2) {
#line 158
      goto while_break;
    }
#line 159
    if ((int )line[0] == 0) {
#line 160
      goto while_continue;
    }
    {
#line 162
    tmp = strncmp((char const   *)(line), "***END", (size_t )6);
    }
#line 162
    if (tmp == 0) {
#line 163
      goto while_break;
    }
#line 165
    if (compressed___0) {
      {
#line 166
      tmp___0 = comp_to_bin();
#line 166
      nbytes += (long )tmp___0;
      }
    } else {
      {
#line 168
      tmp___1 = hex_to_bin();
#line 168
      nbytes += (long )tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (nbytes);
}
}
#line 174 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static void comp_c_crc(unsigned char c ) 
{ 


  {
#line 177
  crc = (crc + (unsigned long )c) & 65535UL;
#line 178
  crc = ((crc << 3) & 65535UL) | (crc >> 13);
#line 179
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static void comp_e_crc(unsigned char c ) 
{ 


  {
#line 184
  crc += (unsigned long )c;
#line 185
  return;
}
}
#line 189 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static int comp_to_bin(void) 
{ 
  char obuf___0[8192] ;
  register char *ip ;
  register char *op___0 ;
  register int n ;
  register int outcount ;
  int numread ;
  int incount ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 192
  ip = line;
#line 193
  op___0 = obuf___0;
#line 197
  tmp = strlen((char const   *)(line));
#line 197
  numread = (int )tmp;
#line 198
  outcount = ((((int )*(ip + 0) - 32) & 63) << 2) | ((((int )*(ip + 1) - 32) & 63) >> 4);
#line 199
  incount = (outcount / 3 + 1) * 4;
#line 200
  n = numread;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (n < incount)) {
#line 200
      goto while_break;
    }
#line 201
    line[n] = (char )' ';
#line 200
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  n = 0;
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 205
    if (! (n <= outcount)) {
#line 205
      goto while_break___0;
    }
#line 206
    tmp___0 = op___0;
#line 206
    op___0 ++;
#line 206
    *tmp___0 = (char )(((((int )*(ip + 0) - 32) & 63) << 2) | ((((int )*(ip + 1) - 32) & 63) >> 4));
#line 207
    tmp___1 = op___0;
#line 207
    op___0 ++;
#line 207
    *tmp___1 = (char )(((((int )*(ip + 1) - 32) & 63) << 4) | ((((int )*(ip + 2) - 32) & 63) >> 2));
#line 208
    tmp___2 = op___0;
#line 208
    op___0 ++;
#line 208
    *tmp___2 = (char )(((((int )*(ip + 2) - 32) & 63) << 6) | (((int )*(ip + 3) - 32) & 63));
#line 209
    ip += 4;
#line 210
    n += 3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 213
  n = 1;
  {
#line 213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 213
    if (! (n <= outcount)) {
#line 213
      goto while_break___1;
    }
    {
#line 214
    comp_c_crc((unsigned char )((unsigned int )obuf___0[n]));
#line 215
    put_byte((int )obuf___0[n]);
#line 213
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 217
  return (outcount);
}
}
#line 220 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static int hex_to_bin(void) 
{ 
  register char *ip ;
  register int n ;
  register int outcount ;
  int c ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 222
  ip = line;
#line 226
  tmp = strlen((char const   *)(line));
#line 226
  n = (int )tmp;
#line 227
  outcount = n / 2;
#line 228
  n = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (n < outcount)) {
#line 228
      goto while_break;
    }
    {
#line 229
    tmp___0 = ip;
#line 229
    ip ++;
#line 229
    c = hexit((int )*tmp___0);
#line 230
    tmp___1 = ip;
#line 230
    ip ++;
#line 230
    tmp___2 = hexit((int )*tmp___1);
#line 230
    c = (c << 4) | tmp___2;
#line 230
    comp_e_crc((unsigned char )((unsigned int )c));
#line 231
    put_byte((int )((char )c));
#line 228
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (outcount);
}
}
#line 236 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hecx.c"
static int hexit(int c ) 
{ 


  {
#line 239
  if (48 <= c) {
#line 239
    if (c <= 57) {
#line 240
      return (c - 48);
    }
  }
#line 242
  if (65 <= c) {
#line 242
    if (c <= 70) {
#line 243
      return ((c - 65) + 10);
    }
  }
  {
#line 246
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"illegal hex digit: %c",
          c);
#line 250
  exit(1);
  }
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
unsigned long ccitt_crcinit  =    65535UL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
static unsigned short crctab[256]  = 
#line 3
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
unsigned long ccitt_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 45
  crc___0 = icrc;
#line 46
  cp = icp___0;
#line 47
  cnt = icnt;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp___0 = cnt;
#line 49
    cnt --;
#line 49
    if (! tmp___0) {
#line 49
      goto while_break;
    }
#line 50
    tmp = cp;
#line 50
    cp ++;
#line 50
    crc___0 = ((crc___0 << 8) & 65280UL) ^ (unsigned long )crctab[((crc___0 >> 8) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (crc___0);
}
}
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 86 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
void transname(char *name , char *namebuf , int n ) 
{ 
  char *np ;

  {
#line 93
  if (n > 253) {
#line 94
    n = 253;
  }
  {
#line 96
  strncpy(namebuf, name, n);
#line 97
  *(namebuf + n) = (char )'\000';
#line 100
  np = namebuf;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! *np) {
#line 100
      goto while_break;
    }
#line 101
    *np = char_mapping[(int )*np & 255];
#line 100
    np ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((int )*namebuf == 46) {
#line 105
    *namebuf = (char )'_';
  }
#line 108
  return;
}
}
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 30 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int verbose ;
#line 32
int uneven_lines ;
#line 36
FILE *ifp ;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.h"
unsigned long binhex_crcinit ;
#line 7
void comp_q_crc(unsigned int c ) ;
#line 8
void comp_q_crc_n(unsigned char *s , unsigned char *e ) ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static void get_header(void) ;
#line 15
static void oflush(void) ;
#line 16
static int getq(void) ;
#line 17
static long get2q(void) ;
#line 18
static long get4q(void) ;
#line 19
static int getqbuf(char *buf___0 , int n ) ;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static char *g_macname  ;
#line 31 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static char lookup[256]  = 
#line 31
  {      (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)126,      (char)125, 
        (char)125,      (char)126,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)0,      (char)1,      (char)2, 
        (char)3,      (char)4,      (char)5,      (char)6, 
        (char)7,      (char)8,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)125,      (char)125, 
        (char)13,      (char)14,      (char)15,      (char)16, 
        (char)17,      (char)18,      (char)19,      (char)125, 
        (char)20,      (char)21,      (char)127,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)22,      (char)23,      (char)24,      (char)25, 
        (char)26,      (char)27,      (char)28,      (char)29, 
        (char)30,      (char)31,      (char)32,      (char)33, 
        (char)34,      (char)35,      (char)36,      (char)125, 
        (char)37,      (char)38,      (char)39,      (char)40, 
        (char)41,      (char)42,      (char)43,      (char)125, 
        (char)44,      (char)45,      (char)46,      (char)47, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)48,      (char)49,      (char)50,      (char)51, 
        (char)52,      (char)53,      (char)54,      (char)125, 
        (char)55,      (char)56,      (char)57,      (char)58, 
        (char)59,      (char)60,      (char)125,      (char)125, 
        (char)61,      (char)62,      (char)63,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125, 
        (char)125,      (char)125,      (char)125,      (char)125};
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static int stop  =    0;
#line 84 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static unsigned char obuf[8192]  ;
#line 85 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static unsigned char *op  =    obuf;
#line 86 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static unsigned char *oq  ;
#line 99 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static int ostate  =    0;
#line 101 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static unsigned long calc_crc  ;
#line 102 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static unsigned long file_crc  ;
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static long todo  ;
#line 108 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
void hqx(char *macname ) 
{ 
  int n ;
  int normlen ;
  int c ;
  register char *in ;
  register char *out ;
  register int b6 ;
  register int b8 ;
  register int data ;
  register int lastc ;
  char state68 ;
  char run ;
  char linestate ;
  char first ;
  size_t tmp ;
  int tmp___0 ;
  char tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;

  {
#line 113
  lastc = 0;
#line 114
  state68 = (char)0;
#line 114
  run = (char)0;
#line 114
  first = (char)1;
#line 116
  g_macname = macname;
#line 118
  ostate = 0;
#line 119
  stop = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (! stop)) {
#line 121
      goto while_break;
    }
    {
#line 122
    tmp = strlen((char const   *)(line));
#line 122
    n = (int )tmp;
    }
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 123
      if (n > 0) {
#line 123
        if (! ((int )line[n - 1] == 32)) {
#line 123
          goto while_break___0;
        }
      } else {
#line 123
        goto while_break___0;
      }
#line 124
      n --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    out = line + n;
#line 127
    if (uneven_lines) {
#line 128
      goto skipcheck;
    }
#line 130
    if (first) {
#line 131
      normlen = n;
    }
#line 134
    linestate = (char)126;
#line 135
    in = line;
    {
#line 135
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )in < (unsigned long )out)) {
#line 135
        goto while_break___1;
      }
#line 136
      linestate = lookup[(int )*in & 255];
#line 136
      if ((int )linestate == 125) {
#line 138
        goto while_break___1;
      } else
#line 136
      if ((int )linestate == 127) {
#line 136
        if (! first) {
#line 138
          goto while_break___1;
        }
      }
#line 135
      in ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    if ((int )linestate != 125) {
#line 141
      if (n != normlen) {
#line 141
        if ((int )linestate != 127) {
          {
#line 142
          c = fgetc(ifp);
#line 143
          ungetc(c, ifp);
          }
#line 144
          if ((int )lookup[c] == 127) {
#line 145
            linestate = (char)127;
          }
        }
      }
    }
#line 148
    if ((int )linestate == 125) {
#line 148
      goto _L;
    } else
#line 148
    if (n != normlen) {
#line 148
      if ((int )linestate != 127) {
        _L: /* CIL Label */ 
#line 149
        if (verbose) {
#line 149
          if (n > 0) {
            {
#line 150
            *out = (char)0;
#line 151
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skip:%s\n",
                    line);
            }
          }
        }
        {
#line 153
        tmp___0 = readline();
        }
#line 153
        if (tmp___0) {
#line 154
          goto while_continue;
        } else {
#line 156
          goto while_break;
        }
      }
    }
    skipcheck: 
#line 160
    in = line;
    {
#line 161
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 162
      b6 = (int )lookup[(int )*in & 255];
#line 162
      if (b6 >= 64) {
        {
#line 164
        if (b6 == 127) {
#line 164
          goto case_127;
        }
#line 169
        if (b6 == 126) {
#line 169
          goto case_126;
        }
#line 171
        goto switch_default;
        case_127: /* CIL Label */ 
#line 165
        first = (char )(! first);
#line 166
        if (first) {
#line 167
          goto done;
        }
        case_126: /* CIL Label */ 
#line 170
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 172
        if (uneven_lines) {
#line 173
          goto switch_break;
        }
        {
#line 175
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad char \'%c\'(%d)\n",
                (int )*in, (int )*in);
        }
#line 176
        goto done;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 180
        tmp___1 = state68;
#line 180
        state68 = (char )((int )state68 + 1);
        {
#line 181
        if ((int )tmp___1 == 0) {
#line 181
          goto case_0;
        }
#line 184
        if ((int )tmp___1 == 1) {
#line 184
          goto case_1;
        }
#line 188
        if ((int )tmp___1 == 2) {
#line 188
          goto case_2;
        }
#line 192
        if ((int )tmp___1 == 3) {
#line 192
          goto case_3;
        }
#line 180
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 182
        b8 = b6 << 2;
#line 183
        goto __Cont;
        case_1: /* CIL Label */ 
#line 185
        data = b8 | (b6 >> 4);
#line 186
        b8 = (b6 & 15) << 4;
#line 187
        goto switch_break___0;
        case_2: /* CIL Label */ 
#line 189
        data = b8 | (b6 >> 2);
#line 190
        b8 = (b6 & 3) << 6;
#line 191
        goto switch_break___0;
        case_3: /* CIL Label */ 
#line 193
        data = b8 | b6;
#line 194
        state68 = (char)0;
#line 195
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 197
        if (! run) {
#line 198
          if (data == 144) {
#line 199
            run = (char)1;
          } else {
#line 201
            tmp___2 = op;
#line 201
            op ++;
#line 201
            lastc = data;
#line 201
            *tmp___2 = (unsigned char )lastc;
#line 201
            if ((unsigned long )op >= (unsigned long )(& obuf[8192])) {
              {
#line 201
              oflush();
              }
            }
          }
        } else {
#line 205
          if (data == 0) {
#line 206
            tmp___3 = op;
#line 206
            op ++;
#line 206
            lastc = 144;
#line 206
            *tmp___3 = (unsigned char )lastc;
#line 206
            if ((unsigned long )op >= (unsigned long )(& obuf[8192])) {
              {
#line 206
              oflush();
              }
            }
          } else {
            {
#line 208
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 208
              data --;
#line 208
              if (! (data > 0)) {
#line 208
                goto while_break___3;
              }
#line 209
              tmp___4 = op;
#line 209
              op ++;
#line 209
              *tmp___4 = (unsigned char )lastc;
#line 209
              if ((unsigned long )op >= (unsigned long )(& obuf[8192])) {
                {
#line 209
                oflush();
                }
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 212
          run = (char)0;
        }
      }
      __Cont: /* CIL Label */ 
#line 161
      in ++;
#line 161
      if (! ((unsigned long )in < (unsigned long )out)) {
#line 161
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 216
    if (! stop) {
      {
#line 217
      tmp___5 = readline();
      }
#line 217
      if (! tmp___5) {
#line 218
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 223
  oflush();
  }
#line 224
  if (! stop) {
#line 224
    if (ostate != 9) {
      {
#line 225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"premature EOF\n");
#line 229
      exit(1);
      }
    }
  }
  {
#line 231
  end_put();
#line 232
  print_header2(verbose);
  }
#line 233
  return;
}
}
#line 235 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static void get_header(void) 
{ 
  int n ;
  unsigned long calc_crc___0 ;
  unsigned long file_crc___0 ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 240
  crc = binhex_crcinit;
#line 242
  n = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (n < 128)) {
#line 242
      goto while_break;
    }
#line 243
    info[n] = (char)0;
#line 242
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 245
  n = getq();
#line 246
  n ++;
#line 247
  getqbuf(trname, n);
  }
#line 248
  if ((int )*(g_macname + 0) == 0) {
#line 249
    g_macname = trname;
  }
  {
#line 252
  tmp = strlen((char const   *)g_macname);
#line 252
  n = (int )tmp;
  }
#line 253
  if (n > 63) {
#line 254
    n = 63;
  }
  {
#line 256
  strncpy((char */* __restrict  */)(mh.m_name), (char const   */* __restrict  */)g_macname,
          (size_t )n);
#line 257
  mh.m_name[n] = (char )'\000';
#line 259
  getqbuf(mh.m_type, 4);
#line 260
  getqbuf(mh.m_author, 4);
#line 261
  tmp___0 = get2q();
#line 261
  mh.m_flags = (short )tmp___0;
#line 262
  mh.m_datalen = get4q();
#line 263
  mh.m_rsrclen = get4q();
#line 265
  calc_crc___0 = crc;
#line 266
  tmp___1 = get2q();
#line 266
  file_crc___0 = (unsigned long )tmp___1;
#line 267
  verify_crc(calc_crc___0, file_crc___0);
  }
#line 268
  if (listmode) {
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is in \"hqx\" format.\n");
    }
  }
  {
#line 271
  transname(mh.m_name, trname, n);
#line 272
  define_name(trname);
#line 273
  print_header0(0);
#line 274
  print_header1(0, verbose);
#line 275
  info[1] = (char )n;
#line 276
  strncpy((char */* __restrict  */)((info + 1) + 1), (char const   */* __restrict  */)(mh.m_name),
          (size_t )n);
#line 277
  strncpy((char */* __restrict  */)(info + 65), (char const   */* __restrict  */)(mh.m_type),
          (size_t )4);
#line 278
  strncpy((char */* __restrict  */)(info + 69), (char const   */* __restrict  */)(mh.m_author),
          (size_t )4);
#line 279
  put2(info + 73, (unsigned long )mh.m_flags);
#line 280
  put4(info + 83, (unsigned long )mh.m_datalen);
#line 281
  put4(info + 87, (unsigned long )mh.m_rsrclen);
#line 282
  put4(info + 91, (unsigned long )mh.m_createtime);
#line 283
  put4(info + 95, (unsigned long )mh.m_modifytime);
  }
#line 284
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static void oflush(void) 
{ 
  int n ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 290
  oq = obuf;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if ((unsigned long )oq < (unsigned long )op) {
#line 291
      if (! (! stop)) {
#line 291
        goto while_break;
      }
    } else {
#line 291
      goto while_break;
    }
    {
#line 293
    if (ostate == 0) {
#line 293
      goto case_0;
    }
#line 297
    if (ostate == 1) {
#line 297
      goto case_1;
    }
#line 303
    if (ostate == 5) {
#line 303
      goto case_5;
    }
#line 310
    if (ostate == 6) {
#line 310
      goto case_6;
    }
#line 310
    if (ostate == 2) {
#line 310
      goto case_6;
    }
#line 326
    if (ostate == 7) {
#line 326
      goto case_7;
    }
#line 326
    if (ostate == 3) {
#line 326
      goto case_7;
    }
#line 332
    if (ostate == 8) {
#line 332
      goto case_8;
    }
#line 332
    if (ostate == 4) {
#line 332
      goto case_8;
    }
#line 338
    if (ostate == 9) {
#line 338
      goto case_9;
    }
#line 292
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 294
    get_header();
#line 295
    ostate ++;
    }
#line 296
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 298
    set_put(1);
#line 299
    todo = mh.m_datalen;
#line 300
    crc = binhex_crcinit;
#line 301
    ostate ++;
    }
#line 302
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 304
    set_put(0);
#line 305
    todo = mh.m_rsrclen;
#line 306
    crc = binhex_crcinit;
#line 307
    ostate ++;
    }
#line 308
    goto switch_break;
    case_6: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 311
    n = (int )(op - oq);
#line 312
    if ((long )n > todo) {
#line 313
      n = (int )todo;
    }
#line 315
    i = 0;
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (i < n)) {
#line 315
        goto while_break___0;
      }
      {
#line 316
      put_byte((int )((char )*(oq + i)));
#line 315
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 318
    comp_q_crc_n(oq, oq + n);
#line 319
    oq += n;
#line 320
    todo -= (long )n;
    }
#line 321
    if (todo <= 0L) {
#line 322
      ostate ++;
    }
#line 324
    goto switch_break;
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 327
    calc_crc = crc;
#line 328
    tmp = getq();
#line 328
    file_crc = (unsigned long )(tmp << 8);
#line 329
    ostate ++;
    }
#line 330
    goto switch_break;
    case_8: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 334
    tmp___0 = getq();
#line 334
    file_crc |= (unsigned long )tmp___0;
#line 335
    verify_crc(calc_crc, file_crc);
#line 336
    ostate ++;
    }
#line 337
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d excess bytes ignored\n",
            op - oq);
#line 340
    oq = op;
    }
#line 341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  op = obuf;
#line 345
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static int getq(void) 
{ 
  int c ;
  unsigned char *tmp ;

  {
#line 351
  if ((unsigned long )oq >= (unsigned long )op) {
    {
#line 352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"premature EOF\n");
#line 356
    exit(1);
    }
  }
  {
#line 358
  tmp = oq;
#line 358
  oq ++;
#line 358
  c = (int )*tmp & 255;
#line 359
  comp_q_crc((unsigned int )c);
  }
#line 360
  return (c);
}
}
#line 364 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static long get2q(void) 
{ 
  short high ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 366
  tmp = getq();
#line 366
  high = (short )(tmp << 8);
#line 367
  tmp___0 = getq();
  }
#line 367
  return ((long )((int )high | tmp___0));
}
}
#line 371 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static long get4q(void) 
{ 
  int i ;
  long value ;
  int tmp ;

  {
#line 374
  value = 0L;
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < 4)) {
#line 376
      goto while_break;
    }
    {
#line 377
    tmp = getq();
#line 377
    value = (value << 8) | (long )tmp;
#line 376
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (value);
}
}
#line 383 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hqx.c"
static int getqbuf(char *buf___0 , int n ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 389
  i = 0;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < n)) {
#line 389
      goto while_break;
    }
    {
#line 390
    tmp = buf___0;
#line 390
    buf___0 ++;
#line 390
    tmp___0 = getq();
#line 390
    *tmp = (char )tmp___0;
#line 389
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return (0);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.h"
unsigned long get4(char *bp ) ;
#line 11
unsigned long get4i(char *bp ) ;
#line 12
unsigned long get2(char *bp ) ;
#line 13
unsigned long get2i(char *bp ) ;
#line 14
unsigned char getb(FILE *fp ) ;
#line 15
void copy(char *d , char *s , int n ) ;
#line 16
int do_query(void) ;
#line 19
void do_indent(int indent___0 ) ;
#line 20
real_time set_time(int year , int month , int day , int hours , int minutes , int seconds ) ;
#line 21
unsigned long tomactime(real_time time___0 ) ;
#line 22
real_time frommactime(unsigned long accum ) ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned long get4(char *bp ) 
{ 
  register int i ;
  long value ;

  {
#line 16
  value = 0L;
#line 18
  i = 0;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i < 4)) {
#line 18
      goto while_break;
    }
#line 19
    value <<= 8;
#line 20
    value |= (long )((int )*bp & 255);
#line 21
    bp ++;
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return ((unsigned long )value);
}
}
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned long get4i(char *bp ) 
{ 
  register int i ;
  long value ;

  {
#line 31
  value = 0L;
#line 33
  bp += 3;
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < 4)) {
#line 34
      goto while_break;
    }
#line 35
    value <<= 8;
#line 36
    value |= (long )((int )*bp & 255);
#line 37
    bp --;
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  return ((unsigned long )value);
}
}
#line 42 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned long get2(char *bp ) 
{ 
  register int i ;
  int value ;

  {
#line 46
  value = 0;
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < 2)) {
#line 48
      goto while_break;
    }
#line 49
    value <<= 8;
#line 50
    value |= (int )*bp & 255;
#line 51
    bp ++;
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((unsigned long )value);
}
}
#line 57 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned long get2i(char *bp ) 
{ 
  register int i ;
  long value ;

  {
#line 61
  value = 0L;
#line 63
  bp ++;
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 2)) {
#line 64
      goto while_break;
    }
#line 65
    value <<= 8;
#line 66
    value |= (long )((int )*bp & 255);
#line 67
    bp --;
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned long )value);
}
}
#line 72 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned char getb(FILE *fp ) 
{ 
  int c ;

  {
  {
#line 77
  bytes_read ++;
#line 78
  c = _IO_getc(fp);
  }
#line 79
  if (c == -1) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nPremature EOF\n");
#line 81
    exit(1);
    }
  }
#line 83
  return ((unsigned char )(c & 255));
}
}
#line 86 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
void copy(char *d , char *s , int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    n --;
#line 90
    if (! (n >= 0)) {
#line 90
      goto while_break;
    }
#line 91
    tmp = d;
#line 91
    d ++;
#line 91
    tmp___0 = s;
#line 91
    s ++;
#line 91
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 101
extern int ( /* missing proto */  read)() ;
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
int do_query(void) 
{ 
  char *tp ;
  char temp[10] ;

  {
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? ");
#line 100
  fflush(stdout);
#line 101
  read(2, temp, sizeof(temp));
#line 102
  temp[sizeof(temp) - 1UL] = (char)0;
#line 103
  tp = temp;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((int )*tp != 0)) {
#line 104
      goto while_break;
    }
#line 105
    if ((int )*tp == 121) {
#line 106
      return (1);
    } else
#line 105
    if ((int )*tp == 89) {
#line 106
      return (1);
    } else {
#line 108
      tp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (0);
}
}
#line 114 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
void put4(char *dest , unsigned long value ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 118
  tmp = dest;
#line 118
  dest ++;
#line 118
  *tmp = (char )((value >> 24) & 255UL);
#line 119
  tmp___0 = dest;
#line 119
  dest ++;
#line 119
  *tmp___0 = (char )((value >> 16) & 255UL);
#line 120
  tmp___1 = dest;
#line 120
  dest ++;
#line 120
  *tmp___1 = (char )((value >> 8) & 255UL);
#line 121
  tmp___2 = dest;
#line 121
  dest ++;
#line 121
  *tmp___2 = (char )(value & 255UL);
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
void put2(char *dest , unsigned long value ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 128
  tmp = dest;
#line 128
  dest ++;
#line 128
  *tmp = (char )((value >> 8) & 255UL);
#line 129
  tmp___0 = dest;
#line 129
  dest ++;
#line 129
  *tmp___0 = (char )(value & 255UL);
#line 130
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
void do_indent(int indent___0 ) 
{ 
  int i ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < indent___0)) {
#line 137
      goto while_break;
    }
    {
#line 138
    fputc(' ', stderr);
#line 137
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
real_time set_time(int year , int month , int day , int hours , int minutes , int seconds ) 
{ 
  real_time toset ;

  {
#line 147
  toset.year = year;
#line 148
  toset.month = month;
#line 149
  toset.day = day;
#line 150
  toset.hours = hours;
#line 151
  toset.minutes = minutes;
#line 152
  toset.seconds = seconds;
#line 153
  return (toset);
}
}
#line 156 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
unsigned long tomactime(real_time time___0 ) 
{ 
  long accum ;
  int year ;

  {
#line 162
  accum = (long )(time___0.month - 3);
#line 163
  year = time___0.year;
#line 164
  if (accum < 0L) {
#line 165
    accum += 12L;
#line 166
    year --;
  }
#line 168
  accum = (long )((time___0.day + mlength[accum]) + 59);
#line 169
  accum += (long )(((year - 1904) * 365 + year / 4) - 476);
#line 170
  accum = ((accum * 24L + (long )time___0.hours) * 60L + (long )time___0.minutes) * 60L + (long )time___0.seconds;
#line 171
  return ((unsigned long )((unsigned int )accum));
}
}
#line 174 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
real_time frommactime(unsigned long accum ) 
{ 
  long tmp1 ;
  long tmp2 ;
  real_time time___0 ;

  {
#line 180
  tmp1 = (long )(accum % 60UL);
#line 180
  time___0.seconds = (int )tmp1;
#line 181
  accum /= 60UL;
#line 182
  tmp1 = (long )(accum % 60UL);
#line 182
  time___0.minutes = (int )tmp1;
#line 183
  accum /= 60UL;
#line 184
  tmp1 = (long )(accum % 24UL);
#line 184
  time___0.hours = (int )tmp1;
#line 185
  accum /= 24UL;
#line 186
  tmp1 = (long )accum - 60L;
#line 187
  tmp2 = tmp1 % 1461L;
#line 188
  if (tmp2 < 0L) {
#line 189
    tmp2 += 1461L;
  }
#line 191
  tmp1 = (tmp1 - tmp2) / 1461L;
#line 192
  time___0.year = (int )(tmp1 * 4L);
#line 193
  tmp1 = tmp2 / 365L;
#line 194
  if (tmp1 > 3L) {
#line 195
    tmp1 = 3L;
  }
#line 197
  time___0.year = (int )((long )time___0.year + (tmp1 + 1904L));
#line 198
  tmp2 -= tmp1 * 365L;
#line 199
  tmp1 = 12L;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    tmp1 --;
#line 200
    if (! ((long )mlength[tmp1] > tmp2)) {
#line 200
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  time___0.day = (int )((tmp2 + 1L) - (long )mlength[tmp1]);
#line 202
  time___0.month = (int )(tmp1 + 3L);
#line 203
  if (tmp1 > 9L) {
#line 204
    time___0.month = (int )(tmp1 - 9L);
#line 205
    (time___0.year) ++;
  }
#line 207
  return (time___0);
}
}
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
static char char_mapping___0[256]  = 
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'/', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'_',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char)127, 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 57 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
void backtrans(char *macname , char *name ) 
{ 
  char *in ;
  char *out ;
  int c ;
  int count ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 61
  count = 0;
#line 63
  out = macname;
#line 64
  in = name;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! *in) {
#line 64
      goto while_break;
    }
#line 65
    if (count == 31) {
#line 66
      goto while_break;
    }
#line 68
    if ((int )*in != 92) {
#line 69
      tmp = out;
#line 69
      out ++;
#line 69
      *tmp = char_mapping___0[(int )*in & 255];
#line 70
      count ++;
#line 71
      goto __Cont;
    }
#line 73
    in ++;
#line 74
    if ((int )*in == 0) {
#line 75
      goto while_break;
    }
#line 77
    if ((int )*in < 48) {
#line 78
      tmp___0 = out;
#line 78
      out ++;
#line 78
      *tmp___0 = char_mapping___0[(int )*in & 255];
#line 79
      count ++;
#line 80
      goto __Cont;
    } else
#line 77
    if ((int )*in > 57) {
#line 78
      tmp___0 = out;
#line 78
      out ++;
#line 78
      *tmp___0 = char_mapping___0[(int )*in & 255];
#line 79
      count ++;
#line 80
      goto __Cont;
    }
#line 82
    c = (int )*in - 48;
#line 83
    in ++;
#line 84
    if ((int )*in < 48) {
#line 84
      goto _L;
    } else
#line 84
    if ((int )*in > 57) {
      _L: /* CIL Label */ 
#line 85
      tmp___1 = out;
#line 85
      out ++;
#line 85
      *tmp___1 = (char )c;
#line 86
      count ++;
#line 87
      in --;
#line 88
      goto __Cont;
    }
#line 90
    c = ((c << 3) + (int )*in) - 48;
#line 91
    in ++;
#line 92
    if ((int )*in < 48) {
#line 92
      goto _L___0;
    } else
#line 92
    if ((int )*in > 57) {
      _L___0: /* CIL Label */ 
#line 93
      tmp___2 = out;
#line 93
      out ++;
#line 93
      *tmp___2 = (char )c;
#line 94
      count ++;
#line 95
      in --;
#line 96
      goto __Cont;
    }
#line 98
    c = ((c << 3) + (int )*in) - 48;
#line 99
    tmp___3 = out;
#line 99
    out ++;
#line 99
    *tmp___3 = (char )c;
#line 100
    count ++;
    __Cont: /* CIL Label */ 
#line 64
    in ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  tmp___4 = out;
#line 102
  out ++;
#line 102
  *tmp___4 = (char)0;
#line 103
  return;
}
}
#line 5 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/printhdr.c"
void print_header0(int skip ) 
{ 


  {
#line 8
  if (listmode) {
    {
#line 9
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", ",
            trname);
    }
#line 10
    if (skip) {
      {
#line 11
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 14
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/printhdr.c"
void print_header1(int skip1 , int skip2 ) 
{ 
  char ftype[5] ;
  char fauth[5] ;

  {
  {
#line 22
  transname(mh.m_type, ftype, 4);
#line 23
  transname(mh.m_author, fauth, 4);
  }
#line 24
  if (listmode) {
#line 25
    if (skip1) {
      {
#line 26
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t");
      }
    }
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"type=%4.4s, author=%4.4s, ",
            ftype, fauth);
    }
#line 29
    if (skip2) {
      {
#line 30
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 33
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/printhdr.c"
void print_header2(int skip ) 
{ 


  {
#line 38
  if (listmode) {
#line 39
    if (skip) {
      {
#line 40
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t");
      }
    }
    {
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data=%ld, rsrc=%ld\n",
            mh.m_datalen, mh.m_rsrclen);
    }
  }
#line 45
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
char info[128]  ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
char trname[64]  ;
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
struct macheader mh  ;
#line 29 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int listmode  ;
#line 30 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int verbose  ;
#line 31 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int info_only  ;
#line 32 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int uneven_lines  ;
#line 33 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int to_read  ;
#line 34 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
int was_macbin  ;
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/globals.h"
FILE *ifp  ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
unsigned long binhex_crcinit  =    0UL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
static unsigned short crctab___0[256]  = 
#line 3
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
unsigned long binhex_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 45
  crc___0 = icrc;
#line 46
  cp = icp___0;
#line 47
  cnt = icnt;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp___0 = cnt;
#line 49
    cnt --;
#line 49
    if (! tmp___0) {
#line 49
      goto while_break;
    }
#line 50
    tmp = cp;
#line 50
    cp ++;
#line 50
    crc___0 = ((crc___0 << 8) & 65280UL) ^ (unsigned long )crctab___0[((crc___0 >> 8) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (crc___0);
}
}
#line 2 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
int data_size ;
#line 2
int rsrc_size ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/mu.c"
static void do_mu_fork(void) ;
#line 15
static int mu_comp_to_bin(void) ;
#line 16
static int mu_convert(char *ibuf , char *obuf___0 ) ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/mu.c"
void mu(char *macname ) 
{ 
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 24
  n = 0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (n < 128)) {
#line 24
      goto while_break;
    }
#line 25
    info[n] = (char)0;
#line 24
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  if ((int )*(macname + 0) == 0) {
#line 30
    n = 0;
    {
#line 31
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 31
      if (! ((int )line[n] != 34)) {
#line 31
        goto while_break___0;
      }
#line 32
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 34
    macname = (line + n) + 1;
#line 35
    tmp = strlen((char const   *)(line));
#line 35
    line[tmp - 1UL] = (char)0;
    }
  }
  {
#line 37
  tmp___0 = strlen((char const   *)macname);
#line 37
  n = (int )tmp___0;
  }
#line 38
  if (n > 63) {
#line 39
    n = 63;
  }
  {
#line 41
  strncpy((char */* __restrict  */)(mh.m_name), (char const   */* __restrict  */)macname,
          (size_t )n);
#line 42
  mh.m_name[n] = (char )'\000';
#line 43
  info[1] = (char )n;
#line 44
  strncpy((char */* __restrict  */)((info + 1) + 1), (char const   */* __restrict  */)(mh.m_name),
          (size_t )n);
  }
#line 46
  if (listmode) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is in \"mu\" format.\n");
    }
  }
  {
#line 49
  transname(mh.m_name, trname, n);
#line 50
  define_name(trname);
#line 51
  print_header0(0);
#line 52
  set_put(0);
#line 53
  set_put(1);
#line 54
  do_mu_fork();
#line 55
  mh.m_datalen = (long )data_size;
#line 56
  tmp___1 = readline();
  }
#line 56
  if (! tmp___1) {
    {
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 61
    exit(1);
    }
  }
  {
#line 63
  tmp___2 = strncmp((char const   *)(line), "begin ", (size_t )6);
  }
#line 63
  if (tmp___2) {
    {
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No UU header found.\n");
#line 68
    exit(1);
    }
  }
  {
#line 70
  tmp___5 = strncmp((char const   *)(line + 10), " .rsrc", (size_t )6);
  }
#line 70
  if (tmp___5) {
#line 89
    mh.m_rsrclen = 0L;
  } else {
    {
#line 71
    set_put(0);
#line 72
    do_mu_fork();
#line 73
    mh.m_rsrclen = (long )rsrc_size;
#line 74
    tmp___3 = readline();
    }
#line 74
    if (! tmp___3) {
      {
#line 75
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 79
      exit(1);
      }
    }
    {
#line 81
    tmp___4 = strncmp((char const   *)(line), "begin ", (size_t )6);
    }
#line 81
    if (tmp___4) {
      {
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No UU header found.\n");
#line 86
      exit(1);
      }
    }
  }
  {
#line 91
  tmp___6 = strncmp((char const   *)(line + 10), " .finfo", (size_t )7);
  }
#line 91
  if (tmp___6) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No finder info found.\n");
#line 96
    exit(1);
    }
  }
  {
#line 98
  tmp___7 = readline();
  }
#line 98
  if (! tmp___7) {
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 103
    exit(1);
    }
  }
  {
#line 105
  mu_convert(line, info + 65);
#line 106
  tmp___8 = readline();
  }
#line 106
  if (! tmp___8) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 111
    exit(1);
    }
  }
  {
#line 113
  tmp___9 = mu_convert(line, line);
  }
#line 113
  if (tmp___9) {
    {
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Long finderinfo.\n");
#line 118
    exit(1);
    }
  }
  {
#line 120
  tmp___10 = readline();
  }
#line 120
  if (! tmp___10) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 125
    exit(1);
    }
  }
  {
#line 127
  tmp___11 = strncmp((char const   *)(line), "end", (size_t )3);
  }
#line 127
  if (tmp___11) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"end\" line missing.\n");
#line 132
    exit(1);
    }
  }
  {
#line 135
  strncpy((char */* __restrict  */)(mh.m_type), (char const   */* __restrict  */)(info + 65),
          (size_t )4);
#line 136
  strncpy((char */* __restrict  */)(mh.m_author), (char const   */* __restrict  */)(info + 69),
          (size_t )4);
#line 137
  print_header1(0, 0);
#line 138
  put4(info + 83, (unsigned long )mh.m_datalen);
#line 139
  put4(info + 87, (unsigned long )mh.m_rsrclen);
#line 140
  put4(info + 91, (unsigned long )mh.m_createtime);
#line 141
  put4(info + 95, (unsigned long )mh.m_modifytime);
#line 142
  print_header2(0);
#line 143
  end_put();
  }
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/mu.c"
static void do_mu_fork(void) 
{ 
  long newbytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    tmp___2 = readline();
    }
#line 150
    if (! tmp___2) {
#line 150
      goto while_break;
    }
#line 151
    if ((int )line[0] == 0) {
#line 152
      goto while_continue;
    }
    {
#line 154
    tmp = mu_comp_to_bin();
#line 154
    newbytes = (long )tmp;
    }
#line 155
    if (newbytes != 0L) {
#line 156
      goto while_continue;
    }
    {
#line 158
    tmp___0 = readline();
    }
#line 158
    if (! tmp___0) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 163
      exit(1);
      }
    }
    {
#line 165
    tmp___1 = strncmp((char const   *)(line), "end", (size_t )3);
    }
#line 165
    if (tmp___1) {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"end\" line missing.\n");
#line 170
      exit(1);
      }
    }
#line 172
    return;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 178
  exit(1);
  }
}
}
#line 182 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/mu.c"
static int mu_comp_to_bin(void) 
{ 
  char obuf___0[8192] ;
  int outcount ;
  int n ;

  {
  {
#line 187
  outcount = mu_convert(line, obuf___0);
#line 188
  n = 0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (n < outcount)) {
#line 188
      goto while_break;
    }
    {
#line 189
    put_byte((int )obuf___0[n]);
#line 188
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (outcount);
}
}
#line 196 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/mu.c"
static int mu_convert(char *ibuf , char *obuf___0 ) 
{ 
  register char *ip ;
  register char *op___0 ;
  register int n ;
  register int outcount ;
  int numread ;
  int incount ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 199
  ip = ibuf;
#line 200
  op___0 = obuf___0;
#line 204
  tmp = strlen((char const   *)ip);
#line 204
  numread = (int )tmp;
#line 205
  outcount = ((int )*(ip + 0) - 32) & 63;
#line 206
  incount = (outcount / 3 + 1) * 4;
#line 207
  n = numread;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (n < incount)) {
#line 207
      goto while_break;
    }
#line 208
    *(ip + n) = (char )' ';
#line 207
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  ip ++;
#line 212
  n = 0;
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! (n <= outcount)) {
#line 213
      goto while_break___0;
    }
#line 214
    tmp___0 = op___0;
#line 214
    op___0 ++;
#line 214
    *tmp___0 = (char )(((((int )*(ip + 0) - 32) & 63) << 2) | ((((int )*(ip + 1) - 32) & 63) >> 4));
#line 215
    tmp___1 = op___0;
#line 215
    op___0 ++;
#line 215
    *tmp___1 = (char )(((((int )*(ip + 1) - 32) & 63) << 4) | ((((int )*(ip + 2) - 32) & 63) >> 2));
#line 216
    tmp___2 = op___0;
#line 216
    op___0 ++;
#line 216
    *tmp___2 = (char )(((((int )*(ip + 2) - 32) & 63) << 6) | (((int )*(ip + 3) - 32) & 63));
#line 217
    ip += 4;
#line 218
    n += 3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  return (outcount);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
unsigned long kermit_crcinit  =    0UL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
static unsigned short crctab___1[256]  = 
#line 3
  {      (unsigned short)0,      (unsigned short)4489,      (unsigned short)8978,      (unsigned short)12955, 
        (unsigned short)17956,      (unsigned short)22445,      (unsigned short)25910,      (unsigned short)29887, 
        (unsigned short)35912,      (unsigned short)40385,      (unsigned short)44890,      (unsigned short)48851, 
        (unsigned short)51820,      (unsigned short)56293,      (unsigned short)59774,      (unsigned short)63735, 
        (unsigned short)4225,      (unsigned short)264,      (unsigned short)13203,      (unsigned short)8730, 
        (unsigned short)22181,      (unsigned short)18220,      (unsigned short)30135,      (unsigned short)25662, 
        (unsigned short)40137,      (unsigned short)36160,      (unsigned short)49115,      (unsigned short)44626, 
        (unsigned short)56045,      (unsigned short)52068,      (unsigned short)63999,      (unsigned short)59510, 
        (unsigned short)8450,      (unsigned short)12427,      (unsigned short)528,      (unsigned short)5017, 
        (unsigned short)26406,      (unsigned short)30383,      (unsigned short)17460,      (unsigned short)21949, 
        (unsigned short)44362,      (unsigned short)48323,      (unsigned short)36440,      (unsigned short)40913, 
        (unsigned short)60270,      (unsigned short)64231,      (unsigned short)51324,      (unsigned short)55797, 
        (unsigned short)12675,      (unsigned short)8202,      (unsigned short)4753,      (unsigned short)792, 
        (unsigned short)30631,      (unsigned short)26158,      (unsigned short)21685,      (unsigned short)17724, 
        (unsigned short)48587,      (unsigned short)44098,      (unsigned short)40665,      (unsigned short)36688, 
        (unsigned short)64495,      (unsigned short)60006,      (unsigned short)55549,      (unsigned short)51572, 
        (unsigned short)16900,      (unsigned short)21389,      (unsigned short)24854,      (unsigned short)28831, 
        (unsigned short)1056,      (unsigned short)5545,      (unsigned short)10034,      (unsigned short)14011, 
        (unsigned short)52812,      (unsigned short)57285,      (unsigned short)60766,      (unsigned short)64727, 
        (unsigned short)34920,      (unsigned short)39393,      (unsigned short)43898,      (unsigned short)47859, 
        (unsigned short)21125,      (unsigned short)17164,      (unsigned short)29079,      (unsigned short)24606, 
        (unsigned short)5281,      (unsigned short)1320,      (unsigned short)14259,      (unsigned short)9786, 
        (unsigned short)57037,      (unsigned short)53060,      (unsigned short)64991,      (unsigned short)60502, 
        (unsigned short)39145,      (unsigned short)35168,      (unsigned short)48123,      (unsigned short)43634, 
        (unsigned short)25350,      (unsigned short)29327,      (unsigned short)16404,      (unsigned short)20893, 
        (unsigned short)9506,      (unsigned short)13483,      (unsigned short)1584,      (unsigned short)6073, 
        (unsigned short)61262,      (unsigned short)65223,      (unsigned short)52316,      (unsigned short)56789, 
        (unsigned short)43370,      (unsigned short)47331,      (unsigned short)35448,      (unsigned short)39921, 
        (unsigned short)29575,      (unsigned short)25102,      (unsigned short)20629,      (unsigned short)16668, 
        (unsigned short)13731,      (unsigned short)9258,      (unsigned short)5809,      (unsigned short)1848, 
        (unsigned short)65487,      (unsigned short)60998,      (unsigned short)56541,      (unsigned short)52564, 
        (unsigned short)47595,      (unsigned short)43106,      (unsigned short)39673,      (unsigned short)35696, 
        (unsigned short)33800,      (unsigned short)38273,      (unsigned short)42778,      (unsigned short)46739, 
        (unsigned short)49708,      (unsigned short)54181,      (unsigned short)57662,      (unsigned short)61623, 
        (unsigned short)2112,      (unsigned short)6601,      (unsigned short)11090,      (unsigned short)15067, 
        (unsigned short)20068,      (unsigned short)24557,      (unsigned short)28022,      (unsigned short)31999, 
        (unsigned short)38025,      (unsigned short)34048,      (unsigned short)47003,      (unsigned short)42514, 
        (unsigned short)53933,      (unsigned short)49956,      (unsigned short)61887,      (unsigned short)57398, 
        (unsigned short)6337,      (unsigned short)2376,      (unsigned short)15315,      (unsigned short)10842, 
        (unsigned short)24293,      (unsigned short)20332,      (unsigned short)32247,      (unsigned short)27774, 
        (unsigned short)42250,      (unsigned short)46211,      (unsigned short)34328,      (unsigned short)38801, 
        (unsigned short)58158,      (unsigned short)62119,      (unsigned short)49212,      (unsigned short)53685, 
        (unsigned short)10562,      (unsigned short)14539,      (unsigned short)2640,      (unsigned short)7129, 
        (unsigned short)28518,      (unsigned short)32495,      (unsigned short)19572,      (unsigned short)24061, 
        (unsigned short)46475,      (unsigned short)41986,      (unsigned short)38553,      (unsigned short)34576, 
        (unsigned short)62383,      (unsigned short)57894,      (unsigned short)53437,      (unsigned short)49460, 
        (unsigned short)14787,      (unsigned short)10314,      (unsigned short)6865,      (unsigned short)2904, 
        (unsigned short)32743,      (unsigned short)28270,      (unsigned short)23797,      (unsigned short)19836, 
        (unsigned short)50700,      (unsigned short)55173,      (unsigned short)58654,      (unsigned short)62615, 
        (unsigned short)32808,      (unsigned short)37281,      (unsigned short)41786,      (unsigned short)45747, 
        (unsigned short)19012,      (unsigned short)23501,      (unsigned short)26966,      (unsigned short)30943, 
        (unsigned short)3168,      (unsigned short)7657,      (unsigned short)12146,      (unsigned short)16123, 
        (unsigned short)54925,      (unsigned short)50948,      (unsigned short)62879,      (unsigned short)58390, 
        (unsigned short)37033,      (unsigned short)33056,      (unsigned short)46011,      (unsigned short)41522, 
        (unsigned short)23237,      (unsigned short)19276,      (unsigned short)31191,      (unsigned short)26718, 
        (unsigned short)7393,      (unsigned short)3432,      (unsigned short)16371,      (unsigned short)11898, 
        (unsigned short)59150,      (unsigned short)63111,      (unsigned short)50204,      (unsigned short)54677, 
        (unsigned short)41258,      (unsigned short)45219,      (unsigned short)33336,      (unsigned short)37809, 
        (unsigned short)27462,      (unsigned short)31439,      (unsigned short)18516,      (unsigned short)23005, 
        (unsigned short)11618,      (unsigned short)15595,      (unsigned short)3696,      (unsigned short)8185, 
        (unsigned short)63375,      (unsigned short)58886,      (unsigned short)54429,      (unsigned short)50452, 
        (unsigned short)45483,      (unsigned short)40994,      (unsigned short)37561,      (unsigned short)33584, 
        (unsigned short)31687,      (unsigned short)27214,      (unsigned short)22741,      (unsigned short)18780, 
        (unsigned short)15843,      (unsigned short)11370,      (unsigned short)7921,      (unsigned short)3960};
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
unsigned long kermit_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 45
  crc___0 = icrc;
#line 46
  cp = icp___0;
#line 47
  cnt = icnt;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp___0 = cnt;
#line 49
    cnt --;
#line 49
    if (! tmp___0) {
#line 49
      goto while_break;
    }
#line 50
    tmp = cp;
#line 50
    cp ++;
#line 50
    crc___0 = ((crc___0 >> 8) & 255UL) ^ (unsigned long )crctab___1[(crc___0 & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (crc___0);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
unsigned long arc_crcinit  =    0UL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
static unsigned short crctab___2[256]  = 
#line 3
  {      (unsigned short)0,      (unsigned short)49345,      (unsigned short)49537,      (unsigned short)320, 
        (unsigned short)49921,      (unsigned short)960,      (unsigned short)640,      (unsigned short)49729, 
        (unsigned short)50689,      (unsigned short)1728,      (unsigned short)1920,      (unsigned short)51009, 
        (unsigned short)1280,      (unsigned short)50625,      (unsigned short)50305,      (unsigned short)1088, 
        (unsigned short)52225,      (unsigned short)3264,      (unsigned short)3456,      (unsigned short)52545, 
        (unsigned short)3840,      (unsigned short)53185,      (unsigned short)52865,      (unsigned short)3648, 
        (unsigned short)2560,      (unsigned short)51905,      (unsigned short)52097,      (unsigned short)2880, 
        (unsigned short)51457,      (unsigned short)2496,      (unsigned short)2176,      (unsigned short)51265, 
        (unsigned short)55297,      (unsigned short)6336,      (unsigned short)6528,      (unsigned short)55617, 
        (unsigned short)6912,      (unsigned short)56257,      (unsigned short)55937,      (unsigned short)6720, 
        (unsigned short)7680,      (unsigned short)57025,      (unsigned short)57217,      (unsigned short)8000, 
        (unsigned short)56577,      (unsigned short)7616,      (unsigned short)7296,      (unsigned short)56385, 
        (unsigned short)5120,      (unsigned short)54465,      (unsigned short)54657,      (unsigned short)5440, 
        (unsigned short)55041,      (unsigned short)6080,      (unsigned short)5760,      (unsigned short)54849, 
        (unsigned short)53761,      (unsigned short)4800,      (unsigned short)4992,      (unsigned short)54081, 
        (unsigned short)4352,      (unsigned short)53697,      (unsigned short)53377,      (unsigned short)4160, 
        (unsigned short)61441,      (unsigned short)12480,      (unsigned short)12672,      (unsigned short)61761, 
        (unsigned short)13056,      (unsigned short)62401,      (unsigned short)62081,      (unsigned short)12864, 
        (unsigned short)13824,      (unsigned short)63169,      (unsigned short)63361,      (unsigned short)14144, 
        (unsigned short)62721,      (unsigned short)13760,      (unsigned short)13440,      (unsigned short)62529, 
        (unsigned short)15360,      (unsigned short)64705,      (unsigned short)64897,      (unsigned short)15680, 
        (unsigned short)65281,      (unsigned short)16320,      (unsigned short)16000,      (unsigned short)65089, 
        (unsigned short)64001,      (unsigned short)15040,      (unsigned short)15232,      (unsigned short)64321, 
        (unsigned short)14592,      (unsigned short)63937,      (unsigned short)63617,      (unsigned short)14400, 
        (unsigned short)10240,      (unsigned short)59585,      (unsigned short)59777,      (unsigned short)10560, 
        (unsigned short)60161,      (unsigned short)11200,      (unsigned short)10880,      (unsigned short)59969, 
        (unsigned short)60929,      (unsigned short)11968,      (unsigned short)12160,      (unsigned short)61249, 
        (unsigned short)11520,      (unsigned short)60865,      (unsigned short)60545,      (unsigned short)11328, 
        (unsigned short)58369,      (unsigned short)9408,      (unsigned short)9600,      (unsigned short)58689, 
        (unsigned short)9984,      (unsigned short)59329,      (unsigned short)59009,      (unsigned short)9792, 
        (unsigned short)8704,      (unsigned short)58049,      (unsigned short)58241,      (unsigned short)9024, 
        (unsigned short)57601,      (unsigned short)8640,      (unsigned short)8320,      (unsigned short)57409, 
        (unsigned short)40961,      (unsigned short)24768,      (unsigned short)24960,      (unsigned short)41281, 
        (unsigned short)25344,      (unsigned short)41921,      (unsigned short)41601,      (unsigned short)25152, 
        (unsigned short)26112,      (unsigned short)42689,      (unsigned short)42881,      (unsigned short)26432, 
        (unsigned short)42241,      (unsigned short)26048,      (unsigned short)25728,      (unsigned short)42049, 
        (unsigned short)27648,      (unsigned short)44225,      (unsigned short)44417,      (unsigned short)27968, 
        (unsigned short)44801,      (unsigned short)28608,      (unsigned short)28288,      (unsigned short)44609, 
        (unsigned short)43521,      (unsigned short)27328,      (unsigned short)27520,      (unsigned short)43841, 
        (unsigned short)26880,      (unsigned short)43457,      (unsigned short)43137,      (unsigned short)26688, 
        (unsigned short)30720,      (unsigned short)47297,      (unsigned short)47489,      (unsigned short)31040, 
        (unsigned short)47873,      (unsigned short)31680,      (unsigned short)31360,      (unsigned short)47681, 
        (unsigned short)48641,      (unsigned short)32448,      (unsigned short)32640,      (unsigned short)48961, 
        (unsigned short)32000,      (unsigned short)48577,      (unsigned short)48257,      (unsigned short)31808, 
        (unsigned short)46081,      (unsigned short)29888,      (unsigned short)30080,      (unsigned short)46401, 
        (unsigned short)30464,      (unsigned short)47041,      (unsigned short)46721,      (unsigned short)30272, 
        (unsigned short)29184,      (unsigned short)45761,      (unsigned short)45953,      (unsigned short)29504, 
        (unsigned short)45313,      (unsigned short)29120,      (unsigned short)28800,      (unsigned short)45121, 
        (unsigned short)20480,      (unsigned short)37057,      (unsigned short)37249,      (unsigned short)20800, 
        (unsigned short)37633,      (unsigned short)21440,      (unsigned short)21120,      (unsigned short)37441, 
        (unsigned short)38401,      (unsigned short)22208,      (unsigned short)22400,      (unsigned short)38721, 
        (unsigned short)21760,      (unsigned short)38337,      (unsigned short)38017,      (unsigned short)21568, 
        (unsigned short)39937,      (unsigned short)23744,      (unsigned short)23936,      (unsigned short)40257, 
        (unsigned short)24320,      (unsigned short)40897,      (unsigned short)40577,      (unsigned short)24128, 
        (unsigned short)23040,      (unsigned short)39617,      (unsigned short)39809,      (unsigned short)23360, 
        (unsigned short)39169,      (unsigned short)22976,      (unsigned short)22656,      (unsigned short)38977, 
        (unsigned short)34817,      (unsigned short)18624,      (unsigned short)18816,      (unsigned short)35137, 
        (unsigned short)19200,      (unsigned short)35777,      (unsigned short)35457,      (unsigned short)19008, 
        (unsigned short)19968,      (unsigned short)36545,      (unsigned short)36737,      (unsigned short)20288, 
        (unsigned short)36097,      (unsigned short)19904,      (unsigned short)19584,      (unsigned short)35905, 
        (unsigned short)17408,      (unsigned short)33985,      (unsigned short)34177,      (unsigned short)17728, 
        (unsigned short)34561,      (unsigned short)18368,      (unsigned short)18048,      (unsigned short)34369, 
        (unsigned short)33281,      (unsigned short)17088,      (unsigned short)17280,      (unsigned short)33601, 
        (unsigned short)16640,      (unsigned short)33217,      (unsigned short)32897,      (unsigned short)16448};
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
unsigned long arc_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 45
  crc___0 = icrc;
#line 46
  cp = icp___0;
#line 47
  cnt = icnt;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp___0 = cnt;
#line 49
    cnt --;
#line 49
    if (! tmp___0) {
#line 49
      goto while_break;
    }
#line 50
    tmp = cp;
#line 50
    cp ++;
#line 50
    crc___0 = ((crc___0 >> 8) & 255UL) ^ (unsigned long )crctab___2[(crc___0 & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (crc___0);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/readline.h"
char line[1024]  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/readline.c"
int readline(void) 
{ 
  int ptr___3 ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 11
  ptr___3 = 0;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14
    if (was_macbin) {
#line 14
      tmp = to_read;
#line 14
      to_read --;
#line 14
      if (tmp <= 0) {
#line 15
        c = -1;
      } else {
        {
#line 17
        c = _IO_getc(ifp);
        }
      }
    } else {
      {
#line 17
      c = _IO_getc(ifp);
      }
    }
#line 19
    if (c == -1) {
#line 20
      goto while_break;
    } else
#line 19
    if (c == 10) {
#line 20
      goto while_break;
    } else
#line 19
    if (c == 13) {
#line 20
      goto while_break;
    } else
#line 19
    if (ptr___3 == 1023) {
#line 20
      goto while_break;
    }
#line 22
    tmp___0 = ptr___3;
#line 22
    ptr___3 ++;
#line 22
    line[tmp___0] = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  tmp___1 = ptr___3;
#line 24
  ptr___3 ++;
#line 24
  line[tmp___1] = (char)0;
#line 25
  if (c == -1) {
#line 26
    if (ptr___3 == 1) {
#line 27
      return (0);
    } else {
#line 29
      return (1);
    }
  }
  {
#line 32
  c = _IO_getc(ifp);
  }
#line 33
  if (c != 10) {
    {
#line 34
    ungetc(c, ifp);
    }
  } else
#line 33
  if (c != 13) {
    {
#line 34
    ungetc(c, ifp);
    }
  } else {
#line 36
    to_read --;
  }
#line 38
  return (1);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
unsigned long zip_crcinit  =    0xffffffffffffffffUL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
static unsigned long crctab___3[256]  = 
#line 3
  {      0UL,      151466134UL,      302932268UL,      453595578UL, 
        4285383705UL,      4134204559UL,      3982730549UL,      3831797155UL, 
        4275800114UL,      4158437540UL,      3973441822UL,      3855800712UL, 
        28724267UL,      145849533UL,      330837255UL,      448732561UL, 
        4256632932UL,      4105183474UL,      4021907784UL,      3871228382UL, 
        47895677UL,      199091435UL,      282375505UL,      433292743UL, 
        57448534UL,      174827712UL,      291699066UL,      409324012UL, 
        4227947599UL,      4110839001UL,      3993976163UL,      3876064757UL, 
        4218298568UL,      4066971742UL,      3915399652UL,      3764875634UL, 
        67364049UL,      218420295UL,      369985021UL,      520795499UL, 
        95791354UL,      213031020UL,      398182870UL,      515701056UL, 
        4208487651UL,      4091501685UL,      3906342351UL,      3788586329UL, 
        114897068UL,      266207290UL,      349655424UL,      500195606UL, 
        4189385909UL,      4038312995UL,      3954873753UL,      3804079375UL, 
        4160927902UL,      4043671560UL,      3926710706UL,      3809208612UL, 
        124746887UL,      241716241UL,      358686123UL,      476458301UL, 
        4141629840UL,      4292571398UL,      3838976188UL,      3990163498UL, 
        162629001UL,      11973919UL,      465560741UL,      314102835UL, 
        134728098UL,      16841012UL,      436840590UL,      319723544UL, 
        4150922683UL,      4268571949UL,      3848563863UL,      3965934593UL, 
        191582708UL,      40657250UL,      426062040UL,      274858062UL, 
        4094072301UL,      4244743547UL,      3859346625UL,      4010787927UL, 
        4122008006UL,      4239911248UL,      3888036074UL,      4005136508UL, 
        182263263UL,      64630089UL,      416513267UL,      299125861UL, 
        229794136UL,      78991822UL,      532414580UL,      381366498UL, 
        4074743105UL,      4225275351UL,      3771843693UL,      3923178747UL, 
        4083804522UL,      4201568764UL,      3781658694UL,      3898652880UL, 
        201600371UL,      84090341UL,      503991391UL,      386759881UL, 
        4026888508UL,      4177674666UL,      3792375824UL,      3943440518UL, 
        258520357UL,      107972019UL,      493278217UL,      341959839UL, 
        249493774UL,      131713432UL,      483432482UL,      366454964UL, 
        4055055639UL,      4172549505UL,      3820837947UL,      3938086061UL, 
        3988292384UL,      3837768630UL,      4290175500UL,      4138848922UL, 
        315967289UL,      466778031UL,      14362133UL,      165418627UL, 
        325258002UL,      442776452UL,      23947838UL,      141187752UL, 
        3960393483UL,      3842637725UL,      4261457447UL,      4144471729UL, 
        269456196UL,      419996626UL,      33682024UL,      184992510UL, 
        4016199517UL,      3865405387UL,      4251727473UL,      4100654823UL, 
        4006878070UL,      3889376224UL,      4242176602UL,      4124920524UL, 
        297394031UL,      415166457UL,      62373443UL,      179343061UL, 
        383165416UL,      533828478UL,      81314500UL,      232780370UL, 
        3921373169UL,      3770439527UL,      4222944989UL,      4071765579UL, 
        3893177306UL,      3775535948UL,      4194519798UL,      4077156960UL, 
        392228803UL,      510123861UL,      91131631UL,      208256633UL, 
        3949048716UL,      3798369050UL,      4184855200UL,      4033405494UL, 
        336361365UL,      487278339UL,      100800185UL,      251995695UL, 
        364526526UL,      482151208UL,      129260178UL,      246639108UL, 
        3940024231UL,      3822112561UL,      4175011467UL,      4057902621UL, 
        459588272UL,      308539942UL,      157983644UL,      7181066UL, 
        3825796777UL,      3977131583UL,      4127680389UL,      4278212371UL, 
        3854518914UL,      3971512852UL,      4155583406UL,      4273347384UL, 
        450006683UL,      332774925UL,      148697015UL,      31186721UL, 
        3872641748UL,      4023706178UL,      4108170232UL,      4258956142UL, 
        431888077UL,      280569435UL,      196114401UL,      45565815UL, 
        403200742UL,      286222960UL,      168180682UL,      50400092UL, 
        3882196735UL,      3999444585UL,      4117495763UL,      4234989381UL, 
        3758809720UL,      3909997294UL,      4060382036UL,      4211323842UL, 
        526853729UL,      375396087UL,      225003341UL,      74348507UL, 
        517040714UL,      399923932UL,      215944038UL,      98057200UL, 
        3787238995UL,      3904609989UL,      4088582015UL,      4206231529UL, 
        498987548UL,      347783818UL,      263426864UL,      112501670UL, 
        3805296133UL,      3956737683UL,      4041103145UL,      4191774655UL, 
        3815143982UL,      3932244664UL,      4050131714UL,      4168035220UL, 
        470531639UL,      353144481UL,      235265819UL,      117632909UL};
#line 70 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
unsigned long zip_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 77
  crc___0 = icrc;
#line 78
  cp = icp___0;
#line 79
  cnt = icnt;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    tmp___0 = cnt;
#line 81
    cnt --;
#line 81
    if (! tmp___0) {
#line 81
      goto while_break;
    }
#line 82
    tmp = cp;
#line 82
    cp ++;
#line 82
    crc___0 = ((crc___0 >> 8) & 16777215UL) ^ crctab___3[(crc___0 & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (crc___0);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
unsigned long ccitt32_crcinit  =    0xffffffffffffffffUL;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
static unsigned long crctab___4[256]  = 
#line 3
  {      0UL,      79764919UL,      159529838UL,      222504665UL, 
        319059676UL,      398814059UL,      445009330UL,      507990021UL, 
        638119352UL,      583659535UL,      797628118UL,      726387553UL, 
        890018660UL,      835552979UL,      1015980042UL,      944750013UL, 
        1276238704UL,      1221641927UL,      1167319070UL,      1095957929UL, 
        1595256236UL,      1540665371UL,      1452775106UL,      1381403509UL, 
        1780037320UL,      1859660671UL,      1671105958UL,      1733955601UL, 
        2031960084UL,      2111593891UL,      1889500026UL,      1952343757UL, 
        2552477408UL,      2632100695UL,      2443283854UL,      2506133561UL, 
        2334638140UL,      2414271883UL,      2191915858UL,      2254759653UL, 
        3190512472UL,      3135915759UL,      3081330742UL,      3009969537UL, 
        2905550212UL,      2850959411UL,      2762807018UL,      2691435357UL, 
        3560074640UL,      3505614887UL,      3719321342UL,      3648080713UL, 
        3342211916UL,      3287746299UL,      3467911202UL,      3396681109UL, 
        4063920168UL,      4143685023UL,      4223187782UL,      4286162673UL, 
        3779000052UL,      3858754371UL,      3904687514UL,      3967668269UL, 
        881225847UL,      809987520UL,      1023691545UL,      969234094UL, 
        662832811UL,      591600412UL,      771767749UL,      717299826UL, 
        311336399UL,      374308984UL,      453813921UL,      533576470UL, 
        25881363UL,      88864420UL,      134795389UL,      214552010UL, 
        2023205639UL,      2086057648UL,      1897238633UL,      1976864222UL, 
        1804852699UL,      1867694188UL,      1645340341UL,      1724971778UL, 
        1587496639UL,      1516133128UL,      1461550545UL,      1406951526UL, 
        1302016099UL,      1230646740UL,      1142491917UL,      1087903418UL, 
        2896545431UL,      2825181984UL,      2770861561UL,      2716262478UL, 
        3215044683UL,      3143675388UL,      3055782693UL,      3001194130UL, 
        2326604591UL,      2389456536UL,      2200899649UL,      2280525302UL, 
        2578013683UL,      2640855108UL,      2418763421UL,      2498394922UL, 
        3769900519UL,      3832873040UL,      3912640137UL,      3992402750UL, 
        4088425275UL,      4151408268UL,      4197601365UL,      4277358050UL, 
        3334271071UL,      3263032808UL,      3476998961UL,      3422541446UL, 
        3585640067UL,      3514407732UL,      3694837229UL,      3640369242UL, 
        1762451694UL,      1842216281UL,      1619975040UL,      1682949687UL, 
        2047383090UL,      2127137669UL,      1938468188UL,      2001449195UL, 
        1325665622UL,      1271206113UL,      1183200824UL,      1111960463UL, 
        1543535498UL,      1489069629UL,      1434599652UL,      1363369299UL, 
        622672798UL,      568075817UL,      748617968UL,      677256519UL, 
        907627842UL,      853037301UL,      1067152940UL,      995781531UL, 
        51762726UL,      131386257UL,      177728840UL,      240578815UL, 
        269590778UL,      349224269UL,      429104020UL,      491947555UL, 
        4046411278UL,      4126034873UL,      4172115296UL,      4234965207UL, 
        3794477266UL,      3874110821UL,      3953728444UL,      4016571915UL, 
        3609705398UL,      3555108353UL,      3735388376UL,      3664026991UL, 
        3290680682UL,      3236090077UL,      3449943556UL,      3378572211UL, 
        3174993278UL,      3120533705UL,      3032266256UL,      2961025959UL, 
        2923101090UL,      2868635157UL,      2813903052UL,      2742672763UL, 
        2604032198UL,      2683796849UL,      2461293480UL,      2524268063UL, 
        2284983834UL,      2364738477UL,      2175806836UL,      2238787779UL, 
        1569362073UL,      1498123566UL,      1409854455UL,      1355396672UL, 
        1317987909UL,      1246755826UL,      1192025387UL,      1137557660UL, 
        2072149281UL,      2135122070UL,      1912620623UL,      1992383480UL, 
        1753615357UL,      1816598090UL,      1627664531UL,      1707420964UL, 
        295390185UL,      358241886UL,      404320391UL,      483945776UL, 
        43990325UL,      106832002UL,      186451547UL,      266083308UL, 
        932423249UL,      861060070UL,      1041341759UL,      986742920UL, 
        613929101UL,      542559546UL,      756411363UL,      701822548UL, 
        3316196985UL,      3244833742UL,      3425377559UL,      3370778784UL, 
        3601682597UL,      3530312978UL,      3744426955UL,      3689838204UL, 
        3819031489UL,      3881883254UL,      3928223919UL,      4007849240UL, 
        4037393693UL,      4100235434UL,      4180117107UL,      4259748804UL, 
        2310601993UL,      2373574846UL,      2151335527UL,      2231098320UL, 
        2596047829UL,      2659030626UL,      2470359227UL,      2550115596UL, 
        2947551409UL,      2876312838UL,      2788305887UL,      2733848168UL, 
        3165939309UL,      3094707162UL,      3040238851UL,      2985771188UL};
#line 70 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
unsigned long ccitt32_updcrc(unsigned long icrc , unsigned char *icp___0 , int icnt ) 
{ 
  register unsigned long crc___0 ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 77
  crc___0 = icrc;
#line 78
  cp = icp___0;
#line 79
  cnt = icnt;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    tmp___0 = cnt;
#line 81
    cnt --;
#line 81
    if (! tmp___0) {
#line 81
      goto while_break;
    }
#line 82
    tmp = cp;
#line 82
    cp ++;
#line 82
    crc___0 = ((crc___0 << 8) & 4294967040UL) ^ crctab___4[((crc___0 >> 24) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (crc___0);
}
}
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
char *data_fork  ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
char *rsrc_fork  ;
#line 2 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
int data_size  ;
#line 2 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.h"
int rsrc_size  ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../fileio/wrfile.h"
char *out_ptr ;
#line 4
void start_info(char *info___0 , unsigned long rsize , unsigned long dsize ) ;
#line 5
void start_rsrc(void) ;
#line 6
void start_data(void) ;
#line 7
void end_file(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
static int max_data_size  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
static int max_rsrc_size  ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
static int do_data  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
void put_byte(char c ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 15
  if (do_data) {
#line 16
    if (data_size >= max_data_size) {
#line 17
      if (max_data_size == 0) {
        {
#line 18
        tmp = malloc((size_t )1024);
#line 18
        data_fork = (char *)tmp;
        }
      } else {
        {
#line 20
        tmp___0 = realloc((void *)data_fork, (size_t )((unsigned int )max_data_size + 1024U));
#line 20
        data_fork = (char *)tmp___0;
        }
      }
#line 22
      max_data_size += 1024;
#line 23
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 24
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.\n");
#line 25
        exit(1);
        }
      }
    }
#line 28
    tmp___1 = data_size;
#line 28
    data_size ++;
#line 28
    *(data_fork + tmp___1) = c;
  } else {
#line 30
    if (rsrc_size >= max_rsrc_size) {
#line 31
      if (max_rsrc_size == 0) {
        {
#line 32
        tmp___2 = malloc((size_t )1024);
#line 32
        rsrc_fork = (char *)tmp___2;
        }
      } else {
        {
#line 34
        tmp___3 = realloc((void *)rsrc_fork, (size_t )((unsigned int )max_rsrc_size + 1024U));
#line 34
        rsrc_fork = (char *)tmp___3;
        }
      }
#line 36
      max_rsrc_size += 1024;
#line 37
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 38
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.\n");
#line 39
        exit(1);
        }
      }
    }
#line 42
    tmp___4 = rsrc_size;
#line 42
    rsrc_size ++;
#line 42
    *(rsrc_fork + tmp___4) = c;
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
void set_put(int data ) 
{ 


  {
#line 49
  do_data = data;
#line 50
  if (do_data) {
#line 51
    data_size = 0;
  } else {
#line 53
    rsrc_size = 0;
  }
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/buffer.c"
void end_put(void) 
{ 


  {
#line 59
  if (info_only) {
#line 60
    return;
  }
  {
#line 62
  start_info(info, (unsigned long )rsrc_size, (unsigned long )data_size);
  }
#line 63
  if (data_size != 0) {
    {
#line 64
    start_data();
#line 65
    copy(out_ptr, data_fork, data_size);
    }
  }
#line 67
  if (rsrc_size != 0) {
    {
#line 68
    start_rsrc();
#line 69
    copy(out_ptr, rsrc_fork, rsrc_size);
    }
  }
  {
#line 71
  end_file();
  }
#line 72
  return;
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 13 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../fileio/wrfile.h"
char *get_mina(void) ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../fileio/wrfileopt.h"
int wrfileopt(char c ) ;
#line 2
void give_wrfileopt(void) ;
#line 3
void set_wrfileopt(int restricted ) ;
#line 5
char *get_wrfileopt(void) ;
#line 7 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/../util/curtime.h"
extern time_t time() ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
void dl(char *macname , char *filename___2 ) ;
#line 35
static void usage(void) ;
#line 36
static void do_files(char *filename___2 , char *macname ) ;
#line 37
static int find_header(int again ) ;
#line 39 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
static char options[128]  ;
#line 47
extern int optind ;
#line 48
extern char *optarg ;
#line 59
extern int ( /* missing proto */  getopt)() ;
#line 41 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
int main(int argc , char **argv ) 
{ 
  char *filename___2 ;
  char macname[32] ;
  int errflg ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 52
  set_wrfileopt(0);
#line 53
  tmp = get_wrfileopt();
#line 53
  strcat((char */* __restrict  */)(options), (char const   */* __restrict  */)tmp);
#line 54
  strcat((char */* __restrict  */)(options), (char const   */* __restrict  */)"ilvcn:qVH");
#line 55
  errflg = 0;
#line 56
  filename___2 = (char *)"";
#line 57
  macname[0] = (char)0;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    c = getopt(argc, argv, options);
    }
#line 59
    if (! (c != -1)) {
#line 59
      goto while_break;
    }
    {
#line 60
    tmp___1 = wrfileopt((int )((char )c));
    }
#line 60
    if (! tmp___1) {
      {
#line 62
      if (c == 108) {
#line 62
        goto case_108;
      }
#line 65
      if (c == 118) {
#line 65
        goto case_118;
      }
#line 68
      if (c == 105) {
#line 68
        goto case_105;
      }
#line 71
      if (c == 99) {
#line 71
        goto case_99;
      }
#line 74
      if (c == 110) {
#line 74
        goto case_110;
      }
#line 77
      if (c == 63) {
#line 77
        goto case_63;
      }
#line 80
      if (c == 72) {
#line 80
        goto case_72;
      }
#line 96
      if (c == 86) {
#line 96
        goto case_86;
      }
#line 61
      goto switch_break;
      case_108: /* CIL Label */ 
#line 63
      listmode ++;
#line 64
      goto switch_break;
      case_118: /* CIL Label */ 
#line 66
      verbose ++;
#line 67
      goto switch_break;
      case_105: /* CIL Label */ 
#line 69
      info_only ++;
#line 70
      goto switch_break;
      case_99: /* CIL Label */ 
#line 72
      uneven_lines ++;
#line 73
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 75
      backtrans(macname, optarg);
      }
#line 76
      goto switch_break;
      case_63: /* CIL Label */ 
#line 78
      errflg ++;
#line 79
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 81
      give_wrfileopt();
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hexbin specific options:\n");
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-i:\tgive information only, do not convert\n");
#line 85
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-l:\tgive listing\n");
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-v:\tgive verbose listing, including lines skipped\n");
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c:\tdo not check for equal line lengths\n");
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-n nm:\tname to be generated\n");
#line 91
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-V:\tgive information about this version\n");
#line 93
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-H:\tthis message\n");
#line 94
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Default is silent conversion\n");
#line 95
      exit(0);
      }
      case_86: /* CIL Label */ 
      {
#line 97
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version %s, ",
              "2.0b3 (22-OCT-1992)");
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"patchlevel %d",
              0);
#line 99
      tmp___0 = get_mina();
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.\n",
              tmp___0);
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hexified files recognized:\n");
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tDownload (.dl)\n");
#line 105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tBinHex 2.0 (.hex)\n");
#line 106
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tBinHex 3.0 (.hcx)\n");
#line 109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tBinHex 4.0 (.hqx)\n");
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUUTool (.mu)\n");
#line 114
      exit(0);
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (errflg) {
    {
#line 119
    usage();
#line 120
    exit(1);
    }
  }
#line 122
  if (info_only) {
#line 123
    listmode ++;
  } else
#line 122
  if (verbose) {
#line 123
    listmode ++;
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (optind == argc) {
#line 128
      filename___2 = (char *)"-";
    } else {
#line 130
      filename___2 = *(argv + optind);
#line 131
      optind ++;
    }
    {
#line 136
    do_files(filename___2, macname);
    }
#line 126
    if (! (optind < argc)) {
#line 126
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  exit(0);
  }
}
}
#line 142 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
static char *extensions[10]  = 
#line 142
  {      (char *)".dl",      (char *)".hex",      (char *)".Hex",      (char *)".hcx", 
        (char *)".Hcx",      (char *)".hqx",      (char *)".Hqx",      (char *)".mu", 
        (char *)"",      (char *)((void *)0)};
#line 163 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
static void do_files(char *filename___2 , char *macname ) 
{ 
  char namebuf[256] ;
  char **ep ;
  struct stat stbuf ;
  long curtime ;
  int qformat ;
  int again ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 174
  if ((int )*(filename___2 + 0) == 45) {
#line 175
    ifp = stdin;
#line 176
    filename___2 = (char *)"stdin";
  } else {
#line 179
    ep = extensions;
    {
#line 179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 179
      if (! ((unsigned long )*ep != (unsigned long )((void *)0))) {
#line 179
        goto while_break;
      }
      {
#line 180
      sprintf((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)"%s%s",
              filename___2, *ep);
#line 181
      tmp = stat((char const   */* __restrict  */)(namebuf), (struct stat */* __restrict  */)(& stbuf));
      }
#line 181
      if (tmp == 0) {
#line 182
        goto while_break;
      }
#line 179
      ep ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 185
    if ((unsigned long )*ep == (unsigned long )((void *)0)) {
      {
#line 186
      perror((char const   *)(namebuf));
#line 187
      exit(1);
      }
    }
    {
#line 189
    ifp = fopen((char const   */* __restrict  */)(namebuf), (char const   */* __restrict  */)"r");
    }
#line 190
    if ((unsigned long )ifp == (unsigned long )((void *)0)) {
      {
#line 191
      perror((char const   *)(namebuf));
#line 192
      exit(1);
      }
    }
  }
#line 195
  again = 0;
  nexttry: 
#line 197
  if ((unsigned long )ifp == (unsigned long )stdin) {
    {
#line 198
    tmp___0 = time((time_t *)0);
#line 198
    curtime = tmp___0 + 2082844800L;
#line 199
    mh.m_createtime = curtime;
#line 200
    mh.m_modifytime = curtime;
    }
  } else {
#line 202
    mh.m_createtime = stbuf.st_mtim.tv_sec + 2082844800L;
#line 203
    mh.m_modifytime = stbuf.st_mtim.tv_sec + 2082844800L;
  }
  {
#line 206
  qformat = find_header(again);
  }
  {
#line 210
  if (qformat == 0) {
#line 210
    goto case_0;
  }
#line 215
  if (qformat == 1) {
#line 215
    goto case_1;
  }
#line 220
  if (qformat == 2) {
#line 220
    goto case_2;
  }
#line 226
  if (qformat == 3) {
#line 226
    goto case_3;
  }
#line 231
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 211
  dl(macname, filename___2);
  }
#line 212
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 216
  hecx(macname, filename___2);
  }
#line 217
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 221
  hqx(macname);
#line 222
  again = 1;
  }
#line 223
  goto nexttry;
  case_3: /* CIL Label */ 
  {
#line 227
  mu(macname);
#line 228
  again = 1;
  }
#line 229
  goto nexttry;
  switch_default: /* CIL Label */ 
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  fclose(ifp);
  }
#line 235
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
static int find_header(int again ) 
{ 
  int c ;
  int dl_start ;
  int llen ;
  char *cp ;
  char header[128] ;
  int ds ;
  int rs ;
  int tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 246
  if (again) {
#line 246
    if (was_macbin) {
      {
#line 247
      while (1) {
        while_continue: /* CIL Label */ ;
#line 247
        tmp = to_read;
#line 247
        to_read --;
#line 247
        if (! (tmp > 0)) {
#line 247
          goto while_break;
        }
        {
#line 248
        c = fgetc(ifp);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 251
  was_macbin = 0;
#line 252
  c = fgetc(ifp);
#line 253
  ungetc(c, ifp);
  }
#line 254
  if (c == 0) {
    {
#line 255
    was_macbin = 1;
#line 256
    tmp___0 = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)ifp);
    }
#line 256
    if (tmp___0 != 128UL) {
      {
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 261
      exit(1);
      }
    }
    {
#line 263
    tmp___1 = get4(header + 83);
#line 263
    ds = (int )tmp___1;
#line 264
    tmp___2 = get4(header + 87);
#line 264
    rs = (int )tmp___2;
#line 265
    ds = ((ds + 127) >> 7) << 7;
#line 266
    rs = ((rs + 127) >> 7) << 7;
#line 267
    to_read = ds + rs;
#line 268
    tmp___3 = strncmp((char const   *)(header + 65), "TEXT", (size_t )4);
    }
#line 268
    if (tmp___3) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is not a proper BinHexed file.\n");
#line 273
      exit(1);
      }
    }
#line 275
    if (listmode) {
      {
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is probably packed by ");
#line 277
      tmp___8 = strncmp((char const   *)(header + 69), "BNHQ", (size_t )4);
      }
#line 277
      if (tmp___8) {
        {
#line 279
        tmp___7 = strncmp((char const   *)(header + 69), "BthX", (size_t )4);
        }
#line 279
        if (tmp___7) {
          {
#line 281
          tmp___6 = strncmp((char const   *)(header + 69), "BnHq", (size_t )4);
          }
#line 281
          if (tmp___6) {
            {
#line 283
            tmp___5 = strncmp((char const   *)(header + 69), "ttxt", (size_t )4);
            }
#line 283
            if (tmp___5) {
              {
#line 285
              tmp___4 = strncmp((char const   *)(header + 69), "BSWU", (size_t )4);
              }
#line 285
              if (tmp___4) {
                {
#line 288
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"an unknown program");
                }
              } else {
                {
#line 286
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"UUTool\"");
                }
              }
            } else {
              {
#line 284
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"Compactor\"");
              }
            }
          } else {
            {
#line 282
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"StuffIt\"");
            }
          }
        } else {
          {
#line 280
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"BinHqx\"");
          }
        }
      } else {
        {
#line 278
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"BinHex\"");
        }
      }
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
      }
    }
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    tmp___13 = readline();
    }
#line 297
    if (! tmp___13) {
#line 297
      goto while_break___0;
    }
    {
#line 298
    tmp___9 = strlen((char const   *)(line));
#line 298
    llen = (int )tmp___9;
#line 300
    tmp___10 = strncmp((char const   *)(line), "(This file", (size_t )10);
    }
#line 300
    if (tmp___10 == 0) {
#line 300
      goto _L;
    } else {
      {
#line 300
      tmp___11 = strncmp((char const   *)(line), "(Convert with", (size_t )13);
      }
#line 300
      if (tmp___11 == 0) {
        _L: /* CIL Label */ 
#line 302
        if (verbose) {
          {
#line 303
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skip:%s\n",
                  line);
          }
        }
#line 305
        goto while_break___0;
      }
    }
    {
#line 309
    tmp___12 = strncmp((char const   *)(line), "begin ", (size_t )6);
    }
#line 309
    if (tmp___12 == 0) {
#line 310
      return (3);
    }
#line 315
    if (llen > 40) {
#line 315
      if ((llen & 1) == 0) {
#line 316
        dl_start = 1;
#line 317
        cp = & line[0];
        {
#line 317
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 317
          if (! ((int )*cp != 0)) {
#line 317
            goto while_break___1;
          }
#line 318
          if ((int )*cp < 64) {
#line 318
            goto _L___0;
          } else
#line 318
          if ((int )*cp > 79) {
            _L___0: /* CIL Label */ 
#line 318
            if ((int )*cp != 124) {
#line 319
              dl_start = 0;
#line 320
              goto while_break___1;
            }
          }
#line 317
          cp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 323
        if (dl_start) {
#line 323
          if ((unsigned long )cp > (unsigned long )(& line[1])) {
#line 324
            return (0);
          }
        }
      }
    }
#line 328
    if (llen != 0) {
#line 328
      if (verbose) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skip:%s\n",
                line);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 332
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 332
    tmp___14 = readline();
    }
#line 332
    if (! tmp___14) {
#line 332
      goto while_break___2;
    }
    {
#line 335
    if ((int )line[0] == 58) {
#line 335
      goto case_58;
    }
#line 339
    if ((int )line[0] == 35) {
#line 339
      goto case_35;
    }
#line 342
    goto switch_default;
    case_58: /* CIL Label */ 
#line 336
    return (2);
    case_35: /* CIL Label */ 
#line 340
    return (1);
    switch_default: /* CIL Label */ 
#line 343
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 347
  if (! again) {
    {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
#line 352
    exit(1);
    }
  }
#line 354
  return (-1);
}
}
#line 357 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/hexbin.c"
static void usage(void) 
{ 


  {
  {
#line 359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: hexbin [-%s] [filenames]\n",
          options);
#line 360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"hexbin -H\" for help.\n");
  }
#line 361
  return;
}
}
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
static long dl_fork(void) ;
#line 15
static int nchar(void) ;
#line 16
static int nextc(void) ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
static char *icp  =    & line[0];
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
void dl(char *macname , char *filename___2 ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 26
  if (listmode) {
    {
#line 27
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This file is in \"dl\" format.\n");
    }
  }
#line 29
  n = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (n < 128)) {
#line 29
      goto while_break;
    }
#line 30
    info[n] = (char)0;
#line 29
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  if ((int )*(macname + 0) == 0) {
    {
#line 35
    macname = rindex((char const   *)filename___2, '/');
    }
#line 36
    if ((unsigned long )macname == (unsigned long )((void *)0)) {
#line 37
      macname = filename___2;
    } else {
#line 39
      macname ++;
    }
    {
#line 42
    tmp = strlen((char const   *)macname);
#line 42
    n = (int )tmp;
    }
#line 43
    if (n > 3) {
      {
#line 44
      n -= 3;
#line 45
      tmp___0 = strncmp((char const   *)(macname + n), ".dl", (size_t )3);
      }
#line 45
      if (! tmp___0) {
#line 46
        *(macname + n) = (char )'\000';
      }
    }
  }
  {
#line 50
  tmp___1 = strlen((char const   *)macname);
#line 50
  n = (int )tmp___1;
  }
#line 51
  if (n > 63) {
#line 52
    n = 63;
  }
  {
#line 54
  strncpy((char */* __restrict  */)(mh.m_name), (char const   */* __restrict  */)macname,
          (size_t )n);
#line 55
  strncpy((char */* __restrict  */)(mh.m_type), (char const   */* __restrict  */)"APPL",
          (size_t )4);
#line 56
  strncpy((char */* __restrict  */)(mh.m_author), (char const   */* __restrict  */)"????",
          (size_t )4);
#line 57
  mh.m_name[n] = (char )'\000';
#line 58
  transname(mh.m_name, trname, n);
#line 59
  define_name(trname);
#line 60
  print_header0(0);
#line 61
  print_header1(0, 0);
#line 62
  set_put(1);
#line 63
  mh.m_datalen = 0L;
#line 64
  set_put(0);
#line 65
  mh.m_rsrclen = dl_fork();
#line 66
  info[1] = (char )n;
#line 67
  strncpy((char */* __restrict  */)((info + 1) + 1), (char const   */* __restrict  */)(mh.m_name),
          (size_t )n);
#line 68
  strncpy((char */* __restrict  */)(info + 65), (char const   */* __restrict  */)(mh.m_type),
          (size_t )4);
#line 69
  strncpy((char */* __restrict  */)(info + 69), (char const   */* __restrict  */)(mh.m_author),
          (size_t )4);
#line 70
  put4(info + 83, (unsigned long )mh.m_datalen);
#line 71
  put4(info + 87, (unsigned long )mh.m_rsrclen);
#line 72
  put4(info + 91, (unsigned long )mh.m_createtime);
#line 73
  put4(info + 95, (unsigned long )mh.m_modifytime);
#line 74
  print_header2(0);
#line 75
  end_put();
  }
#line 76
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
static long dl_fork(void) 
{ 
  register unsigned long i ;
  register unsigned long v ;
  register unsigned long c ;
  register unsigned long n ;
  register unsigned long bytes ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  n = 0UL;
#line 84
  bytes = 0UL;
#line 85
  v = 0UL;
#line 86
  crc = 0UL;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp = nchar();
#line 87
    i = (unsigned long )tmp;
    }
#line 87
    if (! (i != 124UL)) {
#line 87
      goto while_break;
    }
#line 88
    if (i < 64UL) {
#line 89
      goto while_continue;
    } else
#line 88
    if (i > 79UL) {
#line 89
      goto while_continue;
    }
#line 91
    v = (v << 4) | (i & 15UL);
#line 92
    n ++;
#line 92
    if ((n & 1UL) == 0UL) {
      {
#line 93
      put_byte((int )((char )v));
#line 94
      crc += v;
#line 95
      v = 0UL;
#line 96
      bytes ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  c = 0UL;
#line 100
  i = 0UL;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (i < 8UL)) {
#line 100
      goto while_break___0;
    }
    {
#line 101
    tmp___0 = nchar();
#line 101
    c = (c << 4) | (unsigned long )(tmp___0 & 15);
#line 100
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  verify_crc(bytes + crc, c);
  }
#line 104
  return ((long )bytes);
}
}
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
static int nchar(void) 
{ 
  int i ;

  {
  {
#line 111
  i = nextc();
  }
#line 111
  if (i == -1) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 116
    exit(1);
    }
  }
#line 118
  return (i & 127);
}
}
#line 121 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/dl.c"
static int nextc(void) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((int )*icp == 0)) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp = readline();
    }
#line 124
    if (tmp == 0) {
#line 125
      return (-1);
    }
#line 127
    icp = & line[0];
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  tmp___0 = icp;
#line 129
  icp ++;
#line 129
  return ((int )*tmp___0);
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.h"
char *out_buffer  ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.h"
char *out_ptr  ;
#line 11
void do_mkdir(char *name , char *header ) ;
#line 12
void enddir(void) ;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfileopt.h"
void set_s_wrfileopt(int restricted ) ;
#line 40 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
extern char *strcpy() ;
#line 55
static void check_appledouble(void) ;
#line 56
static void appledouble_namings(void) ;
#line 57
static void wr_appledouble_info(FILE *fp ) ;
#line 60
static void mk_share_name(void) ;
#line 73 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info[69]  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_data[207]  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_rsrc[69]  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_text[69]  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_unix[69]  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_bin[69]  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_folder[12]  = 
#line 79
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char share_name[256]  ;
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char hex[17]  = 
#line 82
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char infodir[13]  = 
#line 93
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info_appledouble[207UL + sizeof(infodir)]  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode  =    4;
#line 99 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_restricted  =    0;
#line 100 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_s_restricted  =    0;
#line 103 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char init_buffer[128]  ;
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *buffer  =    & init_buffer[0];
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *rbuffer  =    (char *)((void *)0);
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *dbuffer  =    (char *)((void *)0);
#line 106 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *ptr  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long rsz  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long dsz  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long totsize  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long maxsize  ;
#line 109 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void define_name(char *text___0 ) 
{ 


  {
  {
#line 112
  sprintf((char */* __restrict  */)(f_info), (char const   */* __restrict  */)"%s.info",
          text___0);
#line 113
  sprintf((char */* __restrict  */)(f_rsrc), (char const   */* __restrict  */)"%s.rsrc",
          text___0);
#line 114
  sprintf((char */* __restrict  */)(f_data), (char const   */* __restrict  */)"%s.data",
          text___0);
#line 115
  sprintf((char */* __restrict  */)(f_text), (char const   */* __restrict  */)"%s.text",
          text___0);
#line 116
  sprintf((char */* __restrict  */)(f_bin), (char const   */* __restrict  */)"%s.bin",
          text___0);
#line 117
  sprintf((char */* __restrict  */)(f_unix), (char const   */* __restrict  */)"%s",
          text___0);
  }
#line 123
  return;
}
}
#line 148
extern int ( /* missing proto */  bzero)() ;
#line 150
extern int ( /* missing proto */  bcopy)() ;
#line 125 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void start_info(char *info___0 , unsigned long rsize , unsigned long dsize ) 
{ 
  int rs ;
  int ds ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 131
  rsz = rsize;
#line 132
  dsz = dsize;
#line 133
  rs = (int )(((rsz + 127UL) >> 7) << 7);
#line 134
  ds = (int )(((dsz + 127UL) >> 7) << 7);
#line 135
  totsize = (unsigned long )((rs + ds) + 128);
#line 136
  if ((unsigned long )buffer == (unsigned long )(& init_buffer[0])) {
    {
#line 137
    tmp = malloc((unsigned int )totsize);
#line 137
    buffer = tmp;
    }
  } else
#line 138
  if (maxsize < totsize) {
    {
#line 139
    tmp___0 = realloc(buffer, (unsigned int )totsize);
#line 139
    buffer = tmp___0;
    }
  }
#line 141
  maxsize = totsize;
#line 142
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 144
    exit(1);
    }
  }
  {
#line 146
  dbuffer = buffer + 128;
#line 147
  rbuffer = dbuffer + ds;
#line 148
  bzero(buffer, (int )totsize);
#line 149
  ptr = buffer;
#line 150
  bcopy(info___0, ptr, 128);
  }
#line 159
  if (mode == 6) {
    {
#line 160
    appledouble_namings();
    }
  }
#line 163
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void start_rsrc(void) 
{ 


  {
#line 167
  out_ptr = rbuffer;
#line 167
  out_buffer = out_ptr;
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void start_data(void) 
{ 


  {
#line 172
  out_ptr = dbuffer;
#line 172
  out_buffer = out_ptr;
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void end_file(void) 
{ 
  FILE *fp ;
  int i ;
  int c ;

  {
#line 180
  *(buffer + 73) = (char )((int )*(buffer + 73) & -2);
  {
#line 183
  if (mode == 5) {
#line 183
    goto case_5;
  }
#line 183
  if (mode == 3) {
#line 183
    goto case_5;
  }
#line 210
  if (mode == 2) {
#line 210
    goto case_2;
  }
#line 219
  if (mode == 1) {
#line 219
    goto case_1;
  }
#line 228
  if (mode == 0) {
#line 228
    goto case_0;
  }
#line 243
  if (mode == 8) {
#line 243
    goto case_8;
  }
#line 258
  if (mode == 4) {
#line 258
    goto case_4;
  }
#line 272
  if (mode == 7) {
#line 272
    goto case_7;
  }
#line 309
  if (mode == 6) {
#line 309
    goto case_6;
  }
#line 181
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 184
  fp = fopen((char const   */* __restrict  */)(f_info), (char const   */* __restrict  */)"w");
  }
#line 185
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 186
    perror((char const   *)(f_info));
#line 187
    exit(1);
    }
  }
  {
#line 189
  fwrite((void const   */* __restrict  */)buffer, (size_t )1, (size_t )128, (FILE */* __restrict  */)fp);
#line 190
  fclose(fp);
  }
#line 191
  if (rsz != 0UL) {
#line 191
    goto _L;
  } else
#line 191
  if (mode == 3) {
    _L: /* CIL Label */ 
    {
#line 192
    fp = fopen((char const   */* __restrict  */)(f_rsrc), (char const   */* __restrict  */)"w");
    }
#line 193
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 194
      perror((char const   *)(f_rsrc));
#line 195
      exit(1);
      }
    }
    {
#line 197
    fwrite((void const   */* __restrict  */)rbuffer, (size_t )1, (size_t )((int )rsz),
           (FILE */* __restrict  */)fp);
#line 198
    fclose(fp);
    }
  }
#line 200
  if (dsz != 0UL) {
#line 200
    goto _L___0;
  } else
#line 200
  if (mode == 3) {
    _L___0: /* CIL Label */ 
    {
#line 201
    fp = fopen((char const   */* __restrict  */)(f_data), (char const   */* __restrict  */)"w");
    }
#line 202
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 203
      perror((char const   *)(f_data));
#line 204
      exit(1);
      }
    }
    {
#line 206
    fwrite((void const   */* __restrict  */)dbuffer, (size_t )1, (size_t )((int )dsz),
           (FILE */* __restrict  */)fp);
#line 207
    fclose(fp);
    }
  }
#line 209
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 211
  fp = fopen((char const   */* __restrict  */)(f_rsrc), (char const   */* __restrict  */)"w");
  }
#line 212
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 213
    perror((char const   *)(f_rsrc));
#line 214
    exit(1);
    }
  }
  {
#line 216
  fwrite((void const   */* __restrict  */)rbuffer, (size_t )1, (size_t )((int )rsz),
         (FILE */* __restrict  */)fp);
#line 217
  fclose(fp);
  }
#line 218
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 220
  fp = fopen((char const   */* __restrict  */)(f_data), (char const   */* __restrict  */)"w");
  }
#line 221
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 222
    perror((char const   *)(f_data));
#line 223
    exit(1);
    }
  }
  {
#line 225
  fwrite((void const   */* __restrict  */)dbuffer, (size_t )1, (size_t )((int )dsz),
         (FILE */* __restrict  */)fp);
#line 226
  fclose(fp);
  }
#line 227
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 229
  fp = fopen((char const   */* __restrict  */)(f_text), (char const   */* __restrict  */)"w");
  }
#line 230
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 231
    perror((char const   *)(f_data));
#line 232
    exit(1);
    }
  }
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )i < dsz)) {
#line 234
      goto while_break;
    }
#line 235
    c = (int )*(dbuffer + i);
#line 236
    if (c == 10) {
#line 237
      *(dbuffer + i) = (char )(23 - c);
    } else
#line 236
    if (c == 13) {
#line 237
      *(dbuffer + i) = (char )(23 - c);
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  fwrite((void const   */* __restrict  */)dbuffer, (size_t )1, (size_t )((int )dsz),
         (FILE */* __restrict  */)fp);
#line 241
  fclose(fp);
  }
#line 242
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 244
  fp = fopen((char const   */* __restrict  */)(f_unix), (char const   */* __restrict  */)"w");
  }
#line 245
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 246
    perror((char const   *)(f_data));
#line 247
    exit(1);
    }
  }
#line 249
  i = 0;
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )i < dsz)) {
#line 249
      goto while_break___0;
    }
#line 250
    c = (int )*(dbuffer + i);
#line 251
    if (c == 10) {
#line 252
      *(dbuffer + i) = (char )(23 - c);
    } else
#line 251
    if (c == 13) {
#line 252
      *(dbuffer + i) = (char )(23 - c);
    }
#line 249
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 255
  fwrite((void const   */* __restrict  */)dbuffer, (size_t )1, (size_t )((int )dsz),
         (FILE */* __restrict  */)fp);
#line 256
  fclose(fp);
  }
#line 257
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 259
  fp = fopen((char const   */* __restrict  */)(f_bin), (char const   */* __restrict  */)"w");
  }
#line 260
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 261
    perror((char const   *)(f_bin));
#line 262
    exit(1);
    }
  }
#line 264
  if ((int )*(buffer + 74) & 64) {
#line 265
    *(buffer + 81) = (char)1;
  }
  {
#line 267
  *(buffer + 74) = (char)0;
#line 268
  *(buffer + 82) = (char)0;
#line 269
  fwrite((void const   */* __restrict  */)buffer, (size_t )1, (size_t )((int )totsize),
         (FILE */* __restrict  */)fp);
#line 270
  fclose(fp);
  }
#line 271
  goto switch_break;
  case_7: /* CIL Label */ 
#line 276
  if ((int )*(buffer + 74) & 64) {
#line 277
    *(buffer + 81) = (char)1;
  }
  {
#line 279
  *(buffer + 74) = (char)0;
#line 280
  *(buffer + 82) = (char)0;
#line 281
  fwrite((void const   */* __restrict  */)buffer, (size_t )1, (size_t )((int )totsize),
         (FILE */* __restrict  */)stdout);
  }
#line 282
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 310
  fp = fopen((char const   */* __restrict  */)(f_info_appledouble), (char const   */* __restrict  */)"w");
  }
#line 311
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 312
    perror((char const   *)(f_info_appledouble));
#line 313
    exit(1);
    }
  }
  {
#line 315
  wr_appledouble_info(fp);
#line 316
  fwrite((void const   */* __restrict  */)rbuffer, (size_t )1, (size_t )((int )rsz),
         (FILE */* __restrict  */)fp);
#line 317
  fclose(fp);
#line 318
  fp = fopen((char const   */* __restrict  */)(f_data), (char const   */* __restrict  */)"w");
  }
#line 319
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 320
    perror((char const   *)(f_data));
#line 321
    exit(1);
    }
  }
  {
#line 323
  fwrite((void const   */* __restrict  */)dbuffer, (size_t )1, (size_t )((int )dsz),
         (FILE */* __restrict  */)fp);
#line 324
  fclose(fp);
  }
#line 325
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 328
  return;
}
}
#line 409
extern int ( /* missing proto */  chdir)() ;
#line 355 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void do_mkdir(char *name , char *header ) 
{ 
  struct stat sbuf ;
  FILE *fp ;
  char dirinfo[(207UL + sizeof(infodir)) + 10UL] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 370
  if (mode == 7) {
    {
#line 374
    *(header + 1) = (char )((int )*(header + 1) | 128);
#line 375
    fwrite((void const   */* __restrict  */)header, (size_t )1, (size_t )128, (FILE */* __restrict  */)stdout);
#line 376
    *(header + 1) = (char )((int )*(header + 1) & 127);
    }
#line 377
    return;
  }
#line 380
  if (mode == 6) {
    {
#line 381
    bcopy(header, buffer, 128);
#line 382
    mk_share_name();
    }
  } else {
    {
#line 384
    strcpy(share_name, name);
    }
  }
  {
#line 389
  tmp___0 = stat((char const   */* __restrict  */)(share_name), (struct stat */* __restrict  */)(& sbuf));
  }
#line 389
  if (tmp___0 == -1) {
    {
#line 391
    tmp = mkdir((char const   *)(share_name), (__mode_t )511);
    }
#line 391
    if (tmp == -1) {
      {
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t create subdirectory %s\n",
              share_name);
#line 393
      exit(1);
      }
    }
  } else
#line 403
  if ((sbuf.st_mode & 61440U) != 16384U) {
    {
#line 404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Directory name %s already in use\n",
            share_name);
#line 406
    exit(1);
    }
  }
  {
#line 409
  chdir(share_name);
  }
#line 464
  if (mode == 6) {
    {
#line 465
    tmp___2 = stat((char const   */* __restrict  */)(infodir), (struct stat */* __restrict  */)(& sbuf));
    }
#line 465
    if (tmp___2 == -1) {
      {
#line 466
      tmp___1 = mkdir((char const   *)(infodir), (__mode_t )511);
      }
#line 466
      if (tmp___1 == -1) {
        {
#line 467
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t create subdirectory %s\n",
                infodir);
#line 469
        exit(1);
        }
      }
    } else
#line 472
    if ((sbuf.st_mode & 61440U) != 16384U) {
      {
#line 473
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Directory name %s already in use\n",
              infodir);
#line 475
      exit(1);
      }
    }
    {
#line 478
    dirinfo[0] = (char)0;
#line 479
    strcat(dirinfo, infodir);
#line 480
    strcat(dirinfo, "/.Parent");
#line 481
    fp = fopen((char const   */* __restrict  */)(dirinfo), (char const   */* __restrict  */)"w");
    }
#line 482
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 483
      perror((char const   *)(dirinfo));
#line 484
      exit(1);
      }
    }
    {
#line 486
    rsz = 0UL;
#line 487
    wr_appledouble_info(fp);
#line 488
    fclose(fp);
    }
  } else {
    {
#line 490
    fp = fopen((char const   */* __restrict  */)(f_folder), (char const   */* __restrict  */)"w");
    }
#line 491
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 492
      perror((char const   *)(f_folder));
#line 493
      exit(1);
      }
    }
    {
#line 495
    *(header + 1) = (char )((int )*(header + 1) | 128);
#line 496
    fwrite((void const   */* __restrict  */)header, (size_t )1, (size_t )128, (FILE */* __restrict  */)fp);
#line 497
    *(header + 1) = (char )((int )*(header + 1) & 127);
#line 498
    fclose(fp);
    }
  }
#line 512
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void enddir(void) 
{ 
  char header[128] ;
  int i ;

  {
#line 520
  if (mode == 7) {
#line 524
    i = 0;
    {
#line 524
    while (1) {
      while_continue: /* CIL Label */ ;
#line 524
      if (! (i < 128)) {
#line 524
        goto while_break;
      }
#line 525
      header[i] = (char)0;
#line 524
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 527
    header[1] = (char)-128;
#line 528
    fwrite((void const   */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 530
    chdir("..");
    }
  }
#line 532
  return;
}
}
#line 606 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble(void) 
{ 
  struct stat stbuf ;
  int error ;
  int tmp ;

  {
  {
#line 610
  error = 0;
#line 612
  tmp = stat((char const   */* __restrict  */)(infodir), (struct stat */* __restrict  */)(& stbuf));
  }
#line 612
  if (tmp < 0) {
#line 613
    error ++;
  } else
#line 615
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 616
    error ++;
  }
#line 619
  if (error) {
    {
#line 620
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not in an AppleDouble folder.\n");
#line 621
    exit(1);
    }
  }
#line 623
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void appledouble_namings(void) 
{ 


  {
  {
#line 627
  mk_share_name();
#line 628
  sprintf((char */* __restrict  */)(f_info_appledouble), (char const   */* __restrict  */)"%s/%s",
          infodir, share_name);
#line 629
  sprintf((char */* __restrict  */)(f_data), (char const   */* __restrict  */)"%s",
          share_name);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void wr_appledouble_info(FILE *fp ) 
{ 
  FileInfo theinfo ;
  int n ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 638
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 639
  put4(theinfo.fi_magic, 333319UL);
#line 640
  put2(theinfo.fi_version, 1UL);
#line 641
  put4(theinfo.fi_fill5, 5UL);
#line 642
  put4(theinfo.fi_fill6, 2UL);
#line 643
  put4(theinfo.fi_hlen, 589UL);
#line 644
  put4(theinfo.fi_fill7, 3UL);
#line 645
  put4(theinfo.fi_namptr, 86UL);
#line 646
  put4(theinfo.fi_fill9, 4UL);
#line 647
  put4(theinfo.fi_commptr, 341UL);
#line 648
  put4(theinfo.fi_fill12, 7UL);
#line 649
  put4(theinfo.fi_timeptr, 541UL);
#line 650
  put4(theinfo.fi_timesize, 16UL);
#line 651
  put4(theinfo.fi_fill15, 9UL);
#line 652
  put4(theinfo.fi_infoptr, 557UL);
#line 653
  put4(theinfo.fi_infosize, 32UL);
#line 655
  bcopy(buffer + 65, theinfo.fi_type, 4);
#line 656
  bcopy(buffer + 69, theinfo.fi_auth, 4);
#line 657
  bcopy(buffer + 73, theinfo.fi_finfo, 2);
#line 659
  tmp = get4(buffer + 91);
#line 659
  put4(theinfo.fi_ctime, tmp - 2082844800UL);
#line 660
  tmp___0 = get4(buffer + 95);
#line 660
  put4(theinfo.fi_mtime, tmp___0 - 2082844800UL);
#line 661
  n = (int )*(buffer + 1) & 255;
  }
#line 661
  if (n > 63) {
#line 662
    n = 63;
  }
  {
#line 664
  put4(theinfo.fi_namlen, (unsigned long )n);
#line 665
  strncpy(theinfo.fi_name, (buffer + 1) + 1, n);
#line 667
  strcpy(theinfo.fi_comment, "Converted by Unix utility to AppleDouble format");
#line 669
  tmp___1 = (int )strlen(theinfo.fi_comment);
#line 669
  put4(theinfo.fi_commsize, (unsigned long )tmp___1);
#line 670
  put4(theinfo.fi_rsrc, rsz);
#line 674
  fwrite((void const   */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
         (FILE */* __restrict  */)fp);
  }
#line 675
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void mk_share_name(void) 
{ 
  int ch ;
  char *mp ;
  char *up ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 683
  mp = buffer + 2;
#line 684
  up = & share_name[0];
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    tmp___5 = mp;
#line 685
    mp ++;
#line 685
    ch = (int )*tmp___5;
#line 685
    if (! ch) {
#line 685
      goto while_break;
    }
#line 686
    if ((ch & -128) == 0) {
      {
#line 686
      tmp___3 = __ctype_b_loc();
      }
#line 686
      if ((int const   )*(*tmp___3 + ch) & 2) {
#line 686
        goto _L___1;
      } else {
        {
#line 686
        tmp___4 = __ctype_b_loc();
        }
#line 686
        if ((int const   )*(*tmp___4 + ch) & 16384) {
#line 686
          if (ch != 47) {
#line 687
            tmp = up;
#line 687
            up ++;
#line 687
            *tmp = (char )ch;
          } else {
#line 686
            goto _L___1;
          }
        } else {
#line 686
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 689
      tmp___0 = up;
#line 689
      up ++;
#line 689
      *tmp___0 = (char )':';
#line 690
      tmp___1 = up;
#line 690
      up ++;
#line 690
      *tmp___1 = hex[(ch >> 4) & 15];
#line 691
      tmp___2 = up;
#line 691
      up ++;
#line 691
      *tmp___2 = hex[ch & 15];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  *up = (char)0;
#line 695
  return;
}
}
#line 698 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
int wrfileopt(char c ) 
{ 


  {
  {
#line 702
  if ((int )c == 98) {
#line 702
    goto case_98;
  }
#line 705
  if ((int )c == 114) {
#line 705
    goto case_114;
  }
#line 711
  if ((int )c == 100) {
#line 711
    goto case_100;
  }
#line 717
  if ((int )c == 117) {
#line 717
    goto case_117;
  }
#line 723
  if ((int )c == 85) {
#line 723
    goto case_85;
  }
#line 729
  if ((int )c == 102) {
#line 729
    goto case_102;
  }
#line 732
  if ((int )c == 51) {
#line 732
    goto case_51;
  }
#line 735
  if ((int )c == 115) {
#line 735
    goto case_115;
  }
#line 749
  if ((int )c == 97) {
#line 749
    goto case_97;
  }
#line 766
  goto switch_default;
  case_98: /* CIL Label */ 
#line 703
  mode = 4;
#line 704
  goto switch_break;
  case_114: /* CIL Label */ 
#line 706
  if (mode_restricted) {
#line 707
    return (0);
  }
#line 709
  mode = 2;
#line 710
  goto switch_break;
  case_100: /* CIL Label */ 
#line 712
  if (mode_restricted) {
#line 713
    return (0);
  }
#line 715
  mode = 1;
#line 716
  goto switch_break;
  case_117: /* CIL Label */ 
#line 718
  if (mode_restricted) {
#line 719
    return (0);
  }
#line 721
  mode = 0;
#line 722
  goto switch_break;
  case_85: /* CIL Label */ 
#line 724
  if (mode_restricted) {
#line 725
    return (0);
  }
#line 727
  mode = 8;
#line 728
  goto switch_break;
  case_102: /* CIL Label */ 
#line 730
  mode = 5;
#line 731
  goto switch_break;
  case_51: /* CIL Label */ 
#line 733
  mode = 3;
#line 734
  goto switch_break;
  case_115: /* CIL Label */ 
#line 736
  if (mode_s_restricted) {
#line 737
    return (0);
  }
#line 739
  mode = 7;
#line 740
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 757
  check_appledouble();
#line 758
  mode = 6;
  }
#line 759
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 767
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 769
  return (1);
}
}
#line 772 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void give_wrfileopt(void) 
{ 


  {
  {
#line 774
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File output options:\n");
#line 775
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-b:\tMacBinary (default)\n");
  }
#line 776
  if (! mode_s_restricted) {
    {
#line 777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-s:\tMacBinary stream to standard output\n");
    }
  }
  {
#line 783
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-f:\tthree fork mode, skipping empty forks\n");
#line 784
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-3:\tthe same, writing also empty forks\n");
  }
#line 785
  if (! mode_restricted) {
    {
#line 786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-r:\tresource forks only\n");
#line 787
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-d:\tdata forks only\n");
#line 788
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u:\tdata forks only with Mac -> Unix text file translation\n");
#line 790
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-U:\tas -u, but filename will not have an extension\n");
    }
  }
  {
#line 798
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-a:\tAppleDouble format\n");
  }
#line 803
  return;
}
}
#line 805 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void set_wrfileopt(int restricted ) 
{ 


  {
#line 807
  mode_restricted = restricted;
#line 808
  return;
}
}
#line 810 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
void set_s_wrfileopt(int restricted ) 
{ 


  {
#line 812
  mode_s_restricted = restricted;
#line 813
  return;
}
}
#line 817 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char options___0[20]  ;
#line 815 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
char *get_wrfileopt(void) 
{ 


  {
  {
#line 819
  strcpy(options___0, "b");
  }
#line 820
  if (! mode_s_restricted) {
    {
#line 821
    strcat(options___0, "s");
    }
  }
  {
#line 826
  strcat(options___0, "f3");
  }
#line 827
  if (! mode_restricted) {
    {
#line 828
    strcat(options___0, "rduU");
    }
  }
  {
#line 830
  strcat(options___0, "a");
  }
#line 831
  return (options___0);
}
}
#line 834 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
char *get_mina(void) 
{ 


  {
#line 841
  return ((char *)", AppleDouble supported");
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.h"
unsigned long crc  ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.c"
void comp_q_crc(unsigned int c ) 
{ 
  unsigned char cc ;

  {
  {
#line 17
  cc = (unsigned char )c;
#line 19
  crc = binhex_updcrc(crc, & cc, 1);
  }
#line 20
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.c"
void comp_q_crc_n(unsigned char *s , unsigned char *e ) 
{ 


  {
  {
#line 25
  crc = binhex_updcrc(crc, s, e - s);
  }
#line 26
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/macutils-2.0b3/hexbin/crc.c"
void verify_crc(unsigned long calc_crc___0 , unsigned long file_crc___0 ) 
{ 


  {
#line 32
  calc_crc___0 &= 65535UL;
#line 33
  file_crc___0 &= 65535UL;
#line 35
  if (calc_crc___0 != file_crc___0) {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC mismatch: got 0x%04lx, need 0x%04lx\n",
            file_crc___0, calc_crc___0);
#line 41
    exit(1);
    }
  }
#line 43
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___1[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int dir_skip ;
#line 10
FILE *infp ;
#line 12
int in_data_size ;
#line 12
int in_rsrc_size ;
#line 12
int in_ds ;
#line 12
int in_rs ;
#line 12
int ds_skip ;
#line 12
int rs_skip ;
#line 6 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macbinary.c"
void dir(char *hdr ) ;
#line 7
void mcb(char *hdr , unsigned long rsrcLength , unsigned long dataLength , int toread___0 ) ;
#line 10
static void skip_file(int skip ) ;
#line 15 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macbinary.c"
void macbinary(void) 
{ 
  char header[128] ;
  int c ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 21
    c = fgetc(infp);
    }
#line 21
    if (c == -1) {
#line 22
      goto while_break;
    }
    {
#line 24
    ungetc(c, infp);
#line 25
    tmp = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)infp);
    }
#line 25
    if (tmp != 128UL) {
      {
#line 26
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read MacBinary header.\n");
#line 27
      exit(1);
      }
    }
#line 29
    if ((int )header[1] & 128) {
      {
#line 30
      dir(header);
      }
#line 31
      goto while_continue;
    }
    {
#line 33
    tmp___0 = get4(header + 83);
#line 33
    in_data_size = (int )tmp___0;
#line 34
    tmp___1 = get4(header + 87);
#line 34
    in_rsrc_size = (int )tmp___1;
#line 35
    in_ds = ((in_data_size + 127) >> 7) << 7;
#line 36
    in_rs = ((in_rsrc_size + 127) >> 7) << 7;
#line 37
    ds_skip = in_ds - in_data_size;
#line 38
    rs_skip = in_rs - in_rsrc_size;
    }
#line 39
    if (dir_skip != 0) {
      {
#line 40
      skip_file(in_ds + in_rs);
      }
#line 41
      goto while_continue;
    }
#line 50
    if ((int )header[0] == 0) {
      {
#line 51
      mcb(header, (unsigned long )in_rsrc_size, (unsigned long )in_data_size, in_ds + in_rs);
      }
#line 53
      goto while_continue;
    } else {
      {
#line 55
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unrecognized header.\n");
#line 56
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macbinary.c"
static void skip_file(int skip ) 
{ 
  char buff[1024] ;
  int n ;
  size_t tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (skip > 0)) {
#line 67
      goto while_break;
    }
#line 68
    if (skip < 1024) {
#line 68
      n = skip;
    } else {
#line 68
      n = 1024;
    }
    {
#line 69
    tmp = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )n, (FILE */* __restrict  */)infp);
    }
#line 69
    if (tmp != (size_t )n) {
      {
#line 70
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incomplete file.\n");
#line 71
      exit(1);
      }
    }
#line 73
    skip -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int list ;
#line 9
int query ;
#line 9
int indent ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/dir.c"
static char *dir_stack  ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/dir.c"
static int dir_ptr  =    -64;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/dir.c"
static int dir_max  ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/dir.c"
void dir(char *hdr ) 
{ 
  int doit ;

  {
#line 19
  if (((int )*(hdr + 1) & 255) == 128) {
#line 20
    if (dir_skip) {
#line 21
      dir_skip --;
#line 22
      return;
    }
#line 24
    indent --;
#line 25
    if (list) {
      {
#line 26
      do_indent(indent);
#line 27
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
              dir_stack + dir_ptr);
      }
    }
#line 30
    if (! info_only) {
      {
#line 31
      enddir();
      }
    }
#line 33
    dir_ptr -= 64;
#line 34
    return;
  }
#line 36
  if (dir_skip) {
#line 37
    dir_skip ++;
#line 38
    return;
  }
#line 40
  dir_ptr += 64;
#line 41
  if (dir_ptr == dir_max) {
#line 42
    if (dir_max == 0) {
      {
#line 43
      dir_stack = malloc(64);
      }
    } else {
      {
#line 45
      dir_stack = realloc(dir_stack, (unsigned int )dir_max + 64U);
      }
    }
#line 47
    dir_max += 64;
#line 48
    if ((unsigned long )dir_stack == (unsigned long )((void *)0)) {
      {
#line 49
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory\n");
#line 50
      exit(1);
      }
    }
  }
  {
#line 53
  transname((hdr + 1) + 1, dir_stack + dir_ptr, (int )*(hdr + 1) & 127);
#line 55
  doit = 1;
  }
#line 56
  if (list) {
    {
#line 57
    do_indent(indent);
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
            dir_stack + dir_ptr);
    }
#line 59
    if (query) {
      {
#line 60
      doit = do_query();
      }
    } else {
      {
#line 62
      fputc('\n', stderr);
      }
    }
  }
#line 65
  if (! doit) {
#line 66
    dir_ptr -= 64;
#line 67
    dir_skip = 1;
#line 68
    return;
  }
#line 70
  if (! info_only) {
    {
#line 71
    do_mkdir(dir_stack + dir_ptr, hdr);
    }
  }
#line 73
  indent ++;
#line 74
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___0[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 55 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___0(void) ;
#line 56
static void appledouble_namings___0(void) ;
#line 57
static void wr_appledouble_info___0(FILE *fp ) ;
#line 60
static void mk_share_name___0(void) ;
#line 73 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info___0[69]  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_data___0[207]  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_rsrc___0[69]  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_text___0[69]  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_unix___0[69]  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_bin___0[69]  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_folder___0[12]  = 
#line 79
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char share_name___0[256]  ;
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char hex___0[17]  = 
#line 82
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char infodir___0[13]  = 
#line 93
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info_appledouble___0[207UL + sizeof(infodir___0)]  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode___0  =    4;
#line 99 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_restricted___0  =    0;
#line 100 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_s_restricted___0  =    0;
#line 103 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char init_buffer___0[128]  ;
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *buffer___0  =    & init_buffer___0[0];
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *rbuffer___0  =    (char *)((void *)0);
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *dbuffer___0  =    (char *)((void *)0);
#line 106 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *ptr___0  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long rsz___0  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long dsz___0  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long totsize___0  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long maxsize___0  ;
#line 606 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___0(void) 
{ 
  struct stat stbuf ;
  int error ;
  int tmp ;

  {
  {
#line 610
  error = 0;
#line 612
  tmp = stat((char const   */* __restrict  */)(infodir___0), (struct stat */* __restrict  */)(& stbuf));
  }
#line 612
  if (tmp < 0) {
#line 613
    error ++;
  } else
#line 615
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 616
    error ++;
  }
#line 619
  if (error) {
    {
#line 620
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not in an AppleDouble folder.\n");
#line 621
    exit(1);
    }
  }
#line 623
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void appledouble_namings___0(void) 
{ 


  {
  {
#line 627
  mk_share_name___0();
#line 628
  sprintf((char */* __restrict  */)(f_info_appledouble___0), (char const   */* __restrict  */)"%s/%s",
          infodir___0, share_name___0);
#line 629
  sprintf((char */* __restrict  */)(f_data___0), (char const   */* __restrict  */)"%s",
          share_name___0);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void wr_appledouble_info___0(FILE *fp ) 
{ 
  FileInfo theinfo ;
  int n ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 638
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 639
  put4(theinfo.fi_magic, 333319UL);
#line 640
  put2(theinfo.fi_version, 1UL);
#line 641
  put4(theinfo.fi_fill5, 5UL);
#line 642
  put4(theinfo.fi_fill6, 2UL);
#line 643
  put4(theinfo.fi_hlen, 589UL);
#line 644
  put4(theinfo.fi_fill7, 3UL);
#line 645
  put4(theinfo.fi_namptr, 86UL);
#line 646
  put4(theinfo.fi_fill9, 4UL);
#line 647
  put4(theinfo.fi_commptr, 341UL);
#line 648
  put4(theinfo.fi_fill12, 7UL);
#line 649
  put4(theinfo.fi_timeptr, 541UL);
#line 650
  put4(theinfo.fi_timesize, 16UL);
#line 651
  put4(theinfo.fi_fill15, 9UL);
#line 652
  put4(theinfo.fi_infoptr, 557UL);
#line 653
  put4(theinfo.fi_infosize, 32UL);
#line 655
  bcopy(buffer___0 + 65, theinfo.fi_type, 4);
#line 656
  bcopy(buffer___0 + 69, theinfo.fi_auth, 4);
#line 657
  bcopy(buffer___0 + 73, theinfo.fi_finfo, 2);
#line 659
  tmp = get4(buffer___0 + 91);
#line 659
  put4(theinfo.fi_ctime, tmp - 2082844800UL);
#line 660
  tmp___0 = get4(buffer___0 + 95);
#line 660
  put4(theinfo.fi_mtime, tmp___0 - 2082844800UL);
#line 661
  n = (int )*(buffer___0 + 1) & 255;
  }
#line 661
  if (n > 63) {
#line 662
    n = 63;
  }
  {
#line 664
  put4(theinfo.fi_namlen, (unsigned long )n);
#line 665
  strncpy(theinfo.fi_name, (buffer___0 + 1) + 1, n);
#line 667
  strcpy(theinfo.fi_comment, "Converted by Unix utility to AppleDouble format");
#line 669
  tmp___1 = (int )strlen(theinfo.fi_comment);
#line 669
  put4(theinfo.fi_commsize, (unsigned long )tmp___1);
#line 670
  put4(theinfo.fi_rsrc, rsz___0);
#line 674
  fwrite((void const   */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
         (FILE */* __restrict  */)fp);
  }
#line 675
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void mk_share_name___0(void) 
{ 
  int ch ;
  char *mp ;
  char *up ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 683
  mp = buffer___0 + 2;
#line 684
  up = & share_name___0[0];
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    tmp___5 = mp;
#line 685
    mp ++;
#line 685
    ch = (int )*tmp___5;
#line 685
    if (! ch) {
#line 685
      goto while_break;
    }
#line 686
    if ((ch & -128) == 0) {
      {
#line 686
      tmp___3 = __ctype_b_loc();
      }
#line 686
      if ((int const   )*(*tmp___3 + ch) & 2) {
#line 686
        goto _L___1;
      } else {
        {
#line 686
        tmp___4 = __ctype_b_loc();
        }
#line 686
        if ((int const   )*(*tmp___4 + ch) & 16384) {
#line 686
          if (ch != 47) {
#line 687
            tmp = up;
#line 687
            up ++;
#line 687
            *tmp = (char )ch;
          } else {
#line 686
            goto _L___1;
          }
        } else {
#line 686
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 689
      tmp___0 = up;
#line 689
      up ++;
#line 689
      *tmp___0 = (char )':';
#line 690
      tmp___1 = up;
#line 690
      up ++;
#line 690
      *tmp___1 = hex___0[(ch >> 4) & 15];
#line 691
      tmp___2 = up;
#line 691
      up ++;
#line 691
      *tmp___2 = hex___0[ch & 15];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  *up = (char)0;
#line 695
  return;
}
}
#line 817 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char options___1[20]  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macsave.c"
static void usage___0(void) ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macsave.c"
static char options___2[128]  ;
#line 91 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macsave.c"
static void usage___0(void) 
{ 


  {
  {
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: macsave [-%s]\n",
          options___2);
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"macsave -H\" for help.\n");
  }
#line 95
  return;
}
}
#line 7 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
char text[64] ;
#line 9
int write_it ;
#line 7 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/mcb.c"
static int mcb_read  ;
#line 9
static void mcb_wrfile(unsigned long ibytes ) ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/mcb.c"
void mcb(char *hdr , unsigned long rsrcLength , unsigned long dataLength , int toread___0 ) 
{ 
  register int i ;
  int n ;
  char ftype[5] ;
  char fauth[5] ;

  {
#line 20
  mcb_read = toread___0;
#line 21
  i = 0;
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    if (! (i < 128)) {
#line 21
      goto while_break;
    }
#line 22
    info[i] = *(hdr + i);
#line 21
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  n = (int )*(hdr + 1) & 255;
#line 26
  if (n > 63) {
#line 27
    n = 63;
  }
  {
#line 29
  info[1] = (char )n;
#line 30
  transname((hdr + 1) + 1, text, n);
  }
#line 31
  if ((int )*(hdr + 81) & 1) {
#line 32
    *(hdr + 74) = (char)64;
#line 33
    *(hdr + 81) = (char )((int )*(hdr + 81) & -2);
  }
#line 36
  write_it = 1;
#line 37
  if (list) {
    {
#line 38
    transname(hdr + 65, ftype, 4);
#line 39
    transname(hdr + 69, fauth, 4);
#line 40
    do_indent(indent);
#line 41
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )dataLength, (long )rsrcLength);
    }
#line 44
    if (info_only) {
#line 45
      write_it = 0;
    }
#line 47
    if (query) {
      {
#line 48
      write_it = do_query();
      }
    } else {
      {
#line 50
      fputc('\n', stderr);
      }
    }
  }
#line 54
  if (write_it) {
    {
#line 55
    define_name(text);
#line 56
    start_info(info, rsrcLength, dataLength);
#line 57
    start_data();
    }
  }
  {
#line 59
  mcb_wrfile(dataLength);
  }
#line 60
  if (write_it) {
    {
#line 61
    start_rsrc();
    }
  }
  {
#line 63
  mcb_wrfile(rsrcLength);
  }
#line 64
  if (write_it) {
    {
#line 65
    end_file();
    }
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/mcb.c"
static void mcb_wrfile(unsigned long ibytes ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 74
  if (write_it) {
#line 75
    if (ibytes == 0UL) {
#line 76
      return;
    }
    {
#line 78
    tmp = fread((void */* __restrict  */)out_buffer, (size_t )1, (size_t )((int )ibytes),
                (FILE */* __restrict  */)infp);
#line 78
    n = (int )tmp;
    }
#line 79
    if ((unsigned long )n != ibytes) {
      {
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 81
      exit(1);
      }
    }
#line 83
    mcb_read -= n;
#line 84
    n = ((n + 127) / 128) * 128 - n;
#line 85
    if (n > mcb_read) {
#line 86
      n = mcb_read;
    }
#line 88
    mcb_read -= n;
    {
#line 89
    while (1) {
      while_continue: /* CIL Label */ ;
#line 89
      tmp___1 = n;
#line 89
      n --;
#line 89
      if (! (tmp___1 > 0)) {
#line 89
        goto while_break;
      }
      {
#line 90
      tmp___0 = _IO_getc(infp);
      }
#line 90
      if (tmp___0 == -1) {
        {
#line 91
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 92
        exit(1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 96
    n = (int )(((ibytes + 127UL) / 128UL) * 128UL);
#line 97
    if (n > mcb_read) {
#line 98
      n = mcb_read;
    }
#line 100
    mcb_read -= n;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      tmp___3 = n;
#line 101
      n --;
#line 101
      if (! (tmp___3 > 0)) {
#line 101
        goto while_break___0;
      }
      {
#line 102
      tmp___2 = _IO_getc(infp);
      }
#line 102
      if (tmp___2 == -1) {
        {
#line 103
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 104
        exit(1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 108
  return;
}
}
#line 7 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
char text[64]  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int list  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int query  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int write_it  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int indent  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int dir_skip  ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
FILE *infp  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int in_ds  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int in_rs  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int ds_skip  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.h"
int rs_skip  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.c"
int in_data_size  =    -1;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/globals.c"
int in_rsrc_size  =    -1;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___1[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 6 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.h"
char file_info[128]  ;
#line 10
void setup(int argc , char **argv ) ;
#line 11
int nextfile(void) ;
#line 12
char *get_minb(void) ;
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfileopt.h"
int rdfileopt(char c ) ;
#line 2
void give_rdfileopt(void) ;
#line 3
void set_norecurse(void) ;
#line 4
char *get_rdfileopt(void) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files(int initial ) ;
#line 53
static void read_file(void) ;
#line 54
static void enter_dir(void) ;
#line 55
static void exit_dir(void) ;
#line 56
static int get_stdin_file(void) ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_data_size___0  ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_rsrc_size___0  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int data_only  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int no_recurse  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int read_stdin  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist global_files  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist *current_files  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_auth[5]  ;
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_type[5]  ;
#line 81 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_name[12]  = 
#line 81
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 91 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char infodir___1[13]  = 
#line 91
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 92
static void read_appledouble_info(FILE *fd ) ;
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char filename[255]  ;
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int filekind  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
void setup(int argc , char **argv ) 
{ 


  {
#line 102
  if (argc == 0) {
#line 103
    read_stdin = 1;
  } else {
    {
#line 105
    read_stdin = 0;
#line 106
    global_files.previous = (struct filelist *)((void *)0);
#line 107
    global_files.nfiles = argc;
#line 108
    global_files.files = argv;
#line 109
    global_files.current = 0;
#line 110
    current_files = & global_files;
#line 111
    check_files(1);
    }
  }
#line 113
  return;
}
}
#line 182
extern int ( /* missing proto */  strcmp)() ;
#line 115 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files(int initial ) 
{ 
  struct stat stbuf ;
  int i ;
  int j ;
  int n ;
  char filename___2[255] ;
  char filename1[255] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 123
  current_files->current = 0;
#line 125
  n = current_files->nfiles;
#line 126
  tmp = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 126
  current_files->kind = (int *)tmp;
  }
#line 127
  if ((unsigned long )current_files->kind == (unsigned long )((void *)0)) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory\n");
#line 129
    exit(1);
    }
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < n)) {
#line 131
      goto while_break;
    }
    {
#line 132
    *(current_files->kind + i) = 0;
#line 133
    tmp___0 = stat((char const   */* __restrict  */)*(current_files->files + i), (struct stat */* __restrict  */)(& stbuf));
    }
#line 133
    if (tmp___0 >= 0) {
#line 134
      if ((stbuf.st_mode & 61440U) == 16384U) {
#line 136
        *(current_files->kind + i) = 6;
#line 137
        goto __Cont;
      }
#line 139
      *(current_files->kind + i) = 1;
    }
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (data_only) {
#line 144
    return;
  }
  {
#line 148
  i = 1;
#line 166
  tmp___1 = stat((char const   */* __restrict  */)(infodir___1), (struct stat */* __restrict  */)(& stbuf));
  }
#line 166
  if (tmp___1 < 0) {
#line 167
    i = 0;
  } else
#line 169
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 170
    i = 0;
  }
#line 174
  current_files->shared_dir = i;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < n)) {
#line 176
      goto while_break___0;
    }
#line 177
    if (*(current_files->kind + i) == 0) {
#line 178
      j = 0;
    } else
#line 179
    if (*(current_files->kind + i) == 1) {
#line 182
      if (! current_files->shared_dir) {
        {
#line 182
        tmp___2 = strcmp(*(current_files->files + i), f_name);
        }
#line 182
        if (! tmp___2) {
#line 184
          *(current_files->kind + i) = 4;
#line 185
          goto __Cont___0;
        }
      }
#line 193
      j = 1;
    } else
#line 194
    if (*(current_files->kind + i) == 4) {
#line 195
      goto __Cont___0;
    } else
#line 196
    if (! initial) {
      {
#line 198
      tmp___3 = strcmp(*(current_files->files + i), ".");
      }
#line 198
      if (tmp___3) {
        {
#line 198
        tmp___4 = strcmp(*(current_files->files + i), "..");
        }
#line 198
        if (! tmp___4) {
#line 200
          *(current_files->kind + i) = 4;
        }
      } else {
#line 200
        *(current_files->kind + i) = 4;
      }
#line 211
      if (current_files->shared_dir) {
        {
#line 211
        tmp___5 = strcmp(*(current_files->files + i), infodir___1);
        }
#line 211
        if (! tmp___5) {
#line 213
          *(current_files->kind + i) = 4;
        }
      }
#line 217
      goto __Cont___0;
    } else {
#line 219
      goto __Cont___0;
    }
#line 223
    if (j & current_files->shared_dir) {
      {
#line 224
      j = 0;
#line 225
      filename___2[0] = (char)0;
#line 226
      strcat(filename___2, infodir___1);
#line 227
      strcat(filename___2, "/");
#line 228
      strcat(filename___2, *(current_files->files + i));
#line 230
      tmp___6 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 230
      if (tmp___6 >= 0) {
#line 231
        *(current_files->kind + i) = 7;
#line 232
        goto __Cont___0;
      }
    }
#line 237
    if (! j) {
      {
#line 238
      filename___2[0] = (char)0;
#line 239
      strcat(filename___2, *(current_files->files + i));
#line 240
      strcat(filename___2, ".info");
#line 242
      tmp___7 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 242
      if (tmp___7 >= 0) {
#line 243
        *(current_files->kind + i) = 3;
      }
#line 245
      goto __Cont___0;
    }
    {
#line 249
    tmp___8 = (int )strlen(*(current_files->files + i));
#line 249
    j = tmp___8 - 5;
#line 250
    tmp___11 = strncmp(*(current_files->files + i) + j, ".info", 5);
    }
#line 250
    if (! tmp___11) {
      {
#line 252
      *(current_files->kind + i) = 2;
#line 255
      filename___2[0] = (char)0;
#line 256
      strcat(filename___2, *(current_files->files + i));
#line 257
      filename___2[j] = (char)0;
#line 258
      strcpy(filename1, filename___2);
#line 259
      strcat(filename___2, ".data");
#line 260
      strcat(filename1, ".rsrc");
#line 261
      j = i + 1;
      }
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (j < n)) {
#line 261
          goto while_break___1;
        }
        {
#line 262
        tmp___9 = strcmp(filename___2, *(current_files->files + j));
        }
#line 262
        if (! tmp___9) {
#line 264
          *(current_files->kind + j) = 4;
#line 265
          goto __Cont___1;
        }
        {
#line 267
        tmp___10 = strcmp(filename1, *(current_files->files + j));
        }
#line 267
        if (! tmp___10) {
#line 269
          *(current_files->kind + j) = 4;
        }
        __Cont___1: /* CIL Label */ 
#line 261
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 272
      goto __Cont___0;
    }
    {
#line 274
    tmp___13 = strncmp(*(current_files->files + i) + j, ".data", 5);
    }
#line 274
    if (tmp___13) {
      {
#line 274
      tmp___14 = strncmp(*(current_files->files + i) + j, ".rsrc", 5);
      }
#line 274
      if (! tmp___14) {
        _L: /* CIL Label */ 
        {
#line 278
        filename___2[0] = (char)0;
#line 279
        strcat(filename___2, *(current_files->files + i));
#line 280
        filename___2[j] = (char)0;
#line 281
        strcat(filename___2, ".info");
#line 282
        j = i + 1;
        }
        {
#line 282
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 282
          if (! (j < n)) {
#line 282
            goto while_break___2;
          }
          {
#line 283
          tmp___12 = strcmp(filename___2, *(current_files->files + j));
          }
#line 283
          if (! tmp___12) {
#line 285
            *(current_files->kind + i) = 4;
#line 286
            goto while_break___2;
          }
#line 282
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 289
        if (j < n) {
#line 290
          goto __Cont___0;
        }
      }
    } else {
#line 274
      goto _L;
    }
#line 294
    *(current_files->kind + i) = 5;
    __Cont___0: /* CIL Label */ 
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
int nextfile(void) 
{ 
  int i ;
  int tmp ;

  {
#line 302
  if (read_stdin) {
    {
#line 303
    tmp = get_stdin_file();
    }
#line 303
    return (tmp);
  }
#line 305
  i = current_files->current;
  again: 
#line 307
  if (i == current_files->nfiles) {
#line 308
    if ((unsigned long )current_files->previous == (unsigned long )((void *)0)) {
#line 309
      return (0);
    } else {
      {
#line 311
      exit_dir();
#line 312
      (current_files->current) ++;
      }
#line 313
      return (3);
    }
  }
  {
#line 316
  filename[0] = (char)0;
#line 317
  strcat(filename, *(current_files->files + i));
#line 318
  filekind = *(current_files->kind + i);
  }
  {
#line 320
  if (filekind == 6) {
#line 320
    goto case_6;
  }
#line 329
  if (filekind == 4) {
#line 329
    goto case_4;
  }
#line 333
  if (filekind == 0) {
#line 333
    goto case_0;
  }
#line 336
  goto switch_default;
  case_6: /* CIL Label */ 
#line 321
  if (no_recurse) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Directory %s skipped.\n",
            filename);
#line 323
    i ++;
#line 324
    current_files->current = i;
    }
#line 325
    goto again;
  }
  {
#line 327
  enter_dir();
  }
#line 328
  return (2);
  case_4: /* CIL Label */ 
#line 330
  i ++;
#line 331
  current_files->current = i;
#line 332
  goto again;
  case_0: /* CIL Label */ 
  {
#line 334
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File %s not found.\n",
          filename);
#line 335
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 337
  read_file();
#line 338
  current_files->current = i + 1;
  }
#line 339
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 343 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_file(void) 
{ 
  FILE *fd ;
  int c ;
  int j ;
  int lname ;
  int skip ;
  struct stat stbuf ;
  char filename1[255] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  unsigned long tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
  {
#line 353
  if (filekind == 1) {
#line 353
    goto case_1;
  }
#line 437
  if (filekind == 3) {
#line 437
    goto case_3;
  }
#line 439
  if (filekind == 2) {
#line 439
    goto case_2;
  }
#line 492
  if (filekind == 5) {
#line 492
    goto case_5;
  }
#line 545
  if (filekind == 7) {
#line 545
    goto case_7;
  }
#line 352
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 354
  tmp = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& stbuf));
  }
#line 354
  if (tmp < 0) {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot stat file %s\n",
            filename);
#line 356
    exit(1);
    }
  }
#line 358
  j = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (j < 128)) {
#line 358
      goto while_break;
    }
#line 359
    file_info[j] = (char)0;
#line 358
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  strcpy((file_info + 1) + 1, filename);
#line 362
  tmp___0 = (int )strlen(filename);
#line 362
  file_info[1] = (char )tmp___0;
#line 363
  put4(file_info + 91, (unsigned long )stbuf.st_ctim.tv_sec + 2082844800UL);
#line 364
  put4(file_info + 95, (unsigned long )stbuf.st_mtim.tv_sec + 2082844800UL);
  }
#line 365
  if (data_only == 2) {
#line 366
    rsrc_size = (int )stbuf.st_size;
#line 367
    data_size = 0;
#line 368
    if (rsrc_size > max_rsrc_size___0) {
#line 369
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 370
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 372
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 374
      max_rsrc_size___0 = rsrc_size;
    }
#line 376
    if ((int )f_type[0] == 0) {
      {
#line 377
      strncpy(file_info + 65, "RSRC", 4);
      }
    } else {
      {
#line 379
      strncpy(file_info + 65, f_type, 4);
      }
    }
#line 381
    if ((int )f_auth[0] == 0) {
      {
#line 382
      strncpy(file_info + 69, "RSED", 4);
      }
    } else {
      {
#line 384
      strncpy(file_info + 69, f_auth, 4);
      }
    }
    {
#line 386
    put4(file_info + 87, (unsigned long )rsrc_size);
#line 387
    fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 387
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename);
#line 389
      exit(1);
      }
    }
    {
#line 391
    tmp___1 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 391
    if (tmp___1 != (size_t )rsrc_size) {
      {
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename);
#line 393
      exit(1);
      }
    }
    {
#line 395
    fclose(fd);
    }
  } else {
#line 397
    data_size = (int )stbuf.st_size;
#line 398
    rsrc_size = 0;
#line 399
    if (data_size > max_data_size___0) {
#line 400
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 401
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 403
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 405
      max_data_size___0 = data_size;
    }
#line 407
    if ((int )f_type[0] == 0) {
      {
#line 408
      strncpy(file_info + 65, "TEXT", 4);
      }
    } else {
      {
#line 410
      strncpy(file_info + 65, f_type, 4);
      }
    }
#line 412
    if ((int )f_auth[0] == 0) {
      {
#line 413
      strncpy(file_info + 69, "MACA", 4);
      }
    } else {
      {
#line 415
      strncpy(file_info + 69, f_auth, 4);
      }
    }
    {
#line 417
    put4(file_info + 83, (unsigned long )data_size);
#line 418
    fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 418
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename);
#line 420
      exit(1);
      }
    }
    {
#line 422
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 422
    if (tmp___2 != (size_t )data_size) {
      {
#line 423
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename);
#line 424
      exit(1);
      }
    }
    {
#line 426
    fclose(fd);
    }
#line 427
    if (data_only == 3) {
#line 428
      j = 0;
      {
#line 428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 428
        if (! (j < data_size)) {
#line 428
          goto while_break___0;
        }
#line 429
        c = (int )*(data_fork + j);
#line 430
        if (c == 10) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        } else
#line 430
        if (c == 13) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        }
#line 428
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 436
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 438
  strcat(filename, ".info");
  }
  case_2: /* CIL Label */ 
  {
#line 440
  tmp___3 = (int )strlen(filename);
#line 440
  lname = tmp___3 - 5;
#line 441
  fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 441
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename);
#line 443
    exit(1);
    }
  }
  {
#line 445
  tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 445
  if (tmp___4 != 128UL) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read info header %s\n",
            filename);
    }
  }
  {
#line 448
  fclose(fd);
#line 449
  tmp___5 = get4(file_info + 83);
#line 449
  data_size = (int )tmp___5;
#line 450
  tmp___6 = get4(file_info + 87);
#line 450
  rsrc_size = (int )tmp___6;
  }
#line 451
  if (data_size > max_data_size___0) {
#line 452
    if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
      {
#line 453
      data_fork = malloc((unsigned int )data_size);
      }
    } else {
      {
#line 455
      data_fork = realloc(data_fork, (unsigned int )data_size);
      }
    }
#line 457
    max_data_size___0 = data_size;
  }
#line 459
  if (rsrc_size > max_rsrc_size___0) {
#line 460
    if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
      {
#line 461
      rsrc_fork = malloc((unsigned int )rsrc_size);
      }
    } else {
      {
#line 463
      rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
      }
    }
#line 465
    max_rsrc_size___0 = rsrc_size;
  }
#line 467
  if (data_size != 0) {
    {
#line 468
    filename[lname] = (char)0;
#line 469
    strcat(filename, ".data");
#line 470
    fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 470
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open data fork %s\n",
              filename);
#line 472
      exit(1);
      }
    }
    {
#line 474
    tmp___7 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 474
    if (tmp___7 != (size_t )data_size) {
      {
#line 475
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename);
      }
    }
    {
#line 477
    fclose(fd);
    }
  }
#line 479
  if (rsrc_size != 0) {
    {
#line 480
    filename[lname] = (char)0;
#line 481
    strcat(filename, ".rsrc");
#line 482
    fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 482
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 483
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open rsrc fork %s\n",
              filename);
#line 484
      exit(1);
      }
    }
    {
#line 486
    tmp___8 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 486
    if (tmp___8 != (size_t )rsrc_size) {
      {
#line 487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename);
      }
    }
    {
#line 489
    fclose(fd);
    }
  }
#line 491
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 493
  fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 493
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename);
#line 495
    exit(1);
    }
  }
  {
#line 497
  tmp___9 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 497
  if (tmp___9 != 128UL) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
            filename);
#line 499
    exit(1);
    }
  }
#line 501
  if ((int )file_info[0] != 0) {
    {
#line 502
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename);
#line 503
    exit(1);
    }
  }
  {
#line 505
  tmp___10 = get4(file_info + 83);
#line 505
  data_size = (int )tmp___10;
#line 506
  tmp___11 = get4(file_info + 87);
#line 506
  rsrc_size = (int )tmp___11;
  }
#line 507
  if ((int )file_info[81] & 1) {
#line 508
    file_info[74] = (char)64;
#line 509
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 511
  if (data_size != 0) {
#line 512
    if (data_size > max_data_size___0) {
#line 513
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 514
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 516
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 518
      max_data_size___0 = data_size;
    }
    {
#line 520
    tmp___12 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                     (FILE */* __restrict  */)fd);
    }
#line 520
    if (tmp___12 != (size_t )data_size) {
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename);
#line 522
      exit(1);
      }
    }
#line 524
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 525
    j = 0;
    {
#line 525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 525
      if (! (j < skip)) {
#line 525
        goto while_break___1;
      }
      {
#line 526
      fgetc(fd);
#line 525
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 529
  if (rsrc_size != 0) {
#line 530
    if (rsrc_size > max_rsrc_size___0) {
#line 531
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 532
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 534
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 536
      max_rsrc_size___0 = rsrc_size;
    }
    {
#line 538
    tmp___13 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 538
    if (tmp___13 != (size_t )rsrc_size) {
      {
#line 539
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename);
#line 540
      exit(1);
      }
    }
  }
#line 543
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 606
  strcpy(filename1, infodir___1);
#line 607
  strcat(filename1, "/");
#line 608
  strcat(filename1, filename);
#line 609
  fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
  }
#line 609
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename1);
    }
  }
  {
#line 612
  read_appledouble_info(fd);
#line 613
  tmp___14 = get4(file_info + 87);
#line 613
  rsrc_size = (int )tmp___14;
  }
#line 614
  if (rsrc_size > 0) {
#line 615
    if (rsrc_size > max_rsrc_size___0) {
#line 616
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 617
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 619
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 621
      max_rsrc_size___0 = rsrc_size;
    }
    {
#line 623
    tmp___15 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 623
    if (tmp___15 != (size_t )rsrc_size) {
      {
#line 624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename1);
#line 625
      exit(1);
      }
    }
  }
  {
#line 628
  fclose(fd);
#line 629
  tmp___17 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& stbuf));
  }
#line 629
  if (tmp___17 >= 0) {
    {
#line 630
    data_size = (int )stbuf.st_size;
#line 631
    put4(file_info + 83, (unsigned long )data_size);
    }
#line 632
    if (data_size > 0) {
#line 633
      if (data_size > max_data_size___0) {
#line 634
        if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
          {
#line 635
          data_fork = malloc((unsigned int )data_size);
          }
        } else {
          {
#line 637
          data_fork = realloc(data_fork, (unsigned int )data_size);
          }
        }
#line 639
        max_data_size___0 = data_size;
      }
      {
#line 641
      fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
      }
#line 641
      if ((unsigned long )fd == (unsigned long )((void *)0)) {
        {
#line 642
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
                filename);
#line 643
        exit(1);
        }
      }
      {
#line 645
      tmp___16 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                       (FILE */* __restrict  */)fd);
      }
#line 645
      if (tmp___16 != (size_t )data_size) {
        {
#line 646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
                filename1);
#line 647
        exit(1);
        }
      }
      {
#line 649
      fclose(fd);
      }
    }
  }
#line 653
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void enter_dir(void) 
{ 
  DIR *directory ;
  struct dirent *curentry ;
  FILE *fd ;
  int n ;
  int j ;
  int namlen ;
  int listsize ;
  int cursize ;
  char *filetable ;
  filelist *new_files ;
  char filename1[255] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 671
  j = 0;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! (j < 128)) {
#line 671
      goto while_break;
    }
#line 672
    file_info[j] = (char)0;
#line 671
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  strcpy((file_info + 1) + 1, filename);
#line 675
  tmp = (int )strlen(filename);
#line 675
  file_info[1] = (char )tmp;
#line 676
  directory = opendir((char const   *)(filename));
  }
#line 677
  if ((unsigned long )directory == (unsigned long )((void *)0)) {
    {
#line 678
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s\n",
            filename);
#line 679
    exit(1);
    }
  }
  {
#line 681
  listsize = 1024;
#line 682
  filetable = malloc((unsigned int )listsize);
#line 683
  cursize = 0;
#line 684
  n = 0;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 685
    curentry = readdir(directory);
    }
#line 685
    if (! ((unsigned long )curentry != (unsigned long )((void *)0))) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    namlen = (int )strlen(curentry->d_name);
    }
#line 687
    if (namlen + 1 > listsize - cursize) {
      {
#line 688
      listsize += 1024;
#line 689
      filetable = realloc(filetable, (unsigned int )listsize);
      }
    }
    {
#line 691
    strcpy(filetable + cursize, curentry->d_name);
#line 692
    cursize += namlen + 1;
#line 693
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 695
  filetable = realloc(filetable, (unsigned int )cursize);
#line 696
  closedir(directory);
#line 697
  tmp___0 = malloc(sizeof(filelist ));
#line 697
  new_files = (filelist *)tmp___0;
#line 698
  new_files->nfiles = n;
#line 699
  tmp___1 = malloc((unsigned long )((unsigned int )n) * sizeof(char **));
#line 699
  new_files->files = (char **)tmp___1;
#line 700
  tmp___2 = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 700
  new_files->kind = (int *)tmp___2;
#line 701
  new_files->previous = current_files;
#line 702
  new_files->current = 0;
#line 703
  cursize = 0;
#line 704
  j = 0;
  }
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 704
    if (! (j < n)) {
#line 704
      goto while_break___1;
    }
    {
#line 705
    *(new_files->files + j) = filetable + cursize;
#line 706
    tmp___3 = (int )strlen(filetable + cursize);
#line 706
    cursize += tmp___3 + 1;
#line 704
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 708
  chdir(filename);
#line 710
  fd = fopen((char const   */* __restrict  */)(f_name), (char const   */* __restrict  */)"r");
  }
#line 710
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 711
    tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                    (FILE */* __restrict  */)fd);
    }
#line 711
    if (tmp___4 != 128UL) {
      {
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File error on %s\n",
              f_name);
#line 713
      exit(1);
      }
    }
    {
#line 715
    file_info[1] = (char )((int )file_info[1] | 128);
#line 716
    fclose(fd);
    }
  } else {
    {
#line 729
    strcpy(filename1, infodir___1);
#line 730
    strcat(filename1, "/.Parent");
#line 731
    fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
    }
#line 731
    if ((unsigned long )fd != (unsigned long )((void *)0)) {
      {
#line 732
      read_appledouble_info(fd);
#line 733
      fclose(fd);
      }
    }
#line 736
    file_info[1] = (char )((int )file_info[1] | 128);
  }
  {
#line 748
  current_files = new_files;
#line 749
  check_files(0);
  }
#line 750
  return;
}
}
#line 764
extern int free() ;
#line 752 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void exit_dir(void) 
{ 
  filelist *old_files ;
  int i ;

  {
#line 757
  i = 0;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (i < 128)) {
#line 757
      goto while_break;
    }
#line 758
    file_info[i] = (char)0;
#line 757
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  file_info[1] = (char)-128;
#line 761
  old_files = current_files;
#line 763
  current_files = current_files->previous;
#line 764
  free(*(old_files->files + 0));
#line 765
  free((char *)old_files->files);
#line 766
  free((char *)old_files->kind);
#line 767
  free((char *)old_files);
#line 768
  chdir("..");
  }
#line 769
  return;
}
}
#line 838 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_appledouble_info(FILE *fd ) 
{ 
  FileInfo theinfo ;
  int i ;
  int n ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 844
  i = 0;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (i < 128)) {
#line 844
      goto while_break;
    }
#line 845
    file_info[i] = (char)0;
#line 844
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 848
  tmp = fread((void */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
              (FILE */* __restrict  */)fd);
  }
#line 848
  if (tmp != sizeof(theinfo)) {
    {
#line 849
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short AppleDouble info header for %s\n",
            filename);
#line 851
    exit(1);
    }
  }
  {
#line 853
  tmp___0 = get4(theinfo.fi_magic);
  }
#line 853
  if (tmp___0 != 333319UL) {
    {
#line 855
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
            filename);
#line 856
    exit(1);
    }
  } else {
    {
#line 853
    tmp___1 = get2(theinfo.fi_version);
    }
#line 853
    if (tmp___1 != 1UL) {
      {
#line 855
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
              filename);
#line 856
      exit(1);
      }
    }
  }
  {
#line 858
  bcopy(theinfo.fi_type, file_info + 65, 4);
#line 859
  bcopy(theinfo.fi_auth, file_info + 69, 4);
#line 860
  bcopy(theinfo.fi_finfo, file_info + 73, 2);
#line 861
  tmp___2 = get4(theinfo.fi_namlen);
#line 861
  n = (int )tmp___2;
#line 862
  strncpy((file_info + 1) + 1, theinfo.fi_name, n);
#line 863
  file_info[1] = (char )n;
#line 864
  tmp___3 = get4(theinfo.fi_ctime);
#line 864
  put4(file_info + 91, tmp___3 + 2082844800UL);
#line 865
  tmp___4 = get4(theinfo.fi_mtime);
#line 865
  put4(file_info + 95, tmp___4 + 2082844800UL);
#line 866
  tmp___5 = get4(theinfo.fi_rsrc);
#line 866
  rsrc_size = (int )tmp___5;
#line 867
  put4(file_info + 87, (unsigned long )rsrc_size);
  }
#line 868
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int get_stdin_file(void) 
{ 
  int i ;
  int skip ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 876
  i = fgetc(stdin);
  }
#line 877
  if (i == -1) {
#line 878
    return (0);
  }
  {
#line 880
  ungetc(i, stdin);
#line 881
  tmp = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128, (FILE */* __restrict  */)stdin);
  }
#line 881
  if (tmp != 128UL) {
    {
#line 882
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 883
    exit(1);
    }
  }
#line 885
  if ((int )file_info[0] != 0) {
    {
#line 886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename);
#line 887
    exit(1);
    }
  }
  {
#line 889
  tmp___0 = get4(file_info + 83);
#line 889
  data_size = (int )tmp___0;
#line 890
  tmp___1 = get4(file_info + 87);
#line 890
  rsrc_size = (int )tmp___1;
  }
#line 891
  if ((int )file_info[81] & 1) {
#line 892
    file_info[74] = (char)64;
#line 893
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 895
  if (data_size != 0) {
#line 896
    if (data_size > max_data_size___0) {
#line 897
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 898
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 900
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 902
      max_data_size___0 = data_size;
    }
    {
#line 904
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 904
    if (tmp___2 != (size_t )data_size) {
      {
#line 905
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 906
      exit(1);
      }
    }
#line 908
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 909
    i = 0;
    {
#line 909
    while (1) {
      while_continue: /* CIL Label */ ;
#line 909
      if (! (i < skip)) {
#line 909
        goto while_break;
      }
      {
#line 910
      fgetc(stdin);
#line 909
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 913
  if (rsrc_size != 0) {
#line 914
    if (rsrc_size > max_rsrc_size___0) {
#line 915
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 916
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 918
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 920
      max_rsrc_size___0 = rsrc_size;
    }
    {
#line 922
    tmp___3 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 922
    if (tmp___3 != (size_t )rsrc_size) {
      {
#line 923
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 924
      exit(1);
      }
    }
#line 926
    skip = (((rsrc_size + 127) >> 7) << 7) - rsrc_size;
#line 927
    i = 0;
    {
#line 927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 927
      if (! (i < skip)) {
#line 927
        goto while_break___0;
      }
      {
#line 928
      fgetc(stdin);
#line 927
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 931
  if ((int )file_info[1] & 128) {
#line 932
    if (((int )file_info[1] & 255) == 128) {
#line 933
      return (3);
    }
#line 935
    return (2);
  }
#line 937
  return (1);
}
}
#line 940 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
int rdfileopt(char c ) 
{ 
  char name[32] ;

  {
  {
#line 947
  if ((int )c == 100) {
#line 947
    goto case_100;
  }
#line 951
  if ((int )c == 85) {
#line 951
    goto case_85;
  }
#line 951
  if ((int )c == 117) {
#line 951
    goto case_85;
  }
#line 954
  if ((int )c == 114) {
#line 954
    goto case_114;
  }
#line 957
  if ((int )c == 99) {
#line 957
    goto case_99;
  }
#line 961
  if ((int )c == 116) {
#line 961
    goto case_116;
  }
#line 965
  goto switch_default;
  case_100: /* CIL Label */ 
#line 948
  data_only = 1;
#line 949
  goto switch_break;
  case_85: /* CIL Label */ 
  case_117: /* CIL Label */ 
#line 952
  data_only = 3;
#line 953
  goto switch_break;
  case_114: /* CIL Label */ 
#line 955
  data_only = 2;
#line 956
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 958
  backtrans(name, optarg);
#line 959
  strncpy(f_auth, name, 4);
  }
#line 960
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 962
  backtrans(name, optarg);
#line 963
  strncpy(f_type, name, 4);
  }
#line 964
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 966
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 968
  return (1);
}
}
#line 971 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
void give_rdfileopt(void) 
{ 


  {
  {
#line 973
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File input options:\n");
#line 974
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-r:\tread as resource files\n");
#line 975
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-d:\tread as data files\n");
#line 976
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u:\tread as data files with Unix -> Mac text file translation\n");
#line 978
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-U:\ta synonym for -u\n");
#line 979
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c cr:\tcreator if one of the above options is used\n");
#line 981
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-t ty:\tfiletype if one of the above options is used\n");
  }
#line 983
  return;
}
}
#line 985 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
void set_norecurse(void) 
{ 


  {
#line 987
  no_recurse = 1;
#line 988
  return;
}
}
#line 992 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char options___3[9]  = 
#line 992
  {      (char )'r',      (char )'d',      (char )'u',      (char )'U', 
        (char )'c',      (char )':',      (char )'t',      (char )':', 
        (char )'\000'};
#line 990 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
char *get_rdfileopt(void) 
{ 


  {
#line 994
  return (options___3);
}
}
#line 997 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
char *get_minb(void) 
{ 


  {
#line 1004
  return ((char *)", AppleDouble supported");
}
}
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
static char char_mapping___2[256]  = 
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'/', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'_',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char)127, 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static void usage___1(void) ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static char options___4[128]  ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static char *dir_stack___0  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static int dir_ptr___0  =    -64;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static int dir_max___0  ;
#line 178 "/home/wheatley/newnew/temp/macutils-2.0b3/mixed/macstream.c"
static void usage___1(void) 
{ 


  {
  {
#line 180
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: macstream [-%s] files\n",
          options___4);
#line 181
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"macstream -H\" for help.\n");
  }
#line 182
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___3[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
void dofile(void) ;
#line 16
static void usage___2(void) ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
static char options___5[128]  ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
static char *dir_stack___1  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
static int dir_ptr___1  =    -64;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
static int dir_max___1  ;
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
int dorep  =    1;
#line 169 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/binhex.c"
static void usage___2(void) 
{ 


  {
  {
#line 171
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: binhex [-%s] [files]\n",
          options___5);
#line 172
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"binhex -H\" for help.\n");
  }
#line 173
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
static unsigned short crctab___5[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
  {      (unsigned short)0,      (unsigned short)4489,      (unsigned short)8978,      (unsigned short)12955, 
        (unsigned short)17956,      (unsigned short)22445,      (unsigned short)25910,      (unsigned short)29887, 
        (unsigned short)35912,      (unsigned short)40385,      (unsigned short)44890,      (unsigned short)48851, 
        (unsigned short)51820,      (unsigned short)56293,      (unsigned short)59774,      (unsigned short)63735, 
        (unsigned short)4225,      (unsigned short)264,      (unsigned short)13203,      (unsigned short)8730, 
        (unsigned short)22181,      (unsigned short)18220,      (unsigned short)30135,      (unsigned short)25662, 
        (unsigned short)40137,      (unsigned short)36160,      (unsigned short)49115,      (unsigned short)44626, 
        (unsigned short)56045,      (unsigned short)52068,      (unsigned short)63999,      (unsigned short)59510, 
        (unsigned short)8450,      (unsigned short)12427,      (unsigned short)528,      (unsigned short)5017, 
        (unsigned short)26406,      (unsigned short)30383,      (unsigned short)17460,      (unsigned short)21949, 
        (unsigned short)44362,      (unsigned short)48323,      (unsigned short)36440,      (unsigned short)40913, 
        (unsigned short)60270,      (unsigned short)64231,      (unsigned short)51324,      (unsigned short)55797, 
        (unsigned short)12675,      (unsigned short)8202,      (unsigned short)4753,      (unsigned short)792, 
        (unsigned short)30631,      (unsigned short)26158,      (unsigned short)21685,      (unsigned short)17724, 
        (unsigned short)48587,      (unsigned short)44098,      (unsigned short)40665,      (unsigned short)36688, 
        (unsigned short)64495,      (unsigned short)60006,      (unsigned short)55549,      (unsigned short)51572, 
        (unsigned short)16900,      (unsigned short)21389,      (unsigned short)24854,      (unsigned short)28831, 
        (unsigned short)1056,      (unsigned short)5545,      (unsigned short)10034,      (unsigned short)14011, 
        (unsigned short)52812,      (unsigned short)57285,      (unsigned short)60766,      (unsigned short)64727, 
        (unsigned short)34920,      (unsigned short)39393,      (unsigned short)43898,      (unsigned short)47859, 
        (unsigned short)21125,      (unsigned short)17164,      (unsigned short)29079,      (unsigned short)24606, 
        (unsigned short)5281,      (unsigned short)1320,      (unsigned short)14259,      (unsigned short)9786, 
        (unsigned short)57037,      (unsigned short)53060,      (unsigned short)64991,      (unsigned short)60502, 
        (unsigned short)39145,      (unsigned short)35168,      (unsigned short)48123,      (unsigned short)43634, 
        (unsigned short)25350,      (unsigned short)29327,      (unsigned short)16404,      (unsigned short)20893, 
        (unsigned short)9506,      (unsigned short)13483,      (unsigned short)1584,      (unsigned short)6073, 
        (unsigned short)61262,      (unsigned short)65223,      (unsigned short)52316,      (unsigned short)56789, 
        (unsigned short)43370,      (unsigned short)47331,      (unsigned short)35448,      (unsigned short)39921, 
        (unsigned short)29575,      (unsigned short)25102,      (unsigned short)20629,      (unsigned short)16668, 
        (unsigned short)13731,      (unsigned short)9258,      (unsigned short)5809,      (unsigned short)1848, 
        (unsigned short)65487,      (unsigned short)60998,      (unsigned short)56541,      (unsigned short)52564, 
        (unsigned short)47595,      (unsigned short)43106,      (unsigned short)39673,      (unsigned short)35696, 
        (unsigned short)33800,      (unsigned short)38273,      (unsigned short)42778,      (unsigned short)46739, 
        (unsigned short)49708,      (unsigned short)54181,      (unsigned short)57662,      (unsigned short)61623, 
        (unsigned short)2112,      (unsigned short)6601,      (unsigned short)11090,      (unsigned short)15067, 
        (unsigned short)20068,      (unsigned short)24557,      (unsigned short)28022,      (unsigned short)31999, 
        (unsigned short)38025,      (unsigned short)34048,      (unsigned short)47003,      (unsigned short)42514, 
        (unsigned short)53933,      (unsigned short)49956,      (unsigned short)61887,      (unsigned short)57398, 
        (unsigned short)6337,      (unsigned short)2376,      (unsigned short)15315,      (unsigned short)10842, 
        (unsigned short)24293,      (unsigned short)20332,      (unsigned short)32247,      (unsigned short)27774, 
        (unsigned short)42250,      (unsigned short)46211,      (unsigned short)34328,      (unsigned short)38801, 
        (unsigned short)58158,      (unsigned short)62119,      (unsigned short)49212,      (unsigned short)53685, 
        (unsigned short)10562,      (unsigned short)14539,      (unsigned short)2640,      (unsigned short)7129, 
        (unsigned short)28518,      (unsigned short)32495,      (unsigned short)19572,      (unsigned short)24061, 
        (unsigned short)46475,      (unsigned short)41986,      (unsigned short)38553,      (unsigned short)34576, 
        (unsigned short)62383,      (unsigned short)57894,      (unsigned short)53437,      (unsigned short)49460, 
        (unsigned short)14787,      (unsigned short)10314,      (unsigned short)6865,      (unsigned short)2904, 
        (unsigned short)32743,      (unsigned short)28270,      (unsigned short)23797,      (unsigned short)19836, 
        (unsigned short)50700,      (unsigned short)55173,      (unsigned short)58654,      (unsigned short)62615, 
        (unsigned short)32808,      (unsigned short)37281,      (unsigned short)41786,      (unsigned short)45747, 
        (unsigned short)19012,      (unsigned short)23501,      (unsigned short)26966,      (unsigned short)30943, 
        (unsigned short)3168,      (unsigned short)7657,      (unsigned short)12146,      (unsigned short)16123, 
        (unsigned short)54925,      (unsigned short)50948,      (unsigned short)62879,      (unsigned short)58390, 
        (unsigned short)37033,      (unsigned short)33056,      (unsigned short)46011,      (unsigned short)41522, 
        (unsigned short)23237,      (unsigned short)19276,      (unsigned short)31191,      (unsigned short)26718, 
        (unsigned short)7393,      (unsigned short)3432,      (unsigned short)16371,      (unsigned short)11898, 
        (unsigned short)59150,      (unsigned short)63111,      (unsigned short)50204,      (unsigned short)54677, 
        (unsigned short)41258,      (unsigned short)45219,      (unsigned short)33336,      (unsigned short)37809, 
        (unsigned short)27462,      (unsigned short)31439,      (unsigned short)18516,      (unsigned short)23005, 
        (unsigned short)11618,      (unsigned short)15595,      (unsigned short)3696,      (unsigned short)8185, 
        (unsigned short)63375,      (unsigned short)58886,      (unsigned short)54429,      (unsigned short)50452, 
        (unsigned short)45483,      (unsigned short)40994,      (unsigned short)37561,      (unsigned short)33584, 
        (unsigned short)31687,      (unsigned short)27214,      (unsigned short)22741,      (unsigned short)18780, 
        (unsigned short)15843,      (unsigned short)11370,      (unsigned short)7921,      (unsigned short)3960};
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
static unsigned short crctab___6[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
  {      (unsigned short)0,      (unsigned short)49345,      (unsigned short)49537,      (unsigned short)320, 
        (unsigned short)49921,      (unsigned short)960,      (unsigned short)640,      (unsigned short)49729, 
        (unsigned short)50689,      (unsigned short)1728,      (unsigned short)1920,      (unsigned short)51009, 
        (unsigned short)1280,      (unsigned short)50625,      (unsigned short)50305,      (unsigned short)1088, 
        (unsigned short)52225,      (unsigned short)3264,      (unsigned short)3456,      (unsigned short)52545, 
        (unsigned short)3840,      (unsigned short)53185,      (unsigned short)52865,      (unsigned short)3648, 
        (unsigned short)2560,      (unsigned short)51905,      (unsigned short)52097,      (unsigned short)2880, 
        (unsigned short)51457,      (unsigned short)2496,      (unsigned short)2176,      (unsigned short)51265, 
        (unsigned short)55297,      (unsigned short)6336,      (unsigned short)6528,      (unsigned short)55617, 
        (unsigned short)6912,      (unsigned short)56257,      (unsigned short)55937,      (unsigned short)6720, 
        (unsigned short)7680,      (unsigned short)57025,      (unsigned short)57217,      (unsigned short)8000, 
        (unsigned short)56577,      (unsigned short)7616,      (unsigned short)7296,      (unsigned short)56385, 
        (unsigned short)5120,      (unsigned short)54465,      (unsigned short)54657,      (unsigned short)5440, 
        (unsigned short)55041,      (unsigned short)6080,      (unsigned short)5760,      (unsigned short)54849, 
        (unsigned short)53761,      (unsigned short)4800,      (unsigned short)4992,      (unsigned short)54081, 
        (unsigned short)4352,      (unsigned short)53697,      (unsigned short)53377,      (unsigned short)4160, 
        (unsigned short)61441,      (unsigned short)12480,      (unsigned short)12672,      (unsigned short)61761, 
        (unsigned short)13056,      (unsigned short)62401,      (unsigned short)62081,      (unsigned short)12864, 
        (unsigned short)13824,      (unsigned short)63169,      (unsigned short)63361,      (unsigned short)14144, 
        (unsigned short)62721,      (unsigned short)13760,      (unsigned short)13440,      (unsigned short)62529, 
        (unsigned short)15360,      (unsigned short)64705,      (unsigned short)64897,      (unsigned short)15680, 
        (unsigned short)65281,      (unsigned short)16320,      (unsigned short)16000,      (unsigned short)65089, 
        (unsigned short)64001,      (unsigned short)15040,      (unsigned short)15232,      (unsigned short)64321, 
        (unsigned short)14592,      (unsigned short)63937,      (unsigned short)63617,      (unsigned short)14400, 
        (unsigned short)10240,      (unsigned short)59585,      (unsigned short)59777,      (unsigned short)10560, 
        (unsigned short)60161,      (unsigned short)11200,      (unsigned short)10880,      (unsigned short)59969, 
        (unsigned short)60929,      (unsigned short)11968,      (unsigned short)12160,      (unsigned short)61249, 
        (unsigned short)11520,      (unsigned short)60865,      (unsigned short)60545,      (unsigned short)11328, 
        (unsigned short)58369,      (unsigned short)9408,      (unsigned short)9600,      (unsigned short)58689, 
        (unsigned short)9984,      (unsigned short)59329,      (unsigned short)59009,      (unsigned short)9792, 
        (unsigned short)8704,      (unsigned short)58049,      (unsigned short)58241,      (unsigned short)9024, 
        (unsigned short)57601,      (unsigned short)8640,      (unsigned short)8320,      (unsigned short)57409, 
        (unsigned short)40961,      (unsigned short)24768,      (unsigned short)24960,      (unsigned short)41281, 
        (unsigned short)25344,      (unsigned short)41921,      (unsigned short)41601,      (unsigned short)25152, 
        (unsigned short)26112,      (unsigned short)42689,      (unsigned short)42881,      (unsigned short)26432, 
        (unsigned short)42241,      (unsigned short)26048,      (unsigned short)25728,      (unsigned short)42049, 
        (unsigned short)27648,      (unsigned short)44225,      (unsigned short)44417,      (unsigned short)27968, 
        (unsigned short)44801,      (unsigned short)28608,      (unsigned short)28288,      (unsigned short)44609, 
        (unsigned short)43521,      (unsigned short)27328,      (unsigned short)27520,      (unsigned short)43841, 
        (unsigned short)26880,      (unsigned short)43457,      (unsigned short)43137,      (unsigned short)26688, 
        (unsigned short)30720,      (unsigned short)47297,      (unsigned short)47489,      (unsigned short)31040, 
        (unsigned short)47873,      (unsigned short)31680,      (unsigned short)31360,      (unsigned short)47681, 
        (unsigned short)48641,      (unsigned short)32448,      (unsigned short)32640,      (unsigned short)48961, 
        (unsigned short)32000,      (unsigned short)48577,      (unsigned short)48257,      (unsigned short)31808, 
        (unsigned short)46081,      (unsigned short)29888,      (unsigned short)30080,      (unsigned short)46401, 
        (unsigned short)30464,      (unsigned short)47041,      (unsigned short)46721,      (unsigned short)30272, 
        (unsigned short)29184,      (unsigned short)45761,      (unsigned short)45953,      (unsigned short)29504, 
        (unsigned short)45313,      (unsigned short)29120,      (unsigned short)28800,      (unsigned short)45121, 
        (unsigned short)20480,      (unsigned short)37057,      (unsigned short)37249,      (unsigned short)20800, 
        (unsigned short)37633,      (unsigned short)21440,      (unsigned short)21120,      (unsigned short)37441, 
        (unsigned short)38401,      (unsigned short)22208,      (unsigned short)22400,      (unsigned short)38721, 
        (unsigned short)21760,      (unsigned short)38337,      (unsigned short)38017,      (unsigned short)21568, 
        (unsigned short)39937,      (unsigned short)23744,      (unsigned short)23936,      (unsigned short)40257, 
        (unsigned short)24320,      (unsigned short)40897,      (unsigned short)40577,      (unsigned short)24128, 
        (unsigned short)23040,      (unsigned short)39617,      (unsigned short)39809,      (unsigned short)23360, 
        (unsigned short)39169,      (unsigned short)22976,      (unsigned short)22656,      (unsigned short)38977, 
        (unsigned short)34817,      (unsigned short)18624,      (unsigned short)18816,      (unsigned short)35137, 
        (unsigned short)19200,      (unsigned short)35777,      (unsigned short)35457,      (unsigned short)19008, 
        (unsigned short)19968,      (unsigned short)36545,      (unsigned short)36737,      (unsigned short)20288, 
        (unsigned short)36097,      (unsigned short)19904,      (unsigned short)19584,      (unsigned short)35905, 
        (unsigned short)17408,      (unsigned short)33985,      (unsigned short)34177,      (unsigned short)17728, 
        (unsigned short)34561,      (unsigned short)18368,      (unsigned short)18048,      (unsigned short)34369, 
        (unsigned short)33281,      (unsigned short)17088,      (unsigned short)17280,      (unsigned short)33601, 
        (unsigned short)16640,      (unsigned short)33217,      (unsigned short)32897,      (unsigned short)16448};
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
static unsigned short crctab___7[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___2[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
static unsigned short crctab___8[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static int pos_ptr  ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static char codes[65]  = 
#line 11
  {      (char )'!',      (char )'\"',      (char )'#',      (char )'$', 
        (char )'%',      (char )'&',      (char )'\'',      (char )'(', 
        (char )')',      (char )'*',      (char )'+',      (char )',', 
        (char )'-',      (char )'0',      (char )'1',      (char )'2', 
        (char )'3',      (char )'4',      (char )'5',      (char )'6', 
        (char )'8',      (char )'9',      (char )'@',      (char )'A', 
        (char )'B',      (char )'C',      (char )'D',      (char )'E', 
        (char )'F',      (char )'G',      (char )'H',      (char )'I', 
        (char )'J',      (char )'K',      (char )'L',      (char )'M', 
        (char )'N',      (char )'P',      (char )'Q',      (char )'R', 
        (char )'S',      (char )'T',      (char )'U',      (char )'V', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'h', 
        (char )'i',      (char )'j',      (char )'k',      (char )'l', 
        (char )'m',      (char )'p',      (char )'q',      (char )'r', 
        (char )'\000'};
#line 13 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static int state  ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static int savebits  ;
#line 15 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static int rep_char  ;
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
static int rep_count  ;
#line 18
void doheader(void) ;
#line 19
void dofork(char *fork , int size___0 ) ;
#line 20
void outbyte(int b___1 ) ;
#line 21
void finish(void) ;
#line 22
void outbyte1(int b___1 ) ;
#line 23
void out6bit(char c ) ;
#line 24
void outchar(char c ) ;
#line 28
extern int ( /* missing proto */  printf)() ;
#line 39
extern int ( /* missing proto */  putchar)() ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void dofile(void) 
{ 


  {
  {
#line 28
  printf("(This file must be converted; you knew that already.)\n");
#line 29
  printf("\n");
#line 30
  pos_ptr = 1;
#line 31
  state = 0;
#line 32
  rep_char = -1;
#line 33
  rep_count = 0;
#line 34
  outchar(':');
#line 35
  doheader();
#line 36
  dofork(data_fork, data_size);
#line 37
  dofork(rsrc_fork, rsrc_size);
#line 38
  finish();
#line 39
  putchar(':');
#line 40
  putchar('\n');
  }
#line 41
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void doheader(void) 
{ 
  unsigned long crc___0 ;
  int i ;
  int n ;

  {
  {
#line 48
  crc___0 = binhex_crcinit;
#line 49
  n = (int )file_info[1];
#line 50
  crc___0 = binhex_updcrc(crc___0, file_info + 1, n + 1);
#line 51
  i = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i <= n)) {
#line 51
      goto while_break;
    }
    {
#line 52
    outbyte((int )file_info[1 + i]);
#line 51
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  n = 0;
#line 55
  crc___0 = binhex_updcrc(crc___0, (char *)(& n), 1);
#line 56
  outbyte(0);
#line 57
  crc___0 = binhex_updcrc(crc___0, file_info + 65, 4);
#line 58
  i = 0;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i < 4)) {
#line 58
      goto while_break___0;
    }
    {
#line 59
    outbyte((int )file_info[65 + i]);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 61
  crc___0 = binhex_updcrc(crc___0, file_info + 69, 4);
#line 62
  i = 0;
  }
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if (! (i < 4)) {
#line 62
      goto while_break___1;
    }
    {
#line 63
    outbyte((int )file_info[69 + i]);
#line 62
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 65
  crc___0 = binhex_updcrc(crc___0, file_info + 73, 2);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 66
    if (! (i < 2)) {
#line 66
      goto while_break___2;
    }
    {
#line 67
    outbyte((int )file_info[73 + i]);
#line 66
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 69
  crc___0 = binhex_updcrc(crc___0, file_info + 83, 4);
#line 70
  i = 0;
  }
  {
#line 70
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 70
    if (! (i < 4)) {
#line 70
      goto while_break___3;
    }
    {
#line 71
    outbyte((int )file_info[83 + i]);
#line 70
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 73
  crc___0 = binhex_updcrc(crc___0, file_info + 87, 4);
#line 74
  i = 0;
  }
  {
#line 74
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 74
    if (! (i < 4)) {
#line 74
      goto while_break___4;
    }
    {
#line 75
    outbyte((int )file_info[87 + i]);
#line 74
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 77
  outbyte((int )(crc___0 >> 8));
#line 78
  outbyte((int )(crc___0 & 255UL));
  }
#line 79
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void dofork(char *fork , int size___0 ) 
{ 
  unsigned long crc___0 ;
  int i ;

  {
  {
#line 88
  crc___0 = binhex_updcrc(binhex_crcinit, fork, size___0);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < size___0)) {
#line 89
      goto while_break;
    }
    {
#line 90
    outbyte((int )*(fork + i));
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  outbyte((int )(crc___0 >> 8));
#line 93
  outbyte((int )(crc___0 & 255UL));
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void outbyte(int b___1 ) 
{ 
  int tmp ;

  {
#line 99
  b___1 &= 255;
#line 100
  if (dorep) {
#line 100
    if (b___1 == rep_char) {
#line 101
      rep_count ++;
#line 101
      if (rep_count == 254) {
        {
#line 102
        outbyte1(144);
#line 103
        outbyte1(255);
#line 104
        rep_char = -1;
#line 105
        rep_count = 0;
        }
      }
    } else {
#line 100
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 108
    if (rep_count > 0) {
#line 109
      if (rep_count > 3) {
        {
#line 110
        outbyte1(144);
#line 111
        outbyte1(rep_count + 1);
        }
      } else {
        {
#line 113
        while (1) {
          while_continue: /* CIL Label */ ;
#line 113
          tmp = rep_count;
#line 113
          rep_count --;
#line 113
          if (! (tmp > 0)) {
#line 113
            goto while_break;
          }
          {
#line 114
          outbyte1(rep_char);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 118
    outbyte1(b___1);
    }
#line 119
    if (b___1 == 144) {
      {
#line 120
      outbyte1(0);
#line 121
      rep_char = -1;
      }
    } else {
#line 123
      rep_char = b___1;
    }
#line 125
    rep_count = 0;
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void finish(void) 
{ 
  int tmp ;

  {
#line 131
  if (rep_count > 0) {
#line 132
    if (rep_count > 3) {
      {
#line 133
      outbyte1(144);
#line 134
      outbyte1(rep_count + 1);
      }
    } else {
      {
#line 136
      while (1) {
        while_continue: /* CIL Label */ ;
#line 136
        tmp = rep_count;
#line 136
        rep_count --;
#line 136
        if (! (tmp > 0)) {
#line 136
          goto while_break;
        }
        {
#line 137
        outbyte1(rep_char);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 142
  if (state == 1) {
#line 142
    goto case_1;
  }
#line 145
  if (state == 2) {
#line 145
    goto case_2;
  }
#line 148
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 143
  out6bit(savebits << 4);
  }
#line 144
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 146
  out6bit(savebits << 2);
  }
#line 147
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 149
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void outbyte1(int b___1 ) 
{ 


  {
  {
#line 157
  if (state == 0) {
#line 157
    goto case_0;
  }
#line 162
  if (state == 1) {
#line 162
    goto case_1;
  }
#line 168
  if (state == 2) {
#line 168
    goto case_2;
  }
#line 156
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 158
  out6bit(b___1 >> 2);
#line 159
  savebits = b___1 & 3;
#line 160
  state = 1;
  }
#line 161
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 163
  b___1 |= savebits << 8;
#line 164
  out6bit(b___1 >> 4);
#line 165
  savebits = b___1 & 15;
#line 166
  state = 2;
  }
#line 167
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 169
  b___1 |= savebits << 8;
#line 170
  out6bit(b___1 >> 6);
#line 171
  out6bit(b___1 & 63);
#line 172
  state = 0;
  }
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void out6bit(char c ) 
{ 


  {
  {
#line 180
  outchar((int )codes[(int )c & 63]);
  }
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/macutils-2.0b3/binhex/dofile.c"
void outchar(char c ) 
{ 


  {
  {
#line 186
  putchar((int )c);
#line 187
  pos_ptr ++;
  }
#line 187
  if (pos_ptr > 64) {
    {
#line 188
    putchar('\n');
#line 189
    pos_ptr = 1;
    }
  }
#line 191
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
static unsigned long crctab___9[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
  {      0UL,      151466134UL,      302932268UL,      453595578UL, 
        4285383705UL,      4134204559UL,      3982730549UL,      3831797155UL, 
        4275800114UL,      4158437540UL,      3973441822UL,      3855800712UL, 
        28724267UL,      145849533UL,      330837255UL,      448732561UL, 
        4256632932UL,      4105183474UL,      4021907784UL,      3871228382UL, 
        47895677UL,      199091435UL,      282375505UL,      433292743UL, 
        57448534UL,      174827712UL,      291699066UL,      409324012UL, 
        4227947599UL,      4110839001UL,      3993976163UL,      3876064757UL, 
        4218298568UL,      4066971742UL,      3915399652UL,      3764875634UL, 
        67364049UL,      218420295UL,      369985021UL,      520795499UL, 
        95791354UL,      213031020UL,      398182870UL,      515701056UL, 
        4208487651UL,      4091501685UL,      3906342351UL,      3788586329UL, 
        114897068UL,      266207290UL,      349655424UL,      500195606UL, 
        4189385909UL,      4038312995UL,      3954873753UL,      3804079375UL, 
        4160927902UL,      4043671560UL,      3926710706UL,      3809208612UL, 
        124746887UL,      241716241UL,      358686123UL,      476458301UL, 
        4141629840UL,      4292571398UL,      3838976188UL,      3990163498UL, 
        162629001UL,      11973919UL,      465560741UL,      314102835UL, 
        134728098UL,      16841012UL,      436840590UL,      319723544UL, 
        4150922683UL,      4268571949UL,      3848563863UL,      3965934593UL, 
        191582708UL,      40657250UL,      426062040UL,      274858062UL, 
        4094072301UL,      4244743547UL,      3859346625UL,      4010787927UL, 
        4122008006UL,      4239911248UL,      3888036074UL,      4005136508UL, 
        182263263UL,      64630089UL,      416513267UL,      299125861UL, 
        229794136UL,      78991822UL,      532414580UL,      381366498UL, 
        4074743105UL,      4225275351UL,      3771843693UL,      3923178747UL, 
        4083804522UL,      4201568764UL,      3781658694UL,      3898652880UL, 
        201600371UL,      84090341UL,      503991391UL,      386759881UL, 
        4026888508UL,      4177674666UL,      3792375824UL,      3943440518UL, 
        258520357UL,      107972019UL,      493278217UL,      341959839UL, 
        249493774UL,      131713432UL,      483432482UL,      366454964UL, 
        4055055639UL,      4172549505UL,      3820837947UL,      3938086061UL, 
        3988292384UL,      3837768630UL,      4290175500UL,      4138848922UL, 
        315967289UL,      466778031UL,      14362133UL,      165418627UL, 
        325258002UL,      442776452UL,      23947838UL,      141187752UL, 
        3960393483UL,      3842637725UL,      4261457447UL,      4144471729UL, 
        269456196UL,      419996626UL,      33682024UL,      184992510UL, 
        4016199517UL,      3865405387UL,      4251727473UL,      4100654823UL, 
        4006878070UL,      3889376224UL,      4242176602UL,      4124920524UL, 
        297394031UL,      415166457UL,      62373443UL,      179343061UL, 
        383165416UL,      533828478UL,      81314500UL,      232780370UL, 
        3921373169UL,      3770439527UL,      4222944989UL,      4071765579UL, 
        3893177306UL,      3775535948UL,      4194519798UL,      4077156960UL, 
        392228803UL,      510123861UL,      91131631UL,      208256633UL, 
        3949048716UL,      3798369050UL,      4184855200UL,      4033405494UL, 
        336361365UL,      487278339UL,      100800185UL,      251995695UL, 
        364526526UL,      482151208UL,      129260178UL,      246639108UL, 
        3940024231UL,      3822112561UL,      4175011467UL,      4057902621UL, 
        459588272UL,      308539942UL,      157983644UL,      7181066UL, 
        3825796777UL,      3977131583UL,      4127680389UL,      4278212371UL, 
        3854518914UL,      3971512852UL,      4155583406UL,      4273347384UL, 
        450006683UL,      332774925UL,      148697015UL,      31186721UL, 
        3872641748UL,      4023706178UL,      4108170232UL,      4258956142UL, 
        431888077UL,      280569435UL,      196114401UL,      45565815UL, 
        403200742UL,      286222960UL,      168180682UL,      50400092UL, 
        3882196735UL,      3999444585UL,      4117495763UL,      4234989381UL, 
        3758809720UL,      3909997294UL,      4060382036UL,      4211323842UL, 
        526853729UL,      375396087UL,      225003341UL,      74348507UL, 
        517040714UL,      399923932UL,      215944038UL,      98057200UL, 
        3787238995UL,      3904609989UL,      4088582015UL,      4206231529UL, 
        498987548UL,      347783818UL,      263426864UL,      112501670UL, 
        3805296133UL,      3956737683UL,      4041103145UL,      4191774655UL, 
        3815143982UL,      3932244664UL,      4050131714UL,      4168035220UL, 
        470531639UL,      353144481UL,      235265819UL,      117632909UL};
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
static unsigned long crctab___10[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
  {      0UL,      79764919UL,      159529838UL,      222504665UL, 
        319059676UL,      398814059UL,      445009330UL,      507990021UL, 
        638119352UL,      583659535UL,      797628118UL,      726387553UL, 
        890018660UL,      835552979UL,      1015980042UL,      944750013UL, 
        1276238704UL,      1221641927UL,      1167319070UL,      1095957929UL, 
        1595256236UL,      1540665371UL,      1452775106UL,      1381403509UL, 
        1780037320UL,      1859660671UL,      1671105958UL,      1733955601UL, 
        2031960084UL,      2111593891UL,      1889500026UL,      1952343757UL, 
        2552477408UL,      2632100695UL,      2443283854UL,      2506133561UL, 
        2334638140UL,      2414271883UL,      2191915858UL,      2254759653UL, 
        3190512472UL,      3135915759UL,      3081330742UL,      3009969537UL, 
        2905550212UL,      2850959411UL,      2762807018UL,      2691435357UL, 
        3560074640UL,      3505614887UL,      3719321342UL,      3648080713UL, 
        3342211916UL,      3287746299UL,      3467911202UL,      3396681109UL, 
        4063920168UL,      4143685023UL,      4223187782UL,      4286162673UL, 
        3779000052UL,      3858754371UL,      3904687514UL,      3967668269UL, 
        881225847UL,      809987520UL,      1023691545UL,      969234094UL, 
        662832811UL,      591600412UL,      771767749UL,      717299826UL, 
        311336399UL,      374308984UL,      453813921UL,      533576470UL, 
        25881363UL,      88864420UL,      134795389UL,      214552010UL, 
        2023205639UL,      2086057648UL,      1897238633UL,      1976864222UL, 
        1804852699UL,      1867694188UL,      1645340341UL,      1724971778UL, 
        1587496639UL,      1516133128UL,      1461550545UL,      1406951526UL, 
        1302016099UL,      1230646740UL,      1142491917UL,      1087903418UL, 
        2896545431UL,      2825181984UL,      2770861561UL,      2716262478UL, 
        3215044683UL,      3143675388UL,      3055782693UL,      3001194130UL, 
        2326604591UL,      2389456536UL,      2200899649UL,      2280525302UL, 
        2578013683UL,      2640855108UL,      2418763421UL,      2498394922UL, 
        3769900519UL,      3832873040UL,      3912640137UL,      3992402750UL, 
        4088425275UL,      4151408268UL,      4197601365UL,      4277358050UL, 
        3334271071UL,      3263032808UL,      3476998961UL,      3422541446UL, 
        3585640067UL,      3514407732UL,      3694837229UL,      3640369242UL, 
        1762451694UL,      1842216281UL,      1619975040UL,      1682949687UL, 
        2047383090UL,      2127137669UL,      1938468188UL,      2001449195UL, 
        1325665622UL,      1271206113UL,      1183200824UL,      1111960463UL, 
        1543535498UL,      1489069629UL,      1434599652UL,      1363369299UL, 
        622672798UL,      568075817UL,      748617968UL,      677256519UL, 
        907627842UL,      853037301UL,      1067152940UL,      995781531UL, 
        51762726UL,      131386257UL,      177728840UL,      240578815UL, 
        269590778UL,      349224269UL,      429104020UL,      491947555UL, 
        4046411278UL,      4126034873UL,      4172115296UL,      4234965207UL, 
        3794477266UL,      3874110821UL,      3953728444UL,      4016571915UL, 
        3609705398UL,      3555108353UL,      3735388376UL,      3664026991UL, 
        3290680682UL,      3236090077UL,      3449943556UL,      3378572211UL, 
        3174993278UL,      3120533705UL,      3032266256UL,      2961025959UL, 
        2923101090UL,      2868635157UL,      2813903052UL,      2742672763UL, 
        2604032198UL,      2683796849UL,      2461293480UL,      2524268063UL, 
        2284983834UL,      2364738477UL,      2175806836UL,      2238787779UL, 
        1569362073UL,      1498123566UL,      1409854455UL,      1355396672UL, 
        1317987909UL,      1246755826UL,      1192025387UL,      1137557660UL, 
        2072149281UL,      2135122070UL,      1912620623UL,      1992383480UL, 
        1753615357UL,      1816598090UL,      1627664531UL,      1707420964UL, 
        295390185UL,      358241886UL,      404320391UL,      483945776UL, 
        43990325UL,      106832002UL,      186451547UL,      266083308UL, 
        932423249UL,      861060070UL,      1041341759UL,      986742920UL, 
        613929101UL,      542559546UL,      756411363UL,      701822548UL, 
        3316196985UL,      3244833742UL,      3425377559UL,      3370778784UL, 
        3601682597UL,      3530312978UL,      3744426955UL,      3689838204UL, 
        3819031489UL,      3881883254UL,      3928223919UL,      4007849240UL, 
        4037393693UL,      4100235434UL,      4180117107UL,      4259748804UL, 
        2310601993UL,      2373574846UL,      2151335527UL,      2231098320UL, 
        2596047829UL,      2659030626UL,      2470359227UL,      2550115596UL, 
        2947551409UL,      2876312838UL,      2788305887UL,      2733848168UL, 
        3165939309UL,      3094707162UL,      3040238851UL,      2985771188UL};
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
static char char_mapping___4[256]  = 
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'/', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'_',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char)127, 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___5[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files___0(int initial ) ;
#line 53
static void read_file___0(void) ;
#line 54
static void enter_dir___0(void) ;
#line 55
static void exit_dir___0(void) ;
#line 56
static int get_stdin_file___0(void) ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_data_size___1  ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_rsrc_size___1  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int data_only___0  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int no_recurse___0  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int read_stdin___0  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist global_files___0  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist *current_files___0  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_auth___0[5]  ;
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_type___0[5]  ;
#line 81 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_name___0[12]  = 
#line 81
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 91 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char infodir___2[13]  = 
#line 91
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 92
static void read_appledouble_info___0(FILE *fd ) ;
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char filename___0[255]  ;
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int filekind___0  ;
#line 115 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files___0(int initial ) 
{ 
  struct stat stbuf ;
  int i ;
  int j ;
  int n ;
  char filename___2[255] ;
  char filename1[255] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 123
  current_files___0->current = 0;
#line 125
  n = current_files___0->nfiles;
#line 126
  tmp = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 126
  current_files___0->kind = (int *)tmp;
  }
#line 127
  if ((unsigned long )current_files___0->kind == (unsigned long )((void *)0)) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory\n");
#line 129
    exit(1);
    }
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < n)) {
#line 131
      goto while_break;
    }
    {
#line 132
    *(current_files___0->kind + i) = 0;
#line 133
    tmp___0 = stat((char const   */* __restrict  */)*(current_files___0->files + i),
                   (struct stat */* __restrict  */)(& stbuf));
    }
#line 133
    if (tmp___0 >= 0) {
#line 134
      if ((stbuf.st_mode & 61440U) == 16384U) {
#line 136
        *(current_files___0->kind + i) = 6;
#line 137
        goto __Cont;
      }
#line 139
      *(current_files___0->kind + i) = 1;
    }
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (data_only___0) {
#line 144
    return;
  }
  {
#line 148
  i = 1;
#line 166
  tmp___1 = stat((char const   */* __restrict  */)(infodir___2), (struct stat */* __restrict  */)(& stbuf));
  }
#line 166
  if (tmp___1 < 0) {
#line 167
    i = 0;
  } else
#line 169
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 170
    i = 0;
  }
#line 174
  current_files___0->shared_dir = i;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < n)) {
#line 176
      goto while_break___0;
    }
#line 177
    if (*(current_files___0->kind + i) == 0) {
#line 178
      j = 0;
    } else
#line 179
    if (*(current_files___0->kind + i) == 1) {
#line 182
      if (! current_files___0->shared_dir) {
        {
#line 182
        tmp___2 = strcmp(*(current_files___0->files + i), f_name___0);
        }
#line 182
        if (! tmp___2) {
#line 184
          *(current_files___0->kind + i) = 4;
#line 185
          goto __Cont___0;
        }
      }
#line 193
      j = 1;
    } else
#line 194
    if (*(current_files___0->kind + i) == 4) {
#line 195
      goto __Cont___0;
    } else
#line 196
    if (! initial) {
      {
#line 198
      tmp___3 = strcmp(*(current_files___0->files + i), ".");
      }
#line 198
      if (tmp___3) {
        {
#line 198
        tmp___4 = strcmp(*(current_files___0->files + i), "..");
        }
#line 198
        if (! tmp___4) {
#line 200
          *(current_files___0->kind + i) = 4;
        }
      } else {
#line 200
        *(current_files___0->kind + i) = 4;
      }
#line 211
      if (current_files___0->shared_dir) {
        {
#line 211
        tmp___5 = strcmp(*(current_files___0->files + i), infodir___2);
        }
#line 211
        if (! tmp___5) {
#line 213
          *(current_files___0->kind + i) = 4;
        }
      }
#line 217
      goto __Cont___0;
    } else {
#line 219
      goto __Cont___0;
    }
#line 223
    if (j & current_files___0->shared_dir) {
      {
#line 224
      j = 0;
#line 225
      filename___2[0] = (char)0;
#line 226
      strcat(filename___2, infodir___2);
#line 227
      strcat(filename___2, "/");
#line 228
      strcat(filename___2, *(current_files___0->files + i));
#line 230
      tmp___6 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 230
      if (tmp___6 >= 0) {
#line 231
        *(current_files___0->kind + i) = 7;
#line 232
        goto __Cont___0;
      }
    }
#line 237
    if (! j) {
      {
#line 238
      filename___2[0] = (char)0;
#line 239
      strcat(filename___2, *(current_files___0->files + i));
#line 240
      strcat(filename___2, ".info");
#line 242
      tmp___7 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 242
      if (tmp___7 >= 0) {
#line 243
        *(current_files___0->kind + i) = 3;
      }
#line 245
      goto __Cont___0;
    }
    {
#line 249
    tmp___8 = (int )strlen(*(current_files___0->files + i));
#line 249
    j = tmp___8 - 5;
#line 250
    tmp___11 = strncmp(*(current_files___0->files + i) + j, ".info", 5);
    }
#line 250
    if (! tmp___11) {
      {
#line 252
      *(current_files___0->kind + i) = 2;
#line 255
      filename___2[0] = (char)0;
#line 256
      strcat(filename___2, *(current_files___0->files + i));
#line 257
      filename___2[j] = (char)0;
#line 258
      strcpy(filename1, filename___2);
#line 259
      strcat(filename___2, ".data");
#line 260
      strcat(filename1, ".rsrc");
#line 261
      j = i + 1;
      }
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (j < n)) {
#line 261
          goto while_break___1;
        }
        {
#line 262
        tmp___9 = strcmp(filename___2, *(current_files___0->files + j));
        }
#line 262
        if (! tmp___9) {
#line 264
          *(current_files___0->kind + j) = 4;
#line 265
          goto __Cont___1;
        }
        {
#line 267
        tmp___10 = strcmp(filename1, *(current_files___0->files + j));
        }
#line 267
        if (! tmp___10) {
#line 269
          *(current_files___0->kind + j) = 4;
        }
        __Cont___1: /* CIL Label */ 
#line 261
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 272
      goto __Cont___0;
    }
    {
#line 274
    tmp___13 = strncmp(*(current_files___0->files + i) + j, ".data", 5);
    }
#line 274
    if (tmp___13) {
      {
#line 274
      tmp___14 = strncmp(*(current_files___0->files + i) + j, ".rsrc", 5);
      }
#line 274
      if (! tmp___14) {
        _L: /* CIL Label */ 
        {
#line 278
        filename___2[0] = (char)0;
#line 279
        strcat(filename___2, *(current_files___0->files + i));
#line 280
        filename___2[j] = (char)0;
#line 281
        strcat(filename___2, ".info");
#line 282
        j = i + 1;
        }
        {
#line 282
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 282
          if (! (j < n)) {
#line 282
            goto while_break___2;
          }
          {
#line 283
          tmp___12 = strcmp(filename___2, *(current_files___0->files + j));
          }
#line 283
          if (! tmp___12) {
#line 285
            *(current_files___0->kind + i) = 4;
#line 286
            goto while_break___2;
          }
#line 282
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 289
        if (j < n) {
#line 290
          goto __Cont___0;
        }
      }
    } else {
#line 274
      goto _L;
    }
#line 294
    *(current_files___0->kind + i) = 5;
    __Cont___0: /* CIL Label */ 
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_file___0(void) 
{ 
  FILE *fd ;
  int c ;
  int j ;
  int lname ;
  int skip ;
  struct stat stbuf ;
  char filename1[255] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  unsigned long tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
  {
#line 353
  if (filekind___0 == 1) {
#line 353
    goto case_1;
  }
#line 437
  if (filekind___0 == 3) {
#line 437
    goto case_3;
  }
#line 439
  if (filekind___0 == 2) {
#line 439
    goto case_2;
  }
#line 492
  if (filekind___0 == 5) {
#line 492
    goto case_5;
  }
#line 545
  if (filekind___0 == 7) {
#line 545
    goto case_7;
  }
#line 352
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 354
  tmp = stat((char const   */* __restrict  */)(filename___0), (struct stat */* __restrict  */)(& stbuf));
  }
#line 354
  if (tmp < 0) {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot stat file %s\n",
            filename___0);
#line 356
    exit(1);
    }
  }
#line 358
  j = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (j < 128)) {
#line 358
      goto while_break;
    }
#line 359
    file_info[j] = (char)0;
#line 358
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  strcpy((file_info + 1) + 1, filename___0);
#line 362
  tmp___0 = (int )strlen(filename___0);
#line 362
  file_info[1] = (char )tmp___0;
#line 363
  put4(file_info + 91, (unsigned long )stbuf.st_ctim.tv_sec + 2082844800UL);
#line 364
  put4(file_info + 95, (unsigned long )stbuf.st_mtim.tv_sec + 2082844800UL);
  }
#line 365
  if (data_only___0 == 2) {
#line 366
    rsrc_size = (int )stbuf.st_size;
#line 367
    data_size = 0;
#line 368
    if (rsrc_size > max_rsrc_size___1) {
#line 369
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 370
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 372
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 374
      max_rsrc_size___1 = rsrc_size;
    }
#line 376
    if ((int )f_type___0[0] == 0) {
      {
#line 377
      strncpy(file_info + 65, "RSRC", 4);
      }
    } else {
      {
#line 379
      strncpy(file_info + 65, f_type___0, 4);
      }
    }
#line 381
    if ((int )f_auth___0[0] == 0) {
      {
#line 382
      strncpy(file_info + 69, "RSED", 4);
      }
    } else {
      {
#line 384
      strncpy(file_info + 69, f_auth___0, 4);
      }
    }
    {
#line 386
    put4(file_info + 87, (unsigned long )rsrc_size);
#line 387
    fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
    }
#line 387
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename___0);
#line 389
      exit(1);
      }
    }
    {
#line 391
    tmp___1 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 391
    if (tmp___1 != (size_t )rsrc_size) {
      {
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___0);
#line 393
      exit(1);
      }
    }
    {
#line 395
    fclose(fd);
    }
  } else {
#line 397
    data_size = (int )stbuf.st_size;
#line 398
    rsrc_size = 0;
#line 399
    if (data_size > max_data_size___1) {
#line 400
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 401
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 403
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 405
      max_data_size___1 = data_size;
    }
#line 407
    if ((int )f_type___0[0] == 0) {
      {
#line 408
      strncpy(file_info + 65, "TEXT", 4);
      }
    } else {
      {
#line 410
      strncpy(file_info + 65, f_type___0, 4);
      }
    }
#line 412
    if ((int )f_auth___0[0] == 0) {
      {
#line 413
      strncpy(file_info + 69, "MACA", 4);
      }
    } else {
      {
#line 415
      strncpy(file_info + 69, f_auth___0, 4);
      }
    }
    {
#line 417
    put4(file_info + 83, (unsigned long )data_size);
#line 418
    fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
    }
#line 418
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename___0);
#line 420
      exit(1);
      }
    }
    {
#line 422
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 422
    if (tmp___2 != (size_t )data_size) {
      {
#line 423
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___0);
#line 424
      exit(1);
      }
    }
    {
#line 426
    fclose(fd);
    }
#line 427
    if (data_only___0 == 3) {
#line 428
      j = 0;
      {
#line 428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 428
        if (! (j < data_size)) {
#line 428
          goto while_break___0;
        }
#line 429
        c = (int )*(data_fork + j);
#line 430
        if (c == 10) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        } else
#line 430
        if (c == 13) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        }
#line 428
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 436
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 438
  strcat(filename___0, ".info");
  }
  case_2: /* CIL Label */ 
  {
#line 440
  tmp___3 = (int )strlen(filename___0);
#line 440
  lname = tmp___3 - 5;
#line 441
  fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
  }
#line 441
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename___0);
#line 443
    exit(1);
    }
  }
  {
#line 445
  tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 445
  if (tmp___4 != 128UL) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read info header %s\n",
            filename___0);
    }
  }
  {
#line 448
  fclose(fd);
#line 449
  tmp___5 = get4(file_info + 83);
#line 449
  data_size = (int )tmp___5;
#line 450
  tmp___6 = get4(file_info + 87);
#line 450
  rsrc_size = (int )tmp___6;
  }
#line 451
  if (data_size > max_data_size___1) {
#line 452
    if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
      {
#line 453
      data_fork = malloc((unsigned int )data_size);
      }
    } else {
      {
#line 455
      data_fork = realloc(data_fork, (unsigned int )data_size);
      }
    }
#line 457
    max_data_size___1 = data_size;
  }
#line 459
  if (rsrc_size > max_rsrc_size___1) {
#line 460
    if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
      {
#line 461
      rsrc_fork = malloc((unsigned int )rsrc_size);
      }
    } else {
      {
#line 463
      rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
      }
    }
#line 465
    max_rsrc_size___1 = rsrc_size;
  }
#line 467
  if (data_size != 0) {
    {
#line 468
    filename___0[lname] = (char)0;
#line 469
    strcat(filename___0, ".data");
#line 470
    fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
    }
#line 470
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open data fork %s\n",
              filename___0);
#line 472
      exit(1);
      }
    }
    {
#line 474
    tmp___7 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 474
    if (tmp___7 != (size_t )data_size) {
      {
#line 475
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename___0);
      }
    }
    {
#line 477
    fclose(fd);
    }
  }
#line 479
  if (rsrc_size != 0) {
    {
#line 480
    filename___0[lname] = (char)0;
#line 481
    strcat(filename___0, ".rsrc");
#line 482
    fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
    }
#line 482
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 483
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open rsrc fork %s\n",
              filename___0);
#line 484
      exit(1);
      }
    }
    {
#line 486
    tmp___8 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 486
    if (tmp___8 != (size_t )rsrc_size) {
      {
#line 487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename___0);
      }
    }
    {
#line 489
    fclose(fd);
    }
  }
#line 491
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 493
  fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
  }
#line 493
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename___0);
#line 495
    exit(1);
    }
  }
  {
#line 497
  tmp___9 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 497
  if (tmp___9 != 128UL) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
            filename___0);
#line 499
    exit(1);
    }
  }
#line 501
  if ((int )file_info[0] != 0) {
    {
#line 502
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename___0);
#line 503
    exit(1);
    }
  }
  {
#line 505
  tmp___10 = get4(file_info + 83);
#line 505
  data_size = (int )tmp___10;
#line 506
  tmp___11 = get4(file_info + 87);
#line 506
  rsrc_size = (int )tmp___11;
  }
#line 507
  if ((int )file_info[81] & 1) {
#line 508
    file_info[74] = (char)64;
#line 509
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 511
  if (data_size != 0) {
#line 512
    if (data_size > max_data_size___1) {
#line 513
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 514
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 516
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 518
      max_data_size___1 = data_size;
    }
    {
#line 520
    tmp___12 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                     (FILE */* __restrict  */)fd);
    }
#line 520
    if (tmp___12 != (size_t )data_size) {
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___0);
#line 522
      exit(1);
      }
    }
#line 524
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 525
    j = 0;
    {
#line 525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 525
      if (! (j < skip)) {
#line 525
        goto while_break___1;
      }
      {
#line 526
      fgetc(fd);
#line 525
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 529
  if (rsrc_size != 0) {
#line 530
    if (rsrc_size > max_rsrc_size___1) {
#line 531
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 532
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 534
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 536
      max_rsrc_size___1 = rsrc_size;
    }
    {
#line 538
    tmp___13 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 538
    if (tmp___13 != (size_t )rsrc_size) {
      {
#line 539
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___0);
#line 540
      exit(1);
      }
    }
  }
#line 543
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 606
  strcpy(filename1, infodir___2);
#line 607
  strcat(filename1, "/");
#line 608
  strcat(filename1, filename___0);
#line 609
  fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
  }
#line 609
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename1);
    }
  }
  {
#line 612
  read_appledouble_info___0(fd);
#line 613
  tmp___14 = get4(file_info + 87);
#line 613
  rsrc_size = (int )tmp___14;
  }
#line 614
  if (rsrc_size > 0) {
#line 615
    if (rsrc_size > max_rsrc_size___1) {
#line 616
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 617
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 619
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 621
      max_rsrc_size___1 = rsrc_size;
    }
    {
#line 623
    tmp___15 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 623
    if (tmp___15 != (size_t )rsrc_size) {
      {
#line 624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename1);
#line 625
      exit(1);
      }
    }
  }
  {
#line 628
  fclose(fd);
#line 629
  tmp___17 = stat((char const   */* __restrict  */)(filename___0), (struct stat */* __restrict  */)(& stbuf));
  }
#line 629
  if (tmp___17 >= 0) {
    {
#line 630
    data_size = (int )stbuf.st_size;
#line 631
    put4(file_info + 83, (unsigned long )data_size);
    }
#line 632
    if (data_size > 0) {
#line 633
      if (data_size > max_data_size___1) {
#line 634
        if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
          {
#line 635
          data_fork = malloc((unsigned int )data_size);
          }
        } else {
          {
#line 637
          data_fork = realloc(data_fork, (unsigned int )data_size);
          }
        }
#line 639
        max_data_size___1 = data_size;
      }
      {
#line 641
      fd = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"r");
      }
#line 641
      if ((unsigned long )fd == (unsigned long )((void *)0)) {
        {
#line 642
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
                filename___0);
#line 643
        exit(1);
        }
      }
      {
#line 645
      tmp___16 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                       (FILE */* __restrict  */)fd);
      }
#line 645
      if (tmp___16 != (size_t )data_size) {
        {
#line 646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
                filename1);
#line 647
        exit(1);
        }
      }
      {
#line 649
      fclose(fd);
      }
    }
  }
#line 653
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void enter_dir___0(void) 
{ 
  DIR *directory ;
  struct dirent *curentry ;
  FILE *fd ;
  int n ;
  int j ;
  int namlen ;
  int listsize ;
  int cursize ;
  char *filetable ;
  filelist *new_files ;
  char filename1[255] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 671
  j = 0;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! (j < 128)) {
#line 671
      goto while_break;
    }
#line 672
    file_info[j] = (char)0;
#line 671
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  strcpy((file_info + 1) + 1, filename___0);
#line 675
  tmp = (int )strlen(filename___0);
#line 675
  file_info[1] = (char )tmp;
#line 676
  directory = opendir((char const   *)(filename___0));
  }
#line 677
  if ((unsigned long )directory == (unsigned long )((void *)0)) {
    {
#line 678
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s\n",
            filename___0);
#line 679
    exit(1);
    }
  }
  {
#line 681
  listsize = 1024;
#line 682
  filetable = malloc((unsigned int )listsize);
#line 683
  cursize = 0;
#line 684
  n = 0;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 685
    curentry = readdir(directory);
    }
#line 685
    if (! ((unsigned long )curentry != (unsigned long )((void *)0))) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    namlen = (int )strlen(curentry->d_name);
    }
#line 687
    if (namlen + 1 > listsize - cursize) {
      {
#line 688
      listsize += 1024;
#line 689
      filetable = realloc(filetable, (unsigned int )listsize);
      }
    }
    {
#line 691
    strcpy(filetable + cursize, curentry->d_name);
#line 692
    cursize += namlen + 1;
#line 693
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 695
  filetable = realloc(filetable, (unsigned int )cursize);
#line 696
  closedir(directory);
#line 697
  tmp___0 = malloc(sizeof(filelist ));
#line 697
  new_files = (filelist *)tmp___0;
#line 698
  new_files->nfiles = n;
#line 699
  tmp___1 = malloc((unsigned long )((unsigned int )n) * sizeof(char **));
#line 699
  new_files->files = (char **)tmp___1;
#line 700
  tmp___2 = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 700
  new_files->kind = (int *)tmp___2;
#line 701
  new_files->previous = current_files___0;
#line 702
  new_files->current = 0;
#line 703
  cursize = 0;
#line 704
  j = 0;
  }
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 704
    if (! (j < n)) {
#line 704
      goto while_break___1;
    }
    {
#line 705
    *(new_files->files + j) = filetable + cursize;
#line 706
    tmp___3 = (int )strlen(filetable + cursize);
#line 706
    cursize += tmp___3 + 1;
#line 704
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 708
  chdir(filename___0);
#line 710
  fd = fopen((char const   */* __restrict  */)(f_name___0), (char const   */* __restrict  */)"r");
  }
#line 710
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 711
    tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                    (FILE */* __restrict  */)fd);
    }
#line 711
    if (tmp___4 != 128UL) {
      {
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File error on %s\n",
              f_name___0);
#line 713
      exit(1);
      }
    }
    {
#line 715
    file_info[1] = (char )((int )file_info[1] | 128);
#line 716
    fclose(fd);
    }
  } else {
    {
#line 729
    strcpy(filename1, infodir___2);
#line 730
    strcat(filename1, "/.Parent");
#line 731
    fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
    }
#line 731
    if ((unsigned long )fd != (unsigned long )((void *)0)) {
      {
#line 732
      read_appledouble_info___0(fd);
#line 733
      fclose(fd);
      }
    }
#line 736
    file_info[1] = (char )((int )file_info[1] | 128);
  }
  {
#line 748
  current_files___0 = new_files;
#line 749
  check_files___0(0);
  }
#line 750
  return;
}
}
#line 752 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void exit_dir___0(void) 
{ 
  filelist *old_files ;
  int i ;

  {
#line 757
  i = 0;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (i < 128)) {
#line 757
      goto while_break;
    }
#line 758
    file_info[i] = (char)0;
#line 757
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  file_info[1] = (char)-128;
#line 761
  old_files = current_files___0;
#line 763
  current_files___0 = current_files___0->previous;
#line 764
  free(*(old_files->files + 0));
#line 765
  free((char *)old_files->files);
#line 766
  free((char *)old_files->kind);
#line 767
  free((char *)old_files);
#line 768
  chdir("..");
  }
#line 769
  return;
}
}
#line 838 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_appledouble_info___0(FILE *fd ) 
{ 
  FileInfo theinfo ;
  int i ;
  int n ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 844
  i = 0;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (i < 128)) {
#line 844
      goto while_break;
    }
#line 845
    file_info[i] = (char)0;
#line 844
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 848
  tmp = fread((void */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
              (FILE */* __restrict  */)fd);
  }
#line 848
  if (tmp != sizeof(theinfo)) {
    {
#line 849
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short AppleDouble info header for %s\n",
            filename___0);
#line 851
    exit(1);
    }
  }
  {
#line 853
  tmp___0 = get4(theinfo.fi_magic);
  }
#line 853
  if (tmp___0 != 333319UL) {
    {
#line 855
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
            filename___0);
#line 856
    exit(1);
    }
  } else {
    {
#line 853
    tmp___1 = get2(theinfo.fi_version);
    }
#line 853
    if (tmp___1 != 1UL) {
      {
#line 855
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
              filename___0);
#line 856
      exit(1);
      }
    }
  }
  {
#line 858
  bcopy(theinfo.fi_type, file_info + 65, 4);
#line 859
  bcopy(theinfo.fi_auth, file_info + 69, 4);
#line 860
  bcopy(theinfo.fi_finfo, file_info + 73, 2);
#line 861
  tmp___2 = get4(theinfo.fi_namlen);
#line 861
  n = (int )tmp___2;
#line 862
  strncpy((file_info + 1) + 1, theinfo.fi_name, n);
#line 863
  file_info[1] = (char )n;
#line 864
  tmp___3 = get4(theinfo.fi_ctime);
#line 864
  put4(file_info + 91, tmp___3 + 2082844800UL);
#line 865
  tmp___4 = get4(theinfo.fi_mtime);
#line 865
  put4(file_info + 95, tmp___4 + 2082844800UL);
#line 866
  tmp___5 = get4(theinfo.fi_rsrc);
#line 866
  rsrc_size = (int )tmp___5;
#line 867
  put4(file_info + 87, (unsigned long )rsrc_size);
  }
#line 868
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int get_stdin_file___0(void) 
{ 
  int i ;
  int skip ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 876
  i = fgetc(stdin);
  }
#line 877
  if (i == -1) {
#line 878
    return (0);
  }
  {
#line 880
  ungetc(i, stdin);
#line 881
  tmp = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128, (FILE */* __restrict  */)stdin);
  }
#line 881
  if (tmp != 128UL) {
    {
#line 882
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 883
    exit(1);
    }
  }
#line 885
  if ((int )file_info[0] != 0) {
    {
#line 886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename___0);
#line 887
    exit(1);
    }
  }
  {
#line 889
  tmp___0 = get4(file_info + 83);
#line 889
  data_size = (int )tmp___0;
#line 890
  tmp___1 = get4(file_info + 87);
#line 890
  rsrc_size = (int )tmp___1;
  }
#line 891
  if ((int )file_info[81] & 1) {
#line 892
    file_info[74] = (char)64;
#line 893
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 895
  if (data_size != 0) {
#line 896
    if (data_size > max_data_size___1) {
#line 897
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 898
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 900
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 902
      max_data_size___1 = data_size;
    }
    {
#line 904
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 904
    if (tmp___2 != (size_t )data_size) {
      {
#line 905
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 906
      exit(1);
      }
    }
#line 908
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 909
    i = 0;
    {
#line 909
    while (1) {
      while_continue: /* CIL Label */ ;
#line 909
      if (! (i < skip)) {
#line 909
        goto while_break;
      }
      {
#line 910
      fgetc(stdin);
#line 909
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 913
  if (rsrc_size != 0) {
#line 914
    if (rsrc_size > max_rsrc_size___1) {
#line 915
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 916
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 918
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 920
      max_rsrc_size___1 = rsrc_size;
    }
    {
#line 922
    tmp___3 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 922
    if (tmp___3 != (size_t )rsrc_size) {
      {
#line 923
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 924
      exit(1);
      }
    }
#line 926
    skip = (((rsrc_size + 127) >> 7) << 7) - rsrc_size;
#line 927
    i = 0;
    {
#line 927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 927
      if (! (i < skip)) {
#line 927
        goto while_break___0;
      }
      {
#line 928
      fgetc(stdin);
#line 927
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 931
  if ((int )file_info[1] & 128) {
#line 932
    if (((int )file_info[1] & 255) == 128) {
#line 933
      return (3);
    }
#line 935
    return (2);
  }
#line 937
  return (1);
}
}
#line 992 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char options___6[9]  = 
#line 992
  {      (char )'r',      (char )'d',      (char )'u',      (char )'U', 
        (char )'c',      (char )':',      (char )'t',      (char )':', 
        (char )'\000'};
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
static unsigned short crctab___11[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt.c"
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
void clrhuff(void) ;
#line 12
struct node nodelist[515] ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
void de_huffman(unsigned long obytes ) ;
#line 12
void set_huffman(int endian ) ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
static table_struct table[511]  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
static char length[256]  ;
#line 22
static void stf_wrfile(unsigned long rsrcLength , unsigned long dataLength , unsigned long ibytes ) ;
#line 23
static void stf_wrfork(unsigned long *num , unsigned long towrite , int offs ) ;
#line 24
static void stf_construct(int n ) ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
void stf(unsigned long ibytes ) 
{ 
  char magic[3] ;
  char fauth[5] ;
  char ftype[5] ;
  int filel ;
  int i ;
  unsigned int rsrcLength ;
  unsigned int dataLength ;
  unsigned long curtime ;
  unsigned char tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  time_t tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;

  {
  {
#line 34
  set_huffman(1);
#line 35
  i = 0;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < 3)) {
#line 35
      goto while_break;
    }
    {
#line 36
    tmp = getb(infp);
#line 36
    magic[i] = (char )tmp;
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 38
  tmp___0 = strncmp(magic, "RTH", 3);
  }
#line 38
  if (tmp___0) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in magic header.\n");
#line 43
    exit(1);
    }
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 45
    if (! (i < 128)) {
#line 45
      goto while_break___0;
    }
#line 46
    info[i] = (char)0;
#line 45
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 48
  tmp___1 = getb(infp);
#line 48
  filel = (int )tmp___1;
#line 49
  info[1] = (char )filel;
#line 50
  i = filel;
#line 51
  i = 1;
  }
  {
#line 51
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 51
    if (! (i <= filel)) {
#line 51
      goto while_break___1;
    }
    {
#line 52
    tmp___2 = getb(infp);
#line 52
    info[1 + i] = (char )tmp___2;
#line 51
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 54
    if (! (i < 4)) {
#line 54
      goto while_break___2;
    }
    {
#line 55
    tmp___3 = getb(infp);
#line 55
    info[65 + i] = (char )tmp___3;
#line 54
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 57
    if (! (i < 4)) {
#line 57
      goto while_break___3;
    }
    {
#line 58
    tmp___4 = getb(infp);
#line 58
    info[69 + i] = (char )tmp___4;
#line 57
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 60
  tmp___5 = time((time_t *)0);
#line 60
  curtime = (unsigned long )tmp___5 + 2082844800UL;
#line 61
  put4(info + 91, curtime);
#line 62
  put4(info + 95, curtime);
#line 63
  rsrcLength = 0U;
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 64
    if (! (i < 4)) {
#line 64
      goto while_break___4;
    }
    {
#line 65
    tmp___6 = getb(infp);
#line 65
    rsrcLength = (rsrcLength << 8) + (unsigned int )tmp___6;
#line 64
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 67
  put4(info + 87, (unsigned long )rsrcLength);
#line 68
  dataLength = 0U;
#line 69
  i = 0;
  }
  {
#line 69
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 69
    if (! (i < 4)) {
#line 69
      goto while_break___5;
    }
    {
#line 70
    tmp___7 = getb(infp);
#line 70
    dataLength = (dataLength << 8) + (unsigned int )tmp___7;
#line 69
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 72
  put4(info + 83, (unsigned long )dataLength);
#line 73
  ibytes -= (unsigned long )(filel + 20);
#line 74
  write_it = 1;
  }
#line 75
  if (list) {
    {
#line 76
    transname((info + 1) + 1, text, (int )info[1]);
#line 77
    transname(info + 65, ftype, 4);
#line 78
    transname(info + 69, fauth, 4);
#line 79
    do_indent(indent);
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )dataLength, (long )rsrcLength);
    }
#line 83
    if (info_only) {
#line 84
      write_it = 0;
    }
#line 86
    if (query) {
      {
#line 87
      write_it = do_query();
      }
    } else {
      {
#line 89
      fputc('\n', stderr);
      }
    }
  }
  {
#line 92
  stf_wrfile((unsigned long )rsrcLength, (unsigned long )dataLength, ibytes);
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
static void stf_wrfile(unsigned long rsrcLength , unsigned long dataLength , unsigned long ibytes ) 
{ 
  unsigned long num ;

  {
#line 98
  num = 0UL;
#line 100
  if (write_it) {
    {
#line 101
    define_name(text);
#line 102
    start_info(info, rsrcLength, dataLength);
#line 103
    start_rsrc();
#line 104
    stf_wrfork(& num, rsrcLength, 0);
#line 105
    start_data();
#line 106
    stf_wrfork(& num, rsrcLength + dataLength, (int )(rsrcLength & 4095UL));
#line 107
    end_file();
    }
  } else {
#line 109
    num = 0UL;
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! (num < ibytes)) {
#line 109
        goto while_break;
      }
      {
#line 110
      getb(infp);
#line 109
      num ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  if (verbose) {
    {
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tHuffman compressed (%4.1f%%).\n",
            (100.0 * (double )ibytes) / (double )(rsrcLength + dataLength));
    }
  }
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
static void stf_wrfork(unsigned long *num , unsigned long towrite , int offs ) 
{ 
  int c ;
  int k ;
  int max ;
  int i ;
  int i1 ;
  char *tmp_out_ptr___0 ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (*num < towrite)) {
#line 126
      goto while_break;
    }
#line 127
    if ((*num & 4095UL) == 0UL) {
      {
#line 128
      clrhuff();
#line 129
      tmp = getb(infp);
#line 129
      c = (int )tmp & 255;
#line 130
      k = c;
#line 131
      max = 0;
#line 132
      i = 0;
      }
      {
#line 132
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 132
        if (! (i < k)) {
#line 132
          goto while_break___0;
        }
        {
#line 133
        tmp___0 = getb(infp);
#line 133
        c = (int )tmp___0 & 255;
#line 134
        nodelist[i + 1].flag = 1;
#line 135
        nodelist[i + 1].byte = i + 1;
#line 136
        table[i + 1].num = c;
#line 137
        table[i + 1].next = 0;
        }
#line 138
        if (c > max) {
#line 139
          max = c;
        }
#line 132
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 142
      i = k;
      {
#line 142
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 142
        if (! (i < 32)) {
#line 142
          goto while_break___1;
        }
#line 143
        nodelist[i + 1].flag = 1;
#line 144
        nodelist[i + 1].byte = i + 1;
#line 145
        table[i + 1].num = 0;
#line 146
        table[i + 1].next = 0;
#line 142
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 148
      k = 0;
#line 149
      i = 0;
      {
#line 149
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 149
        if (! (i <= max)) {
#line 149
          goto while_break___2;
        }
#line 150
        i1 = 1;
        {
#line 150
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 150
          if (! (i1 < 33)) {
#line 150
            goto while_break___3;
          }
#line 151
          if (table[i1].num == i) {
#line 152
            table[k].next = i1;
#line 153
            k = i1;
          }
#line 150
          i1 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 149
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 157
      stf_construct(32);
#line 158
      tmp_out_ptr___0 = out_ptr;
#line 159
      out_ptr = length;
#line 160
      de_huffman(256UL);
#line 161
      out_ptr = tmp_out_ptr___0;
#line 162
      i = 1;
      }
      {
#line 162
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 162
        if (! (i < 257)) {
#line 162
          goto while_break___4;
        }
#line 163
        table[i].num = 1073741824 >> (int )length[i - 1];
#line 164
        nodelist[i].flag = 1;
#line 165
        nodelist[i].byte = i - 1;
#line 166
        table[i].next = 0;
#line 162
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 168
      k = 0;
#line 169
      i = 1;
      {
#line 169
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 169
        if (! (i < 1073741824)) {
#line 169
          goto while_break___5;
        }
#line 170
        i1 = 1;
        {
#line 170
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 170
          if (! (i1 < 257)) {
#line 170
            goto while_break___6;
          }
#line 171
          if (table[i1].num == i) {
#line 172
            table[k].next = i1;
#line 173
            k = i1;
          }
#line 170
          i1 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 169
        i <<= 1;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 177
      stf_construct(256);
      }
    }
#line 179
    i = 4096 - offs;
#line 180
    offs = 0;
#line 181
    if ((unsigned long )i > towrite - *num) {
#line 182
      i = (int )(towrite - *num);
    }
    {
#line 184
    de_huffman((unsigned long )i);
#line 185
    *num += (unsigned long )i;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/stf.c"
static void stf_construct(int n ) 
{ 
  int i ;
  int i1 ;
  int i2 ;
  int j1 ;
  int k ;

  {
#line 194
  j1 = n + 1;
#line 195
  i = table[0].next;
#line 196
  i1 = table[i].next;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (table[i1].next != 0)) {
#line 197
      goto while_break;
    }
#line 198
    k = table[i].num + table[i1].num;
#line 199
    table[j1].num = k;
#line 200
    nodelist[j1].flag = 0;
#line 201
    nodelist[j1].zero = nodelist + i;
#line 202
    nodelist[j1].one = nodelist + i1;
#line 203
    i2 = i1;
#line 204
    i = table[i2].next;
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (i != 0) {
#line 205
        if (! (table[i].num <= k)) {
#line 205
          goto while_break___0;
        }
      } else {
#line 205
        goto while_break___0;
      }
#line 206
      i2 = i;
#line 207
      i = table[i].next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    table[j1].next = i;
#line 210
    table[i2].next = j1;
#line 211
    i = table[i1].next;
#line 212
    i1 = table[i].next;
#line 213
    j1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  table[0].num = table[i].num + table[i1].num;
#line 216
  nodelist[0].flag = 0;
#line 217
  nodelist[0].zero = nodelist + i;
#line 218
  nodelist[0].one = nodelist + i1;
#line 219
  return;
}
}
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bin.c"
void bin(char *header , int data_size___0 , int UMcp ) 
{ 
  char hdr[128] ;
  unsigned long rsrcLength ;
  unsigned long dataLength ;
  unsigned char tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 19
  tmp = getb(infp);
#line 19
  hdr[0] = (char )tmp;
#line 20
  ungetc((int )hdr[0], infp);
  }
#line 21
  if ((int )hdr[0] != 0) {
    {
#line 22
    tmp___0 = strncmp(header + 69, "BnHq", 4);
    }
#line 22
    if (tmp___0) {
      {
#line 30
      do_indent(indent);
#line 31
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, contents not recognized.\n");
      }
    } else
#line 22
    if ((int )hdr[0] == 40) {
      {
#line 23
      do_indent(indent);
#line 24
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, this is a fake BinHex 5.0 file.  ");
#line 25
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Debinhex with hexbin first.\n");
      }
    } else {
      {
#line 30
      do_indent(indent);
#line 31
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, contents not recognized.\n");
      }
    }
    {
#line 36
    do_indent(indent);
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copying as a plain file.\n");
#line 41
    mcb(header, (unsigned long )in_data_size, (unsigned long )in_rsrc_size, in_ds + in_rs);
#line 43
    ds_skip = 0;
#line 44
    rs_skip = 0;
#line 45
    in_ds = 0;
#line 46
    in_rs = 0;
    }
#line 47
    return;
  }
  {
#line 49
  tmp___1 = fread((void */* __restrict  */)(hdr), (size_t )1, (size_t )127, (FILE */* __restrict  */)infp);
  }
#line 49
  if (tmp___1 != 128UL) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header\n");
#line 54
    exit(1);
    }
  }
  {
#line 56
  rsrcLength = get4(hdr + 87);
#line 57
  dataLength = get4(hdr + 83);
  }
#line 58
  if (UMcp) {
    {
#line 60
    rsrcLength ++;
#line 60
    put4(hdr + 87, rsrcLength);
#line 61
    dataLength ++;
#line 61
    put4(hdr + 83, dataLength);
    }
  }
  {
#line 63
  mcb(hdr, rsrcLength, dataLength, data_size___0 - 128);
  }
#line 64
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char *dia_archive  ;
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_archive_size  ;
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_max_archive_size  ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_finfo  ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_method  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char *dia_archive_ptr  ;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char *dia_header_ptr  ;
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char *dia_header_last  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_forklength  ;
#line 24 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_cforklength  ;
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char dia_bitbuf[74896]  ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_LZtab[74896]  ;
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static unsigned char *dia_bit_base  ;
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_imask  ;
#line 30
static void dia_folder(unsigned char *name ) ;
#line 31
static void dia_file(unsigned char indicator , unsigned char *name ) ;
#line 32
static void dia_getlength(int nblocks ) ;
#line 33
static void dia_skipfork(int nblocks ) ;
#line 34
static void dia_getfork(int nblocks ) ;
#line 35
static void dia_getblock(unsigned char **archive_ptr , unsigned char **block_ptr ) ;
#line 36
static int dia_decode(unsigned char *ibuff , unsigned char *obuff , int in_length ) ;
#line 37
static int dia_prevbit(void) ;
#line 39 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
void dia(unsigned char *bin_hdr ) 
{ 
  int i ;
  int folder ;
  int nlength ;
  unsigned char hdr ;
  unsigned char *header ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 46
  dir_skip = 0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 128)) {
#line 47
      goto while_break;
    }
#line 48
    info[i] = (char)0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (in_data_size > dia_max_archive_size) {
#line 51
    if ((unsigned long )dia_archive == (unsigned long )((void *)0)) {
      {
#line 52
      tmp = malloc((unsigned int )in_data_size);
#line 52
      dia_archive = (unsigned char *)tmp;
      }
    } else {
      {
#line 54
      tmp___0 = realloc((char *)dia_archive, (unsigned int )in_data_size);
#line 54
      dia_archive = (unsigned char *)tmp___0;
      }
    }
#line 57
    if ((unsigned long )dia_archive == (unsigned long )((unsigned char *)0)) {
      {
#line 58
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.\n");
#line 59
      exit(1);
      }
    }
#line 61
    dia_max_archive_size = in_data_size;
  }
  {
#line 63
  dia_archive_size = in_data_size;
#line 64
  tmp___1 = fread((void */* __restrict  */)((char *)dia_archive), (size_t )1, (size_t )in_data_size,
                  (FILE */* __restrict  */)infp);
  }
#line 64
  if (tmp___1 != (size_t )in_data_size) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read archive.\n");
#line 69
    exit(1);
    }
  }
  {
#line 71
  nlength = (int )*(bin_hdr + 1) & 255;
#line 72
  tmp___2 = strncmp((((char *)bin_hdr + 1) + nlength) - 1, " \272", 2);
  }
#line 72
  if (! tmp___2) {
#line 73
    nlength -= 2;
  }
#line 75
  info[1] = (char )nlength;
#line 76
  i = 1;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! (i <= nlength)) {
#line 76
      goto while_break___0;
    }
#line 77
    info[1 + i] = (char )*(bin_hdr + (1 + i));
#line 76
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 79
  hdr = *dia_archive;
#line 80
  folder = (int )hdr & 128;
#line 81
  dia_finfo = (int )hdr & 64;
#line 82
  if ((int )hdr & 48) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Multi-segment archives not implemented.\n");
#line 87
    exit(1);
    }
  }
#line 89
  if ((int )hdr & 8) {
    {
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Encrypted archives not implemented.\n");
#line 94
    exit(1);
    }
  }
  {
#line 96
  i = ((int )hdr & 7) + 1;
#line 97
  tmp___3 = malloc((unsigned int )(i * 32767));
#line 97
  header = (unsigned char *)tmp___3;
#line 98
  dia_archive_ptr = dia_archive + 1;
#line 99
  dia_header_last = header;
#line 100
  dia_method = 0;
  }
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    tmp___4 = i;
#line 101
    i --;
#line 101
    if (! (tmp___4 > 0)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    dia_getblock(& dia_archive_ptr, & dia_header_last);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  dia_header_ptr = header;
#line 105
  if (folder) {
    {
#line 106
    dia_folder((unsigned char *)((void *)0));
    }
  } else {
    {
#line 108
    tmp___5 = dia_header_ptr;
#line 108
    dia_header_ptr ++;
#line 108
    dia_file((int )*tmp___5, (unsigned char *)((void *)0));
    }
  }
  {
#line 110
  free((char *)header);
  }
#line 111
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_folder(unsigned char *name ) 
{ 
  unsigned char lname[32] ;
  int i ;
  int length___0 ;
  int doit ;
  unsigned char indicator ;
  unsigned char *old_ptr ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 120
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 121
    i = 0;
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      if (! (i < 128)) {
#line 121
        goto while_break;
      }
#line 122
      info[i] = (char)0;
#line 121
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 124
    tmp = name;
#line 124
    name ++;
#line 124
    length___0 = (int )*tmp & 31;
#line 125
    info[1] = (char )length___0;
#line 126
    i = 1;
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      if (! (i <= length___0)) {
#line 126
        goto while_break___0;
      }
#line 127
      tmp___0 = name;
#line 127
      name ++;
#line 127
      info[1 + i] = (char )*tmp___0;
#line 126
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 130
    length___0 = (int )info[1];
  }
#line 132
  if (dia_finfo) {
#line 133
    dia_header_ptr += 20;
  }
#line 135
  if (! dir_skip) {
#line 136
    doit = 1;
#line 137
    if (list) {
      {
#line 138
      transname((info + 1) + 1, (char *)(lname), length___0);
#line 139
      do_indent(indent);
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
              lname);
      }
#line 141
      if (query) {
        {
#line 142
        doit = do_query();
        }
      } else {
        {
#line 144
        fputc('\n', stderr);
        }
      }
#line 146
      if (doit) {
#line 147
        indent ++;
      } else {
#line 149
        dir_skip = 1;
      }
    }
#line 152
    if (doit) {
#line 152
      if (! info_only) {
        {
#line 153
        do_mkdir((char *)(lname), info);
        }
      }
    }
  } else {
#line 156
    dir_skip ++;
  }
  {
#line 158
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )dia_header_ptr < (unsigned long )dia_header_last)) {
#line 158
      goto while_break___1;
    }
#line 159
    indicator = *dia_header_ptr;
#line 160
    if ((int )indicator & 128) {
#line 161
      *dia_header_ptr = (unsigned char )((int )indicator & -129);
#line 162
      goto while_break___1;
    } else
#line 163
    if ((int )indicator & 64) {
#line 164
      if ((int )indicator == 64) {
#line 165
        dia_header_ptr ++;
      } else {
#line 167
        *dia_header_ptr = (unsigned char )((int )*dia_header_ptr - 1);
      }
#line 169
      goto while_break___1;
    } else
#line 170
    if ((int )indicator & 32) {
      {
#line 171
      old_ptr = dia_header_ptr;
#line 172
      dia_header_ptr += ((int )indicator & 31) + 1;
#line 173
      dia_folder(old_ptr);
      }
    } else {
      {
#line 175
      dia_header_ptr ++;
#line 176
      old_ptr = dia_header_ptr;
#line 177
      dia_header_ptr += ((int )*old_ptr & 31) + 1;
#line 178
      dia_file((int )indicator, old_ptr);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if (! dir_skip) {
#line 182
    if (doit) {
#line 183
      indent --;
#line 184
      if (! info_only) {
        {
#line 185
        enddir();
        }
      }
      {
#line 187
      do_indent(indent);
#line 188
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
              lname);
      }
    }
  } else {
#line 191
    dir_skip --;
  }
#line 193
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_file(unsigned char indicator , unsigned char *name ) 
{ 
  unsigned char lname[32] ;
  int i ;
  int length___0 ;
  int doit ;
  int n_data ;
  int n_rsrc ;
  unsigned char *old_archive_ptr ;
  char ftype[5] ;
  char fauth[5] ;
  int dataLength ;
  int rsrcLength ;
  int cdataLength ;
  int crsrcLength ;
  int dataMethod ;
  int rsrcMethod ;
  unsigned long curtime ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  time_t tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;

  {
#line 208
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 209
    i = 0;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      if (! (i < 128)) {
#line 209
        goto while_break;
      }
#line 210
      info[i] = (char)0;
#line 209
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 212
    tmp = name;
#line 212
    name ++;
#line 212
    length___0 = (int )*tmp & 31;
#line 213
    info[1] = (char )length___0;
#line 214
    i = 1;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (i <= length___0)) {
#line 214
        goto while_break___0;
      }
#line 215
      tmp___0 = name;
#line 215
      name ++;
#line 215
      info[1 + i] = (char )*tmp___0;
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 218
    length___0 = (int )info[1];
  }
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 220
    if (! (i < 4)) {
#line 220
      goto while_break___1;
    }
#line 221
    tmp___1 = dia_header_ptr;
#line 221
    dia_header_ptr ++;
#line 221
    info[65 + i] = (char )*tmp___1;
#line 220
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 223
    if (! (i < 4)) {
#line 223
      goto while_break___2;
    }
#line 224
    tmp___2 = dia_header_ptr;
#line 224
    dia_header_ptr ++;
#line 224
    info[69 + i] = (char )*tmp___2;
#line 223
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 226
  if ((int )indicator & 16) {
#line 227
    i = 0;
    {
#line 227
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 227
      if (! (i < 4)) {
#line 227
        goto while_break___3;
      }
#line 228
      tmp___3 = dia_header_ptr;
#line 228
      dia_header_ptr ++;
#line 228
      info[91 + i] = (char )*tmp___3;
#line 227
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 230
      if (! (i < 4)) {
#line 230
        goto while_break___4;
      }
#line 231
      tmp___4 = dia_header_ptr;
#line 231
      dia_header_ptr ++;
#line 231
      info[95 + i] = (char )*tmp___4;
#line 230
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 234
    tmp___5 = time((time_t *)0);
#line 234
    curtime = (unsigned long )tmp___5 + 2082844800UL;
#line 235
    put4(info + 91, curtime);
#line 236
    put4(info + 95, curtime);
    }
  }
#line 238
  if (dia_finfo) {
#line 239
    i = 0;
    {
#line 239
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 239
      if (! (i < 6)) {
#line 239
        goto while_break___5;
      }
#line 240
      tmp___6 = dia_header_ptr;
#line 240
      dia_header_ptr ++;
#line 240
      info[73 + i] = (char )*tmp___6;
#line 239
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 243
  n_data = 0;
#line 244
  if ((int )indicator & 8) {
#line 245
    if ((int )indicator & 2) {
#line 246
      n_data = 1;
    } else {
#line 248
      tmp___7 = dia_header_ptr;
#line 248
      dia_header_ptr ++;
#line 248
      n_data = (int )*tmp___7 + 1;
    }
  }
#line 251
  n_rsrc = 0;
#line 252
  if ((int )indicator & 4) {
#line 253
    if ((int )indicator & 1) {
#line 254
      n_rsrc = 1;
    } else {
#line 256
      tmp___8 = dia_header_ptr;
#line 256
      dia_header_ptr ++;
#line 256
      n_rsrc = (int )*tmp___8 + 1;
    }
  }
#line 259
  if (! dir_skip) {
    {
#line 260
    old_archive_ptr = dia_archive_ptr;
#line 261
    dia_getlength(n_data);
#line 262
    dataLength = dia_forklength;
#line 263
    cdataLength = dia_cforklength;
#line 264
    dataMethod = dia_method;
#line 265
    dia_getlength(n_rsrc);
#line 266
    rsrcLength = dia_forklength;
#line 267
    crsrcLength = dia_cforklength;
#line 268
    rsrcMethod = dia_method;
#line 269
    dia_archive_ptr = old_archive_ptr;
#line 270
    put4(info + 83, (unsigned long )dataLength);
#line 271
    put4(info + 87, (unsigned long )rsrcLength);
    }
#line 272
    if (list) {
      {
#line 273
      transname((info + 1) + 1, (char *)(lname), length___0);
#line 274
      do_indent(indent);
#line 275
      transname(info + 65, ftype, 4);
#line 276
      transname(info + 69, fauth, 4);
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
              lname, ftype, fauth, (long )dataLength, (long )rsrcLength);
      }
#line 280
      if (info_only) {
#line 281
        doit = 0;
      } else {
#line 283
        doit = 1;
      }
#line 285
      if (query) {
        {
#line 286
        doit = do_query();
        }
      } else {
        {
#line 288
        fputc('\n', stderr);
        }
      }
    } else {
#line 291
      doit = 1;
    }
  } else {
    {
#line 294
    dia_skipfork(n_data);
#line 295
    dia_skipfork(n_rsrc);
    }
#line 296
    return;
  }
#line 298
  if (doit) {
    {
#line 299
    define_name((char *)(lname));
#line 300
    start_info(info, (unsigned long )rsrcLength, (unsigned long )dataLength);
    }
  }
#line 302
  if (verbose) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tData: ");
    }
#line 304
    if (dataLength == 0) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    } else
#line 306
    if (dataMethod == 1) {
      {
#line 307
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
      }
    } else {
#line 309
      if (dataMethod != 2) {
        {
#line 310
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Partial ");
        }
      }
      {
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZFK compressed (%4.1f%%)",
              (100.0 * (double )cdataLength) / (double )dataLength);
      }
    }
  }
#line 316
  if (doit) {
    {
#line 317
    start_data();
#line 318
    dia_getfork(n_data);
    }
  } else {
    {
#line 320
    dia_skipfork(n_data);
    }
  }
#line 322
  if (verbose) {
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Rsrc: ");
    }
#line 324
    if (rsrcLength == 0) {
      {
#line 325
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    } else
#line 326
    if (rsrcMethod == 1) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
      }
    } else {
#line 329
      if (rsrcMethod != 2) {
        {
#line 330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Partial ");
        }
      }
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZFK compressed (%4.1f%%)",
              (100.0 * (double )crsrcLength) / (double )rsrcLength);
      }
    }
  }
#line 336
  if (doit) {
    {
#line 337
    start_rsrc();
#line 338
    dia_getfork(n_rsrc);
    }
  } else {
    {
#line 340
    dia_skipfork(n_rsrc);
    }
  }
#line 342
  if (verbose) {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 345
  if (doit) {
    {
#line 346
    end_file();
    }
  }
#line 348
  return;
}
}
#line 350 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_getlength(int nblocks ) 
{ 
  int length___0 ;
  unsigned char *arch_ptr ;
  unsigned char *block_ptr ;
  unsigned char block[32767] ;
  unsigned long tmp ;

  {
#line 357
  dia_method = 0;
#line 358
  dia_forklength = 0;
#line 359
  dia_cforklength = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (nblocks > 1)) {
#line 360
      goto while_break;
    }
    {
#line 361
    nblocks --;
#line 362
    tmp = get2((char *)dia_archive_ptr);
#line 362
    length___0 = (int )tmp;
    }
#line 363
    if (length___0 >= 32768) {
#line 364
      length___0 = 65536 - length___0;
#line 365
      dia_method |= 1;
    } else {
#line 367
      dia_method |= 2;
    }
#line 369
    dia_forklength += 32767;
#line 370
    dia_cforklength += length___0 + 2;
#line 371
    dia_archive_ptr += length___0 + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (nblocks == 1) {
    {
#line 374
    arch_ptr = dia_archive_ptr;
#line 375
    block_ptr = block;
#line 376
    dia_getblock(& arch_ptr, & block_ptr);
#line 377
    dia_forklength = (int )((long )dia_forklength + (block_ptr - block));
#line 378
    dia_cforklength = (int )((long )dia_cforklength + (arch_ptr - dia_archive_ptr));
#line 379
    dia_archive_ptr = arch_ptr;
    }
  }
#line 381
  return;
}
}
#line 383 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_skipfork(int nblocks ) 
{ 
  int length___0 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    tmp___0 = nblocks;
#line 388
    nblocks --;
#line 388
    if (! (tmp___0 > 0)) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = get2((char *)dia_archive_ptr);
#line 389
    length___0 = (int )tmp;
    }
#line 390
    if (length___0 >= 32768) {
#line 391
      length___0 = 65536 - length___0;
    }
#line 393
    dia_archive_ptr += length___0 + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 397 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_getfork(int nblocks ) 
{ 
  int tmp ;

  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    tmp = nblocks;
#line 400
    nblocks --;
#line 400
    if (! (tmp > 0)) {
#line 400
      goto while_break;
    }
    {
#line 401
    dia_getblock(& dia_archive_ptr, (unsigned char **)(& out_ptr));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return;
}
}
#line 405 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static void dia_getblock(unsigned char **archive_ptr , unsigned char **block_ptr ) 
{ 
  int length___0 ;
  int i ;
  unsigned char *arch_ptr ;
  unsigned char *bl_ptr ;
  unsigned long tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 411
  arch_ptr = *archive_ptr;
#line 412
  bl_ptr = *block_ptr;
#line 413
  tmp = get2((char *)arch_ptr);
#line 413
  length___0 = (int )tmp;
#line 414
  arch_ptr += 2;
  }
#line 415
  if (length___0 >= 32768) {
#line 416
    length___0 = 65536 - length___0;
#line 417
    i = 0;
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (! (i < length___0)) {
#line 417
        goto while_break;
      }
#line 418
      tmp___0 = bl_ptr;
#line 418
      bl_ptr ++;
#line 418
      tmp___1 = arch_ptr;
#line 418
      arch_ptr ++;
#line 418
      *tmp___0 = *tmp___1;
#line 417
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 420
    *block_ptr += length___0;
#line 421
    dia_method |= 1;
  } else {
    {
#line 423
    tmp___2 = dia_decode(arch_ptr, bl_ptr, length___0);
#line 423
    *block_ptr += tmp___2;
#line 424
    dia_method |= 2;
    }
  }
#line 426
  *archive_ptr += length___0 + 2;
#line 427
  return;
}
}
#line 429 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_decode(unsigned char *ibuff , unsigned char *obuff , int in_length ) 
{ 
  int nbits ;
  int set_zero ;
  int i ;
  int j ;
  unsigned char *bitbuf_ptr ;
  int count[4] ;
  int *LZtab_ptr ;
  unsigned char *out_ptr___0 ;
  unsigned char *buf_ptr ;
  unsigned char *in_ptr ;
  int omask ;
  int LZcount ;
  int *length_ptr ;
  int *nchars_ptr ;
  int *offsn_ptr ;
  int length___0 ;
  int nchars ;
  int offset___0 ;
  int *offs_ptr[4] ;
  int nwords ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;

  {
#line 444
  in_ptr = ibuff + in_length;
#line 445
  in_ptr --;
#line 445
  nbits = (int )*in_ptr;
#line 446
  in_ptr --;
#line 446
  nbits |= (int )*in_ptr << 8;
#line 447
  if (nbits == 65535) {
#line 448
    in_ptr --;
#line 448
    nbits = (int )*in_ptr;
#line 449
    in_ptr --;
#line 449
    nbits |= (int )*in_ptr << 8;
#line 450
    nbits += 65535;
  }
  {
#line 452
  bitbuf_ptr = dia_bitbuf + 74896;
#line 453
  bitbuf_ptr --;
#line 453
  in_ptr --;
#line 453
  *bitbuf_ptr = *in_ptr;
#line 454
  set_zero = 0;
#line 455
  dia_bit_base = bitbuf_ptr;
#line 456
  dia_imask = 1 << (7 - (nbits & 7));
#line 457
  tmp = dia_prevbit();
  }
#line 457
  if (tmp) {
#line 458
    set_zero = 1;
  }
#line 460
  i = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < nbits)) {
#line 460
      goto while_break;
    }
#line 461
    if (set_zero) {
#line 462
      bitbuf_ptr --;
#line 462
      *bitbuf_ptr = (unsigned char)0;
    } else {
#line 464
      bitbuf_ptr --;
#line 464
      in_ptr --;
#line 464
      *bitbuf_ptr = *in_ptr;
    }
    {
#line 466
    tmp___0 = dia_prevbit();
    }
#line 466
    if (tmp___0) {
#line 467
      set_zero = ! set_zero;
    }
#line 460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  nwords = (int )((dia_bit_base - bitbuf_ptr) >> 1);
#line 472
  i = 0;
  {
#line 472
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 472
    if (! (i < nwords)) {
#line 472
      goto while_break___0;
    }
#line 473
    dia_LZtab[i] = 0;
#line 472
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 475
  omask = 1;
#line 476
  i = 0;
  {
#line 476
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 476
    if (! (i < 16)) {
#line 476
      goto while_break___1;
    }
#line 477
    j = nwords;
#line 478
    LZtab_ptr = dia_LZtab + nwords;
    {
#line 479
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 479
      tmp___2 = j;
#line 479
      j --;
#line 479
      if (! (tmp___2 > 0)) {
#line 479
        goto while_break___2;
      }
      {
#line 480
      LZtab_ptr --;
#line 481
      tmp___1 = dia_prevbit();
      }
#line 481
      if (tmp___1) {
#line 482
        *LZtab_ptr |= omask;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 485
    omask <<= 1;
#line 476
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 487
  LZcount = nwords / 3;
#line 503
  count[0] = 0;
#line 504
  count[1] = 0;
#line 505
  count[2] = 0;
#line 506
  count[3] = 0;
#line 507
  i = 0;
  {
#line 507
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 507
    if (! (i < LZcount)) {
#line 507
      goto while_break___3;
    }
#line 508
    j = dia_LZtab[i];
#line 508
    if (j < 4) {
#line 509
      (count[j]) ++;
    }
#line 507
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 512
  length_ptr = dia_LZtab;
#line 513
  nchars_ptr = dia_LZtab + LZcount;
#line 514
  offs_ptr[0] = nchars_ptr + LZcount;
#line 515
  offs_ptr[1] = offs_ptr[0] + count[0];
#line 516
  offs_ptr[2] = offs_ptr[1] + count[1];
#line 517
  offs_ptr[3] = offs_ptr[2] + count[2];
#line 518
  offsn_ptr = offs_ptr[3] + count[3];
#line 519
  out_ptr___0 = obuff;
#line 520
  i = 0;
  {
#line 520
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 520
    if (! (i < LZcount)) {
#line 520
      goto while_break___4;
    }
#line 521
    tmp___3 = length_ptr;
#line 521
    length_ptr ++;
#line 521
    length___0 = *tmp___3;
#line 522
    tmp___4 = nchars_ptr;
#line 522
    nchars_ptr ++;
#line 522
    nchars = *tmp___4;
#line 523
    if (length___0 < 4) {
#line 524
      tmp___5 = offs_ptr[length___0];
#line 524
      (offs_ptr[length___0]) ++;
#line 524
      offset___0 = *tmp___5;
    } else {
#line 526
      tmp___6 = offsn_ptr;
#line 526
      offsn_ptr ++;
#line 526
      offset___0 = *tmp___6;
    }
    {
#line 528
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 528
      tmp___9 = nchars;
#line 528
      nchars --;
#line 528
      if (! (tmp___9 > 0)) {
#line 528
        goto while_break___5;
      }
#line 529
      tmp___7 = out_ptr___0;
#line 529
      out_ptr___0 ++;
#line 529
      tmp___8 = ibuff;
#line 529
      ibuff ++;
#line 529
      *tmp___7 = *tmp___8;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 531
    buf_ptr = ((out_ptr___0 - length___0) - offset___0) - 1;
    {
#line 532
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 532
      tmp___12 = length___0;
#line 532
      length___0 --;
#line 532
      if (! (tmp___12 >= 0)) {
#line 532
        goto while_break___6;
      }
#line 533
      tmp___10 = out_ptr___0;
#line 533
      out_ptr___0 ++;
#line 533
      tmp___11 = buf_ptr;
#line 533
      buf_ptr ++;
#line 533
      *tmp___10 = *tmp___11;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 520
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 536
  i = (int )(in_ptr - ibuff);
  {
#line 537
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 537
    tmp___15 = i;
#line 537
    i --;
#line 537
    if (! (tmp___15 > 0)) {
#line 537
      goto while_break___7;
    }
#line 538
    tmp___13 = out_ptr___0;
#line 538
    out_ptr___0 ++;
#line 538
    tmp___14 = ibuff;
#line 538
    ibuff ++;
#line 538
    *tmp___13 = *tmp___14;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 540
  return ((int )(out_ptr___0 - obuff));
}
}
#line 543 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dia.c"
static int dia_prevbit(void) 
{ 
  int c ;

  {
#line 547
  if (dia_imask == 256) {
#line 548
    dia_bit_base --;
#line 549
    dia_imask = 1;
  }
#line 551
  c = (int )*dia_bit_base & dia_imask;
#line 552
  dia_imask <<= 1;
#line 553
  return (c);
}
}
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
int (*get_bit)()  ;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
struct node nodelist[515]  ;
#line 13 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/huffman.h"
int bytesread  ;
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int getbit_be(void) ;
#line 29
static int getbit_le(void) ;
#line 30
static int getdecodebyte(void) ;
#line 32 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static node *nodeptr  ;
#line 32
static node *read_sub_tree(void) ;
#line 34 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int bit  ;
#line 40
int gethuffbyte(node *l_nodelist ) ;
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
void de_huffman(unsigned long obytes ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (obytes != 0UL)) {
#line 39
      goto while_break;
    }
    {
#line 40
    tmp = out_ptr;
#line 40
    out_ptr ++;
#line 40
    tmp___0 = gethuffbyte(nodelist);
#line 40
    *tmp = (char )tmp___0;
#line 41
    obytes --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
void de_huffman_end(unsigned int term ) 
{ 
  int c ;
  char *tmp ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    c = gethuffbyte(nodelist);
    }
#line 51
    if (! ((unsigned int )c != term)) {
#line 51
      goto while_break;
    }
#line 52
    tmp = out_ptr;
#line 52
    out_ptr ++;
#line 52
    *tmp = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
void set_huffman(int endian ) 
{ 


  {
#line 59
  if (endian == 1) {
#line 60
    get_bit = & getbit_le;
  } else
#line 61
  if (endian == 0) {
#line 62
    get_bit = & getbit_be;
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
void read_tree(void) 
{ 


  {
  {
#line 68
  nodeptr = nodelist;
#line 69
  bit = 0;
#line 70
  read_sub_tree();
  }
#line 71
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static node *read_sub_tree(void) 
{ 
  node *np ;
  node *tmp ;
  int tmp___0 ;

  {
  {
#line 79
  tmp = nodeptr;
#line 79
  nodeptr ++;
#line 79
  np = tmp;
#line 80
  tmp___0 = (*get_bit)();
  }
#line 80
  if (tmp___0 == 1) {
    {
#line 81
    np->flag = 1;
#line 82
    np->byte = getdecodebyte();
    }
  } else {
    {
#line 84
    np->flag = 0;
#line 85
    np->zero = read_sub_tree();
#line 86
    np->one = read_sub_tree();
    }
  }
#line 88
  return (np);
}
}
#line 94 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int b  ;
#line 92 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int getbit_be(void) 
{ 
  unsigned char tmp ;

  {
#line 96
  if (bit == 0) {
    {
#line 97
    tmp = getb(infp);
#line 97
    b = (int )tmp & 255;
#line 98
    bit = 8;
#line 99
    bytesread ++;
    }
  }
#line 101
  bit --;
#line 102
  return ((b >> bit) & 1);
}
}
#line 108 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int b___0  ;
#line 106 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int getbit_le(void) 
{ 
  unsigned char tmp ;

  {
#line 110
  if (bit == 0) {
    {
#line 111
    tmp = getb(infp);
#line 111
    b___0 = (int )tmp & 255;
#line 112
    bit = 8;
#line 113
    bytesread ++;
    }
  }
#line 115
  bit --;
#line 116
  return ((b___0 >> (7 - bit)) & 1);
}
}
#line 119 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
void clrhuff(void) 
{ 


  {
#line 121
  bit = 0;
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
int gethuffbyte(node *l_nodelist ) 
{ 
  register node *np ;
  int tmp___0 ;

  {
#line 129
  np = l_nodelist;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (np->flag == 0)) {
#line 130
      goto while_break;
    }
    {
#line 131
    tmp___0 = (*get_bit)();
    }
#line 131
    if (tmp___0) {
#line 131
      np = np->one;
    } else {
#line 131
      np = np->zero;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (np->byte);
}
}
#line 136 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
int getihuffbyte(void) 
{ 
  int tmp ;

  {
  {
#line 138
  tmp = gethuffbyte(nodelist);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_huffman.c"
static int getdecodebyte(void) 
{ 
  register int i ;
  register int b___1 ;
  int tmp ;

  {
#line 145
  b___1 = 0;
#line 146
  i = 8;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i > 0)) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp = (*get_bit)();
#line 147
    b___1 = (b___1 << 1) + tmp;
#line 146
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (b___1);
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.h"
unsigned int bit_be_bitbuf ;
#line 4
char *bit_be_filestart ;
#line 5
int bit_be_inbytes ;
#line 7
void bit_be_fillbuf(int n ) ;
#line 8
unsigned int bit_be_getbits(int n ) ;
#line 9
void bit_be_init_getbits(void) ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static int decoded  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static int bitsused  ;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int blocksize  ;
#line 22
static unsigned int decode_c(void) ;
#line 23
static unsigned int decode_p(void) ;
#line 24
static void make_table(int nchar___0 , unsigned char *bitlen , int tablebits , unsigned int *table___0 ) ;
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
void de_lzh(long ibytes , long obytes , char **data , int bits ) 
{ 
  unsigned int i ;
  unsigned int r ;
  unsigned int c ;
  int remains ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 36
  bit_be_inbytes = (int )ibytes;
#line 37
  bit_be_filestart = *data;
#line 38
  bitsused = bits;
#line 39
  bit_be_init_getbits();
#line 40
  blocksize = 0U;
#line 41
  decoded = 0;
#line 42
  r = 0U;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    c = decode_c();
    }
#line 45
    if (decoded) {
#line 46
      *data = bit_be_filestart;
#line 47
      return;
    }
#line 49
    if (c <= 255U) {
#line 50
      tmp = r;
#line 50
      r ++;
#line 50
      *(out_ptr + tmp) = (char )c;
#line 51
      obytes --;
#line 52
      if (obytes == 0L) {
#line 53
        *data = bit_be_filestart;
#line 54
        return;
      }
    } else {
      {
#line 57
      remains = (int )(c - 253U);
#line 58
      tmp___0 = decode_p();
#line 58
      i = (r - tmp___0) - 1U;
      }
      {
#line 59
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 59
        remains --;
#line 59
        if (! (remains >= 0)) {
#line 59
          goto while_break___0;
        }
#line 60
        tmp___1 = r;
#line 60
        r ++;
#line 60
        tmp___2 = i;
#line 60
        i ++;
#line 60
        *(out_ptr + tmp___1) = *(out_ptr + tmp___2);
#line 61
        obytes --;
#line 62
        if (obytes == 0L) {
#line 63
          *data = bit_be_filestart;
#line 64
          return;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 85 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int left[1019]  ;
#line 85 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int right[1019]  ;
#line 86 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned char c_len[510]  ;
#line 86 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned char pt_len[19]  ;
#line 87 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int c_table[4096]  ;
#line 87 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int pt_table[256]  ;
#line 89 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ 
  int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 97
  tmp = bit_be_getbits(nbit);
#line 97
  n = (int )tmp;
  }
#line 98
  if (n == 0) {
    {
#line 99
    tmp___0 = bit_be_getbits(nbit);
#line 99
    c = (int )tmp___0;
#line 100
    i = 0;
    }
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! (i < nn)) {
#line 100
        goto while_break;
      }
#line 101
      pt_len[i] = (unsigned char)0;
#line 100
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 103
    i = 0;
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! (i < 256)) {
#line 103
        goto while_break___0;
      }
#line 104
      pt_table[i] = (unsigned int )c;
#line 103
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 107
    i = 0;
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 108
      if (! (i < n)) {
#line 108
        goto while_break___1;
      }
#line 109
      c = (int )(bit_be_bitbuf >> 13);
#line 110
      if (c == 7) {
#line 111
        mask = 1U << 12;
        {
#line 112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 112
          if (! (mask & bit_be_bitbuf)) {
#line 112
            goto while_break___2;
          }
#line 113
          mask >>= 1;
#line 114
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 117
      if (c < 7) {
#line 117
        tmp___1 = 3;
      } else {
#line 117
        tmp___1 = c - 3;
      }
      {
#line 117
      bit_be_fillbuf(tmp___1);
#line 118
      tmp___2 = i;
#line 118
      i ++;
#line 118
      pt_len[tmp___2] = (unsigned char )c;
      }
#line 119
      if (i == i_special) {
        {
#line 120
        tmp___3 = bit_be_getbits(2);
#line 120
        c = (int )tmp___3;
        }
        {
#line 121
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 121
          c --;
#line 121
          if (! (c >= 0)) {
#line 121
            goto while_break___3;
          }
#line 122
          tmp___4 = i;
#line 122
          i ++;
#line 122
          pt_len[tmp___4] = (unsigned char)0;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 126
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 126
      if (! (i < nn)) {
#line 126
        goto while_break___4;
      }
#line 127
      tmp___5 = i;
#line 127
      i ++;
#line 127
      pt_len[tmp___5] = (unsigned char)0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 129
    make_table(nn, pt_len, 8, pt_table);
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static void read_c_len(void) 
{ 
  int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 138
  tmp = bit_be_getbits(9);
#line 138
  n = (int )tmp;
  }
#line 139
  if (n == 0) {
    {
#line 140
    tmp___0 = bit_be_getbits(9);
#line 140
    c = (int )tmp___0;
#line 141
    i = 0;
    }
    {
#line 141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 141
      if (! (i < 510)) {
#line 141
        goto while_break;
      }
#line 142
      c_len[i] = (unsigned char)0;
#line 141
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 144
    i = 0;
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 144
      if (! (i < 4096)) {
#line 144
        goto while_break___0;
      }
#line 145
      c_table[i] = (unsigned int )c;
#line 144
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 148
    i = 0;
    {
#line 149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 149
      if (! (i < n)) {
#line 149
        goto while_break___1;
      }
#line 150
      c = (int )pt_table[bit_be_bitbuf >> 8];
#line 151
      if (c >= 19) {
#line 152
        mask = 1U << 7;
        {
#line 153
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 154
          if (bit_be_bitbuf & mask) {
#line 155
            c = (int )right[c];
          } else {
#line 157
            c = (int )left[c];
          }
#line 159
          mask >>= 1;
#line 153
          if (! (c >= 19)) {
#line 153
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 162
      bit_be_fillbuf((int )pt_len[c]);
      }
#line 163
      if (c <= 2) {
#line 164
        if (c == 0) {
#line 165
          c = 1;
        } else
#line 166
        if (c == 1) {
          {
#line 167
          tmp___1 = bit_be_getbits(4);
#line 167
          c = (int )(tmp___1 + 3U);
          }
        } else {
          {
#line 169
          tmp___2 = bit_be_getbits(9);
#line 169
          c = (int )(tmp___2 + 20U);
          }
        }
        {
#line 171
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 171
          c --;
#line 171
          if (! (c >= 0)) {
#line 171
            goto while_break___3;
          }
#line 172
          tmp___3 = i;
#line 172
          i ++;
#line 172
          c_len[tmp___3] = (unsigned char)0;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 175
        tmp___4 = i;
#line 175
        i ++;
#line 175
        c_len[tmp___4] = (unsigned char )(c - 2);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 178
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 178
      if (! (i < 510)) {
#line 178
        goto while_break___4;
      }
#line 179
      tmp___5 = i;
#line 179
      i ++;
#line 179
      c_len[tmp___5] = (unsigned char)0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 181
    make_table(510, c_len, 12, c_table);
    }
  }
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int decode_c(void) 
{ 
  unsigned int j ;
  unsigned int mask ;

  {
#line 189
  if (blocksize == 0U) {
    {
#line 190
    blocksize = bit_be_getbits(16);
    }
#line 191
    if (blocksize == 0U) {
#line 192
      decoded = 1;
#line 193
      return (0U);
    }
    {
#line 195
    read_pt_len(19, 5, 3);
#line 196
    read_c_len();
#line 197
    read_pt_len(bitsused + 1, 4, -1);
    }
  }
#line 199
  blocksize --;
#line 200
  j = c_table[bit_be_bitbuf >> 4];
#line 201
  if (j >= 510U) {
#line 202
    mask = 1U << 3;
    {
#line 203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (bit_be_bitbuf & mask) {
#line 205
        j = right[j];
      } else {
#line 207
        j = left[j];
      }
#line 209
      mask >>= 1;
#line 203
      if (! (j >= 510U)) {
#line 203
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 212
  bit_be_fillbuf((int )c_len[j]);
  }
#line 213
  return (j);
}
}
#line 216 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static unsigned int decode_p(void) 
{ 
  unsigned int j ;
  unsigned int mask ;
  unsigned int tmp ;

  {
#line 220
  j = pt_table[bit_be_bitbuf >> 8];
#line 221
  if (j > (unsigned int )bitsused) {
#line 222
    mask = 1U << 7;
    {
#line 223
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (bit_be_bitbuf & mask) {
#line 225
        j = right[j];
      } else {
#line 227
        j = left[j];
      }
#line 229
      mask >>= 1;
#line 223
      if (! (j > (unsigned int )bitsused)) {
#line 223
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 232
  bit_be_fillbuf((int )pt_len[j]);
  }
#line 233
  if (j != 0U) {
    {
#line 234
    tmp = bit_be_getbits((int )(j - 1U));
#line 234
    j = (1U << (j - 1U)) + tmp;
    }
  }
#line 236
  return (j);
}
}
#line 239 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzh.c"
static void make_table(int nchar___0 , unsigned char *bitlen , int tablebits , unsigned int *table___0 ) 
{ 
  unsigned int count[17] ;
  unsigned int weight[17] ;
  unsigned int start[18] ;
  unsigned int *p ;
  unsigned int i ;
  unsigned int k ;
  unsigned int len ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 248
  i = 1U;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i <= 16U)) {
#line 248
      goto while_break;
    }
#line 249
    count[i] = 0U;
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  i = 0U;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (i < (unsigned int )nchar___0)) {
#line 251
      goto while_break___0;
    }
#line 252
    (count[*(bitlen + i)]) ++;
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 255
  start[1] = 0U;
#line 256
  i = 1U;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (! (i <= 16U)) {
#line 256
      goto while_break___1;
    }
#line 257
    start[i + 1U] = start[i] + (count[i] << (16U - i));
#line 256
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 260
  jutbits = (unsigned int )(16 - tablebits);
#line 261
  i = 1U;
  {
#line 261
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 261
    if (! (i <= (unsigned int )tablebits)) {
#line 261
      goto while_break___2;
    }
#line 262
    start[i] >>= jutbits;
#line 263
    weight[i] = 1U << ((unsigned int )tablebits - i);
#line 261
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 265
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 265
    if (! (i <= 16U)) {
#line 265
      goto while_break___3;
    }
#line 266
    weight[i] = 1U << (16U - i);
#line 267
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 270
  i = start[tablebits + 1] >> jutbits;
#line 271
  if (i != 1U << 16) {
#line 272
    k = (unsigned int )(1 << tablebits);
    {
#line 273
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 273
      if (! (i != k)) {
#line 273
        goto while_break___4;
      }
#line 274
      tmp = i;
#line 274
      i ++;
#line 274
      *(table___0 + tmp) = 0U;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 278
  avail = (unsigned int )nchar___0;
#line 279
  mask = 1U << (15 - tablebits);
#line 280
  ch = 0U;
  {
#line 280
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 280
    if (! (ch < (unsigned int )nchar___0)) {
#line 280
      goto while_break___5;
    }
#line 281
    len = (unsigned int )*(bitlen + ch);
#line 281
    if (len == 0U) {
#line 282
      goto __Cont;
    }
#line 284
    nextcode = start[len] + weight[len];
#line 285
    if (len <= (unsigned int )tablebits) {
#line 286
      i = start[len];
      {
#line 286
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 286
        if (! (i < nextcode)) {
#line 286
          goto while_break___6;
        }
#line 287
        *(table___0 + i) = ch;
#line 286
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 290
      k = start[len];
#line 291
      p = table___0 + (k >> jutbits);
#line 292
      i = len - (unsigned int )tablebits;
      {
#line 293
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 293
        if (! (i != 0U)) {
#line 293
          goto while_break___7;
        }
#line 294
        if (*p == 0U) {
#line 295
          tmp___0 = 0U;
#line 295
          left[avail] = tmp___0;
#line 295
          right[avail] = tmp___0;
#line 296
          tmp___1 = avail;
#line 296
          avail ++;
#line 296
          *p = tmp___1;
        }
#line 298
        if (k & mask) {
#line 299
          p = & right[*p];
        } else {
#line 301
          p = & left[*p];
        }
#line 303
        k <<= 1;
#line 304
        i --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 306
      *p = ch;
    }
#line 308
    start[len] = nextcode;
    __Cont: /* CIL Label */ 
#line 280
    ch ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___3[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 1 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/crc.c"
unsigned long crcinit  ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/crc.c"
unsigned long (*updcrc)()  ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
static int pit_filehdr(struct pit_header *f , int compr ) ;
#line 19
static void pit_wrfile(unsigned long bytes , int type ) ;
#line 20
static void pit_nocomp(unsigned long ibytes ) ;
#line 21
static void pit_huffman(unsigned long obytes ) ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
void pit(void) 
{ 
  struct pit_header filehdr ;
  char pithdr[4] ;
  int decode ;
  int synced ;
  int ch ;
  unsigned long data_crc ;
  unsigned long crc___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 30
  updcrc = & binhex_updcrc;
#line 31
  crcinit = binhex_crcinit;
#line 32
  set_huffman(0);
#line 33
  synced = 0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! synced) {
      {
#line 36
      tmp = fread((void */* __restrict  */)(pithdr), (size_t )1, (size_t )4, (FILE */* __restrict  */)infp);
      }
#line 36
      if (tmp != 4UL) {
        {
#line 37
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 41
        exit(1);
        }
      }
    }
    {
#line 44
    synced = 0;
#line 45
    tmp___0 = strncmp(pithdr, "PEnd", 4);
    }
#line 45
    if (tmp___0 == 0) {
#line 46
      goto while_break;
    }
    {
#line 48
    tmp___1 = strncmp(pithdr, "PMa", 3);
    }
#line 48
    if (tmp___1 != 0) {
      {
#line 49
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File contains non PackIt info %.4s\n",
              pithdr);
#line 54
      exit(1);
      }
    }
    {
#line 58
    if ((int )pithdr[3] == 52) {
#line 58
      goto case_52;
    }
#line 58
    if ((int )pithdr[3] == 103) {
#line 58
      goto case_52;
    }
#line 61
    if ((int )pithdr[3] == 54) {
#line 61
      goto case_54;
    }
#line 61
    if ((int )pithdr[3] == 53) {
#line 61
      goto case_54;
    }
#line 98
    goto switch_default;
    case_52: /* CIL Label */ 
    case_103: /* CIL Label */ 
#line 59
    goto switch_break;
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
#line 62
    if ((int )pithdr[3] == 54) {
      {
#line 63
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DES-");
      }
    }
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Encrypted file found, trying to sync");
    }
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! (! synced)) {
#line 66
        goto while_break___0;
      }
      {
#line 67
      tmp___2 = getb(infp);
#line 67
      ch = (int )tmp___2;
      }
#line 68
      if (ch == 80) {
        {
#line 69
        pithdr[0] = (char )ch;
#line 70
        tmp___3 = getb(infp);
#line 70
        ch = (int )tmp___3;
#line 70
        pithdr[1] = (char )ch;
        }
#line 71
        if (ch == 77) {
          {
#line 72
          tmp___4 = getb(infp);
#line 72
          ch = (int )tmp___4;
#line 72
          pithdr[2] = (char )ch;
          }
#line 73
          if (ch == 97) {
            {
#line 74
            tmp___5 = getb(infp);
#line 74
            ch = (int )tmp___5;
#line 74
            pithdr[3] = (char )ch;
            }
#line 75
            if (ch >= 52) {
#line 75
              if (ch <= 54) {
#line 76
                synced = 1;
              } else {
#line 75
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 75
            if (ch == 103) {
#line 76
              synced = 1;
            }
          }
        } else
#line 79
        if (ch == 69) {
          {
#line 80
          tmp___6 = getb(infp);
#line 80
          ch = (int )tmp___6;
#line 80
          pithdr[2] = (char )ch;
          }
#line 81
          if (ch == 110) {
            {
#line 82
            tmp___7 = getb(infp);
#line 82
            ch = (int )tmp___7;
#line 82
            pithdr[3] = (char )ch;
            }
#line 83
            if (ch == 100) {
#line 84
              synced = 1;
            }
          }
        }
#line 88
        if (! synced) {
          {
#line 89
          ungetc(ch, infp);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", done.\n");
    }
#line 97
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File contains non PackIt info %.4s\n",
            pithdr);
#line 104
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 106
    bytes_read = 0;
#line 107
    if ((int )pithdr[3] == 52) {
      {
#line 108
      read_tree();
#line 109
      decode = 1;
      }
    } else {
#line 111
      decode = 0;
    }
    {
#line 113
    tmp___8 = pit_filehdr(& filehdr, decode);
    }
#line 113
    if (tmp___8 == -1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header\n");
#line 118
      exit(1);
      }
    }
    {
#line 120
    bytes_written = (int )(filehdr.rlen + filehdr.dlen);
#line 121
    start_info(info, filehdr.rlen, filehdr.dlen);
#line 122
    start_data();
#line 123
    pit_wrfile(filehdr.dlen, decode);
#line 124
    data_crc = (*updcrc)(crcinit, out_buffer, filehdr.dlen);
#line 125
    start_rsrc();
#line 126
    pit_wrfile(filehdr.rlen, decode);
#line 127
    data_crc = (*updcrc)(data_crc, out_buffer, filehdr.rlen);
    }
#line 128
    if (decode == 0) {
      {
#line 129
      tmp___9 = getb(infp);
#line 129
      crc___0 = (unsigned long )tmp___9;
#line 130
      tmp___10 = getb(infp);
#line 130
      crc___0 = (crc___0 << 8) | (unsigned long )tmp___10;
      }
    } else {
      {
#line 132
      tmp___11 = getihuffbyte();
#line 132
      tmp___12 = getihuffbyte();
#line 132
      crc___0 = (unsigned long )((tmp___11 & 255) | ((tmp___12 & 255) << 8));
      }
    }
#line 135
    if (crc___0 != data_crc) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error in file: need 0x%04x, got 0x%04x\n",
              (int )crc___0, (int )data_crc);
#line 142
      exit(1);
      }
    }
#line 144
    if (verbose) {
#line 145
      if (decode == 0) {
        {
#line 146
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tNo compression");
        }
      } else {
        {
#line 148
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tHuffman compressed (%4.1f%%)",
                (100.0 * (double )bytes_read) / (double )bytes_written);
        }
      }
    }
#line 152
    if (write_it) {
      {
#line 153
      end_file();
      }
    }
#line 155
    if (verbose) {
      {
#line 156
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
static int pit_filehdr(struct pit_header *f , int compr ) 
{ 
  register int i ;
  unsigned long crc___0 ;
  int n ;
  char hdr[94] ;
  char ftype[5] ;
  char fauth[5] ;
  int tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < 128)) {
#line 171
      goto while_break;
    }
#line 172
    info[i] = (char )'\000';
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (compr == 1) {
#line 175
    i = 0;
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 175
      if (! (i < 94)) {
#line 175
        goto while_break___0;
      }
      {
#line 176
      tmp = getihuffbyte();
#line 176
      hdr[i] = (char )tmp;
#line 175
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 179
    tmp___0 = fread((void */* __restrict  */)(hdr), (size_t )1, (size_t )94, (FILE */* __restrict  */)infp);
    }
#line 179
    if (tmp___0 != 94UL) {
#line 180
      return (-1);
    }
  }
  {
#line 183
  crc___0 = crcinit;
#line 184
  crc___0 = (*updcrc)(crc___0, hdr, 92);
#line 186
  tmp___1 = get2(hdr + 92);
#line 186
  f->hdrCRC = (unsigned short )tmp___1;
  }
#line 187
  if ((unsigned long )f->hdrCRC != crc___0) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tHeader CRC mismatch: got 0x%04x, need 0x%04x\n",
            (int )f->hdrCRC & 65535, (int )crc___0);
    }
#line 191
    return (-1);
  }
#line 194
  n = (int )hdr[0] & 255;
#line 195
  if (n > 63) {
#line 196
    n = 63;
  }
  {
#line 198
  info[1] = (char )n;
#line 199
  copy((info + 1) + 1, hdr + 1, n);
#line 200
  transname(hdr + 1, text, n);
#line 201
  text[n] = (char )'\000';
#line 203
  f->rlen = get4(hdr + 80);
#line 204
  f->dlen = get4(hdr + 76);
#line 206
  write_it = 1;
  }
#line 207
  if (list) {
    {
#line 208
    transname(hdr + 64, ftype, 4);
#line 209
    transname(hdr + 68, fauth, 4);
#line 210
    do_indent(indent);
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )f->dlen, (long )f->rlen);
    }
#line 214
    if (info_only) {
#line 215
      write_it = 0;
    }
#line 217
    if (query) {
      {
#line 218
      write_it = do_query();
      }
    } else {
      {
#line 220
      fputc('\n', stderr);
      }
    }
  }
#line 225
  if (write_it) {
    {
#line 226
    define_name(text);
#line 228
    copy(info + 65, hdr + 64, 4);
#line 229
    copy(info + 69, hdr + 68, 4);
#line 230
    copy(info + 73, hdr + 72, 2);
#line 231
    copy(info + 81, hdr + 74, 2);
#line 232
    copy(info + 83, hdr + 76, 4);
#line 233
    copy(info + 87, hdr + 80, 4);
#line 234
    copy(info + 91, hdr + 84, 4);
#line 235
    copy(info + 95, hdr + 88, 4);
    }
  }
#line 237
  return (1);
}
}
#line 240 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
static void pit_wrfile(unsigned long bytes , int type ) 
{ 


  {
#line 244
  if (bytes == 0UL) {
#line 245
    return;
  }
  {
#line 248
  if (type == 0) {
#line 248
    goto case_0;
  }
#line 251
  if (type == 1) {
#line 251
    goto case_1;
  }
#line 247
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 249
  pit_nocomp(bytes);
  }
#line 250
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 252
  pit_huffman(bytes);
  }
  switch_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
static void pit_nocomp(unsigned long ibytes ) 
{ 
  int n ;
  size_t tmp ;

  {
  {
#line 264
  tmp = fread((void */* __restrict  */)out_buffer, (size_t )1, (size_t )((int )ibytes),
              (FILE */* __restrict  */)infp);
#line 264
  n = (int )tmp;
  }
#line 265
  if ((unsigned long )n != ibytes) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 270
    exit(1);
    }
  }
#line 272
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/pit.c"
static void pit_huffman(unsigned long obytes ) 
{ 


  {
  {
#line 280
  de_huffman(obytes);
  }
#line 281
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___6[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 55 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___1(void) ;
#line 56
static void appledouble_namings___1(void) ;
#line 57
static void wr_appledouble_info___1(FILE *fp ) ;
#line 60
static void mk_share_name___1(void) ;
#line 73 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info___1[69]  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_data___1[207]  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_rsrc___1[69]  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_text___1[69]  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_unix___1[69]  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_bin___1[69]  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_folder___1[12]  = 
#line 79
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char share_name___1[256]  ;
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char hex___1[17]  = 
#line 82
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char infodir___3[13]  = 
#line 93
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info_appledouble___1[207UL + sizeof(infodir___3)]  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode___1  =    4;
#line 99 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_restricted___1  =    0;
#line 100 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_s_restricted___1  =    0;
#line 103 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char init_buffer___1[128]  ;
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *buffer___1  =    & init_buffer___1[0];
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *rbuffer___1  =    (char *)((void *)0);
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *dbuffer___1  =    (char *)((void *)0);
#line 106 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *ptr___1  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long rsz___1  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long dsz___1  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long totsize___1  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long maxsize___1  ;
#line 606 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___1(void) 
{ 
  struct stat stbuf ;
  int error ;
  int tmp ;

  {
  {
#line 610
  error = 0;
#line 612
  tmp = stat((char const   */* __restrict  */)(infodir___3), (struct stat */* __restrict  */)(& stbuf));
  }
#line 612
  if (tmp < 0) {
#line 613
    error ++;
  } else
#line 615
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 616
    error ++;
  }
#line 619
  if (error) {
    {
#line 620
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not in an AppleDouble folder.\n");
#line 621
    exit(1);
    }
  }
#line 623
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void appledouble_namings___1(void) 
{ 


  {
  {
#line 627
  mk_share_name___1();
#line 628
  sprintf((char */* __restrict  */)(f_info_appledouble___1), (char const   */* __restrict  */)"%s/%s",
          infodir___3, share_name___1);
#line 629
  sprintf((char */* __restrict  */)(f_data___1), (char const   */* __restrict  */)"%s",
          share_name___1);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void wr_appledouble_info___1(FILE *fp ) 
{ 
  FileInfo theinfo ;
  int n ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 638
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 639
  put4(theinfo.fi_magic, 333319UL);
#line 640
  put2(theinfo.fi_version, 1UL);
#line 641
  put4(theinfo.fi_fill5, 5UL);
#line 642
  put4(theinfo.fi_fill6, 2UL);
#line 643
  put4(theinfo.fi_hlen, 589UL);
#line 644
  put4(theinfo.fi_fill7, 3UL);
#line 645
  put4(theinfo.fi_namptr, 86UL);
#line 646
  put4(theinfo.fi_fill9, 4UL);
#line 647
  put4(theinfo.fi_commptr, 341UL);
#line 648
  put4(theinfo.fi_fill12, 7UL);
#line 649
  put4(theinfo.fi_timeptr, 541UL);
#line 650
  put4(theinfo.fi_timesize, 16UL);
#line 651
  put4(theinfo.fi_fill15, 9UL);
#line 652
  put4(theinfo.fi_infoptr, 557UL);
#line 653
  put4(theinfo.fi_infosize, 32UL);
#line 655
  bcopy(buffer___1 + 65, theinfo.fi_type, 4);
#line 656
  bcopy(buffer___1 + 69, theinfo.fi_auth, 4);
#line 657
  bcopy(buffer___1 + 73, theinfo.fi_finfo, 2);
#line 659
  tmp = get4(buffer___1 + 91);
#line 659
  put4(theinfo.fi_ctime, tmp - 2082844800UL);
#line 660
  tmp___0 = get4(buffer___1 + 95);
#line 660
  put4(theinfo.fi_mtime, tmp___0 - 2082844800UL);
#line 661
  n = (int )*(buffer___1 + 1) & 255;
  }
#line 661
  if (n > 63) {
#line 662
    n = 63;
  }
  {
#line 664
  put4(theinfo.fi_namlen, (unsigned long )n);
#line 665
  strncpy(theinfo.fi_name, (buffer___1 + 1) + 1, n);
#line 667
  strcpy(theinfo.fi_comment, "Converted by Unix utility to AppleDouble format");
#line 669
  tmp___1 = (int )strlen(theinfo.fi_comment);
#line 669
  put4(theinfo.fi_commsize, (unsigned long )tmp___1);
#line 670
  put4(theinfo.fi_rsrc, rsz___1);
#line 674
  fwrite((void const   */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
         (FILE */* __restrict  */)fp);
  }
#line 675
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void mk_share_name___1(void) 
{ 
  int ch ;
  char *mp ;
  char *up ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 683
  mp = buffer___1 + 2;
#line 684
  up = & share_name___1[0];
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    tmp___5 = mp;
#line 685
    mp ++;
#line 685
    ch = (int )*tmp___5;
#line 685
    if (! ch) {
#line 685
      goto while_break;
    }
#line 686
    if ((ch & -128) == 0) {
      {
#line 686
      tmp___3 = __ctype_b_loc();
      }
#line 686
      if ((int const   )*(*tmp___3 + ch) & 2) {
#line 686
        goto _L___1;
      } else {
        {
#line 686
        tmp___4 = __ctype_b_loc();
        }
#line 686
        if ((int const   )*(*tmp___4 + ch) & 16384) {
#line 686
          if (ch != 47) {
#line 687
            tmp = up;
#line 687
            up ++;
#line 687
            *tmp = (char )ch;
          } else {
#line 686
            goto _L___1;
          }
        } else {
#line 686
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 689
      tmp___0 = up;
#line 689
      up ++;
#line 689
      *tmp___0 = (char )':';
#line 690
      tmp___1 = up;
#line 690
      up ++;
#line 690
      *tmp___1 = hex___1[(ch >> 4) & 15];
#line 691
      tmp___2 = up;
#line 691
      up ++;
#line 691
      *tmp___2 = hex___1[ch & 15];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  *up = (char)0;
#line 695
  return;
}
}
#line 817 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char options___7[20]  ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
static unsigned short crctab___12[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/binhex.c"
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
void de_lzah(unsigned long obytes ) ;
#line 23
unsigned char (*lzah_getbyte)() ;
#line 31 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static struct methodinfo methods[9]  = 
#line 31
  {      {(char *)"-lh0-", 0}, 
        {(char *)"-lh1-", 1}, 
        {(char *)"-lh2-", 2}, 
        {(char *)"-lh3-", 3}, 
        {(char *)"-lh4-", 4}, 
        {(char *)"-lh5-", 5}, 
        {(char *)"-lz4-", 6}, 
        {(char *)"-lz5-", 7}, 
        {(char *)"-lzs-", 8}};
#line 42 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_archive  ;
#line 43 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_pointer  ;
#line 44 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_data  ;
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_finfo  ;
#line 46 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int lzh_fsize  ;
#line 47 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int lzh_kind  ;
#line 48 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int oldsize  ;
#line 49 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_file  ;
#line 50 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int lzh_filesize  ;
#line 51 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_current  ;
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *tmp_out_ptr  ;
#line 53 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char lzh_lzbuf[8192]  ;
#line 55
static int lzh_filehdr(struct fileHdr *f ) ;
#line 56
static int lzh_checkm(struct fileHdr *f ) ;
#line 57
static char *lzh_methname(int n ) ;
#line 58
static void lzh_wrfile(struct fileHdr *filehdr , int method ) ;
#line 59
static void lzh_skip(struct fileHdr *filehdr ) ;
#line 60
static void lzh_nocomp(unsigned long obytes ) ;
#line 62
static void lzh_lzss1(unsigned long obytes ) ;
#line 63
static void lzh_lzss2(unsigned long obytes ) ;
#line 65
static void lzh_lzah(unsigned long obytes ) ;
#line 66
static unsigned char lzh_getbyte(void) ;
#line 72
static void lzh_lzh12(unsigned long obytes ) ;
#line 74
static void lzh_lzh13(unsigned long obytes ) ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
void lzh(int kind ) 
{ 
  struct fileHdr filehdr ;
  int m ;
  int i ;
  int j ;
  char loc_name[64] ;
  char dirinfo[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 84
  updcrc = & arc_updcrc;
#line 85
  crcinit = arc_crcinit;
#line 86
  write_it = 1;
#line 87
  lzh_fsize = 0;
#line 88
  lzh_kind = kind;
#line 89
  if ((unsigned long )lzh_archive == (unsigned long )((void *)0)) {
    {
#line 90
    lzh_archive = malloc((unsigned int )in_data_size);
#line 91
    oldsize = in_data_size;
    }
  } else
#line 92
  if (in_data_size > oldsize) {
    {
#line 93
    lzh_archive = realloc(lzh_archive, (unsigned int )in_data_size);
#line 94
    oldsize = in_data_size;
    }
  }
#line 96
  if ((unsigned long )lzh_archive == (unsigned long )((void *)0)) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory for archive.\n");
#line 98
    exit(1);
    }
  }
  {
#line 100
  tmp = fread((void */* __restrict  */)lzh_archive, (size_t )1, (size_t )in_data_size,
              (FILE */* __restrict  */)infp);
  }
#line 100
  if (tmp != (size_t )in_data_size) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read archive.\n");
#line 105
    exit(1);
    }
  }
#line 107
  lzh_pointer = lzh_archive;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (in_data_size == 0) {
#line 110
      goto while_break;
    }
    {
#line 112
    tmp___0 = lzh_filehdr(& filehdr);
    }
#line 112
    if (tmp___0 == 0) {
#line 113
      goto while_break;
    }
    {
#line 115
    m = lzh_checkm(& filehdr);
    }
#line 116
    if (m < 0) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping file: \"%s\"; unknown method: %.5s.\n",
              text, filehdr.method);
#line 120
      lzh_skip(& filehdr);
      }
#line 121
      goto while_continue;
    }
#line 123
    if (! write_it) {
#line 126
      if (lzh_fsize <= (int )filehdr.extendsize) {
        {
#line 126
        tmp___1 = strncmp(lzh_finfo, filehdr.extend, lzh_fsize);
        }
#line 126
        if (! tmp___1) {
          {
#line 129
          lzh_skip(& filehdr);
          }
#line 130
          goto while_continue;
        }
      }
    }
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (lzh_fsize > (int )filehdr.extendsize)) {
        {
#line 136
        tmp___2 = strncmp(lzh_finfo, filehdr.extend, lzh_fsize);
        }
#line 136
        if (! tmp___2) {
#line 136
          goto while_break___0;
        }
      }
#line 139
      i = lzh_fsize - 1;
      {
#line 140
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 140
        i --;
#line 140
        if (i >= 0) {
#line 140
          if (! ((int )*(lzh_finfo + i) != 58)) {
#line 140
            goto while_break___1;
          }
        } else {
#line 140
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 141
      i ++;
#line 142
      transname(lzh_finfo + i, loc_name, (lzh_fsize - i) - 1);
#line 143
      lzh_fsize = i;
      }
#line 144
      if (write_it) {
#line 145
        indent --;
#line 146
        if (! info_only) {
          {
#line 147
          enddir();
          }
        }
#line 149
        if (list) {
          {
#line 150
          do_indent(indent);
#line 151
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
                  loc_name);
          }
        }
      }
#line 154
      write_it = 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    write_it = 1;
#line 158
    lzh_finfo = filehdr.extend;
    {
#line 160
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 160
      if (! (lzh_fsize < (int )filehdr.extendsize)) {
#line 160
        goto while_break___2;
      }
#line 161
      i = lzh_fsize;
      {
#line 162
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 162
        i ++;
#line 162
        if (! ((int )*(lzh_finfo + i) != 58)) {
#line 162
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 163
      transname(lzh_finfo + lzh_fsize, loc_name, i - lzh_fsize);
#line 164
      j = 0;
      }
      {
#line 164
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 164
        if (! (j < 128)) {
#line 164
          goto while_break___4;
        }
#line 165
        dirinfo[j] = (char)0;
#line 164
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 167
      dirinfo[1] = (char )(i - lzh_fsize);
#line 168
      copy((dirinfo + 1) + 1, lzh_finfo + lzh_fsize, i - lzh_fsize);
#line 169
      lzh_fsize = i + 1;
      }
#line 170
      if (list) {
        {
#line 171
        do_indent(indent);
#line 172
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
                loc_name);
        }
#line 173
        if (query) {
          {
#line 174
          write_it = do_query();
          }
        } else {
          {
#line 176
          fputc('\n', stderr);
          }
        }
#line 178
        if (write_it) {
#line 179
          indent ++;
        }
      }
#line 182
      if (write_it) {
#line 182
        if (! info_only) {
          {
#line 183
          do_mkdir(loc_name, dirinfo);
          }
        }
      }
#line 185
      if (! write_it) {
#line 186
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 189
    if (! write_it) {
      {
#line 190
      lzh_skip(& filehdr);
      }
    } else {
      {
#line 192
      lzh_wrfile(& filehdr, m);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 196
    if (! (lzh_fsize != 0)) {
#line 196
      goto while_break___5;
    }
#line 197
    i = lzh_fsize - 1;
    {
#line 198
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 198
      i --;
#line 198
      if (i >= 0) {
#line 198
        if (! ((int )*(lzh_finfo + i) != 58)) {
#line 198
          goto while_break___6;
        }
      } else {
#line 198
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 199
    i ++;
#line 200
    transname(lzh_finfo + i, loc_name, (lzh_fsize - i) - 1);
#line 201
    lzh_fsize = i;
    }
#line 204
    if (write_it) {
#line 205
      indent --;
#line 206
      if (! info_only) {
        {
#line 207
        enddir();
        }
      }
#line 209
      if (list) {
        {
#line 210
        do_indent(indent);
#line 211
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
                loc_name);
        }
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int lzh_filehdr(struct fileHdr *f ) 
{ 
  register int i ;
  char *hdr ;
  int c ;
  int ext_ptr ;
  int chk_sum ;
  char *ptr___3 ;
  char *tmp ;
  unsigned long tmp___0 ;
  unsigned short tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 224
  chk_sum = 0;
#line 227
  if (in_data_size <= 0) {
#line 228
    return (0);
  }
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < 128)) {
#line 230
      goto while_break;
    }
#line 231
    info[i] = (char )'\000';
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  hdr = lzh_pointer;
#line 234
  in_data_size -= 2;
#line 235
  lzh_pointer += 2;
#line 236
  if (in_data_size < 0) {
#line 237
    in_data_size ++;
  }
#line 239
  f->hsize = (unsigned char )*(hdr + 0);
#line 240
  if ((int )f->hsize == 0) {
#line 241
    return (0);
  }
  {
#line 243
  f->hcrc = (unsigned char )*(hdr + 1);
#line 244
  ptr___3 = hdr + 2;
#line 245
  in_data_size -= (int )f->hsize;
#line 246
  lzh_pointer += (int )f->hsize;
#line 247
  copy(& f->method[0], hdr + 2, 5);
#line 248
  f->psize = get4i(hdr + 7);
#line 249
  f->upsize = get4i(hdr + 11);
#line 250
  f->lastmod = get4i(hdr + 15);
#line 251
  f->attribute = (unsigned short )*(hdr + 20);
  }
#line 252
  if ((int )f->attribute < 2) {
#line 253
    i = 0;
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! (i < (int )f->hsize)) {
#line 253
        goto while_break___0;
      }
#line 254
      tmp = ptr___3;
#line 254
      ptr___3 ++;
#line 254
      chk_sum += (int )*tmp;
#line 253
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    chk_sum &= 255;
#line 257
    if (chk_sum != (int )f->hcrc) {
      {
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header checksum error; got %.2x, must be %.2x.\n",
              chk_sum, (int )f->hcrc);
#line 264
      exit(1);
      }
    }
    {
#line 266
    f->nlength = (unsigned char )*(hdr + 21);
#line 267
    info[1] = (char )f->nlength;
#line 268
    copy((info + 1) + 1, hdr + 22, (int )f->nlength);
#line 269
    transname(hdr + 22, text, (int )f->nlength);
#line 270
    ext_ptr = (21 + (int )f->nlength) + 1;
#line 271
    tmp___0 = get2i((hdr + ext_ptr) + 0);
#line 271
    f->crc = (unsigned short )tmp___0;
    }
#line 272
    if ((int )f->attribute == 1) {
#line 273
      f->etype = (unsigned char )*(hdr + (ext_ptr + 2));
#line 274
      f->extendsize = (unsigned char )*(hdr + (ext_ptr + 3));
#line 275
      f->extend = (hdr + ext_ptr) + 4;
    } else {
#line 277
      f->extend = (char *)((void *)0);
#line 278
      f->extendsize = (unsigned char)0;
    }
  } else
#line 280
  if ((int )f->attribute == 2) {
    {
#line 281
    in_data_size += 2;
#line 282
    lzh_pointer -= 2;
#line 283
    f->nlength = (unsigned char )((int )*(hdr + 24) - 3);
#line 284
    info[1] = (char )f->nlength;
#line 285
    copy((info + 1) + 1, (hdr + 25) + 2, (int )f->nlength);
#line 286
    transname((hdr + 25) + 2, text, (int )f->nlength);
#line 287
    tmp___2 = get2i(hdr + 21);
#line 287
    tmp___1 = (unsigned short )tmp___2;
#line 287
    f->crc = tmp___1;
#line 287
    ext_ptr = (int )tmp___1;
#line 289
    f->etype = (unsigned char )*(hdr + 23);
#line 290
    ext_ptr = 27 + (int )f->nlength;
#line 291
    f->extendsize = (unsigned char )*(hdr + ext_ptr);
#line 292
    f->extend = (hdr + ext_ptr) + 1;
    }
  } else {
    {
#line 294
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown file header format (%d).\n",
            (int )f->attribute);
#line 299
    exit(1);
    }
  }
#line 301
  if ((unsigned long )f->extend != (unsigned long )((void *)0)) {
#line 302
    if ((int )f->extendsize > 5) {
#line 303
      f->extend += 2;
#line 304
      hdr = f->extend;
#line 305
      f->extendsize = (unsigned char )((int )f->extendsize - 3);
#line 306
      i = 0;
      {
#line 306
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 306
        if (! (i < (int )f->extendsize)) {
#line 306
          goto while_break___1;
        }
#line 307
        tmp___3 = hdr;
#line 307
        hdr ++;
#line 307
        c = (int )*tmp___3;
#line 308
        if ((c & 255) == 255) {
#line 309
          *(hdr + -1) = (char )':';
#line 310
          c = ':';
        }
#line 306
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 313
      tmp___4 = hdr;
#line 313
      hdr ++;
#line 313
      c = (int )*tmp___4;
#line 314
      if (c == 5) {
#line 315
        hdr += 5;
      }
    } else
#line 318
    if ((int )f->extendsize == 5) {
#line 319
      hdr = f->extend;
#line 320
      f->extend = (char *)((void *)0);
#line 321
      f->extendsize = (unsigned char)0;
#line 322
      hdr += 5;
    } else {
#line 324
      hdr = f->extend;
#line 325
      f->extend = (char *)((void *)0);
#line 326
      f->extendsize = (unsigned char)0;
    }
  } else {
#line 330
    hdr += ext_ptr;
  }
#line 332
  lzh_data = hdr;
#line 333
  if ((int )f->attribute != 0) {
#line 334
    lzh_data ++;
  }
#line 336
  return (1);
}
}
#line 339 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static int lzh_checkm(struct fileHdr *f ) 
{ 
  int i ;
  int nummeth ;
  char *meth ;
  int tmp ;

  {
#line 345
  meth = f->method;
#line 346
  nummeth = (int )(sizeof(methods) / sizeof(struct methodinfo ));
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < nummeth)) {
#line 347
      goto while_break;
    }
    {
#line 348
    tmp = strncmp(methods[i].name, meth, 5);
    }
#line 348
    if (! tmp) {
#line 349
      return (methods[i].number);
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return (-1);
}
}
#line 355 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static char *lzh_methname(int n ) 
{ 


  {
#line 358
  if ((unsigned long )n > sizeof(methods) / sizeof(struct methodinfo )) {
#line 359
    return ((char *)((void *)0));
  }
#line 361
  return (methods[n].name);
}
}
#line 364 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_wrfile(struct fileHdr *filehdr , int method ) 
{ 
  char ftype[5] ;
  char fauth[5] ;
  int rsrcLength ;
  int dataLength ;
  int doit ;
  char *mname ;
  unsigned long crc___0 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 374
  if (filehdr->upsize > (unsigned long )lzh_filesize) {
#line 375
    if (lzh_filesize == 0) {
      {
#line 376
      lzh_file = malloc((unsigned int )filehdr->upsize);
      }
    } else {
      {
#line 378
      lzh_file = realloc(lzh_file, (unsigned int )filehdr->upsize);
      }
    }
#line 380
    if ((unsigned long )lzh_file == (unsigned long )((void *)0)) {
      {
#line 381
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to unpack file.\n");
#line 382
      exit(1);
      }
    }
  }
  {
#line 386
  if (method == 6) {
#line 386
    goto case_6;
  }
#line 390
  if (method == 7) {
#line 390
    goto case_7;
  }
#line 393
  if (method == 8) {
#line 393
    goto case_8;
  }
#line 397
  if (method == 0) {
#line 397
    goto case_0;
  }
#line 400
  if (method == 1) {
#line 400
    goto case_1;
  }
#line 412
  if (method == 4) {
#line 412
    goto case_4;
  }
#line 416
  if (method == 5) {
#line 416
    goto case_5;
  }
#line 419
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 387
  lzh_nocomp(128UL);
  }
#line 388
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 391
  lzh_lzss1(128UL);
  }
#line 392
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 394
  lzh_lzss2(128UL);
  }
#line 395
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 398
  lzh_nocomp(128UL);
  }
#line 399
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 401
  lzh_lzah(128UL);
  }
#line 402
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 413
  lzh_lzh12(128UL);
  }
#line 414
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 417
  lzh_lzh13(128UL);
  }
#line 418
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 420
  mname = lzh_methname(method);
  }
#line 421
  if ((unsigned long )mname != (unsigned long )((void *)0)) {
    {
#line 422
    do_indent(indent);
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tSorry, packing method not yet implemented.\n");
#line 425
    do_indent(indent);
#line 426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File = \"%s\"; ",
            text);
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"method = %s, skipping file.\n",
            mname);
#line 428
    lzh_skip(filehdr);
    }
#line 429
    return;
  }
  {
#line 431
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There is something very wrong with this program!\n");
#line 436
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 439
  if ((int )*lzh_file != 0) {
    {
#line 440
    do_indent(indent);
#line 441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File = \"%s\" ",
            text);
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not packed in MacBinary, skipping file.\n");
#line 446
    lzh_skip(filehdr);
    }
#line 447
    return;
  }
  {
#line 449
  copy(info, lzh_file, 128);
#line 450
  tmp = get4(info + 87);
#line 450
  rsrcLength = (int )tmp;
#line 451
  tmp___0 = get4(info + 83);
#line 451
  dataLength = (int )tmp___0;
#line 452
  transname(info + 65, ftype, 4);
#line 453
  transname(info + 69, fauth, 4);
  }
#line 454
  if (list) {
    {
#line 455
    do_indent(indent);
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )dataLength, (long )rsrcLength);
    }
  }
#line 460
  if (info_only) {
#line 461
    doit = 0;
  } else {
#line 463
    doit = 1;
  }
#line 465
  if (query) {
    {
#line 466
    doit = do_query();
    }
  } else
#line 467
  if (list) {
    {
#line 468
    fputc('\n', stderr);
    }
  }
#line 470
  if (doit) {
    {
#line 471
    define_name(text);
#line 472
    start_info(info, (unsigned long )rsrcLength, (unsigned long )dataLength);
    }
  }
  {
#line 475
  if (method == 6) {
#line 475
    goto case_6___0;
  }
#line 484
  if (method == 7) {
#line 484
    goto case_7___0;
  }
#line 493
  if (method == 8) {
#line 493
    goto case_8___0;
  }
#line 503
  if (method == 0) {
#line 503
    goto case_0___0;
  }
#line 511
  if (method == 1) {
#line 511
    goto case_1___0;
  }
#line 541
  if (method == 4) {
#line 541
    goto case_4___0;
  }
#line 551
  if (method == 5) {
#line 551
    goto case_5___0;
  }
#line 474
  goto switch_break___0;
  case_6___0: /* CIL Label */ 
#line 476
  if (verbose) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tNo Compression (%.5s)",
            filehdr->method);
    }
  }
#line 479
  if (doit) {
    {
#line 480
    lzh_nocomp(filehdr->upsize);
    }
  }
#line 482
  goto switch_break___0;
  case_7___0: /* CIL Label */ 
#line 485
  if (verbose) {
    {
#line 486
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tLZSS (%.5s) compressed (%4.1f%%)",
            filehdr->method, (100.0 * (double )filehdr->psize) / (double )filehdr->upsize);
    }
  }
#line 489
  if (doit) {
    {
#line 490
    lzh_lzss1(filehdr->upsize);
    }
  }
#line 492
  goto switch_break___0;
  case_8___0: /* CIL Label */ 
#line 494
  if (verbose) {
    {
#line 495
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tLZSS (%.5s) compressed (%4.1f%%)",
            filehdr->method, (100.0 * (double )filehdr->psize) / (double )filehdr->upsize);
    }
  }
#line 498
  if (doit) {
    {
#line 499
    lzh_lzss2(filehdr->upsize);
    }
  }
#line 501
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 504
  if (verbose) {
    {
#line 505
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tNo Compression (%.5s)",
            filehdr->method);
    }
  }
#line 507
  if (doit) {
    {
#line 508
    lzh_nocomp(filehdr->upsize);
    }
  }
#line 510
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 512
  if (verbose) {
    {
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tLZAH (%.5s) compressed (%4.1f%%)",
            filehdr->method, (100.0 * (double )filehdr->psize) / (double )filehdr->upsize);
    }
  }
#line 516
  if (doit) {
    {
#line 517
    lzh_lzah(filehdr->upsize);
    }
  }
#line 519
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 542
  if (verbose) {
    {
#line 543
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tLZH (%.5s) compressed (%4.1f%%)",
            filehdr->method, (100.0 * (double )filehdr->psize) / (double )filehdr->upsize);
    }
  }
#line 546
  if (doit) {
    {
#line 547
    lzh_lzh12(filehdr->upsize);
    }
  }
#line 549
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 552
  if (verbose) {
    {
#line 553
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tLZH (%.5s) compressed (%4.1f%%)",
            filehdr->method, (100.0 * (double )filehdr->psize) / (double )filehdr->upsize);
    }
  }
#line 556
  if (doit) {
    {
#line 557
    lzh_lzh13(filehdr->upsize);
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 560
  if (doit) {
    {
#line 561
    crc___0 = (*updcrc)(crcinit, lzh_file, filehdr->upsize);
    }
#line 562
    if ((unsigned long )filehdr->crc != crc___0) {
      {
#line 563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on file: need 0x%04x, got 0x%04x\n",
              (int )filehdr->crc, (int )crc___0);
#line 569
      exit(1);
      }
    }
    {
#line 571
    start_data();
#line 572
    copy(out_ptr, lzh_file + 128, (int )(filehdr->upsize - 128UL));
    }
  }
#line 574
  if (verbose) {
    {
#line 575
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 577
  if (doit) {
    {
#line 578
    end_file();
    }
  }
  {
#line 580
  lzh_skip(filehdr);
  }
#line 581
  return;
}
}
#line 583 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_skip(struct fileHdr *filehdr ) 
{ 


  {
#line 586
  lzh_pointer += filehdr->psize;
#line 587
  in_data_size = (int )((unsigned long )in_data_size - filehdr->psize);
#line 588
  return;
}
}
#line 593 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_nocomp(unsigned long obytes ) 
{ 


  {
  {
#line 596
  copy(lzh_file, lzh_data, (int )obytes);
  }
#line 597
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_lzss1(unsigned long obytes ) 
{ 
  int mask ;
  int ch ;
  int lzcnt ;
  int lzptr ;
  int ptr___3 ;
  int count ;
  char *p ;
  int i ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 607
  p = lzh_lzbuf;
#line 610
  i = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (i < 256)) {
#line 610
      goto while_break;
    }
#line 611
    j = 0;
    {
#line 611
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 611
      if (! (j < 13)) {
#line 611
        goto while_break___0;
      }
#line 612
      tmp = p;
#line 612
      p ++;
#line 612
      *tmp = (char )i;
#line 611
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 615
    if (! (i < 256)) {
#line 615
      goto while_break___1;
    }
#line 616
    tmp___0 = p;
#line 616
    p ++;
#line 616
    *tmp___0 = (char )i;
#line 615
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 618
  i = 0;
  {
#line 618
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 618
    if (! (i < 256)) {
#line 618
      goto while_break___2;
    }
#line 619
    tmp___1 = p;
#line 619
    p ++;
#line 619
    *tmp___1 = (char )(255 - i);
#line 618
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 621
  i = 0;
  {
#line 621
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 621
    if (! (i < 128)) {
#line 621
      goto while_break___3;
    }
#line 622
    tmp___2 = p;
#line 622
    p ++;
#line 622
    *tmp___2 = (char)0;
#line 621
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 624
  i = 0;
  {
#line 624
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 624
    if (! (i < 128)) {
#line 624
      goto while_break___4;
    }
#line 625
    tmp___3 = p;
#line 625
    p ++;
#line 625
    *tmp___3 = (char )' ';
#line 624
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 628
  tmp_out_ptr = out_ptr;
#line 629
  out_ptr = lzh_file;
#line 630
  ptr___3 = 8174;
#line 631
  count = 0;
#line 632
  lzh_current = lzh_data;
  {
#line 633
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 633
    if (! (obytes != 0UL)) {
#line 633
      goto while_break___5;
    }
#line 634
    if (count == 0) {
#line 635
      tmp___4 = lzh_current;
#line 635
      lzh_current ++;
#line 635
      mask = (int )*tmp___4 & 255;
#line 636
      count = 8;
    }
#line 638
    count --;
#line 639
    tmp___5 = lzh_current;
#line 639
    lzh_current ++;
#line 639
    ch = (int )*tmp___5 & 255;
#line 640
    if ((mask & 1) != 0) {
#line 641
      tmp___6 = out_ptr;
#line 641
      out_ptr ++;
#line 641
      *tmp___6 = (char )ch;
#line 642
      tmp___7 = ptr___3;
#line 642
      ptr___3 ++;
#line 642
      lzh_lzbuf[tmp___7] = (char )ch;
#line 643
      ptr___3 &= 8191;
#line 644
      obytes --;
    } else {
#line 646
      tmp___8 = lzh_current;
#line 646
      lzh_current ++;
#line 646
      lzcnt = (int )*tmp___8;
#line 647
      lzptr = (ch & 255) | ((lzcnt << 4) & 3840);
#line 648
      lzcnt = (lzcnt & 15) + 3;
#line 649
      obytes -= (unsigned long )lzcnt;
      {
#line 650
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 651
        tmp___9 = lzptr;
#line 651
        lzptr ++;
#line 651
        ch = (int )lzh_lzbuf[tmp___9];
#line 652
        tmp___10 = ptr___3;
#line 652
        ptr___3 ++;
#line 652
        lzh_lzbuf[tmp___10] = (char )ch;
#line 653
        tmp___11 = out_ptr;
#line 653
        out_ptr ++;
#line 653
        *tmp___11 = (char )ch;
#line 654
        lzptr &= 8191;
#line 655
        ptr___3 &= 8191;
#line 650
        lzcnt --;
#line 650
        if (! (lzcnt != 0)) {
#line 650
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 658
    mask >>= 1;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 660
  out_ptr = tmp_out_ptr;
#line 661
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_lzss2(unsigned long obytes ) 
{ 
  int ch ;
  int lzcnt ;
  int lzptr ;
  int ptr___3 ;
  int i ;
  unsigned int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 671
  tmp_out_ptr = out_ptr;
#line 672
  out_ptr = lzh_file;
#line 673
  ptr___3 = 4079;
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (i < ptr___3)) {
#line 674
      goto while_break;
    }
#line 675
    lzh_lzbuf[i] = (char )' ';
#line 674
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  i = ptr___3;
  {
#line 677
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 677
    if (! (i < 4096)) {
#line 677
      goto while_break___0;
    }
#line 678
    lzh_lzbuf[i] = (char)0;
#line 677
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 680
  bit_be_init_getbits();
#line 681
  bit_be_filestart = lzh_data;
#line 682
  bit_be_inbytes = -1;
  }
  {
#line 683
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 683
    if (! (obytes != 0UL)) {
#line 683
      goto while_break___1;
    }
    {
#line 684
    tmp___7 = bit_be_getbits(1);
    }
#line 684
    if (tmp___7 == 0U) {
      {
#line 685
      tmp = bit_be_getbits(8);
#line 685
      ch = (int )tmp;
#line 686
      tmp___0 = out_ptr;
#line 686
      out_ptr ++;
#line 686
      *tmp___0 = (char )ch;
#line 687
      tmp___1 = ptr___3;
#line 687
      ptr___3 ++;
#line 687
      lzh_lzbuf[tmp___1] = (char )ch;
#line 688
      ptr___3 &= 4095;
#line 689
      obytes --;
      }
    } else {
      {
#line 691
      tmp___2 = bit_be_getbits(11);
#line 691
      lzptr = (int )tmp___2;
#line 692
      tmp___3 = bit_be_getbits(4);
#line 692
      lzcnt = (int )(tmp___3 + 3U);
#line 693
      obytes -= (unsigned long )lzcnt;
      }
      {
#line 694
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 695
        tmp___4 = lzptr;
#line 695
        lzptr ++;
#line 695
        ch = (int )lzh_lzbuf[tmp___4];
#line 696
        tmp___5 = ptr___3;
#line 696
        ptr___3 ++;
#line 696
        lzh_lzbuf[tmp___5] = (char )ch;
#line 697
        tmp___6 = out_ptr;
#line 697
        out_ptr ++;
#line 697
        *tmp___6 = (char )ch;
#line 698
        lzptr &= 4095;
#line 699
        ptr___3 &= 4095;
#line 694
        lzcnt --;
#line 694
        if (! (lzcnt != 0)) {
#line 694
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 703
  out_ptr = tmp_out_ptr;
#line 704
  return;
}
}
#line 710 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_lzah(unsigned long obytes ) 
{ 


  {
  {
#line 713
  lzh_current = lzh_data + 2;
#line 714
  tmp_out_ptr = out_ptr;
#line 715
  out_ptr = lzh_file;
#line 716
  lzah_getbyte = & lzh_getbyte;
#line 717
  de_lzah(obytes);
#line 718
  out_ptr = tmp_out_ptr;
  }
#line 719
  return;
}
}
#line 721 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static unsigned char lzh_getbyte(void) 
{ 
  char *tmp ;

  {
#line 723
  tmp = lzh_current;
#line 723
  lzh_current ++;
#line 723
  return ((unsigned char )*tmp);
}
}
#line 748 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_lzh12(unsigned long obytes ) 
{ 


  {
  {
#line 751
  lzh_current = lzh_data;
#line 752
  tmp_out_ptr = out_ptr;
#line 753
  out_ptr = lzh_file;
#line 755
  de_lzh(-1L, (long )obytes, & lzh_current, 12);
#line 756
  out_ptr = tmp_out_ptr;
  }
#line 757
  return;
}
}
#line 763 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzh.c"
static void lzh_lzh13(unsigned long obytes ) 
{ 


  {
  {
#line 766
  lzh_current = lzh_data;
#line 767
  tmp_out_ptr = out_ptr;
#line 768
  out_ptr = lzh_file;
#line 770
  de_lzh(-1L, (long )obytes, & lzh_current, 13);
#line 771
  out_ptr = tmp_out_ptr;
  }
#line 772
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dir.c"
static char *dir_stack___2  ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dir.c"
static int dir_ptr___2  =    -64;
#line 12 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dir.c"
static int dir_max___2  ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.h"
unsigned int bit_be_bitbuf  ;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.h"
char *bit_be_filestart  ;
#line 5 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.h"
int bit_be_inbytes  ;
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.c"
static unsigned int bit_be_subbitbuf  ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.c"
static int bit_be_bitcount  ;
#line 11 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.c"
void bit_be_fillbuf(int n ) 
{ 
  char *tmp ;

  {
#line 14
  bit_be_bitbuf <<= n;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (n > bit_be_bitcount)) {
#line 15
      goto while_break;
    }
#line 16
    n -= bit_be_bitcount;
#line 16
    bit_be_bitbuf |= bit_be_subbitbuf << n;
#line 17
    if (bit_be_inbytes == 0) {
#line 18
      bit_be_subbitbuf = 0U;
    } else {
#line 20
      tmp = bit_be_filestart;
#line 20
      bit_be_filestart ++;
#line 20
      bit_be_subbitbuf = (unsigned int )((int )*tmp & 255);
#line 21
      bit_be_inbytes --;
    }
#line 23
    bit_be_bitcount = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  bit_be_bitcount -= n;
#line 25
  bit_be_bitbuf |= bit_be_subbitbuf >> bit_be_bitcount;
#line 26
  bit_be_bitbuf &= 65535U;
#line 27
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.c"
unsigned int bit_be_getbits(int n ) 
{ 
  unsigned int x ;

  {
  {
#line 34
  x = bit_be_bitbuf >> (16 - n);
#line 35
  bit_be_fillbuf(n);
  }
#line 36
  return (x);
}
}
#line 39 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/bits_be.c"
void bit_be_init_getbits(void) 
{ 


  {
  {
#line 41
  bit_be_bitbuf = 0U;
#line 42
  bit_be_subbitbuf = 0U;
#line 43
  bit_be_bitcount = 0;
#line 44
  bit_be_fillbuf(16);
  }
#line 45
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
static unsigned long crctab___13[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/ccitt32.c"
  {      0UL,      79764919UL,      159529838UL,      222504665UL, 
        319059676UL,      398814059UL,      445009330UL,      507990021UL, 
        638119352UL,      583659535UL,      797628118UL,      726387553UL, 
        890018660UL,      835552979UL,      1015980042UL,      944750013UL, 
        1276238704UL,      1221641927UL,      1167319070UL,      1095957929UL, 
        1595256236UL,      1540665371UL,      1452775106UL,      1381403509UL, 
        1780037320UL,      1859660671UL,      1671105958UL,      1733955601UL, 
        2031960084UL,      2111593891UL,      1889500026UL,      1952343757UL, 
        2552477408UL,      2632100695UL,      2443283854UL,      2506133561UL, 
        2334638140UL,      2414271883UL,      2191915858UL,      2254759653UL, 
        3190512472UL,      3135915759UL,      3081330742UL,      3009969537UL, 
        2905550212UL,      2850959411UL,      2762807018UL,      2691435357UL, 
        3560074640UL,      3505614887UL,      3719321342UL,      3648080713UL, 
        3342211916UL,      3287746299UL,      3467911202UL,      3396681109UL, 
        4063920168UL,      4143685023UL,      4223187782UL,      4286162673UL, 
        3779000052UL,      3858754371UL,      3904687514UL,      3967668269UL, 
        881225847UL,      809987520UL,      1023691545UL,      969234094UL, 
        662832811UL,      591600412UL,      771767749UL,      717299826UL, 
        311336399UL,      374308984UL,      453813921UL,      533576470UL, 
        25881363UL,      88864420UL,      134795389UL,      214552010UL, 
        2023205639UL,      2086057648UL,      1897238633UL,      1976864222UL, 
        1804852699UL,      1867694188UL,      1645340341UL,      1724971778UL, 
        1587496639UL,      1516133128UL,      1461550545UL,      1406951526UL, 
        1302016099UL,      1230646740UL,      1142491917UL,      1087903418UL, 
        2896545431UL,      2825181984UL,      2770861561UL,      2716262478UL, 
        3215044683UL,      3143675388UL,      3055782693UL,      3001194130UL, 
        2326604591UL,      2389456536UL,      2200899649UL,      2280525302UL, 
        2578013683UL,      2640855108UL,      2418763421UL,      2498394922UL, 
        3769900519UL,      3832873040UL,      3912640137UL,      3992402750UL, 
        4088425275UL,      4151408268UL,      4197601365UL,      4277358050UL, 
        3334271071UL,      3263032808UL,      3476998961UL,      3422541446UL, 
        3585640067UL,      3514407732UL,      3694837229UL,      3640369242UL, 
        1762451694UL,      1842216281UL,      1619975040UL,      1682949687UL, 
        2047383090UL,      2127137669UL,      1938468188UL,      2001449195UL, 
        1325665622UL,      1271206113UL,      1183200824UL,      1111960463UL, 
        1543535498UL,      1489069629UL,      1434599652UL,      1363369299UL, 
        622672798UL,      568075817UL,      748617968UL,      677256519UL, 
        907627842UL,      853037301UL,      1067152940UL,      995781531UL, 
        51762726UL,      131386257UL,      177728840UL,      240578815UL, 
        269590778UL,      349224269UL,      429104020UL,      491947555UL, 
        4046411278UL,      4126034873UL,      4172115296UL,      4234965207UL, 
        3794477266UL,      3874110821UL,      3953728444UL,      4016571915UL, 
        3609705398UL,      3555108353UL,      3735388376UL,      3664026991UL, 
        3290680682UL,      3236090077UL,      3449943556UL,      3378572211UL, 
        3174993278UL,      3120533705UL,      3032266256UL,      2961025959UL, 
        2923101090UL,      2868635157UL,      2813903052UL,      2742672763UL, 
        2604032198UL,      2683796849UL,      2461293480UL,      2524268063UL, 
        2284983834UL,      2364738477UL,      2175806836UL,      2238787779UL, 
        1569362073UL,      1498123566UL,      1409854455UL,      1355396672UL, 
        1317987909UL,      1246755826UL,      1192025387UL,      1137557660UL, 
        2072149281UL,      2135122070UL,      1912620623UL,      1992383480UL, 
        1753615357UL,      1816598090UL,      1627664531UL,      1707420964UL, 
        295390185UL,      358241886UL,      404320391UL,      483945776UL, 
        43990325UL,      106832002UL,      186451547UL,      266083308UL, 
        932423249UL,      861060070UL,      1041341759UL,      986742920UL, 
        613929101UL,      542559546UL,      756411363UL,      701822548UL, 
        3316196985UL,      3244833742UL,      3425377559UL,      3370778784UL, 
        3601682597UL,      3530312978UL,      3744426955UL,      3689838204UL, 
        3819031489UL,      3881883254UL,      3928223919UL,      4007849240UL, 
        4037393693UL,      4100235434UL,      4180117107UL,      4259748804UL, 
        2310601993UL,      2373574846UL,      2151335527UL,      2231098320UL, 
        2596047829UL,      2659030626UL,      2470359227UL,      2550115596UL, 
        2947551409UL,      2876312838UL,      2788305887UL,      2733848168UL, 
        3165939309UL,      3094707162UL,      3040238851UL,      2985771188UL};
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzc.c"
void de_compress(unsigned long ibytes , int mb ) ;
#line 11
void core_compress(char *ptr___3 ) ;
#line 14
static void lzc_zivm(char *ohdr ) ;
#line 15
static void lzc_wrfile(unsigned long obytes , unsigned long ibytes ) ;
#line 16
static void lzc_zivu(char *ohdr ) ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzc.c"
void lzc(char *ohdr ) 
{ 
  int tmp ;

  {
  {
#line 21
  core_compress((char *)((void *)0));
#line 22
  tmp = strncmp(ohdr + 65, "ZIVM", 4);
  }
#line 22
  if (tmp) {
    {
#line 25
    lzc_zivu(ohdr);
    }
  } else {
    {
#line 23
    lzc_zivm(ohdr);
    }
  }
#line 27
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzc.c"
static void lzc_zivm(char *ohdr ) 
{ 
  char hdr[48] ;
  unsigned long dataLength ;
  unsigned long rsrcLength ;
  unsigned long dataCLength ;
  unsigned long rsrcCLength ;
  char ftype[5] ;
  char fauth[5] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = fread((void */* __restrict  */)(hdr), (size_t )1, (size_t )48, (FILE */* __restrict  */)infp);
  }
#line 36
  if (tmp != 48UL) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header\n");
#line 41
    exit(1);
    }
  }
  {
#line 43
  tmp___0 = strncmp(hdr, "\253\315\0000", 4);
  }
#line 43
  if (tmp___0) {
    {
#line 44
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic header mismatch\n");
#line 48
    exit(1);
    }
  }
  {
#line 50
  dataLength = get4(hdr + 4);
#line 51
  dataCLength = get4(hdr + 8);
#line 52
  rsrcLength = get4(hdr + 12);
#line 53
  rsrcCLength = get4(hdr + 16);
#line 55
  write_it = 1;
  }
#line 56
  if (list) {
    {
#line 57
    copy(info, ohdr, 128);
#line 58
    copy(info + 65, hdr + 32, 4);
#line 59
    copy(info + 69, hdr + 36, 4);
#line 60
    copy(info + 83, hdr + 4, 4);
#line 61
    copy(info + 87, hdr + 12, 4);
#line 62
    copy(info + 91, hdr + 28, 4);
#line 63
    copy(info + 95, hdr + 24, 4);
#line 64
    copy(info + 73, hdr + 40, 8);
#line 66
    transname((ohdr + 1) + 1, text, (int )*(ohdr + 1));
#line 67
    transname(hdr + 32, ftype, 4);
#line 68
    transname(hdr + 36, fauth, 4);
#line 69
    do_indent(indent);
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )dataLength, (long )rsrcLength);
    }
#line 73
    if (info_only) {
#line 74
      write_it = 0;
    }
#line 76
    if (query) {
      {
#line 77
      write_it = do_query();
      }
    } else {
      {
#line 79
      fputc('\n', stderr);
      }
    }
  }
#line 83
  if (write_it) {
    {
#line 84
    define_name(text);
    }
  }
#line 86
  if (write_it) {
    {
#line 87
    start_info(info, rsrcLength, dataLength);
    }
  }
#line 89
  if (verbose) {
    {
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tData: ");
    }
  }
#line 92
  if (write_it) {
    {
#line 93
    start_data();
    }
  }
  {
#line 95
  lzc_wrfile(dataLength, dataCLength);
  }
#line 96
  if (verbose) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Rsrc: ");
    }
  }
#line 99
  if (write_it) {
    {
#line 100
    start_rsrc();
    }
  }
  {
#line 102
  lzc_wrfile(rsrcLength, rsrcCLength);
  }
#line 103
  if (write_it) {
    {
#line 104
    end_file();
    }
  }
#line 106
  if (verbose) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzc.c"
static void lzc_wrfile(unsigned long obytes , unsigned long ibytes ) 
{ 
  int n ;
  int nbits ;
  char subheader[3] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 117
  if (ibytes == 0UL) {
#line 118
    if (verbose) {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    }
#line 121
    return;
  }
#line 123
  if (ibytes == obytes) {
#line 124
    if (verbose) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
      }
    }
#line 127
    if (write_it) {
      {
#line 128
      tmp = fread((void */* __restrict  */)out_buffer, (size_t )1, (size_t )((int )ibytes),
                  (FILE */* __restrict  */)infp);
#line 128
      n = (int )tmp;
      }
#line 129
      if ((unsigned long )n != ibytes) {
        {
#line 130
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 134
        exit(1);
        }
      }
    } else {
#line 137
      n = (int )ibytes;
      {
#line 138
      while (1) {
        while_continue: /* CIL Label */ ;
#line 138
        tmp___1 = n;
#line 138
        n --;
#line 138
        if (! (tmp___1 > 0)) {
#line 138
          goto while_break;
        }
        {
#line 139
        tmp___0 = _IO_getc(infp);
        }
#line 139
        if (tmp___0 == -1) {
          {
#line 140
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 144
          exit(1);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 149
    tmp___2 = fread((void */* __restrict  */)(subheader), (size_t )1, (size_t )3,
                    (FILE */* __restrict  */)infp);
    }
#line 149
    if (tmp___2 != 3UL) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 154
      exit(1);
      }
    }
    {
#line 156
    tmp___3 = strncmp(subheader, "\037\235", 2);
    }
#line 156
    if (tmp___3) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic subheader mismatch\n");
#line 161
      exit(1);
      }
    }
#line 163
    nbits = (int )subheader[2] & 127;
#line 164
    if (verbose) {
      {
#line 165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZC(%d) compressed (%4.1f%%)",
              nbits, (100.0 * (double )ibytes) / (double )obytes);
      }
    }
#line 168
    if (write_it) {
      {
#line 169
      de_compress(ibytes - 3UL, nbits);
      }
    } else {
#line 171
      n = (int )(ibytes - 3UL);
      {
#line 172
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 172
        tmp___5 = n;
#line 172
        n --;
#line 172
        if (! (tmp___5 > 0)) {
#line 172
          goto while_break___0;
        }
        {
#line 173
        tmp___4 = _IO_getc(infp);
        }
#line 173
        if (tmp___4 == -1) {
          {
#line 174
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 178
          exit(1);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/lzc.c"
static void lzc_zivu(char *ohdr ) 
{ 


  {
  {
#line 188
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tMacCompress(Unix) not yet implemented, copied as MacBinary\n");
#line 190
  mcb(ohdr, (unsigned long )in_rsrc_size, (unsigned long )in_data_size, in_ds + in_rs);
  }
#line 192
  return;
}
}
#line 7 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/mcb.c"
static int mcb_read___0  ;
#line 9
static void mcb_wrfile___0(unsigned long ibytes ) ;
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/mcb.c"
static void mcb_wrfile___0(unsigned long ibytes ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 87
  if (ibytes == 0UL) {
#line 88
    if (verbose) {
      {
#line 89
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    }
#line 91
    return;
  }
#line 93
  if (verbose) {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
    }
  }
#line 96
  if (write_it) {
    {
#line 97
    tmp = fread((void */* __restrict  */)out_buffer, (size_t )1, (size_t )((int )ibytes),
                (FILE */* __restrict  */)infp);
#line 97
    n = (int )tmp;
    }
#line 98
    if ((unsigned long )n != ibytes) {
      {
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 103
      exit(1);
      }
    }
#line 105
    mcb_read___0 -= n;
#line 106
    n = ((n + 127) / 128) * 128 - n;
#line 107
    if (n > mcb_read___0) {
#line 108
      n = mcb_read___0;
    }
#line 110
    mcb_read___0 -= n;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      tmp___1 = n;
#line 111
      n --;
#line 111
      if (! (tmp___1 > 0)) {
#line 111
        goto while_break;
      }
      {
#line 112
      tmp___0 = _IO_getc(infp);
      }
#line 112
      if (tmp___0 == -1) {
        {
#line 113
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 117
        exit(1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 121
    n = (int )(((ibytes + 127UL) / 128UL) * 128UL);
#line 122
    if (n > mcb_read___0) {
#line 123
      n = mcb_read___0;
    }
#line 125
    mcb_read___0 -= n;
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      tmp___3 = n;
#line 126
      n --;
#line 126
      if (! (tmp___3 > 0)) {
#line 126
        goto while_break___0;
      }
      {
#line 127
      tmp___2 = _IO_getc(infp);
      }
#line 127
      if (tmp___2 == -1) {
        {
#line 128
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 132
        exit(1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 136
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static struct methodinfo methods___0[7]  = {      {(char *)"NoComp", 0}, 
        {(char *)"RLE", 1}, 
        {(char *)"LZC", 2}, 
        {(char *)"Huffman", 3}, 
        {(char *)"LZAH", 5}, 
        {(char *)"FixHuf", 6}, 
        {(char *)"MW", 8}};
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_nodeptr  ;
#line 38
static int readsithdr(struct sitHdr *s ) ;
#line 39
static int sit_filehdr(struct fileHdr___0 *f , int skip ) ;
#line 40
static int sit_valid(struct fileHdr___0 f ) ;
#line 41
static int sit_checkm(int f ) ;
#line 42
static char *sit_methname(int n ) ;
#line 43
static void sit_folder(char *name ) ;
#line 44
static void sit_unstuff(struct fileHdr___0 filehdr ) ;
#line 45
static void sit_wrfile(unsigned long ibytes , unsigned long obytes , unsigned char type ) ;
#line 46
static void sit_skip(unsigned long ibytes ) ;
#line 47
static void sit_nocomp(unsigned long ibytes ) ;
#line 48
static void sit_rle(unsigned long ibytes ) ;
#line 49
static void sit_lzc(unsigned long ibytes ) ;
#line 50
static void sit_huffman(unsigned long obytes ) ;
#line 51
static void sit_lzah(unsigned long obytes ) ;
#line 52
static unsigned char sit_getbyte(void) ;
#line 53
static void sit_fixhuf(unsigned long ibytes ) ;
#line 54
static void sit_dosplit(int ptr___3 , int sum , int low , int upp ) ;
#line 55
static void sit_mw(unsigned long ibytes ) ;
#line 56
static void sit_mw_out(int ptr___3 ) ;
#line 57
static int sit_mw_in(int bits , unsigned long *ibytes ) ;
#line 59 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static short code6[258]  = 
#line 59
  {      (short)1024,      (short)512,      (short)256,      (short)256, 
        (short)256,      (short)256,      (short)128,      (short)128, 
        (short)128,      (short)128,      (short)128,      (short)128, 
        (short)128,      (short)128,      (short)128,      (short)128, 
        (short)128,      (short)128,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)64,      (short)64, 
        (short)64,      (short)64,      (short)32,      (short)32, 
        (short)32,      (short)32,      (short)32,      (short)32, 
        (short)32,      (short)32,      (short)32,      (short)32, 
        (short)32,      (short)32,      (short)32,      (short)32, 
        (short)32,      (short)32,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)16, 
        (short)16,      (short)16,      (short)16,      (short)8, 
        (short)8,      (short)16,      (short)16,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)1,      (short)1, 
        (short)1,      (short)1};
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static char sit_buffer[32768]  ;
#line 94 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static short sit_dict[16385]  ;
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static unsigned long sit_avail  ;
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_bits_avail  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
void sit(void) 
{ 
  struct sitHdr sithdr ;
  struct fileHdr___0 filehdr ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 104
  set_huffman(0);
#line 105
  core_compress((char *)((void *)0));
#line 106
  updcrc = & arc_updcrc;
#line 107
  crcinit = arc_crcinit;
#line 108
  tmp = readsithdr(& sithdr);
  }
#line 108
  if (tmp == 0) {
    {
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header\n");
#line 113
    exit(1);
    }
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < (int )sithdr.numFiles)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___0 = sit_filehdr(& filehdr, 0);
    }
#line 117
    if (tmp___0 == -1) {
      {
#line 118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
              i + 1);
#line 122
      exit(1);
      }
    }
    {
#line 124
    tmp___1 = sit_valid(filehdr);
    }
#line 124
    if (! tmp___1) {
#line 125
      goto __Cont;
    }
#line 127
    if ((int )filehdr.compRMethod == 32) {
      {
#line 128
      sit_folder(text);
      }
    } else {
      {
#line 130
      sit_unstuff(filehdr);
      }
    }
    __Cont: /* CIL Label */ 
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int readsithdr(struct sitHdr *s ) 
{ 
  char temp[22] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 140
  tmp = fread((void */* __restrict  */)(temp), (size_t )1, (size_t )22, (FILE */* __restrict  */)infp);
  }
#line 140
  if (tmp != 22UL) {
#line 141
    return (0);
  }
  {
#line 144
  tmp___0 = strncmp(temp + 0, "SIT!", 4);
  }
#line 144
  if (tmp___0 != 0) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a StuffIt file\n");
    }
#line 147
    return (0);
  } else {
    {
#line 144
    tmp___1 = strncmp(temp + 10, "rLau", 4);
    }
#line 144
    if (tmp___1 != 0) {
      {
#line 146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a StuffIt file\n");
      }
#line 147
      return (0);
    }
  }
  {
#line 150
  tmp___2 = get2(temp + 4);
#line 150
  s->numFiles = (unsigned short )tmp___2;
#line 151
  s->arcLength = get4(temp + 6);
  }
#line 153
  return (1);
}
}
#line 156 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_filehdr(struct fileHdr___0 *f , int skip ) 
{ 
  register int i ;
  unsigned long crc___0 ;
  int n ;
  char hdr[112] ;
  char ftype[5] ;
  char fauth[5] ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < 128)) {
#line 166
      goto while_break;
    }
#line 167
    info[i] = (char )'\000';
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  tmp = fread((void */* __restrict  */)(hdr), (size_t )1, (size_t )112, (FILE */* __restrict  */)infp);
  }
#line 169
  if (tmp != 112UL) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header\n");
    }
#line 171
    return (-1);
  }
  {
#line 173
  crc___0 = crcinit;
#line 174
  crc___0 = (*updcrc)(crc___0, hdr, 110);
#line 176
  tmp___0 = get2(hdr + 110);
#line 176
  f->hdrCRC = (unsigned short )tmp___0;
  }
#line 177
  if ((unsigned long )f->hdrCRC != crc___0) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header CRC mismatch: got 0x%04x, need 0x%04x\n",
            (int )f->hdrCRC & 65535, (int )crc___0);
    }
#line 180
    return (-1);
  }
#line 183
  n = (int )hdr[2] & 255;
#line 184
  if (n > 63) {
#line 185
    n = 63;
  }
  {
#line 187
  info[1] = (char )n;
#line 188
  copy((info + 1) + 1, (hdr + 2) + 1, n);
#line 189
  transname((hdr + 2) + 1, text, n);
#line 191
  f->compRMethod = (unsigned char )hdr[0];
#line 192
  f->compDMethod = (unsigned char )hdr[1];
#line 193
  f->rsrcLength = get4(hdr + 84);
#line 194
  f->dataLength = get4(hdr + 88);
#line 195
  f->compRLength = get4(hdr + 92);
#line 196
  f->compDLength = get4(hdr + 96);
#line 197
  tmp___1 = get2(hdr + 100);
#line 197
  f->rsrcCRC = (unsigned short )tmp___1;
#line 198
  tmp___2 = get2(hdr + 102);
#line 198
  f->dataCRC = (unsigned short )tmp___2;
#line 200
  write_it = ! skip;
  }
#line 201
  if (list) {
#line 201
    if (! skip) {
#line 202
      if ((int )f->compRMethod != 33) {
        {
#line 203
        do_indent(indent);
        }
      }
#line 205
      if ((int )f->compRMethod == 32) {
        {
#line 206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
                text);
        }
      } else
#line 207
      if ((int )f->compRMethod != 33) {
        {
#line 208
        transname(hdr + 66, ftype, 4);
#line 209
        transname(hdr + 70, fauth, 4);
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
                text, ftype, fauth, (long )f->dataLength, (long )f->rsrcLength);
        }
      }
#line 215
      if (info_only) {
#line 216
        write_it = 0;
      }
#line 218
      if ((int )f->compRMethod != 33) {
#line 219
        if (query) {
          {
#line 220
          write_it = do_query();
          }
        } else {
          {
#line 222
          fputc('\n', stderr);
          }
        }
      }
    }
  }
#line 227
  if (write_it) {
    {
#line 228
    define_name(text);
    }
#line 230
    if ((int )f->compRMethod != 32) {
      {
#line 231
      copy(info + 65, hdr + 66, 4);
#line 232
      copy(info + 69, hdr + 70, 4);
#line 233
      copy(info + 73, hdr + 74, 2);
#line 234
      copy(info + 83, hdr + 88, 4);
#line 235
      copy(info + 87, hdr + 84, 4);
#line 236
      copy(info + 91, hdr + 76, 4);
#line 237
      copy(info + 95, hdr + 80, 4);
      }
    }
  }
#line 240
  return (1);
}
}
#line 243 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_valid(struct fileHdr___0 f ) 
{ 
  int fr ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 246
  fr = (int )f.compRMethod;
#line 246
  fd = (int )f.compDMethod;
#line 248
  if (fr == 32) {
#line 249
    return (1);
  } else
#line 248
  if (fr == 33) {
#line 249
    return (1);
  }
#line 251
  if (fr & 16) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFile is password protected");
    }
  } else
#line 251
  if (fd & 16) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFile is password protected");
    }
  } else
#line 256
  if (fr >= 16) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnknown stuffit flags: %x %x",
            fr, fd);
    }
  } else
#line 256
  if (fd >= 16) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnknown stuffit flags: %x %x",
            fr, fd);
    }
  } else
#line 261
  if ((1 << fr) & 367) {
#line 261
    if ((1 << fd) & 367) {
      {
#line 262
      tmp = sit_checkm(fr);
      }
#line 262
      if (tmp) {
        {
#line 262
        tmp___0 = sit_checkm(fd);
        }
#line 262
        if (tmp___0) {
#line 263
          return (1);
        }
      }
      {
#line 265
      tmp___3 = sit_checkm(fr);
      }
#line 265
      if (tmp___3) {
        {
#line 269
        tmp___2 = sit_methname(fd);
#line 269
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tMethod \"%s\" not implemented",
                tmp___2);
        }
      } else {
        {
#line 266
        tmp___1 = sit_methname(fr);
#line 266
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tMethod \"%s\" not implemented",
                tmp___1);
        }
      }
    } else {
      {
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnknown compression methods: %x %x",
              fr, fd);
      }
    }
  } else {
    {
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnknown compression methods: %x %x",
            fr, fd);
    }
  }
  {
#line 281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", skipping file.\n");
#line 282
  sit_skip(f.compRLength);
#line 283
  sit_skip(f.compDLength);
  }
#line 284
  return (0);
}
}
#line 287 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_checkm(int f ) 
{ 


  {
  {
#line 291
  if (f == 0) {
#line 291
    goto case_0;
  }
#line 293
  if (f == 1) {
#line 293
    goto case_1;
  }
#line 295
  if (f == 2) {
#line 295
    goto case_2;
  }
#line 297
  if (f == 3) {
#line 297
    goto case_3;
  }
#line 299
  if (f == 5) {
#line 299
    goto case_5;
  }
#line 301
  if (f == 6) {
#line 301
    goto case_6;
  }
#line 303
  if (f == 8) {
#line 303
    goto case_8;
  }
#line 305
  goto switch_default;
  case_0: /* CIL Label */ 
#line 292
  return (1);
  case_1: /* CIL Label */ 
#line 294
  return (1);
  case_2: /* CIL Label */ 
#line 296
  return (1);
  case_3: /* CIL Label */ 
#line 298
  return (1);
  case_5: /* CIL Label */ 
#line 300
  return (1);
  case_6: /* CIL Label */ 
#line 302
  return (1);
  case_8: /* CIL Label */ 
#line 304
  return (1);
  switch_default: /* CIL Label */ 
#line 306
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static char *sit_methname(int n ) 
{ 
  int i ;
  int nmeths ;

  {
#line 315
  nmeths = (int )(sizeof(methods___0) / sizeof(struct methodinfo ));
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i < nmeths)) {
#line 316
      goto while_break;
    }
#line 317
    if (methods___0[i].number == n) {
#line 318
      return (methods___0[i].name);
    }
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return ((char *)((void *)0));
}
}
#line 324 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_folder(char *name ) 
{ 
  int i ;
  int recurse ;
  char loc_name[64] ;
  struct fileHdr___0 filehdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 331
  i = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < 64)) {
#line 331
      goto while_break;
    }
#line 332
    loc_name[i] = *(name + i);
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if (write_it) {
#line 334
    goto _L;
  } else
#line 334
  if (info_only) {
    _L: /* CIL Label */ 
#line 335
    if (write_it) {
      {
#line 336
      do_mkdir(text, info);
      }
    }
#line 338
    indent ++;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 340
      tmp = sit_filehdr(& filehdr, 0);
      }
#line 340
      if (tmp == -1) {
        {
#line 341
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
                i + 1);
#line 345
        exit(1);
        }
      }
      {
#line 347
      tmp___0 = sit_valid(filehdr);
      }
#line 347
      if (! tmp___0) {
#line 348
        goto while_continue___0;
      }
#line 350
      if ((int )filehdr.compRMethod == 32) {
        {
#line 351
        sit_folder(text);
        }
      } else
#line 352
      if ((int )filehdr.compRMethod == 33) {
#line 353
        goto while_break___0;
      } else {
        {
#line 355
        sit_unstuff(filehdr);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 358
    if (write_it) {
      {
#line 359
      enddir();
      }
    }
#line 361
    indent --;
#line 362
    if (list) {
      {
#line 363
      do_indent(indent);
#line 364
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
              loc_name);
      }
    }
  } else {
#line 367
    recurse = 0;
    {
#line 368
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 369
      tmp___1 = sit_filehdr(& filehdr, 1);
      }
#line 369
      if (tmp___1 == -1) {
        {
#line 370
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
                i + 1);
#line 374
        exit(1);
        }
      }
#line 376
      if ((int )filehdr.compRMethod == 32) {
#line 377
        recurse ++;
      } else
#line 378
      if ((int )filehdr.compRMethod == 33) {
#line 379
        recurse --;
#line 380
        if (recurse < 0) {
#line 381
          goto while_break___1;
        }
      } else {
        {
#line 384
        sit_skip(filehdr.compRLength);
#line 385
        sit_skip(filehdr.compDLength);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 389
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_unstuff(struct fileHdr___0 filehdr ) 
{ 
  unsigned long crc___0 ;

  {
#line 396
  if (write_it) {
    {
#line 397
    start_info(info, filehdr.rsrcLength, filehdr.dataLength);
    }
  }
#line 399
  if (verbose) {
    {
#line 400
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tRsrc: ");
    }
  }
#line 402
  if (write_it) {
    {
#line 403
    start_rsrc();
    }
  }
  {
#line 405
  sit_wrfile(filehdr.compRLength, filehdr.rsrcLength, (int )filehdr.compRMethod);
  }
#line 406
  if (write_it) {
    {
#line 407
    crc___0 = (*updcrc)(crcinit, out_buffer, filehdr.rsrcLength);
    }
#line 408
    if ((unsigned long )filehdr.rsrcCRC != crc___0) {
      {
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on resource fork: need 0x%04x, got 0x%04x\n",
              (int )filehdr.rsrcCRC, (int )crc___0);
#line 415
      exit(1);
      }
    }
  }
#line 418
  if (verbose) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Data: ");
    }
  }
#line 421
  if (write_it) {
    {
#line 422
    start_data();
    }
  }
  {
#line 424
  sit_wrfile(filehdr.compDLength, filehdr.dataLength, (int )filehdr.compDMethod);
  }
#line 425
  if (write_it) {
    {
#line 426
    crc___0 = (*updcrc)(crcinit, out_buffer, filehdr.dataLength);
    }
#line 427
    if ((unsigned long )filehdr.dataCRC != crc___0) {
      {
#line 428
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on data fork: need 0x%04x, got 0x%04x\n",
              (int )filehdr.dataCRC, (int )crc___0);
#line 434
      exit(1);
      }
    }
    {
#line 436
    end_file();
    }
  }
#line 438
  if (verbose) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 441
  return;
}
}
#line 443 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_wrfile(unsigned long ibytes , unsigned long obytes , unsigned char type ) 
{ 


  {
#line 447
  if (ibytes == 0UL) {
#line 448
    if (verbose) {
      {
#line 449
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    }
#line 451
    return;
  }
  {
#line 454
  if ((int )type == 0) {
#line 454
    goto case_0;
  }
#line 464
  if ((int )type == 1) {
#line 464
    goto case_1;
  }
#line 475
  if ((int )type == 2) {
#line 475
    goto case_2;
  }
#line 486
  if ((int )type == 3) {
#line 486
    goto case_3;
  }
#line 497
  if ((int )type == 5) {
#line 497
    goto case_5;
  }
#line 508
  if ((int )type == 6) {
#line 508
    goto case_6;
  }
#line 519
  if ((int )type == 8) {
#line 519
    goto case_8;
  }
#line 530
  goto switch_default;
  case_0: /* CIL Label */ 
#line 455
  if (verbose) {
    {
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
    }
  }
#line 458
  if (write_it) {
    {
#line 459
    sit_nocomp(ibytes);
    }
  } else {
    {
#line 461
    sit_skip(ibytes);
    }
  }
#line 463
  goto switch_break;
  case_1: /* CIL Label */ 
#line 465
  if (verbose) {
    {
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 469
  if (write_it) {
    {
#line 470
    sit_rle(ibytes);
    }
  } else {
    {
#line 472
    sit_skip(ibytes);
    }
  }
#line 474
  goto switch_break;
  case_2: /* CIL Label */ 
#line 476
  if (verbose) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZC compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 480
  if (write_it) {
    {
#line 481
    sit_lzc(ibytes);
    }
  } else {
    {
#line 483
    sit_skip(ibytes);
    }
  }
#line 485
  goto switch_break;
  case_3: /* CIL Label */ 
#line 487
  if (verbose) {
    {
#line 488
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Huffman compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 491
  if (write_it) {
    {
#line 492
    sit_huffman(obytes);
    }
  } else {
    {
#line 494
    sit_skip(ibytes);
    }
  }
#line 496
  goto switch_break;
  case_5: /* CIL Label */ 
#line 498
  if (verbose) {
    {
#line 499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZAH compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 502
  if (write_it) {
    {
#line 503
    sit_lzah(obytes);
    }
  } else {
    {
#line 505
    sit_skip(ibytes);
    }
  }
#line 507
  goto switch_break;
  case_6: /* CIL Label */ 
#line 509
  if (verbose) {
    {
#line 510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FixHuf compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 513
  if (write_it) {
    {
#line 514
    sit_fixhuf(ibytes);
    }
  } else {
    {
#line 516
    sit_skip(ibytes);
    }
  }
#line 518
  goto switch_break;
  case_8: /* CIL Label */ 
#line 520
  if (verbose) {
    {
#line 521
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MW compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 524
  if (write_it) {
    {
#line 525
    sit_mw(ibytes);
    }
  } else {
    {
#line 527
    sit_skip(ibytes);
    }
  }
#line 529
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 531
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown compression method %2x\n",
          (int )type);
#line 535
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_skip(unsigned long ibytes ) 
{ 
  int tmp ;

  {
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (ibytes != 0UL)) {
#line 543
      goto while_break;
    }
    {
#line 544
    tmp = _IO_getc(infp);
    }
#line 544
    if (tmp == -1) {
      {
#line 545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 549
      exit(1);
      }
    }
#line 551
    ibytes --;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return;
}
}
#line 558 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_nocomp(unsigned long ibytes ) 
{ 
  int n ;
  size_t tmp ;

  {
  {
#line 563
  tmp = fread((void */* __restrict  */)out_buffer, (size_t )1, (size_t )((int )ibytes),
              (FILE */* __restrict  */)infp);
#line 563
  n = (int )tmp;
  }
#line 564
  if ((unsigned long )n != ibytes) {
    {
#line 565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 569
    exit(1);
    }
  }
#line 571
  return;
}
}
#line 576 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_rle(unsigned long ibytes ) 
{ 
  int ch ;
  int lastch ;
  int n ;
  int i ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (! (ibytes != 0UL)) {
#line 581
      goto while_break;
    }
    {
#line 582
    tmp = getb(infp);
#line 582
    ch = (int )tmp & 255;
#line 583
    ibytes --;
    }
#line 584
    if (ch == 144) {
      {
#line 585
      tmp___0 = getb(infp);
#line 585
      n = ((int )tmp___0 & 255) - 1;
#line 586
      ibytes --;
      }
#line 587
      if (n < 0) {
#line 588
        tmp___1 = out_ptr;
#line 588
        out_ptr ++;
#line 588
        *tmp___1 = (char)-112;
#line 589
        lastch = 144;
#line 590
        n = 1;
      } else {
#line 592
        i = 0;
        {
#line 592
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 592
          if (! (i < n)) {
#line 592
            goto while_break___0;
          }
#line 593
          tmp___2 = out_ptr;
#line 593
          out_ptr ++;
#line 593
          *tmp___2 = (char )lastch;
#line 592
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 597
      tmp___3 = out_ptr;
#line 597
      out_ptr ++;
#line 597
      *tmp___3 = (char )ch;
#line 598
      lastch = ch;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  return;
}
}
#line 606 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_lzc(unsigned long ibytes ) 
{ 


  {
  {
#line 609
  de_compress(ibytes, 14);
  }
#line 610
  return;
}
}
#line 615 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_huffman(unsigned long obytes ) 
{ 


  {
  {
#line 618
  read_tree();
#line 619
  de_huffman(obytes);
  }
#line 620
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_lzah(unsigned long obytes ) 
{ 


  {
  {
#line 628
  lzah_getbyte = & sit_getbyte;
#line 629
  de_lzah(obytes);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static unsigned char sit_getbyte(void) 
{ 
  unsigned char tmp ;

  {
  {
#line 634
  tmp = getb(infp);
  }
#line 634
  return (tmp);
}
}
#line 640 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_fixhuf(unsigned long ibytes ) 
{ 
  int i ;
  int sum ;
  int codes___0 ;
  int sym ;
  int num ;
  char byte_int[4] ;
  char byte_short[2] ;
  long size___0 ;
  int sign ;
  char *tmp_ptr ;
  char *ptr___3 ;
  char *end_ptr ;
  size_t tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned char tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 649
  sum = 0;
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < 258)) {
#line 650
      goto while_break;
    }
#line 651
    sum += (int )code6[i];
#line 652
    nodelist[i + 1].flag = 1;
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 654
  sit_nodeptr = 258;
#line 655
  sit_dosplit(0, sum, 1, 258);
  }
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 656
    if (! (ibytes > 0UL)) {
#line 656
      goto while_break___0;
    }
    {
#line 657
    tmp = fread((void */* __restrict  */)(byte_int), (size_t )1, (size_t )4, (FILE */* __restrict  */)infp);
    }
#line 657
    if (tmp != 4UL) {
      {
#line 658
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 662
      exit(1);
      }
    }
    {
#line 664
    ibytes -= 4UL;
#line 665
    tmp___0 = get4(byte_int);
#line 665
    size___0 = (long )tmp___0;
#line 666
    sign = 0;
    }
#line 667
    if (size___0 < 0L) {
#line 668
      size___0 = - size___0;
#line 669
      sign = 1;
    }
#line 671
    size___0 -= 4L;
#line 672
    if (sign) {
      {
#line 673
      ibytes -= (unsigned long )size___0;
#line 674
      tmp___1 = fread((void */* __restrict  */)(sit_buffer), (size_t )1, (size_t )((int )size___0),
                      (FILE */* __restrict  */)infp);
      }
#line 674
      if (tmp___1 != (size_t )size___0) {
        {
#line 675
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 679
        exit(1);
        }
      }
    } else {
      {
#line 682
      ibytes -= (unsigned long )size___0;
#line 683
      tmp___2 = fread((void */* __restrict  */)(byte_int), (size_t )1, (size_t )4,
                      (FILE */* __restrict  */)infp);
      }
#line 683
      if (tmp___2 != 4UL) {
        {
#line 684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 688
        exit(1);
        }
      }
      {
#line 690
      size___0 -= 4L;
#line 691
      tmp___3 = fread((void */* __restrict  */)(byte_short), (size_t )1, (size_t )2,
                      (FILE */* __restrict  */)infp);
      }
#line 691
      if (tmp___3 != 2UL) {
        {
#line 692
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 696
        exit(1);
        }
      }
      {
#line 698
      size___0 -= 2L;
#line 699
      tmp___4 = get2(byte_short);
#line 699
      codes___0 = (int )tmp___4;
#line 700
      i = 1;
      }
      {
#line 700
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 700
        if (! (i <= codes___0)) {
#line 700
          goto while_break___1;
        }
        {
#line 701
        tmp___5 = getb(infp);
#line 701
        nodelist[i].byte = (int )tmp___5;
#line 700
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 703
      size___0 -= (long )codes___0;
#line 704
      clrhuff();
#line 705
      nodelist[257].byte = 256;
#line 706
      nodelist[258].byte = 256;
#line 707
      tmp_ptr = out_ptr;
#line 708
      out_ptr = & sit_buffer[0];
#line 709
      bytesread = 0;
#line 710
      de_huffman_end(256);
      }
      {
#line 711
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 711
        if (! ((long )bytesread < size___0)) {
#line 711
          goto while_break___2;
        }
        {
#line 712
        getb(infp);
#line 713
        bytesread ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 715
      tmp___6 = get4(byte_int);
#line 715
      size___0 = (long )tmp___6;
#line 716
      out_ptr = tmp_ptr;
      }
    }
#line 718
    ptr___3 = sit_buffer;
#line 719
    end_ptr = ptr___3 + size___0;
    {
#line 720
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 720
      if (! ((unsigned long )ptr___3 < (unsigned long )end_ptr)) {
#line 720
        goto while_break___3;
      }
#line 721
      tmp___7 = ptr___3;
#line 721
      ptr___3 ++;
#line 721
      num = (int )*tmp___7 & 255;
#line 722
      if (num < 128) {
        {
#line 723
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 723
          tmp___10 = num;
#line 723
          num --;
#line 723
          if (! (tmp___10 >= 0)) {
#line 723
            goto while_break___4;
          }
#line 724
          tmp___8 = out_ptr;
#line 724
          out_ptr ++;
#line 724
          tmp___9 = ptr___3;
#line 724
          ptr___3 ++;
#line 724
          *tmp___8 = *tmp___9;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 726
      if (num != 128) {
#line 727
        tmp___11 = ptr___3;
#line 727
        ptr___3 ++;
#line 727
        sym = (int )*tmp___11;
        {
#line 728
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 728
          tmp___13 = num;
#line 728
          num ++;
#line 728
          if (! (tmp___13 <= 256)) {
#line 728
            goto while_break___5;
          }
#line 729
          tmp___12 = out_ptr;
#line 729
          out_ptr ++;
#line 729
          *tmp___12 = (char )sym;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 736 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_dosplit(int ptr___3 , int sum , int low , int upp ) 
{ 
  int i ;
  int locsum ;
  int tmp ;

  {
#line 741
  sum /= 2;
#line 742
  locsum = 0;
#line 743
  i = low;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! (locsum < sum)) {
#line 744
      goto while_break;
    }
#line 745
    tmp = i;
#line 745
    i ++;
#line 745
    locsum += (int )code6[tmp - 1];
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if (low == i - 1) {
#line 748
    nodelist[ptr___3].zero = nodelist + low;
  } else {
    {
#line 750
    sit_nodeptr ++;
#line 750
    nodelist[ptr___3].zero = nodelist + sit_nodeptr;
#line 751
    sit_dosplit(sit_nodeptr, sum, low, i - 1);
    }
  }
#line 753
  if (upp == i) {
#line 754
    nodelist[ptr___3].one = nodelist + upp;
  } else {
    {
#line 756
    sit_nodeptr ++;
#line 756
    nodelist[ptr___3].one = nodelist + sit_nodeptr;
#line 757
    sit_dosplit(sit_nodeptr, sum, i, upp);
    }
  }
#line 759
  return;
}
}
#line 764 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_mw(unsigned long ibytes ) 
{ 
  int ptr___3 ;
  int max ;
  int max1 ;
  int bits ;
  char *out_buf ;
  int tmp ;

  {
#line 771
  out_buf = out_buffer;
#line 772
  sit_bits_avail = 0;
#line 773
  sit_avail = 0UL;
  start_over: 
  {
#line 775
  max = 256;
#line 776
  max1 = max + max;
#line 777
  bits = 9;
#line 778
  ptr___3 = sit_mw_in(bits, & ibytes);
  }
#line 779
  if (ptr___3 == max) {
#line 780
    goto start_over;
  }
#line 782
  if (ptr___3 > max) {
#line 783
    out_buffer = out_buf;
#line 784
    return;
  } else
#line 782
  if (ptr___3 < 0) {
#line 783
    out_buffer = out_buf;
#line 784
    return;
  }
  {
#line 786
  sit_dict[255] = (short )ptr___3;
#line 787
  sit_mw_out(ptr___3);
  }
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 789
    ptr___3 = sit_mw_in(bits, & ibytes);
    }
#line 790
    if (ptr___3 == max) {
#line 791
      goto start_over;
    }
#line 793
    if (ptr___3 > max) {
#line 794
      out_buffer = out_buf;
#line 795
      return;
    } else
#line 793
    if (ptr___3 < 0) {
#line 794
      out_buffer = out_buf;
#line 795
      return;
    }
#line 797
    tmp = max;
#line 797
    max ++;
#line 797
    sit_dict[tmp] = (short )ptr___3;
#line 798
    if (max == max1) {
#line 799
      max1 <<= 1;
#line 800
      bits ++;
    }
    {
#line 802
    sit_mw_out(ptr___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 806 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static void sit_mw_out(int ptr___3 ) 
{ 
  int stack_ptr ;
  int stack[16384] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 812
  stack_ptr = 1;
#line 813
  stack[0] = ptr___3;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! stack_ptr) {
#line 814
      goto while_break;
    }
#line 815
    stack_ptr --;
#line 815
    ptr___3 = stack[stack_ptr];
    {
#line 816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 816
      if (! (ptr___3 >= 256)) {
#line 816
        goto while_break___0;
      }
#line 817
      tmp = stack_ptr;
#line 817
      stack_ptr ++;
#line 817
      stack[tmp] = (int )sit_dict[ptr___3];
#line 818
      ptr___3 = (int )sit_dict[ptr___3 - 1];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 820
    tmp___0 = out_buffer;
#line 820
    out_buffer ++;
#line 820
    *tmp___0 = (char )ptr___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 822
  return;
}
}
#line 824 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/sit.c"
static int sit_mw_in(int bits , unsigned long *ibytes ) 
{ 
  int res ;
  int res1 ;
  unsigned char tmp ;

  {
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (! (bits > sit_bits_avail)) {
#line 830
      goto while_break;
    }
#line 831
    if (*ibytes == 0UL) {
#line 832
      return (-1);
    }
    {
#line 834
    (*ibytes) --;
#line 835
    tmp = getb(infp);
#line 835
    sit_avail += (unsigned long )(((int )tmp & 255) << sit_bits_avail);
#line 836
    sit_bits_avail += 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  res1 = (int )(sit_avail >> bits);
#line 839
  res = (int )(sit_avail ^ (unsigned long )(res1 << bits));
#line 840
  sit_avail = (unsigned long )res1;
#line 841
  sit_bits_avail -= bits;
#line 842
  return (res);
}
}
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/globals.h"
int no_dd  ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
static unsigned long crctab___14[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/zip.c"
  {      0UL,      151466134UL,      302932268UL,      453595578UL, 
        4285383705UL,      4134204559UL,      3982730549UL,      3831797155UL, 
        4275800114UL,      4158437540UL,      3973441822UL,      3855800712UL, 
        28724267UL,      145849533UL,      330837255UL,      448732561UL, 
        4256632932UL,      4105183474UL,      4021907784UL,      3871228382UL, 
        47895677UL,      199091435UL,      282375505UL,      433292743UL, 
        57448534UL,      174827712UL,      291699066UL,      409324012UL, 
        4227947599UL,      4110839001UL,      3993976163UL,      3876064757UL, 
        4218298568UL,      4066971742UL,      3915399652UL,      3764875634UL, 
        67364049UL,      218420295UL,      369985021UL,      520795499UL, 
        95791354UL,      213031020UL,      398182870UL,      515701056UL, 
        4208487651UL,      4091501685UL,      3906342351UL,      3788586329UL, 
        114897068UL,      266207290UL,      349655424UL,      500195606UL, 
        4189385909UL,      4038312995UL,      3954873753UL,      3804079375UL, 
        4160927902UL,      4043671560UL,      3926710706UL,      3809208612UL, 
        124746887UL,      241716241UL,      358686123UL,      476458301UL, 
        4141629840UL,      4292571398UL,      3838976188UL,      3990163498UL, 
        162629001UL,      11973919UL,      465560741UL,      314102835UL, 
        134728098UL,      16841012UL,      436840590UL,      319723544UL, 
        4150922683UL,      4268571949UL,      3848563863UL,      3965934593UL, 
        191582708UL,      40657250UL,      426062040UL,      274858062UL, 
        4094072301UL,      4244743547UL,      3859346625UL,      4010787927UL, 
        4122008006UL,      4239911248UL,      3888036074UL,      4005136508UL, 
        182263263UL,      64630089UL,      416513267UL,      299125861UL, 
        229794136UL,      78991822UL,      532414580UL,      381366498UL, 
        4074743105UL,      4225275351UL,      3771843693UL,      3923178747UL, 
        4083804522UL,      4201568764UL,      3781658694UL,      3898652880UL, 
        201600371UL,      84090341UL,      503991391UL,      386759881UL, 
        4026888508UL,      4177674666UL,      3792375824UL,      3943440518UL, 
        258520357UL,      107972019UL,      493278217UL,      341959839UL, 
        249493774UL,      131713432UL,      483432482UL,      366454964UL, 
        4055055639UL,      4172549505UL,      3820837947UL,      3938086061UL, 
        3988292384UL,      3837768630UL,      4290175500UL,      4138848922UL, 
        315967289UL,      466778031UL,      14362133UL,      165418627UL, 
        325258002UL,      442776452UL,      23947838UL,      141187752UL, 
        3960393483UL,      3842637725UL,      4261457447UL,      4144471729UL, 
        269456196UL,      419996626UL,      33682024UL,      184992510UL, 
        4016199517UL,      3865405387UL,      4251727473UL,      4100654823UL, 
        4006878070UL,      3889376224UL,      4242176602UL,      4124920524UL, 
        297394031UL,      415166457UL,      62373443UL,      179343061UL, 
        383165416UL,      533828478UL,      81314500UL,      232780370UL, 
        3921373169UL,      3770439527UL,      4222944989UL,      4071765579UL, 
        3893177306UL,      3775535948UL,      4194519798UL,      4077156960UL, 
        392228803UL,      510123861UL,      91131631UL,      208256633UL, 
        3949048716UL,      3798369050UL,      4184855200UL,      4033405494UL, 
        336361365UL,      487278339UL,      100800185UL,      251995695UL, 
        364526526UL,      482151208UL,      129260178UL,      246639108UL, 
        3940024231UL,      3822112561UL,      4175011467UL,      4057902621UL, 
        459588272UL,      308539942UL,      157983644UL,      7181066UL, 
        3825796777UL,      3977131583UL,      4127680389UL,      4278212371UL, 
        3854518914UL,      3971512852UL,      4155583406UL,      4273347384UL, 
        450006683UL,      332774925UL,      148697015UL,      31186721UL, 
        3872641748UL,      4023706178UL,      4108170232UL,      4258956142UL, 
        431888077UL,      280569435UL,      196114401UL,      45565815UL, 
        403200742UL,      286222960UL,      168180682UL,      50400092UL, 
        3882196735UL,      3999444585UL,      4117495763UL,      4234989381UL, 
        3758809720UL,      3909997294UL,      4060382036UL,      4211323842UL, 
        526853729UL,      375396087UL,      225003341UL,      74348507UL, 
        517040714UL,      399923932UL,      215944038UL,      98057200UL, 
        3787238995UL,      3904609989UL,      4088582015UL,      4206231529UL, 
        498987548UL,      347783818UL,      263426864UL,      112501670UL, 
        3805296133UL,      3956737683UL,      4041103145UL,      4191774655UL, 
        3815143982UL,      3932244664UL,      4050131714UL,      4168035220UL, 
        470531639UL,      353144481UL,      235265819UL,      117632909UL};
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macunpack.c"
void cpt(void) ;
#line 26
static void usage___3(void) ;
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macunpack.c"
static char options___8[128]  ;
#line 196 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macunpack.c"
static void usage___3(void) 
{ 


  {
  {
#line 198
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: macunpack [-%s] [filename]\n",
          options___8);
#line 199
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"macunpack -H\" for help.\n");
  }
#line 200
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static char *zma_archive  ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static char *zma_current  ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static char *zma_filestart  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static unsigned long zma_length  ;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static long zma_archlength  ;
#line 23
static int zma_filehdr(struct fileHdr___1 *f , int skip ) ;
#line 24
static void zma_folder(struct fileHdr___1 fhdr ) ;
#line 25
static void zma_mooz(struct fileHdr___1 filehdr ) ;
#line 26
static void zma_wrfile(unsigned long ibytes , unsigned long obytes , char type ) ;
#line 27
static void zma_nocomp(unsigned long ibytes ) ;
#line 28
static void zma_lzh(unsigned long ibytes ) ;
#line 30 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
void zma(char *start , unsigned long length___0 ) 
{ 
  struct fileHdr___1 filehdr ;
  int i ;
  int toread___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 37
  if (length___0 != 0UL) {
#line 38
    if ((unsigned long )zma_archlength < length___0) {
#line 39
      if (zma_archlength == 0L) {
        {
#line 40
        zma_archive = malloc((unsigned int )length___0);
        }
      } else {
        {
#line 42
        zma_archive = realloc(zma_archive, (unsigned int )length___0);
        }
      }
#line 44
      zma_archlength = (long )length___0;
#line 45
      if ((unsigned long )zma_archive == (unsigned long )((void *)0)) {
        {
#line 46
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 47
        exit(1);
        }
      }
    }
    {
#line 50
    tmp = fread((void */* __restrict  */)zma_archive, (size_t )1, (size_t )((int )length___0),
                (FILE */* __restrict  */)infp);
    }
#line 50
    if (tmp != length___0) {
      {
#line 51
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read archive.\n");
#line 55
      exit(1);
      }
    }
    {
#line 57
    zma_length = get4((zma_archive + 3) + 1);
    }
#line 58
    if (zma_length != length___0) {
      {
#line 59
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Archive length mismatch.\n");
#line 63
      exit(1);
      }
    }
  } else {
    {
#line 66
    zma_length = get4((start + 3) + 1);
    }
#line 67
    if ((unsigned long )zma_archlength < zma_length) {
#line 68
      if (zma_archlength == 0L) {
        {
#line 69
        zma_archive = malloc((unsigned int )zma_length);
        }
      } else {
        {
#line 71
        zma_archive = realloc(zma_archive, (unsigned int )zma_length);
        }
      }
#line 73
      zma_archlength = (long )zma_length;
#line 74
      if ((unsigned long )zma_archive == (unsigned long )((void *)0)) {
        {
#line 75
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 76
        exit(1);
        }
      }
    }
#line 79
    if ((unsigned long )zma_archive == (unsigned long )((void *)0)) {
      {
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 81
      exit(1);
      }
    }
#line 83
    i = 0;
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 83
      if (! (i <= 7)) {
#line 83
        goto while_break;
      }
#line 84
      *(zma_archive + i) = *(start + i);
#line 83
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 86
    toread___0 = (int )((zma_length - 7UL) - 1UL);
#line 87
    tmp___0 = fread((void */* __restrict  */)((zma_archive + 7) + 1), (size_t )1,
                    (size_t )toread___0, (FILE */* __restrict  */)infp);
    }
#line 87
    if (tmp___0 != (size_t )toread___0) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read archive.\n");
#line 92
      exit(1);
      }
    }
  }
#line 96
  if ((int )*(zma_archive + 0) != 0) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a \"Zoom\" archive after all, aborting\n");
#line 98
    exit(1);
    }
  }
  {
#line 100
  tmp___1 = strncmp(zma_archive + 1, "\005\237\032", 3);
  }
#line 100
  if (tmp___1) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a \"Zoom\" archive after all, aborting\n");
#line 102
    exit(1);
    }
  }
#line 104
  zma_current = zma_archive + 8;
#line 105
  updcrc = & arc_updcrc;
#line 106
  crcinit = arc_crcinit;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! ((unsigned long )zma_current != (unsigned long )zma_archive)) {
#line 107
      goto while_break___0;
    }
    {
#line 108
    tmp___2 = zma_filehdr(& filehdr, 0);
    }
#line 108
    if (tmp___2 == -1) {
      {
#line 109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t find file header./n");
#line 113
      exit(1);
      }
    }
#line 115
    zma_filestart = zma_current + (int )filehdr.hlen;
#line 116
    if ((int )filehdr.what == 3) {
      {
#line 117
      zma_folder(filehdr);
      }
    } else {
      {
#line 119
      zma_mooz(filehdr);
      }
    }
#line 121
    zma_current = zma_archive + filehdr.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static int zma_filehdr(struct fileHdr___1 *f , int skip ) 
{ 
  register int i ;
  int n ;
  char ftype[5] ;
  char fauth[5] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 133
  if ((unsigned long )((zma_current - zma_archive) + 78L) > zma_length) {
#line 134
    return (-1);
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < 128)) {
#line 136
      goto while_break;
    }
#line 137
    info[i] = (char )'\000';
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  n = (int )*(zma_current + 46) & 255;
#line 141
  if (n > 63) {
#line 142
    n = 63;
  }
  {
#line 144
  info[1] = (char )n;
#line 145
  copy((info + 1) + 1, (zma_current + 46) + 1, n);
#line 146
  transname((zma_current + 46) + 1, text, n);
#line 148
  f->what = *(zma_current + 0);
#line 149
  f->rsrcLength = get4(zma_current + 16);
#line 150
  f->dataLength = get4(zma_current + 20);
#line 151
  f->compRLength = get4(zma_current + 8);
#line 152
  f->compDLength = get4(zma_current + 12);
#line 153
  tmp = get2(zma_current + 44);
#line 153
  f->rsrcCRC = (unsigned short )tmp;
#line 154
  tmp___0 = get2(zma_current + 42);
#line 154
  f->dataCRC = (unsigned short )tmp___0;
#line 155
  f->hlen = (unsigned char )*(zma_current + 1);
#line 156
  f->next = get4(zma_current + 4);
  }
#line 157
  if ((int )f->what == 3) {
    {
#line 158
    f->conts = get4(zma_current + 28);
    }
  }
#line 161
  f->rsrcLength -= f->dataLength;
#line 162
  f->compRLength -= f->compDLength;
#line 164
  write_it = ! skip;
#line 165
  if ((int )f->what & 128) {
#line 166
    write_it = 0;
#line 167
    f->what = (char )(- ((int )f->what));
#line 168
    f->deleted = (char)1;
#line 169
    return (0);
  }
#line 171
  f->deleted = (char)0;
#line 172
  if (list) {
#line 172
    if (! skip) {
      {
#line 173
      do_indent(indent);
      }
#line 174
      if ((int )f->what == 3) {
        {
#line 175
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
                text);
        }
      } else {
        {
#line 177
        transname(zma_current + 24, ftype, 4);
#line 178
        transname(zma_current + 28, fauth, 4);
#line 179
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
                text, ftype, fauth, (long )f->dataLength, (long )f->rsrcLength);
        }
      }
      {
#line 185
      if ((int )f->what == 4) {
#line 185
        goto case_4;
      }
#line 193
      if ((int )f->what == 2) {
#line 193
        goto case_2;
      }
#line 193
      if ((int )f->what == 1) {
#line 193
        goto case_2;
      }
#line 193
      if ((int )f->what == 3) {
#line 193
        goto case_2;
      }
#line 195
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 186
      fputc('\n', stderr);
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFile uses custom processing, cannot handle.\n");
#line 189
      write_it = 0;
      }
#line 190
      return (0);
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 194
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 196
      fputc('\n', stderr);
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tEh, do not understand this (%d); skipped.\n",
              (int )f->what);
#line 199
      write_it = 0;
      }
#line 200
      return (0);
      switch_break: /* CIL Label */ ;
      }
#line 203
      if (info_only) {
#line 204
        write_it = 0;
      }
#line 206
      if (query) {
        {
#line 207
        write_it = do_query();
        }
      } else {
        {
#line 209
        fputc('\n', stderr);
        }
      }
    }
  }
#line 214
  if (write_it) {
    {
#line 215
    define_name(text);
    }
#line 217
    if ((int )f->what != 3) {
      {
#line 218
      copy(info + 65, zma_current + 24, 4);
#line 219
      copy(info + 69, zma_current + 28, 4);
#line 220
      copy(info + 73, zma_current + 40, 2);
#line 221
      copy(info + 83, zma_current + 20, 4);
#line 222
      put4(zma_current + 16, f->rsrcLength);
#line 223
      copy(info + 87, zma_current + 16, 4);
#line 224
      copy(info + 91, zma_current + 32, 4);
#line 225
      copy(info + 95, zma_current + 32, 4);
      }
    }
  }
#line 228
  return (1);
}
}
#line 231 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static void zma_folder(struct fileHdr___1 fhdr ) 
{ 
  int i ;
  char loc_name[64] ;
  struct fileHdr___1 filehdr ;
  int tmp ;

  {
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < 64)) {
#line 238
      goto while_break;
    }
#line 239
    loc_name[i] = text[i];
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  zma_current = zma_archive + fhdr.conts;
#line 242
  if (write_it) {
#line 242
    goto _L;
  } else
#line 242
  if (info_only) {
    _L: /* CIL Label */ 
#line 243
    if (write_it) {
      {
#line 244
      do_mkdir(text, info);
      }
    }
#line 246
    indent ++;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! ((unsigned long )zma_current != (unsigned long )zma_archive)) {
#line 247
        goto while_break___0;
      }
      {
#line 248
      tmp = zma_filehdr(& filehdr, 0);
      }
#line 248
      if (tmp == -1) {
        {
#line 249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t find file header.\n");
#line 253
        exit(1);
        }
      }
#line 255
      zma_filestart = zma_current + (int )filehdr.hlen;
#line 256
      if ((int )filehdr.what == 3) {
        {
#line 257
        zma_folder(filehdr);
        }
      } else {
        {
#line 259
        zma_mooz(filehdr);
        }
      }
#line 261
      zma_current = zma_archive + filehdr.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    if (write_it) {
      {
#line 264
      enddir();
      }
    }
#line 266
    indent --;
#line 267
    if (list) {
      {
#line 268
      do_indent(indent);
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
              loc_name);
      }
    }
  }
#line 272
  return;
}
}
#line 274 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static void zma_mooz(struct fileHdr___1 filehdr ) 
{ 
  unsigned long crc___0 ;

  {
#line 279
  if (write_it) {
    {
#line 280
    start_info(info, filehdr.rsrcLength, filehdr.dataLength);
    }
  }
#line 282
  if (verbose) {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tData: ");
    }
  }
#line 285
  if (write_it) {
    {
#line 286
    start_data();
    }
  }
  {
#line 288
  zma_wrfile(filehdr.compDLength, filehdr.dataLength, (int )filehdr.what);
  }
#line 289
  if (write_it) {
    {
#line 290
    crc___0 = (*updcrc)(crcinit, out_buffer, filehdr.dataLength);
    }
#line 291
    if ((unsigned long )filehdr.dataCRC != crc___0) {
      {
#line 292
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on data fork: need 0x%04x, got 0x%04x\n",
              (int )filehdr.dataCRC, (int )crc___0);
#line 298
      exit(1);
      }
    }
  }
#line 301
  if (verbose) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Rsrc: ");
    }
  }
#line 304
  if (write_it) {
    {
#line 305
    start_rsrc();
    }
  }
  {
#line 307
  zma_wrfile(filehdr.compRLength, filehdr.rsrcLength, (int )filehdr.what);
  }
#line 308
  if (write_it) {
    {
#line 309
    crc___0 = (*updcrc)(crcinit, out_buffer, filehdr.rsrcLength);
    }
#line 310
    if ((unsigned long )filehdr.rsrcCRC != crc___0) {
      {
#line 311
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on resource fork: need 0x%04x, got 0x%04x\n",
              (int )filehdr.rsrcCRC, (int )crc___0);
#line 317
      exit(1);
      }
    }
    {
#line 319
    end_file();
    }
  }
#line 321
  if (verbose) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 324
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static void zma_wrfile(unsigned long ibytes , unsigned long obytes , char type ) 
{ 


  {
#line 330
  if (ibytes == 0UL) {
#line 331
    if (verbose) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    }
#line 334
    return;
  }
  {
#line 337
  if ((int )type == 2) {
#line 337
    goto case_2;
  }
#line 345
  if ((int )type == 1) {
#line 345
    goto case_1;
  }
#line 354
  goto switch_default;
  case_2: /* CIL Label */ 
#line 338
  if (verbose) {
    {
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
    }
  }
#line 341
  if (write_it) {
    {
#line 342
    zma_nocomp(ibytes);
    }
  }
#line 344
  goto switch_break;
  case_1: /* CIL Label */ 
#line 346
  if (verbose) {
    {
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZH compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 350
  if (write_it) {
    {
#line 351
    zma_lzh(ibytes);
    }
  }
#line 353
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown compression method %2x\n",
          (int )type);
#line 359
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static void zma_nocomp(unsigned long ibytes ) 
{ 
  int n ;
  char *ptr___3 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 369
  n = (int )ibytes;
#line 370
  ptr___3 = out_buffer;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    tmp___1 = n;
#line 372
    n --;
#line 372
    if (! (tmp___1 > 0)) {
#line 372
      goto while_break;
    }
#line 373
    tmp = ptr___3;
#line 373
    ptr___3 ++;
#line 373
    tmp___0 = zma_filestart;
#line 373
    zma_filestart ++;
#line 373
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/zma.c"
static void zma_lzh(unsigned long ibytes ) 
{ 


  {
  {
#line 384
  de_lzh((long )ibytes, -1L, & zma_filestart, 13);
  }
#line 385
  return;
}
}
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_uncompact(struct fileHdr___2 filehdr ) ;
#line 29 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned char *cpt_data  ;
#line 30 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_datamax  ;
#line 31 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_datasize  ;
#line 32 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned char cpt_LZbuff[8192]  ;
#line 33 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned int cpt_LZptr  ;
#line 34 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned char *cpt_char  ;
#line 35 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_crc  ;
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_inlength  ;
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_outlength  ;
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_outstat  ;
#line 39 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned char cpt_savechar  ;
#line 40 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static unsigned long cpt_newbits  ;
#line 41 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_bitsavail  ;
#line 42 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_blocksize  ;
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static node cpt_Hufftree[518]  ;
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static node cpt_LZlength[134]  ;
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static node cpt_LZoffs[262]  ;
#line 48
static int readcpthdr(struct cptHdr *s ) ;
#line 49
static int cpt_filehdr(struct fileHdr___2 *f , char *hdr ) ;
#line 50
static void cpt_folder(char *name , struct fileHdr___2 fileh , char *cptptr ) ;
#line 52
static void cpt_wrfile(unsigned long ibytes , unsigned long obytes , unsigned short type ) ;
#line 53
void cpt_wrfile1(unsigned char *in_char , unsigned long ibytes , unsigned long obytes ,
                 int type , unsigned long blocksize___0 ) ;
#line 54
static void cpt_outch(unsigned char ch ) ;
#line 55
static void cpt_rle(void) ;
#line 56
static void cpt_rle_lzh(void) ;
#line 57
static void cpt_readHuff(int size___0 , struct node *Hufftree ) ;
#line 58
static int cpt_get6bits(void) ;
#line 59
static int cpt_getbit(void) ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
void cpt(void) 
{ 
  struct cptHdr cpthdr ;
  struct fileHdr___2 filehdr ;
  char *cptindex ;
  int cptindsize ;
  char *cptptr ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 70
  updcrc = & zip_updcrc;
#line 71
  crcinit = zip_crcinit;
#line 72
  cpt_crc = crcinit;
#line 73
  tmp = readcpthdr(& cpthdr);
  }
#line 73
  if (tmp == 0) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read archive header\n");
#line 78
    exit(1);
    }
  }
#line 81
  cptindsize = (int )cpthdr.entries * 80;
#line 82
  if ((int )cpthdr.commentsize > cptindsize) {
#line 83
    cptindsize = (int )cpthdr.commentsize;
  }
  {
#line 85
  cptindex = malloc((unsigned int )cptindsize);
  }
#line 86
  if ((unsigned long )cptindex == (unsigned long )((void *)0)) {
    {
#line 87
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 88
    exit(1);
    }
  }
  {
#line 90
  cptptr = cptindex;
#line 91
  tmp___0 = fread((void */* __restrict  */)cptptr, (size_t )1, (size_t )((int )cpthdr.commentsize),
                  (FILE */* __restrict  */)infp);
  }
#line 91
  if (tmp___0 != (size_t )cpthdr.commentsize) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read comment.\n");
#line 96
    exit(1);
    }
  }
  {
#line 98
  cpt_crc = (*updcrc)(cpt_crc, cptptr, (int )cpthdr.commentsize);
#line 100
  i = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < (int )cpthdr.entries)) {
#line 100
      goto while_break;
    }
    {
#line 101
    tmp___1 = _IO_getc(infp);
#line 101
    *cptptr = (char )tmp___1;
#line 102
    cpt_crc = (*updcrc)(cpt_crc, cptptr, 1);
    }
#line 103
    if ((int )*cptptr & 128) {
#line 104
      *(cptptr + 32) = (char)1;
#line 105
      *cptptr = (char )((int )*cptptr & 63);
    } else {
#line 107
      *(cptptr + 32) = (char)0;
    }
    {
#line 109
    tmp___2 = fread((void */* __restrict  */)(cptptr + 1), (size_t )1, (size_t )*cptptr,
                    (FILE */* __restrict  */)infp);
    }
#line 109
    if (tmp___2 != (size_t )*cptptr) {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
              i + 1);
#line 114
      exit(1);
      }
    }
    {
#line 116
    cpt_crc = (*updcrc)(cpt_crc, cptptr + 1, (int )*cptptr);
    }
#line 117
    if (*(cptptr + 32)) {
      {
#line 118
      tmp___3 = fread((void */* __restrict  */)(cptptr + 33), (size_t )1, (size_t )2,
                      (FILE */* __restrict  */)infp);
      }
#line 118
      if (tmp___3 != 2UL) {
        {
#line 119
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
                i + 1);
#line 123
        exit(1);
        }
      }
      {
#line 125
      cpt_crc = (*updcrc)(cpt_crc, cptptr + 33, 2);
      }
    } else {
      {
#line 127
      tmp___4 = fread((void */* __restrict  */)(cptptr + 35), (size_t )1, (size_t )45,
                      (FILE */* __restrict  */)infp);
      }
#line 127
      if (tmp___4 != 45UL) {
        {
#line 129
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
                i + 1);
#line 133
        exit(1);
        }
      }
      {
#line 135
      cpt_crc = (*updcrc)(cpt_crc, cptptr + 35, 45);
      }
    }
#line 138
    cptptr += 80;
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (cpt_crc != cpthdr.hdrcrc) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header CRC mismatch: got 0x%08x, need 0x%08x\n",
            (int )cpthdr.hdrcrc, (int )cpt_crc);
#line 146
    exit(1);
    }
  }
#line 149
  cptptr = cptindex;
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! (i < (int )cpthdr.entries)) {
#line 150
      goto while_break___0;
    }
    {
#line 151
    tmp___5 = cpt_filehdr(& filehdr, cptptr);
    }
#line 151
    if (tmp___5 == -1) {
      {
#line 152
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
              i + 1);
#line 156
      exit(1);
      }
    }
#line 158
    if (filehdr.folder) {
      {
#line 159
      cpt_folder(text, filehdr, cptptr);
#line 160
      i += (int )filehdr.foldersize;
#line 161
      cptptr += (int )filehdr.foldersize * 80;
      }
    } else {
      {
#line 163
      cpt_uncompact(filehdr);
      }
    }
#line 165
    cptptr += 80;
#line 150
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 167
  free(cptindex);
  }
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int readcpthdr(struct cptHdr *s ) 
{ 
  char temp[15] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;

  {
  {
#line 175
  tmp = fread((void */* __restrict  */)(temp), (size_t )1, (size_t )8, (FILE */* __restrict  */)infp);
  }
#line 175
  if (tmp != 8UL) {
#line 176
    return (0);
  }
#line 179
  if ((int )temp[0] != 1) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a Compactor file\n");
    }
#line 181
    return (0);
  }
  {
#line 184
  cpt_datasize = get4(temp + 4);
#line 185
  s->offset = cpt_datasize;
  }
#line 186
  if (cpt_datasize > cpt_datamax) {
#line 187
    if (cpt_datamax == 0UL) {
      {
#line 188
      tmp___0 = malloc((unsigned int )cpt_datasize);
#line 188
      cpt_data = (unsigned char *)tmp___0;
      }
    } else {
      {
#line 190
      tmp___1 = realloc((char *)cpt_data, (unsigned int )cpt_datasize);
#line 190
      cpt_data = (unsigned char *)tmp___1;
      }
    }
#line 193
    cpt_datamax = cpt_datasize;
  }
#line 195
  if ((unsigned long )cpt_data == (unsigned long )((void *)0)) {
    {
#line 196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory, aborting\n");
#line 197
    exit(1);
    }
  }
  {
#line 200
  tmp___2 = fread((void */* __restrict  */)((char *)(cpt_data + 8)), (size_t )1, (size_t )((int )s->offset - 8),
                  (FILE */* __restrict  */)infp);
  }
#line 200
  if (tmp___2 != s->offset - 8UL) {
#line 202
    return (0);
  }
  {
#line 205
  tmp___3 = fread((void */* __restrict  */)(temp + 8), (size_t )1, (size_t )7, (FILE */* __restrict  */)infp);
  }
#line 205
  if (tmp___3 != 7UL) {
#line 206
    return (0);
  }
  {
#line 209
  cpt_crc = (*updcrc)(cpt_crc, (temp + 8) + 4, 3);
#line 210
  s->hdrcrc = get4((temp + 8) + 0);
#line 211
  tmp___4 = get2((temp + 8) + 4);
#line 211
  s->entries = (unsigned short )tmp___4;
#line 212
  s->commentsize = (unsigned char )temp[14];
  }
#line 214
  return (1);
}
}
#line 217 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_filehdr(struct fileHdr___2 *f , char *hdr ) 
{ 
  register int i ;
  int n ;
  char ftype[5] ;
  char fauth[5] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < 128)) {
#line 225
      goto while_break;
    }
#line 226
    info[i] = (char )'\000';
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  n = (int )*(hdr + 0) & 255;
#line 230
  if (n > 63) {
#line 231
    n = 63;
  }
  {
#line 233
  info[1] = (char )n;
#line 234
  copy((info + 1) + 1, (hdr + 0) + 1, n);
#line 235
  transname((hdr + 0) + 1, text, n);
#line 237
  f->folder = (unsigned char )*(hdr + 32);
  }
#line 238
  if (f->folder) {
    {
#line 239
    tmp = get2(hdr + 33);
#line 239
    f->foldersize = (unsigned short )tmp;
    }
  } else {
    {
#line 241
    tmp___0 = get2(hdr + 62);
#line 241
    f->cptFlag = (unsigned short )tmp___0;
#line 242
    f->rsrcLength = get4(hdr + 64);
#line 243
    f->dataLength = get4(hdr + 68);
#line 244
    f->compRLength = get4(hdr + 72);
#line 245
    f->compDLength = get4(hdr + 76);
#line 246
    f->fileCRC = get4(hdr + 58);
#line 247
    tmp___1 = get2(hdr + 56);
#line 247
    f->FndrFlags = (unsigned short )tmp___1;
#line 248
    f->filepos = get4(hdr + 36);
#line 249
    f->volume = (unsigned char )*(hdr + 35);
    }
  }
#line 252
  write_it = 1;
#line 253
  if (list) {
    {
#line 254
    do_indent(indent);
    }
#line 255
    if (f->folder) {
      {
#line 256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
              text);
      }
    } else {
      {
#line 258
      transname(hdr + 40, ftype, 4);
#line 259
      transname(hdr + 44, fauth, 4);
#line 260
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
              text, ftype, fauth, (long )f->dataLength, (long )f->rsrcLength);
      }
    }
#line 265
    if (info_only) {
#line 266
      write_it = 0;
    }
#line 268
    if (query) {
      {
#line 269
      write_it = do_query();
      }
    } else {
      {
#line 271
      fputc('\n', stderr);
      }
    }
  }
#line 276
  if (write_it) {
    {
#line 277
    define_name(text);
    }
#line 279
    if (! f->folder) {
      {
#line 280
      copy(info + 65, hdr + 40, 4);
#line 281
      copy(info + 69, hdr + 44, 4);
#line 282
      copy(info + 73, hdr + 56, 2);
#line 283
      copy(info + 83, hdr + 68, 4);
#line 284
      copy(info + 87, hdr + 64, 4);
#line 285
      copy(info + 91, hdr + 48, 4);
#line 286
      copy(info + 95, hdr + 52, 4);
      }
    }
  }
#line 289
  return (1);
}
}
#line 292 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_folder(char *name , struct fileHdr___2 fileh , char *cptptr ) 
{ 
  int i ;
  int nfiles ;
  char loc_name[64] ;
  struct fileHdr___2 filehdr ;
  int tmp ;

  {
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < 64)) {
#line 301
      goto while_break;
    }
#line 302
    loc_name[i] = *(name + i);
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (write_it) {
#line 304
    goto _L;
  } else
#line 304
  if (info_only) {
    _L: /* CIL Label */ 
#line 305
    cptptr += 80;
#line 306
    nfiles = (int )fileh.foldersize;
#line 307
    if (write_it) {
      {
#line 308
      do_mkdir(text, info);
      }
    }
#line 310
    indent ++;
#line 311
    i = 0;
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 311
      if (! (i < nfiles)) {
#line 311
        goto while_break___0;
      }
      {
#line 312
      tmp = cpt_filehdr(& filehdr, cptptr);
      }
#line 312
      if (tmp == -1) {
        {
#line 313
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read file header #%d\n",
                i + 1);
#line 317
        exit(1);
        }
      }
#line 319
      if (filehdr.folder) {
        {
#line 320
        cpt_folder(text, filehdr, cptptr);
#line 321
        i += (int )filehdr.foldersize;
#line 322
        cptptr += (int )filehdr.foldersize * 80;
        }
      } else {
        {
#line 324
        cpt_uncompact(filehdr);
        }
      }
#line 326
      cptptr += 80;
#line 311
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 328
    if (write_it) {
      {
#line 329
      enddir();
      }
    }
#line 331
    indent --;
#line 332
    if (list) {
      {
#line 333
      do_indent(indent);
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
              loc_name);
      }
    }
  }
#line 337
  return;
}
}
#line 339 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_uncompact(struct fileHdr___2 filehdr ) 
{ 


  {
#line 342
  if ((int )filehdr.cptFlag & 1) {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFile is password protected, skipping file\n");
    }
#line 347
    return;
  }
#line 349
  if (write_it) {
    {
#line 350
    start_info(info, filehdr.rsrcLength, filehdr.dataLength);
#line 351
    cpt_crc = crcinit;
#line 352
    cpt_char = cpt_data + filehdr.filepos;
    }
  }
#line 354
  if (verbose) {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tRsrc: ");
    }
#line 356
    if (filehdr.compRLength == 0UL) {
      {
#line 357
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    } else
#line 358
    if ((int )filehdr.cptFlag & 2) {
      {
#line 359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE/LZH compressed (%4.1f%%)",
              (100.0 * (double )filehdr.compRLength) / (double )filehdr.rsrcLength);
      }
    } else {
      {
#line 362
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE compressed (%4.1f%%)",
              (100.0 * (double )filehdr.compRLength) / (double )filehdr.rsrcLength);
      }
    }
  }
#line 366
  if (write_it) {
    {
#line 367
    start_rsrc();
#line 368
    cpt_wrfile(filehdr.compRLength, filehdr.rsrcLength, (int )filehdr.cptFlag & 2);
#line 370
    cpt_char = (cpt_data + filehdr.filepos) + filehdr.compRLength;
    }
  }
#line 372
  if (verbose) {
    {
#line 373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Data: ");
    }
#line 374
    if (filehdr.compDLength == 0UL) {
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    } else
#line 376
    if ((int )filehdr.cptFlag & 4) {
      {
#line 377
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE/LZH compressed (%4.1f%%)",
              (100.0 * (double )filehdr.compDLength) / (double )filehdr.dataLength);
      }
    } else {
      {
#line 380
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE compressed (%4.1f%%)",
              (100.0 * (double )filehdr.compDLength) / (double )filehdr.dataLength);
      }
    }
  }
#line 384
  if (write_it) {
    {
#line 385
    start_data();
#line 386
    cpt_wrfile(filehdr.compDLength, filehdr.dataLength, (int )filehdr.cptFlag & 4);
    }
#line 388
    if (filehdr.fileCRC != cpt_crc) {
      {
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC error on file: need 0x%08lx, got 0x%08lx\n",
              (long )filehdr.fileCRC, (long )cpt_crc);
#line 395
      exit(1);
      }
    }
    {
#line 397
    end_file();
    }
  }
#line 399
  if (verbose) {
    {
#line 400
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 402
  return;
}
}
#line 404 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_wrfile(unsigned long ibytes , unsigned long obytes , unsigned short type ) 
{ 


  {
#line 408
  if (ibytes == 0UL) {
#line 409
    return;
  }
#line 411
  cpt_outstat = 0;
#line 412
  cpt_inlength = ibytes;
#line 413
  cpt_outlength = obytes;
#line 414
  cpt_LZptr = 0U;
#line 415
  cpt_blocksize = 131056;
#line 416
  if ((int )type == 0) {
    {
#line 417
    cpt_rle();
    }
  } else {
    {
#line 419
    cpt_rle_lzh();
    }
  }
  {
#line 421
  cpt_crc = (*updcrc)(cpt_crc, out_buffer, obytes);
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
void cpt_wrfile1(unsigned char *in_char , unsigned long ibytes , unsigned long obytes ,
                 int type , unsigned long blocksize___0 ) 
{ 


  {
#line 429
  cpt_char = in_char;
#line 430
  if (ibytes == 0UL) {
#line 431
    return;
  }
#line 433
  cpt_outstat = 0;
#line 434
  cpt_inlength = ibytes;
#line 435
  cpt_outlength = obytes;
#line 436
  cpt_LZptr = 0U;
#line 437
  cpt_blocksize = (int )blocksize___0;
#line 438
  if (type == 0) {
    {
#line 439
    cpt_rle();
    }
  } else {
    {
#line 441
    cpt_rle_lzh();
    }
  }
#line 443
  return;
}
}
#line 445 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_outch(unsigned char ch ) 
{ 
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 448
  tmp = cpt_LZptr;
#line 448
  cpt_LZptr ++;
#line 448
  cpt_LZbuff[tmp & 8191U] = ch;
  {
#line 450
  if (cpt_outstat == 0) {
#line 450
    goto case_0;
  }
#line 459
  if (cpt_outstat == 1) {
#line 459
    goto case_1;
  }
#line 478
  if (cpt_outstat == 2) {
#line 478
    goto case_2;
  }
#line 449
  goto switch_break;
  case_0: /* CIL Label */ 
#line 451
  if ((int )ch == 129) {
#line 451
    if (cpt_outlength != 1UL) {
#line 452
      cpt_outstat = 1;
    } else {
#line 454
      cpt_savechar = ch;
#line 455
      tmp___0 = out_ptr;
#line 455
      out_ptr ++;
#line 455
      *tmp___0 = (char )ch;
#line 456
      cpt_outlength --;
    }
  } else {
#line 454
    cpt_savechar = ch;
#line 455
    tmp___0 = out_ptr;
#line 455
    out_ptr ++;
#line 455
    *tmp___0 = (char )ch;
#line 456
    cpt_outlength --;
  }
#line 458
  goto switch_break;
  case_1: /* CIL Label */ 
#line 460
  if ((int )ch == 130) {
#line 461
    cpt_outstat = 2;
  } else {
#line 463
    cpt_savechar = (unsigned char)129;
#line 464
    tmp___1 = out_ptr;
#line 464
    out_ptr ++;
#line 464
    *tmp___1 = (char)-127;
#line 465
    cpt_outlength --;
#line 466
    if (cpt_outlength == 0UL) {
#line 467
      return;
    }
#line 469
    if ((int )ch == 129) {
#line 469
      if (cpt_outlength != 1UL) {
#line 470
        return;
      }
    }
#line 472
    cpt_outstat = 0;
#line 473
    cpt_savechar = ch;
#line 474
    tmp___2 = out_ptr;
#line 474
    out_ptr ++;
#line 474
    *tmp___2 = (char )ch;
#line 475
    cpt_outlength --;
  }
#line 477
  goto switch_break;
  case_2: /* CIL Label */ 
#line 479
  cpt_outstat = 0;
#line 480
  if ((int )ch != 0) {
    {
#line 481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 481
      ch = (unsigned char )((int )ch - 1);
#line 481
      if (! ((int )ch != 0)) {
#line 481
        goto while_break;
      }
#line 482
      tmp___3 = out_ptr;
#line 482
      out_ptr ++;
#line 482
      *tmp___3 = (char )cpt_savechar;
#line 483
      cpt_outlength --;
#line 484
      if (cpt_outlength == 0UL) {
#line 485
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 489
    tmp___4 = out_ptr;
#line 489
    out_ptr ++;
#line 489
    *tmp___4 = (char)-127;
#line 490
    cpt_outlength --;
#line 491
    if (cpt_outlength == 0UL) {
#line 492
      return;
    }
#line 494
    cpt_savechar = (unsigned char)130;
#line 495
    tmp___5 = out_ptr;
#line 495
    out_ptr ++;
#line 495
    *tmp___5 = (char )cpt_savechar;
#line 496
    cpt_outlength --;
  }
  switch_break: /* CIL Label */ ;
  }
#line 499
  return;
}
}
#line 504 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_rle(void) 
{ 
  unsigned char *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    tmp___0 = cpt_inlength;
#line 506
    cpt_inlength --;
#line 506
    if (! (tmp___0 > 0UL)) {
#line 506
      goto while_break;
    }
    {
#line 507
    tmp = cpt_char;
#line 507
    cpt_char ++;
#line 507
    cpt_outch(*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_rle_lzh(void) 
{ 
  int block_count ;
  unsigned int bptr ;
  int Huffchar ;
  int LZlength ;
  int LZoffs ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 520
  get_bit = & cpt_getbit;
#line 521
  cpt_LZbuff[8189] = (unsigned char)0;
#line 522
  cpt_LZbuff[8190] = (unsigned char)0;
#line 523
  cpt_LZbuff[8191] = (unsigned char)0;
#line 524
  cpt_LZptr = 0U;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (cpt_outlength != 0UL)) {
#line 525
      goto while_break;
    }
    {
#line 526
    cpt_readHuff(256, cpt_Hufftree);
#line 527
    cpt_readHuff(64, cpt_LZlength);
#line 528
    cpt_readHuff(128, cpt_LZoffs);
#line 529
    block_count = 0;
#line 530
    tmp = cpt_char;
#line 530
    cpt_char ++;
#line 530
    cpt_newbits = (unsigned long )((int )*tmp << 8);
#line 531
    tmp___0 = cpt_char;
#line 531
    cpt_char ++;
#line 531
    cpt_newbits |= (unsigned long )*tmp___0;
#line 532
    cpt_newbits <<= 16;
#line 533
    cpt_bitsavail = 16;
    }
    {
#line 534
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 534
      if (block_count < cpt_blocksize) {
#line 534
        if (! (cpt_outlength != 0UL)) {
#line 534
          goto while_break___0;
        }
      } else {
#line 534
        goto while_break___0;
      }
      {
#line 535
      tmp___4 = cpt_getbit();
      }
#line 535
      if (tmp___4) {
        {
#line 536
        Huffchar = gethuffbyte(cpt_Hufftree);
#line 537
        cpt_outch((unsigned char )Huffchar);
#line 538
        block_count += 2;
        }
      } else {
        {
#line 540
        LZlength = gethuffbyte(cpt_LZlength);
#line 541
        LZoffs = gethuffbyte(cpt_LZoffs);
#line 542
        tmp___1 = cpt_get6bits();
#line 542
        LZoffs = (LZoffs << 6) | tmp___1;
#line 543
        bptr = cpt_LZptr - (unsigned int )LZoffs;
        }
        {
#line 544
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 544
          tmp___3 = LZlength;
#line 544
          LZlength --;
#line 544
          if (! (tmp___3 > 0)) {
#line 544
            goto while_break___1;
          }
          {
#line 545
          tmp___2 = bptr;
#line 545
          bptr ++;
#line 545
          cpt_outch(cpt_LZbuff[tmp___2 & 8191U]);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 547
        block_count += 3;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static void cpt_readHuff(int size___0 , struct node *Hufftree ) 
{ 
  sf_entry tree_entry[262] ;
  int tree_entries ;
  int tree_MaxLength ;
  int treeBytes ;
  int i ;
  int len ;
  sf_entry *ejm1 ;
  int j ;
  sf_entry *entry ;
  sf_entry tmp ;
  int entries ;
  unsigned int a ;
  unsigned int b___1 ;
  int codelen ;
  int lvlstart ;
  int next ;
  int parents ;
  int tree_count[32] ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 590
  tmp___0 = cpt_char;
#line 590
  cpt_char ++;
#line 590
  treeBytes = (int )*tmp___0;
#line 591
  if (size___0 < treeBytes * 2) {
    {
#line 592
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bytes is: %d, expected: %d\n",
            treeBytes, size___0 / 2);
#line 597
    exit(1);
    }
  }
#line 599
  i = 0;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    if (! (i < 32)) {
#line 599
      goto while_break;
    }
#line 600
    tree_count[i] = 0;
#line 599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  i = 0;
#line 603
  tree_MaxLength = 0;
#line 604
  tree_entries = 0;
  {
#line 605
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 605
    tmp___4 = treeBytes;
#line 605
    treeBytes --;
#line 605
    if (! (tmp___4 > 0)) {
#line 605
      goto while_break___0;
    }
#line 606
    len = (int )*cpt_char >> 4;
#line 607
    if (len != 0) {
#line 608
      if (len > tree_MaxLength) {
#line 609
        tree_MaxLength = len;
      }
#line 611
      (tree_count[len]) ++;
#line 612
      tree_entry[tree_entries].Value = i;
#line 613
      tmp___1 = tree_entries;
#line 613
      tree_entries ++;
#line 613
      tree_entry[tmp___1].BitLength = len;
    }
#line 615
    i ++;
#line 616
    tmp___2 = cpt_char;
#line 616
    cpt_char ++;
#line 616
    len = (int )*tmp___2 & 15;
#line 617
    if (len != 0) {
#line 618
      if (len > tree_MaxLength) {
#line 619
        tree_MaxLength = len;
      }
#line 621
      (tree_count[len]) ++;
#line 622
      tree_entry[tree_entries].Value = i;
#line 623
      tmp___3 = tree_entries;
#line 623
      tree_entries ++;
#line 623
      tree_entry[tmp___3].BitLength = len;
    }
#line 625
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 629
  j = 0;
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 630
    if (! (i <= tree_MaxLength)) {
#line 630
      goto while_break___1;
    }
#line 631
    j = (j << 1) + tree_count[i];
#line 630
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 633
  j = (1 << tree_MaxLength) - j;
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 635
    if (! (i < j)) {
#line 635
      goto while_break___2;
    }
#line 636
    tree_entry[tree_entries].Value = size___0;
#line 637
    tmp___5 = tree_entries;
#line 637
    tree_entries ++;
#line 637
    tree_entry[tmp___5].BitLength = tree_MaxLength;
#line 635
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 641
  entry = & tree_entry[0];
#line 642
  entries = tree_entries;
#line 643
  i = 0;
  {
#line 643
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 643
    i ++;
#line 643
    if (! (i < entries)) {
#line 643
      goto while_break___3;
    }
#line 644
    tmp = *(entry + i);
#line 645
    b___1 = (unsigned int )tmp.BitLength;
#line 646
    j = i;
    {
#line 647
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 647
      if (j > 0) {
#line 647
        ejm1 = entry + (j - 1);
#line 647
        a = (unsigned int )ejm1->BitLength;
#line 647
        if (! (a >= b___1)) {
#line 647
          goto while_break___4;
        }
      } else {
#line 647
        goto while_break___4;
      }
#line 648
      if (a == b___1) {
#line 648
        if (ejm1->Value <= tmp.Value) {
#line 649
          goto while_break___4;
        }
      }
#line 651
      *(ejm1 + 1) = *ejm1;
#line 652
      j --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 654
    *(entry + j) = tmp;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 658
  i = tree_entries - 1;
#line 660
  next = (size___0 * 2 + 6) - 1;
#line 660
  lvlstart = next;
#line 662
  codelen = tree_MaxLength;
  {
#line 662
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 662
    if (! (codelen >= 1)) {
#line 662
      goto while_break___5;
    }
    {
#line 663
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 663
      if (i >= 0) {
#line 663
        if (! (tree_entry[i].BitLength == codelen)) {
#line 663
          goto while_break___6;
        }
      } else {
#line 663
        goto while_break___6;
      }
#line 664
      (Hufftree + next)->byte = tree_entry[i].Value;
#line 665
      (Hufftree + next)->flag = 1;
#line 666
      next --;
#line 667
      i --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 669
    parents = next;
#line 670
    if (codelen > 1) {
#line 672
      j = lvlstart;
      {
#line 672
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 672
        if (! (j > parents + 1)) {
#line 672
          goto while_break___7;
        }
#line 673
        (Hufftree + next)->one = Hufftree + j;
#line 674
        (Hufftree + next)->zero = Hufftree + (j - 1);
#line 675
        (Hufftree + next)->flag = 0;
#line 676
        next --;
#line 672
        j -= 2;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 679
    lvlstart = parents;
#line 662
    codelen --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 681
  (Hufftree + 0)->one = Hufftree + (next + 2);
#line 682
  (Hufftree + 0)->zero = Hufftree + (next + 1);
#line 683
  (Hufftree + 0)->flag = 0;
#line 684
  return;
}
}
#line 686 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_get6bits(void) 
{ 
  int b___1 ;
  int cn ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 688
  b___1 = 0;
#line 690
  b___1 = (int )((cpt_newbits >> 26) & 63UL);
#line 691
  cpt_bitsavail -= 6;
#line 692
  cpt_newbits <<= 6;
#line 693
  if (cpt_bitsavail < 16) {
#line 694
    tmp = cpt_char;
#line 694
    cpt_char ++;
#line 694
    cn = (int )*tmp << 8;
#line 695
    tmp___0 = cpt_char;
#line 695
    cpt_char ++;
#line 695
    cn |= (int )*tmp___0;
#line 696
    cpt_newbits |= (unsigned long )(cn << (16 - cpt_bitsavail));
#line 697
    cpt_bitsavail += 16;
  }
#line 699
  return (b___1);
}
}
#line 702 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/cpt.c"
static int cpt_getbit(void) 
{ 
  int b___1 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 706
  b___1 = (int )((cpt_newbits >> 31) & 1UL);
#line 707
  cpt_bitsavail --;
#line 708
  if (cpt_bitsavail < 16) {
#line 709
    tmp = cpt_char;
#line 709
    cpt_char ++;
#line 709
    cpt_newbits |= (unsigned long )((int )*tmp << 8);
#line 710
    tmp___0 = cpt_char;
#line 710
    cpt_char ++;
#line 710
    cpt_newbits |= (unsigned long )*tmp___0;
#line 711
    cpt_bitsavail += 16;
  }
#line 713
  cpt_newbits <<= 1;
#line 714
  return (b___1);
}
}
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static unsigned short HuffCode[256]  = 
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
  {      (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)64,      (unsigned short)64,      (unsigned short)64,      (unsigned short)64, 
        (unsigned short)64,      (unsigned short)64,      (unsigned short)64,      (unsigned short)64, 
        (unsigned short)64,      (unsigned short)64,      (unsigned short)64,      (unsigned short)64, 
        (unsigned short)64,      (unsigned short)64,      (unsigned short)64,      (unsigned short)64, 
        (unsigned short)128,      (unsigned short)128,      (unsigned short)128,      (unsigned short)128, 
        (unsigned short)128,      (unsigned short)128,      (unsigned short)128,      (unsigned short)128, 
        (unsigned short)128,      (unsigned short)128,      (unsigned short)128,      (unsigned short)128, 
        (unsigned short)128,      (unsigned short)128,      (unsigned short)128,      (unsigned short)128, 
        (unsigned short)192,      (unsigned short)192,      (unsigned short)192,      (unsigned short)192, 
        (unsigned short)192,      (unsigned short)192,      (unsigned short)192,      (unsigned short)192, 
        (unsigned short)192,      (unsigned short)192,      (unsigned short)192,      (unsigned short)192, 
        (unsigned short)192,      (unsigned short)192,      (unsigned short)192,      (unsigned short)192, 
        (unsigned short)256,      (unsigned short)256,      (unsigned short)256,      (unsigned short)256, 
        (unsigned short)256,      (unsigned short)256,      (unsigned short)256,      (unsigned short)256, 
        (unsigned short)320,      (unsigned short)320,      (unsigned short)320,      (unsigned short)320, 
        (unsigned short)320,      (unsigned short)320,      (unsigned short)320,      (unsigned short)320, 
        (unsigned short)384,      (unsigned short)384,      (unsigned short)384,      (unsigned short)384, 
        (unsigned short)384,      (unsigned short)384,      (unsigned short)384,      (unsigned short)384, 
        (unsigned short)448,      (unsigned short)448,      (unsigned short)448,      (unsigned short)448, 
        (unsigned short)448,      (unsigned short)448,      (unsigned short)448,      (unsigned short)448, 
        (unsigned short)512,      (unsigned short)512,      (unsigned short)512,      (unsigned short)512, 
        (unsigned short)512,      (unsigned short)512,      (unsigned short)512,      (unsigned short)512, 
        (unsigned short)576,      (unsigned short)576,      (unsigned short)576,      (unsigned short)576, 
        (unsigned short)576,      (unsigned short)576,      (unsigned short)576,      (unsigned short)576, 
        (unsigned short)640,      (unsigned short)640,      (unsigned short)640,      (unsigned short)640, 
        (unsigned short)640,      (unsigned short)640,      (unsigned short)640,      (unsigned short)640, 
        (unsigned short)704,      (unsigned short)704,      (unsigned short)704,      (unsigned short)704, 
        (unsigned short)704,      (unsigned short)704,      (unsigned short)704,      (unsigned short)704, 
        (unsigned short)768,      (unsigned short)768,      (unsigned short)768,      (unsigned short)768, 
        (unsigned short)832,      (unsigned short)832,      (unsigned short)832,      (unsigned short)832, 
        (unsigned short)896,      (unsigned short)896,      (unsigned short)896,      (unsigned short)896, 
        (unsigned short)960,      (unsigned short)960,      (unsigned short)960,      (unsigned short)960, 
        (unsigned short)1024,      (unsigned short)1024,      (unsigned short)1024,      (unsigned short)1024, 
        (unsigned short)1088,      (unsigned short)1088,      (unsigned short)1088,      (unsigned short)1088, 
        (unsigned short)1152,      (unsigned short)1152,      (unsigned short)1152,      (unsigned short)1152, 
        (unsigned short)1216,      (unsigned short)1216,      (unsigned short)1216,      (unsigned short)1216, 
        (unsigned short)1280,      (unsigned short)1280,      (unsigned short)1280,      (unsigned short)1280, 
        (unsigned short)1344,      (unsigned short)1344,      (unsigned short)1344,      (unsigned short)1344, 
        (unsigned short)1408,      (unsigned short)1408,      (unsigned short)1408,      (unsigned short)1408, 
        (unsigned short)1472,      (unsigned short)1472,      (unsigned short)1472,      (unsigned short)1472, 
        (unsigned short)1536,      (unsigned short)1536,      (unsigned short)1600,      (unsigned short)1600, 
        (unsigned short)1664,      (unsigned short)1664,      (unsigned short)1728,      (unsigned short)1728, 
        (unsigned short)1792,      (unsigned short)1792,      (unsigned short)1856,      (unsigned short)1856, 
        (unsigned short)1920,      (unsigned short)1920,      (unsigned short)1984,      (unsigned short)1984, 
        (unsigned short)2048,      (unsigned short)2048,      (unsigned short)2112,      (unsigned short)2112, 
        (unsigned short)2176,      (unsigned short)2176,      (unsigned short)2240,      (unsigned short)2240, 
        (unsigned short)2304,      (unsigned short)2304,      (unsigned short)2368,      (unsigned short)2368, 
        (unsigned short)2432,      (unsigned short)2432,      (unsigned short)2496,      (unsigned short)2496, 
        (unsigned short)2560,      (unsigned short)2560,      (unsigned short)2624,      (unsigned short)2624, 
        (unsigned short)2688,      (unsigned short)2688,      (unsigned short)2752,      (unsigned short)2752, 
        (unsigned short)2816,      (unsigned short)2816,      (unsigned short)2880,      (unsigned short)2880, 
        (unsigned short)2944,      (unsigned short)2944,      (unsigned short)3008,      (unsigned short)3008, 
        (unsigned short)3072,      (unsigned short)3136,      (unsigned short)3200,      (unsigned short)3264, 
        (unsigned short)3328,      (unsigned short)3392,      (unsigned short)3456,      (unsigned short)3520, 
        (unsigned short)3584,      (unsigned short)3648,      (unsigned short)3712,      (unsigned short)3776, 
        (unsigned short)3840,      (unsigned short)3904,      (unsigned short)3968,      (unsigned short)4032};
#line 62 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static short HuffLength[256]  = 
#line 62
  {      (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)3,      (short)3,      (short)3,      (short)3, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)4,      (short)4,      (short)4,      (short)4, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)6,      (short)6,      (short)6,      (short)6, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)7,      (short)7,      (short)7,      (short)7, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8, 
        (short)8,      (short)8,      (short)8,      (short)8};
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
unsigned char (*lzah_getbyte)()  ;
#line 82
static void lzah_inithuf(void) ;
#line 83
static void lzah_reorder(void) ;
#line 84
static void lzah_move(int *p , int *q , int n ) ;
#line 85
static void lzah_getbit(void) ;
#line 86
static void lzah_outchar(char ch ) ;
#line 88 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static char lzah_buf[4096]  ;
#line 89 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int lzah_bufptr  ;
#line 90 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int lzah_bitsavail  ;
#line 91 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int lzah_bits  ;
#line 92 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int Frequ[1000]  ;
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int ForwTree[1000]  ;
#line 94 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static int BackTree[1000]  ;
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
void de_lzah(unsigned long obytes ) 
{ 
  int i ;
  int i1 ;
  int j ;
  int ch ;
  int byte ;
  int offs ;
  int skip ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 101
  lzah_inithuf();
#line 102
  lzah_bitsavail = 0;
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 4036)) {
#line 103
      goto while_break;
    }
#line 104
    lzah_buf[i] = (char )' ';
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  lzah_bufptr = 4036;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (obytes != 0UL)) {
#line 107
      goto while_break___0;
    }
#line 108
    ch = ForwTree[626];
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      if (! (ch < 627)) {
#line 109
        goto while_break___1;
      }
      {
#line 110
      lzah_getbit();
      }
#line 111
      if (lzah_bits & 128) {
#line 112
        ch ++;
      }
#line 114
      ch = ForwTree[ch];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    ch -= 627;
#line 117
    if (Frequ[626] >= 32768) {
      {
#line 118
      lzah_reorder();
      }
    }
#line 121
    i = BackTree[ch + 627];
    {
#line 122
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 123
      (Frequ[i]) ++;
#line 123
      j = Frequ[i];
#line 124
      i1 = i + 1;
#line 125
      if (Frequ[i1] < j) {
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 126
          i1 ++;
#line 126
          if (! (Frequ[i1] < j)) {
#line 126
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 127
        i1 --;
#line 128
        Frequ[i] = Frequ[i1];
#line 129
        Frequ[i1] = j;
#line 131
        j = ForwTree[i];
#line 132
        BackTree[j] = i1;
#line 133
        if (j < 627) {
#line 134
          BackTree[j + 1] = i1;
        }
#line 136
        ForwTree[i] = ForwTree[i1];
#line 137
        ForwTree[i1] = j;
#line 138
        j = ForwTree[i];
#line 139
        BackTree[j] = i;
#line 140
        if (j < 627) {
#line 141
          BackTree[j + 1] = i;
        }
#line 143
        i = i1;
      }
#line 145
      i = BackTree[i];
#line 122
      if (! (i != 0)) {
#line 122
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 148
    if (ch < 256) {
      {
#line 149
      lzah_outchar((int )((char )ch));
#line 150
      obytes --;
      }
    } else {
#line 152
      if (lzah_bitsavail != 0) {
        {
#line 153
        byte = (lzah_bits << 1) & 255;
#line 154
        tmp = (*lzah_getbyte)();
#line 154
        lzah_bits = (int )tmp & 255;
#line 155
        byte |= lzah_bits >> lzah_bitsavail;
#line 156
        lzah_bits <<= 7 - lzah_bitsavail;
        }
      } else {
        {
#line 158
        tmp___0 = (*lzah_getbyte)();
#line 158
        byte = (int )tmp___0 & 255;
        }
      }
#line 160
      offs = (int )HuffCode[byte];
#line 161
      skip = (int )HuffLength[byte] - 2;
      {
#line 162
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 162
        tmp___1 = skip;
#line 162
        skip --;
#line 162
        if (! (tmp___1 != 0)) {
#line 162
          goto while_break___4;
        }
        {
#line 163
        byte += byte;
#line 164
        lzah_getbit();
        }
#line 165
        if (lzah_bits & 128) {
#line 166
          byte ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 169
      offs |= byte & 63;
#line 170
      offs = ((lzah_bufptr - offs) - 1) & 4095;
#line 171
      ch -= 253;
      {
#line 172
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 172
        tmp___3 = ch;
#line 172
        ch --;
#line 172
        if (! (tmp___3 > 0)) {
#line 172
          goto while_break___5;
        }
        {
#line 173
        tmp___2 = offs;
#line 173
        offs ++;
#line 173
        lzah_outchar((int )lzah_buf[tmp___2 & 4095]);
#line 174
        obytes --;
        }
#line 175
        if (obytes == 0UL) {
#line 176
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static void lzah_inithuf(void) 
{ 
  int i ;
  int j ;

  {
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < 314)) {
#line 187
      goto while_break;
    }
#line 188
    Frequ[i] = 1;
#line 189
    ForwTree[i] = i + 627;
#line 190
    BackTree[i + 627] = i;
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  i = 0;
#line 192
  j = 314;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! (j < 627)) {
#line 192
      goto while_break___0;
    }
#line 193
    Frequ[j] = Frequ[i] + Frequ[i + 1];
#line 194
    ForwTree[j] = i;
#line 195
    BackTree[i] = j;
#line 196
    BackTree[i + 1] = j;
#line 192
    i += 2;
#line 192
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 198
  Frequ[627] = 65535;
#line 199
  BackTree[626] = 0;
#line 200
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static void lzah_reorder(void) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;

  {
#line 206
  j = 0;
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i < 627)) {
#line 207
      goto while_break;
    }
#line 208
    if (ForwTree[i] >= 627) {
#line 209
      Frequ[j] = (Frequ[i] + 1) >> 1;
#line 210
      ForwTree[j] = ForwTree[i];
#line 211
      j ++;
    }
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  i = 0;
#line 214
  j = 314;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! (i < 627)) {
#line 214
      goto while_break___0;
    }
#line 215
    k = i + 1;
#line 216
    l = Frequ[i] + Frequ[k];
#line 217
    Frequ[j] = l;
#line 218
    k = j - 1;
    {
#line 219
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 219
      if (! (l < Frequ[k])) {
#line 219
        goto while_break___1;
      }
#line 220
      k --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 222
    k ++;
#line 223
    lzah_move(Frequ + k, (Frequ + k) + 1, j - k);
#line 224
    Frequ[k] = l;
#line 225
    lzah_move(ForwTree + k, (ForwTree + k) + 1, j - k);
#line 226
    ForwTree[k] = i;
#line 214
    i += 2;
#line 214
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 228
    if (! (i < 627)) {
#line 228
      goto while_break___2;
    }
#line 229
    k = ForwTree[i];
#line 230
    if (k >= 627) {
#line 231
      BackTree[k] = i;
    } else {
#line 233
      BackTree[k] = i;
#line 234
      BackTree[k + 1] = i;
    }
#line 228
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 237
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static void lzah_move(int *p , int *q , int n ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 242
  if ((unsigned long )p > (unsigned long )q) {
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      tmp___1 = n;
#line 243
      n --;
#line 243
      if (! (tmp___1 > 0)) {
#line 243
        goto while_break;
      }
#line 244
      tmp = q;
#line 244
      q ++;
#line 244
      tmp___0 = p;
#line 244
      p ++;
#line 244
      *tmp = *tmp___0;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 247
    p += n;
#line 248
    q += n;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      tmp___2 = n;
#line 249
      n --;
#line 249
      if (! (tmp___2 > 0)) {
#line 249
        goto while_break___0;
      }
#line 250
      q --;
#line 250
      p --;
#line 250
      *q = *p;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 253
  return;
}
}
#line 255 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static void lzah_getbit(void) 
{ 
  unsigned char tmp ;

  {
#line 257
  if (lzah_bitsavail != 0) {
#line 258
    lzah_bits += lzah_bits;
#line 259
    lzah_bitsavail --;
  } else {
    {
#line 261
    tmp = (*lzah_getbyte)();
#line 261
    lzah_bits = (int )tmp & 255;
#line 262
    lzah_bitsavail = 7;
    }
  }
#line 264
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_lzah.c"
static void lzah_outchar(char ch ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 269
  tmp = out_ptr;
#line 269
  out_ptr ++;
#line 269
  *tmp = ch;
#line 270
  tmp___0 = lzah_bufptr;
#line 270
  lzah_bufptr ++;
#line 270
  lzah_buf[tmp___0] = ch;
#line 271
  lzah_bufptr &= 4095;
#line 272
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int n_bits  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int maxbits  ;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static long maxcode  ;
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static long maxmaxcode  ;
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static long htab[69001]  ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static unsigned short codetab[69001]  ;
#line 32 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static long free_ent  =    0L;
#line 34
static long getcode(void) ;
#line 36 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int clear_flg  =    0;
#line 45 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int toread  ;
#line 47 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
void de_compress(unsigned long ibytes , int mb ) 
{ 
  register unsigned char *stackp ;
  register int finchar ;
  register long code ;
  register long oldcode ;
  register long incode ;
  char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;

  {
#line 55
  toread = (int )ibytes;
#line 56
  maxbits = mb;
#line 57
  maxmaxcode = (long )(1 << maxbits);
#line 58
  n_bits = 9;
#line 58
  maxcode = (long )((1 << n_bits) - 1);
#line 59
  code = 255L;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (code >= 0L)) {
#line 59
      goto while_break;
    }
#line 60
    codetab[code] = (unsigned short)0;
#line 61
    *((unsigned char *)(htab) + code) = (unsigned char )code;
#line 59
    code --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  free_ent = 257L;
#line 64
  oldcode = getcode();
#line 64
  finchar = (int )oldcode;
  }
#line 65
  if (oldcode == -1L) {
#line 66
    return;
  }
#line 69
  tmp = out_ptr;
#line 69
  out_ptr ++;
#line 69
  *tmp = (char )finchar;
#line 70
  stackp = (unsigned char *)(htab) + (1 << 16);
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 71
    code = getcode();
    }
#line 71
    if (! (code > -1L)) {
#line 71
      goto while_break___0;
    }
#line 72
    if (code == 256L) {
#line 73
      code = 255L;
      {
#line 73
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 73
        if (! (code >= 0L)) {
#line 73
          goto while_break___1;
        }
#line 74
        codetab[code] = (unsigned short)0;
#line 73
        code --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 76
      clear_flg = 1;
#line 77
      free_ent = 256L;
#line 78
      code = getcode();
      }
#line 78
      if (code == -1L) {
#line 79
        goto while_break___0;
      }
    }
#line 82
    incode = code;
#line 86
    if (code >= free_ent) {
#line 87
      tmp___0 = stackp;
#line 87
      stackp ++;
#line 87
      *tmp___0 = (unsigned char )finchar;
#line 88
      code = oldcode;
    }
    {
#line 93
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 93
      if (! (code >= 256L)) {
#line 93
        goto while_break___2;
      }
#line 94
      tmp___1 = stackp;
#line 94
      stackp ++;
#line 94
      *tmp___1 = *((unsigned char *)(htab) + code);
#line 95
      code = (long )codetab[code];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 97
    tmp___2 = stackp;
#line 97
    stackp ++;
#line 97
    finchar = (int )*((unsigned char *)(htab) + code);
#line 97
    *tmp___2 = (unsigned char )finchar;
    {
#line 101
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 102
      tmp___3 = out_ptr;
#line 102
      out_ptr ++;
#line 102
      stackp --;
#line 102
      *tmp___3 = (char )*stackp;
#line 101
      if (! ((unsigned long )stackp > (unsigned long )((unsigned char *)(htab) + (1 << 16)))) {
#line 101
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 107
    code = free_ent;
#line 107
    if (code < maxmaxcode) {
#line 108
      codetab[code] = (unsigned short )oldcode;
#line 109
      *((unsigned char *)(htab) + code) = (unsigned char )finchar;
#line 110
      free_ent = code + 1L;
    }
#line 115
    oldcode = incode;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static unsigned char rmask[9]  = 
#line 120
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)3,      (unsigned char)7, 
        (unsigned char)15,      (unsigned char)31,      (unsigned char)63,      (unsigned char)127, 
        (unsigned char)255};
#line 123 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int get_core_bytes  ;
#line 124 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static char *core_ptr  ;
#line 125
static int file_bytes(char *buf___0 , int length___0 ) ;
#line 126
static int core_bytes(char *buf___0 , int length___0 ) ;
#line 131 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int offset  =    0;
#line 131 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int size  =    0;
#line 132 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static unsigned char buf[16]  ;
#line 128 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static long getcode(void) 
{ 
  register long code ;
  register int r_off ;
  register int bits ;
  register unsigned char *bp ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 134
  bp = buf;
#line 136
  if (clear_flg > 0) {
#line 136
    goto _L;
  } else
#line 136
  if (offset >= size) {
#line 136
    goto _L;
  } else
#line 136
  if (free_ent > maxcode) {
    _L: /* CIL Label */ 
#line 142
    if (free_ent > maxcode) {
#line 143
      n_bits ++;
#line 144
      if (n_bits == maxbits) {
#line 145
        maxcode = maxmaxcode;
      } else {
#line 147
        maxcode = (long )((1 << n_bits) - 1);
      }
    }
#line 150
    if (clear_flg > 0) {
#line 151
      n_bits = 9;
#line 151
      maxcode = (long )((1 << n_bits) - 1);
#line 152
      clear_flg = 0;
    }
#line 154
    if (toread == 0) {
#line 155
      return (-1L);
    }
#line 157
    if (get_core_bytes) {
#line 158
      if (n_bits < toread) {
#line 158
        tmp = n_bits;
      } else {
#line 158
        tmp = toread;
      }
      {
#line 158
      size = core_bytes((char *)(buf), tmp);
      }
    } else {
#line 160
      if (n_bits < toread) {
#line 160
        tmp___0 = n_bits;
      } else {
#line 160
        tmp___0 = toread;
      }
      {
#line 160
      size = file_bytes((char *)(buf), tmp___0);
      }
    }
#line 162
    toread -= size;
#line 163
    if (size <= 0) {
      {
#line 164
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 168
      exit(1);
      }
    }
#line 170
    offset = 0;
#line 172
    size = (size << 3) - (n_bits - 1);
  }
#line 174
  r_off = offset;
#line 175
  bits = n_bits;
#line 179
  bp += r_off >> 3;
#line 180
  r_off &= 7;
#line 182
  tmp___1 = bp;
#line 182
  bp ++;
#line 182
  code = (long )((int )*tmp___1 >> r_off);
#line 183
  bits -= 8 - r_off;
#line 184
  r_off = 8 - r_off;
#line 186
  if (bits >= 8) {
#line 187
    tmp___2 = bp;
#line 187
    bp ++;
#line 187
    code |= (long )((int )*tmp___2 << r_off);
#line 188
    r_off += 8;
#line 189
    bits -= 8;
  }
#line 192
  code |= (long )(((int )*bp & (int )rmask[bits]) << r_off);
#line 193
  offset += n_bits;
#line 194
  return (code);
}
}
#line 197 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int file_bytes(char *buf___0 , int length___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 201
  tmp = fread((void */* __restrict  */)buf___0, (size_t )1, (size_t )length___0, (FILE */* __restrict  */)infp);
  }
#line 201
  return ((int )tmp);
}
}
#line 204 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
static int core_bytes(char *buf___0 , int length___0 ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < length___0)) {
#line 210
      goto while_break;
    }
#line 211
    tmp = buf___0;
#line 211
    buf___0 ++;
#line 211
    tmp___0 = core_ptr;
#line 211
    core_ptr ++;
#line 211
    *tmp = *tmp___0;
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (length___0);
}
}
#line 216 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/de_compress.c"
void core_compress(char *ptr___3 ) 
{ 


  {
#line 219
  core_ptr = ptr___3;
#line 220
  get_core_bytes = (unsigned long )ptr___3 != (unsigned long )((void *)0);
#line 221
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
static unsigned short crctab___15[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/kermit.c"
  {      (unsigned short)0,      (unsigned short)4489,      (unsigned short)8978,      (unsigned short)12955, 
        (unsigned short)17956,      (unsigned short)22445,      (unsigned short)25910,      (unsigned short)29887, 
        (unsigned short)35912,      (unsigned short)40385,      (unsigned short)44890,      (unsigned short)48851, 
        (unsigned short)51820,      (unsigned short)56293,      (unsigned short)59774,      (unsigned short)63735, 
        (unsigned short)4225,      (unsigned short)264,      (unsigned short)13203,      (unsigned short)8730, 
        (unsigned short)22181,      (unsigned short)18220,      (unsigned short)30135,      (unsigned short)25662, 
        (unsigned short)40137,      (unsigned short)36160,      (unsigned short)49115,      (unsigned short)44626, 
        (unsigned short)56045,      (unsigned short)52068,      (unsigned short)63999,      (unsigned short)59510, 
        (unsigned short)8450,      (unsigned short)12427,      (unsigned short)528,      (unsigned short)5017, 
        (unsigned short)26406,      (unsigned short)30383,      (unsigned short)17460,      (unsigned short)21949, 
        (unsigned short)44362,      (unsigned short)48323,      (unsigned short)36440,      (unsigned short)40913, 
        (unsigned short)60270,      (unsigned short)64231,      (unsigned short)51324,      (unsigned short)55797, 
        (unsigned short)12675,      (unsigned short)8202,      (unsigned short)4753,      (unsigned short)792, 
        (unsigned short)30631,      (unsigned short)26158,      (unsigned short)21685,      (unsigned short)17724, 
        (unsigned short)48587,      (unsigned short)44098,      (unsigned short)40665,      (unsigned short)36688, 
        (unsigned short)64495,      (unsigned short)60006,      (unsigned short)55549,      (unsigned short)51572, 
        (unsigned short)16900,      (unsigned short)21389,      (unsigned short)24854,      (unsigned short)28831, 
        (unsigned short)1056,      (unsigned short)5545,      (unsigned short)10034,      (unsigned short)14011, 
        (unsigned short)52812,      (unsigned short)57285,      (unsigned short)60766,      (unsigned short)64727, 
        (unsigned short)34920,      (unsigned short)39393,      (unsigned short)43898,      (unsigned short)47859, 
        (unsigned short)21125,      (unsigned short)17164,      (unsigned short)29079,      (unsigned short)24606, 
        (unsigned short)5281,      (unsigned short)1320,      (unsigned short)14259,      (unsigned short)9786, 
        (unsigned short)57037,      (unsigned short)53060,      (unsigned short)64991,      (unsigned short)60502, 
        (unsigned short)39145,      (unsigned short)35168,      (unsigned short)48123,      (unsigned short)43634, 
        (unsigned short)25350,      (unsigned short)29327,      (unsigned short)16404,      (unsigned short)20893, 
        (unsigned short)9506,      (unsigned short)13483,      (unsigned short)1584,      (unsigned short)6073, 
        (unsigned short)61262,      (unsigned short)65223,      (unsigned short)52316,      (unsigned short)56789, 
        (unsigned short)43370,      (unsigned short)47331,      (unsigned short)35448,      (unsigned short)39921, 
        (unsigned short)29575,      (unsigned short)25102,      (unsigned short)20629,      (unsigned short)16668, 
        (unsigned short)13731,      (unsigned short)9258,      (unsigned short)5809,      (unsigned short)1848, 
        (unsigned short)65487,      (unsigned short)60998,      (unsigned short)56541,      (unsigned short)52564, 
        (unsigned short)47595,      (unsigned short)43106,      (unsigned short)39673,      (unsigned short)35696, 
        (unsigned short)33800,      (unsigned short)38273,      (unsigned short)42778,      (unsigned short)46739, 
        (unsigned short)49708,      (unsigned short)54181,      (unsigned short)57662,      (unsigned short)61623, 
        (unsigned short)2112,      (unsigned short)6601,      (unsigned short)11090,      (unsigned short)15067, 
        (unsigned short)20068,      (unsigned short)24557,      (unsigned short)28022,      (unsigned short)31999, 
        (unsigned short)38025,      (unsigned short)34048,      (unsigned short)47003,      (unsigned short)42514, 
        (unsigned short)53933,      (unsigned short)49956,      (unsigned short)61887,      (unsigned short)57398, 
        (unsigned short)6337,      (unsigned short)2376,      (unsigned short)15315,      (unsigned short)10842, 
        (unsigned short)24293,      (unsigned short)20332,      (unsigned short)32247,      (unsigned short)27774, 
        (unsigned short)42250,      (unsigned short)46211,      (unsigned short)34328,      (unsigned short)38801, 
        (unsigned short)58158,      (unsigned short)62119,      (unsigned short)49212,      (unsigned short)53685, 
        (unsigned short)10562,      (unsigned short)14539,      (unsigned short)2640,      (unsigned short)7129, 
        (unsigned short)28518,      (unsigned short)32495,      (unsigned short)19572,      (unsigned short)24061, 
        (unsigned short)46475,      (unsigned short)41986,      (unsigned short)38553,      (unsigned short)34576, 
        (unsigned short)62383,      (unsigned short)57894,      (unsigned short)53437,      (unsigned short)49460, 
        (unsigned short)14787,      (unsigned short)10314,      (unsigned short)6865,      (unsigned short)2904, 
        (unsigned short)32743,      (unsigned short)28270,      (unsigned short)23797,      (unsigned short)19836, 
        (unsigned short)50700,      (unsigned short)55173,      (unsigned short)58654,      (unsigned short)62615, 
        (unsigned short)32808,      (unsigned short)37281,      (unsigned short)41786,      (unsigned short)45747, 
        (unsigned short)19012,      (unsigned short)23501,      (unsigned short)26966,      (unsigned short)30943, 
        (unsigned short)3168,      (unsigned short)7657,      (unsigned short)12146,      (unsigned short)16123, 
        (unsigned short)54925,      (unsigned short)50948,      (unsigned short)62879,      (unsigned short)58390, 
        (unsigned short)37033,      (unsigned short)33056,      (unsigned short)46011,      (unsigned short)41522, 
        (unsigned short)23237,      (unsigned short)19276,      (unsigned short)31191,      (unsigned short)26718, 
        (unsigned short)7393,      (unsigned short)3432,      (unsigned short)16371,      (unsigned short)11898, 
        (unsigned short)59150,      (unsigned short)63111,      (unsigned short)50204,      (unsigned short)54677, 
        (unsigned short)41258,      (unsigned short)45219,      (unsigned short)33336,      (unsigned short)37809, 
        (unsigned short)27462,      (unsigned short)31439,      (unsigned short)18516,      (unsigned short)23005, 
        (unsigned short)11618,      (unsigned short)15595,      (unsigned short)3696,      (unsigned short)8185, 
        (unsigned short)63375,      (unsigned short)58886,      (unsigned short)54429,      (unsigned short)50452, 
        (unsigned short)45483,      (unsigned short)40994,      (unsigned short)37561,      (unsigned short)33584, 
        (unsigned short)31687,      (unsigned short)27214,      (unsigned short)22741,      (unsigned short)18780, 
        (unsigned short)15843,      (unsigned short)11370,      (unsigned short)7921,      (unsigned short)3960};
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_name(unsigned char *bin_hdr ) ;
#line 21
static int dd_filehdr(struct fileHdr___3 *f , struct fileCHdr *cf , int skip ) ;
#line 22
static void dd_cfilehdr(struct fileCHdr *f ) ;
#line 23
static int dd_valid(int dmethod , int rmethod ) ;
#line 24
static int dd_valid1(int method ) ;
#line 26
static unsigned long dd_checksum(unsigned long init , char *buffer___3 , unsigned long length___0 ) ;
#line 27
static void dd_chksum(struct fileHdr___3 hdr , unsigned char *data ) ;
#line 28
static unsigned long dd_checkor(unsigned long init , char *buffer___3 , unsigned long length___0 ) ;
#line 29
static void dd_do_delta(char *out_ptr___0 , unsigned long nbytes , int kind ) ;
#line 30
static void dd_delta(char *out_ptr___0 , unsigned long nbytes ) ;
#line 31
static void dd_delta3(char *out_ptr___0 , unsigned long nbytes ) ;
#line 32
static void dd_copy(struct fileHdr___3 hdr , unsigned char *data ) ;
#line 33
static void dd_copyfile(unsigned long obytes , unsigned char *data ) ;
#line 34
static void dd_expand(struct fileCHdr hdr , unsigned char *data ) ;
#line 35
static void dd_expandfile(unsigned long obytes , unsigned long ibytes , int method ,
                          int kind , unsigned char *data , unsigned long chksum ) ;
#line 36
static void dd_nocomp(unsigned long obytes , unsigned char *data ) ;
#line 37
static void dd_lzc(unsigned long ibytes , unsigned long obytes , unsigned char *data ,
                   int mb , unsigned long chksum , unsigned long ckinit ) ;
#line 39
static void dd_rle(unsigned long ibytes , unsigned char *data ) ;
#line 43
static void dd_lzss(unsigned char *data , unsigned long chksum ) ;
#line 44
static int dd_getbits(int n ) ;
#line 46
static void dd_cpt_compat(unsigned long ibytes , unsigned long obytes , unsigned char *data ,
                          int sub_method , unsigned long chksum ) ;
#line 65 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned char *dd_archive  ;
#line 66 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned char *dd_data_ptr  ;
#line 67 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_archive_size  ;
#line 68 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_max_archive_size  ;
#line 69 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned char *dd_dirst  ;
#line 70 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_dirstptr  ;
#line 71 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_dirstmax  ;
#line 72 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_xor  ;
#line 73 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static long dd_bitbuf  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_bitcount  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned char *dd_bitptr  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static char dd_LZbuff[2048]  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
void dd_file(unsigned char *bin_hdr ) 
{ 
  unsigned long data_size___0 ;
  int i ;
  struct fileCHdr cf ;
  char ftype[5] ;
  char fauth[5] ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
  {
#line 86
  updcrc = & binhex_updcrc;
#line 87
  crcinit = binhex_crcinit;
#line 88
  dd_name(bin_hdr);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 128)) {
#line 89
      goto while_break;
    }
#line 90
    info[i] = (char )*(bin_hdr + i);
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  transname((info + 1) + 1, text, (int )info[1] & 255);
#line 93
  data_size___0 = get4(info + 83);
  }
#line 94
  if (data_size___0 > (unsigned long )dd_max_archive_size) {
#line 95
    if (dd_max_archive_size == 0) {
      {
#line 96
      tmp = malloc((unsigned int )data_size___0);
#line 96
      dd_archive = (unsigned char *)tmp;
      }
    } else {
      {
#line 98
      tmp___0 = realloc((char *)dd_archive, (unsigned int )data_size___0);
#line 98
      dd_archive = (unsigned char *)tmp___0;
      }
    }
#line 101
    dd_max_archive_size = (int )data_size___0;
#line 102
    if ((unsigned long )dd_archive == (unsigned long )((void *)0)) {
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.\n");
#line 104
      exit(1);
      }
    }
  }
  {
#line 107
  dd_archive_size = (int )data_size___0;
#line 108
  tmp___1 = fread((void */* __restrict  */)((char *)dd_archive), (size_t )1, (size_t )((int )data_size___0),
                  (FILE */* __restrict  */)infp);
  }
#line 108
  if (tmp___1 != data_size___0) {
    {
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF\n");
#line 113
    exit(1);
    }
  }
  {
#line 115
  dd_data_ptr = dd_archive;
#line 116
  dd_cfilehdr(& cf);
#line 117
  write_it = 1;
  }
#line 118
  if (list) {
    {
#line 119
    do_indent(indent);
#line 120
    transname(info + 65, ftype, 4);
#line 121
    transname(info + 69, fauth, 4);
#line 122
    tmp___2 = get4(info + 87);
#line 122
    tmp___3 = get4(info + 83);
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )tmp___3, (long )tmp___2);
    }
#line 126
    if (info_only) {
#line 127
      write_it = 0;
    }
#line 129
    if (query) {
      {
#line 130
      write_it = do_query();
      }
    } else {
      {
#line 132
      fputc('\n', stderr);
      }
    }
  }
  {
#line 135
  tmp___4 = dd_valid((int )cf.datamethod, (int )cf.rsrcmethod);
  }
#line 135
  if (! tmp___4) {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnimplemented method found: %d %d\n",
            (int )cf.datamethod, (int )cf.rsrcmethod);
    }
#line 141
    return;
  }
#line 144
  if (write_it) {
    {
#line 145
    define_name(text);
    }
  }
#line 147
  if (write_it) {
    {
#line 148
    dd_expand(cf, dd_data_ptr);
    }
  } else
#line 147
  if (list) {
    {
#line 148
    dd_expand(cf, dd_data_ptr);
    }
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
void dd_arch(unsigned char *bin_hdr ) 
{ 
  unsigned long data_size___0 ;
  unsigned long crc___0 ;
  unsigned long filecrc ;
  struct fileHdr___3 f ;
  struct fileCHdr cf ;
  char locname[64] ;
  int i ;
  int nlength ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 162
  updcrc = & binhex_updcrc;
#line 163
  crcinit = binhex_crcinit;
#line 164
  data_size___0 = get4((char *)bin_hdr + 83);
  }
#line 165
  if (data_size___0 > (unsigned long )dd_max_archive_size) {
#line 166
    if (dd_max_archive_size == 0) {
      {
#line 167
      tmp = malloc((unsigned int )data_size___0);
#line 167
      dd_archive = (unsigned char *)tmp;
      }
    } else {
      {
#line 169
      tmp___0 = realloc((char *)dd_archive, (unsigned int )data_size___0);
#line 169
      dd_archive = (unsigned char *)tmp___0;
      }
    }
#line 172
    dd_max_archive_size = (int )data_size___0;
  }
  {
#line 174
  dd_archive_size = (int )data_size___0;
#line 175
  tmp___1 = fread((void */* __restrict  */)((char *)dd_archive), (size_t )1, (size_t )((int )data_size___0),
                  (FILE */* __restrict  */)infp);
  }
#line 175
  if (tmp___1 != data_size___0) {
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.\n");
#line 177
    exit(1);
    }
  }
  {
#line 179
  dd_name(bin_hdr);
#line 180
  nlength = (int )*(bin_hdr + 1);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 128)) {
#line 181
      goto while_break;
    }
#line 182
    info[i] = (char)0;
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  info[1] = (char )nlength;
#line 185
  i = 1;
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! (i <= nlength)) {
#line 185
      goto while_break___0;
    }
#line 186
    info[1 + i] = (char )*(bin_hdr + (1 + i));
#line 185
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 188
  transname((info + 1) + 1, text, nlength);
#line 189
  strcpy(locname, text);
  }
#line 190
  if (list) {
    {
#line 191
    do_indent(indent);
#line 192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
            text);
    }
#line 193
    if (query) {
      {
#line 194
      tmp___2 = do_query();
      }
#line 194
      if (! tmp___2) {
#line 195
        return;
      }
    } else {
      {
#line 198
      fputc('\n', stderr);
      }
    }
#line 200
    indent ++;
  }
#line 202
  if (! info_only) {
    {
#line 203
    do_mkdir(text, info);
    }
  }
  {
#line 206
  tmp___3 = strncmp((char *)dd_archive, "DDAR", 4);
  }
#line 206
  if (tmp___3) {
    {
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic archive header error\n");
#line 211
    exit(1);
    }
  }
  {
#line 213
  crc___0 = (*updcrc)(crcinit, dd_archive, 76);
#line 214
  filecrc = get2((char *)dd_archive + 76);
  }
#line 215
  if (crc___0 != filecrc) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header CRC mismatch: got 0x%02x, need 0x%02x\n",
            (int )crc___0, (int )filecrc);
#line 221
    exit(1);
    }
  }
#line 223
  dd_data_ptr = dd_archive + 78;
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )dd_data_ptr < (unsigned long )(dd_archive + data_size___0))) {
#line 224
      goto while_break___1;
    }
    {
#line 225
    tmp___4 = dd_filehdr(& f, & cf, dir_skip);
    }
    {
#line 226
    if (tmp___4 == 0) {
#line 226
      goto case_0;
    }
#line 229
    if (tmp___4 == 4) {
#line 229
      goto case_4;
    }
#line 232
    if (tmp___4 == 1) {
#line 232
      goto case_1;
    }
#line 236
    if (tmp___4 == 2) {
#line 236
      goto case_2;
    }
#line 259
    if (tmp___4 == 3) {
#line 259
      goto case_3;
    }
#line 225
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 227
    dd_chksum(f, dd_data_ptr);
#line 228
    dd_expand(cf, dd_data_ptr);
    }
    case_4: /* CIL Label */ 
#line 230
    dd_data_ptr += f.dataLength - 84UL;
#line 231
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 233
    dd_copy(f, dd_data_ptr);
#line 234
    dd_data_ptr += f.dataLength + f.rsrcLength;
    }
#line 235
    goto switch_break;
    case_2: /* CIL Label */ 
#line 237
    if (write_it) {
#line 237
      goto _L;
    } else
#line 237
    if (info_only) {
      _L: /* CIL Label */ 
#line 238
      if (write_it) {
        {
#line 239
        do_mkdir(text, info);
        }
      }
#line 241
      if (dd_dirstptr == dd_dirstmax) {
#line 242
        if (dd_dirstmax == 0) {
          {
#line 243
          tmp___5 = malloc(64);
#line 243
          dd_dirst = (unsigned char *)tmp___5;
          }
        } else {
          {
#line 245
          tmp___6 = realloc((char *)dd_dirst, (unsigned int )dd_dirstmax + 64U);
#line 245
          dd_dirst = (unsigned char *)tmp___6;
          }
        }
#line 248
        dd_dirstmax += 64;
      }
#line 250
      i = 0;
      {
#line 250
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 250
        if (! (i < 64)) {
#line 250
          goto while_break___2;
        }
#line 251
        *(dd_dirst + (dd_dirstptr + i)) = (unsigned char )text[i];
#line 250
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 253
      dd_dirst += 64;
#line 254
      indent ++;
    } else {
#line 256
      dir_skip ++;
    }
#line 258
    goto switch_break;
    case_3: /* CIL Label */ 
#line 260
    if (dir_skip) {
#line 261
      dir_skip --;
    } else {
#line 263
      dd_dirst -= 64;
#line 264
      indent --;
#line 265
      if (list) {
        {
#line 266
        do_indent(indent);
#line 267
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
                dd_dirst + dd_dirstptr);
        }
      }
#line 270
      if (! info_only) {
        {
#line 271
        enddir();
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 276
  if (! info_only) {
    {
#line 277
    enddir();
    }
  }
#line 279
  if (list) {
    {
#line 280
    indent --;
#line 281
    do_indent(indent);
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"leaving folder \"%s\"\n",
            locname);
    }
  }
#line 284
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_name(unsigned char *bin_hdr ) 
{ 
  int nlength ;
  unsigned char *extptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 292
  nlength = (int )*(bin_hdr + 1) & 255;
#line 293
  extptr = ((bin_hdr + 1) + nlength) - 3;
#line 294
  tmp = strncmp((char *)extptr, ".sea", 4);
  }
#line 294
  if (tmp) {
    {
#line 294
    tmp___0 = strncmp((char *)extptr, ".Sea", 4);
    }
#line 294
    if (tmp___0) {
      {
#line 294
      tmp___1 = strncmp((char *)extptr, ".SEA", 4);
      }
#line 294
      if (! tmp___1) {
        _L: /* CIL Label */ 
#line 297
        nlength -= 4;
#line 298
        *(extptr + 0) = (unsigned char)0;
#line 299
        *(extptr + 1) = (unsigned char)0;
#line 300
        *(extptr + 2) = (unsigned char)0;
#line 301
        *(extptr + 3) = (unsigned char)0;
#line 302
        *(bin_hdr + 1) = (unsigned char )nlength;
#line 303
        return;
      }
    } else {
#line 294
      goto _L;
    }
  } else {
#line 294
    goto _L;
  }
  {
#line 305
  extptr ++;
#line 306
  tmp___2 = strncmp((char *)extptr, ".dd", 3);
  }
#line 306
  if (! tmp___2) {
#line 307
    nlength -= 3;
#line 308
    *(extptr + 0) = (unsigned char)0;
#line 309
    *(extptr + 1) = (unsigned char)0;
#line 310
    *(extptr + 2) = (unsigned char)0;
#line 311
    *(bin_hdr + 1) = (unsigned char )nlength;
#line 312
    return;
  }
#line 314
  if (nlength < 31) {
#line 315
    nlength ++;
  }
#line 317
  *(bin_hdr + (1 + nlength)) = (unsigned char)165;
#line 318
  *(bin_hdr + 1) = (unsigned char )nlength;
#line 319
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_filehdr(struct fileHdr___3 *f , struct fileCHdr *cf , int skip ) 
{ 
  register int i ;
  unsigned long crc___0 ;
  int n ;
  int to_uncompress ;
  unsigned char *hdr ;
  char ftype[5] ;
  char fauth[5] ;
  unsigned long datalength ;
  unsigned long rsrclength ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 333
  to_uncompress = 1;
#line 334
  hdr = dd_data_ptr;
#line 335
  dd_data_ptr += 124;
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < 128)) {
#line 336
      goto while_break;
    }
#line 337
    info[i] = (char )'\000';
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  crc___0 = crcinit;
#line 340
  crc___0 = (*updcrc)(crc___0, hdr, 122);
#line 342
  tmp = get2((char *)hdr + 122);
#line 342
  f->hdrcrc = (unsigned short )tmp;
  }
#line 343
  if ((unsigned long )f->hdrcrc != crc___0) {
    {
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header CRC mismatch: got 0x%04x, need 0x%04x\n",
            (int )f->hdrcrc & 65535, (int )crc___0);
#line 349
    exit(1);
    }
  }
#line 352
  n = (int )*(hdr + 8) & 255;
#line 353
  if (n > 63) {
#line 354
    n = 63;
  }
  {
#line 356
  info[1] = (char )n;
#line 357
  copy((info + 1) + 1, ((char *)hdr + 8) + 1, n);
#line 358
  transname(((char *)hdr + 8) + 1, text, n);
  }
#line 360
  if (! *(hdr + 72)) {
    {
#line 361
    tmp___0 = get2((char *)hdr + 118);
#line 361
    f->datacrc = (unsigned short )tmp___0;
#line 362
    tmp___1 = get2((char *)hdr + 120);
#line 362
    f->rsrccrc = (unsigned short )tmp___1;
#line 363
    f->dataLength = get4((char *)hdr + 74);
#line 364
    f->rsrcLength = get4((char *)hdr + 78);
#line 365
    copy(info + 83, (char *)hdr + 74, 4);
#line 366
    copy(info + 87, (char *)hdr + 78, 4);
#line 367
    copy(info + 91, (char *)hdr + 82, 4);
#line 368
    copy(info + 95, (char *)hdr + 86, 4);
#line 369
    copy(info + 65, (char *)hdr + 90, 4);
#line 370
    copy(info + 69, (char *)hdr + 94, 4);
#line 371
    copy(info + 73, (char *)hdr + 98, 2);
    }
  }
#line 374
  if (*(hdr + 72)) {
#line 375
    to_uncompress = 2;
  } else
#line 376
  if (*(hdr + 73)) {
#line 377
    to_uncompress = 3;
  } else
#line 378
  if (! no_dd) {
#line 378
    if (((int )*(hdr + 98) & 128) == 0) {
      {
#line 379
      dd_cfilehdr(cf);
#line 380
      to_uncompress = 0;
#line 381
      datalength = cf->dataLength;
#line 382
      rsrclength = cf->rsrcLength;
      }
    } else {
#line 384
      datalength = f->dataLength;
#line 385
      rsrclength = f->rsrcLength;
    }
  } else {
#line 384
    datalength = f->dataLength;
#line 385
    rsrclength = f->rsrcLength;
  }
#line 387
  *(hdr + 98) = (unsigned char )((int )*(hdr + 98) & 127);
#line 388
  write_it = ! skip;
#line 389
  if (list) {
#line 389
    if (! skip) {
#line 390
      if (to_uncompress != 3) {
        {
#line 391
        do_indent(indent);
        }
      }
#line 393
      if (to_uncompress == 2) {
        {
#line 394
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"folder=\"%s\"",
                text);
        }
      } else
#line 395
      if (to_uncompress != 3) {
        {
#line 396
        transname(info + 65, ftype, 4);
#line 397
        transname(info + 69, fauth, 4);
#line 398
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
                text, ftype, fauth, (long )datalength, (long )rsrclength);
        }
      }
#line 402
      if (info_only) {
#line 403
        write_it = 0;
      }
#line 405
      if (to_uncompress != 3) {
#line 406
        if (query) {
          {
#line 407
          write_it = do_query();
          }
        } else {
          {
#line 409
          fputc('\n', stderr);
          }
        }
      }
#line 412
      if (to_uncompress == 0) {
        {
#line 413
        tmp___2 = dd_valid((int )cf->datamethod, (int )cf->rsrcmethod);
        }
#line 413
        if (! tmp___2) {
          {
#line 414
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUnimplemented method found: %d %d\n",
                  (int )cf->datamethod, (int )cf->rsrcmethod);
          }
#line 419
          return (4);
        }
      }
    }
  }
#line 424
  if (write_it) {
    {
#line 425
    define_name(text);
    }
  }
#line 427
  return (to_uncompress);
}
}
#line 430 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_cfilehdr(struct fileCHdr *f ) 
{ 
  unsigned long crc___0 ;
  unsigned char *hdr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 436
  hdr = dd_data_ptr;
#line 437
  dd_data_ptr += 84;
#line 438
  crc___0 = crcinit;
#line 439
  crc___0 = (*updcrc)(crc___0, hdr, 82);
#line 441
  tmp = get2((char *)hdr + 82);
#line 441
  f->hdrcrc = (unsigned short )tmp;
  }
#line 442
  if ((unsigned long )f->hdrcrc != crc___0) {
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header CRC mismatch: got 0x%04x, need 0x%04x\n",
            (int )f->hdrcrc & 65535, (int )crc___0);
#line 448
    exit(1);
    }
  }
  {
#line 451
  f->dataLength = get4((char *)hdr + 4);
#line 452
  f->dataCLength = get4((char *)hdr + 8);
#line 453
  f->rsrcLength = get4((char *)hdr + 12);
#line 454
  f->rsrcCLength = get4((char *)hdr + 16);
#line 455
  f->datamethod = *(hdr + 20);
#line 456
  f->rsrcmethod = *(hdr + 21);
#line 457
  tmp___0 = get2((char *)hdr + 48);
#line 457
  f->datacrc = (unsigned short )tmp___0;
#line 458
  tmp___1 = get2((char *)hdr + 50);
#line 458
  f->rsrccrc = (unsigned short )tmp___1;
#line 459
  tmp___2 = get2((char *)hdr + 54);
#line 459
  f->datainfo = (unsigned short )tmp___2;
#line 460
  tmp___3 = get2((char *)hdr + 56);
#line 460
  f->rsrcinfo = (unsigned short )tmp___3;
#line 461
  tmp___4 = get2((char *)hdr + 78);
#line 461
  f->datacrc2 = (unsigned short )tmp___4;
#line 462
  tmp___5 = get2((char *)hdr + 80);
#line 462
  f->rsrccrc2 = (unsigned short )tmp___5;
#line 463
  f->info1 = *(hdr + 22);
#line 464
  f->info2 = *(hdr + 52);
#line 465
  copy(info + 83, (char *)hdr + 4, 4);
#line 466
  copy(info + 87, (char *)hdr + 12, 4);
#line 467
  copy(info + 91, (char *)hdr + 28, 4);
#line 468
  copy(info + 95, (char *)hdr + 24, 4);
#line 469
  copy(info + 65, (char *)hdr + 32, 4);
#line 470
  copy(info + 69, (char *)hdr + 36, 4);
#line 471
  copy(info + 73, (char *)hdr + 40, 2);
  }
#line 472
  if ((int )f->info1 >= 42) {
#line 472
    if (((int )f->info2 & 128) == 0) {
#line 473
      dd_xor = 90;
    } else {
#line 475
      dd_xor = 0;
    }
  } else {
#line 475
    dd_xor = 0;
  }
#line 477
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_valid(int dmethod , int rmethod ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 482
  tmp = dd_valid1(dmethod);
#line 482
  tmp___0 = dd_valid1(rmethod);
  }
#line 482
  return (tmp | tmp___0);
}
}
#line 485 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_valid1(int method ) 
{ 


  {
  {
#line 498
  if (method == 8) {
#line 498
    goto case_8;
  }
#line 498
  if (method == 7) {
#line 498
    goto case_8;
  }
#line 498
  if (method == 3) {
#line 498
    goto case_8;
  }
#line 498
  if (method == 1) {
#line 498
    goto case_8;
  }
#line 498
  if (method == 0) {
#line 498
    goto case_8;
  }
#line 488
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 499
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 501
  return (0);
}
}
#line 517 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned long dd_checksum(unsigned long init , char *buffer___3 , unsigned long length___0 ) 
{ 
  int i ;
  unsigned long cks ;
  char *tmp ;

  {
#line 525
  cks = init;
#line 526
  i = 0;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! ((unsigned long )i < length___0)) {
#line 526
      goto while_break;
    }
#line 527
    tmp = buffer___3;
#line 527
    buffer___3 ++;
#line 527
    cks += (unsigned long )((int )*tmp & 255);
#line 526
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  return (cks & 65535UL);
}
}
#line 532 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_chksum(struct fileHdr___3 hdr , unsigned char *data ) 
{ 
  unsigned long cks ;

  {
#line 538
  if (write_it) {
    {
#line 539
    cks = dd_checksum(crcinit, (char *)data - 84, hdr.dataLength);
    }
#line 541
    if ((unsigned long )hdr.datacrc != cks) {
      {
#line 542
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on compressed file: need 0x%04x, got 0x%04x\n",
              (int )hdr.datacrc, (int )cks);
#line 548
      exit(1);
      }
    }
  }
#line 551
  return;
}
}
#line 553 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static unsigned long dd_checkor(unsigned long init , char *buffer___3 , unsigned long length___0 ) 
{ 
  int i ;
  unsigned long cks ;
  char *tmp ;

  {
#line 561
  cks = init;
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! ((unsigned long )i < length___0)) {
#line 562
      goto while_break;
    }
#line 563
    tmp = buffer___3;
#line 563
    buffer___3 ++;
#line 563
    cks ^= (unsigned long )((int )*tmp & 255);
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  return (cks & 65535UL);
}
}
#line 568 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_do_delta(char *out_ptr___0 , unsigned long nbytes , int kind ) 
{ 


  {
  {
#line 574
  if (kind == 0) {
#line 574
    goto case_0;
  }
#line 576
  if (kind == 1) {
#line 576
    goto case_1;
  }
#line 579
  if (kind == 2) {
#line 579
    goto case_2;
  }
#line 582
  goto switch_default;
  case_0: /* CIL Label */ 
#line 575
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 577
  dd_delta(out_ptr___0, nbytes);
  }
#line 578
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 580
  dd_delta3(out_ptr___0, nbytes);
  }
#line 581
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 583
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal kind value found: %d\n",
          kind);
#line 587
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 589
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_delta(char *out_ptr___0 , unsigned long nbytes ) 
{ 
  int i ;
  int sum ;
  char *tmp ;

  {
#line 595
  sum = 0;
#line 597
  i = 0;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )i < nbytes)) {
#line 597
      goto while_break;
    }
#line 598
    sum = (sum + (int )*out_ptr___0) & 255;
#line 599
    tmp = out_ptr___0;
#line 599
    out_ptr___0 ++;
#line 599
    *tmp = (char )sum;
#line 597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_delta3(char *out_ptr___0 , unsigned long nbytes ) 
{ 
  int i ;
  int sum1 ;
  int sum2 ;
  int sum3 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 607
  sum1 = 0;
#line 607
  sum2 = 0;
#line 607
  sum3 = 0;
#line 609
  i = 0;
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! ((unsigned long )i < nbytes)) {
#line 609
      goto while_break;
    }
#line 610
    sum1 = (sum1 + (int )*out_ptr___0) & 255;
#line 611
    tmp = out_ptr___0;
#line 611
    out_ptr___0 ++;
#line 611
    *tmp = (char )sum1;
#line 612
    if ((unsigned long )i < nbytes - 1UL) {
#line 613
      sum2 = (sum2 + (int )*out_ptr___0) & 255;
#line 614
      tmp___0 = out_ptr___0;
#line 614
      out_ptr___0 ++;
#line 614
      *tmp___0 = (char )sum2;
#line 615
      if ((unsigned long )i < nbytes) {
#line 616
        sum3 = (sum3 + (int )*out_ptr___0) & 255;
#line 617
        tmp___1 = out_ptr___0;
#line 617
        out_ptr___0 ++;
#line 617
        *tmp___1 = (char )sum3;
      }
    }
#line 609
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 626 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_copy(struct fileHdr___3 hdr , unsigned char *data ) 
{ 
  unsigned long cks ;

  {
#line 632
  if (write_it) {
    {
#line 633
    start_info(info, hdr.rsrcLength, hdr.dataLength);
    }
  }
#line 635
  if (verbose) {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tNo compression");
    }
  }
#line 638
  if (write_it) {
    {
#line 639
    start_data();
    }
  }
  {
#line 641
  dd_copyfile(hdr.dataLength, data);
#line 642
  data += hdr.dataLength;
  }
#line 643
  if (write_it) {
    {
#line 644
    cks = dd_checksum(crcinit, out_buffer, hdr.dataLength);
    }
#line 645
    if ((unsigned long )hdr.datacrc != cks) {
      {
#line 646
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on data fork: need 0x%04x, got 0x%04x\n",
              (int )hdr.datacrc, (int )cks);
#line 652
      exit(1);
      }
    }
  }
#line 655
  if (write_it) {
    {
#line 656
    start_rsrc();
    }
  }
  {
#line 658
  dd_copyfile(hdr.rsrcLength, data);
#line 659
  data += hdr.rsrcLength;
  }
#line 660
  if (write_it) {
    {
#line 661
    cks = dd_checksum(crcinit, out_buffer, hdr.rsrcLength);
    }
#line 662
    if ((unsigned long )hdr.rsrccrc != cks) {
      {
#line 663
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on resource fork: need 0x%04x, got 0x%04x\n",
              (int )hdr.rsrccrc, (int )cks);
#line 669
      exit(1);
      }
    }
    {
#line 671
    end_file();
    }
  }
#line 673
  if (verbose) {
    {
#line 674
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 676
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_copyfile(unsigned long obytes , unsigned char *data ) 
{ 


  {
#line 682
  if (obytes == 0UL) {
#line 683
    return;
  }
#line 685
  if (write_it) {
    {
#line 686
    copy(out_ptr, (char *)data, (int )obytes);
    }
  }
#line 688
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_expand(struct fileCHdr hdr , unsigned char *data ) 
{ 
  unsigned long cks ;
  char *out_buf ;

  {
#line 700
  if (write_it) {
    {
#line 701
    start_info(info, hdr.rsrcLength, hdr.dataLength);
    }
  }
#line 703
  if (verbose) {
    {
#line 704
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tData: ");
    }
  }
#line 706
  if (write_it) {
    {
#line 707
    start_data();
    }
  }
  {
#line 709
  out_buf = out_buffer;
#line 710
  dd_expandfile(hdr.dataLength, hdr.dataCLength, (int )hdr.datamethod, (int )hdr.datainfo,
                data, (unsigned long )hdr.datacrc);
#line 712
  data += hdr.dataCLength;
  }
#line 713
  if (write_it) {
#line 714
    if ((int )hdr.info2 & 64) {
#line 714
      if (hdr.dataLength != 0UL) {
        {
#line 715
        cks = arc_updcrc(crcinit, (unsigned char *)out_buf, (int )hdr.dataLength);
        }
#line 717
        if (cks != (unsigned long )hdr.datacrc2) {
          {
#line 718
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on data fork: need 0x%04x, got 0x%04x\n",
                  (int )hdr.datacrc2, (int )cks);
#line 724
          exit(1);
          }
        }
      }
    }
  }
#line 728
  if (verbose) {
    {
#line 729
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Rsrc: ");
    }
  }
#line 731
  if (write_it) {
    {
#line 732
    start_rsrc();
    }
  }
  {
#line 734
  out_buf = out_buffer;
#line 735
  dd_expandfile(hdr.rsrcLength, hdr.rsrcCLength, (int )hdr.rsrcmethod, (int )hdr.rsrcinfo,
                data, (unsigned long )hdr.rsrccrc);
#line 737
  data += hdr.rsrcCLength;
  }
#line 738
  if (write_it) {
#line 739
    if ((int )hdr.info2 & 64) {
#line 739
      if (hdr.rsrcLength != 0UL) {
        {
#line 740
        cks = arc_updcrc(crcinit, (unsigned char *)out_buf, (int )hdr.rsrcLength);
        }
#line 742
        if (cks != (unsigned long )hdr.rsrccrc2) {
          {
#line 743
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on resource fork: need 0x%04x, got 0x%04x\n",
                  (int )hdr.rsrccrc2, (int )cks);
#line 749
          exit(1);
          }
        }
      }
    }
    {
#line 752
    end_file();
    }
  }
#line 754
  if (verbose) {
    {
#line 755
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 757
  return;
}
}
#line 759 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_expandfile(unsigned long obytes , unsigned long ibytes , int method ,
                          int kind , unsigned char *data , unsigned long chksum ) 
{ 
  int sub_method ;
  int m1 ;
  int m2 ;
  char *optr ;
  unsigned long cksinit ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 765
  optr = out_ptr;
#line 768
  if (obytes == 0UL) {
#line 769
    if (verbose) {
      {
#line 770
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
      }
    }
#line 772
    return;
  }
  {
#line 775
  if ((method & 127) == 0) {
#line 775
    goto case_0;
  }
#line 783
  if ((method & 127) == 1) {
#line 783
    goto case_1;
  }
#line 798
  if ((method & 127) == 3) {
#line 798
    goto case_3;
  }
#line 818
  if ((method & 127) == 7) {
#line 818
    goto case_7;
  }
#line 828
  if ((method & 127) == 8) {
#line 828
    goto case_8;
  }
#line 849
  goto switch_default;
  case_0: /* CIL Label */ 
#line 776
  if (verbose) {
    {
#line 777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression");
    }
  }
#line 779
  if (write_it) {
    {
#line 780
    dd_nocomp(obytes, data);
    }
  }
#line 782
  goto switch_break;
  case_1: /* CIL Label */ 
#line 784
  tmp = data;
#line 784
  data ++;
#line 784
  m1 = ((int )*tmp & 255) ^ dd_xor;
#line 785
  tmp___0 = data;
#line 785
  data ++;
#line 785
  m2 = ((int )*tmp___0 & 255) ^ dd_xor;
#line 786
  tmp___1 = data;
#line 786
  data ++;
#line 786
  sub_method = ((int )*tmp___1 & 255) ^ dd_xor;
#line 787
  cksinit = (unsigned long )((m1 + m2) + sub_method);
#line 788
  sub_method &= 31;
#line 789
  if (verbose) {
    {
#line 790
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZC(%d) compressed (%4.1f%%)",
            sub_method, (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 793
  if (write_it) {
    {
#line 794
    dd_lzc(ibytes - 3UL, obytes, data, sub_method, chksum, cksinit);
    }
  }
#line 796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 799
  if (verbose) {
    {
#line 800
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 803
  if (write_it) {
    {
#line 804
    dd_rle(ibytes, data);
    }
  }
#line 806
  goto switch_break;
  case_7: /* CIL Label */ 
#line 819
  if (verbose) {
    {
#line 820
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LZSS compressed (%4.1f%%)",
            (100.0 * (double )ibytes) / (double )obytes);
    }
  }
#line 823
  if (write_it) {
    {
#line 824
    dd_lzss(data, chksum);
    }
  }
#line 826
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 829
  tmp___2 = get2((char *)data);
#line 829
  sub_method = (int )tmp___2;
#line 830
  data += 16;
  }
#line 831
  if (sub_method != 0) {
#line 832
    sub_method = 0;
  } else {
#line 834
    sub_method = 1;
  }
#line 836
  if (verbose) {
#line 837
    if (! sub_method) {
      {
#line 838
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE compressed (%4.1f%%)",
              (100.0 * (double )ibytes) / (double )obytes);
      }
    } else {
      {
#line 841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RLE/LZH compressed (%4.1f%%)",
              (100.0 * (double )ibytes) / (double )obytes);
      }
    }
  }
#line 845
  if (write_it) {
    {
#line 846
    dd_cpt_compat(ibytes, obytes, data, sub_method, chksum);
    }
  }
#line 848
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 850
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 852
  if (write_it) {
    {
#line 853
    dd_do_delta(optr, obytes, kind);
    }
  }
#line 855
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_nocomp(unsigned long obytes , unsigned char *data ) 
{ 


  {
  {
#line 864
  copy(out_ptr, (char *)data, (int )obytes);
  }
#line 865
  return;
}
}
#line 870 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_lzc(unsigned long ibytes , unsigned long obytes , unsigned char *data ,
                   int mb , unsigned long chksum , unsigned long ckinit ) 
{ 
  int i ;
  char *out_buf ;
  unsigned long cks ;
  char *tmp ;

  {
  {
#line 879
  out_buf = out_buffer;
#line 880
  core_compress((char *)data);
#line 881
  de_compress(ibytes, mb);
#line 882
  out_buffer = out_buf;
  }
#line 883
  if (dd_xor != 0) {
#line 884
    i = 0;
    {
#line 884
    while (1) {
      while_continue: /* CIL Label */ ;
#line 884
      if (! ((unsigned long )i < obytes)) {
#line 884
        goto while_break;
      }
#line 885
      tmp = out_buf;
#line 885
      out_buf ++;
#line 885
      *tmp = (char )((int )*tmp ^ dd_xor);
#line 884
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 888
  cks = dd_checksum(ckinit, out_buffer, obytes);
  }
#line 889
  if (chksum != cks) {
    {
#line 890
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on fork: need 0x%04x, got 0x%04x\n",
            (int )chksum, (int )cks);
#line 896
    exit(1);
    }
  }
#line 898
  return;
}
}
#line 904 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_rle(unsigned long ibytes , unsigned char *data ) 
{ 
  int ch ;
  int lastch ;
  int n ;
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    if (! (ibytes != 0UL)) {
#line 910
      goto while_break;
    }
#line 911
    tmp = data;
#line 911
    data ++;
#line 911
    ch = (int )*tmp;
#line 912
    ibytes --;
#line 913
    if (ch == 324) {
#line 914
      tmp___0 = data;
#line 914
      data ++;
#line 914
      n = (int )*tmp___0 - 1;
#line 915
      ibytes --;
#line 916
      if (n < 0) {
#line 917
        tmp___1 = out_ptr;
#line 917
        out_ptr ++;
#line 917
        *tmp___1 = (char)68;
#line 918
        lastch = 324;
      } else {
#line 920
        i = 0;
        {
#line 920
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 920
          if (! (i < n)) {
#line 920
            goto while_break___0;
          }
#line 921
          tmp___2 = out_ptr;
#line 921
          out_ptr ++;
#line 921
          *tmp___2 = (char )lastch;
#line 920
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 925
      tmp___3 = out_ptr;
#line 925
      out_ptr ++;
#line 925
      *tmp___3 = (char )ch;
#line 926
      lastch = ch;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 929
  return;
}
}
#line 945 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_lzss(unsigned char *data , unsigned long chksum ) 
{ 
  int i ;
  int LZptr ;
  int LZbptr ;
  int LZlength ;
  char *optr ;
  unsigned char cks ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned long tmp___11 ;

  {
  {
#line 950
  optr = out_ptr;
#line 953
  tmp = get4((char *)data + 6);
#line 953
  data += tmp;
#line 954
  LZptr = 0;
  }
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 956
    tmp___10 = dd_getbits(1);
    }
#line 956
    if (tmp___10 == 0) {
      {
#line 957
      tmp___0 = out_ptr;
#line 957
      out_ptr ++;
#line 957
      tmp___1 = LZptr;
#line 957
      LZptr ++;
#line 957
      tmp___3 = dd_getbits(8);
#line 957
      tmp___2 = (char )tmp___3;
#line 957
      dd_LZbuff[tmp___1] = tmp___2;
#line 957
      *tmp___0 = tmp___2;
#line 958
      LZptr &= 2047;
      }
    } else {
      {
#line 960
      tmp___4 = dd_getbits(1);
      }
#line 960
      if (tmp___4 == 0) {
        {
#line 961
        LZbptr = dd_getbits(11);
        }
      } else {
        {
#line 963
        LZbptr = dd_getbits(7);
        }
      }
#line 965
      if (LZbptr == 0) {
#line 966
        goto while_break;
      }
      {
#line 968
      LZbptr = (LZptr - LZbptr) & 2047;
#line 969
      LZlength = dd_getbits(2);
      }
#line 970
      if (LZlength == 3) {
        {
#line 971
        tmp___5 = dd_getbits(2);
#line 971
        LZlength += tmp___5;
        }
#line 972
        if (LZlength == 6) {
          {
#line 973
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 974
            i = dd_getbits(4);
#line 975
            LZlength += i;
            }
#line 973
            if (! (i == 15)) {
#line 973
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 979
      LZlength += 2;
#line 980
      i = 0;
      {
#line 980
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 980
        if (! (i < LZlength)) {
#line 980
          goto while_break___1;
        }
#line 981
        tmp___6 = out_ptr;
#line 981
        out_ptr ++;
#line 981
        tmp___7 = LZptr;
#line 981
        LZptr ++;
#line 981
        tmp___9 = LZbptr;
#line 981
        LZbptr ++;
#line 981
        tmp___8 = dd_LZbuff[tmp___9];
#line 981
        dd_LZbuff[tmp___7] = tmp___8;
#line 981
        *tmp___6 = tmp___8;
#line 982
        LZptr &= 2047;
#line 983
        LZbptr &= 2047;
#line 980
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  tmp___11 = dd_checkor(crcinit, optr, (unsigned long )(out_ptr - optr));
#line 987
  cks = (unsigned char )tmp___11;
  }
#line 988
  if (chksum != (unsigned long )cks) {
    {
#line 989
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on fork: need 0x%04x, got 0x%04x\n",
            (int )chksum, (int )cks);
#line 995
    exit(1);
    }
  }
#line 997
  return;
}
}
#line 999 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static int dd_getbits(int n ) 
{ 
  int r ;
  unsigned char *tmp ;

  {
  {
#line 1004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1004
    if (! (dd_bitcount < n)) {
#line 1004
      goto while_break;
    }
#line 1005
    tmp = dd_bitptr;
#line 1005
    dd_bitptr ++;
#line 1005
    dd_bitbuf = (dd_bitbuf << 8) | (long )(~ ((int )*tmp) & 255);
#line 1006
    dd_bitcount += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  dd_bitcount -= n;
#line 1009
  r = (int )(dd_bitbuf >> dd_bitcount);
#line 1010
  dd_bitbuf ^= (long )(r << dd_bitcount);
#line 1011
  return (r);
}
}
#line 1019 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/dd.c"
static void dd_cpt_compat(unsigned long ibytes , unsigned long obytes , unsigned char *data ,
                          int sub_method , unsigned long chksum ) 
{ 
  unsigned long cks ;
  char *optr ;

  {
  {
#line 1025
  optr = out_buffer;
#line 1027
  cpt_wrfile1(data, ibytes, obytes, sub_method, 65520UL);
#line 1028
  cks = arc_updcrc(crcinit, (unsigned char *)optr, (int )obytes);
  }
#line 1029
  if (chksum != cks) {
    {
#line 1030
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checksum error on fork: need 0x%04x, got 0x%04x\n",
            (int )chksum, (int )cks);
#line 1036
    exit(1);
    }
  }
#line 1038
  return;
}
}
#line 16 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/jdw.c"
static void jdw_wrfile(unsigned long rsrcLength , unsigned long dataLength ) ;
#line 17
static void jdw_wrfork(unsigned long length___0 ) ;
#line 18
static void jdw_block(int olength ) ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/jdw.c"
void jdw(unsigned long ibytes ) 
{ 
  char fauth[5] ;
  char ftype[5] ;
  int filel ;
  int i ;
  unsigned int rsrcLength ;
  unsigned int dataLength ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;

  {
  {
#line 27
  set_huffman(0);
#line 28
  i = 0;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < 6)) {
#line 28
      goto while_break;
    }
    {
#line 28
    getb(infp);
#line 28
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  i = 0;
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! (i < 128)) {
#line 29
      goto while_break___0;
    }
#line 30
    info[i] = (char)0;
#line 29
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 32
  i = 0;
  {
#line 32
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 32
    if (! (i < 4)) {
#line 32
      goto while_break___1;
    }
    {
#line 33
    tmp = getb(infp);
#line 33
    info[65 + i] = (char )tmp;
#line 32
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 35
  i = 0;
  {
#line 35
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 35
    if (! (i < 4)) {
#line 35
      goto while_break___2;
    }
    {
#line 36
    tmp___0 = getb(infp);
#line 36
    info[69 + i] = (char )tmp___0;
#line 35
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 38
  i = 0;
  {
#line 38
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 38
    if (! (i < 8)) {
#line 38
      goto while_break___3;
    }
    {
#line 39
    tmp___1 = getb(infp);
#line 39
    info[73 + i] = (char )tmp___1;
#line 38
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 41
    if (! (i < 4)) {
#line 41
      goto while_break___4;
    }
    {
#line 42
    tmp___2 = getb(infp);
#line 42
    info[83 + i] = (char )tmp___2;
#line 41
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 44
    if (! (i < 4)) {
#line 44
      goto while_break___5;
    }
    {
#line 45
    tmp___3 = getb(infp);
#line 45
    info[87 + i] = (char )tmp___3;
#line 44
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 47
    if (! (i < 4)) {
#line 47
      goto while_break___6;
    }
    {
#line 48
    tmp___4 = getb(infp);
#line 48
    info[91 + i] = (char )tmp___4;
#line 47
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 50
    if (! (i < 4)) {
#line 50
      goto while_break___7;
    }
    {
#line 51
    tmp___5 = getb(infp);
#line 51
    info[95 + i] = (char )tmp___5;
#line 50
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 53
  tmp___6 = getb(infp);
#line 53
  filel = (int )tmp___6;
#line 54
  info[1] = (char )filel;
#line 55
  i = filel;
#line 56
  i = 1;
  }
  {
#line 56
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 56
    if (! (i <= filel)) {
#line 56
      goto while_break___8;
    }
    {
#line 57
    tmp___7 = getb(infp);
#line 57
    info[1 + i] = (char )tmp___7;
#line 56
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 59
  getb(infp);
#line 60
  tmp___8 = get4(info + 87);
#line 60
  rsrcLength = (unsigned int )tmp___8;
#line 61
  tmp___9 = get4(info + 83);
#line 61
  dataLength = (unsigned int )tmp___9;
#line 62
  ibytes -= (unsigned long )(filel + 40);
#line 63
  write_it = 1;
  }
#line 64
  if (list) {
    {
#line 65
    transname((info + 1) + 1, text, (int )info[1]);
#line 66
    transname(info + 65, ftype, 4);
#line 67
    transname(info + 69, fauth, 4);
#line 68
    do_indent(indent);
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
            text, ftype, fauth, (long )dataLength, (long )rsrcLength);
    }
#line 72
    if (info_only) {
#line 73
      write_it = 0;
    }
#line 75
    if (query) {
      {
#line 76
      write_it = do_query();
      }
    } else {
      {
#line 78
      fputc('\n', stderr);
      }
    }
  }
  {
#line 81
  jdw_wrfile((unsigned long )rsrcLength, (unsigned long )dataLength);
  }
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/jdw.c"
static void jdw_wrfile(unsigned long rsrcLength , unsigned long dataLength ) 
{ 


  {
#line 87
  if (write_it) {
    {
#line 88
    define_name(text);
#line 89
    start_info(info, rsrcLength, dataLength);
#line 90
    start_data();
    }
  }
#line 92
  if (verbose) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tData: ");
    }
  }
  {
#line 95
  jdw_wrfork(dataLength);
  }
#line 96
  if (write_it) {
    {
#line 97
    start_rsrc();
    }
  }
#line 99
  if (verbose) {
    {
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", Rsrc: ");
    }
  }
  {
#line 102
  jdw_wrfork(rsrcLength);
  }
#line 103
  if (write_it) {
    {
#line 104
    end_file();
    }
  }
#line 106
  if (verbose) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/jdw.c"
static void jdw_wrfork(unsigned long length___0 ) 
{ 
  int olength ;
  int ilength ;
  int i ;
  unsigned long origlength ;
  unsigned long comprlength ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 117
  if (length___0 == 0UL) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty");
    }
#line 119
    return;
  }
  {
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Huffman compressed ");
#line 122
  comprlength = 0UL;
#line 123
  origlength = length___0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (length___0 > 0UL)) {
#line 124
      goto while_break;
    }
    {
#line 125
    tmp = getb(infp);
#line 125
    olength = (int )tmp & 255;
#line 126
    tmp___0 = getb(infp);
#line 126
    olength = (olength << 8) | ((int )tmp___0 & 255);
#line 127
    tmp___1 = getb(infp);
#line 127
    ilength = (int )tmp___1 & 255;
#line 128
    tmp___2 = getb(infp);
#line 128
    ilength = (ilength << 8) | ((int )tmp___2 & 255);
    }
#line 129
    if (write_it) {
      {
#line 130
      jdw_block(olength);
      }
    } else {
#line 132
      i = 0;
      {
#line 132
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 132
        if (! (i < ilength)) {
#line 132
          goto while_break___0;
        }
        {
#line 133
        getb(infp);
#line 132
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 136
    comprlength += (unsigned long )(ilength + 4);
#line 137
    length___0 -= (unsigned long )olength;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (verbose) {
    {
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%4.1f%%)",
            (100.0 * (double )comprlength) / (double )origlength);
    }
  }
#line 142
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/jdw.c"
static void jdw_block(int olength ) 
{ 


  {
  {
#line 147
  bytesread = 0;
#line 148
  read_tree();
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (bytesread & 3)) {
#line 150
      goto while_break;
    }
    {
#line 151
    getb(infp);
#line 152
    bytesread ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  clrhuff();
#line 155
  de_huffman((unsigned long )olength);
  }
#line 156
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macbinary.c"
static void skip_file___0(int skip ) ;
#line 59 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macbinary.c"
static int info_given  ;
#line 519 "/home/wheatley/newnew/temp/macutils-2.0b3/macunpack/macbinary.c"
static void skip_file___0(int skip ) 
{ 
  char buff[1024] ;
  int n ;
  size_t tmp ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (skip > 0)) {
#line 525
      goto while_break;
    }
#line 526
    if (skip < 1024) {
#line 526
      n = skip;
    } else {
#line 526
      n = 1024;
    }
    {
#line 527
    tmp = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )n, (FILE */* __restrict  */)infp);
    }
#line 527
    if (tmp != (size_t )n) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incomplete file.\n");
#line 532
      exit(1);
      }
    }
#line 534
    skip -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
static unsigned short crctab___16[256]  = 
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/arc.c"
  {      (unsigned short)0,      (unsigned short)49345,      (unsigned short)49537,      (unsigned short)320, 
        (unsigned short)49921,      (unsigned short)960,      (unsigned short)640,      (unsigned short)49729, 
        (unsigned short)50689,      (unsigned short)1728,      (unsigned short)1920,      (unsigned short)51009, 
        (unsigned short)1280,      (unsigned short)50625,      (unsigned short)50305,      (unsigned short)1088, 
        (unsigned short)52225,      (unsigned short)3264,      (unsigned short)3456,      (unsigned short)52545, 
        (unsigned short)3840,      (unsigned short)53185,      (unsigned short)52865,      (unsigned short)3648, 
        (unsigned short)2560,      (unsigned short)51905,      (unsigned short)52097,      (unsigned short)2880, 
        (unsigned short)51457,      (unsigned short)2496,      (unsigned short)2176,      (unsigned short)51265, 
        (unsigned short)55297,      (unsigned short)6336,      (unsigned short)6528,      (unsigned short)55617, 
        (unsigned short)6912,      (unsigned short)56257,      (unsigned short)55937,      (unsigned short)6720, 
        (unsigned short)7680,      (unsigned short)57025,      (unsigned short)57217,      (unsigned short)8000, 
        (unsigned short)56577,      (unsigned short)7616,      (unsigned short)7296,      (unsigned short)56385, 
        (unsigned short)5120,      (unsigned short)54465,      (unsigned short)54657,      (unsigned short)5440, 
        (unsigned short)55041,      (unsigned short)6080,      (unsigned short)5760,      (unsigned short)54849, 
        (unsigned short)53761,      (unsigned short)4800,      (unsigned short)4992,      (unsigned short)54081, 
        (unsigned short)4352,      (unsigned short)53697,      (unsigned short)53377,      (unsigned short)4160, 
        (unsigned short)61441,      (unsigned short)12480,      (unsigned short)12672,      (unsigned short)61761, 
        (unsigned short)13056,      (unsigned short)62401,      (unsigned short)62081,      (unsigned short)12864, 
        (unsigned short)13824,      (unsigned short)63169,      (unsigned short)63361,      (unsigned short)14144, 
        (unsigned short)62721,      (unsigned short)13760,      (unsigned short)13440,      (unsigned short)62529, 
        (unsigned short)15360,      (unsigned short)64705,      (unsigned short)64897,      (unsigned short)15680, 
        (unsigned short)65281,      (unsigned short)16320,      (unsigned short)16000,      (unsigned short)65089, 
        (unsigned short)64001,      (unsigned short)15040,      (unsigned short)15232,      (unsigned short)64321, 
        (unsigned short)14592,      (unsigned short)63937,      (unsigned short)63617,      (unsigned short)14400, 
        (unsigned short)10240,      (unsigned short)59585,      (unsigned short)59777,      (unsigned short)10560, 
        (unsigned short)60161,      (unsigned short)11200,      (unsigned short)10880,      (unsigned short)59969, 
        (unsigned short)60929,      (unsigned short)11968,      (unsigned short)12160,      (unsigned short)61249, 
        (unsigned short)11520,      (unsigned short)60865,      (unsigned short)60545,      (unsigned short)11328, 
        (unsigned short)58369,      (unsigned short)9408,      (unsigned short)9600,      (unsigned short)58689, 
        (unsigned short)9984,      (unsigned short)59329,      (unsigned short)59009,      (unsigned short)9792, 
        (unsigned short)8704,      (unsigned short)58049,      (unsigned short)58241,      (unsigned short)9024, 
        (unsigned short)57601,      (unsigned short)8640,      (unsigned short)8320,      (unsigned short)57409, 
        (unsigned short)40961,      (unsigned short)24768,      (unsigned short)24960,      (unsigned short)41281, 
        (unsigned short)25344,      (unsigned short)41921,      (unsigned short)41601,      (unsigned short)25152, 
        (unsigned short)26112,      (unsigned short)42689,      (unsigned short)42881,      (unsigned short)26432, 
        (unsigned short)42241,      (unsigned short)26048,      (unsigned short)25728,      (unsigned short)42049, 
        (unsigned short)27648,      (unsigned short)44225,      (unsigned short)44417,      (unsigned short)27968, 
        (unsigned short)44801,      (unsigned short)28608,      (unsigned short)28288,      (unsigned short)44609, 
        (unsigned short)43521,      (unsigned short)27328,      (unsigned short)27520,      (unsigned short)43841, 
        (unsigned short)26880,      (unsigned short)43457,      (unsigned short)43137,      (unsigned short)26688, 
        (unsigned short)30720,      (unsigned short)47297,      (unsigned short)47489,      (unsigned short)31040, 
        (unsigned short)47873,      (unsigned short)31680,      (unsigned short)31360,      (unsigned short)47681, 
        (unsigned short)48641,      (unsigned short)32448,      (unsigned short)32640,      (unsigned short)48961, 
        (unsigned short)32000,      (unsigned short)48577,      (unsigned short)48257,      (unsigned short)31808, 
        (unsigned short)46081,      (unsigned short)29888,      (unsigned short)30080,      (unsigned short)46401, 
        (unsigned short)30464,      (unsigned short)47041,      (unsigned short)46721,      (unsigned short)30272, 
        (unsigned short)29184,      (unsigned short)45761,      (unsigned short)45953,      (unsigned short)29504, 
        (unsigned short)45313,      (unsigned short)29120,      (unsigned short)28800,      (unsigned short)45121, 
        (unsigned short)20480,      (unsigned short)37057,      (unsigned short)37249,      (unsigned short)20800, 
        (unsigned short)37633,      (unsigned short)21440,      (unsigned short)21120,      (unsigned short)37441, 
        (unsigned short)38401,      (unsigned short)22208,      (unsigned short)22400,      (unsigned short)38721, 
        (unsigned short)21760,      (unsigned short)38337,      (unsigned short)38017,      (unsigned short)21568, 
        (unsigned short)39937,      (unsigned short)23744,      (unsigned short)23936,      (unsigned short)40257, 
        (unsigned short)24320,      (unsigned short)40897,      (unsigned short)40577,      (unsigned short)24128, 
        (unsigned short)23040,      (unsigned short)39617,      (unsigned short)39809,      (unsigned short)23360, 
        (unsigned short)39169,      (unsigned short)22976,      (unsigned short)22656,      (unsigned short)38977, 
        (unsigned short)34817,      (unsigned short)18624,      (unsigned short)18816,      (unsigned short)35137, 
        (unsigned short)19200,      (unsigned short)35777,      (unsigned short)35457,      (unsigned short)19008, 
        (unsigned short)19968,      (unsigned short)36545,      (unsigned short)36737,      (unsigned short)20288, 
        (unsigned short)36097,      (unsigned short)19904,      (unsigned short)19584,      (unsigned short)35905, 
        (unsigned short)17408,      (unsigned short)33985,      (unsigned short)34177,      (unsigned short)17728, 
        (unsigned short)34561,      (unsigned short)18368,      (unsigned short)18048,      (unsigned short)34369, 
        (unsigned short)33281,      (unsigned short)17088,      (unsigned short)17280,      (unsigned short)33601, 
        (unsigned short)16640,      (unsigned short)33217,      (unsigned short)32897,      (unsigned short)16448};
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/zm_to.c"
int zm_to  ;
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
static char char_mapping___7[256]  = 
#line 8 "/home/wheatley/newnew/temp/macutils-2.0b3/util/backtrans.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'/', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'_',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char)127, 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___4[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/ym_to.c"
int ym_to  ;
#line 6 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/globals.h"
int pre_beta ;
#line 9 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_to.c"
int tgetc(int timeout ) ;
#line 10
void tputc(int c ) ;
#line 11
void tputrec(char *buf___0 , int count ) ;
#line 13
static void send_part(char *info___0 , int size___0 , int more ) ;
#line 14
static int send_sync(void) ;
#line 15
static void send_rec(char *buf___0 , int bufsize , int recno ) ;
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_to.c"
void xm_to(void) 
{ 
  int tmp ;

  {
  {
#line 19
  tmp = send_sync();
  }
#line 19
  if (tmp == 6) {
    {
#line 20
    send_part(file_info, 128, 1);
#line 21
    send_part(data_fork, data_size, 1);
#line 22
    send_part(rsrc_fork, rsrc_size, 0);
    }
  }
#line 24
  return;
}
}
#line 41
void cleanup(int sig ) ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_to.c"
static void send_part(char *info___0 , int size___0 , int more ) 
{ 
  int recno ;
  int i ;
  int status ;

  {
#line 30
  recno = 1;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (size___0 > 0)) {
#line 32
      goto while_break;
    }
#line 33
    i = 0;
    {
#line 33
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 33
      if (! (i < 10)) {
#line 33
        goto while_break___0;
      }
      {
#line 34
      send_rec(info___0, 128, recno);
#line 35
      status = tgetc(10);
      }
#line 36
      if (status != 21) {
#line 37
        goto while_break___0;
      }
#line 33
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 40
    if (status == 21) {
      {
#line 41
      cleanup(-1);
      }
    } else
#line 40
    if (status == 24) {
      {
#line 41
      cleanup(-1);
      }
    }
#line 43
    size___0 -= 128;
#line 44
    info___0 += 128;
#line 45
    recno = (recno + 1) & 255;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tputc('\004');
  }
#line 48
  if (! pre_beta) {
    {
#line 49
    status = tgetc(10);
    }
  }
#line 51
  if (more) {
    {
#line 52
    status = tgetc(10);
    }
  }
#line 54
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_to.c"
static int send_sync(void) 
{ 
  int c ;
  int i ;

  {
#line 60
  i = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < 3)) {
#line 60
      goto while_break;
    }
    {
#line 61
    tputc('\033');
#line 62
    tputc('a');
    }
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 63
      c = tgetc(10);
      }
#line 63
      if (! (c != -1)) {
#line 63
        goto while_break___0;
      }
      {
#line 67
      if (c == 6) {
#line 67
        goto case_6;
      }
#line 67
      if (c == 4) {
#line 67
        goto case_6;
      }
#line 67
      if (c == 24) {
#line 67
        goto case_6;
      }
#line 69
      goto switch_default;
      case_6: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_24: /* CIL Label */ 
#line 68
      return (c);
      switch_default: /* CIL Label */ 
#line 70
      goto while_continue___0;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return ('\030');
}
}
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_to.c"
static void send_rec(char *buf___0 , int bufsize , int recno ) 
{ 
  int i ;
  int cksum ;
  char *bp ;
  char *tmp ;

  {
#line 84
  cksum = 0;
#line 85
  bp = buf___0;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < bufsize)) {
#line 86
      goto while_break;
    }
#line 87
    tmp = bp;
#line 87
    bp ++;
#line 87
    cksum += (int )*tmp & 255;
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tputc('\001');
#line 90
  tputc((int )((unsigned char )recno));
#line 91
  tputc((int )((unsigned char )(255 - recno)));
#line 92
  tputrec(buf___0, bufsize);
#line 93
  tputc((int )((char )(cksum & 255)));
  }
#line 94
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files___1(int initial ) ;
#line 53
static void read_file___1(void) ;
#line 54
static void enter_dir___1(void) ;
#line 55
static void exit_dir___1(void) ;
#line 56
static int get_stdin_file___1(void) ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_data_size___2  ;
#line 61 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int max_rsrc_size___2  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int data_only___1  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int no_recurse___1  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int read_stdin___1  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist global_files___1  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static filelist *current_files___1  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_auth___1[5]  ;
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_type___1[5]  ;
#line 81 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char f_name___1[12]  = 
#line 81
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 91 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char infodir___4[13]  = 
#line 91
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 92
static void read_appledouble_info___1(FILE *fd ) ;
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char filename___1[255]  ;
#line 96 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int filekind___1  ;
#line 115 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void check_files___1(int initial ) 
{ 
  struct stat stbuf ;
  int i ;
  int j ;
  int n ;
  char filename___2[255] ;
  char filename1[255] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 123
  current_files___1->current = 0;
#line 125
  n = current_files___1->nfiles;
#line 126
  tmp = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 126
  current_files___1->kind = (int *)tmp;
  }
#line 127
  if ((unsigned long )current_files___1->kind == (unsigned long )((void *)0)) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory\n");
#line 129
    exit(1);
    }
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < n)) {
#line 131
      goto while_break;
    }
    {
#line 132
    *(current_files___1->kind + i) = 0;
#line 133
    tmp___0 = stat((char const   */* __restrict  */)*(current_files___1->files + i),
                   (struct stat */* __restrict  */)(& stbuf));
    }
#line 133
    if (tmp___0 >= 0) {
#line 134
      if ((stbuf.st_mode & 61440U) == 16384U) {
#line 136
        *(current_files___1->kind + i) = 6;
#line 137
        goto __Cont;
      }
#line 139
      *(current_files___1->kind + i) = 1;
    }
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (data_only___1) {
#line 144
    return;
  }
  {
#line 148
  i = 1;
#line 166
  tmp___1 = stat((char const   */* __restrict  */)(infodir___4), (struct stat */* __restrict  */)(& stbuf));
  }
#line 166
  if (tmp___1 < 0) {
#line 167
    i = 0;
  } else
#line 169
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 170
    i = 0;
  }
#line 174
  current_files___1->shared_dir = i;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < n)) {
#line 176
      goto while_break___0;
    }
#line 177
    if (*(current_files___1->kind + i) == 0) {
#line 178
      j = 0;
    } else
#line 179
    if (*(current_files___1->kind + i) == 1) {
#line 182
      if (! current_files___1->shared_dir) {
        {
#line 182
        tmp___2 = strcmp(*(current_files___1->files + i), f_name___1);
        }
#line 182
        if (! tmp___2) {
#line 184
          *(current_files___1->kind + i) = 4;
#line 185
          goto __Cont___0;
        }
      }
#line 193
      j = 1;
    } else
#line 194
    if (*(current_files___1->kind + i) == 4) {
#line 195
      goto __Cont___0;
    } else
#line 196
    if (! initial) {
      {
#line 198
      tmp___3 = strcmp(*(current_files___1->files + i), ".");
      }
#line 198
      if (tmp___3) {
        {
#line 198
        tmp___4 = strcmp(*(current_files___1->files + i), "..");
        }
#line 198
        if (! tmp___4) {
#line 200
          *(current_files___1->kind + i) = 4;
        }
      } else {
#line 200
        *(current_files___1->kind + i) = 4;
      }
#line 211
      if (current_files___1->shared_dir) {
        {
#line 211
        tmp___5 = strcmp(*(current_files___1->files + i), infodir___4);
        }
#line 211
        if (! tmp___5) {
#line 213
          *(current_files___1->kind + i) = 4;
        }
      }
#line 217
      goto __Cont___0;
    } else {
#line 219
      goto __Cont___0;
    }
#line 223
    if (j & current_files___1->shared_dir) {
      {
#line 224
      j = 0;
#line 225
      filename___2[0] = (char)0;
#line 226
      strcat(filename___2, infodir___4);
#line 227
      strcat(filename___2, "/");
#line 228
      strcat(filename___2, *(current_files___1->files + i));
#line 230
      tmp___6 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 230
      if (tmp___6 >= 0) {
#line 231
        *(current_files___1->kind + i) = 7;
#line 232
        goto __Cont___0;
      }
    }
#line 237
    if (! j) {
      {
#line 238
      filename___2[0] = (char)0;
#line 239
      strcat(filename___2, *(current_files___1->files + i));
#line 240
      strcat(filename___2, ".info");
#line 242
      tmp___7 = stat((char const   */* __restrict  */)(filename___2), (struct stat */* __restrict  */)(& stbuf));
      }
#line 242
      if (tmp___7 >= 0) {
#line 243
        *(current_files___1->kind + i) = 3;
      }
#line 245
      goto __Cont___0;
    }
    {
#line 249
    tmp___8 = (int )strlen(*(current_files___1->files + i));
#line 249
    j = tmp___8 - 5;
#line 250
    tmp___11 = strncmp(*(current_files___1->files + i) + j, ".info", 5);
    }
#line 250
    if (! tmp___11) {
      {
#line 252
      *(current_files___1->kind + i) = 2;
#line 255
      filename___2[0] = (char)0;
#line 256
      strcat(filename___2, *(current_files___1->files + i));
#line 257
      filename___2[j] = (char)0;
#line 258
      strcpy(filename1, filename___2);
#line 259
      strcat(filename___2, ".data");
#line 260
      strcat(filename1, ".rsrc");
#line 261
      j = i + 1;
      }
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (j < n)) {
#line 261
          goto while_break___1;
        }
        {
#line 262
        tmp___9 = strcmp(filename___2, *(current_files___1->files + j));
        }
#line 262
        if (! tmp___9) {
#line 264
          *(current_files___1->kind + j) = 4;
#line 265
          goto __Cont___1;
        }
        {
#line 267
        tmp___10 = strcmp(filename1, *(current_files___1->files + j));
        }
#line 267
        if (! tmp___10) {
#line 269
          *(current_files___1->kind + j) = 4;
        }
        __Cont___1: /* CIL Label */ 
#line 261
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 272
      goto __Cont___0;
    }
    {
#line 274
    tmp___13 = strncmp(*(current_files___1->files + i) + j, ".data", 5);
    }
#line 274
    if (tmp___13) {
      {
#line 274
      tmp___14 = strncmp(*(current_files___1->files + i) + j, ".rsrc", 5);
      }
#line 274
      if (! tmp___14) {
        _L: /* CIL Label */ 
        {
#line 278
        filename___2[0] = (char)0;
#line 279
        strcat(filename___2, *(current_files___1->files + i));
#line 280
        filename___2[j] = (char)0;
#line 281
        strcat(filename___2, ".info");
#line 282
        j = i + 1;
        }
        {
#line 282
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 282
          if (! (j < n)) {
#line 282
            goto while_break___2;
          }
          {
#line 283
          tmp___12 = strcmp(filename___2, *(current_files___1->files + j));
          }
#line 283
          if (! tmp___12) {
#line 285
            *(current_files___1->kind + i) = 4;
#line 286
            goto while_break___2;
          }
#line 282
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 289
        if (j < n) {
#line 290
          goto __Cont___0;
        }
      }
    } else {
#line 274
      goto _L;
    }
#line 294
    *(current_files___1->kind + i) = 5;
    __Cont___0: /* CIL Label */ 
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_file___1(void) 
{ 
  FILE *fd ;
  int c ;
  int j ;
  int lname ;
  int skip ;
  struct stat stbuf ;
  char filename1[255] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  unsigned long tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
  {
#line 353
  if (filekind___1 == 1) {
#line 353
    goto case_1;
  }
#line 437
  if (filekind___1 == 3) {
#line 437
    goto case_3;
  }
#line 439
  if (filekind___1 == 2) {
#line 439
    goto case_2;
  }
#line 492
  if (filekind___1 == 5) {
#line 492
    goto case_5;
  }
#line 545
  if (filekind___1 == 7) {
#line 545
    goto case_7;
  }
#line 352
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 354
  tmp = stat((char const   */* __restrict  */)(filename___1), (struct stat */* __restrict  */)(& stbuf));
  }
#line 354
  if (tmp < 0) {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot stat file %s\n",
            filename___1);
#line 356
    exit(1);
    }
  }
#line 358
  j = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (j < 128)) {
#line 358
      goto while_break;
    }
#line 359
    file_info[j] = (char)0;
#line 358
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  strcpy((file_info + 1) + 1, filename___1);
#line 362
  tmp___0 = (int )strlen(filename___1);
#line 362
  file_info[1] = (char )tmp___0;
#line 363
  put4(file_info + 91, (unsigned long )stbuf.st_ctim.tv_sec + 2082844800UL);
#line 364
  put4(file_info + 95, (unsigned long )stbuf.st_mtim.tv_sec + 2082844800UL);
  }
#line 365
  if (data_only___1 == 2) {
#line 366
    rsrc_size = (int )stbuf.st_size;
#line 367
    data_size = 0;
#line 368
    if (rsrc_size > max_rsrc_size___2) {
#line 369
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 370
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 372
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 374
      max_rsrc_size___2 = rsrc_size;
    }
#line 376
    if ((int )f_type___1[0] == 0) {
      {
#line 377
      strncpy(file_info + 65, "RSRC", 4);
      }
    } else {
      {
#line 379
      strncpy(file_info + 65, f_type___1, 4);
      }
    }
#line 381
    if ((int )f_auth___1[0] == 0) {
      {
#line 382
      strncpy(file_info + 69, "RSED", 4);
      }
    } else {
      {
#line 384
      strncpy(file_info + 69, f_auth___1, 4);
      }
    }
    {
#line 386
    put4(file_info + 87, (unsigned long )rsrc_size);
#line 387
    fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
    }
#line 387
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename___1);
#line 389
      exit(1);
      }
    }
    {
#line 391
    tmp___1 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 391
    if (tmp___1 != (size_t )rsrc_size) {
      {
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___1);
#line 393
      exit(1);
      }
    }
    {
#line 395
    fclose(fd);
    }
  } else {
#line 397
    data_size = (int )stbuf.st_size;
#line 398
    rsrc_size = 0;
#line 399
    if (data_size > max_data_size___2) {
#line 400
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 401
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 403
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 405
      max_data_size___2 = data_size;
    }
#line 407
    if ((int )f_type___1[0] == 0) {
      {
#line 408
      strncpy(file_info + 65, "TEXT", 4);
      }
    } else {
      {
#line 410
      strncpy(file_info + 65, f_type___1, 4);
      }
    }
#line 412
    if ((int )f_auth___1[0] == 0) {
      {
#line 413
      strncpy(file_info + 69, "MACA", 4);
      }
    } else {
      {
#line 415
      strncpy(file_info + 69, f_auth___1, 4);
      }
    }
    {
#line 417
    put4(file_info + 83, (unsigned long )data_size);
#line 418
    fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
    }
#line 418
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
              filename___1);
#line 420
      exit(1);
      }
    }
    {
#line 422
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 422
    if (tmp___2 != (size_t )data_size) {
      {
#line 423
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___1);
#line 424
      exit(1);
      }
    }
    {
#line 426
    fclose(fd);
    }
#line 427
    if (data_only___1 == 3) {
#line 428
      j = 0;
      {
#line 428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 428
        if (! (j < data_size)) {
#line 428
          goto while_break___0;
        }
#line 429
        c = (int )*(data_fork + j);
#line 430
        if (c == 10) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        } else
#line 430
        if (c == 13) {
#line 431
          *(data_fork + j) = (char )(23 - c);
        }
#line 428
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 436
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 438
  strcat(filename___1, ".info");
  }
  case_2: /* CIL Label */ 
  {
#line 440
  tmp___3 = (int )strlen(filename___1);
#line 440
  lname = tmp___3 - 5;
#line 441
  fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
  }
#line 441
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename___1);
#line 443
    exit(1);
    }
  }
  {
#line 445
  tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 445
  if (tmp___4 != 128UL) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read info header %s\n",
            filename___1);
    }
  }
  {
#line 448
  fclose(fd);
#line 449
  tmp___5 = get4(file_info + 83);
#line 449
  data_size = (int )tmp___5;
#line 450
  tmp___6 = get4(file_info + 87);
#line 450
  rsrc_size = (int )tmp___6;
  }
#line 451
  if (data_size > max_data_size___2) {
#line 452
    if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
      {
#line 453
      data_fork = malloc((unsigned int )data_size);
      }
    } else {
      {
#line 455
      data_fork = realloc(data_fork, (unsigned int )data_size);
      }
    }
#line 457
    max_data_size___2 = data_size;
  }
#line 459
  if (rsrc_size > max_rsrc_size___2) {
#line 460
    if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
      {
#line 461
      rsrc_fork = malloc((unsigned int )rsrc_size);
      }
    } else {
      {
#line 463
      rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
      }
    }
#line 465
    max_rsrc_size___2 = rsrc_size;
  }
#line 467
  if (data_size != 0) {
    {
#line 468
    filename___1[lname] = (char)0;
#line 469
    strcat(filename___1, ".data");
#line 470
    fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
    }
#line 470
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open data fork %s\n",
              filename___1);
#line 472
      exit(1);
      }
    }
    {
#line 474
    tmp___7 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)fd);
    }
#line 474
    if (tmp___7 != (size_t )data_size) {
      {
#line 475
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename___1);
      }
    }
    {
#line 477
    fclose(fd);
    }
  }
#line 479
  if (rsrc_size != 0) {
    {
#line 480
    filename___1[lname] = (char)0;
#line 481
    strcat(filename___1, ".rsrc");
#line 482
    fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
    }
#line 482
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 483
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open rsrc fork %s\n",
              filename___1);
#line 484
      exit(1);
      }
    }
    {
#line 486
    tmp___8 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)fd);
    }
#line 486
    if (tmp___8 != (size_t )rsrc_size) {
      {
#line 487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF on %s\n",
              filename___1);
      }
    }
    {
#line 489
    fclose(fd);
    }
  }
#line 491
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 493
  fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
  }
#line 493
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename___1);
#line 495
    exit(1);
    }
  }
  {
#line 497
  tmp___9 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                  (FILE */* __restrict  */)fd);
  }
#line 497
  if (tmp___9 != 128UL) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
            filename___1);
#line 499
    exit(1);
    }
  }
#line 501
  if ((int )file_info[0] != 0) {
    {
#line 502
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename___1);
#line 503
    exit(1);
    }
  }
  {
#line 505
  tmp___10 = get4(file_info + 83);
#line 505
  data_size = (int )tmp___10;
#line 506
  tmp___11 = get4(file_info + 87);
#line 506
  rsrc_size = (int )tmp___11;
  }
#line 507
  if ((int )file_info[81] & 1) {
#line 508
    file_info[74] = (char)64;
#line 509
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 511
  if (data_size != 0) {
#line 512
    if (data_size > max_data_size___2) {
#line 513
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 514
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 516
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 518
      max_data_size___2 = data_size;
    }
    {
#line 520
    tmp___12 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                     (FILE */* __restrict  */)fd);
    }
#line 520
    if (tmp___12 != (size_t )data_size) {
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___1);
#line 522
      exit(1);
      }
    }
#line 524
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 525
    j = 0;
    {
#line 525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 525
      if (! (j < skip)) {
#line 525
        goto while_break___1;
      }
      {
#line 526
      fgetc(fd);
#line 525
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 529
  if (rsrc_size != 0) {
#line 530
    if (rsrc_size > max_rsrc_size___2) {
#line 531
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 532
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 534
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 536
      max_rsrc_size___2 = rsrc_size;
    }
    {
#line 538
    tmp___13 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 538
    if (tmp___13 != (size_t )rsrc_size) {
      {
#line 539
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename___1);
#line 540
      exit(1);
      }
    }
  }
#line 543
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 606
  strcpy(filename1, infodir___4);
#line 607
  strcat(filename1, "/");
#line 608
  strcat(filename1, filename___1);
#line 609
  fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
  }
#line 609
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
            filename1);
    }
  }
  {
#line 612
  read_appledouble_info___1(fd);
#line 613
  tmp___14 = get4(file_info + 87);
#line 613
  rsrc_size = (int )tmp___14;
  }
#line 614
  if (rsrc_size > 0) {
#line 615
    if (rsrc_size > max_rsrc_size___2) {
#line 616
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 617
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 619
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 621
      max_rsrc_size___2 = rsrc_size;
    }
    {
#line 623
    tmp___15 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                     (FILE */* __restrict  */)fd);
    }
#line 623
    if (tmp___15 != (size_t )rsrc_size) {
      {
#line 624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
              filename1);
#line 625
      exit(1);
      }
    }
  }
  {
#line 628
  fclose(fd);
#line 629
  tmp___17 = stat((char const   */* __restrict  */)(filename___1), (struct stat */* __restrict  */)(& stbuf));
  }
#line 629
  if (tmp___17 >= 0) {
    {
#line 630
    data_size = (int )stbuf.st_size;
#line 631
    put4(file_info + 83, (unsigned long )data_size);
    }
#line 632
    if (data_size > 0) {
#line 633
      if (data_size > max_data_size___2) {
#line 634
        if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
          {
#line 635
          data_fork = malloc((unsigned int )data_size);
          }
        } else {
          {
#line 637
          data_fork = realloc(data_fork, (unsigned int )data_size);
          }
        }
#line 639
        max_data_size___2 = data_size;
      }
      {
#line 641
      fd = fopen((char const   */* __restrict  */)(filename___1), (char const   */* __restrict  */)"r");
      }
#line 641
      if ((unsigned long )fd == (unsigned long )((void *)0)) {
        {
#line 642
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s\n",
                filename___1);
#line 643
        exit(1);
        }
      }
      {
#line 645
      tmp___16 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                       (FILE */* __restrict  */)fd);
      }
#line 645
      if (tmp___16 != (size_t )data_size) {
        {
#line 646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short file %s\n",
                filename1);
#line 647
        exit(1);
        }
      }
      {
#line 649
      fclose(fd);
      }
    }
  }
#line 653
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void enter_dir___1(void) 
{ 
  DIR *directory ;
  struct dirent *curentry ;
  FILE *fd ;
  int n ;
  int j ;
  int namlen ;
  int listsize ;
  int cursize ;
  char *filetable ;
  filelist *new_files ;
  char filename1[255] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 671
  j = 0;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! (j < 128)) {
#line 671
      goto while_break;
    }
#line 672
    file_info[j] = (char)0;
#line 671
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  strcpy((file_info + 1) + 1, filename___1);
#line 675
  tmp = (int )strlen(filename___1);
#line 675
  file_info[1] = (char )tmp;
#line 676
  directory = opendir((char const   *)(filename___1));
  }
#line 677
  if ((unsigned long )directory == (unsigned long )((void *)0)) {
    {
#line 678
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s\n",
            filename___1);
#line 679
    exit(1);
    }
  }
  {
#line 681
  listsize = 1024;
#line 682
  filetable = malloc((unsigned int )listsize);
#line 683
  cursize = 0;
#line 684
  n = 0;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 685
    curentry = readdir(directory);
    }
#line 685
    if (! ((unsigned long )curentry != (unsigned long )((void *)0))) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    namlen = (int )strlen(curentry->d_name);
    }
#line 687
    if (namlen + 1 > listsize - cursize) {
      {
#line 688
      listsize += 1024;
#line 689
      filetable = realloc(filetable, (unsigned int )listsize);
      }
    }
    {
#line 691
    strcpy(filetable + cursize, curentry->d_name);
#line 692
    cursize += namlen + 1;
#line 693
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 695
  filetable = realloc(filetable, (unsigned int )cursize);
#line 696
  closedir(directory);
#line 697
  tmp___0 = malloc(sizeof(filelist ));
#line 697
  new_files = (filelist *)tmp___0;
#line 698
  new_files->nfiles = n;
#line 699
  tmp___1 = malloc((unsigned long )((unsigned int )n) * sizeof(char **));
#line 699
  new_files->files = (char **)tmp___1;
#line 700
  tmp___2 = malloc((unsigned long )((unsigned int )n) * sizeof(int ));
#line 700
  new_files->kind = (int *)tmp___2;
#line 701
  new_files->previous = current_files___1;
#line 702
  new_files->current = 0;
#line 703
  cursize = 0;
#line 704
  j = 0;
  }
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 704
    if (! (j < n)) {
#line 704
      goto while_break___1;
    }
    {
#line 705
    *(new_files->files + j) = filetable + cursize;
#line 706
    tmp___3 = (int )strlen(filetable + cursize);
#line 706
    cursize += tmp___3 + 1;
#line 704
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 708
  chdir(filename___1);
#line 710
  fd = fopen((char const   */* __restrict  */)(f_name___1), (char const   */* __restrict  */)"r");
  }
#line 710
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 711
    tmp___4 = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128,
                    (FILE */* __restrict  */)fd);
    }
#line 711
    if (tmp___4 != 128UL) {
      {
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File error on %s\n",
              f_name___1);
#line 713
      exit(1);
      }
    }
    {
#line 715
    file_info[1] = (char )((int )file_info[1] | 128);
#line 716
    fclose(fd);
    }
  } else {
    {
#line 729
    strcpy(filename1, infodir___4);
#line 730
    strcat(filename1, "/.Parent");
#line 731
    fd = fopen((char const   */* __restrict  */)(filename1), (char const   */* __restrict  */)"r");
    }
#line 731
    if ((unsigned long )fd != (unsigned long )((void *)0)) {
      {
#line 732
      read_appledouble_info___1(fd);
#line 733
      fclose(fd);
      }
    }
#line 736
    file_info[1] = (char )((int )file_info[1] | 128);
  }
  {
#line 748
  current_files___1 = new_files;
#line 749
  check_files___1(0);
  }
#line 750
  return;
}
}
#line 752 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void exit_dir___1(void) 
{ 
  filelist *old_files ;
  int i ;

  {
#line 757
  i = 0;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (i < 128)) {
#line 757
      goto while_break;
    }
#line 758
    file_info[i] = (char)0;
#line 757
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  file_info[1] = (char)-128;
#line 761
  old_files = current_files___1;
#line 763
  current_files___1 = current_files___1->previous;
#line 764
  free(*(old_files->files + 0));
#line 765
  free((char *)old_files->files);
#line 766
  free((char *)old_files->kind);
#line 767
  free((char *)old_files);
#line 768
  chdir("..");
  }
#line 769
  return;
}
}
#line 838 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static void read_appledouble_info___1(FILE *fd ) 
{ 
  FileInfo theinfo ;
  int i ;
  int n ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 844
  i = 0;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (i < 128)) {
#line 844
      goto while_break;
    }
#line 845
    file_info[i] = (char)0;
#line 844
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 848
  tmp = fread((void */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
              (FILE */* __restrict  */)fd);
  }
#line 848
  if (tmp != sizeof(theinfo)) {
    {
#line 849
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short AppleDouble info header for %s\n",
            filename___1);
#line 851
    exit(1);
    }
  }
  {
#line 853
  tmp___0 = get4(theinfo.fi_magic);
  }
#line 853
  if (tmp___0 != 333319UL) {
    {
#line 855
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
            filename___1);
#line 856
    exit(1);
    }
  } else {
    {
#line 853
    tmp___1 = get2(theinfo.fi_version);
    }
#line 853
    if (tmp___1 != 1UL) {
      {
#line 855
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Magic number mismatch on %s\n",
              filename___1);
#line 856
      exit(1);
      }
    }
  }
  {
#line 858
  bcopy(theinfo.fi_type, file_info + 65, 4);
#line 859
  bcopy(theinfo.fi_auth, file_info + 69, 4);
#line 860
  bcopy(theinfo.fi_finfo, file_info + 73, 2);
#line 861
  tmp___2 = get4(theinfo.fi_namlen);
#line 861
  n = (int )tmp___2;
#line 862
  strncpy((file_info + 1) + 1, theinfo.fi_name, n);
#line 863
  file_info[1] = (char )n;
#line 864
  tmp___3 = get4(theinfo.fi_ctime);
#line 864
  put4(file_info + 91, tmp___3 + 2082844800UL);
#line 865
  tmp___4 = get4(theinfo.fi_mtime);
#line 865
  put4(file_info + 95, tmp___4 + 2082844800UL);
#line 866
  tmp___5 = get4(theinfo.fi_rsrc);
#line 866
  rsrc_size = (int )tmp___5;
#line 867
  put4(file_info + 87, (unsigned long )rsrc_size);
  }
#line 868
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static int get_stdin_file___1(void) 
{ 
  int i ;
  int skip ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 876
  i = fgetc(stdin);
  }
#line 877
  if (i == -1) {
#line 878
    return (0);
  }
  {
#line 880
  ungetc(i, stdin);
#line 881
  tmp = fread((void */* __restrict  */)(file_info), (size_t )1, (size_t )128, (FILE */* __restrict  */)stdin);
  }
#line 881
  if (tmp != 128UL) {
    {
#line 882
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 883
    exit(1);
    }
  }
#line 885
  if ((int )file_info[0] != 0) {
    {
#line 886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is not MacBinary: %s\n",
            filename___1);
#line 887
    exit(1);
    }
  }
  {
#line 889
  tmp___0 = get4(file_info + 83);
#line 889
  data_size = (int )tmp___0;
#line 890
  tmp___1 = get4(file_info + 87);
#line 890
  rsrc_size = (int )tmp___1;
  }
#line 891
  if ((int )file_info[81] & 1) {
#line 892
    file_info[74] = (char)64;
#line 893
    file_info[81] = (char )((int )file_info[81] & -2);
  }
#line 895
  if (data_size != 0) {
#line 896
    if (data_size > max_data_size___2) {
#line 897
      if ((unsigned long )data_fork == (unsigned long )((void *)0)) {
        {
#line 898
        data_fork = malloc((unsigned int )data_size);
        }
      } else {
        {
#line 900
        data_fork = realloc(data_fork, (unsigned int )data_size);
        }
      }
#line 902
      max_data_size___2 = data_size;
    }
    {
#line 904
    tmp___2 = fread((void */* __restrict  */)data_fork, (size_t )1, (size_t )data_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 904
    if (tmp___2 != (size_t )data_size) {
      {
#line 905
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 906
      exit(1);
      }
    }
#line 908
    skip = (((data_size + 127) >> 7) << 7) - data_size;
#line 909
    i = 0;
    {
#line 909
    while (1) {
      while_continue: /* CIL Label */ ;
#line 909
      if (! (i < skip)) {
#line 909
        goto while_break;
      }
      {
#line 910
      fgetc(stdin);
#line 909
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 913
  if (rsrc_size != 0) {
#line 914
    if (rsrc_size > max_rsrc_size___2) {
#line 915
      if ((unsigned long )rsrc_fork == (unsigned long )((void *)0)) {
        {
#line 916
        rsrc_fork = malloc((unsigned int )rsrc_size);
        }
      } else {
        {
#line 918
        rsrc_fork = realloc(rsrc_fork, (unsigned int )rsrc_size);
        }
      }
#line 920
      max_rsrc_size___2 = rsrc_size;
    }
    {
#line 922
    tmp___3 = fread((void */* __restrict  */)rsrc_fork, (size_t )1, (size_t )rsrc_size,
                    (FILE */* __restrict  */)stdin);
    }
#line 922
    if (tmp___3 != (size_t )rsrc_size) {
      {
#line 923
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short input\n");
#line 924
      exit(1);
      }
    }
#line 926
    skip = (((rsrc_size + 127) >> 7) << 7) - rsrc_size;
#line 927
    i = 0;
    {
#line 927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 927
      if (! (i < skip)) {
#line 927
        goto while_break___0;
      }
      {
#line 928
      fgetc(stdin);
#line 927
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 931
  if ((int )file_info[1] & 128) {
#line 932
    if (((int )file_info[1] & 255) == 128) {
#line 933
      return (3);
    }
#line 935
    return (2);
  }
#line 937
  return (1);
}
}
#line 992 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/rdfile.c"
static char options___9[9]  = 
#line 992
  {      (char )'r',      (char )'d',      (char )'u',      (char )'U', 
        (char )'c',      (char )':',      (char )'t',      (char )':', 
        (char )'\000'};
#line 5 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/globals.h"
int xfertype ;
#line 7
int time_out ;
#line 3 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/globals.c"
int xfertype  =    0;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/globals.c"
int pre_beta  =    0;
#line 5 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/globals.c"
int time_out  =    0;
#line 858 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void timedout(void) ;
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static jmp_buf timobuf  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static struct termios otty  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static struct termios ntty  ;
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static int ttyfd  ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static int signal_set  ;
#line 28 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void setup_tty(void) 
{ 


  {
  {
#line 30
  ttyfd = fileno(stderr);
  }
#line 31
  if (! signal_set) {
    {
#line 32
    signal(1, (void (*)(int  ))(& cleanup));
#line 33
    signal(2, (void (*)(int  ))(& cleanup));
#line 34
    signal(3, (void (*)(int  ))(& cleanup));
#line 35
    signal(15, (void (*)(int  ))(& cleanup));
    }
#line 36
    if (time_out) {
      {
#line 37
      signal(14, (void (*)(int  ))(& timedout));
      }
    }
#line 39
    signal_set = 1;
  }
  {
#line 47
  tcgetattr(ttyfd, & otty);
#line 48
  ntty = otty;
#line 49
  ntty.c_lflag &= 4294967284U;
#line 50
  ntty.c_iflag &= 4096U;
#line 51
  ntty.c_oflag &= 4294967294U;
#line 52
  ntty.c_cflag &= 4294966527U;
#line 53
  ntty.c_cc[6] = (cc_t )1;
#line 54
  ntty.c_cc[5] = (cc_t )0;
#line 55
  tcsetattr(ttyfd, 2, (struct termios  const  *)(& ntty));
  }
#line 57
  return;
}
}
#line 61
extern int ( /* missing proto */  sleep)() ;
#line 59 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void reset_tty(void) 
{ 


  {
  {
#line 61
  sleep(1);
#line 65
  tcsetattr(ttyfd, 2, (struct termios  const  *)(& otty));
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void cleanup(int sig ) 
{ 


  {
  {
#line 71
  reset_tty();
#line 72
  exit(sig);
  }
}
}
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void timedout(void) 
{ 


  {
  {
#line 77
  signal(14, (void (*)(int  ))(& timedout));
#line 78
  longjmp((struct __jmp_buf_tag *)(timobuf), 1);
  }
}
}
#line 91
extern int ( /* missing proto */  alarm)() ;
#line 81 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
int tgetc(int timeout ) 
{ 
  char c ;
  int i ;
  int tmp ;

  {
#line 87
  if (time_out) {
    {
#line 88
    tmp = _setjmp((struct __jmp_buf_tag *)(timobuf));
    }
#line 88
    if (tmp) {
#line 89
      return (-1);
    }
    {
#line 91
    alarm(timeout);
    }
  }
  {
#line 93
  i = read(ttyfd, & c, 1);
  }
#line 94
  if (time_out) {
    {
#line 95
    alarm(0);
    }
  }
#line 97
  if (i == 0) {
#line 98
    return ('\004');
  } else {
#line 100
    return ((int )c & 255);
  }
}
}
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
int tgetrec(char *buf___0 , int count , int timeout ) 
{ 
  int i ;
  int tot ;
  int cc ;
  int tmp ;

  {
#line 108
  tot = 0;
#line 108
  cc = count;
#line 110
  if (time_out) {
    {
#line 111
    tmp = _setjmp((struct __jmp_buf_tag *)(timobuf));
    }
#line 111
    if (tmp) {
#line 112
      return (-1);
    }
    {
#line 114
    alarm(timeout);
    }
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (tot < count)) {
#line 116
      goto while_break;
    }
    {
#line 117
    i = read(ttyfd, buf___0, cc);
    }
#line 118
    if (i < 0) {
#line 119
      goto while_continue;
    }
#line 121
    tot += i;
#line 122
    cc -= i;
#line 123
    buf___0 += i;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (time_out) {
    {
#line 126
    alarm(0);
    }
  }
#line 128
  return (0);
}
}
#line 137
extern int ( /* missing proto */  write)() ;
#line 131 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void tputc(int c ) 
{ 
  char cc ;

  {
  {
#line 136
  cc = (char )(c & 255);
#line 137
  write(ttyfd, & cc, 1);
  }
#line 138
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
void tputrec(char *buf___0 , int count ) 
{ 


  {
  {
#line 144
  write(ttyfd, buf___0, count);
  }
#line 145
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___8[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static void usage___4(void) ;
#line 22 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static char options___10[128]  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static char *dir_stack___3  ;
#line 24 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static int dir_ptr___3  =    -64;
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static int dir_max___3  ;
#line 237 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tomac.c"
static void usage___4(void) 
{ 


  {
  {
#line 239
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: tomac [-%s] [files]\n",
          options___10);
#line 240
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"tomac -H\" for help.\n");
  }
#line 241
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___2(void) ;
#line 56
static void appledouble_namings___2(void) ;
#line 57
static void wr_appledouble_info___2(FILE *fp ) ;
#line 60
static void mk_share_name___2(void) ;
#line 73 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info___2[69]  ;
#line 74 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_data___2[207]  ;
#line 75 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_rsrc___2[69]  ;
#line 76 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_text___2[69]  ;
#line 77 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_unix___2[69]  ;
#line 78 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_bin___2[69]  ;
#line 79 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_folder___2[12]  = 
#line 79
  {      (char )'.',      (char )'f',      (char )'o',      (char )'l', 
        (char )'d',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 80 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char share_name___2[256]  ;
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char hex___2[17]  = 
#line 82
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 93 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char infodir___5[13]  = 
#line 93
  {      (char )'.',      (char )'A',      (char )'p',      (char )'p', 
        (char )'l',      (char )'e',      (char )'D',      (char )'o', 
        (char )'u',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 95 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char f_info_appledouble___2[207UL + sizeof(infodir___5)]  ;
#line 98 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode___2  =    4;
#line 99 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_restricted___2  =    0;
#line 100 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static int mode_s_restricted___2  =    0;
#line 103 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char init_buffer___2[128]  ;
#line 104 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *buffer___2  =    & init_buffer___2[0];
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *rbuffer___2  =    (char *)((void *)0);
#line 105 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *dbuffer___2  =    (char *)((void *)0);
#line 106 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char *ptr___2  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long rsz___2  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long dsz___2  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long totsize___2  ;
#line 107 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static unsigned long maxsize___2  ;
#line 606 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void check_appledouble___2(void) 
{ 
  struct stat stbuf ;
  int error ;
  int tmp ;

  {
  {
#line 610
  error = 0;
#line 612
  tmp = stat((char const   */* __restrict  */)(infodir___5), (struct stat */* __restrict  */)(& stbuf));
  }
#line 612
  if (tmp < 0) {
#line 613
    error ++;
  } else
#line 615
  if ((stbuf.st_mode & 61440U) != 16384U) {
#line 616
    error ++;
  }
#line 619
  if (error) {
    {
#line 620
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not in an AppleDouble folder.\n");
#line 621
    exit(1);
    }
  }
#line 623
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void appledouble_namings___2(void) 
{ 


  {
  {
#line 627
  mk_share_name___2();
#line 628
  sprintf((char */* __restrict  */)(f_info_appledouble___2), (char const   */* __restrict  */)"%s/%s",
          infodir___5, share_name___2);
#line 629
  sprintf((char */* __restrict  */)(f_data___2), (char const   */* __restrict  */)"%s",
          share_name___2);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void wr_appledouble_info___2(FILE *fp ) 
{ 
  FileInfo theinfo ;
  int n ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 638
  bzero((char *)(& theinfo), sizeof(theinfo));
#line 639
  put4(theinfo.fi_magic, 333319UL);
#line 640
  put2(theinfo.fi_version, 1UL);
#line 641
  put4(theinfo.fi_fill5, 5UL);
#line 642
  put4(theinfo.fi_fill6, 2UL);
#line 643
  put4(theinfo.fi_hlen, 589UL);
#line 644
  put4(theinfo.fi_fill7, 3UL);
#line 645
  put4(theinfo.fi_namptr, 86UL);
#line 646
  put4(theinfo.fi_fill9, 4UL);
#line 647
  put4(theinfo.fi_commptr, 341UL);
#line 648
  put4(theinfo.fi_fill12, 7UL);
#line 649
  put4(theinfo.fi_timeptr, 541UL);
#line 650
  put4(theinfo.fi_timesize, 16UL);
#line 651
  put4(theinfo.fi_fill15, 9UL);
#line 652
  put4(theinfo.fi_infoptr, 557UL);
#line 653
  put4(theinfo.fi_infosize, 32UL);
#line 655
  bcopy(buffer___2 + 65, theinfo.fi_type, 4);
#line 656
  bcopy(buffer___2 + 69, theinfo.fi_auth, 4);
#line 657
  bcopy(buffer___2 + 73, theinfo.fi_finfo, 2);
#line 659
  tmp = get4(buffer___2 + 91);
#line 659
  put4(theinfo.fi_ctime, tmp - 2082844800UL);
#line 660
  tmp___0 = get4(buffer___2 + 95);
#line 660
  put4(theinfo.fi_mtime, tmp___0 - 2082844800UL);
#line 661
  n = (int )*(buffer___2 + 1) & 255;
  }
#line 661
  if (n > 63) {
#line 662
    n = 63;
  }
  {
#line 664
  put4(theinfo.fi_namlen, (unsigned long )n);
#line 665
  strncpy(theinfo.fi_name, (buffer___2 + 1) + 1, n);
#line 667
  strcpy(theinfo.fi_comment, "Converted by Unix utility to AppleDouble format");
#line 669
  tmp___1 = (int )strlen(theinfo.fi_comment);
#line 669
  put4(theinfo.fi_commsize, (unsigned long )tmp___1);
#line 670
  put4(theinfo.fi_rsrc, rsz___2);
#line 674
  fwrite((void const   */* __restrict  */)((char *)(& theinfo)), (size_t )1, sizeof(theinfo),
         (FILE */* __restrict  */)fp);
  }
#line 675
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static void mk_share_name___2(void) 
{ 
  int ch ;
  char *mp ;
  char *up ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 683
  mp = buffer___2 + 2;
#line 684
  up = & share_name___2[0];
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    tmp___5 = mp;
#line 685
    mp ++;
#line 685
    ch = (int )*tmp___5;
#line 685
    if (! ch) {
#line 685
      goto while_break;
    }
#line 686
    if ((ch & -128) == 0) {
      {
#line 686
      tmp___3 = __ctype_b_loc();
      }
#line 686
      if ((int const   )*(*tmp___3 + ch) & 2) {
#line 686
        goto _L___1;
      } else {
        {
#line 686
        tmp___4 = __ctype_b_loc();
        }
#line 686
        if ((int const   )*(*tmp___4 + ch) & 16384) {
#line 686
          if (ch != 47) {
#line 687
            tmp = up;
#line 687
            up ++;
#line 687
            *tmp = (char )ch;
          } else {
#line 686
            goto _L___1;
          }
        } else {
#line 686
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 689
      tmp___0 = up;
#line 689
      up ++;
#line 689
      *tmp___0 = (char )':';
#line 690
      tmp___1 = up;
#line 690
      up ++;
#line 690
      *tmp___1 = hex___2[(ch >> 4) & 15];
#line 691
      tmp___2 = up;
#line 691
      up ++;
#line 691
      *tmp___2 = hex___2[ch & 15];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  *up = (char)0;
#line 695
  return;
}
}
#line 817 "/home/wheatley/newnew/temp/macutils-2.0b3/fileio/wrfile.c"
static char options___11[20]  ;
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/zm_from.c"
int zm_from  ;
#line 17 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/frommac.c"
static void usage___5(void) ;
#line 19 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/frommac.c"
static char options___12[128]  ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/frommac.c"
static int multi_file  =    0;
#line 21 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/frommac.c"
static int listmode___0  =    0;
#line 132
void xm_from(void) ;
#line 162 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/frommac.c"
static void usage___5(void) 
{ 


  {
  {
#line 164
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: frommac [-%s]\n",
          options___12);
#line 165
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \"frommac -H\" for help.\n");
  }
#line 166
  return;
}
}
#line 4 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/ym_from.c"
int ym_from  ;
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
static int mlength___5[12]  = 
#line 10 "/home/wheatley/newnew/temp/macutils-2.0b3/util/util.c"
  {      0,      31,      61,      92, 
        122,      153,      184,      214, 
        245,      275,      306,      337};
#line 14 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_from.c"
static void receive_part(char *info___0 , int size___0 , int more ) ;
#line 15
static int receive_sync(void) ;
#line 16
static int receive_rec(char *buf___0 , int bufsize , int recno ) ;
#line 20 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_from.c"
void xm_from(void) 
{ 
  unsigned long data_size___0 ;
  unsigned long rsrc_size___0 ;
  char text___0[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 25
  tmp___1 = receive_sync();
  }
#line 25
  if (tmp___1 == 6) {
    {
#line 26
    receive_part(info, 128, 1);
#line 27
    transname((info + 1) + 1, text___0, (int )info[1]);
#line 28
    define_name(text___0);
#line 29
    tmp = (int )get4(info + 83);
#line 29
    data_size___0 = (unsigned long )tmp;
#line 30
    tmp___0 = (int )get4(info + 87);
#line 30
    rsrc_size___0 = (unsigned long )tmp___0;
#line 31
    start_info(info, rsrc_size___0, data_size___0);
#line 32
    start_data();
#line 33
    receive_part(out_buffer, data_size___0, 1);
#line 34
    start_rsrc();
#line 35
    receive_part(out_buffer, rsrc_size___0, 0);
#line 36
    end_file();
    }
  }
#line 38
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_from.c"
static void receive_part(char *info___0 , int size___0 , int more ) 
{ 
  int recno ;
  int status ;
  int naks ;
  int tmp ;

  {
#line 44
  recno = 1;
#line 44
  naks = 0;
#line 46
  status = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (status != 4)) {
#line 47
      goto while_break;
    }
    {
#line 48
    status = receive_rec(info___0, 128, recno);
    }
    {
#line 50
    if (status == 4) {
#line 50
      goto case_4;
    }
#line 59
    if (status == 6) {
#line 59
      goto case_6;
    }
#line 66
    if (status == 0) {
#line 66
      goto case_0;
    }
#line 70
    if (status == 21) {
#line 70
      goto case_21;
    }
#line 75
    if (status == 24) {
#line 75
      goto case_24;
    }
#line 49
    goto switch_break;
    case_4: /* CIL Label */ 
#line 51
    if (! pre_beta) {
      {
#line 52
      tputc('\006');
      }
    }
#line 54
    if (more) {
      {
#line 55
      tputc('\025');
      }
    }
#line 57
    size___0 = 0;
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 60
    tputc('\006');
#line 61
    naks = 0;
#line 62
    size___0 -= 128;
#line 63
    info___0 += 128;
#line 64
    recno = (recno + 1) & 255;
    }
#line 65
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 67
    tputc('\006');
#line 68
    naks = 0;
    }
#line 69
    goto switch_break;
    case_21: /* CIL Label */ 
#line 71
    tmp = naks;
#line 71
    naks ++;
#line 71
    if (tmp < 10) {
      {
#line 72
      tputc('\025');
      }
#line 73
      goto switch_break;
    }
    case_24: /* CIL Label */ 
    {
#line 76
    tputc('\030');
#line 77
    cleanup(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_from.c"
static int receive_sync(void) 
{ 
  int c ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    c = tgetc(60);
    }
    {
#line 89
    if (c == 27) {
#line 89
      goto case_27;
    }
#line 91
    if (c == 24) {
#line 91
      goto case_24;
    }
#line 95
    if (c == -1) {
#line 95
      goto case_neg_1;
    }
#line 95
    if (c == 4) {
#line 95
      goto case_neg_1;
    }
#line 97
    goto switch_default;
    case_27: /* CIL Label */ 
#line 90
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 92
    cleanup();
    }
#line 93
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 96
    return (c);
    switch_default: /* CIL Label */ 
#line 98
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 100
    c = tgetc(1);
    }
#line 101
    if (c == 97) {
#line 102
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  tputc('\006');
  }
#line 106
  return ('\006');
}
}
#line 109 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/xm_from.c"
static int receive_rec(char *buf___0 , int bufsize , int recno ) 
{ 
  int i ;
  int cksum ;
  int c ;
  int rec ;
  int recbar ;
  char *bp ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 116
  c = tgetc(10);
  }
  {
#line 119
  if (c == 24) {
#line 119
    goto case_24;
  }
#line 119
  if (c == 4) {
#line 119
    goto case_24;
  }
#line 121
  if (c == 1) {
#line 121
    goto case_1;
  }
#line 124
  goto switch_default;
  case_24: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 120
  return (c);
  case_1: /* CIL Label */ 
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 125
  return ('\025');
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  rec = tgetc(2);
  }
#line 128
  if (rec == -1) {
#line 129
    return ('\025');
  }
  {
#line 131
  recbar = tgetc(2);
  }
#line 132
  if (recbar == -1) {
#line 133
    return ('\025');
  }
#line 135
  if (rec + recbar != 255) {
#line 136
    return ('\025');
  }
  {
#line 138
  tmp = tgetrec(buf___0, bufsize, 20);
  }
#line 138
  if (tmp == -1) {
#line 139
    return ('\025');
  }
#line 141
  bp = buf___0;
#line 142
  cksum = 0;
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < bufsize)) {
#line 143
      goto while_break;
    }
#line 144
    tmp___0 = bp;
#line 144
    bp ++;
#line 144
    cksum += (int )*tmp___0 & 255;
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  c = tgetc(2);
  }
#line 147
  if (c == -1) {
#line 148
    return ('\025');
  }
#line 150
  if (c != (cksum & 255)) {
#line 151
    return ('\025');
  }
#line 153
  if (rec == recno - 1) {
#line 154
    return ('\000');
  }
#line 156
  if (rec != recno) {
#line 157
    return ('\030');
  }
#line 159
  return ('\006');
}
}
#line 18 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static jmp_buf timobuf___0  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static struct termios otty___0  ;
#line 23 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static struct termios ntty___0  ;
#line 25 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static int ttyfd___0  ;
#line 26 "/home/wheatley/newnew/temp/macutils-2.0b3/comm/tty.c"
static int signal_set___0  ;
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
static char char_mapping___9[256]  = 
#line 37 "/home/wheatley/newnew/temp/macutils-2.0b3/util/transname.c"
  {      (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'_', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'U',      (char )'V',      (char )'W', 
        (char )'X',      (char )'Y',      (char )'Z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'_', 
        (char )'A',      (char )'A',      (char )'C',      (char )'E', 
        (char )'N',      (char )'O',      (char )'U',      (char )'a', 
        (char )'a',      (char )'a',      (char )'a',      (char )'a', 
        (char )'a',      (char )'c',      (char )'e',      (char )'e', 
        (char )'e',      (char )'e',      (char )'i',      (char )'i', 
        (char )'i',      (char )'i',      (char )'n',      (char )'o', 
        (char )'o',      (char )'o',      (char )'o',      (char )'o', 
        (char )'u',      (char )'u',      (char )'u',      (char )'u', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'O', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'o', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'A', 
        (char )'A',      (char )'O',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'y',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_', 
        (char )'_',      (char )'_',      (char )'_',      (char )'_'};
#line 38 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/makecrc.c"
static void initcrctab(char *name , int poly , int init , int swapped , int bits ) ;
#line 52 "/home/wheatley/newnew/temp/macutils-2.0b3/crc/makecrc.c"
static void initcrctab(char *name , int poly , int init , int swapped , int bits ) 
{ 
  register int b___1 ;
  register int i ;
  unsigned short v ;
  unsigned long vv ;
  FILE *fd ;
  char buf___0[20] ;

  {
  {
#line 62
  buf___0[0] = (char)0;
#line 63
  strcat(buf___0, name);
#line 64
  strcat(buf___0, ".c");
#line 65
  fd = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"w");
  }
#line 65
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s for writing\n",
            buf___0);
#line 67
    exit(1);
    }
  }
  {
#line 69
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"unsigned long %s_crcinit = %d;\n",
          name, init);
#line 70
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
  }
#line 71
  if (bits == 16) {
    {
#line 72
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"static unsigned short crctab[256] = {\n");
    }
  } else {
    {
#line 74
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"static unsigned long crctab[256] = {\n");
    }
  }
  {
#line 76
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    ");
  }
#line 77
  if (bits == 16) {
#line 78
    b___1 = 0;
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if (! (b___1 < 256)) {
#line 78
        goto while_break;
      }
#line 79
      if (swapped) {
#line 80
        v = (unsigned short )b___1;
#line 80
        i = 8;
        {
#line 80
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 80
          i --;
#line 80
          if (! (i >= 0)) {
#line 80
            goto while_break___0;
          }
#line 81
          if ((int )v & 1) {
#line 81
            v = (unsigned short )(((int )v >> 1) ^ poly);
          } else {
#line 81
            v = (unsigned short )((int )v >> 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 83
        v = (unsigned short )(b___1 << 8);
#line 83
        i = 8;
        {
#line 83
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 83
          i --;
#line 83
          if (! (i >= 0)) {
#line 83
            goto while_break___1;
          }
#line 84
          if ((int )v & 32768) {
#line 84
            v = (unsigned short )(((int )v << 1) ^ poly);
          } else {
#line 84
            v = (unsigned short )((int )v << 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 86
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"0x%.4x,",
              (int )v & 65535);
      }
#line 87
      if ((b___1 & 7) == 7) {
        {
#line 88
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
        }
#line 89
        if (b___1 != 255) {
          {
#line 89
          fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    ");
          }
        }
      } else {
        {
#line 91
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" ");
        }
      }
#line 78
      b___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 95
    b___1 = 0;
    {
#line 95
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 95
      if (! (b___1 < 256)) {
#line 95
        goto while_break___2;
      }
#line 96
      if (swapped) {
#line 97
        vv = (unsigned long )b___1;
#line 97
        i = 8;
        {
#line 97
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 97
          i --;
#line 97
          if (! (i >= 0)) {
#line 97
            goto while_break___3;
          }
#line 98
          if (vv & 1UL) {
#line 98
            vv = (vv >> 1) ^ (unsigned long )poly;
          } else {
#line 98
            vv >>= 1;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 100
        vv = (unsigned long )(b___1 << 24);
#line 100
        i = 8;
        {
#line 100
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 100
          i --;
#line 100
          if (! (i >= 0)) {
#line 100
            goto while_break___4;
          }
#line 101
          if (vv & 2147483648UL) {
#line 101
            vv = (vv << 1) ^ (unsigned long )poly;
          } else {
#line 101
            vv <<= 1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 103
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"0x%.8x,",
              vv & 4294967295UL);
      }
#line 104
      if ((b___1 & 3) == 3) {
        {
#line 105
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
        }
#line 106
        if (b___1 != 255) {
          {
#line 106
          fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    ");
          }
        }
      } else {
        {
#line 108
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" ");
        }
      }
#line 95
      b___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 112
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"};\n");
#line 113
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 114
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"unsigned long %s_updcrc(icrc, icp, icnt)\n",
          name);
#line 115
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    unsigned long icrc;\n");
#line 116
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    unsigned char *icp;\n");
#line 117
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    int icnt;\n");
#line 118
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"{\n");
  }
#line 119
  if (bits == 16) {
    {
#line 120
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#define M1 0xff\n");
#line 121
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#define M2 0xff00\n");
    }
  } else {
    {
#line 123
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#define M1 0xffffff\n");
#line 124
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#define M2 0xffffff00\n");
    }
  }
  {
#line 126
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    register unsigned long crc = icrc;\n");
#line 127
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    register unsigned char *cp = icp;\n");
#line 128
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    register int cnt = icnt;\n");
#line 129
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 130
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    while(cnt--) {\n");
  }
#line 131
  if (bits == 16) {
#line 132
    if (swapped) {
      {
#line 133
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\tcrc=((crc>>8)&M1)^crctab[(crc&0xff)^*cp++];\n");
      }
    } else {
      {
#line 136
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\tcrc=((crc<<8)&M2)^crctab[((crc>>8)&0xff)^*cp++];\n");
      }
    }
  } else
#line 140
  if (swapped) {
    {
#line 141
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\tcrc=((crc>>8)&M1)^crctab[(crc&0xff)^*cp++];\n");
    }
  } else {
    {
#line 144
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\tcrc=((crc<<8)&M2)^crctab[((crc>>24)&0xff)^*cp++];\n");
    }
  }
  {
#line 148
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    }\n");
#line 149
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 150
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    return(crc);\n");
#line 151
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"}\n");
#line 152
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 153
  fclose(fd);
  }
#line 154
  return;
}
}
