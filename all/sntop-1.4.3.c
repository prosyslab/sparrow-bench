/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.h"
struct hdc_ {
   char name[33] ;
   char host[33] ;
   char note[33] ;
   char *status ;
   struct hdc_ *next ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.h"
typedef struct hdc_ hdc;
#line 351 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 351 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 764
extern int start_color(void) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.h"
char *get(char *s , int n , char d , FILE *f ) ;
#line 52
void abortion(char const   *msg , int type ) ;
#line 53
void aborted(int ignore ) ;
#line 54
unsigned short sntop_exec(char *command ) ;
#line 55
void load_config(char *cfile , hdc **head ) ;
#line 56
void exec_alarm(char *command , char *name , char *host , char *status ) ;
#line 57
void start_html(char *file , FILE **hf , unsigned int refresh___0 ) ;
#line 58
void add_html(FILE *hf , char *name , char *status , char *comments ) ;
#line 59
void end_html(FILE *hf , unsigned int hosts , unsigned int up ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
int main(int argc , char **argv ) 
{ 
  char up_status[3] ;
  char down_status[5] ;
  char buf[78] ;
  char cfile[256] ;
  char hfile[256] ;
  unsigned int tmp ;
  char ping[21] ;
  unsigned int tmp___0 ;
  char action[64] ;
  char ch ;
  FILE *hf ;
  fd_set readfds ;
  struct timeval timeout___0 ;
  hdc *head ;
  hdc *current ;
  unsigned int up ;
  unsigned int refresh___0 ;
  unsigned int i ;
  unsigned short val ;
  unsigned int bold_attribute ;
  unsigned short flags ;
  struct option longopts[15] ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 62
  up_status[0] = (char )'U';
#line 62
  up_status[1] = (char )'P';
#line 62
  up_status[2] = (char )'\000';
#line 63
  down_status[0] = (char )'D';
#line 63
  down_status[1] = (char )'O';
#line 63
  down_status[2] = (char )'W';
#line 63
  down_status[3] = (char )'N';
#line 63
  down_status[4] = (char )'\000';
#line 66
  hfile[0] = (char )'s';
#line 66
  hfile[1] = (char )'n';
#line 66
  hfile[2] = (char )'t';
#line 66
  hfile[3] = (char )'o';
#line 66
  hfile[4] = (char )'p';
#line 66
  hfile[5] = (char )'.';
#line 66
  hfile[6] = (char )'h';
#line 66
  hfile[7] = (char )'t';
#line 66
  hfile[8] = (char )'m';
#line 66
  hfile[9] = (char )'l';
#line 66
  hfile[10] = (char )'\000';
#line 66
  tmp = 11U;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (tmp >= 256U) {
#line 66
      goto while_break;
    }
#line 66
    hfile[tmp] = (char)0;
#line 66
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  ping[0] = (char )'f';
#line 68
  ping[1] = (char )'p';
#line 68
  ping[2] = (char )'i';
#line 68
  ping[3] = (char )'n';
#line 68
  ping[4] = (char )'g';
#line 68
  ping[5] = (char )' ';
#line 68
  ping[6] = (char )'-';
#line 68
  ping[7] = (char )'r';
#line 68
  ping[8] = (char )' ';
#line 68
  ping[9] = (char )'1';
#line 68
  ping[10] = (char )' ';
#line 68
  ping[11] = (char )'-';
#line 68
  ping[12] = (char )'b';
#line 68
  ping[13] = (char )' ';
#line 68
  ping[14] = (char )'2';
#line 68
  ping[15] = (char )'4';
#line 68
  ping[16] = (char )' ';
#line 68
  ping[17] = (char )'-';
#line 68
  ping[18] = (char )'q';
#line 68
  ping[19] = (char )'\000';
#line 68
  tmp___0 = 20U;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (tmp___0 >= 21U) {
#line 68
      goto while_break___0;
    }
#line 68
    ping[tmp___0] = (char)0;
#line 68
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 71
  hf = (FILE *)((void *)0);
#line 74
  head = (hdc *)((void *)0);
#line 74
  current = (hdc *)((void *)0);
#line 76
  refresh___0 = 180U;
#line 79
  bold_attribute = 0U;
#line 80
  flags = (unsigned short)32;
#line 82
  longopts[0].name = "once";
#line 82
  longopts[0].has_arg = 0;
#line 82
  longopts[0].flag = (int *)0;
#line 82
  longopts[0].val = 'o';
#line 82
  longopts[1].name = "nocolor";
#line 82
  longopts[1].has_arg = 0;
#line 82
  longopts[1].flag = (int *)0;
#line 82
  longopts[1].val = 'c';
#line 82
  longopts[2].name = "ping";
#line 82
  longopts[2].has_arg = 0;
#line 82
  longopts[2].flag = (int *)0;
#line 82
  longopts[2].val = 'p';
#line 82
  longopts[3].name = "html";
#line 82
  longopts[3].has_arg = 0;
#line 82
  longopts[3].flag = (int *)0;
#line 82
  longopts[3].val = 'w';
#line 82
  longopts[4].name = "secure";
#line 82
  longopts[4].has_arg = 0;
#line 82
  longopts[4].flag = (int *)0;
#line 82
  longopts[4].val = 's';
#line 82
  longopts[5].name = "wfile";
#line 82
  longopts[5].has_arg = 1;
#line 82
  longopts[5].flag = (int *)0;
#line 82
  longopts[5].val = 'e';
#line 82
  longopts[6].name = "refresh";
#line 82
  longopts[6].has_arg = 1;
#line 82
  longopts[6].flag = (int *)0;
#line 82
  longopts[6].val = 'r';
#line 82
  longopts[7].name = "version";
#line 82
  longopts[7].has_arg = 0;
#line 82
  longopts[7].flag = (int *)0;
#line 82
  longopts[7].val = 'v';
#line 82
  longopts[8].name = "help";
#line 82
  longopts[8].has_arg = 0;
#line 82
  longopts[8].flag = (int *)0;
#line 82
  longopts[8].val = 'h';
#line 82
  longopts[9].name = "conf";
#line 82
  longopts[9].has_arg = 1;
#line 82
  longopts[9].flag = (int *)0;
#line 82
  longopts[9].val = 'f';
#line 82
  longopts[10].name = "alarm";
#line 82
  longopts[10].has_arg = 1;
#line 82
  longopts[10].flag = (int *)0;
#line 82
  longopts[10].val = 'a';
#line 82
  longopts[11].name = "log";
#line 82
  longopts[11].has_arg = 1;
#line 82
  longopts[11].flag = (int *)0;
#line 82
  longopts[11].val = 'l';
#line 82
  longopts[12].name = "byte";
#line 82
  longopts[12].has_arg = 1;
#line 82
  longopts[12].flag = (int *)0;
#line 82
  longopts[12].val = 'b';
#line 82
  longopts[13].name = "daemon";
#line 82
  longopts[13].has_arg = 0;
#line 82
  longopts[13].flag = (int *)0;
#line 82
  longopts[13].val = 'd';
#line 82
  longopts[14].name = (char const   *)0;
#line 82
  longopts[14].has_arg = 0;
#line 82
  longopts[14].flag = (int *)0;
#line 82
  longopts[14].val = 0;
#line 102
  tmp___1 = getenv("HOME");
#line 102
  snprintf((char */* __restrict  */)(cfile), (size_t )256, (char const   */* __restrict  */)"%s%s",
           tmp___1, "/.sntoprc");
  }
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 104
    tmp___4 = getopt_long(argc, (char * const  *)argv, "docpwse:f:r:vhb:a:l:", (struct option  const  *)(longopts),
                          (int *)0);
#line 104
    i = (unsigned int )tmp___4;
    }
#line 104
    if (! (i != 4294967295U)) {
#line 104
      goto while_break___1;
    }
    {
#line 106
    if (i == 100U) {
#line 106
      goto case_100;
    }
#line 109
    if (i == 111U) {
#line 109
      goto case_111;
    }
#line 113
    if (i == 99U) {
#line 113
      goto case_99;
    }
#line 116
    if (i == 112U) {
#line 116
      goto case_112;
    }
#line 119
    if (i == 119U) {
#line 119
      goto case_119;
    }
#line 122
    if (i == 115U) {
#line 122
      goto case_115;
    }
#line 125
    if (i == 101U) {
#line 125
      goto case_101;
    }
#line 128
    if (i == 102U) {
#line 128
      goto case_102;
    }
#line 131
    if (i == 114U) {
#line 131
      goto case_114;
    }
#line 134
    if (i == 97U) {
#line 134
      goto case_97;
    }
#line 138
    if (i == 108U) {
#line 138
      goto case_108;
    }
#line 142
    if (i == 118U) {
#line 142
      goto case_118;
    }
#line 147
    if (i == 98U) {
#line 147
      goto case_98;
    }
#line 150
    if (i == 104U) {
#line 150
      goto case_104;
    }
#line 150
    if (i == 63U) {
#line 150
      goto case_104;
    }
#line 150
    if (i == 58U) {
#line 150
      goto case_104;
    }
#line 105
    goto switch_break;
    case_100: /* CIL Label */ 
#line 107
    flags = (unsigned short )((int )flags ^ 64);
#line 108
    goto switch_break;
    case_111: /* CIL Label */ 
#line 110
    flags = (unsigned short )((int )flags ^ 4);
#line 111
    refresh___0 = 0U;
#line 112
    goto switch_break;
    case_99: /* CIL Label */ 
#line 114
    flags = (unsigned short )((int )flags ^ 32);
#line 115
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 117
    strcpy((char */* __restrict  */)(ping), (char const   */* __restrict  */)"ping -c 1 -s 8 -q");
    }
#line 118
    goto switch_break;
    case_119: /* CIL Label */ 
#line 120
    flags = (unsigned short )((int )flags ^ 1);
#line 121
    goto switch_break;
    case_115: /* CIL Label */ 
#line 123
    flags = (unsigned short )((int )flags ^ 2);
#line 124
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 126
    strncpy((char */* __restrict  */)(hfile), (char const   */* __restrict  */)optarg,
            (size_t )256);
    }
#line 127
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 129
    strncpy((char */* __restrict  */)(cfile), (char const   */* __restrict  */)optarg,
            (size_t )256);
    }
#line 130
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 132
    tmp___2 = atoi((char const   *)optarg);
#line 132
    refresh___0 = (unsigned int )tmp___2;
    }
#line 133
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 135
    flags = (unsigned short )((int )flags ^ 8);
#line 136
    strncpy((char */* __restrict  */)(action), (char const   */* __restrict  */)optarg,
            (size_t )64);
    }
#line 137
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 139
    flags = (unsigned short )((int )flags ^ 16);
#line 140
    strncpy((char */* __restrict  */)(action), (char const   */* __restrict  */)optarg,
            (size_t )64);
    }
#line 141
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 143
    printf((char const   */* __restrict  */)"\rsntop v1.4.3");
#line 144
    printf((char const   */* __restrict  */)" - a top-like console network status monitor\nRobert M. Love <rml@tech9.net>, Chris M. Rivera <cmrivera@ufl.edu>\n");
#line 145
    exit(0);
    }
#line 146
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 148
    tmp___3 = atoi((char const   *)optarg);
#line 148
    snprintf((char */* __restrict  */)(ping), (size_t )20, (char const   */* __restrict  */)"fping -r 1 -b %d -q",
             tmp___3);
    }
#line 149
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_58: /* CIL Label */ 
    {
#line 151
    printf((char const   */* __restrict  */)"\rsntop v1.4.3: Robert M. Love <rml@tech9.net>, Chris M. Rivera <cmrivera@ufl.edu>\n\n");
#line 152
    printf((char const   */* __restrict  */)"Usage: %s [FLAG(S)...]\n\n", *(argv + 0));
#line 153
    printf((char const   */* __restrict  */)" -d, --daemon           allow use as a daemon\n");
#line 154
    printf((char const   */* __restrict  */)" -o, --once\t\tpoll and display once, then exit\n");
#line 155
    printf((char const   */* __restrict  */)" -c, --nocolor\t\tdisable use of ncurses\' color\n");
#line 156
    printf((char const   */* __restrict  */)" -p, --ping\t\tuse \'ping\' in lieu of \'fping\'. MUCH SLOWER!\n");
#line 157
    printf((char const   */* __restrict  */)" -w, --html\t\tgenerate html output of results\n");
#line 158
    printf((char const   */* __restrict  */)" -s, --secure\t\tsecure mode: interactive commands are disabled\n");
#line 159
    printf((char const   */* __restrict  */)" -e, --wfile=file\toutput html to <file> instead of sntop.html\n");
#line 160
    printf((char const   */* __restrict  */)" -f, --conf=file\tread conf data from <file> instead of ~/.sntoprc.\n");
#line 161
    printf((char const   */* __restrict  */)"\t\t\tnote, sntop will still try to read from\n");
#line 162
    printf((char const   */* __restrict  */)"\t\t\t%s if <file> fails\n", "/usr/local/etc/sntoprc");
#line 163
    printf((char const   */* __restrict  */)" -r, --refresh=time\trefresh every <time> seconds instead of every %d\n",
           180);
#line 164
    printf((char const   */* __restrict  */)" -a, --alarm=action\twhen a site goes down, execute action\n");
#line 165
    printf((char const   */* __restrict  */)" -l, --log=action\twhen a site changes status, execute action\n");
#line 166
    printf((char const   */* __restrict  */)" -b, --byte=bytes\tbytes of ping data to send\n");
#line 167
    printf((char const   */* __restrict  */)" -v, --version\t\tdisplay version information and exit\n");
#line 168
    printf((char const   */* __restrict  */)" -h, --help\t\tdisplay this help and exit\n");
#line 169
    printf((char const   */* __restrict  */)"\nSee \'man sntop\'\n");
#line 170
    exit(0);
    }
#line 171
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 175
  signal(2, & aborted);
#line 177
  load_config(cfile, & head);
  }
#line 179
  if (! ((int )flags & 64)) {
    {
#line 180
    printf((char const   */* __restrict  */)"sntop v1.4.3 - loading ... ");
#line 181
    initscr();
    }
#line 183
    if ((int )flags & 32) {
      {
#line 183
      tmp___5 = has_colors();
      }
#line 183
      if (tmp___5) {
        {
#line 184
        start_color();
#line 185
        bold_attribute = (unsigned int )(1UL << 21);
#line 187
        init_pair((short)0, (short)0, (short)0);
#line 188
        init_pair((short)2, (short)2, (short)0);
#line 189
        init_pair((short)1, (short)1, (short)0);
#line 190
        init_pair((short)6, (short)6, (short)0);
#line 191
        init_pair((short)7, (short)7, (short)0);
#line 192
        init_pair((short)5, (short)5, (short)0);
#line 193
        init_pair((short)4, (short)4, (short)0);
#line 194
        init_pair((short)3, (short)3, (short)0);
        }
      }
    }
#line 196
    if (stdscr) {
#line 196
      stdscr->_attrs = (3UL << 8) | (unsigned long )bold_attribute;
    }
    {
#line 197
    printw("(sntop) simple network top\n");
    }
#line 198
    if (stdscr) {
#line 198
      stdscr->_attrs = 1UL << 16;
    }
    {
#line 199
    printw("%-16s  %-12s  %-32s\n", "HOST", "STATUS", "COMMENT");
    }
#line 200
    if (stdscr) {
#line 200
      stdscr->_attrs = 0UL;
    }
  }
  {
#line 203
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 204
    if (! ((int )flags & 64)) {
      {
#line 205
      wmove(stdscr, 2, 0);
#line 206
      wclrtobot(stdscr);
      }
    }
#line 209
    current = head;
#line 210
    up = 0U;
#line 210
    i = up;
#line 212
    if ((int )flags & 1) {
      {
#line 212
      start_html(hfile, & hf, refresh___0);
      }
    }
    {
#line 214
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 215
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s %s %s",
              ping, current->host, " 2> /dev/null > /dev/null");
#line 216
      val = sntop_exec(buf);
      }
#line 217
      if ((int )val == 127) {
        {
#line 218
        abortion("error, execution of (f)ping failed", 6);
        }
      } else
#line 219
      if ((int )val == 0) {
#line 221
        if ((int )flags & 16) {
#line 221
          if ((unsigned long )current->status == (unsigned long )(down_status)) {
            {
#line 222
            exec_alarm(action, current->name, current->host, up_status);
            }
          }
        }
#line 223
        current->status = up_status;
#line 224
        if (! ((int )flags & 64)) {
#line 224
          if (stdscr) {
#line 224
            stdscr->_attrs = (2UL << 8) | (unsigned long )bold_attribute;
          }
        }
#line 225
        up ++;
      } else {
#line 228
        if ((int )flags & 8) {
#line 228
          goto _L;
        } else
#line 228
        if ((int )flags & 16) {
          _L: /* CIL Label */ 
#line 228
          if ((unsigned long )current->status == (unsigned long )(up_status)) {
            {
#line 230
            exec_alarm(action, current->name, current->host, down_status);
            }
          }
        }
#line 231
        current->status = down_status;
#line 232
        if (! ((int )flags & 64)) {
#line 232
          if (stdscr) {
#line 232
            stdscr->_attrs = (1UL << 8) | (unsigned long )bold_attribute;
          }
        }
      }
#line 234
      if (! ((int )flags & 64)) {
        {
#line 234
        printw("%-16s  %-12s  %-32s\n", current->name, current->status, current->note);
        }
      }
#line 235
      if ((int )flags & 1) {
        {
#line 235
        add_html(hf, current->name, current->status, current->note);
        }
      }
#line 236
      i ++;
#line 237
      current = current->next;
#line 214
      if (! ((unsigned long )current->next != (unsigned long )((void *)0))) {
#line 214
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 240
    if (! ((int )flags & 64)) {
#line 241
      if (stdscr) {
#line 241
        stdscr->_attrs = (6UL << 8) | (unsigned long )bold_attribute;
      }
      {
#line 242
      printw("\n\n%u hosts polled: %u up, %u down", i, up, i - up);
      }
#line 243
      if (stdscr) {
#line 243
        stdscr->_attrs = (3UL << 8) | (unsigned long )bold_attribute;
      }
      {
#line 244
      wrefresh(stdscr);
      }
    }
#line 247
    if ((int )flags & 1) {
      {
#line 247
      end_html(hf, i, up);
      }
    }
#line 249
    if (! ((int )flags & 64)) {
      {
#line 251
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 251
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.__fds_bits[0]): "memory");
#line 251
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 252
      readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 253
      timeout___0.tv_sec = (__time_t )refresh___0;
#line 254
      timeout___0.tv_usec = (__suseconds_t )0;
#line 255
      tmp___8 = select(1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout___0));
      }
#line 255
      if (tmp___8 > 0) {
        {
#line 256
        tmp___6 = read(0, (void *)(& ch), (size_t )1);
        }
#line 256
        if (tmp___6 != 1L) {
          {
#line 257
          abortion("error, stdin cannot be read", 4);
          }
        }
#line 258
        if (! ((int )flags & 2)) {
          {
#line 260
          if ((int )ch == 113) {
#line 260
            goto case_113;
          }
#line 263
          if ((int )ch == 114) {
#line 263
            goto case_114___0;
          }
#line 270
          if ((int )ch == 119) {
#line 270
            goto case_119___0;
          }
#line 277
          goto switch_default;
          case_113: /* CIL Label */ 
#line 261
          flags = (unsigned short )((int )flags ^ 4);
#line 262
          goto switch_break___0;
          case_114___0: /* CIL Label */ 
          {
#line 264
          printw("\nreloading conf data...");
#line 265
          wrefresh(stdscr);
#line 266
          load_config(cfile, & head);
#line 267
          printw("done\nrefreshing...");
#line 268
          wrefresh(stdscr);
          }
#line 269
          goto switch_break___0;
          case_119___0: /* CIL Label */ 
          {
#line 271
          flags = (unsigned short )((int )flags ^ 1);
#line 272
          load_config(cfile, & head);
          }
#line 273
          if ((int )flags & 1) {
#line 273
            tmp___7 = "ON";
          } else {
#line 273
            tmp___7 = "OFF";
          }
          {
#line 273
          printw("\nhtml generation toggled %s", tmp___7);
#line 275
          wrefresh(stdscr);
          }
#line 276
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 278
          printw("\nrefreshing...");
#line 279
          wrefresh(stdscr);
          }
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 284
      sleep(refresh___0);
      }
    }
#line 203
    if (! (! ((int )flags & 4))) {
#line 203
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 286
  if (! ((int )flags & 64)) {
    {
#line 286
    endwin();
    }
  }
  {
#line 287
  exit(0);
  }
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
char *get(char *s , int n , char d , FILE *f ) 
{ 
  int c ;
  char *cs ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 298
  c = 0;
#line 299
  cs = s;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    n --;
#line 301
    if (n > 0) {
      {
#line 301
      c = _IO_getc(f);
      }
#line 301
      if (c != -1) {
#line 301
        tmp = cs;
#line 301
        cs ++;
#line 301
        tmp___0 = (char )c;
#line 301
        *tmp = tmp___0;
#line 301
        if ((int )tmp___0 != (int )d) {
#line 301
          if (! (c != 35)) {
#line 301
            goto while_break;
          }
        } else {
#line 301
          goto while_break;
        }
      } else {
#line 301
        goto while_break;
      }
    } else {
#line 301
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (c == (int )d) {
#line 303
    cs --;
#line 303
    *cs = (char )'\000';
  } else
#line 303
  if (c == 35) {
#line 303
    cs --;
#line 303
    *cs = (char )'\000';
  } else {
#line 304
    *cs = (char )'\000';
  }
  {
#line 307
  cs = strchr((char const   *)s, '\000');
  }
  {
#line 308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 308
    cs --;
#line 308
    if (! ((int )*cs == 32)) {
#line 308
      if (! ((int )*cs == 9)) {
#line 308
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  cs ++;
#line 309
  *cs = (char )'\000';
  {
#line 311
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 311
    if (c != 10) {
#line 311
      if (! (c != -1)) {
#line 311
        goto while_break___1;
      }
    } else {
#line 311
      goto while_break___1;
    }
    {
#line 311
    c = _IO_getc(f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 313
  if (c == -1) {
#line 313
    tmp___1 = (char *)((void *)0);
  } else {
#line 313
    tmp___1 = s;
  }
#line 313
  return (tmp___1);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void abortion(char const   *msg , int type ) 
{ 


  {
  {
#line 318
  endwin();
#line 319
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sntop: %s\n",
          msg);
#line 320
  exit(type);
  }
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void aborted(int ignore ) 
{ 


  {
  {
#line 324
  abortion("caught SIGINT -- aborted", 5);
  }
#line 324
  return;
}
}
#line 335
extern char **environ ;
#line 333 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
unsigned short sntop_exec(char *command ) 
{ 
  int pid ;
  int status ;
  char *argv[4] ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;
  __pid_t tmp ;

  {
  {
#line 337
  pid = fork();
  }
#line 338
  if (pid == -1) {
#line 338
    return ((unsigned short)127);
  }
#line 339
  if (pid == 0) {
    {
#line 341
    argv[0] = (char *)"sh";
#line 342
    argv[1] = (char *)"-c";
#line 343
    argv[2] = command;
#line 344
    argv[3] = (char *)((void *)0);
#line 345
    execve("/bin/sh", (char * const  *)(argv), (char * const  *)environ);
#line 346
    exit(127);
    }
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    tmp = waitpid(pid, & status, 0);
    }
#line 349
    if (tmp == -1) {
#line 350
      return ((unsigned short)127);
    } else {
#line 351
      __constr_expr_1.__in = status;
#line 351
      if ((__constr_expr_1.__i & 127) == 0) {
#line 351
        __constr_expr_0.__in = status;
#line 351
        return ((unsigned short )((__constr_expr_0.__i & 65280) >> 8));
      } else {
#line 352
        return ((unsigned short)127);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void load_config(char *cfile , hdc **head ) 
{ 
  char *field[3] ;
  char buf[33] ;
  char up_status[3] ;
  int i ;
  FILE *cf ;
  hdc *current ;
  hdc *last ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 360
  up_status[0] = (char )'U';
#line 360
  up_status[1] = (char )'P';
#line 360
  up_status[2] = (char )'\000';
#line 363
  current = (hdc *)((void *)0);
#line 363
  last = (hdc *)((void *)0);
#line 365
  cf = fopen((char const   */* __restrict  */)cfile, (char const   */* __restrict  */)"r");
  }
#line 365
  if ((unsigned long )cf == (unsigned long )((void *)0)) {
    {
#line 367
    strncpy((char */* __restrict  */)cfile, (char const   */* __restrict  */)"/usr/local/etc/sntoprc",
            (size_t )256);
#line 368
    cf = fopen((char const   */* __restrict  */)cfile, (char const   */* __restrict  */)"r");
    }
#line 368
    if ((unsigned long )cf == (unsigned long )((void *)0)) {
      {
#line 369
      abortion("error, cannot open systen or user conf file", 1);
      }
    }
  }
#line 372
  if ((unsigned long )*head != (unsigned long )((void *)0)) {
#line 374
    current = *head;
    {
#line 375
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 376
      last = current->next;
#line 377
      free((void *)current);
#line 378
      current = last;
      }
#line 375
      if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 375
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 380
    *head = (hdc *)((void *)0);
  }
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 383
    tmp___2 = feof(cf);
    }
#line 383
    if (tmp___2) {
#line 383
      goto while_break___0;
    }
    {
#line 384
    tmp = malloc(sizeof(hdc ));
#line 384
    current = (hdc *)tmp;
    }
#line 384
    if ((unsigned long )current == (unsigned long )((void *)0)) {
      {
#line 385
      abortion("error, malloc() returned NULL", 2);
      }
    }
#line 386
    i = 0;
#line 387
    field[0] = current->name;
#line 388
    field[1] = current->host;
#line 389
    field[2] = current->note;
#line 390
    if ((unsigned long )*head == (unsigned long )((void *)0)) {
#line 390
      *head = current;
#line 390
      last = current;
    }
#line 391
    last->next = current;
#line 392
    last = current;
#line 393
    current->next = (struct hdc_ *)((void *)0);
#line 394
    current->status = up_status;
    {
#line 395
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 395
      if (! (i < 3)) {
#line 395
        goto while_break___1;
      }
      {
#line 396
      tmp___0 = get(buf, 33, (char )'\n', cf);
      }
#line 396
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 396
        goto while_break___1;
      }
#line 397
      if (buf[0]) {
        {
#line 398
        tmp___1 = i;
#line 398
        i ++;
#line 398
        strncpy((char */* __restrict  */)field[tmp___1], (char const   */* __restrict  */)(buf),
                (size_t )33);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  fclose(cf);
  }
#line 402
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void exec_alarm(char *command , char *name , char *host , char *status ) 
{ 
  int pid ;
  char *argv[5] ;
  int tmp ;

  {
  {
#line 409
  pid = fork();
  }
#line 410
  if (pid == -1) {
#line 410
    return;
  }
#line 411
  if (pid == 0) {
    {
#line 413
    argv[1] = name;
#line 414
    argv[2] = host;
#line 415
    argv[3] = status;
#line 416
    argv[4] = (char *)((void *)0);
#line 417
    tmp = execve((char const   *)command, (char * const  *)(argv), (char * const  *)environ);
    }
#line 417
    if (tmp == -1) {
      {
#line 418
      abortion("error executing alarm command", 7);
      }
    }
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void start_html(char *file , FILE **hf , unsigned int refresh___0 ) 
{ 
  FILE *tmp ;

  {
  {
#line 424
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
#line 424
  *hf = tmp;
  }
#line 424
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 425
    abortion("error, cannot open html file", 3);
    }
  }
  {
#line 427
  fputs((char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n",
        (FILE */* __restrict  */)*hf);
#line 428
  fputs((char const   */* __restrict  */)"<HTML>\n<HEAD>\n", (FILE */* __restrict  */)*hf);
  }
#line 429
  if (refresh___0) {
    {
#line 429
    fprintf((FILE */* __restrict  */)*hf, (char const   */* __restrict  */)"<META http-equiv=\"Refresh\" content=\"%d\">\n",
            refresh___0);
    }
  }
  {
#line 430
  fputs((char const   */* __restrict  */)"<TITLE>sntop network status</TITLE>\n</HEAD>\n",
        (FILE */* __restrict  */)*hf);
#line 431
  fputs((char const   */* __restrict  */)"<BODY TEXT=\"#000000\" BGCOLOR=\"#FFFFFF\">\n\n",
        (FILE */* __restrict  */)*hf);
#line 432
  fputs((char const   */* __restrict  */)"<P><B>sntop network status - automatically generated html</B></P><BR>\n\n",
        (FILE */* __restrict  */)*hf);
#line 433
  fputs((char const   */* __restrict  */)"<TABLE BORDER CELLPADDING=5>\n<TR VALIGN=top>\n",
        (FILE */* __restrict  */)*hf);
#line 434
  fputs((char const   */* __restrict  */)"<TD BGCOLOR=#EEEEEE><B>Host</B></TD>\n<TD BGCOLOR=#EEEEEE>",
        (FILE */* __restrict  */)*hf);
#line 435
  fputs((char const   */* __restrict  */)"<B>Status</B></TD>\n<TD BGCOLOR=#EEEEEE><B>Comments</B></TD>\n",
        (FILE */* __restrict  */)*hf);
#line 436
  fputs((char const   */* __restrict  */)"</TR>\n", (FILE */* __restrict  */)*hf);
  }
#line 437
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void add_html(FILE *hf , char *name , char *status , char *comments ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 441
  fprintf((FILE */* __restrict  */)hf, (char const   */* __restrict  */)"<TR>\n<TD BGCOLOR=#EEEEEE>%s</TD>\n",
          name);
#line 442
  tmp___1 = strcmp((char const   *)status, "UP");
  }
#line 442
  if (tmp___1) {
#line 442
    tmp___0 = "\"#CC0000\">DOWN";
  } else {
#line 442
    tmp___0 = "\"#00BB00\">UP";
  }
  {
#line 442
  fprintf((FILE */* __restrict  */)hf, (char const   */* __restrict  */)"<TD BGCOLOR=#EEEEEE><B><FONT COLOR=%s",
          tmp___0);
#line 444
  fprintf((FILE */* __restrict  */)hf, (char const   */* __restrict  */)"</FONT></B></TD>\n<TD BGCOLOR=#EEEEEE>%s</TD>\n",
          comments);
  }
#line 445
  return;
}
}
#line 448
extern char *tzname[2] ;
#line 457
extern int ( /* missing proto */  ctime)() ;
#line 456
extern int ( /* missing proto */  time)() ;
#line 447 "/home/june/repo/benchmarks/collector/temp/sntop-1.4.3/sntop.c"
void end_html(FILE *hf , unsigned int hosts , unsigned int up ) 
{ 
  time_t t ;
  char *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 452
  fputs((char const   */* __restrict  */)"</TABLE>\n\n", (FILE */* __restrict  */)hf);
#line 453
  fprintf((FILE */* __restrict  */)hf, (char const   */* __restrict  */)"<P><B>%u</B> hosts polled: <B>%u</B> up, <B>%u</B> down</P><BR>\n\n",
          hosts, up, hosts - up);
#line 456
  tmp___0 = time(& t);
  }
#line 456
  if ((time_t )tmp___0 != -1L) {
    {
#line 457
    tmp = ctime(& t);
#line 457
    s = (char *)tmp;
    }
#line 457
    if (s) {
#line 457
      if (tzname[0]) {
        {
#line 458
        fprintf((FILE */* __restrict  */)hf, (char const   */* __restrict  */)"<P><SMALL>Last updated: %s %s</SMALL></P>\n\n",
                s, tzname[0]);
        }
      }
    }
  }
  {
#line 460
  fputs((char const   */* __restrict  */)"<P><SMALL>Generated by <A HREF=\"http://sntop.sourceforge.net\">",
        (FILE */* __restrict  */)hf);
#line 461
  fputs((char const   */* __restrict  */)"sntop v1.4.3</A> - Robert M. Love <rml@tech9.net>, Chris M. Rivera <cmrivera@ufl.edu></SMALL></P>\n\n",
        (FILE */* __restrict  */)hf);
#line 462
  fputs((char const   */* __restrict  */)"</BODY>\n</HTML>", (FILE */* __restrict  */)hf);
#line 463
  fclose(hf);
  }
#line 464
  return;
}
}
