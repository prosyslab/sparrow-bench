/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 15 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten.c"
struct extnode {
   char *ext ;
   struct extnode *next ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_10 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_11 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_10 __wait_terminated ;
   struct __anonstruct___wait_stopped_11 __wait_stopped ;
};
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 37 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef unsigned long long ulonglong;
#line 160 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct __anonstruct_PStat_53 {
   unsigned long PSt_dev ;
   unsigned long PSt_ino ;
   unsigned long PSt_mode ;
   unsigned long PSt_uid ;
   unsigned long PSt_gid ;
   unsigned long PSt_nlink ;
   unsigned long PSt_rdev ;
   unsigned long PSt_mtime ;
   unsigned long PSt_size ;
};
#line 160 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct __anonstruct_PStat_53 PStat;
#line 173 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct __anonstruct_PHStat_54 {
   unsigned long PSt_dev ;
   unsigned long long PSt_ino ;
   unsigned long PSt_mode ;
   unsigned long PSt_uid ;
   unsigned long PSt_gid ;
   unsigned long PSt_nlink ;
   unsigned long long PSt_rdev ;
   unsigned long long PSt_mtime ;
   unsigned long long PSt_size ;
};
#line 173 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct __anonstruct_PHStat_54 PHStat;
#line 270 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct group Group;
#line 271 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct passwd Passwd;
#line 272 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct tm Time;
#line 279 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct __anonstruct_Stat_55 {
   struct stat sb_stat ;
   char sb_link[1024] ;
   ino_t ino_orig ;
};
#line 279 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct __anonstruct_Stat_55 Stat;
#line 326 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct __anonstruct_Binary_56 {
   short b_dev ;
   unsigned short b_ino ;
   unsigned short b_mode ;
   unsigned short b_uid ;
   unsigned short b_gid ;
   short b_nlink ;
   short b_rdev ;
   unsigned short b_mtime[2] ;
   unsigned short b_name ;
   unsigned short b_size[2] ;
};
#line 326 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct __anonstruct_Binary_56 Binary;
#line 343 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct child {
   struct child *c_forw ;
   int c_pid ;
   int c_flags ;
   int c_status ;
};
#line 343 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct child Child;
#line 360 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct name {
   struct name *p_forw ;
   struct name *p_back ;
   char *p_name ;
};
#line 360 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct name Path;
#line 371 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct link {
   struct link *l_forw ;
   struct link *l_back ;
   dev_t l_dev ;
   ino_t l_ino ;
   ino_t l_ino_ar ;
   unsigned short l_nlink ;
   time_t l_mtime ;
   unsigned short l_mode ;
   off_t l_size ;
   Path *l_path ;
};
#line 371 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct link Link;
#line 389 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
struct dir {
   struct dir *d_forw ;
   time_t d_mtime ;
   char *d_name ;
};
#line 389 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
typedef struct dir Dir;
#line 47 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
struct pattern {
   struct pattern *p_forw ;
   char *p_str ;
   int p_len ;
   int p_ptype ;
   int p_noglob ;
};
#line 47 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
typedef struct pattern Pattern;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 438 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
int namecmp_ext(char *name ) ;
#line 521
int extcasesens ;
#line 529
int readcompexts(char *compextsfile ) ;
#line 2 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de1  =    {(char *)".Z", (struct extnode *)((void *)0)};
#line 3 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de2  =    {(char *)".z", & de1};
#line 4 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de3  =    {(char *)".gz", & de2};
#line 5 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de4  =    {(char *)".bz2", & de3};
#line 6 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de5  =    {(char *)".tgz", & de4};
#line 7 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de6  =    {(char *)".arc", & de5};
#line 8 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de7  =    {(char *)".zip", & de6};
#line 9 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de8  =    {(char *)".rar", & de7};
#line 10 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de9  =    {(char *)".lzh", & de8};
#line 11 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de10  =    {(char *)".lha", & de9};
#line 12 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de11  =    {(char *)".uc2", & de10};
#line 13 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de12  =    {(char *)".tpz", & de11};
#line 14 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de13  =    {(char *)".taz", & de12};
#line 15 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de14  =    {(char *)".tgz", & de13};
#line 16 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de15  =    {(char *)".rpm", & de14};
#line 17 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de16  =    {(char *)".zoo", & de15};
#line 18 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de17  =    {(char *)".deb", & de16};
#line 19 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de18  =    {(char *)".gif", & de17};
#line 20 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de19  =    {(char *)".jpeg", & de18};
#line 21 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de20  =    {(char *)".jpg", & de19};
#line 22 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de21  =    {(char *)".tif", & de20};
#line 23 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de22  =    {(char *)".tiff", & de21};
#line 24 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de23  =    {(char *)".png", & de22};
#line 25 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de24  =    {(char *)".pdf", & de23};
#line 26 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de25  =    {(char *)".arj", & de24};
#line 27 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de26  =    {(char *)".avi", & de25};
#line 28 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de27  =    {(char *)".bgb", & de26};
#line 29 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de28  =    {(char *)".cab", & de27};
#line 30 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de29  =    {(char *)".cpn", & de28};
#line 31 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de30  =    {(char *)".hqx", & de29};
#line 32 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de31  =    {(char *)".jar", & de30};
#line 33 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de32  =    {(char *)".mp3", & de31};
#line 34 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de33  =    {(char *)".mpg", & de32};
#line 35 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de34  =    {(char *)".mpq", & de33};
#line 36 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de35  =    {(char *)".pic", & de34};
#line 37 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de36  =    {(char *)".pkz", & de35};
#line 38 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de37  =    {(char *)".psn", & de36};
#line 39 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de38  =    {(char *)".sit", & de37};
#line 40 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de39  =    {(char *)".ogg", & de38};
#line 41 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode de40  =    {(char *)".smk", & de39};
#line 42 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten_default.h"
struct extnode *compexts  =    & de40;
#line 25 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten.c"
int readcompexts(char *compextsfile ) 
{ 
  FILE *infile ;
  char ex[81] ;
  int c ;
  struct extnode *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 32
  if ((int )*(compextsfile + 0) == 43) {
#line 32
    compextsfile ++;
  } else {
#line 32
    compexts = (struct extnode *)((void *)0);
  }
  {
#line 34
  infile = fopen((char const   */* __restrict  */)compextsfile, (char const   */* __restrict  */)"r");
  }
#line 35
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read configuration file %s\n",
            compextsfile);
    }
#line 40
    return (0);
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    tmp___2 = fscanf((FILE */* __restrict  */)infile, (char const   */* __restrict  */)"%80s",
                     ex);
    }
#line 43
    if (! (tmp___2 != -1)) {
#line 43
      goto while_break;
    }
#line 45
    if ((int )ex[0] == 35) {
      {
#line 47
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 48
        c = fgetc(infile);
        }
#line 49
        if (c == -1) {
          {
#line 49
          fclose(infile);
          }
#line 49
          return (1);
        }
#line 47
        if (! (c != 10)) {
#line 47
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 51
      goto while_continue;
    }
    {
#line 54
    tmp___0 = malloc(sizeof(struct extnode ));
#line 54
    tmp = (struct extnode *)tmp___0;
    }
#line 55
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___1 = strdup((char const   *)(ex));
#line 56
    tmp->ext = tmp___1;
    }
#line 56
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 56
      goto while_break;
    }
#line 57
    tmp->next = compexts;
#line 58
    compexts = tmp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  fclose(infile);
  }
#line 62
  return (1);
}
}
#line 65 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/exten.c"
int matchcompext(char *s ) 
{ 
  struct extnode *p ;
  size_t sl ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 70
  p = compexts;
#line 71
  sl = strlen((char const   *)s);
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 73
      goto while_break;
    }
    {
#line 75
    tmp___3 = strlen((char const   *)p->ext);
    }
#line 75
    if (sl >= tmp___3) {
#line 77
      if (extcasesens) {
        {
#line 79
        tmp = strlen((char const   *)p->ext);
#line 79
        tmp___0 = strcmp((char const   *)((s + sl) - tmp), (char const   *)p->ext);
        }
#line 79
        if (tmp___0 == 0) {
#line 79
          return (1);
        }
      } else {
        {
#line 83
        tmp___1 = strlen((char const   *)p->ext);
#line 83
        tmp___2 = strcasecmp((char const   *)((s + sl) - tmp___1), (char const   *)p->ext);
        }
#line 83
        if (tmp___2 == 0) {
#line 83
          return (1);
        }
      }
    }
#line 86
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___4 = namecmp_ext(s);
  }
#line 89
  if (tmp___4 == 0) {
#line 89
    return (1);
  }
#line 91
  return (0);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 483
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                             __uid_t __owner ,
                                                                                             __gid_t __group ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 598
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) nice)(int __inc ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 717
extern int system(char const   *__command ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                                            __mode_t __mode ,
                                                                                            __dev_t __dev ) ;
#line 350
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 42 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
int zipfdfd ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 195
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode )  __asm__("creat64")  ;
#line 401 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
void copyin(char **av ) ;
#line 402
void copyout(char **av ) ;
#line 403
void compressfile(int *fdp , char *name , Stat *asb , int *cratio ) ;
#line 404
int dirchg(char *name , char *local ) ;
#line 405
int dirmake(char *name , Stat *asb ) ;
#line 406
int dirneed(char *name ) ;
#line 407
void fatal(char *what , char *why ) ;
#line 408
void goodbye(int status ) ;
#line 409
void in(char **av ) ;
#line 410
void inalloc(unsigned int len ) ;
#line 411
int inascii(char *magic , char *name , Stat *asb ) ;
#line 412
int inascii2(char *magic , char *name , Stat *asb ) ;
#line 413
int inascii3(char *magic , char *name , Stat *asb ) ;
#line 414
int inavail(char **bufp , unsigned int *lenp ) ;
#line 415
int inbinary(char *magic , char *name , Stat *asb ) ;
#line 416
int indata(int fd , off_t size , char *name ) ;
#line 417
int inentry(char *name , Stat *asb ) ;
#line 418
int infill(void) ;
#line 419
int inhead(char *name , Stat *asb ) ;
#line 420
int inread(char *dst , unsigned int len ) ;
#line 421
int inskip(off_t len ) ;
#line 422
int inswab(char *magic , char *name , Stat *asb ) ;
#line 423
int lineget(FILE *stream , char *buf , int bufsize ) ;
#line 424
void linkalso(Link *linkp , char *name ) ;
#line 425
Link *linkfrom(Stat *asb , int installing ) ;
#line 426
void linkleft(void) ;
#line 427
Link *linkto(char *name , Stat *asb ) ;
#line 431
char *memget(unsigned int len ) ;
#line 432
char *memstr(char *str ) ;
#line 436
void nameadd(char *name , int ptype ) ;
#line 437
int namecmp(char *name , Stat *asb ) ;
#line 439
int nameopt(char *begin ) ;
#line 440
void next(int mode , char *why ) ;
#line 441
void nextask(char *msg___0 , char *answer , int limit ) ;
#line 442
void nextclos(void) ;
#line 443
int nextopen(int mode ) ;
#line 444
int openin(char *name , char *fsname , Stat *asb , int *cratio ) ;
#line 445
int openotty(char *name , Stat *asb , Link *linkp , int ispass , int dozflag ) ;
#line 446
int openqtty(void) ;
#line 447
int options(int ac , char **av , char *proto ) ;
#line 448
void out(char **av ) ;
#line 449
void outalloc(size_t len ) ;
#line 450
size_t outavail(char **bufp ) ;
#line 451
int outdata(int fd , char *name , off_t size ) ;
#line 453
void outdatazip(int fd , char *name , off_t size ) ;
#line 454
void waitforgzip(void) ;
#line 455
void outdatamem(char *name , off_t size ) ;
#line 456
void memreset(void) ;
#line 457
int memread(char *buf , int count ) ;
#line 458
void memfree(void) ;
#line 459
int nameaddfile(char *fname , int ptype , int parsewith0 ) ;
#line 461
void outeof(char *name , unsigned int namelen ) ;
#line 462
void outflush(int done ) ;
#line 463
void outhead(char *name , Stat *asb ) ;
#line 464
void outhead2(char *name , Stat *asb ) ;
#line 465
void outhead3(char *name , Stat *asb ) ;
#line 466
void outpad(off_t pad ) ;
#line 467
void outwait(void) ;
#line 468
void outwrite(char *idx , unsigned int len ) ;
#line 469
void pass(char **av ) ;
#line 470
void passdata(char *from , int ifd , char *to , int ofd ) ;
#line 471
int passitem(char *from , Stat *asb , int ifd , char **dir ) ;
#line 472
int pipechld(int mode , int *pfd ) ;
#line 473
int pipeopen(int mode ) ;
#line 474
void pipewait(void) ;
#line 475
void prsize(FILE *stream , ulonglong size ) ;
#line 476
void readcheck(char **av ) ;
#line 477
void process_arname(char *template ) ;
#line 484
ssize_t fswrite(int fd , char *buf , size_t len ) ;
#line 485
char *syserr(void) ;
#line 486
void toc(char **av ) ;
#line 487
void tocentry(char *name , Stat *asb ) ;
#line 488
void tocmode(mode_t mode ) ;
#line 489
void usage(void) ;
#line 490
void verify(int error ) ;
#line 491
int warn(char *what , char *why ) ;
#line 492
int warn_nocount(char *what , char *why ) ;
#line 493
int warnarch(char *msg___0 , off_t adjust ) ;
#line 494
int writedisk(int realwrite ) ;
#line 495
int xfork(char *what , int die ) ;
#line 496
void xpause(void) ;
#line 497
int xwait(int pid , char *what , int compstat2 ) ;
#line 498
void mail(char *who , int vol , char *archive ) ;
#line 500
ssize_t writeall(int fd , char const   *buf , size_t count ) ;
#line 501
int incheckentry(char *name , Stat *asb ) ;
#line 502
int incheckdata(int fd , off_t size , char *name , Stat *asb , int comp ) ;
#line 504
int opencontrolscript(char *name ) ;
#line 506
int openincheck(char *name , Stat *asb , int *comp , int dozflag ) ;
#line 507
void mayberewind(void) ;
#line 509
void add_arg(char *arg ) ;
#line 510
char *compress_arg_list[102] ;
#line 512 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
short lflag  ;
#line 513 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
short hflag  ;
#line 515
int gzipfactor ;
#line 516
off_t maxmem ;
#line 517
long compthreshold ;
#line 518
int ignoreslash ;
#line 519 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
short Zflag  ;
#line 520
int arfd ;
#line 523
int forceZflag ;
#line 524
char *compressprog ;
#line 525
int compressargs ;
#line 526
int rewindfd ;
#line 527
char *ignorewarnings ;
#line 531
ulonglong optsize(char *str ) ;
#line 532
void update_aruntil(void) ;
#line 533
ulonglong maxsizetocompress ;
#line 534
short noglob ;
#line 535 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
short flag0  ;
#line 240 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short Fflag  ;
#line 245 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short verifyflag  ;
#line 246 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short verifycnt  ;
#line 250 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short aflag  ;
#line 251 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short dflag  ;
#line 252 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short fflag  ;
#line 253 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short gflag  ;
#line 255 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short jflag  ;
#line 256 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short kflag  ;
#line 258 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short mflag  ;
#line 259 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short nflag  ;
#line 260 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short uflag  ;
#line 261 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short vflag  ;
#line 262 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short xflag  ;
#line 263 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short zflag  ;
#line 265 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short Jflag  =    (short)0;
#line 266 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short hidequit  ;
#line 267 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short abspaths  ;
#line 268 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned int arbsize  =    5120U;
#line 269 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short areof  ;
#line 270 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int arfd  =    -1;
#line 271 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong arleft  ;
#line 272 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *arname  ;
#line 273 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned int arpad  ;
#line 274 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char arspec[1024]  ;
#line 275 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char proc_arname[1034]  ;
#line 276 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong aruntil  =    (ulonglong )0;
#line 277 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int sflagused  =    0;
#line 278 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int roundaruntil  =    1;
#line 279 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong maxsizetocompress  =    (ulonglong )209715200L;
#line 280 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int askfornext  =    0;
#line 281 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned int arvolume  =    1U;
#line 282 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
off_t buflen  ;
#line 283 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *buffer  ;
#line 284 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *bufidx  ;
#line 285 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *bufend  ;
#line 286 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Child *children  ;
#line 287 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *formatcmd  =    (char *)"fdformat /dev/fd0H1440";
#line 288 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
gid_t gid  ;
#line 289 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Link *linkbase[1024]  ;
#line 290 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned char ino16bitused[8192]  ;
#line 291 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ino_t freshino  =    (ino_t )0;
#line 292 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
FILE *logfile  =    (FILE *)((void *)0);
#line 293 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned short mask  ;
#line 294 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *myname  ;
#line 297 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int outpid  ;
#line 298 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char pwd[1024]  ;
#line 299 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int pipepid  ;
#line 300 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
time_t timenow  ;
#line 301 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
time_t timewait  ;
#line 302 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong total  ;
#line 303 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int ttyf  =    -1;
#line 304 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
uid_t uid  ;
#line 305 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int uncompressrun  =    0;
#line 306 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char uncompto[1024]  ;
#line 307 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int anycorrupt  =    0;
#line 308 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int warnings  =    0;
#line 309 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int printbytepos  =    0;
#line 310 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong bytepos  ;
#line 311 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *controlscript  =    (char *)((void *)0);
#line 312 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *promptscript  =    (char *)((void *)0);
#line 313 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned short extfmt  =    (unsigned short)0;
#line 314 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned short cpiocompat  =    (unsigned short)0;
#line 315 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
unsigned short cpiowarned  =    (unsigned short)0;
#line 316 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *email  =    (char *)((void *)0);
#line 317 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int rewindfd  =    -1;
#line 319 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *ignorewarnings  =    (char *)"mc";
#line 320 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *aruntil_string  =    (char *)((void *)0);
#line 321 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int extcasesens  =    0;
#line 322 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Dir *DirP  =    (Dir *)((void *)0);
#line 323 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char firstfilename[1024]  = {      (char )'\000'};
#line 324 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int useoutmodetoc  =    0;
#line 325 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
short noglob  =    (short)0;
#line 327 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int main(int ac , char **av ) 
{ 
  register int c ;
  register unsigned int group ;
  void (*fn)(char ** ) ;
  time_t timedone ;
  char remote[1024] ;
  char *exitmsg ;
  int status ;
  Stat tmpstat ;
  __mode_t tmp ;
  ulonglong tmp___0 ;
  ulonglong tmp___1 ;
  ulonglong tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ulonglong tmp___6 ;
  ulonglong tmp___7 ;
  ulonglong tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ulonglong tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  register char *colon ;
  register char *perc ;
  register char *equal ;
  char *host ;
  register int isoutput ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  void *tmp___36 ;
  char const   *tmp___37 ;
  register FILE *stream ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char *tmp___43 ;

  {
  {
#line 330
  group = 1U;
#line 331
  fn = (void (*)(char ** ))((void *)0);
#line 343
  myname = strrchr((char const   *)*av, '/');
  }
#line 343
  if (myname) {
#line 344
    myname ++;
  } else {
#line 346
    myname = *av;
  }
  {
#line 347
  tmp = umask((__mode_t )0);
#line 347
  mask = (unsigned short )tmp;
#line 348
  uid = getuid();
#line 349
  gid = getgid();
  }
#line 350
  if (uid == 0U) {
#line 351
    xflag = (short)1;
  }
  {
#line 354
  signal(13, (void (*)(int  ))1);
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    c = options(ac, av, (char *)"aioprtIOVCb:c:de:fghjklmns:uvxXy:Y:zFKZL:R:qAE:G:M:w:W:T:SBD:P:Q:U4JH:0@:N:3:1:92:56:7");
    }
#line 359
    if (! c) {
#line 359
      goto while_break;
    }
    {
#line 365
    if (c == 114) {
#line 365
      goto case_114;
    }
#line 370
    if (c == 105) {
#line 370
      goto case_105;
    }
#line 375
    if (c == 111) {
#line 375
      goto case_111;
    }
#line 381
    if (c == 112) {
#line 381
      goto case_112;
    }
#line 386
    if (c == 116) {
#line 386
      goto case_116;
    }
#line 391
    if (c == 73) {
#line 391
      goto case_73;
    }
#line 396
    if (c == 79) {
#line 396
      goto case_79;
    }
#line 401
    if (c == 86) {
#line 401
      goto case_86;
    }
#line 413
    if (c == 97) {
#line 413
      goto case_97;
    }
#line 416
    if (c == 98) {
#line 416
      goto case_98;
    }
#line 420
    if (c == 99) {
#line 420
      goto case_99;
    }
#line 424
    if (c == 100) {
#line 424
      goto case_100;
    }
#line 427
    if (c == 101) {
#line 427
      goto case_101;
    }
#line 430
    if (c == 102) {
#line 430
      goto case_102;
    }
#line 433
    if (c == 103) {
#line 433
      goto case_103;
    }
#line 436
    if (c == 104) {
#line 436
      goto case_104;
    }
#line 439
    if (c == 106) {
#line 439
      goto case_106;
    }
#line 442
    if (c == 107) {
#line 442
      goto case_107;
    }
#line 445
    if (c == 108) {
#line 445
      goto case_108;
    }
#line 448
    if (c == 109) {
#line 448
      goto case_109;
    }
#line 451
    if (c == 110) {
#line 451
      goto case_110;
    }
#line 454
    if (c == 115) {
#line 454
      goto case_115;
    }
#line 464
    if (c == 70) {
#line 464
      goto case_70;
    }
#line 467
    if (c == 90) {
#line 467
      goto case_90;
    }
#line 470
    if (c == 75) {
#line 470
      goto case_75;
    }
#line 473
    if (c == 117) {
#line 473
      goto case_117;
    }
#line 476
    if (c == 118) {
#line 476
      goto case_118;
    }
#line 479
    if (c == 120) {
#line 479
      goto case_120;
    }
#line 482
    if (c == 88) {
#line 482
      goto case_88;
    }
#line 485
    if (c == 121) {
#line 485
      goto case_121;
    }
#line 488
    if (c == 89) {
#line 488
      goto case_89;
    }
#line 491
    if (c == 122) {
#line 491
      goto case_122;
    }
#line 494
    if (c == 76) {
#line 494
      goto case_76;
    }
#line 503
    if (c == 82) {
#line 503
      goto case_82;
    }
#line 506
    if (c == 113) {
#line 506
      goto case_113;
    }
#line 509
    if (c == 65) {
#line 509
      goto case_65;
    }
#line 512
    if (c == 69) {
#line 512
      goto case_69;
    }
#line 520
    if (c == 71) {
#line 520
      goto case_71;
    }
#line 530
    if (c == 77) {
#line 530
      goto case_77;
    }
#line 533
    if (c == 84) {
#line 533
      goto case_84;
    }
#line 536
    if (c == 119) {
#line 536
      goto case_119;
    }
#line 545
    if (c == 87) {
#line 545
      goto case_87;
    }
#line 554
    if (c == 54) {
#line 554
      goto case_54;
    }
#line 563
    if (c == 83) {
#line 563
      goto case_83;
    }
#line 566
    if (c == 66) {
#line 566
      goto case_66;
    }
#line 569
    if (c == 68) {
#line 569
      goto case_68;
    }
#line 572
    if (c == 81) {
#line 572
      goto case_81;
    }
#line 576
    if (c == 80) {
#line 576
      goto case_80;
    }
#line 579
    if (c == 85) {
#line 579
      goto case_85;
    }
#line 583
    if (c == 48) {
#line 583
      goto case_48;
    }
#line 586
    if (c == 52) {
#line 586
      goto case_52;
    }
#line 589
    if (c == 53) {
#line 589
      goto case_53;
    }
#line 592
    if (c == 74) {
#line 592
      goto case_74;
    }
#line 595
    if (c == 72) {
#line 595
      goto case_72;
    }
#line 598
    if (c == 64) {
#line 598
      goto case_64;
    }
#line 601
    if (c == 51) {
#line 601
      goto case_51;
    }
#line 604
    if (c == 49) {
#line 604
      goto case_49;
    }
#line 607
    if (c == 57) {
#line 607
      goto case_57;
    }
#line 610
    if (c == 50) {
#line 610
      goto case_50;
    }
#line 613
    if (c == 55) {
#line 613
      goto case_55;
    }
#line 617
    goto switch_default;
    case_114: /* CIL Label */ 
#line 366
    if (fn) {
      {
#line 367
      usage();
      }
    }
#line 368
    fn = & readcheck;
#line 369
    goto switch_break;
    case_105: /* CIL Label */ 
#line 371
    if (fn) {
      {
#line 372
      usage();
      }
    }
#line 373
    fn = & in;
#line 374
    goto switch_break;
    case_111: /* CIL Label */ 
#line 376
    if (fn) {
      {
#line 377
      usage();
      }
    }
#line 378
    fn = & out;
#line 379
    useoutmodetoc = 1;
#line 380
    goto switch_break;
    case_112: /* CIL Label */ 
#line 382
    if (fn) {
      {
#line 383
      usage();
      }
    }
#line 384
    fn = & pass;
#line 385
    goto switch_break;
    case_116: /* CIL Label */ 
#line 387
    if (fn) {
      {
#line 388
      usage();
      }
    }
#line 389
    fn = & toc;
#line 390
    goto switch_break;
    case_73: /* CIL Label */ 
#line 392
    if (fn) {
      {
#line 393
      usage();
      }
    }
#line 394
    fn = & copyin;
#line 395
    goto switch_break;
    case_79: /* CIL Label */ 
#line 397
    if (fn) {
      {
#line 398
      usage();
      }
    }
#line 399
    fn = & copyout;
#line 400
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 402
    printf((char const   */* __restrict  */)"%s: Version %s dated %s\n", myname, "2.5.1dev",
           ">05 Feb 2012");
#line 404
    exit(0);
    }
    case_97: /* CIL Label */ 
#line 414
    aflag = (short )((int )aflag + 1);
#line 415
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 417
    tmp___0 = optsize(optarg);
#line 417
    arbsize = (unsigned int )tmp___0;
    }
#line 417
    if (arbsize == 0U) {
      {
#line 418
      fatal(optarg, (char *)"Bad block size");
      }
    }
#line 419
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 421
    tmp___1 = optsize(optarg);
#line 421
    group = (unsigned int )tmp___1;
    }
#line 421
    if (group == 0U) {
      {
#line 422
      fatal(optarg, (char *)"Bad buffer count");
      }
    }
#line 423
    goto switch_break;
    case_100: /* CIL Label */ 
#line 425
    dflag = (short )((int )dflag + 1);
#line 426
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 428
    tmp___2 = optsize(optarg);
#line 428
    arpad = (unsigned int )tmp___2;
    }
#line 429
    goto switch_break;
    case_102: /* CIL Label */ 
#line 431
    fflag = (short )((int )fflag + 1);
#line 432
    goto switch_break;
    case_103: /* CIL Label */ 
#line 434
    gflag = (short )((int )gflag + 1);
#line 435
    goto switch_break;
    case_104: /* CIL Label */ 
#line 437
    hflag = (short )((int )hflag + 1);
#line 438
    goto switch_break;
    case_106: /* CIL Label */ 
#line 440
    jflag = (short )((int )jflag + 1);
#line 441
    goto switch_break;
    case_107: /* CIL Label */ 
#line 443
    kflag = (short )((int )kflag + 1);
#line 444
    goto switch_break;
    case_108: /* CIL Label */ 
#line 446
    lflag = (short )((int )lflag + 1);
#line 447
    goto switch_break;
    case_109: /* CIL Label */ 
#line 449
    mflag = (short )((int )mflag + 1);
#line 450
    goto switch_break;
    case_110: /* CIL Label */ 
#line 452
    nflag = (short )((int )nflag + 1);
#line 453
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 455
    sflagused = 1;
#line 457
    aruntil_string = strdup((char const   *)optarg);
    }
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 458
      if (! aruntil_string) {
#line 458
        goto while_break___0;
      }
      {
#line 458
      update_aruntil();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 460
    aruntil_string = optarg;
#line 461
    update_aruntil();
    }
#line 462
    if (aruntil == 0ULL) {
#line 462
      askfornext = 1;
    }
#line 463
    goto switch_break;
    case_70: /* CIL Label */ 
#line 465
    Fflag = (short )((int )Fflag + 1);
#line 466
    goto switch_break;
    case_90: /* CIL Label */ 
#line 468
    Zflag = (short )((int )Zflag + 1);
#line 469
    goto switch_break;
    case_75: /* CIL Label */ 
#line 471
    verifyflag = (short )((int )verifyflag + 1);
#line 472
    goto switch_break;
    case_117: /* CIL Label */ 
#line 474
    uflag = (short )((int )uflag + 1);
#line 475
    goto switch_break;
    case_118: /* CIL Label */ 
#line 477
    vflag = (short )((int )vflag + 1);
#line 478
    goto switch_break;
    case_120: /* CIL Label */ 
#line 480
    xflag = (short)1;
#line 481
    goto switch_break;
    case_88: /* CIL Label */ 
#line 483
    xflag = (short)0;
#line 484
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 486
    nameadd(optarg, 0);
    }
#line 487
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 489
    nameadd(optarg, 1);
    }
#line 490
    goto switch_break;
    case_122: /* CIL Label */ 
#line 492
    zflag = (short )((int )zflag + 1);
#line 493
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 495
    logfile = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"a");
    }
#line 495
    if ((unsigned long )logfile == (unsigned long )((FILE *)0)) {
      {
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s to append, get help\n",
              optarg);
#line 500
      exit(1);
      }
    }
#line 502
    goto switch_break;
    case_82: /* CIL Label */ 
#line 504
    formatcmd = optarg;
#line 505
    goto switch_break;
    case_113: /* CIL Label */ 
#line 507
    hidequit = (short)1;
#line 508
    goto switch_break;
    case_65: /* CIL Label */ 
#line 510
    abspaths = (short)1;
#line 511
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 513
    tmp___5 = strcmp((char const   *)optarg, "CS");
    }
#line 513
    if (tmp___5 == 0) {
#line 513
      extcasesens = 1;
    } else {
      {
#line 514
      tmp___4 = strcmp((char const   *)optarg, "CI");
      }
#line 514
      if (tmp___4 == 0) {
#line 514
        extcasesens = 0;
      } else {
        {
#line 515
        tmp___3 = readcompexts(optarg);
        }
#line 515
        if (! tmp___3) {
          {
#line 517
          exit(1);
          }
        }
      }
    }
#line 519
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 521
    tmp___6 = optsize(optarg);
#line 521
    gzipfactor = (int )((unsigned int )tmp___6);
    }
#line 522
    if (gzipfactor < 1) {
      {
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Illegal gzip speed factor (Must be 1--9)\n",
              optarg);
#line 527
      exit(1);
      }
    } else
#line 522
    if (gzipfactor > 9) {
      {
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Illegal gzip speed factor (Must be 1--9)\n",
              optarg);
#line 527
      exit(1);
      }
    }
#line 529
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 531
    tmp___7 = optsize(optarg);
#line 531
    maxmem = (off_t )tmp___7;
    }
#line 532
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 534
    tmp___8 = optsize(optarg);
#line 534
    compthreshold = (long )((unsigned int )tmp___8);
    }
#line 535
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 537
    tmp___9 = nameaddfile(optarg, 0, (int )flag0);
    }
#line 537
    if (! tmp___9) {
      {
#line 539
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read configuration file %s\n",
              optarg);
#line 542
      exit(1);
      }
    }
#line 544
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 546
    tmp___10 = nameaddfile(optarg, 1, (int )flag0);
    }
#line 546
    if (! tmp___10) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read configuration file %s\n",
              optarg);
#line 551
      exit(1);
      }
    }
#line 553
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 555
    tmp___11 = nameaddfile(optarg, 2, 0);
    }
#line 555
    if (! tmp___11) {
      {
#line 557
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read configuration file %s\n",
              optarg);
#line 560
      exit(1);
      }
    }
#line 562
    goto switch_break;
    case_83: /* CIL Label */ 
#line 564
    ignoreslash = 0;
#line 565
    goto switch_break;
    case_66: /* CIL Label */ 
#line 567
    printbytepos = 1;
#line 568
    goto switch_break;
    case_68: /* CIL Label */ 
#line 570
    controlscript = optarg;
#line 571
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 573
    compressargs = 1;
#line 574
    add_arg(optarg);
    }
#line 575
    goto switch_break;
    case_80: /* CIL Label */ 
#line 577
    compressprog = optarg;
#line 578
    goto switch_break;
    case_85: /* CIL Label */ 
#line 580
    forceZflag = 1;
#line 581
    lflag = (short)1;
#line 582
    goto switch_break;
    case_48: /* CIL Label */ 
#line 584
    flag0 = (short )(1 - (int )flag0);
#line 585
    goto switch_break;
    case_52: /* CIL Label */ 
#line 587
    extfmt = (unsigned short)1;
#line 588
    goto switch_break;
    case_53: /* CIL Label */ 
#line 590
    cpiocompat = (unsigned short)1;
#line 591
    goto switch_break;
    case_74: /* CIL Label */ 
#line 593
    Jflag = (short)1;
#line 594
    goto switch_break;
    case_72: /* CIL Label */ 
#line 596
    promptscript = optarg;
#line 597
    goto switch_break;
    case_64: /* CIL Label */ 
#line 599
    email = optarg;
#line 600
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 602
    tmp___12 = optsize(optarg);
#line 602
    rewindfd = (int )tmp___12;
    }
#line 603
    goto switch_break;
    case_49: /* CIL Label */ 
#line 605
    ignorewarnings = optarg;
#line 606
    goto switch_break;
    case_57: /* CIL Label */ 
#line 608
    roundaruntil = 0;
#line 609
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 611
    maxsizetocompress = optsize(optarg);
    }
#line 612
    goto switch_break;
    case_55: /* CIL Label */ 
#line 614
    noglob = (short )(1 - (int )noglob);
#line 615
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 618
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if ((unsigned long )fn == (unsigned long )((void *)0)) {
    {
#line 622
    usage();
    }
  } else
#line 621
  if ((unsigned long )*(av + optind) == (unsigned long )((void *)0)) {
    {
#line 622
    usage();
    }
  }
#line 624
  if (extfmt) {
#line 624
    if (cpiocompat) {
      {
#line 626
      warn(*(av + 0), (char *)"Options -4 and -5 cannot be specified at the same time.");
#line 627
      usage();
      }
    }
  }
#line 630
  if (fflag) {
#line 630
    if (aruntil == 0ULL) {
      {
#line 632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal: must supply nonzero -s [volsize] to use -f\n");
#line 633
      usage();
      }
    }
  }
#line 636
  if (compressprog) {
#line 636
    if (rewindfd == -1) {
      {
#line 637
      tmp___13 = strstr((char const   *)compressprog, "pgp");
      }
#line 637
      if (tmp___13) {
        {
#line 639
        fatal(compressprog, (char *)"Must use -3 flag if -P program matches \'pgp\' or \'gpg\', see the afio manual page.");
        }
      } else {
        {
#line 637
        tmp___14 = strstr((char const   *)compressprog, "gpg");
        }
#line 637
        if (tmp___14) {
          {
#line 639
          fatal(compressprog, (char *)"Must use -3 flag if -P program matches \'pgp\' or \'gpg\', see the afio manual page.");
          }
        }
      }
    }
  }
#line 642
  if (! compressprog) {
#line 642
    compressprog = (char *)"gzip";
  }
#line 643
  compress_arg_list[0] = compressprog;
#line 645
  if ((maxmem / 1024L) / 1024L > 1536L) {
    {
#line 658
    fatal(arspec, (char *)"In-memory compression buffer size above 1.5GB not supported");
    }
  }
#line 661
  if (Fflag) {
#line 663
    buflen = (off_t )aruntil;
#line 663
    if (buflen == 0L) {
      {
#line 664
      usage();
      }
    }
  } else {
#line 667
    buflen = (off_t )arbsize * (off_t )group;
  }
#line 669
  if (roundaruntil) {
#line 674
    aruntil /= (ulonglong )arbsize;
#line 675
    aruntil *= (ulonglong )arbsize;
  }
#line 678
  if (aruntil) {
#line 678
    if (aruntil < (ulonglong )arbsize) {
      {
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Media size %ld is less than block size %d\n",
              (unsigned long )aruntil, arbsize);
#line 689
      usage();
      }
    }
  }
#line 691
  if (arpad == 0U) {
#line 692
    arpad = arbsize;
  }
#line 693
  if ((unsigned long )fn != (unsigned long )(& pass)) {
#line 699
    if ((unsigned long )fn == (unsigned long )(& out)) {
#line 699
      tmp___15 = 1;
    } else
#line 699
    if ((unsigned long )fn == (unsigned long )(& copyout)) {
#line 699
      tmp___15 = 1;
    } else {
#line 699
      tmp___15 = 0;
    }
    {
#line 699
    isoutput = tmp___15;
#line 701
    tmp___16 = optind;
#line 701
    optind ++;
#line 701
    arname = strcpy((char */* __restrict  */)(arspec), (char const   */* __restrict  */)*(av + tmp___16));
#line 702
    colon = strchr((char const   *)(arspec), ':');
    }
#line 702
    if (colon) {
      {
#line 704
      tmp___17 = colon;
#line 704
      colon ++;
#line 704
      *tmp___17 = (char )'\000';
#line 705
      perc = strchr((char const   *)(arspec), '%');
      }
#line 705
      if (perc) {
#line 706
        tmp___18 = perc;
#line 706
        perc ++;
#line 706
        *tmp___18 = (char )'\000';
      }
#line 707
      if (perc) {
#line 707
        tmp___20 = perc;
      } else {
#line 707
        tmp___20 = arspec;
      }
      {
#line 707
      equal = strchr((char const   *)tmp___20, '=');
      }
#line 707
      if (equal) {
#line 708
        tmp___19 = equal;
#line 708
        equal ++;
#line 708
        *tmp___19 = (char )'\000';
      }
      {
#line 709
      host = strchr((char const   *)(arspec), '@');
      }
#line 709
      if (host) {
#line 710
        tmp___21 = host;
#line 710
        host ++;
#line 710
        *tmp___21 = (char)0;
      }
#line 711
      if (isoutput) {
#line 711
        tmp___22 = 'O';
      } else {
#line 711
        tmp___22 = 'I';
      }
#line 711
      if (equal) {
#line 711
        tmp___23 = equal;
      } else {
#line 711
        tmp___23 = myname;
      }
#line 711
      if (host) {
#line 711
        tmp___24 = host;
      } else {
#line 711
        tmp___24 = arspec;
      }
#line 711
      if (host) {
#line 711
        tmp___25 = (char const   *)(arspec);
      } else {
#line 711
        tmp___25 = "";
      }
#line 711
      if (host) {
#line 711
        tmp___26 = "-l ";
      } else {
#line 711
        tmp___26 = "";
      }
#line 711
      if (perc) {
#line 711
        tmp___27 = (char const   *)perc;
      } else {
#line 711
        tmp___27 = "rsh";
      }
      {
#line 711
      arname = remote;
#line 711
      sprintf((char */* __restrict  */)arname, (char const   */* __restrict  */)"!%s %s%s %s \'%s -%c -b %u -c %u %s\'",
              tmp___27, tmp___26, tmp___25, tmp___24, tmp___23, tmp___22, arbsize,
              group, colon);
      }
#line 720
      if (host) {
#line 721
        host --;
#line 721
        *host = (char )'@';
      }
#line 722
      if (equal) {
#line 723
        equal --;
#line 723
        *equal = (char )'=';
      }
#line 724
      if (perc) {
#line 725
        perc --;
#line 725
        *perc = (char )'%';
      }
#line 726
      colon --;
#line 726
      *colon = (char )':';
    }
#line 728
    if (gflag) {
#line 728
      if ((int )*arname != 47) {
#line 728
        if ((int )*arname != 33) {
          {
#line 729
          fatal(arspec, (char *)"Relative pathname");
          }
        }
      }
    }
    {
#line 730
    signal(2, & goodbye);
    }
#line 732
    if ((buflen / 1024L) / 1024L > 1536L) {
      {
#line 744
      fatal(arspec, (char *)"In-memory I/O buffer size above 1.5GB not supported");
      }
    }
    {
#line 752
    tmp___28 = malloc((size_t )buflen + 5120UL);
#line 752
    bufend = (char *)tmp___28;
#line 752
    bufidx = bufend;
#line 752
    buffer = bufidx;
    }
#line 752
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      {
#line 753
      fatal(arspec, (char *)"Cannot allocate enough memory for I/O buffer");
      }
    }
#line 761
    if ((unsigned long )fn == (unsigned long )(& out)) {
      {
#line 761
      tmp___33 = isatty(0);
      }
#line 761
      if (tmp___33) {
        {
#line 763
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 765
          tmp___29 = lineget(stdin, firstfilename, 1024);
          }
#line 765
          if (tmp___29 < 0) {
            {
#line 767
            fatal((char *)"-o (write archive) mode", (char *)"could not read any file names from stdin");
            }
          }
          {
#line 769
          tmp___30 = strncmp((char const   *)(firstfilename), "//--", (size_t )4);
          }
#line 769
          if (tmp___30 == 0) {
#line 769
            goto while_break___1;
          }
          {
#line 770
          tmp___32 = stat((char const   */* __restrict  */)(firstfilename), (struct stat */* __restrict  */)(& tmpstat.sb_stat));
          }
#line 770
          if (tmp___32 < 0) {
            {
#line 772
            tmp___31 = syserr();
#line 772
            warn(firstfilename, tmp___31);
#line 773
            warn(firstfilename, (char *)"-o (write archive) mode needs file names on stdin");
            }
          } else {
#line 775
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 790
    if (! Fflag) {
#line 790
      goto _L;
    } else
#line 790
    if (! isoutput) {
      _L: /* CIL Label */ 
#line 792
      if (isoutput) {
#line 792
        tmp___34 = 1;
      } else {
#line 792
        tmp___34 = 0;
      }
      {
#line 792
      tmp___35 = nextopen(tmp___34);
      }
#line 792
      if (tmp___35 < 0) {
        {
#line 793
        goodbye(1);
        }
      }
    } else {
#line 796
      arleft = aruntil;
    }
  }
  {
#line 799
  timenow = time((time_t *)((void *)0));
#line 800
  (*fn)(av + optind);
#line 801
  timedone = time((time_t *)((void *)0));
  }
#line 802
  if (uflag) {
    {
#line 803
    linkleft();
    }
  }
#line 804
  if (vflag) {
    {
#line 805
    fflush(stdout);
    }
  } else
#line 804
  if ((unsigned long )fn == (unsigned long )(& toc)) {
    {
#line 805
    fflush(stdout);
    }
  }
#line 807
  if (cpiowarned) {
    {
#line 810
    warn_nocount(arspec, (char *)"Warning: Created archive is not fully compatible with cpio or afio versions 2.4.7 and lower.");
#line 811
    warn_nocount(arspec, (char *)"See the ARCHIVE PORTABILITY section of the manpage.");
    }
  }
#line 814
  exitmsg = (char *)"The operation was successful.";
#line 815
  if (warnings) {
    {
#line 817
    tmp___36 = malloc((size_t )80);
#line 817
    exitmsg = (char *)tmp___36;
    }
#line 818
    if ((unsigned long )exitmsg == (unsigned long )((void *)0)) {
#line 819
      exitmsg = (char *)"The operation HAD WARNINGS ABOUT ERRORS.";
    } else {
#line 821
      if (warnings == 1) {
#line 821
        tmp___37 = "";
      } else {
#line 821
        tmp___37 = "S";
      }
      {
#line 821
      sprintf((char */* __restrict  */)exitmsg, (char const   */* __restrict  */)"The operation HAD %d WARNING%s ABOUT ERRORS.",
              warnings, tmp___37);
      }
    }
  }
#line 823
  if (anycorrupt) {
#line 823
    exitmsg = (char *)"The operation FAILED.";
  }
#line 826
  if (zflag) {
#line 830
    if ((unsigned long )fn == (unsigned long )(& toc)) {
#line 830
      stream = stderr;
    } else
#line 830
    if ((unsigned long )fn == (unsigned long )(& copyin)) {
#line 830
      stream = stderr;
    } else
#line 830
    if (arfd == 1) {
#line 830
      stream = stderr;
    } else {
#line 830
      stream = stdout;
    }
    {
#line 831
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s: ",
            myname);
#line 832
    prsize(stream, total);
    }
#line 833
    if ((unsigned long )fn == (unsigned long )(& pass)) {
#line 833
      tmp___39 = "transferred";
    } else {
#line 833
      if ((unsigned long )fn == (unsigned long )(& out)) {
#line 833
        tmp___38 = "written";
      } else
#line 833
      if ((unsigned long )fn == (unsigned long )(& copyout)) {
#line 833
        tmp___38 = "written";
      } else {
#line 833
        tmp___38 = "read";
      }
#line 833
      tmp___39 = tmp___38;
    }
    {
#line 833
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" bytes %s in %lu seconds. %s\n",
            tmp___39, (timedone - timenow) - timewait, exitmsg);
    }
  }
#line 842
  if ((unsigned long )logfile != (unsigned long )((FILE *)0)) {
    {
#line 844
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Final count: ",
            myname);
#line 845
    prsize(logfile, total);
#line 846
    tmp___40 = ctime((time_t const   *)(& timedone));
    }
#line 846
    if ((unsigned long )fn == (unsigned long )(& pass)) {
#line 846
      tmp___42 = "transferred";
    } else {
#line 846
      if ((unsigned long )fn == (unsigned long )(& out)) {
#line 846
        tmp___41 = "written";
      } else
#line 846
      if ((unsigned long )fn == (unsigned long )(& copyout)) {
#line 846
        tmp___41 = "written";
      } else {
#line 846
        tmp___41 = "read";
      }
#line 846
      tmp___42 = tmp___41;
    }
    {
#line 846
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)" bytes %s in %lu seconds (+waited %lu seconds for disk swapping (%u disks)) finished at %s",
            tmp___42, (timedone - timenow) - timewait, timewait, arvolume, tmp___40);
#line 852
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s\n",
            exitmsg);
    }
  }
  {
#line 854
  nextclos();
  }
#line 858
  if ((unsigned long )fn == (unsigned long )(& copyin)) {
    {
#line 858
    fflush(stdout);
#line 858
    fclose(stdout);
#line 858
    sleep(2U);
    }
  }
#line 859
  if (email) {
    {
#line 859
    mail(email, -1, arspec);
    }
  }
#line 861
  status = 0;
#line 862
  if (anycorrupt) {
#line 862
    status = 1;
  }
#line 863
  if (warnings) {
    {
#line 863
    tmp___43 = index((char const   *)ignorewarnings, 'a');
    }
#line 863
    if ((unsigned long )tmp___43 == (unsigned long )((void *)0)) {
#line 863
      status = 1;
    }
  }
  {
#line 865
  goodbye(status);
  }
#line 867
  return (0);
}
}
#line 877 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void update_aruntil(void) 
{ 
  char *next_aruntil_string ;
  char *tmp ;

  {
#line 879
  next_aruntil_string = aruntil_string;
#line 881
  if (aruntil_string) {
    {
#line 883
    aruntil_string = strchr((char const   *)aruntil_string, ',');
    }
#line 884
    if (aruntil_string) {
#line 884
      tmp = aruntil_string;
#line 884
      aruntil_string ++;
#line 884
      *tmp = (char )'\000';
    }
    {
#line 886
    aruntil = optsize(next_aruntil_string);
    }
  }
#line 888
  return;
}
}
#line 895 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void mail(char *who , int vol , char *archive ) 
{ 
  FILE *fp ;
  char cmd[1024] ;
  char hostname[256] ;
  char const   *tmp ;

  {
  {
#line 900
  gethostname(hostname, sizeof(hostname));
#line 901
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"sendmail %s",
          who);
#line 902
  fp = popen((char const   *)(cmd), "w");
  }
#line 903
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 904
    perror((char const   *)(cmd));
    }
#line 905
    return;
  }
  {
#line 907
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"From: Afio archiver\n");
  }
#line 908
  if (vol < 0) {
#line 908
    tmp = "operation complete";
  } else {
#line 908
    tmp = "volume change needed";
  }
  {
#line 908
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Subject: %s %s: %s\n\n",
          hostname, archive, tmp);
#line 909
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Hostname: %s\n",
          hostname);
#line 910
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Archive : %s\n\n",
          archive);
  }
#line 911
  if (vol >= 0) {
    {
#line 912
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Need change to volume #%d.\n\n",
            vol);
    }
  } else {
    {
#line 914
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Operation complete.\n\n");
    }
  }
  {
#line 915
  pclose(fp);
  }
#line 916
  return;
}
}
#line 924 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void copyin(char **av ) 
{ 
  register ssize_t got ;
  register ssize_t have ;
  char *tmp ;

  {
#line 930
  if (*av) {
    {
#line 931
    fatal(*av, (char *)"Extraneous argument");
    }
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! (! areof)) {
#line 932
      if (! askfornext) {
#line 932
        goto while_break;
      }
    }
    {
#line 934
    infill();
    }
    {
#line 935
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 935
      have = bufend - bufidx;
#line 935
      if (! have) {
#line 935
        goto while_break___0;
      }
      {
#line 936
      got = writeall(1, (char const   *)bufidx, (size_t )have);
      }
#line 936
      if (got < 0L) {
        {
#line 937
        tmp = syserr();
#line 937
        fatal((char *)"<stdout>", tmp);
        }
      } else {
#line 940
        total += (ulonglong )have;
#line 941
        if (got > 0L) {
#line 942
          bufidx += got;
        } else {
#line 944
          return;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return;
}
}
#line 954 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void copyout(char **av ) 
{ 
  register int got ;
  register unsigned int want ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
#line 960
  if (*av) {
    {
#line 961
    fatal(*av, (char *)"Extraneous argument");
    }
  }
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 964
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 964
      want = (unsigned int )(bufend - bufidx);
#line 964
      if (! (want == 0U)) {
#line 964
        goto while_break___0;
      }
      {
#line 965
      outflush(0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 966
    tmp___0 = read(0, (void *)bufidx, (size_t )want);
#line 966
    got = (int )tmp___0;
    }
#line 966
    if (got < 0) {
      {
#line 967
      tmp = syserr();
#line 967
      fatal((char *)"<stdin>", tmp);
      }
    } else
#line 968
    if (got == 0) {
#line 969
      goto while_break;
    } else {
#line 972
      bufidx += got;
#line 973
      total += (ulonglong )got;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 976
  outflush(1);
  }
#line 977
  if (fflag) {
    {
#line 978
    outwait();
    }
  }
#line 979
  return;
}
}
#line 986 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int dirchg(char *name , char *local ) 
{ 
  register char *last ;
  register int len ;
  char dir[1024] ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 993
  if ((int )*name != 47) {
    {
#line 994
    tmp = warn(name, (char *)"Relative pathname");
    }
#line 994
    return (tmp);
  }
  {
#line 995
  tmp___0 = strlen((char const   *)name);
#line 995
  last = name + tmp___0;
  }
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! ((int )*(last + -1) != 47)) {
#line 995
      goto while_break;
    }
#line 995
    last --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  len = (int )(last - name);
#line 998
  tmp___1 = strncpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)name,
                    (size_t )len);
#line 998
  *(tmp___1 + len) = (char )'\000';
  }
#line 999
  if (*last) {
#line 999
    tmp___2 = (char const   *)last;
  } else {
#line 999
    tmp___2 = ".";
  }
  {
#line 999
  strcpy((char */* __restrict  */)local, (char const   */* __restrict  */)tmp___2);
#line 1000
  tmp___3 = strcmp((char const   *)(dir), (char const   *)(pwd));
  }
#line 1000
  if (tmp___3 == 0) {
#line 1001
    return (0);
  }
  {
#line 1002
  tmp___6 = chdir((char const   *)(dir));
  }
#line 1002
  if (tmp___6 < 0) {
    {
#line 1003
    tmp___4 = syserr();
#line 1003
    tmp___5 = warn(name, tmp___4);
    }
#line 1003
    return (tmp___5);
  }
  {
#line 1004
  strcpy((char */* __restrict  */)(pwd), (char const   */* __restrict  */)(dir));
  }
#line 1005
  return (0);
}
}
#line 1013 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int dirmake(char *name , Stat *asb ) 
{ 
  int tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 1016
  tmp = mkdir((char const   *)name, asb->sb_stat.st_mode & 511U);
  }
#line 1016
  if (tmp < 0) {
#line 1017
    return (-1);
  }
#line 1021
  if (xflag) {
#line 1022
    if (uid == 0U) {
#line 1022
      tmp___0 = asb->sb_stat.st_uid;
    } else {
#line 1022
      tmp___0 = uid;
    }
    {
#line 1022
    chown((char const   *)name, tmp___0, asb->sb_stat.st_gid);
    }
  }
#line 1025
  if (asb->sb_stat.st_mode & 3584U) {
    {
#line 1026
    chmod((char const   *)name, asb->sb_stat.st_mode & 4095U);
    }
  }
#line 1027
  return (0);
}
}
#line 1043 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static Stat sb  ;
#line 1037 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int dirneed(char *name ) 
{ 
  register char *cp ;
  register char *last ;
  register int ok ;
  char *tmp ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1045
  last = (char *)((void *)0);
#line 1046
  cp = name;
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! *cp) {
#line 1046
      goto while_break;
    }
#line 1047
    tmp = cp;
#line 1047
    cp ++;
#line 1047
    if ((int )*tmp == 47) {
#line 1048
      last = cp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if ((unsigned long )last == (unsigned long )((void *)0)) {
    {
#line 1050
    tmp___0 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& sb.sb_stat));
    }
#line 1050
    return (tmp___0);
  }
#line 1051
  last --;
#line 1051
  *last = (char )'\000';
#line 1052
  if (*name) {
#line 1052
    tmp___6 = (char const   *)name;
  } else {
#line 1052
    tmp___6 = "/";
  }
  {
#line 1052
  tmp___7 = stat((char const   */* __restrict  */)tmp___6, (struct stat */* __restrict  */)(& sb.sb_stat));
  }
#line 1052
  if (tmp___7 == 0) {
#line 1052
    ok = (sb.sb_stat.st_mode & 61440U) == 16384U;
  } else {
#line 1052
    if (! dflag) {
      {
#line 1052
      tmp___3 = dirneed(name);
      }
#line 1052
      if (tmp___3 == 0) {
        {
#line 1052
        tmp___4 = dirmake(name, & sb);
        }
#line 1052
        if (tmp___4 == 0) {
#line 1052
          tmp___5 = 1;
        } else {
#line 1052
          tmp___5 = 0;
        }
      } else {
#line 1052
        tmp___5 = 0;
      }
    } else {
#line 1052
      tmp___5 = 0;
    }
#line 1052
    ok = tmp___5;
  }
#line 1055
  *last = (char )'/';
#line 1056
  if (ok) {
#line 1056
    tmp___8 = 0;
  } else {
#line 1056
    tmp___8 = -1;
  }
#line 1056
  return (tmp___8);
}
}
#line 1064 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void fatal(char *what , char *why ) 
{ 


  {
#line 1068
  if (total > 0ULL) {
    {
#line 1069
    warnarch((char *)"Fatal error:", (off_t )0);
    }
  }
  {
#line 1070
  warn(what, why);
#line 1071
  goodbye(1);
  }
#line 1072
  return;
}
}
#line 1083 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ssize_t writeall(int fd , char const   *buf , size_t count ) 
{ 
  ssize_t put ;
  size_t totalput ;

  {
#line 1088
  totalput = (size_t )0;
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! (totalput < count)) {
#line 1089
      goto while_break;
    }
    {
#line 1091
    put = write(fd, (void const   *)(buf + totalput), count - totalput);
    }
#line 1093
    if (put < 0L) {
#line 1093
      return (put);
    }
#line 1094
    totalput += (size_t )put;
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  return ((ssize_t )count);
}
}
#line 1108 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ssize_t readall(int fd , char *buf , size_t count ) 
{ 
  ssize_t got ;
  size_t totalgot ;

  {
#line 1113
  totalgot = (size_t )0;
  {
#line 1114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1114
    if (! (totalgot < count)) {
#line 1114
      goto while_break;
    }
    {
#line 1116
    got = read(fd, (void *)(buf + totalgot), count - totalgot);
    }
#line 1118
    if (got <= 0L) {
#line 1120
      if (got == 0L) {
#line 1120
        return ((ssize_t )totalgot);
      }
#line 1121
      if (got < 0L) {
#line 1121
        return (got);
      }
    }
#line 1123
    totalgot += (size_t )got;
  }
  while_break: /* CIL Label */ ;
  }
#line 1126
  return ((ssize_t )count);
}
}
#line 1136 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void mayberewind(void) 
{ 
  char *tmp ;
  __off64_t tmp___0 ;

  {
#line 1138
  if (rewindfd >= 1) {
    {
#line 1140
    tmp___0 = lseek(rewindfd, (off_t )0, 0);
    }
#line 1140
    if (tmp___0 < 0L) {
      {
#line 1142
      tmp = syserr();
#line 1142
      fatal((char *)"-3 option", tmp);
      }
    }
  }
#line 1145
  return;
}
}
#line 1154 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void savedirstamp(char *name , time_t mtime ) 
{ 
  Dir *dirp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1159
  tmp = memget((unsigned int )sizeof(Dir ));
#line 1159
  dirp = (Dir *)tmp;
  }
#line 1159
  if ((unsigned long )dirp != (unsigned long )((void *)0)) {
    {
#line 1159
    tmp___0 = memstr(name);
#line 1159
    dirp->d_name = tmp___0;
    }
#line 1159
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1161
      dirp->d_mtime = mtime;
#line 1162
      dirp->d_forw = DirP;
#line 1163
      DirP = dirp;
    }
  }
#line 1165
  return;
}
}
#line 1172 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void restoredirstamps(void) 
{ 
  struct utimbuf tstamp ;
  Dir *DirP_forw ;

  {
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    if (! ((unsigned long )DirP != (unsigned long )((void *)0))) {
#line 1181
      goto while_break;
    }
    {
#line 1184
    tstamp.actime = DirP->d_mtime;
#line 1185
    tstamp.modtime = DirP->d_mtime;
#line 1187
    utime((char const   *)DirP->d_name, (struct utimbuf  const  *)(& tstamp));
#line 1198
    DirP_forw = DirP->d_forw;
#line 1200
    DirP = DirP_forw;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1202
  return;
}
}
#line 1210 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void in(char **av ) 
{ 
  Stat sb___0 ;
  char name[1024] ;
  int sel ;
  int sel2 ;
  int res ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 1218
  if (*av) {
    {
#line 1219
    fatal(*av, (char *)"Extraneous argument");
    }
  }
#line 1220
  name[0] = (char )'\000';
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1221
    tmp___2 = inhead(name, & sb___0);
    }
#line 1221
    if (! (tmp___2 == 0)) {
#line 1221
      goto while_break;
    }
    {
#line 1223
    sel = namecmp(name, & sb___0);
    }
#line 1224
    if (sel) {
      {
#line 1226
      tmp = inskip(sb___0.sb_stat.st_size);
      }
#line 1226
      if (tmp < 0) {
        {
#line 1227
        warn(name, (char *)"Skipped file data is corrupt");
        }
      }
    } else {
      {
#line 1231
      sel2 = inentry(name, & sb___0);
      }
#line 1231
      if (sel2 != 0) {
        {
#line 1232
        warn(name, (char *)"unpacking error");
        }
      } else
#line 1234
      if (vflag) {
#line 1238
        if (printbytepos) {
          {
#line 1238
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.0f ",
                  (double )bytepos);
          }
        }
#line 1240
        if (uncompto[0]) {
          {
#line 1241
          res = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- uncompressed\n",
                        uncompto);
          }
        } else {
          {
#line 1243
          res = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- okay\n",
                        name);
          }
        }
#line 1246
        if (res < 0) {
          {
#line 1247
          tmp___1 = __errno_location();
          }
#line 1247
          if (*tmp___1 == 32) {
            {
#line 1248
            tmp___0 = syserr();
#line 1248
            fatal((char *)"<stderr>", tmp___0);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1253
  restoredirstamps();
  }
#line 1254
  return;
}
}
#line 1263 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Stat atime_sb  ;
#line 1264 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int atime_sb_valid  ;
#line 1266 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void readcheck(char **av ) 
{ 
  Stat sb___0 ;
  char name[1024] ;
  char local[1024] ;
  int sel ;
  int res ;
  struct utimbuf tstamp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1280
  if (*av) {
    {
#line 1281
    fatal(*av, (char *)"Extraneous argument");
    }
  }
#line 1282
  name[0] = (char )'\000';
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1283
    tmp___0 = inhead(name, & sb___0);
    }
#line 1283
    if (! (tmp___0 == 0)) {
#line 1283
      goto while_break;
    }
    {
#line 1285
    sel = namecmp(name, & sb___0);
    }
#line 1285
    if (sel < 0) {
      {
#line 1286
      tmp = inskip(sb___0.sb_stat.st_size);
      }
#line 1286
      if (tmp < 0) {
        {
#line 1287
        warn(name, (char *)"Skipped file data is corrupt");
        }
      }
#line 1288
      goto while_continue;
    }
#line 1290
    if (vflag) {
      {
#line 1291
      strcpy((char */* __restrict  */)(local), (char const   */* __restrict  */)(name));
#line 1292
      tocentry(local, & sb___0);
      }
    }
    {
#line 1295
    atime_sb_valid = 0;
#line 1296
    res = incheckentry(name, & sb___0);
    }
#line 1296
    if (res < 0) {
      {
#line 1297
      inskip(sb___0.sb_stat.st_size);
      }
    }
#line 1299
    if (aflag) {
#line 1299
      if (atime_sb_valid) {
#line 1299
        if ((sb___0.sb_stat.st_mode & 61440U) == 32768U) {
          {
#line 1303
          tstamp.actime = atime_sb.sb_stat.st_atim.tv_sec;
#line 1304
          tstamp.modtime = atime_sb.sb_stat.st_mtim.tv_sec;
#line 1305
          utime((char const   *)(name), (struct utimbuf  const  *)(& tstamp));
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1315
  return;
}
}
#line 1323 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void inalloc(unsigned int len ) 
{ 


  {
#line 1326
  bufidx += len;
#line 1327
  total += (ulonglong )len;
#line 1328
  return;
}
}
#line 1338 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inascii(char *magic , char *name , Stat *asb ) 
{ 
  unsigned int namelen ;
  char header[71] ;
  PStat pasb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1348
  tmp = strncmp((char const   *)magic, "070707", (size_t )6);
  }
#line 1348
  if (tmp != 0) {
#line 1349
    return (-1);
  }
  {
#line 1351
  tmp___1 = inread(header, 70U);
  }
#line 1351
  if (tmp___1 < 0) {
    {
#line 1352
    tmp___0 = warnarch((char *)"Corrupt ASCII header", (off_t )70);
    }
#line 1352
    return (tmp___0);
  }
  {
#line 1353
  header[70] = (char )'\000';
#line 1355
  tmp___3 = sscanf((char const   */* __restrict  */)(header), (char const   */* __restrict  */)"%6lo%6lo%6lo%6lo%6lo%6lo%6lo%11lo%6o%11lo",
                   & pasb.PSt_dev, & pasb.PSt_ino, & pasb.PSt_mode, & pasb.PSt_uid,
                   & pasb.PSt_gid, & pasb.PSt_nlink, & pasb.PSt_rdev, & pasb.PSt_mtime,
                   & namelen, & pasb.PSt_size);
  }
#line 1355
  if (tmp___3 != 10) {
    {
#line 1359
    tmp___2 = warnarch((char *)"Bad ASCII header", (off_t )70);
    }
#line 1359
    return (tmp___2);
  }
#line 1361
  asb->sb_stat.st_dev = pasb.PSt_dev;
#line 1362
  asb->sb_stat.st_ino = pasb.PSt_ino;
#line 1363
  asb->sb_stat.st_mode = (__mode_t )pasb.PSt_mode;
#line 1364
  asb->sb_stat.st_uid = (__uid_t )pasb.PSt_uid;
#line 1365
  asb->sb_stat.st_gid = (__gid_t )pasb.PSt_gid;
#line 1366
  asb->sb_stat.st_nlink = pasb.PSt_nlink;
#line 1367
  asb->sb_stat.st_rdev = pasb.PSt_rdev;
#line 1368
  asb->sb_stat.st_mtim.tv_sec = (__time_t )pasb.PSt_mtime;
#line 1369
  asb->sb_stat.st_size = (__off_t )pasb.PSt_size;
#line 1370
  if (namelen == 0U) {
    {
#line 1371
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1371
    return (tmp___4);
  } else
#line 1370
  if (namelen >= 1024U) {
    {
#line 1371
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1371
    return (tmp___4);
  }
  {
#line 1372
  tmp___6 = inread(name, namelen);
  }
#line 1372
  if (tmp___6 < 0) {
    {
#line 1373
    tmp___5 = warnarch((char *)"Corrupt ASCII pathname", (off_t )namelen);
    }
#line 1373
    return (tmp___5);
  }
#line 1374
  if ((int )*(name + (namelen - 1U)) != 0) {
    {
#line 1375
    tmp___7 = warnarch((char *)"Bad ASCII pathname", (off_t )namelen);
    }
#line 1375
    return (tmp___7);
  }
#line 1376
  return (0);
}
}
#line 1389 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inascii2(char *magic , char *name , Stat *asb ) 
{ 
  unsigned int namelen ;
  char header[76] ;
  PStat pasb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1396
  tmp = strncmp((char const   *)magic, "070717", (size_t )6);
  }
#line 1396
  if (tmp != 0) {
#line 1397
    return (-1);
  }
  {
#line 1398
  tmp___1 = inread(header, 75U);
  }
#line 1398
  if (tmp___1 < 0) {
    {
#line 1399
    tmp___0 = warnarch((char *)"Corrupt extended ASCII header", (off_t )75);
    }
#line 1399
    return (tmp___0);
  }
  {
#line 1400
  header[75] = (char )'\000';
#line 1401
  tmp___3 = sscanf((char const   */* __restrict  */)(header), (char const   */* __restrict  */)"%6lo%11lo%6lo%6lo%6lo%6lo%6lo%11lo%6o%11lo",
                   & pasb.PSt_dev, & pasb.PSt_ino, & pasb.PSt_mode, & pasb.PSt_uid,
                   & pasb.PSt_gid, & pasb.PSt_nlink, & pasb.PSt_rdev, & pasb.PSt_mtime,
                   & namelen, & pasb.PSt_size);
  }
#line 1401
  if (tmp___3 != 10) {
    {
#line 1405
    tmp___2 = warnarch((char *)"Bad extended ASCII header", (off_t )70);
    }
#line 1405
    return (tmp___2);
  }
#line 1407
  asb->sb_stat.st_dev = pasb.PSt_dev;
#line 1408
  asb->sb_stat.st_ino = pasb.PSt_ino;
#line 1409
  asb->sb_stat.st_mode = (__mode_t )pasb.PSt_mode;
#line 1410
  asb->sb_stat.st_uid = (__uid_t )pasb.PSt_uid;
#line 1411
  asb->sb_stat.st_gid = (__gid_t )pasb.PSt_gid;
#line 1412
  asb->sb_stat.st_nlink = pasb.PSt_nlink;
#line 1413
  asb->sb_stat.st_rdev = pasb.PSt_rdev;
#line 1414
  asb->sb_stat.st_mtim.tv_sec = (__time_t )pasb.PSt_mtime;
#line 1415
  asb->sb_stat.st_size = (__off_t )pasb.PSt_size;
#line 1417
  if (namelen == 0U) {
    {
#line 1418
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1418
    return (tmp___4);
  } else
#line 1417
  if (namelen >= 1024U) {
    {
#line 1418
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1418
    return (tmp___4);
  }
  {
#line 1419
  tmp___6 = inread(name, namelen);
  }
#line 1419
  if (tmp___6 < 0) {
    {
#line 1420
    tmp___5 = warnarch((char *)"Corrupt ASCII pathname", (off_t )namelen);
    }
#line 1420
    return (tmp___5);
  }
#line 1421
  if ((int )*(name + (namelen - 1U)) != 0) {
    {
#line 1422
    tmp___7 = warnarch((char *)"Bad ASCII pathname", (off_t )namelen);
    }
#line 1422
    return (tmp___7);
  }
#line 1423
  return (0);
}
}
#line 1435 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inascii3(char *magic , char *name , Stat *asb ) 
{ 
  unsigned int namelen ;
  char header[111] ;
  PHStat pasb ;
  unsigned int specialflags ;
  unsigned int extraheaderlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1447
  tmp = strncmp((char const   *)magic, "070727", (size_t )6);
  }
#line 1447
  if (tmp != 0) {
#line 1448
    return (-1);
  }
  {
#line 1449
  tmp___1 = inread(header, 110U);
  }
#line 1449
  if (tmp___1 < 0) {
    {
#line 1450
    tmp___0 = warnarch((char *)"Corrupt extended ASCII3 header", (off_t )110);
    }
#line 1450
    return (tmp___0);
  }
  {
#line 1451
  header[110] = (char )'\000';
#line 1452
  tmp___3 = sscanf((char const   */* __restrict  */)(header), (char const   */* __restrict  */)"%8lX%16llXm%6lo%8lX%8lX%8lX%8llX%16llXn%4X%4X%4Xs%16llX:",
                   & pasb.PSt_dev, & pasb.PSt_ino, & pasb.PSt_mode, & pasb.PSt_uid,
                   & pasb.PSt_gid, & pasb.PSt_nlink, & pasb.PSt_rdev, & pasb.PSt_mtime,
                   & namelen, & specialflags, & extraheaderlen, & pasb.PSt_size);
  }
#line 1452
  if (tmp___3 != 12) {
    {
#line 1456
    tmp___2 = warnarch((char *)"Bad extended ASCII3 header", (off_t )70);
    }
#line 1456
    return (tmp___2);
  }
#line 1458
  asb->sb_stat.st_dev = pasb.PSt_dev;
#line 1459
  asb->sb_stat.st_ino = (__ino_t )pasb.PSt_ino;
#line 1460
  asb->sb_stat.st_mode = (__mode_t )pasb.PSt_mode;
#line 1461
  asb->sb_stat.st_uid = (__uid_t )pasb.PSt_uid;
#line 1462
  asb->sb_stat.st_gid = (__gid_t )pasb.PSt_gid;
#line 1463
  asb->sb_stat.st_nlink = pasb.PSt_nlink;
#line 1464
  asb->sb_stat.st_rdev = (__dev_t )pasb.PSt_rdev;
#line 1465
  asb->sb_stat.st_mtim.tv_sec = (__time_t )pasb.PSt_mtime;
#line 1466
  asb->sb_stat.st_size = (__off_t )pasb.PSt_size;
#line 1468
  if (namelen == 0U) {
    {
#line 1469
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1469
    return (tmp___4);
  } else
#line 1468
  if (namelen >= 1024U) {
    {
#line 1469
    tmp___4 = warnarch((char *)"Bad ASCII pathname length", (off_t )70);
    }
#line 1469
    return (tmp___4);
  }
  {
#line 1470
  tmp___6 = inread(name, namelen);
  }
#line 1470
  if (tmp___6 < 0) {
    {
#line 1471
    tmp___5 = warnarch((char *)"Corrupt ASCII pathname", (off_t )namelen);
    }
#line 1471
    return (tmp___5);
  }
#line 1472
  if ((int )*(name + (namelen - 1U)) != 0) {
    {
#line 1473
    tmp___7 = warnarch((char *)"Bad ASCII pathname", (off_t )namelen);
    }
#line 1473
    return (tmp___7);
  }
  {
#line 1474
  tmp___9 = inskip((off_t )extraheaderlen);
  }
#line 1474
  if (tmp___9 < 0) {
    {
#line 1475
    tmp___8 = warnarch((char *)"Corrupt header", (off_t )0);
    }
#line 1475
    return (tmp___8);
  }
#line 1476
  return (0);
}
}
#line 1487 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inavail(char **bufp , unsigned int *lenp ) 
{ 
  register unsigned int have ;
  register int corrupt ;
  int tmp ;

  {
#line 1493
  corrupt = 0;
  {
#line 1495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1495
    have = (unsigned int )(bufend - bufidx);
#line 1495
    if (! (have == 0U)) {
#line 1495
      goto while_break;
    }
    {
#line 1496
    tmp = infill();
#line 1496
    corrupt |= tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1497
  *bufp = bufidx;
#line 1498
  *lenp = have;
#line 1499
  return (corrupt);
}
}
#line 1508 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inbinary(char *magic , char *name , Stat *asb ) 
{ 
  register unsigned int namefull ;
  Binary binary ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1517
  if ((int )*((unsigned short *)magic) != 29127) {
#line 1518
    return (-1);
  }
  {
#line 1519
  memcpy((void */* __restrict  */)((char *)(& binary)), (void const   */* __restrict  */)(magic + sizeof(unsigned short )),
         6UL - sizeof(unsigned short ));
#line 1522
  tmp___0 = inread(((char *)(& binary) + 6) - sizeof(unsigned short ), (unsigned int )(sizeof(binary) - (6UL - sizeof(unsigned short ))));
  }
#line 1522
  if (tmp___0 < 0) {
    {
#line 1524
    tmp = warnarch((char *)"Corrupt binary header", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 1524
    return (tmp);
  }
#line 1526
  asb->sb_stat.st_dev = (__dev_t )binary.b_dev;
#line 1527
  asb->sb_stat.st_ino = (__ino_t )binary.b_ino;
#line 1528
  asb->sb_stat.st_mode = (__mode_t )binary.b_mode;
#line 1529
  asb->sb_stat.st_uid = (__uid_t )binary.b_uid;
#line 1530
  asb->sb_stat.st_gid = (__gid_t )binary.b_gid;
#line 1531
  asb->sb_stat.st_nlink = (__nlink_t )binary.b_nlink;
#line 1532
  asb->sb_stat.st_rdev = (__dev_t )binary.b_rdev;
#line 1533
  asb->sb_stat.st_mtim.tv_sec = (__time_t )(((int )binary.b_mtime[0] << 16) | (int )binary.b_mtime[1]);
#line 1534
  asb->sb_stat.st_size = (__off_t )(((int )binary.b_size[0] << 16) | (int )binary.b_size[1]);
#line 1535
  if ((int )binary.b_name == 0) {
    {
#line 1536
    tmp___1 = warnarch((char *)"Bad binary pathname length", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 1536
    return (tmp___1);
  } else
#line 1535
  if ((int )binary.b_name >= 1024) {
    {
#line 1536
    tmp___1 = warnarch((char *)"Bad binary pathname length", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 1536
    return (tmp___1);
  }
  {
#line 1538
  namefull = (unsigned int )((int )binary.b_name + (int )binary.b_name % 2);
#line 1538
  tmp___3 = inread(name, namefull);
  }
#line 1538
  if (tmp___3 < 0) {
    {
#line 1539
    tmp___2 = warnarch((char *)"Corrupt binary pathname", (off_t )namefull);
    }
#line 1539
    return (tmp___2);
  }
#line 1540
  if ((int )*(name + ((int )binary.b_name - 1)) != 0) {
    {
#line 1541
    tmp___4 = warnarch((char *)"Bad binary pathname", (off_t )namefull);
    }
#line 1541
    return (tmp___4);
  }
#line 1542
  return ((int )(asb->sb_stat.st_size % 2L));
}
}
#line 1550 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int indata(int fd , off_t size , char *name ) 
{ 
  register size_t chunk ;
  register char *oops ;
  register ssize_t sparse ;
  register int corrupt ;
  char *buf ;
  unsigned int avail ;
  int tmp ;
  char *tmp___0 ;
  __off64_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1563
  sparse = (ssize_t )0;
#line 1563
  corrupt = (int )sparse;
#line 1564
  oops = (char *)((void *)0);
  {
#line 1565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1565
    if (! size) {
#line 1565
      goto while_break;
    }
    {
#line 1567
    tmp = inavail(& buf, & avail);
#line 1567
    corrupt |= tmp;
    }
#line 1568
    if (size < (off_t )avail) {
#line 1568
      chunk = (size_t )((unsigned int )size);
    } else {
#line 1568
      chunk = (size_t )avail;
    }
#line 1568
    size = (off_t )((size_t )size - chunk);
#line 1569
    if ((unsigned long )oops == (unsigned long )((void *)0)) {
      {
#line 1569
      sparse = fswrite(fd, buf, chunk);
      }
#line 1569
      if (sparse < 0L) {
        {
#line 1570
        oops = syserr();
        }
      }
    }
    {
#line 1571
    inalloc((unsigned int )chunk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1573
  if (corrupt) {
    {
#line 1574
    warn(name, (char *)"Corrupt archive data");
    }
  }
#line 1575
  if (oops) {
    {
#line 1576
    warn(name, oops);
    }
  } else
#line 1577
  if (sparse > 0L) {
    {
#line 1577
    tmp___1 = lseek(fd, (off_t )-1, 1);
    }
#line 1577
    if (tmp___1 < 0L) {
      {
#line 1580
      tmp___0 = syserr();
#line 1580
      warn(name, tmp___0);
      }
    } else {
      {
#line 1577
      tmp___2 = write(fd, (void const   *)"", (size_t )1);
      }
#line 1577
      if (tmp___2 != 1L) {
        {
#line 1580
        tmp___0 = syserr();
#line 1580
        warn(name, tmp___0);
        }
      }
    }
  }
#line 1581
  return (fd);
}
}
#line 1589 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int incheckdata(int fd , off_t size , char *name , Stat *asb , int comp ) 
{ 
  register unsigned int chunk ;
  register char *oops ;
  register int corrupt ;
  register int warned ;
  char *buf ;
  unsigned int avail ;
  int pfd[2] ;
  int pfdc[2] ;
  int pid ;
  int comppid___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char buff1[40960] ;
  char buff2[40960] ;
  size_t n ;
  ssize_t n1 ;
  ssize_t n2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  char buff1___0[40960] ;
  ssize_t n1___0 ;
  ssize_t n2___0 ;
  ssize_t n___0 ;
  int tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  char *tmp___15 ;

  {
#line 1594
  warned = 0;
#line 1600
  corrupt = 0;
#line 1601
  oops = (char *)((void *)0);
#line 1602
  if (comp) {
    {
#line 1613
    tmp = pipe((int *)(pfd));
    }
#line 1613
    if (tmp < 0) {
      {
#line 1614
      perror("pipe");
#line 1614
      exit(1);
      }
    }
    {
#line 1616
    pid = xfork((char *)"incheckdata, decompressing", 0);
    }
    {
#line 1617
    if (pid == -1) {
#line 1617
      goto case_neg_1;
    }
#line 1621
    if (pid == 0) {
#line 1621
      goto case_0;
    }
#line 1690
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1618
    perror("fork");
#line 1619
    exit(1);
    }
    case_0: /* CIL Label */ 
    {
#line 1622
    close(pfd[1]);
    }
#line 1623
    if (arfd != 0) {
#line 1623
      if (arfd != 1) {
        {
#line 1623
        close(arfd);
        }
      }
    }
    {
#line 1624
    tmp___0 = pipe((int *)(pfdc));
    }
#line 1624
    if (tmp___0 < 0) {
      {
#line 1625
      perror("pipe");
#line 1625
      exit(1);
      }
    }
    {
#line 1627
    comppid___0 = xfork((char *)"incheckdata, decomp", 0);
    }
    {
#line 1628
    if (comppid___0 == -1) {
#line 1628
      goto case_neg_1___0;
    }
#line 1632
    if (comppid___0 == 0) {
#line 1632
      goto case_0___0;
    }
#line 1651
    goto switch_default;
    case_neg_1___0: /* CIL Label */ 
    {
#line 1629
    perror("fork");
#line 1630
    exit(1);
    }
    case_0___0: /* CIL Label */ 
    {
#line 1633
    close(pfdc[0]);
#line 1634
    tmp___1 = fileno(stdin);
#line 1634
    close(tmp___1);
#line 1635
    dup(pfd[0]);
#line 1636
    close(pfd[0]);
#line 1637
    tmp___2 = fileno(stdout);
#line 1637
    close(tmp___2);
#line 1638
    tmp___3 = dup(pfdc[1]);
    }
#line 1638
    if (tmp___3 < 0) {
      {
#line 1639
      exit(1);
      }
    }
    {
#line 1640
    close(pfdc[1]);
#line 1641
    mayberewind();
    }
#line 1642
    if (compressargs) {
      {
#line 1643
      execvp((char const   *)compressprog, (char * const  *)(compress_arg_list));
      }
    } else {
      {
#line 1645
      execlp((char const   *)compressprog, (char const   *)compressprog, "-d", "-c",
             (void *)0);
      }
    }
    {
#line 1646
    tmp___4 = __errno_location();
#line 1646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not uncompress, errno %d\n",
            *tmp___4);
#line 1647
    exit(1);
    }
#line 1648
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1658
    close(pfdc[1]);
#line 1659
    n2 = (ssize_t )1;
#line 1659
    n1 = n2;
    }
    {
#line 1660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1660
      if (n1 > 0L) {
#line 1660
        if (! (n2 > 0L)) {
#line 1660
          goto while_break;
        }
      } else {
#line 1660
        goto while_break;
      }
      {
#line 1661
      n = sizeof(buff1);
#line 1662
      n1 = readall(fd, buff1, n);
#line 1663
      n2 = readall(pfdc[0], buff2, n);
#line 1664
      size -= n1;
      }
#line 1665
      if (n1 < 0L) {
        {
#line 1666
        warn_nocount(name, (char *)"File in archive has different length than file on filesystem");
#line 1667
        corrupt = 1;
        }
#line 1668
        goto while_break;
      } else
#line 1665
      if (n2 < 0L) {
        {
#line 1666
        warn_nocount(name, (char *)"File in archive has different length than file on filesystem");
#line 1667
        corrupt = 1;
        }
#line 1668
        goto while_break;
      } else
#line 1665
      if (n1 != n2) {
        {
#line 1666
        warn_nocount(name, (char *)"File in archive has different length than file on filesystem");
#line 1667
        corrupt = 1;
        }
#line 1668
        goto while_break;
      } else {
        {
#line 1671
        tmp___6 = memcmp((void const   *)(buff1), (void const   *)(buff2), (size_t )n1);
        }
#line 1671
        if (tmp___6 != 0) {
#line 1672
          tmp___5 = warned;
#line 1672
          warned ++;
#line 1672
          if (! tmp___5) {
            {
#line 1673
            warn_nocount(name, (char *)"File in archive has different data than file on filesystem");
            }
          }
#line 1674
          corrupt = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1678
    if (corrupt) {
      {
#line 1679
      kill(comppid___0, 15);
      }
    }
    {
#line 1680
    close(pfdc[0]);
#line 1681
    close(fd);
#line 1682
    tmp___7 = xwait(comppid___0, (char *)"incheckentry xwait() gunzip", 0);
    }
#line 1682
    if (tmp___7 != 0) {
      {
#line 1683
      warn(name, (char *)"uncompressing failure");
#line 1684
      corrupt = 1;
      }
    }
#line 1686
    if (corrupt) {
#line 1686
      tmp___8 = 2;
    } else {
#line 1686
      tmp___8 = 0;
    }
    {
#line 1686
    exit(tmp___8);
    }
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
    {
#line 1692
    close(pfd[0]);
#line 1693
    uncompressrun = pid;
    }
    {
#line 1694
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1694
      if (! asb->sb_stat.st_size) {
#line 1694
        goto while_break___0;
      }
      {
#line 1695
      tmp___9 = inavail(& buf, & avail);
#line 1695
      corrupt |= tmp___9;
      }
#line 1696
      if (corrupt) {
#line 1697
        goto while_break___0;
      }
#line 1699
      if (asb->sb_stat.st_size < (off_t )avail) {
#line 1699
        chunk = (unsigned int )asb->sb_stat.st_size;
      } else {
#line 1699
        chunk = avail;
      }
      {
#line 1699
      asb->sb_stat.st_size -= (__off_t )chunk;
#line 1700
      tmp___10 = writeall(pfd[1], (char const   *)buf, (size_t )chunk);
      }
#line 1700
      if (tmp___10 < 0L) {
        {
#line 1701
        oops = syserr();
        }
      }
      {
#line 1702
      inalloc(chunk);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1704
    close(pfd[1]);
#line 1705
    tmp___11 = xwait(pid, (char *)"incheckentry xwait()", 0);
#line 1705
    corrupt |= tmp___11 != 0;
    }
#line 1706
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1713
      if (asb->sb_stat.st_size) {
#line 1713
        if (! (! corrupt)) {
#line 1713
          goto while_break___1;
        }
      } else {
#line 1713
        goto while_break___1;
      }
      {
#line 1714
      tmp___13 = inavail(& buf, & avail);
#line 1714
      corrupt |= tmp___13;
      }
#line 1714
      if (! corrupt) {
#line 1717
        if (asb->sb_stat.st_size < (off_t )avail) {
#line 1717
          n2___0 = (ssize_t )((size_t )asb->sb_stat.st_size);
        } else {
#line 1717
          n2___0 = (ssize_t )avail;
        }
#line 1718
        if (n2___0 < (ssize_t )sizeof(buff1___0)) {
#line 1718
          n___0 = n2___0;
        } else {
#line 1718
          n___0 = (ssize_t )sizeof(buff1___0);
        }
        {
#line 1719
        n1___0 = readall(fd, buff1___0, (size_t )n___0);
#line 1720
        asb->sb_stat.st_size -= n___0;
        }
#line 1721
        if (n1___0 < 0L) {
#line 1721
          goto _L;
        } else
#line 1721
        if (n2___0 < 0L) {
#line 1721
          goto _L;
        } else
#line 1721
        if (n1___0 != n___0) {
          _L: /* CIL Label */ 
#line 1723
          if (n1___0 != n___0) {
            {
#line 1724
            warn_nocount(name, (char *)"File in archive has different length than file on filesystem");
            }
          }
#line 1725
          corrupt = 1;
        } else {
          {
#line 1729
          tmp___12 = memcmp((void const   *)(buff1___0), (void const   *)buf, (size_t )n___0);
          }
#line 1729
          if (tmp___12 != 0) {
            {
#line 1731
            warn_nocount(name, (char *)"File in archive has different data than file on filesystem");
#line 1732
            corrupt = 1;
            }
          }
        }
        {
#line 1735
        inalloc((unsigned int )n___0);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1739
    tmp___14 = read(fd, (void *)(buff1___0), (size_t )1);
    }
#line 1739
    if (tmp___14 > 0L) {
      {
#line 1741
      warn_nocount(name, (char *)"File in archive is shorter than file on filesystem");
#line 1742
      corrupt = 1;
      }
    }
  }
  {
#line 1745
  close(fd);
  }
#line 1746
  if (oops) {
    {
#line 1747
    warn(name, oops);
    }
  }
#line 1748
  if (corrupt) {
#line 1753
    if (atime_sb.sb_stat.st_mtim.tv_sec == asb->sb_stat.st_mtim.tv_sec) {
#line 1753
      if (atime_sb.sb_stat.st_size == asb->sb_stat.st_size) {
        {
#line 1759
        warn(name, (char *)"File data in archive is corrupt");
#line 1760
        anycorrupt = 1;
        }
      } else {
#line 1753
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1764
      warn(name, (char *)"Archive headers indicate that file on filesystem was modified during or after archive was made");
#line 1766
      tmp___15 = index((char const   *)ignorewarnings, 'r');
      }
#line 1766
      if (tmp___15) {
        {
#line 1768
        warn_nocount(name, (char *)"Not counting this as a verification error");
#line 1769
        warnings --;
        }
      } else {
#line 1772
        anycorrupt = 1;
      }
    }
#line 1776
    return (-1);
  }
#line 1778
  return (0);
}
}
#line 1786 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inentry(char *name , Stat *asb ) 
{ 
  register Link *linkp ;
  register int ifd ;
  register int ofd ;
  struct utimbuf tstamp ;
  int result ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1800
  result = 0;
#line 1802
  linkp = linkfrom(asb, 1);
#line 1802
  ofd = openotty(name, asb, linkp, 0, (int )Zflag);
  }
#line 1802
  if (ofd > 0) {
#line 1804
    if (asb->sb_stat.st_size) {
      {
#line 1805
      tmp = indata(ofd, asb->sb_stat.st_size, name);
#line 1805
      close(tmp);
      }
    } else
#line 1804
    if ((unsigned long )linkp == (unsigned long )((void *)0)) {
      {
#line 1805
      tmp = indata(ofd, asb->sb_stat.st_size, name);
#line 1805
      close(tmp);
      }
    } else
#line 1804
    if (linkp->l_size == 0L) {
      {
#line 1805
      tmp = indata(ofd, asb->sb_stat.st_size, name);
#line 1805
      close(tmp);
      }
    } else {
      {
#line 1806
      ifd = open((char const   *)(linkp->l_path)->p_name, 0);
      }
#line 1806
      if (ifd < 0) {
        {
#line 1807
        tmp___0 = syserr();
#line 1807
        warn((linkp->l_path)->p_name, tmp___0);
        }
      } else {
        {
#line 1810
        passdata((linkp->l_path)->p_name, ifd, name, ofd);
#line 1811
        close(ifd);
#line 1812
        close(ofd);
        }
      }
    }
#line 1815
    if (uncompressrun) {
      {
#line 1817
      result = xwait(uncompressrun, (char *)"inentry xwait()", 1);
#line 1818
      uncompressrun = 0;
      }
#line 1819
      if (result != 0) {
#line 1819
        result = -1;
      }
    }
  } else
#line 1822
  if (ofd < 0) {
#line 1823
    return (-1);
  } else {
    {
#line 1824
    tmp___1 = inskip(asb->sb_stat.st_size);
    }
#line 1824
    if (tmp___1 < 0) {
      {
#line 1825
      warn(name, (char *)"Redundant file data is corrupt");
      }
    }
  }
#line 1828
  if ((asb->sb_stat.st_mode & 61440U) != 40960U) {
#line 1831
    if (mflag) {
#line 1831
      tstamp.modtime = timenow;
    } else {
#line 1831
      tstamp.modtime = asb->sb_stat.st_mtim.tv_sec;
    }
    {
#line 1831
    tstamp.actime = tstamp.modtime;
#line 1832
    utime((char const   *)name, (struct utimbuf  const  *)(& tstamp));
    }
  }
#line 1839
  return (result);
}
}
#line 1847 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int incheckentry(char *name , Stat *asb ) 
{ 
  register int ifd ;
  int compression ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1855
  if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 1855
    if (asb->sb_stat.st_rdev & 2UL) {
      {
#line 1858
      tmp___0 = inentry(name, asb);
      }
#line 1858
      if (tmp___0 < 0) {
        {
#line 1859
        tmp = inskip(asb->sb_stat.st_size);
        }
#line 1859
        if (tmp < 0) {
          {
#line 1860
          warn(name, (char *)"Skipped file data is corrupt");
          }
        }
      }
#line 1863
      return (0);
    }
  }
  {
#line 1866
  uncompressrun = 0;
#line 1873
  ifd = openincheck(name, asb, & compression, (int )Zflag);
  }
#line 1873
  if (ifd > 0) {
#line 1875
    if (asb->sb_stat.st_size) {
      {
#line 1876
      tmp___1 = incheckdata(ifd, asb->sb_stat.st_size, name, asb, compression);
      }
#line 1876
      return (tmp___1);
    }
  } else
#line 1878
  if (ifd < 0) {
#line 1880
    anycorrupt = -1;
#line 1881
    return (-1);
  } else {
    {
#line 1883
    tmp___2 = inskip(asb->sb_stat.st_size);
    }
#line 1883
    if (tmp___2 < 0) {
      {
#line 1884
      warn(name, (char *)"Redundant file data is corrupt");
      }
    }
  }
#line 1885
  if (ifd > 0) {
    {
#line 1886
    close(ifd);
    }
  }
#line 1887
  return (0);
}
}
#line 1901 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static int failed  ;
#line 1897 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int infill(void) 
{ 
  register int got ;
  ulonglong ullreadsize ;
  size_t readsize ;
  char *tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;

  {
#line 1905
  bufidx = buffer;
#line 1905
  bufend = bufidx;
#line 1906
  if (! failed) {
#line 1908
    if (areof) {
#line 1910
      if (total == 0ULL) {
        {
#line 1912
        fatal(arspec, (char *)"No input");
        }
      } else
#line 1916
      if (aruntil != 0ULL) {
        {
#line 1918
        next(0, (char *)"Input EOF");
        }
      } else
#line 1916
      if (askfornext) {
        {
#line 1918
        next(0, (char *)"Input EOF");
        }
      } else {
        {
#line 1922
        fatal(arspec, (char *)"Premature input EOF");
        }
      }
    }
#line 1929
    if (aruntil) {
#line 1929
      if (arleft == 0ULL) {
        {
#line 1930
        next(0, (char *)"Input limit reached");
        }
      }
    }
#line 1932
    if (aruntil) {
#line 1932
      ullreadsize = arleft;
    } else {
#line 1932
      ullreadsize = (ulonglong )((buffer + buflen) - bufend);
    }
#line 1933
    if (ullreadsize > (ulonglong )arbsize) {
#line 1933
      ullreadsize = (ulonglong )arbsize;
    }
#line 1935
    readsize = (size_t )ullreadsize;
    {
#line 1938
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1938
      if (! failed) {
#line 1938
        if (! areof) {
#line 1938
          if (aruntil == 0ULL) {
#line 1938
            goto _L;
          } else
#line 1938
          if (arleft >= (ulonglong )readsize) {
            _L: /* CIL Label */ 
#line 1938
            if (! ((buffer - bufend) + buflen >= (off_t )readsize)) {
#line 1938
              goto while_break;
            }
          } else {
#line 1938
            goto while_break;
          }
        } else {
#line 1938
          goto while_break;
        }
      } else {
#line 1938
        goto while_break;
      }
      {
#line 1943
      tmp___0 = read(arfd, (void *)bufend, readsize);
#line 1943
      got = (int )tmp___0;
      }
#line 1943
      if (got > 0) {
#line 1945
        bufend += got;
#line 1946
        arleft -= (ulonglong )got;
      } else
#line 1948
      if (got < 0) {
        {
#line 1949
        tmp = syserr();
#line 1949
        failed = warnarch(tmp, 0L - (bufend - bufidx));
        }
      } else {
#line 1952
        areof = (short )((int )areof + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1955
  if (failed) {
#line 1955
    if ((unsigned long )bufend == (unsigned long )buffer) {
#line 1957
      failed = 0;
#line 1958
      got = 0;
      {
#line 1958
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1958
        if (! ((unsigned int )got < arbsize)) {
#line 1958
          goto while_break___0;
        }
#line 1959
        tmp___1 = bufend;
#line 1959
        bufend ++;
#line 1959
        *tmp___1 = (char )'\000';
#line 1958
        got ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1960
      return (-1);
    }
  }
#line 1962
  return (0);
}
}
#line 1979 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static int align  ;
#line 1972 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inhead(char *name , Stat *asb ) 
{ 
  register off_t skipped ;
  char magic[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  __time_t tmp___4 ;

  {
#line 1986
  if (align > 0) {
    {
#line 1987
    inskip((off_t )align);
    }
  }
#line 1988
  align = 0;
#line 1990
  bytepos = total;
  {
#line 1992
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1994
    inread(magic, 6U);
#line 1995
    skipped = (off_t )0;
    }
    {
#line 1997
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1997
      align = inascii(magic, name, asb);
      }
#line 1997
      if (align < 0) {
        {
#line 1997
        align = inascii2(magic, name, asb);
        }
#line 1997
        if (align < 0) {
          {
#line 1997
          align = inascii3(magic, name, asb);
          }
#line 1997
          if (align < 0) {
            {
#line 1997
            align = inbinary(magic, name, asb);
            }
#line 1997
            if (align < 0) {
              {
#line 1997
              align = inswab(magic, name, asb);
              }
#line 1997
              if (! (align < 0)) {
#line 1997
                goto while_break___0;
              }
            } else {
#line 1997
              goto while_break___0;
            }
          } else {
#line 1997
            goto while_break___0;
          }
        } else {
#line 1997
          goto while_break___0;
        }
      } else {
#line 1997
        goto while_break___0;
      }
#line 2003
      skipped ++;
#line 2003
      if (skipped == 1L) {
#line 2005
        if (! kflag) {
#line 2005
          if (total - (ulonglong )sizeof(magic) == 0ULL) {
            {
#line 2007
            warn(arspec, (char *)"Input does not start with valid archive header.");
#line 2008
            warn(arspec, (char *)"Use the -k option to start reading in the middle of an archive.");
#line 2009
            fatal(arspec, (char *)"Unrecognizable archive");
            }
          }
        }
        {
#line 2012
        warnarch((char *)"Bad magic number", (off_t )sizeof(magic));
        }
#line 2014
        if (*(name + 0)) {
          {
#line 2015
          warn(name, (char *)"May be corrupt");
          }
        }
      }
      {
#line 2017
      memcpy((void */* __restrict  */)(magic), (void const   */* __restrict  */)(magic + 1),
             sizeof(magic) - 1UL);
#line 2018
      inread((magic + sizeof(magic)) - 1, 1U);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2020
    if (skipped) {
      {
#line 2022
      warnarch((char *)"Apparently resynchronized", (off_t )sizeof(magic));
#line 2024
      warn(name, (char *)"Continuing");
      }
    }
    {
#line 2026
    tmp = strcmp((char const   *)name, "TRAILER!!!");
    }
#line 2026
    if (tmp == 0) {
#line 2027
      return (-1);
    }
    {
#line 2028
    tmp___0 = nameopt(name);
    }
#line 2028
    if (tmp___0 >= 0) {
#line 2029
      goto while_break;
    }
    {
#line 2030
    inskip(asb->sb_stat.st_size + (__off_t )align);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2033
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
    {
#line 2035
    tmp___2 = inread(asb->sb_link, (unsigned int )asb->sb_stat.st_size);
    }
#line 2035
    if (tmp___2 < 0) {
      {
#line 2037
      warn(name, (char *)"Corrupt symbolic link");
#line 2038
      tmp___1 = inhead(name, asb);
      }
#line 2038
      return (tmp___1);
    }
#line 2040
    asb->sb_link[asb->sb_stat.st_size] = (char )'\000';
#line 2041
    asb->sb_stat.st_size = (__off_t )0;
  }
#line 2044
  if ((int )*(name + 0) == 47) {
#line 2044
    if (! abspaths) {
#line 2046
      if (*(name + 1)) {
        {
#line 2048
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2048
          tmp___3 = *(name + 1);
#line 2048
          *(name + 0) = tmp___3;
#line 2048
          if (! tmp___3) {
#line 2048
            goto while_break___1;
          }
#line 2049
          name ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 2053
        *(name + 0) = (char )'.';
      }
    }
  }
#line 2057
  tmp___4 = asb->sb_stat.st_mtim.tv_sec;
#line 2057
  asb->sb_stat.st_ctim.tv_sec = tmp___4;
#line 2057
  asb->sb_stat.st_atim.tv_sec = tmp___4;
#line 2058
  return (0);
}
}
#line 2068 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inread(char *dst , unsigned int len ) 
{ 
  register unsigned int have ;
  register unsigned int want ;
  register int corrupt ;
  char *endx ;
  int tmp ;

  {
#line 2075
  corrupt = 0;
#line 2076
  endx = dst + len;
  {
#line 2078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2078
    want = (unsigned int )(endx - dst);
#line 2078
    if (! want) {
#line 2078
      goto while_break;
    }
    {
#line 2080
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2080
      have = (unsigned int )(bufend - bufidx);
#line 2080
      if (! (have == 0U)) {
#line 2080
        goto while_break___0;
      }
      {
#line 2081
      tmp = infill();
#line 2081
      corrupt |= tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2082
    if (have > want) {
#line 2083
      have = want;
    }
    {
#line 2084
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)bufidx,
           (size_t )have);
#line 2085
    bufidx += have;
#line 2086
    dst += have;
#line 2087
    total += (ulonglong )have;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2089
  return (corrupt);
}
}
#line 2098 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inskip(off_t len ) 
{ 
  register unsigned int chunk ;
  register int corrupt ;
  int tmp ;

  {
#line 2103
  corrupt = 0;
  {
#line 2105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2105
    if (! len) {
#line 2105
      goto while_break;
    }
    {
#line 2107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2107
      chunk = (unsigned int )(bufend - bufidx);
#line 2107
      if (! (chunk == 0U)) {
#line 2107
        goto while_break___0;
      }
      {
#line 2108
      tmp = infill();
#line 2108
      corrupt |= tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2109
    if ((off_t )chunk > len) {
#line 2110
      chunk = (unsigned int )len;
    }
#line 2111
    bufidx += chunk;
#line 2112
    len -= (off_t )chunk;
#line 2113
    total += (ulonglong )chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  return (corrupt);
}
}
#line 2124 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int inswab(char *magic , char *name , Stat *asb ) 
{ 
  register unsigned short namesize ;
  register unsigned int namefull ;
  Binary binary ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2134
  if ((int )*((unsigned short *)magic) != (((29127 >> 8) & 255) | ((29127 << 8) & 65280))) {
#line 2135
    return (-1);
  }
  {
#line 2136
  memcpy((void */* __restrict  */)((char *)(& binary)), (void const   */* __restrict  */)(magic + sizeof(unsigned short )),
         6UL - sizeof(unsigned short ));
#line 2139
  tmp___0 = inread(((char *)(& binary) + 6) - sizeof(unsigned short ), (unsigned int )(sizeof(binary) - (6UL - sizeof(unsigned short ))));
  }
#line 2139
  if (tmp___0 < 0) {
    {
#line 2141
    tmp = warnarch((char *)"Corrupt swapped header", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 2141
    return (tmp);
  }
#line 2143
  asb->sb_stat.st_dev = (dev_t )((((int )((unsigned short )binary.b_dev) >> 8) & 255) | (((int )((unsigned short )binary.b_dev) << 8) & 65280));
#line 2144
  asb->sb_stat.st_ino = (ino_t )((((int )binary.b_ino >> 8) & 255) | (((int )binary.b_ino << 8) & 65280));
#line 2145
  asb->sb_stat.st_mode = (__mode_t )((((int )binary.b_mode >> 8) & 255) | (((int )binary.b_mode << 8) & 65280));
#line 2146
  asb->sb_stat.st_uid = (__uid_t )((((int )binary.b_uid >> 8) & 255) | (((int )binary.b_uid << 8) & 65280));
#line 2147
  asb->sb_stat.st_gid = (__gid_t )((((int )binary.b_gid >> 8) & 255) | (((int )binary.b_gid << 8) & 65280));
#line 2148
  asb->sb_stat.st_nlink = (__nlink_t )((((int )((unsigned short )binary.b_nlink) >> 8) & 255) | (((int )((unsigned short )binary.b_nlink) << 8) & 65280));
#line 2149
  asb->sb_stat.st_rdev = (dev_t )((((int )((unsigned short )binary.b_rdev) >> 8) & 255) | (((int )((unsigned short )binary.b_rdev) << 8) & 65280));
#line 2150
  asb->sb_stat.st_mtim.tv_sec = (__time_t )((((((int )binary.b_mtime[0] >> 8) & 255) | (((int )binary.b_mtime[0] << 8) & 65280)) << 16) | ((((int )binary.b_mtime[1] >> 8) & 255) | (((int )binary.b_mtime[1] << 8) & 65280)));
#line 2151
  asb->sb_stat.st_size = (__off_t )((((((int )binary.b_size[0] >> 8) & 255) | (((int )binary.b_size[0] << 8) & 65280)) << 16) | ((((int )binary.b_size[1] >> 8) & 255) | (((int )binary.b_size[1] << 8) & 65280)));
#line 2152
  namesize = (unsigned short )((((int )binary.b_name >> 8) & 255) | (((int )binary.b_name << 8) & 65280));
#line 2152
  if ((int )namesize == 0) {
    {
#line 2153
    tmp___1 = warnarch((char *)"Bad swapped pathname length", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 2153
    return (tmp___1);
  } else
#line 2152
  if ((int )namesize >= 1024) {
    {
#line 2153
    tmp___1 = warnarch((char *)"Bad swapped pathname length", (off_t )((unsigned long )((off_t )sizeof(binary)) - (6UL - sizeof(unsigned short ))));
    }
#line 2153
    return (tmp___1);
  }
  {
#line 2155
  namefull = (unsigned int )((int )namesize + (int )namesize % 2);
#line 2155
  tmp___3 = inread(name, namefull);
  }
#line 2155
  if (tmp___3 < 0) {
    {
#line 2156
    tmp___2 = warnarch((char *)"Corrupt swapped pathname", (off_t )namefull);
    }
#line 2156
    return (tmp___2);
  }
#line 2157
  if ((int )*(name + ((int )namesize - 1)) != 0) {
    {
#line 2158
    tmp___4 = warnarch((char *)"Bad swapped pathname", (off_t )namefull);
    }
#line 2158
    return (tmp___4);
  }
#line 2159
  return ((int )(asb->sb_stat.st_size % 2L));
}
}
#line 2167 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int lineget(FILE *stream , char *buf , int bufsize ) 
{ 
  register int c ;
  int size ;
  char *bufstart ;
  char *tmp ;

  {
#line 2177
  size = 0;
#line 2178
  bufstart = buf;
  {
#line 2180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2182
    c = _IO_getc(stream);
    }
#line 2182
    if (c == -1) {
#line 2183
      return (-1);
    }
#line 2184
    if (! flag0) {
#line 2184
      if (c == 10) {
#line 2185
        goto while_break;
      } else {
#line 2184
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2184
    if (flag0) {
#line 2184
      if (c == 0) {
#line 2185
        goto while_break;
      }
    }
#line 2186
    if (size < bufsize - 1) {
#line 2187
      tmp = buf;
#line 2187
      buf ++;
#line 2187
      *tmp = (char )c;
    }
#line 2188
    size ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2191
  *buf = (char )'\000';
#line 2193
  if (size > bufsize - 1) {
    {
#line 2194
    warn(bufstart, (char *)"Path name too long, truncated");
    }
  }
#line 2196
  return (0);
}
}
#line 2205 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void linkalso(Link *linkp , char *name ) 
{ 
  register Path *path ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 2212
  tmp = memget((unsigned int )sizeof(Path ));
#line 2212
  path = (Path *)tmp;
  }
#line 2212
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2214
    return;
  } else {
    {
#line 2212
    tmp___0 = memstr(name);
#line 2212
    path->p_name = tmp___0;
    }
#line 2212
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 2214
      return;
    }
  }
#line 2215
  path->p_forw = (struct name *)((void *)0);
#line 2216
  path->p_back = (linkp->l_path)->p_back;
#line 2217
  (path->p_back)->p_forw = path;
#line 2218
  (linkp->l_path)->p_back = path;
#line 2219
  return;
}
}
#line 2234 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Link *linkfrom(Stat *asb , int installing ) 
{ 
  register Link *linkp ;
  register Link *linknext ;
  register Link **abase ;

  {
#line 2244
  if (asb->sb_stat.st_nlink <= 1UL) {
#line 2244
    return ((Link *)((void *)0));
  }
#line 2246
  if ((asb->sb_stat.st_mode & 61440U) == 16384U) {
#line 2246
    return ((Link *)((void *)0));
  }
#line 2248
  if (installing) {
#line 2248
    if (asb->sb_stat.st_size != 0L) {
#line 2248
      return ((Link *)((void *)0));
    }
  }
#line 2250
  abase = linkbase + (asb->sb_stat.st_ino & 65535UL) % (sizeof(linkbase) / sizeof(linkbase[0]));
#line 2250
  linkp = *abase;
  {
#line 2250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2250
    if (! linkp) {
#line 2250
      goto while_break;
    }
#line 2253
    if (linkp->l_ino == asb->sb_stat.st_ino) {
#line 2253
      if (linkp->l_dev == asb->sb_stat.st_dev) {
#line 2253
        if (linkp->l_mtime == asb->sb_stat.st_mtim.tv_sec) {
#line 2253
          if ((__mode_t )linkp->l_mode == asb->sb_stat.st_mode) {
#line 2261
            linkp->l_nlink = (unsigned short )((int )linkp->l_nlink - 1);
#line 2271
            return (linkp);
          }
        }
      }
    }
#line 2274
    linknext = linkp->l_forw;
#line 2250
    linkp = linknext;
  }
  while_break: /* CIL Label */ ;
  }
#line 2277
  return ((Link *)((void *)0));
}
}
#line 2286 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void linkleft(void) 
{ 
  register Link *lp ;
  register Link **base ;

  {
#line 2292
  base = linkbase;
  {
#line 2292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2292
    if (! ((unsigned long )base < (unsigned long )(linkbase + sizeof(linkbase) / sizeof(linkbase[0])))) {
#line 2292
      goto while_break;
    }
#line 2293
    lp = *base;
    {
#line 2293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2293
      if (! lp) {
#line 2293
        goto while_break___0;
      }
#line 2296
      if (lp->l_nlink) {
        {
#line 2297
        warn((lp->l_path)->p_name, (char *)"Unseen link(s)");
        }
      }
#line 2293
      lp = lp->l_forw;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2292
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2300
  return;
}
}
#line 2316 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
Link *linkto(char *name , Stat *asb ) 
{ 
  register Link *linkp ;
  register Path *path ;
  register Link **abase ;
  ino_t ino ;
  int ino16 ;
  ino_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  __ino_t tmp___3 ;
  struct link *tmp___4 ;
  Link *tmp___5 ;

  {
#line 2327
  if ((asb->sb_stat.st_mode & 61440U) == 16384U) {
#line 2328
    return ((Link *)((void *)0));
  }
#line 2330
  if (! extfmt) {
#line 2338
    ino = asb->sb_stat.st_ino & 65535UL;
    {
#line 2341
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2343
      ino16 = (int )(ino & 65535UL);
#line 2347
      if (((int )ino16bitused[ino16 / 8] & (1 << (ino16 & 7))) == 0) {
#line 2347
        goto while_break;
      }
#line 2350
      tmp = freshino;
#line 2350
      freshino ++;
#line 2350
      ino = tmp;
#line 2352
      if (freshino > 65535UL) {
#line 2355
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2362
    ino = asb->sb_stat.st_ino;
  }
  {
#line 2368
  ino16 = (int )(ino & 65535UL);
#line 2369
  ino16bitused[ino16 / 8] = (unsigned char )((int )ino16bitused[ino16 / 8] | (1 << (ino16 & 7)));
#line 2372
  tmp___0 = memget((unsigned int )sizeof(Link ));
#line 2372
  linkp = (Link *)tmp___0;
  }
#line 2372
  if ((unsigned long )linkp == (unsigned long )((void *)0)) {
#line 2375
    return ((Link *)((void *)0));
  } else {
    {
#line 2372
    tmp___1 = memget((unsigned int )sizeof(Path ));
#line 2372
    path = (Path *)tmp___1;
    }
#line 2372
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2375
      return ((Link *)((void *)0));
    } else {
      {
#line 2372
      tmp___2 = memstr(name);
#line 2372
      path->p_name = tmp___2;
      }
#line 2372
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 2375
        return ((Link *)((void *)0));
      }
    }
  }
#line 2377
  linkp->l_dev = asb->sb_stat.st_dev;
#line 2378
  linkp->l_ino = asb->sb_stat.st_ino;
#line 2379
  linkp->l_nlink = (unsigned short )(asb->sb_stat.st_nlink - 1UL);
#line 2380
  linkp->l_size = asb->sb_stat.st_size;
#line 2381
  linkp->l_mtime = asb->sb_stat.st_mtim.tv_sec;
#line 2382
  linkp->l_mode = (unsigned short )asb->sb_stat.st_mode;
#line 2383
  linkp->l_path = path;
#line 2384
  path->p_forw = (struct name *)((void *)0);
#line 2385
  path->p_back = path;
#line 2387
  tmp___3 = ino;
#line 2387
  asb->sb_stat.st_ino = tmp___3;
#line 2387
  linkp->l_ino_ar = tmp___3;
#line 2389
  abase = linkbase + (linkp->l_ino & 65535UL) % (sizeof(linkbase) / sizeof(linkbase[0]));
#line 2389
  tmp___4 = *abase;
#line 2389
  linkp->l_forw = tmp___4;
#line 2389
  if (tmp___4) {
#line 2390
    (linkp->l_forw)->l_back = linkp;
  }
#line 2391
  linkp->l_back = (struct link *)((void *)0);
#line 2393
  tmp___5 = linkp;
#line 2393
  *abase = tmp___5;
#line 2393
  return (tmp___5);
}
}
#line 2428 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static short outofmem  ;
#line 2423 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *memget(unsigned int len ) 
{ 
  register char *mem ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 2430
  tmp___0 = malloc((size_t )len);
#line 2430
  mem = (char *)tmp___0;
  }
#line 2430
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 2430
    if (! outofmem) {
      {
#line 2431
      tmp = warn((char *)"memget()", (char *)"Out of memory");
#line 2431
      outofmem = (short )tmp;
      }
    }
  }
#line 2432
  return (mem);
}
}
#line 2440 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *memstr(char *str ) 
{ 
  register char *mem ;
  size_t tmp ;

  {
  {
#line 2446
  tmp = strlen((char const   *)str);
#line 2446
  mem = memget((unsigned int )tmp + 1U);
  }
#line 2446
  if (mem) {
    {
#line 2447
    strcpy((char */* __restrict  */)mem, (char const   */* __restrict  */)str);
    }
  }
#line 2448
  return (mem);
}
}
#line 2494 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int nameopt(char *begin ) 
{ 
  register char *name ;
  register char *item ;
  register int idx ;
  int absolute ;
  char *element[256] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 2504
  name = begin;
#line 2504
  absolute = (int )*name == 47;
#line 2505
  idx = 0;
  {
#line 2506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2508
    if (idx == 256) {
      {
#line 2509
      tmp = warn(begin, (char *)"Too many elements");
      }
#line 2509
      return (tmp);
    }
    {
#line 2510
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2510
      if (! ((int )*name == 47)) {
#line 2510
        goto while_break___0;
      }
#line 2511
      name ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2512
    if ((int )*name == 0) {
#line 2513
      goto while_break;
    }
#line 2514
    item = name;
#line 2514
    element[idx] = item;
    {
#line 2515
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2515
      if (*name) {
#line 2515
        if (! ((int )*name != 47)) {
#line 2515
          goto while_break___1;
        }
      } else {
#line 2515
        goto while_break___1;
      }
#line 2516
      name ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2517
    if (*name) {
#line 2518
      tmp___0 = name;
#line 2518
      name ++;
#line 2518
      *tmp___0 = (char )'\000';
    }
    {
#line 2519
    tmp___3 = strcmp((char const   *)item, "..");
    }
#line 2519
    if (tmp___3 == 0) {
#line 2520
      if (idx == 0) {
#line 2521
        if (! absolute) {
#line 2524
          idx ++;
        }
      } else {
        {
#line 2525
        tmp___1 = strcmp((char const   *)element[idx - 1], "..");
        }
#line 2525
        if (tmp___1 == 0) {
#line 2526
          idx ++;
        } else {
#line 2528
          idx --;
        }
      }
    } else {
      {
#line 2529
      tmp___2 = strcmp((char const   *)item, ".");
      }
#line 2529
      if (tmp___2 != 0) {
#line 2530
        idx ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2532
  if (idx == 0) {
#line 2533
    tmp___4 = idx;
#line 2533
    idx ++;
#line 2533
    if (absolute) {
#line 2533
      element[tmp___4] = (char *)"";
    } else {
#line 2533
      element[tmp___4] = (char *)".";
    }
  }
#line 2534
  element[idx] = (char *)((void *)0);
#line 2535
  name = begin;
#line 2536
  if (absolute) {
#line 2537
    tmp___5 = name;
#line 2537
    name ++;
#line 2537
    *tmp___5 = (char )'/';
  }
#line 2538
  idx = 0;
  {
#line 2538
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2538
    item = element[idx];
#line 2538
    if (! item) {
#line 2538
      goto while_break___2;
    }
    {
#line 2539
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2539
      if (! *item) {
#line 2539
        goto while_break___3;
      }
#line 2540
      tmp___7 = name;
#line 2540
      name ++;
#line 2540
      tmp___8 = item;
#line 2540
      item ++;
#line 2540
      *tmp___7 = *tmp___8;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2538
    idx ++;
#line 2538
    tmp___6 = name;
#line 2538
    name ++;
#line 2538
    *tmp___6 = (char )'/';
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2541
  name --;
#line 2541
  *name = (char )'\000';
#line 2542
  return (idx);
}
}
#line 2551 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void next(int mode , char *why ) 
{ 
  register time_t began ;
  char *msg___0 ;
  int msgsize ;
  char answer[20] ;
  int ttyfd ;
  char *ttystr ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int result ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  time_t tmp___9 ;

  {
  {
#line 2563
  tmp = strlen((char const   *)myname);
#line 2563
  tmp___0 = strlen((char const   *)(arspec));
#line 2563
  msgsize = (int )((200UL + tmp * 2UL) + tmp___0);
  }
#line 2564
  if (promptscript) {
    {
#line 2564
    tmp___1 = strlen((char const   *)promptscript);
#line 2564
    msgsize = (int )((size_t )msgsize + tmp___1);
    }
  }
  {
#line 2565
  msg___0 = memget((unsigned int )msgsize);
#line 2567
  began = time((time_t *)((void *)0));
#line 2568
  nextclos();
#line 2569
  tmp___2 = index((char const   *)ignorewarnings, 'M');
  }
#line 2569
  if (! tmp___2) {
    {
#line 2571
    warnarch(why, (off_t )0);
#line 2572
    warnings --;
    }
  }
#line 2574
  if (arfd == 0) {
    {
#line 2575
    goodbye(1);
    }
  } else
#line 2574
  if (arfd == 1) {
    {
#line 2575
    goodbye(1);
    }
  }
#line 2576
  arvolume ++;
#line 2578
  if (email) {
    {
#line 2578
    mail(email, (int )arvolume, arspec);
    }
  }
#line 2580
  if (promptscript) {
    {
#line 2590
    ttyfd = open("/dev/tty", 2);
    }
#line 2590
    if (ttyfd < 0) {
#line 2592
      ttystr = (char *)"/dev/null";
    } else {
      {
#line 2596
      close(ttyfd);
#line 2597
      ttystr = (char *)"/dev/tty";
      }
    }
    {
#line 2600
    sprintf((char */* __restrict  */)msg___0, (char const   */* __restrict  */)"%s %u %s \'%s\' <%s",
            promptscript, arvolume, arspec, why, ttystr);
    }
    {
#line 2601
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2605
      result = system((char const   *)msg___0);
      }
#line 2606
      if (result == 1) {
        {
#line 2607
        fatal(arspec, (char *)"Aborted");
        }
      }
#line 2608
      if (result != 0) {
        {
#line 2609
        fatal(arspec, (char *)"Promptscript failed");
        }
      }
      {
#line 2610
      tmp___3 = nextopen(mode);
      }
#line 2610
      if (tmp___3 == 0) {
#line 2611
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2617
    if (Fflag) {
      {
#line 2619
      sprintf((char */* __restrict  */)msg___0, (char const   */* __restrict  */)"%s: Ready for disk %u on %s\n%s: \"quit\" to abort,\"f\" to format, anything else to proceed. > \a",
              myname, arvolume, arspec, myname);
      }
    } else {
      {
#line 2629
      sprintf((char */* __restrict  */)msg___0, (char const   */* __restrict  */)"%s: Ready for volume %u on %s\n%s: \"quit\" to abort, anything else to proceed. > \a",
              myname, arvolume, arspec, myname);
      }
    }
    {
#line 2638
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2640
      nextask(msg___0, answer, (int )sizeof(answer));
#line 2641
      tmp___7 = strcmp((char const   *)(answer), "quit");
      }
#line 2641
      if (tmp___7 == 0) {
        {
#line 2642
        fatal(arspec, (char *)"Aborted");
        }
      } else {
        {
#line 2645
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2645
          if (Fflag) {
            {
#line 2645
            tmp___5 = strcmp((char const   *)(answer), "f");
            }
#line 2645
            if (! (tmp___5 == 0)) {
#line 2645
              goto while_break___1;
            }
          } else {
#line 2645
            goto while_break___1;
          }
          {
#line 2646
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"formating using %s ...\n",
                  formatcmd);
#line 2647
          tmp___4 = system((char const   *)formatcmd);
          }
#line 2647
          if (tmp___4 != 0) {
            {
#line 2649
            strcpy((char */* __restrict  */)msg___0, (char const   */* __restrict  */)"\n");
#line 2650
            strcat((char */* __restrict  */)msg___0, (char const   */* __restrict  */)myname);
#line 2651
            strcat((char */* __restrict  */)msg___0, (char const   */* __restrict  */)": Format failed! Try again (y/n)? > ");
#line 2652
            nextask(msg___0, answer, (int )sizeof(answer));
            }
#line 2653
            if ((int )answer[0] == 121) {
#line 2653
              answer[0] = (char )'f';
            } else {
              {
#line 2654
              exit(1);
              }
            }
          } else {
#line 2656
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2659
        tmp___6 = nextopen(mode);
        }
#line 2659
        if (tmp___6 == 0) {
#line 2660
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2664
  tmp___8 = index((char const   *)ignorewarnings, 'M');
  }
#line 2664
  if (! tmp___8) {
    {
#line 2666
    warnarch((char *)"Continuing", (off_t )0);
#line 2667
    warnings --;
    }
  }
  {
#line 2669
  tmp___9 = time((time_t *)((void *)0));
#line 2669
  timewait += tmp___9 - began;
#line 2670
  free((void *)msg___0);
  }
#line 2671
  return;
}
}
#line 2678 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void nextask(char *msg___0 , char *answer , int limit ) 
{ 
  register int idx ;
  register int got ;
  char c ;
  size_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  char *tmp___2 ;

  {
#line 2688
  if (ttyf < 0) {
    {
#line 2689
    ttyf = openqtty();
    }
  }
#line 2690
  if (ttyf < 0) {
    {
#line 2691
    fatal((char *)"/dev/tty", (char *)"Unavailable");
    }
  }
  {
#line 2692
  tmp = strlen((char const   *)msg___0);
#line 2692
  writeall(ttyf, (char const   *)msg___0, (size_t )((unsigned int )tmp));
#line 2693
  idx = 0;
  }
  {
#line 2694
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2694
    tmp___1 = read(ttyf, (void *)(& c), (size_t )1);
#line 2694
    got = (int )tmp___1;
    }
#line 2694
    if (! (got == 1)) {
#line 2694
      goto while_break;
    }
#line 2695
    if ((int )c == 4) {
#line 2696
      goto while_break;
    } else
#line 2695
    if ((int )c == 10) {
#line 2696
      goto while_break;
    } else
#line 2697
    if ((int )c == 32) {
#line 2698
      goto while_continue;
    } else
#line 2697
    if ((int )c == 9) {
#line 2698
      goto while_continue;
    } else
#line 2699
    if (idx < limit - 1) {
#line 2700
      tmp___0 = idx;
#line 2700
      idx ++;
#line 2700
      *(answer + tmp___0) = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2701
  if (got < 0) {
    {
#line 2702
    tmp___2 = syserr();
#line 2702
    fatal((char *)"/dev/tty", tmp___2);
    }
  }
#line 2703
  *(answer + idx) = (char )'\000';
#line 2704
  return;
}
}
#line 2711 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void nextclos(void) 
{ 


  {
#line 2714
  if (arfd != 0) {
#line 2714
    if (arfd != 1) {
#line 2714
      if (! fflag) {
        {
#line 2716
        close(arfd);
#line 2717
        arfd = -1;
        }
      }
    }
  }
#line 2719
  areof = (short)0;
#line 2720
  if (arname) {
#line 2720
    if ((int )*arname == 33) {
      {
#line 2721
      pipewait();
      }
    }
  }
#line 2726
  if (aruntil != 0ULL) {
    {
#line 2728
    update_aruntil();
    }
#line 2729
    if (aruntil == 0ULL) {
#line 2729
      askfornext = 1;
    }
#line 2731
    if (roundaruntil) {
#line 2736
      aruntil /= (ulonglong )arbsize;
#line 2737
      aruntil *= (ulonglong )arbsize;
    }
#line 2741
    if (aruntil) {
#line 2741
      if (aruntil < (ulonglong )arbsize) {
        {
#line 2743
        fatal(arspec, (char *)"-s option value for this volume smaller than block (-b) size");
        }
      }
    }
  }
#line 2747
  return;
}
}
#line 2754 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int nextopen(int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 2759
  if (arfd != -1) {
    {
#line 2760
    close(arfd);
    }
  }
#line 2762
  if ((int )*arname == 33) {
    {
#line 2763
    arfd = pipeopen(mode);
    }
  } else {
    {
#line 2764
    tmp___1 = strcmp((char const   *)arname, "-");
    }
#line 2764
    if (tmp___1 == 0) {
#line 2765
      if (mode) {
#line 2765
        arfd = 1;
      } else {
#line 2765
        arfd = 0;
      }
    } else {
      {
#line 2768
      process_arname(arname);
      }
#line 2785
      if (Fflag) {
#line 2785
        if (mode) {
          {
#line 2786
          arfd = open((char const   *)(proc_arname), ((mode | 64) | 512) | 1052672,
                      438 & ~ ((int )mask));
          }
        } else {
#line 2785
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2788
      if (mode) {
        {
#line 2788
        tmp = creat((char const   *)(proc_arname), (mode_t )(438 & ~ ((int )mask)));
#line 2788
        arfd = tmp;
        }
      } else {
        {
#line 2788
        tmp___0 = open((char const   *)(proc_arname), mode);
#line 2788
        arfd = tmp___0;
        }
      }
    }
  }
#line 2794
  if (arfd < 0) {
    {
#line 2795
    tmp___2 = syserr();
#line 2795
    tmp___3 = warnarch(tmp___2, (off_t )0);
    }
#line 2795
    return (tmp___3);
  }
#line 2796
  arleft = aruntil;
#line 2797
  return (0);
}
}
#line 2810 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int openin(char *name , char *fsname , Stat *asb , int *cratio ) 
{ 
  int fd ;
  char local[1024] ;
  char *label ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  __off_t tmp___14 ;
  char *tmp___15 ;

  {
#line 2820
  if (fsname) {
#line 2820
    *fsname = (char )'\000';
  }
#line 2822
  if (cratio) {
#line 2823
    *cratio = 100;
  }
  {
#line 2824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2826
    if ((int )firstfilename[0] != 0) {
      {
#line 2829
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)(firstfilename));
#line 2830
      firstfilename[0] = (char)0;
      }
    } else {
      {
#line 2834
      tmp = lineget(stdin, name, 1024);
      }
#line 2834
      if (tmp < 0) {
#line 2835
        return (-1);
      }
    }
    {
#line 2839
    tmp___3 = strncmp((char const   *)name, "//--", (size_t )4);
    }
#line 2839
    if (tmp___3 == 0) {
      {
#line 2841
      strcpy((char */* __restrict  */)(local), (char const   */* __restrict  */)(name + 4));
#line 2843
      label = index((char const   *)(local), ' ');
      }
#line 2844
      if ((unsigned long )label != (unsigned long )((void *)0)) {
#line 2846
        *label = (char )'\000';
#line 2847
        label ++;
      } else {
#line 2850
        label = (char *)"no_label";
      }
#line 2851
      if ((int )*label == 0) {
#line 2851
        label = (char *)"no_label";
      }
      {
#line 2853
      sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/%s",
              "CONTROL_FILE", label);
#line 2859
      tmp___1 = stat((char const   */* __restrict  */)(local), (struct stat */* __restrict  */)(& asb->sb_stat));
      }
#line 2859
      if (tmp___1 < 0) {
        {
#line 2861
        tmp___0 = syserr();
#line 2861
        warn(local, tmp___0);
        }
#line 2862
        goto __Cont;
      }
#line 2867
      if (! ((asb->sb_stat.st_mode & 61440U) == 24576U)) {
#line 2867
        if (! ((asb->sb_stat.st_mode & 61440U) == 8192U)) {
#line 2867
          asb->sb_stat.st_rdev = (__dev_t )0;
        }
      }
#line 2869
      if ((asb->sb_stat.st_mode & 61440U) != 32768U) {
        {
#line 2871
        warn(local, (char *)"Cannot read control file from this source.");
        }
#line 2872
        goto __Cont;
      }
#line 2879
      asb->sb_stat.st_rdev |= 2UL;
#line 2881
      if (asb->sb_stat.st_size == 0L) {
#line 2882
        return (0);
      }
      {
#line 2883
      fd = open((char const   *)(local), 0);
      }
#line 2883
      if (fd >= 0) {
#line 2884
        return (fd);
      }
      {
#line 2885
      tmp___2 = syserr();
#line 2885
      warn(local, tmp___2);
      }
#line 2886
      goto __Cont;
    }
    {
#line 2891
    tmp___4 = namecmp(name, (Stat *)((void *)0));
    }
#line 2891
    if (tmp___4 < 0) {
#line 2892
      goto __Cont;
    }
    {
#line 2893
    tmp___5 = nameopt(name);
    }
#line 2893
    if (tmp___5 < 0) {
#line 2894
      goto __Cont;
    }
#line 2895
    if (! gflag) {
      {
#line 2896
      strcpy((char */* __restrict  */)(local), (char const   */* __restrict  */)name);
      }
    } else {
      {
#line 2897
      tmp___6 = dirchg(name, local);
      }
#line 2897
      if (tmp___6 < 0) {
#line 2898
        goto __Cont;
      }
    }
#line 2900
    if (fsname) {
      {
#line 2900
      strcpy((char */* __restrict  */)fsname, (char const   */* __restrict  */)(local));
      }
    }
#line 2902
    if (hflag) {
      {
#line 2902
      tmp___10 = stat((char const   */* __restrict  */)(local), (struct stat */* __restrict  */)(& asb->sb_stat));
#line 2902
      tmp___12 = tmp___10;
      }
    } else {
      {
#line 2902
      tmp___11 = lstat((char const   */* __restrict  */)(local), (struct stat */* __restrict  */)(& asb->sb_stat));
#line 2902
      tmp___12 = tmp___11;
      }
    }
#line 2902
    if (tmp___12 < 0) {
      {
#line 2904
      tmp___7 = syserr();
#line 2904
      warn(name, tmp___7);
#line 2905
      tmp___8 = index((char const   *)ignorewarnings, 'm');
      }
#line 2905
      if (tmp___8) {
#line 2905
        warnings --;
      }
      {
#line 2912
      tmp___9 = __errno_location();
      }
#line 2912
      if (*tmp___9 == 75) {
        {
#line 2913
        warn(name, (char *)"Can\'t archive file with size >= 2GB");
        }
      }
#line 2915
      goto __Cont;
    }
#line 2920
    if (! ((asb->sb_stat.st_mode & 61440U) == 24576U)) {
#line 2920
      if (! ((asb->sb_stat.st_mode & 61440U) == 8192U)) {
#line 2920
        asb->sb_stat.st_rdev = (__dev_t )0;
      }
    }
    {
#line 2924
    if ((asb->sb_stat.st_mode & 61440U) == 16384U) {
#line 2924
      goto case_16384;
    }
#line 2929
    if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
#line 2929
      goto case_40960;
    }
#line 2939
    if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 2939
      goto case_32768;
    }
#line 2963
    goto switch_default;
    case_16384: /* CIL Label */ 
#line 2925
    asb->sb_stat.st_nlink = (__nlink_t )1;
#line 2926
    asb->sb_stat.st_size = (__off_t )0;
#line 2927
    return (0);
    case_40960: /* CIL Label */ 
    {
#line 2930
    tmp___14 = readlink((char const   */* __restrict  */)(local), (char */* __restrict  */)(asb->sb_link),
                        sizeof(asb->sb_link) - 1UL);
#line 2930
    asb->sb_stat.st_size = tmp___14;
    }
#line 2930
    if (tmp___14 < 0L) {
      {
#line 2933
      tmp___13 = syserr();
#line 2933
      warn(name, tmp___13);
      }
#line 2934
      goto __Cont;
    }
#line 2936
    asb->sb_link[asb->sb_stat.st_size] = (char )'\000';
#line 2937
    return (0);
    case_32768: /* CIL Label */ 
#line 2940
    if (asb->sb_stat.st_size == 0L) {
#line 2943
      asb->sb_stat.st_rdev |= 1UL;
#line 2944
      return (0);
    }
#line 2947
    if (cpiocompat) {
#line 2947
      if (asb->sb_stat.st_size != (asb->sb_stat.st_size & 2147483647L)) {
        {
#line 2950
        fatal(name, (char *)"Archiving file with size >= 2GB not allowed by -5 option");
        }
#line 2951
        goto __Cont;
      }
    }
    {
#line 2954
    fd = open((char const   *)(local), 0);
    }
#line 2954
    if (fd >= 0) {
#line 2956
      if (Zflag) {
        {
#line 2957
        compressfile(& fd, name, asb, cratio);
        }
      }
#line 2959
      return (fd);
    }
    {
#line 2961
    tmp___15 = syserr();
#line 2961
    warn(name, tmp___15);
    }
#line 2962
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2964
    asb->sb_stat.st_size = (__off_t )0;
#line 2965
    return (0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2977 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int openincheck(char *name , Stat *asb , int *comp , int dozflag ) 
{ 
  int fd ;
  char local[1024] ;
  char archlink[1024] ;
  char *namedot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 2989
  uncompto[0] = (char )'\000';
#line 2990
  *comp = 0;
#line 2991
  if (dozflag) {
#line 2991
    if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
      {
#line 2991
      namedot = strrchr((char const   *)name, '.');
      }
#line 2991
      if ((unsigned long )namedot != (unsigned long )((void *)0)) {
#line 2991
        if ((asb->sb_stat.st_rdev & 1UL) == 0UL) {
#line 2991
          if (asb->sb_stat.st_size > 0L) {
            {
#line 2991
            tmp = strcmp((char const   *)namedot, ".z");
            }
#line 2991
            if (tmp == 0) {
              {
#line 2997
              *namedot = (char )'\000';
#line 2998
              strcpy((char */* __restrict  */)(uncompto), (char const   */* __restrict  */)name);
#line 2999
              *comp = 1;
              }
            } else {
#line 3002
              namedot = (char *)((void *)0);
            }
          } else {
#line 3002
            namedot = (char *)((void *)0);
          }
        } else {
#line 3002
          namedot = (char *)((void *)0);
        }
      } else {
#line 3002
        namedot = (char *)((void *)0);
      }
    } else {
#line 3002
      namedot = (char *)((void *)0);
    }
  } else {
#line 3002
    namedot = (char *)((void *)0);
  }
  {
#line 3003
  tmp___0 = nameopt(name);
  }
#line 3003
  if (tmp___0 < 0) {
#line 3004
    return (-1);
  }
#line 3005
  if (! gflag) {
    {
#line 3006
    strcpy((char */* __restrict  */)(local), (char const   */* __restrict  */)name);
    }
  } else {
    {
#line 3007
    tmp___1 = dirchg(name, local);
    }
#line 3007
    if (tmp___1 < 0) {
#line 3008
      return (0);
    }
  }
  {
#line 3011
  if ((asb->sb_stat.st_mode & 61440U) == 16384U) {
#line 3011
    goto case_16384;
  }
#line 3018
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
#line 3018
    goto case_40960;
  }
#line 3041
  if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 3041
    goto case_32768;
  }
#line 3096
  goto switch_default;
  case_16384: /* CIL Label */ 
#line 3012
  asb->sb_stat.st_nlink = (__nlink_t )1;
#line 3013
  asb->sb_stat.st_size = (__off_t )0;
#line 3016
  return (0);
  case_40960: /* CIL Label */ 
#line 3021
  if (asb->sb_stat.st_size == 0L) {
#line 3022
    return (0);
  }
  {
#line 3024
  strcpy((char */* __restrict  */)(archlink), (char const   */* __restrict  */)(asb->sb_link));
#line 3026
  tmp___3 = readlink((char const   */* __restrict  */)(local), (char */* __restrict  */)(asb->sb_link),
                     sizeof(asb->sb_link) - 1UL);
#line 3026
  asb->sb_stat.st_size = tmp___3;
  }
#line 3026
  if (tmp___3 < 0L) {
    {
#line 3029
    tmp___2 = syserr();
#line 3029
    warn(name, tmp___2);
#line 3030
    asb->sb_stat.st_size = (__off_t )0;
    }
#line 3031
    return (0);
  }
  {
#line 3033
  asb->sb_link[asb->sb_stat.st_size] = (char )'\000';
#line 3035
  tmp___4 = strcmp((char const   *)(archlink), (char const   *)(asb->sb_link));
  }
#line 3035
  if (tmp___4 != 0) {
    {
#line 3036
    warn(name, (char *)"Difference in symlink destination filename");
    }
  }
#line 3038
  asb->sb_stat.st_size = (__off_t )0;
#line 3039
  return (0);
  case_32768: /* CIL Label */ 
#line 3045
  if (aflag) {
    {
#line 3047
    tmp___5 = stat((char const   */* __restrict  */)(local), (struct stat */* __restrict  */)(& atime_sb.sb_stat));
    }
#line 3047
    if (! (tmp___5 < 0)) {
#line 3053
      atime_sb_valid = 1;
    }
  }
  {
#line 3057
  fd = open((char const   *)(local), 0);
  }
#line 3057
  if (fd >= 0) {
#line 3070
    if (asb->sb_stat.st_size == 0L) {
#line 3070
      if (asb->sb_stat.st_nlink == 1UL) {
        {
#line 3072
        tmp___7 = stat((char const   */* __restrict  */)(local), (struct stat */* __restrict  */)(& atime_sb.sb_stat));
        }
#line 3072
        if (tmp___7 >= 0) {
#line 3074
          if (asb->sb_stat.st_size != atime_sb.sb_stat.st_size) {
            {
#line 3076
            warn(name, (char *)"File in archive has different length than file on filesystem");
#line 3077
            tmp___6 = index((char const   *)ignorewarnings, 'r');
            }
#line 3077
            if (tmp___6) {
              {
#line 3079
              warn_nocount(name, (char *)"Not counting this as a verification error");
#line 3080
              warnings --;
              }
            }
          }
        }
      }
    }
#line 3085
    return (fd);
  }
  {
#line 3087
  tmp___8 = syserr();
#line 3087
  warn_nocount(name, tmp___8);
#line 3088
  warn(name, (char *)"File on filesystem could not be opened for verify");
#line 3089
  tmp___9 = index((char const   *)ignorewarnings, 'r');
  }
#line 3089
  if (tmp___9) {
    {
#line 3091
    warn_nocount(name, (char *)"Not counting this as a verification error");
#line 3092
    warnings --;
    }
  }
#line 3095
  return (0);
  switch_default: /* CIL Label */ 
#line 3097
  asb->sb_stat.st_size = (__off_t )0;
#line 3098
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3109 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int opencontrolscript(char *name ) 
{ 
  int pfd[2] ;
  int comppid___0 ;
  char *label ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 3116
  uncompto[0] = (char )'\000';
#line 3118
  if ((unsigned long )controlscript == (unsigned long )((void *)0)) {
    {
#line 3121
    warnarch((char *)"No -D option given, ignoring control file.", (off_t )0);
#line 3122
    tmp = open("/dev/null", 1);
    }
#line 3122
    return (tmp);
  }
  {
#line 3125
  tmp___1 = strcmp((char const   *)controlscript, "");
  }
#line 3125
  if (tmp___1 == 0) {
    {
#line 3128
    tmp___0 = open("/dev/null", 1);
    }
#line 3128
    return (tmp___0);
  }
  {
#line 3131
  label = index((char const   *)name, '/');
  }
#line 3132
  if ((unsigned long )label == (unsigned long )((void *)0)) {
#line 3132
    label = (char *)"no_label";
  } else {
#line 3132
    label ++;
  }
  {
#line 3134
  tmp___3 = pipe((int *)(pfd));
  }
#line 3134
  if (tmp___3 < 0) {
    {
#line 3136
    tmp___2 = syserr();
#line 3136
    warn((char *)"Control script", tmp___2);
    }
#line 3137
    return (-1);
  }
  {
#line 3140
  comppid___0 = xfork((char *)"opencontrolscript(in), running control script", 0);
  }
#line 3140
  if (comppid___0 == 0) {
    {
#line 3143
    signal(13, (void (*)(int  ))0);
    }
#line 3145
    if (arfd != 0) {
#line 3145
      if (arfd != 1) {
        {
#line 3145
        close(arfd);
        }
      }
    }
    {
#line 3146
    close(pfd[1]);
#line 3147
    tmp___4 = fileno(stdin);
#line 3147
    close(tmp___4);
#line 3148
    dup(pfd[0]);
#line 3149
    close(pfd[0]);
#line 3151
    execlp((char const   *)controlscript, (char const   *)controlscript, label, (void *)0);
#line 3153
    warnarch((char *)"Problems running control script:", (off_t )0);
#line 3154
    tmp___5 = syserr();
#line 3154
    warn(controlscript, tmp___5);
#line 3155
    exit(1);
    }
  }
#line 3160
  if (comppid___0 < 0) {
    {
#line 3162
    tmp___6 = syserr();
#line 3162
    warn((char *)"Control script", tmp___6);
    }
#line 3163
    return (-1);
  }
  {
#line 3166
  close(pfd[0]);
#line 3169
  uncompressrun = comppid___0;
  }
#line 3171
  return (pfd[1]);
}
}
#line 3182 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int openotty(char *name , Stat *asb , Link *linkp , int ispass , int dozflag ) 
{ 
  register int exists ;
  register int fd ;
  register unsigned short perm ;
  unsigned short operm ;
  uid_t ouid ;
  gid_t ogid ;
  Path *path ;
  Stat osb ;
  register int ssize ;
  char sname[1024] ;
  char *namedot ;
  int pfd[2] ;
  int comppid___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  time_t tmp___40 ;
  time_t tmp___41 ;
  time_t tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  char *tmp___65 ;
  int tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  ssize_t tmp___73 ;
  char *tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int *tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  char *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  char *tmp___84 ;
  int tmp___85 ;
  int *tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int *tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  char *tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  __uid_t tmp___98 ;
  int tmp___99 ;
  __uid_t tmp___100 ;
  int tmp___101 ;

  {
#line 3193
  operm = (unsigned short)0;
#line 3194
  ouid = (uid_t )9999;
#line 3195
  ogid = (gid_t )9999;
#line 3206
  if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 3206
    if (asb->sb_stat.st_rdev & 2UL) {
      {
#line 3207
      tmp = opencontrolscript(name);
      }
#line 3207
      return (tmp);
    }
  }
#line 3209
  uncompto[0] = (char )'\000';
#line 3213
  if (dozflag) {
#line 3213
    if (! linkp) {
#line 3213
      if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
        {
#line 3213
        namedot = strrchr((char const   *)name, '.');
        }
#line 3213
        if ((unsigned long )namedot != (unsigned long )((void *)0)) {
#line 3213
          if ((asb->sb_stat.st_rdev & 1UL) == 0UL) {
#line 3213
            if (asb->sb_stat.st_size > 0L) {
              {
#line 3213
              tmp___0 = strcmp((char const   *)namedot, ".z");
              }
#line 3213
              if (tmp___0 == 0) {
#line 3219
                *namedot = (char )'\000';
              } else {
#line 3222
                namedot = (char *)((void *)0);
              }
            } else {
#line 3222
              namedot = (char *)((void *)0);
            }
          } else {
#line 3222
            namedot = (char *)((void *)0);
          }
        } else {
#line 3222
          namedot = (char *)((void *)0);
        }
      } else {
#line 3222
        namedot = (char *)((void *)0);
      }
    } else {
#line 3222
      namedot = (char *)((void *)0);
    }
  } else {
#line 3222
    namedot = (char *)((void *)0);
  }
  {
#line 3223
  tmp___8 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& osb.sb_stat));
#line 3223
  exists = tmp___8 == 0;
  }
#line 3223
  if (exists) {
#line 3227
    if (ispass) {
#line 3227
      if (osb.sb_stat.st_ino == asb->sb_stat.st_ino) {
#line 3227
        if (osb.sb_stat.st_dev == asb->sb_stat.st_dev) {
          {
#line 3230
          tmp___1 = warn(name, (char *)"Same file");
          }
#line 3230
          return (tmp___1);
        } else {
#line 3227
          goto _L___0;
        }
      } else {
#line 3227
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3231
    if ((osb.sb_stat.st_mode & 61440U) == (asb->sb_stat.st_mode & 61440U)) {
#line 3232
      if (xflag) {
#line 3232
        tmp___2 = 4095;
      } else {
#line 3232
        tmp___2 = 511;
      }
#line 3232
      operm = (unsigned short )(osb.sb_stat.st_mode & (unsigned int )tmp___2);
    } else {
#line 3233
      if ((osb.sb_stat.st_mode & 61440U) == 16384U) {
        {
#line 3233
        tmp___5 = rmdir((char const   *)name);
#line 3233
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 3233
        tmp___6 = unlink((char const   *)name);
#line 3233
        tmp___7 = tmp___6;
        }
      }
#line 3233
      if (tmp___7 < 0) {
        {
#line 3234
        tmp___3 = syserr();
#line 3234
        tmp___4 = warn(name, tmp___3);
        }
#line 3234
        return (tmp___4);
      } else {
#line 3236
        exists = 0;
      }
    }
  }
#line 3238
  if (linkp) {
#line 3240
    if (exists) {
      {
#line 3258
      tmp___11 = unlink((char const   *)name);
      }
#line 3258
      if (tmp___11 < 0) {
        {
#line 3259
        tmp___9 = syserr();
#line 3259
        tmp___10 = warn(name, tmp___9);
        }
#line 3259
        return (tmp___10);
      } else {
#line 3261
        exists = 0;
      }
    }
#line 3263
    path = linkp->l_path;
    {
#line 3263
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3263
      if (! path) {
#line 3263
        goto while_break;
      }
      {
#line 3264
      tmp___15 = link((char const   *)path->p_name, (char const   *)name);
      }
#line 3264
      if (tmp___15 == 0) {
#line 3268
        return (0);
      } else {
        {
#line 3264
        tmp___16 = __errno_location();
        }
#line 3264
        if (*tmp___16 == 2) {
          {
#line 3264
          tmp___17 = dirneed(name);
          }
#line 3264
          if (tmp___17 == 0) {
            {
#line 3264
            tmp___18 = link((char const   *)path->p_name, (char const   *)name);
            }
#line 3264
            if (tmp___18 == 0) {
#line 3268
              return (0);
            } else {
#line 3264
              goto _L___2;
            }
          } else {
#line 3264
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 3269
          tmp___14 = __errno_location();
          }
#line 3269
          if (*tmp___14 != 18) {
            {
#line 3270
            tmp___12 = syserr();
#line 3270
            tmp___13 = warn(name, tmp___12);
            }
#line 3270
            return (tmp___13);
          }
        }
      }
#line 3263
      path = path->p_forw;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3271
    warn(name, (char *)"Link broken");
#line 3272
    linkalso(linkp, name);
    }
  }
#line 3274
  if (xflag) {
#line 3274
    tmp___19 = 4095;
  } else {
#line 3274
    tmp___19 = 511;
  }
#line 3274
  perm = (unsigned short )(asb->sb_stat.st_mode & (unsigned int )tmp___19);
#line 3275
  if (exists) {
#line 3277
    ouid = osb.sb_stat.st_uid;
#line 3278
    ogid = osb.sb_stat.st_gid;
  }
  {
#line 3283
  if ((asb->sb_stat.st_mode & 61440U) == 8192U) {
#line 3283
    goto case_8192;
  }
#line 3283
  if ((asb->sb_stat.st_mode & 61440U) == 24576U) {
#line 3283
    goto case_8192;
  }
#line 3310
  if ((asb->sb_stat.st_mode & 61440U) == 16384U) {
#line 3310
    goto case_16384;
  }
#line 3330
  if ((asb->sb_stat.st_mode & 61440U) == 4096U) {
#line 3330
    goto case_4096;
  }
#line 3344
  if ((asb->sb_stat.st_mode & 61440U) == 49152U) {
#line 3344
    goto case_49152;
  }
#line 3358
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
#line 3358
    goto case_40960;
  }
#line 3378
  if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 3378
    goto case_32768;
  }
#line 3440
  goto switch_default;
  case_8192: /* CIL Label */ 
  case_24576: /* CIL Label */ 
#line 3284
  fd = 0;
#line 3289
  if (asb->sb_stat.st_rdev == 0UL) {
#line 3289
    asb->sb_stat.st_rdev = (asb->sb_stat.st_dev << 16) + asb->sb_stat.st_ino;
  }
#line 3291
  if (exists) {
#line 3293
    if (asb->sb_stat.st_rdev == osb.sb_stat.st_rdev) {
#line 3294
      if ((int )perm != (int )operm) {
        {
#line 3294
        tmp___22 = chmod((char const   *)name, (__mode_t )perm);
        }
#line 3294
        if (tmp___22 < 0) {
          {
#line 3295
          tmp___20 = syserr();
#line 3295
          tmp___21 = warn(name, tmp___20);
          }
#line 3295
          return (tmp___21);
        } else {
#line 3297
          goto switch_break;
        }
      } else {
#line 3297
        goto switch_break;
      }
    } else {
#line 3298
      if ((osb.sb_stat.st_mode & 61440U) == 16384U) {
        {
#line 3298
        tmp___25 = rmdir((char const   *)name);
#line 3298
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 3298
        tmp___26 = unlink((char const   *)name);
#line 3298
        tmp___27 = tmp___26;
        }
      }
#line 3298
      if (tmp___27 < 0) {
        {
#line 3299
        tmp___23 = syserr();
#line 3299
        tmp___24 = warn(name, tmp___23);
        }
#line 3299
        return (tmp___24);
      } else {
#line 3301
        exists = 0;
      }
    }
  }
  {
#line 3304
  tmp___30 = mknod((char const   *)name, asb->sb_stat.st_mode, asb->sb_stat.st_rdev);
  }
#line 3304
  if (tmp___30 < 0) {
    {
#line 3304
    tmp___31 = __errno_location();
    }
#line 3304
    if (*tmp___31 != 2) {
      {
#line 3308
      tmp___28 = syserr();
#line 3308
      tmp___29 = warn(name, tmp___28);
      }
#line 3308
      return (tmp___29);
    } else {
      {
#line 3304
      tmp___32 = dirneed(name);
      }
#line 3304
      if (tmp___32 < 0) {
        {
#line 3308
        tmp___28 = syserr();
#line 3308
        tmp___29 = warn(name, tmp___28);
        }
#line 3308
        return (tmp___29);
      } else {
        {
#line 3304
        tmp___33 = mknod((char const   *)name, asb->sb_stat.st_mode, asb->sb_stat.st_rdev);
        }
#line 3304
        if (tmp___33 < 0) {
          {
#line 3308
          tmp___28 = syserr();
#line 3308
          tmp___29 = warn(name, tmp___28);
          }
#line 3308
          return (tmp___29);
        }
      }
    }
  }
#line 3309
  goto switch_break;
  case_16384: /* CIL Label */ 
#line 3311
  if (exists) {
#line 3313
    if (xflag) {
#line 3313
      if (asb->sb_stat.st_uid != ouid) {
#line 3313
        goto _L___5;
      } else
#line 3313
      if (asb->sb_stat.st_gid != ogid) {
        _L___5: /* CIL Label */ 
        {
#line 3313
        tmp___39 = chown((char const   *)name, asb->sb_stat.st_uid, asb->sb_stat.st_gid);
        }
#line 3313
        if (tmp___39 < 0) {
          {
#line 3315
          tmp___34 = syserr();
#line 3315
          tmp___35 = warn(name, tmp___34);
          }
#line 3315
          return (tmp___35);
        } else {
#line 3313
          goto _L___4;
        }
      } else {
#line 3313
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 3316
    if ((int )perm != (int )operm) {
      {
#line 3316
      tmp___38 = chmod((char const   *)name, (__mode_t )perm);
      }
#line 3316
      if (tmp___38 < 0) {
        {
#line 3317
        tmp___36 = syserr();
#line 3317
        tmp___37 = warn(name, tmp___36);
        }
#line 3317
        return (tmp___37);
      }
    }
#line 3319
    if (mflag) {
#line 3319
      tmp___41 = timenow;
    } else {
#line 3319
      tmp___41 = asb->sb_stat.st_mtim.tv_sec;
    }
#line 3319
    if (osb.sb_stat.st_mtim.tv_sec <= tmp___41) {
#line 3320
      if (mflag) {
#line 3320
        tmp___40 = timenow;
      } else {
#line 3320
        tmp___40 = asb->sb_stat.st_mtim.tv_sec;
      }
      {
#line 3320
      savedirstamp(name, tmp___40);
      }
    }
  } else {
#line 3324
    if (mflag) {
#line 3324
      tmp___42 = timenow;
    } else {
#line 3324
      tmp___42 = asb->sb_stat.st_mtim.tv_sec;
    }
    {
#line 3324
    savedirstamp(name, tmp___42);
#line 3325
    tmp___45 = dirneed(name);
    }
#line 3325
    if (tmp___45 < 0) {
      {
#line 3326
      tmp___43 = syserr();
#line 3326
      tmp___44 = warn(name, tmp___43);
      }
#line 3326
      return (tmp___44);
    } else {
      {
#line 3325
      tmp___46 = dirmake(name, asb);
      }
#line 3325
      if (tmp___46 < 0) {
        {
#line 3326
        tmp___43 = syserr();
#line 3326
        tmp___44 = warn(name, tmp___43);
        }
#line 3326
        return (tmp___44);
      }
    }
  }
#line 3328
  return (0);
  case_4096: /* CIL Label */ 
#line 3331
  fd = 0;
#line 3332
  if (exists) {
#line 3333
    if ((int )perm != (int )operm) {
      {
#line 3333
      tmp___49 = chmod((char const   *)name, (__mode_t )perm);
      }
#line 3333
      if (tmp___49 < 0) {
        {
#line 3334
        tmp___47 = syserr();
#line 3334
        tmp___48 = warn(name, tmp___47);
        }
#line 3334
        return (tmp___48);
      }
    }
  } else {
    {
#line 3336
    tmp___52 = mkfifo((char const   *)name, asb->sb_stat.st_mode);
    }
#line 3336
    if (tmp___52 < 0) {
      {
#line 3336
      tmp___53 = __errno_location();
      }
#line 3336
      if (*tmp___53 != 2) {
        {
#line 3340
        tmp___50 = syserr();
#line 3340
        tmp___51 = warn(name, tmp___50);
        }
#line 3340
        return (tmp___51);
      } else {
        {
#line 3336
        tmp___54 = dirneed(name);
        }
#line 3336
        if (tmp___54 < 0) {
          {
#line 3340
          tmp___50 = syserr();
#line 3340
          tmp___51 = warn(name, tmp___50);
          }
#line 3340
          return (tmp___51);
        } else {
          {
#line 3336
          tmp___55 = mkfifo((char const   *)name, asb->sb_stat.st_mode);
          }
#line 3336
          if (tmp___55 < 0) {
            {
#line 3340
            tmp___50 = syserr();
#line 3340
            tmp___51 = warn(name, tmp___50);
            }
#line 3340
            return (tmp___51);
          }
        }
      }
    }
  }
#line 3341
  goto switch_break;
  case_49152: /* CIL Label */ 
#line 3345
  fd = 0;
#line 3346
  if (exists) {
#line 3347
    if ((int )perm != (int )operm) {
      {
#line 3347
      tmp___58 = chmod((char const   *)name, (__mode_t )perm);
      }
#line 3347
      if (tmp___58 < 0) {
        {
#line 3348
        tmp___56 = syserr();
#line 3348
        tmp___57 = warn(name, tmp___56);
        }
#line 3348
        return (tmp___57);
      }
    }
  } else {
    {
#line 3350
    tmp___61 = mknod((char const   *)name, asb->sb_stat.st_mode, (dev_t )0);
    }
#line 3350
    if (tmp___61 < 0) {
      {
#line 3350
      tmp___62 = __errno_location();
      }
#line 3350
      if (*tmp___62 != 2) {
        {
#line 3354
        tmp___59 = syserr();
#line 3354
        tmp___60 = warn(name, tmp___59);
        }
#line 3354
        return (tmp___60);
      } else {
        {
#line 3350
        tmp___63 = dirneed(name);
        }
#line 3350
        if (tmp___63 < 0) {
          {
#line 3354
          tmp___59 = syserr();
#line 3354
          tmp___60 = warn(name, tmp___59);
          }
#line 3354
          return (tmp___60);
        } else {
          {
#line 3350
          tmp___64 = mknod((char const   *)name, asb->sb_stat.st_mode, (dev_t )0);
          }
#line 3350
          if (tmp___64 < 0) {
            {
#line 3354
            tmp___59 = syserr();
#line 3354
            tmp___60 = warn(name, tmp___59);
            }
#line 3354
            return (tmp___60);
          }
        }
      }
    }
  }
#line 3355
  goto switch_break;
  case_40960: /* CIL Label */ 
#line 3359
  fd = 0;
#line 3360
  if (exists) {
    {
#line 3362
    tmp___73 = readlink((char const   */* __restrict  */)name, (char */* __restrict  */)(sname),
                        sizeof(sname));
#line 3362
    ssize = (int )tmp___73;
    }
#line 3362
    if (ssize < 0) {
      {
#line 3363
      tmp___65 = syserr();
#line 3363
      tmp___66 = warn(name, tmp___65);
      }
#line 3363
      return (tmp___66);
    } else {
      {
#line 3364
      tmp___72 = strncmp((char const   *)(sname), (char const   *)(asb->sb_link),
                         (size_t )ssize);
      }
#line 3364
      if (tmp___72 == 0) {
#line 3365
        goto switch_break;
      } else {
#line 3366
        if ((osb.sb_stat.st_mode & 61440U) == 16384U) {
          {
#line 3366
          tmp___69 = rmdir((char const   *)name);
#line 3366
          tmp___71 = tmp___69;
          }
        } else {
          {
#line 3366
          tmp___70 = unlink((char const   *)name);
#line 3366
          tmp___71 = tmp___70;
          }
        }
#line 3366
        if (tmp___71 < 0) {
          {
#line 3367
          tmp___67 = syserr();
#line 3367
          tmp___68 = warn(name, tmp___67);
          }
#line 3367
          return (tmp___68);
        } else {
#line 3369
          exists = 0;
        }
      }
    }
  }
  {
#line 3371
  tmp___76 = symlink((char const   *)(asb->sb_link), (char const   *)name);
  }
#line 3371
  if (tmp___76 < 0) {
    {
#line 3371
    tmp___77 = __errno_location();
    }
#line 3371
    if (*tmp___77 != 2) {
      {
#line 3375
      tmp___74 = syserr();
#line 3375
      tmp___75 = warn(name, tmp___74);
      }
#line 3375
      return (tmp___75);
    } else {
      {
#line 3371
      tmp___78 = dirneed(name);
      }
#line 3371
      if (tmp___78 < 0) {
        {
#line 3375
        tmp___74 = syserr();
#line 3375
        tmp___75 = warn(name, tmp___74);
        }
#line 3375
        return (tmp___75);
      } else {
        {
#line 3371
        tmp___79 = symlink((char const   *)(asb->sb_link), (char const   *)name);
        }
#line 3371
        if (tmp___79 < 0) {
          {
#line 3375
          tmp___74 = syserr();
#line 3375
          tmp___75 = warn(name, tmp___74);
          }
#line 3375
          return (tmp___75);
        }
      }
    }
  }
#line 3376
  goto switch_break;
  case_32768: /* CIL Label */ 
#line 3379
  if (exists) {
#line 3381
    if (nflag) {
#line 3381
      if (osb.sb_stat.st_mtim.tv_sec > asb->sb_stat.st_mtim.tv_sec) {
        {
#line 3382
        tmp___80 = warn_nocount(name, (char *)"Newer file exists");
        }
#line 3382
        return (tmp___80);
      } else {
#line 3381
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 3383
      tmp___83 = unlink((char const   *)name);
      }
#line 3383
      if (tmp___83 < 0) {
        {
#line 3384
        tmp___81 = syserr();
#line 3384
        tmp___82 = warn(name, tmp___81);
        }
#line 3384
        return (tmp___82);
      } else {
#line 3386
        exists = 0;
      }
    }
  }
  {
#line 3389
  fd = creat((char const   *)name, (mode_t )perm);
  }
#line 3389
  if (fd < 0) {
    {
#line 3389
    tmp___86 = __errno_location();
    }
#line 3389
    if (*tmp___86 != 2) {
      {
#line 3393
      tmp___84 = syserr();
#line 3393
      tmp___85 = warn(name, tmp___84);
      }
#line 3393
      return (tmp___85);
    } else {
      {
#line 3389
      tmp___87 = dirneed(name);
      }
#line 3389
      if (tmp___87 < 0) {
        {
#line 3393
        tmp___84 = syserr();
#line 3393
        tmp___85 = warn(name, tmp___84);
        }
#line 3393
        return (tmp___85);
      } else {
        {
#line 3389
        fd = creat((char const   *)name, (mode_t )perm);
        }
#line 3389
        if (fd < 0) {
          {
#line 3393
          tmp___84 = syserr();
#line 3393
          tmp___85 = warn(name, tmp___84);
          }
#line 3393
          return (tmp___85);
        }
      }
    }
  }
#line 3394
  if (dozflag) {
#line 3394
    if (! linkp) {
#line 3394
      if (namedot) {
        {
#line 3396
        tmp___92 = pipe((int *)(pfd));
        }
#line 3396
        if (tmp___92 >= 0) {
          {
#line 3398
          comppid___0 = xfork((char *)"openotty(in), compressing", 0);
          }
#line 3398
          if (comppid___0 == 0) {
#line 3400
            if (arfd != 0) {
#line 3400
              if (arfd != 1) {
                {
#line 3400
                close(arfd);
                }
              }
            }
            {
#line 3401
            close(pfd[1]);
#line 3402
            tmp___88 = fileno(stdin);
#line 3402
            close(tmp___88);
#line 3403
            dup(pfd[0]);
#line 3404
            close(pfd[0]);
#line 3406
            tmp___89 = fileno(stdout);
#line 3406
            close(tmp___89);
#line 3407
            tmp___90 = dup(fd);
            }
#line 3407
            if (tmp___90 < 0) {
              {
#line 3408
              exit(1);
              }
            }
            {
#line 3409
            close(fd);
#line 3410
            mayberewind();
            }
#line 3411
            if (compressargs) {
              {
#line 3412
              execvp((char const   *)compressprog, (char * const  *)(compress_arg_list));
              }
            } else {
              {
#line 3414
              execlp((char const   *)compressprog, (char const   *)compressprog, "-d",
                     "-c", (void *)0);
              }
            }
            {
#line 3415
            tmp___91 = __errno_location();
#line 3415
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not uncompress, errno %d\n",
                    *tmp___91);
#line 3416
            exit(1);
            }
          } else
#line 3420
          if (comppid___0 > 0) {
            {
#line 3422
            close(fd);
#line 3423
            fd = pfd[1];
#line 3424
            close(pfd[0]);
#line 3425
            uncompressrun = comppid___0;
#line 3426
            strcpy((char */* __restrict  */)(uncompto), (char const   */* __restrict  */)name);
            }
#line 3430
            goto switch_break;
          }
        }
        {
#line 3434
        unlink((char const   *)name);
#line 3435
        *namedot = (char )'.';
#line 3436
        tmp___93 = openotty(name, asb, linkp, ispass, 0);
        }
#line 3436
        return (tmp___93);
      }
    }
  }
#line 3439
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3441
  tmp___94 = warn(name, (char *)"Unknown filetype");
  }
#line 3441
  return (tmp___94);
  switch_break: /* CIL Label */ ;
  }
#line 3445
  if ((asb->sb_stat.st_mode & 61440U) != 40960U) {
#line 3447
    if (xflag) {
#line 3447
      if (! exists) {
#line 3447
        goto _L___7;
      } else
#line 3447
      if (asb->sb_stat.st_uid != osb.sb_stat.st_uid) {
#line 3447
        goto _L___7;
      } else
#line 3447
      if (asb->sb_stat.st_gid != osb.sb_stat.st_gid) {
        _L___7: /* CIL Label */ 
#line 3450
        if (uid == 0U) {
#line 3450
          tmp___98 = asb->sb_stat.st_uid;
        } else {
#line 3450
          tmp___98 = uid;
        }
        {
#line 3450
        tmp___99 = chown((char const   *)name, tmp___98, asb->sb_stat.st_gid);
        }
#line 3450
        if (tmp___99) {
          {
#line 3452
          perror((char const   *)name);
          }
        } else
#line 3454
        if ((int )perm & 3584) {
          {
#line 3455
          tmp___97 = chmod((char const   *)name, (__mode_t )perm);
          }
#line 3455
          if (tmp___97 < 0) {
            {
#line 3456
            tmp___95 = syserr();
#line 3456
            tmp___96 = warn(name, tmp___95);
            }
#line 3456
            return (tmp___96);
          }
        }
      }
    }
  } else
#line 3467
  if (xflag) {
#line 3467
    if (! exists) {
#line 3467
      goto _L___8;
    } else
#line 3467
    if (asb->sb_stat.st_uid != osb.sb_stat.st_uid) {
#line 3467
      goto _L___8;
    } else
#line 3467
    if (asb->sb_stat.st_gid != osb.sb_stat.st_gid) {
      _L___8: /* CIL Label */ 
#line 3470
      if (uid == 0U) {
#line 3470
        tmp___100 = asb->sb_stat.st_uid;
      } else {
#line 3470
        tmp___100 = uid;
      }
      {
#line 3470
      tmp___101 = lchown((char const   *)name, tmp___100, asb->sb_stat.st_gid);
      }
#line 3470
      if (tmp___101) {
        {
#line 3472
        perror((char const   *)name);
        }
      }
    }
  }
#line 3477
  if ((unsigned long )linkp == (unsigned long )((void *)0)) {
#line 3477
    if (asb->sb_stat.st_nlink > 1UL) {
      {
#line 3478
      linkto(name, asb);
      }
    }
  }
#line 3479
  return (fd);
}
}
#line 3490 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int openqtty(void) 
{ 
  register void (*intr)(int  ) ;
  int fd ;
  char *tmp ;
  int tmp___0 ;

  {
#line 3496
  fd = -1;
#line 3497
  if (! Fflag) {
    {
#line 3499
    intr = signal(2, (void (*)(int  ))1);
    }
#line 3499
    if ((unsigned long )intr == (unsigned long )((void (*)(int  ))1)) {
#line 3500
      return (fd);
    }
    {
#line 3501
    signal(2, intr);
    }
  }
  {
#line 3504
  fd = open("/dev/tty", 2);
  }
#line 3504
  if (fd < 0) {
    {
#line 3506
    tmp = syserr();
#line 3506
    warn((char *)"/dev/tty", tmp);
    }
  } else {
    {
#line 3508
    tmp___0 = isatty(fd);
    }
#line 3508
    if (! tmp___0) {
      {
#line 3509
      warn((char *)"/dev/tty", (char *)"Is not a tty");
      }
    }
  }
#line 3510
  return (fd);
}
}
#line 3532 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static int optsub  ;
#line 3524 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int options(int ac , char **av , char *proto ) 
{ 
  register int c ;
  register char *idx ;
  int tmp ;
  int tmp___0 ;

  {
#line 3534
  if (optind == 0) {
#line 3536
    optind = 1;
#line 3537
    optsub = 0;
  }
#line 3539
  optarg = (char *)((void *)0);
#line 3540
  if (optind >= ac) {
#line 3541
    return (0);
  }
#line 3542
  if (optsub == 0) {
#line 3542
    if ((int )*(*(av + optind) + 0) != 45) {
#line 3543
      return (0);
    } else
#line 3542
    if ((int )*(*(av + optind) + 1) == 0) {
#line 3543
      return (0);
    }
  }
#line 3544
  optsub ++;
#line 3544
  c = (int )*(*(av + optind) + optsub);
  {
#line 3546
  if (c == 0) {
#line 3546
    goto case_0;
  }
#line 3550
  if (c == 45) {
#line 3550
    goto case_45;
  }
#line 3554
  if (c == 58) {
#line 3554
    goto case_58;
  }
#line 3544
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 3547
  optind ++;
#line 3548
  optsub = 0;
#line 3549
  tmp = options(ac, av, proto);
  }
#line 3549
  return (tmp);
  case_45: /* CIL Label */ 
#line 3551
  optind ++;
#line 3552
  optsub = 0;
#line 3553
  return (0);
  case_58: /* CIL Label */ 
#line 3555
  return ('?');
  switch_break: /* CIL Label */ ;
  }
  {
#line 3557
  idx = strchr((char const   *)proto, c);
  }
#line 3557
  if ((unsigned long )idx == (unsigned long )((void *)0)) {
#line 3558
    return ('?');
  }
#line 3559
  if ((int )*(idx + 1) != 58) {
#line 3560
    return (c);
  }
#line 3561
  optsub ++;
#line 3561
  optarg = *(av + optind) + optsub;
#line 3562
  optind ++;
#line 3563
  optsub = 0;
#line 3564
  if (*optarg) {
#line 3565
    return (c);
  }
#line 3566
  if (optind >= ac) {
#line 3567
    return ('?');
  }
#line 3568
  tmp___0 = optind;
#line 3568
  optind ++;
#line 3568
  optarg = *(av + tmp___0);
#line 3569
  return (c);
}
}
#line 3579 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ulonglong optsize(char *str ) 
{ 
  register char *idx ;
  ulonglong number ;
  ulonglong result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 3587
  result = (ulonglong )0;
#line 3588
  idx = str;
  {
#line 3589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3591
    number = (ulonglong )0;
    {
#line 3592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3592
      if ((int )*idx >= 48) {
#line 3592
        if (! ((int )*idx <= 57)) {
#line 3592
          goto while_break___0;
        }
      } else {
#line 3592
        goto while_break___0;
      }
#line 3593
      tmp = idx;
#line 3593
      idx ++;
#line 3593
      number = (number * 10ULL + (ulonglong )*tmp) - 48ULL;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3594
    tmp___0 = idx;
#line 3594
    idx ++;
    {
#line 3596
    if ((int )*tmp___0 == 98) {
#line 3596
      goto case_98;
    }
#line 3599
    if ((int )*tmp___0 == 107) {
#line 3599
      goto case_107;
    }
#line 3602
    if ((int )*tmp___0 == 109) {
#line 3602
      goto case_109;
    }
#line 3605
    if ((int )*tmp___0 == 103) {
#line 3605
      goto case_103;
    }
#line 3608
    if ((int )*tmp___0 == 120) {
#line 3608
      goto case_120;
    }
#line 3611
    if ((int )*tmp___0 == 43) {
#line 3611
      goto case_43;
    }
#line 3614
    if ((int )*tmp___0 == 0) {
#line 3614
      goto case_0;
    }
#line 3617
    goto switch_default;
    case_98: /* CIL Label */ 
#line 3597
    result += number * 512ULL;
#line 3598
    goto __Cont;
    case_107: /* CIL Label */ 
#line 3600
    result += number * 1024ULL;
#line 3601
    goto __Cont;
    case_109: /* CIL Label */ 
#line 3603
    result += number * 1048576ULL;
#line 3604
    goto __Cont;
    case_103: /* CIL Label */ 
#line 3606
    result += number * 1073741824ULL;
#line 3607
    goto __Cont;
    case_120: /* CIL Label */ 
#line 3609
    result += number * (ulonglong )arbsize;
#line 3610
    goto __Cont;
    case_43: /* CIL Label */ 
#line 3612
    result += number;
#line 3613
    goto __Cont;
    case_0: /* CIL Label */ 
#line 3615
    result += number;
#line 3616
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3618
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3620
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3622
  idx --;
#line 3622
  if (*idx) {
    {
#line 3623
    fatal(str, (char *)"Unrecognizable value");
    }
  }
#line 3624
  return (result);
}
}
#line 3632 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void out(char **av ) 
{ 
  register int fd ;
  Stat sb___0 ;
  char name[1024] ;
  char fsname[1024] ;
  int compression ;
  struct utimbuf tstamp ;
  int wantlarge ;
  Link *linkp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char toc_name[1024] ;
  Stat toc_sb ;
  struct stat st ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 3649
  if (*av) {
    {
#line 3650
    fatal(*av, (char *)"Extraneous argument");
    }
  }
  {
#line 3652
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3652
    fd = openin(name, fsname, & sb___0, & compression);
    }
#line 3652
    if (! (fd >= 0)) {
#line 3652
      goto while_break;
    }
#line 3654
    bytepos = total;
#line 3656
    sb___0.ino_orig = sb___0.sb_stat.st_ino;
#line 3657
    if (! lflag) {
#line 3657
      if (sb___0.sb_stat.st_nlink > 1UL) {
        {
#line 3659
        linkp = linkfrom(& sb___0, 0);
        }
#line 3659
        if (linkp) {
#line 3662
          sb___0.sb_stat.st_size = (__off_t )0;
#line 3663
          sb___0.sb_stat.st_ino = linkp->l_ino_ar;
        } else {
          {
#line 3668
          linkto(name, & sb___0);
          }
        }
      }
    }
#line 3681
    if ((sb___0.sb_stat.st_mode & 61440U) == 24576U) {
#line 3681
      goto _L;
    } else
#line 3681
    if ((sb___0.sb_stat.st_mode & 61440U) == 8192U) {
      _L: /* CIL Label */ 
#line 3681
      if ((sb___0.sb_stat.st_rdev | 65535UL) != 65535UL) {
#line 3684
        sb___0.sb_stat.st_dev = sb___0.sb_stat.st_rdev >> 16;
#line 3685
        sb___0.sb_stat.st_ino = sb___0.sb_stat.st_rdev & 65535UL;
#line 3686
        sb___0.sb_stat.st_rdev = (dev_t )0;
      } else
#line 3681
      if (sb___0.sb_stat.st_rdev == 0UL) {
#line 3684
        sb___0.sb_stat.st_dev = sb___0.sb_stat.st_rdev >> 16;
#line 3685
        sb___0.sb_stat.st_ino = sb___0.sb_stat.st_rdev & 65535UL;
#line 3686
        sb___0.sb_stat.st_rdev = (dev_t )0;
      }
    }
#line 3693
    wantlarge = sb___0.sb_stat.st_size != (sb___0.sb_stat.st_size & 2147483647L);
#line 3699
    if (! lflag) {
#line 3699
      if (sb___0.sb_stat.st_nlink > 1UL) {
#line 3699
        if (! extfmt) {
#line 3700
          if (wantlarge) {
#line 3700
            tmp = 1;
          } else
#line 3700
          if ((sb___0.sb_stat.st_ino & 65535UL) != sb___0.sb_stat.st_ino) {
#line 3700
            tmp = 1;
          } else {
#line 3700
            tmp = 0;
          }
#line 3700
          wantlarge = tmp;
        }
      }
    }
#line 3703
    if (wantlarge) {
#line 3703
      tmp___0 = 1;
    } else
#line 3703
    if ((sb___0.sb_stat.st_uid & 65535U) != sb___0.sb_stat.st_uid) {
#line 3703
      tmp___0 = 1;
    } else {
#line 3703
      tmp___0 = 0;
    }
#line 3703
    wantlarge = tmp___0;
#line 3704
    if (wantlarge) {
#line 3704
      tmp___1 = 1;
    } else
#line 3704
    if ((sb___0.sb_stat.st_gid & 65535U) != sb___0.sb_stat.st_gid) {
#line 3704
      tmp___1 = 1;
    } else {
#line 3704
      tmp___1 = 0;
    }
#line 3704
    wantlarge = tmp___1;
#line 3711
    if (wantlarge) {
#line 3711
      tmp___2 = 1;
    } else
#line 3711
    if ((sb___0.sb_stat.st_mtim.tv_sec & 2147483647L) != sb___0.sb_stat.st_mtim.tv_sec) {
#line 3711
      tmp___2 = 1;
    } else {
#line 3711
      tmp___2 = 0;
    }
#line 3711
    wantlarge = tmp___2;
#line 3713
    if (cpiocompat) {
#line 3713
      if (wantlarge) {
        {
#line 3716
        fatal(name, (char *)"Cannot create cpio-compatible file header for this input, aborting because of -5 option");
        }
      }
    }
#line 3719
    if (wantlarge) {
#line 3719
      if (! cpiowarned) {
        {
#line 3719
        tmp___4 = index((char const   *)ignorewarnings, 'C');
        }
#line 3719
        if (! tmp___4) {
          {
#line 3721
          warn_nocount(name, (char *)"Cannot create cpio-compatible file header for this input");
#line 3722
          warnarch((char *)"Continuing, archive will not be fully compatible with cpio or afio versions 2.4.7 and lower",
                   (off_t )0);
#line 3723
          tmp___3 = index((char const   *)ignorewarnings, 'c');
          }
#line 3723
          if (tmp___3) {
#line 3723
            warnings --;
          }
#line 3724
          cpiowarned = (unsigned short)1;
        }
      }
    }
#line 3727
    if (wantlarge) {
      {
#line 3729
      outhead3(name, & sb___0);
      }
    } else
#line 3733
    if (extfmt) {
      {
#line 3734
      outhead2(name, & sb___0);
      }
    } else {
      {
#line 3736
      outhead(name, & sb___0);
      }
    }
#line 3739
    if (fd) {
#line 3741
      if (fd == 10001) {
        {
#line 3743
        outdatazip(zipfdfd, name, sb___0.sb_stat.st_size);
#line 3744
        close(zipfdfd);
        }
      } else
#line 3746
      if (fd == 10000) {
        {
#line 3748
        outdatamem(name, sb___0.sb_stat.st_size);
        }
      } else {
        {
#line 3751
        tmp___5 = outdata(fd, name, sb___0.sb_stat.st_size);
#line 3751
        close(tmp___5);
        }
      }
    }
#line 3754
    if ((int )vflag > 1) {
#line 3754
      if (arfd != 1) {
        {
#line 3760
        strncpy((char */* __restrict  */)(toc_name), (char const   */* __restrict  */)(name),
                (size_t )1024);
#line 3761
        memcpy((void */* __restrict  */)(& toc_sb), (void const   */* __restrict  */)(& sb___0),
               sizeof(Stat ));
#line 3762
        tocentry(toc_name, & toc_sb);
        }
      } else {
#line 3754
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3764
    if (vflag) {
#line 3766
      if (printbytepos) {
        {
#line 3766
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.0f ",
                (double )bytepos);
        }
      }
#line 3768
      if ((int )name[0] == 47) {
#line 3768
        if (! abspaths) {
#line 3768
          if ((int )name[1] != 0) {
            {
#line 3769
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- ",
                    & name[1]);
            }
          } else {
            {
#line 3771
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- ",
                    name);
            }
          }
        } else {
          {
#line 3771
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- ",
                  name);
          }
        }
      } else {
        {
#line 3771
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- ",
                name);
        }
      }
#line 3777
      if (fd == 10001) {
        {
#line 3778
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%02d%%)\n",
                compression);
        }
      } else
#line 3777
      if (fd == 10000) {
        {
#line 3778
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%02d%%)\n",
                compression);
        }
      } else {
        {
#line 3780
        fputs((char const   */* __restrict  */)"okay\n", (FILE */* __restrict  */)stderr);
        }
      }
    }
#line 3786
    if ((int )fsname[0] != 0) {
#line 3792
      if (hflag) {
        {
#line 3792
        tmp___8 = stat((char const   */* __restrict  */)(fsname), (struct stat */* __restrict  */)(& st));
#line 3792
        tmp___10 = tmp___8;
        }
      } else {
        {
#line 3792
        tmp___9 = lstat((char const   */* __restrict  */)(fsname), (struct stat */* __restrict  */)(& st));
#line 3792
        tmp___10 = tmp___9;
        }
      }
#line 3792
      if (tmp___10 < 0) {
        {
#line 3794
        tmp___6 = syserr();
#line 3794
        warn(fsname, tmp___6);
        }
      } else
#line 3798
      if (st.st_mtim.tv_sec != sb___0.sb_stat.st_mtim.tv_sec) {
        {
#line 3800
        warn(fsname, (char *)"File was modified during its backup");
#line 3801
        tmp___7 = index((char const   *)ignorewarnings, 'd');
        }
#line 3801
        if (tmp___7) {
#line 3801
          warnings --;
        }
      }
    }
#line 3806
    if (aflag) {
#line 3806
      if (fsname[0]) {
#line 3806
        if ((sb___0.sb_stat.st_mode & 61440U) == 32768U) {
          {
#line 3810
          tstamp.actime = sb___0.sb_stat.st_atim.tv_sec;
#line 3811
          tstamp.modtime = sb___0.sb_stat.st_mtim.tv_sec;
#line 3812
          utime((char const   *)(fsname), (struct utimbuf  const  *)(& tstamp));
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3820
  outeof((char *)"TRAILER!!!", 11U);
  }
#line 3821
  return;
}
}
#line 3828 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outalloc(size_t len ) 
{ 


  {
#line 3832
  bufidx += len;
#line 3833
  total += (ulonglong )len;
#line 3834
  return;
}
}
#line 3842 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
size_t outavail(char **bufp ) 
{ 
  register size_t have ;

  {
  {
#line 3848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3848
    have = (size_t )(bufend - bufidx);
#line 3848
    if (! (have == 0UL)) {
#line 3848
      goto while_break;
    }
    {
#line 3850
    outflush(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3853
  *bufp = bufidx;
#line 3854
  return (have);
}
}
#line 3864 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int outdata(int fd , char *name , off_t size ) 
{ 
  register size_t chunk ;
  register ssize_t got ;
  register int oops ;
  register size_t avail ;
  char *buf ;
  char *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 3876
  got = (ssize_t )0;
#line 3876
  oops = (int )got;
  {
#line 3877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3877
    if (! size) {
#line 3877
      goto while_break;
    }
    {
#line 3879
    avail = outavail(& buf);
    }
#line 3880
    if (size < (off_t )avail) {
#line 3880
      chunk = (size_t )size;
    } else {
#line 3880
      chunk = avail;
    }
#line 3880
    size = (off_t )((size_t )size - chunk);
#line 3881
    if (oops == 0) {
      {
#line 3881
      got = readall(fd, buf, chunk);
      }
#line 3881
      if (got < 0L) {
        {
#line 3883
        tmp = syserr();
#line 3883
        oops = warn(name, tmp);
#line 3884
        tmp___0 = index((char const   *)ignorewarnings, 'n');
        }
#line 3884
        if (tmp___0) {
#line 3884
          warnings --;
        }
#line 3885
        got = (ssize_t )0;
      }
    }
#line 3887
    if ((size_t )got < chunk) {
#line 3889
      if (oops == 0) {
        {
#line 3890
        oops = warn(name, (char *)"Early EOF");
        }
      }
      {
#line 3891
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3891
        if (! ((size_t )got < chunk)) {
#line 3891
          goto while_break___0;
        }
#line 3892
        tmp___1 = got;
#line 3892
        got ++;
#line 3892
        *(buf + tmp___1) = (char )'\000';
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 3894
    outalloc(chunk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3896
  return (fd);
}
}
#line 3907 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outdatazip(int fd , char *name , off_t size ) 
{ 
  register size_t chunk ;
  register ssize_t got ;
  register size_t avail ;
  char *buf ;
  char localbuf[4096] ;
  int overflow ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 3918
  overflow = 0;
  {
#line 3920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3920
    if (! (size > 0L)) {
#line 3920
      goto while_break;
    }
    {
#line 3922
    avail = outavail(& buf);
    }
#line 3923
    if (size < (off_t )avail) {
#line 3923
      chunk = (size_t )size;
    } else {
#line 3923
      chunk = avail;
    }
    {
#line 3925
    got = read(fd, (void *)buf, chunk);
    }
#line 3926
    if (got <= 0L) {
#line 3926
      goto while_break;
    }
    {
#line 3928
    outalloc((size_t )got);
#line 3929
    size -= got;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3933
  overflow = 0;
  {
#line 3934
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3934
    tmp = read(fd, (void *)(localbuf), sizeof(localbuf));
    }
#line 3934
    if (! (tmp > 0L)) {
#line 3934
      goto while_break___0;
    }
#line 3934
    overflow = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3936
  waitforgzip();
  }
#line 3938
  if (size > 0L) {
    {
#line 3939
    warn(name, (char *)"Error zipping file, written damaged copy to archive.");
    }
  } else
#line 3938
  if (overflow) {
    {
#line 3939
    warn(name, (char *)"Error zipping file, written damaged copy to archive.");
    }
  }
  {
#line 3942
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3942
    if (! (size > 0L)) {
#line 3942
      goto while_break___1;
    }
    {
#line 3944
    avail = outavail(& buf);
    }
#line 3945
    if (size < (off_t )avail) {
#line 3945
      chunk = (size_t )size;
    } else {
#line 3945
      chunk = avail;
    }
#line 3945
    size = (off_t )((size_t )size - chunk);
#line 3946
    got = (ssize_t )0;
    {
#line 3947
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3947
      if (! ((size_t )got < chunk)) {
#line 3947
        goto while_break___2;
      }
#line 3948
      tmp___0 = got;
#line 3948
      got ++;
#line 3948
      *(buf + tmp___0) = (char )'\000';
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3949
    outalloc(chunk);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3952
  return;
}
}
#line 3961 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outdatamem(char *name , off_t size ) 
{ 
  register unsigned int chunk ;
  register unsigned int got ;
  register unsigned int avail ;
  char *buf ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 3972
  memreset();
  }
  {
#line 3974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3974
    if (! size) {
#line 3974
      goto while_break;
    }
    {
#line 3976
    tmp = outavail(& buf);
#line 3976
    avail = (unsigned int )tmp;
    }
#line 3977
    if (size < (off_t )avail) {
#line 3977
      chunk = (unsigned int )size;
    } else {
#line 3977
      chunk = avail;
    }
    {
#line 3979
    tmp___0 = memread(buf, (int )chunk);
#line 3979
    got = (unsigned int )tmp___0;
    }
#line 3980
    if (got == 0U) {
#line 3980
      goto while_break;
    }
    {
#line 3982
    outalloc((size_t )got);
#line 3983
    size -= (off_t )got;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3986
  memfree();
  }
#line 3987
  return;
}
}
#line 3994 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outeof(char *name , unsigned int namelen ) 
{ 
  ulonglong pad ;
  char header[77] ;

  {
#line 4002
  pad = (((total + 6ULL) + 70ULL) + (ulonglong )namelen) % (unsigned long long )arpad;
#line 4002
  if (pad) {
#line 4003
    pad = (ulonglong )arpad - pad;
  }
  {
#line 4004
  strcpy((char */* __restrict  */)(header), (char const   */* __restrict  */)"070707");
#line 4005
  sprintf((char */* __restrict  */)(header + 6), (char const   */* __restrict  */)"%06o%06o%06o%06o%06o%06o%06o%011lo%06o%011lo",
          0, 0, 0, 0, 0, 1, 0, 0UL, namelen, (unsigned long )pad);
#line 4007
  outwrite(header, 76U);
#line 4008
  outwrite(name, namelen);
#line 4009
  outpad((off_t )pad);
#line 4010
  outflush(1);
  }
#line 4011
  if (fflag) {
    {
#line 4012
    outwait();
    }
  }
#line 4013
  return;
}
}
#line 4022 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outflush(int done ) 
{ 
  ulonglong tmp ;
  ulonglong tmp___0 ;
  ulonglong tmp___1 ;
  ulonglong tmp___2 ;

  {
#line 4030
  if (aruntil != 0ULL) {
#line 4030
    if ((ulonglong )buflen < arleft) {
#line 4030
      tmp = (ulonglong )buflen;
    } else {
#line 4030
      tmp = arleft;
    }
#line 4030
    tmp___0 = tmp;
  } else {
#line 4030
    tmp___0 = (ulonglong )buflen;
  }
#line 4030
  bufend = buffer + tmp___0;
#line 4031
  if (Fflag) {
#line 4031
    if (done == 0) {
#line 4031
      if (bufend - bufidx > 0L) {
#line 4033
        return;
      }
    }
  }
#line 4039
  if (! Fflag) {
#line 4039
    if (aruntil) {
#line 4039
      if (arleft == 0ULL) {
        {
#line 4040
        next(1, (char *)"Output limit reached");
        }
      }
    }
  }
  {
#line 4043
  writedisk(1);
#line 4044
  bufidx = buffer;
  }
#line 4044
  if (aruntil != 0ULL) {
#line 4044
    if ((ulonglong )buflen < arleft) {
#line 4044
      tmp___1 = (ulonglong )buflen;
    } else {
#line 4044
      tmp___1 = arleft;
    }
#line 4044
    tmp___2 = tmp___1;
  } else {
#line 4044
    tmp___2 = (ulonglong )buflen;
  }
#line 4044
  bufend = bufidx + tmp___2;
#line 4045
  return;
}
}
#line 4052 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outhead(char *name , Stat *asb ) 
{ 
  register unsigned int namelen ;
  char header[77] ;
  size_t tmp ;
  time_t tmp___0 ;

  {
#line 4060
  if ((int )*(name + 0) == 47) {
#line 4060
    if (! abspaths) {
#line 4062
      if (*(name + 1)) {
#line 4063
        name ++;
      } else {
#line 4065
        name = (char *)".";
      }
    }
  }
  {
#line 4067
  tmp = strlen((char const   *)name);
#line 4067
  namelen = (unsigned int )tmp + 1U;
#line 4068
  strcpy((char */* __restrict  */)(header), (char const   */* __restrict  */)"070707");
  }
#line 4069
  if (mflag) {
#line 4069
    tmp___0 = timenow;
  } else {
#line 4069
    tmp___0 = asb->sb_stat.st_mtim.tv_sec;
  }
  {
#line 4069
  sprintf((char */* __restrict  */)(header + 6), (char const   */* __restrict  */)"%06o%06o%06o%06o%06o%06o%06o%011lo%06o%011lo",
          (int )((unsigned short )asb->sb_stat.st_dev) & 65535, (int )((unsigned short )asb->sb_stat.st_ino) & 65535,
          (int )((unsigned short )asb->sb_stat.st_mode) & 65535, (int )((unsigned short )asb->sb_stat.st_uid) & 65535,
          (int )((unsigned short )asb->sb_stat.st_gid) & 65535, (int )((unsigned short )asb->sb_stat.st_nlink) & 65535,
          (int )((unsigned short )asb->sb_stat.st_rdev) & 65535, (unsigned long )tmp___0 & 4294967295UL,
          namelen, (unsigned long )asb->sb_stat.st_size);
#line 4073
  outwrite(header, 76U);
#line 4074
  outwrite(name, namelen);
  }
#line 4076
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
    {
#line 4077
    outwrite(asb->sb_link, (unsigned int )asb->sb_stat.st_size);
    }
  }
#line 4079
  return;
}
}
#line 4086 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outhead2(char *name , Stat *asb ) 
{ 
  register unsigned int namelen ;
  char header[82] ;
  size_t tmp ;
  time_t tmp___0 ;

  {
#line 4094
  if ((int )*(name + 0) == 47) {
#line 4094
    if (! abspaths) {
#line 4096
      if (*(name + 1)) {
#line 4097
        name ++;
      } else {
#line 4099
        name = (char *)".";
      }
    }
  }
  {
#line 4101
  tmp = strlen((char const   *)name);
#line 4101
  namelen = (unsigned int )tmp + 1U;
#line 4102
  strcpy((char */* __restrict  */)(header), (char const   */* __restrict  */)"070717");
  }
#line 4103
  if (mflag) {
#line 4103
    tmp___0 = timenow;
  } else {
#line 4103
    tmp___0 = asb->sb_stat.st_mtim.tv_sec;
  }
  {
#line 4103
  sprintf((char */* __restrict  */)(header + 6), (char const   */* __restrict  */)"%06o%011lo%06o%06o%06o%06o%06o%011lo%06o%011lo",
          (int )((unsigned short )asb->sb_stat.st_dev) & 65535, asb->sb_stat.st_ino,
          (int )((unsigned short )asb->sb_stat.st_mode) & 65535, (int )((unsigned short )asb->sb_stat.st_uid) & 65535,
          (int )((unsigned short )asb->sb_stat.st_gid) & 65535, (int )((unsigned short )asb->sb_stat.st_nlink) & 65535,
          (int )((unsigned short )asb->sb_stat.st_rdev) & 65535, (unsigned long )tmp___0 & 4294967295UL,
          namelen, (unsigned long )asb->sb_stat.st_size);
#line 4107
  outwrite(header, 81U);
#line 4108
  outwrite(name, namelen);
  }
#line 4110
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
    {
#line 4111
    outwrite(asb->sb_link, (unsigned int )asb->sb_stat.st_size);
    }
  }
#line 4113
  return;
}
}
#line 4120 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outhead3(char *name , Stat *asb ) 
{ 
  register unsigned int namelen ;
  char header[117] ;
  size_t tmp ;
  unsigned long long tmp___0 ;

  {
#line 4128
  if ((int )*(name + 0) == 47) {
#line 4128
    if (! abspaths) {
#line 4130
      if (*(name + 1)) {
#line 4131
        name ++;
      } else {
#line 4133
        name = (char *)".";
      }
    }
  }
  {
#line 4135
  tmp = strlen((char const   *)name);
#line 4135
  namelen = (unsigned int )tmp + 1U;
#line 4136
  strcpy((char */* __restrict  */)(header), (char const   */* __restrict  */)"070727");
  }
#line 4138
  if (mflag) {
#line 4138
    tmp___0 = (unsigned long long )timenow & 0xffffffffffffffffULL;
  } else {
#line 4138
    tmp___0 = (unsigned long long )asb->sb_stat.st_mtim.tv_sec & 0xffffffffffffffffULL;
  }
  {
#line 4138
  sprintf((char */* __restrict  */)(header + 6), (char const   */* __restrict  */)"%08lX%016llXm%06lo%08lX%08lX%08lX%08lX%016llXn%04X%04X%04Xs%016llX:",
          asb->sb_stat.st_dev & 4294967295UL, (unsigned long long )asb->sb_stat.st_ino & 0xffffffffffffffffULL,
          (unsigned long )asb->sb_stat.st_mode & 4294967295UL, (unsigned long )asb->sb_stat.st_uid & 4294967295UL,
          (unsigned long )asb->sb_stat.st_gid & 4294967295UL, asb->sb_stat.st_nlink & 4294967295UL,
          asb->sb_stat.st_rdev & 4294967295UL, tmp___0, namelen, 0, 0, (unsigned long long )asb->sb_stat.st_size & 0xffffffffffffffffULL);
#line 4143
  outwrite(header, 116U);
#line 4144
  outwrite(name, namelen);
  }
#line 4146
  if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
    {
#line 4147
    outwrite(asb->sb_link, (unsigned int )asb->sb_stat.st_size);
    }
  }
#line 4149
  return;
}
}
#line 4157 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outpad(off_t pad ) 
{ 
  register int idx ;
  register int len ;
  char *tmp ;

  {
  {
#line 4164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4164
    if (! pad) {
#line 4164
      goto while_break;
    }
#line 4166
    len = (int )(bufend - bufidx);
#line 4166
    if ((off_t )len > pad) {
#line 4167
      len = (int )pad;
    }
#line 4168
    idx = 0;
    {
#line 4168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4168
      if (! (idx < len)) {
#line 4168
        goto while_break___0;
      }
#line 4169
      tmp = bufidx;
#line 4169
      bufidx ++;
#line 4169
      *tmp = (char )'\000';
#line 4168
      idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4170
    total += (ulonglong )len;
#line 4171
    outflush(0);
#line 4172
    pad -= (off_t )len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4174
  return;
}
}
#line 4183 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outwait(void) 
{ 
  int status ;

  {
#line 4188
  if (outpid == 0) {
#line 4189
    return;
  }
  {
#line 4190
  status = xwait(outpid, (char *)"outwait()", 1);
#line 4191
  outpid = 0;
  }
#line 4192
  if (status) {
    {
#line 4193
    fatal(arspec, (char *)"Child error");
    }
  }
#line 4194
  return;
}
}
#line 4201 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void outwrite(char *idx , unsigned int len ) 
{ 
  register unsigned int have ;
  register unsigned int want ;
  register char *endx ;

  {
#line 4208
  endx = idx + len;
  {
#line 4210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4210
    want = (unsigned int )(endx - idx);
#line 4210
    if (! want) {
#line 4210
      goto while_break;
    }
    {
#line 4212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4212
      have = (unsigned int )(bufend - bufidx);
#line 4212
      if (! (have == 0U)) {
#line 4212
        goto while_break___0;
      }
      {
#line 4213
      outflush(0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4214
    if (have > want) {
#line 4215
      have = want;
    }
    {
#line 4216
    memcpy((void */* __restrict  */)bufidx, (void const   */* __restrict  */)idx,
           (size_t )have);
#line 4217
    bufidx += have;
#line 4218
    idx += have;
#line 4219
    total += (ulonglong )have;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4221
  return;
}
}
#line 4228 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void pass(char **av ) 
{ 
  register int fd ;
  register char **avx ;
  Stat sb___0 ;
  char name[1024] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4237
  avx = av;
  {
#line 4237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4237
    if (! *avx) {
#line 4237
      goto while_break;
    }
#line 4239
    if (gflag) {
#line 4239
      if ((int )*(*avx) != 47) {
        {
#line 4240
        fatal(*avx, (char *)"Relative pathname");
        }
      }
    }
    {
#line 4241
    tmp___0 = stat((char const   */* __restrict  */)*avx, (struct stat */* __restrict  */)(& sb___0.sb_stat));
    }
#line 4241
    if (tmp___0 < 0) {
      {
#line 4242
      tmp = syserr();
#line 4242
      fatal(*avx, tmp);
      }
    }
#line 4243
    if ((sb___0.sb_stat.st_mode & 61440U) != 16384U) {
      {
#line 4244
      fatal(*avx, (char *)"Not a directory");
      }
    }
#line 4237
    avx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4246
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 4246
    fd = openin(name, (char *)((void *)0), & sb___0, (int *)0);
    }
#line 4246
    if (! (fd >= 0)) {
#line 4246
      goto while_break___0;
    }
    {
#line 4248
    tmp___1 = passitem(name, & sb___0, fd, av);
    }
#line 4248
    if (tmp___1) {
      {
#line 4249
      close(fd);
      }
    }
#line 4250
    if (vflag) {
#line 4252
      if (uncompto[0]) {
        {
#line 4253
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- uncompressed\n",
                uncompto);
        }
      } else {
        {
#line 4255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -- okay\n",
                name);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4258
  return;
}
}
#line 4267 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void passdata(char *from , int ifd , char *to , int ofd ) 
{ 
  register ssize_t got ;
  register ssize_t sparse ;
  char block[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 4278
  if (ifd) {
    {
#line 4280
    lseek(ifd, (off_t )0, 0);
#line 4281
    sparse = (ssize_t )0;
    }
    {
#line 4282
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4282
      got = read(ifd, (void *)(block), sizeof(block));
      }
#line 4282
      if (got > 0L) {
        {
#line 4282
        sparse = fswrite(ofd, block, (size_t )((unsigned int )got));
        }
#line 4282
        if (! (sparse >= 0L)) {
#line 4282
          goto while_break;
        }
      } else {
#line 4282
        goto while_break;
      }
#line 4284
      total += (ulonglong )got;
    }
    while_break: /* CIL Label */ ;
    }
#line 4285
    if (got) {
      {
#line 4286
      tmp = syserr();
      }
#line 4286
      if (got < 0L) {
#line 4286
        tmp___0 = from;
      } else {
#line 4286
        tmp___0 = to;
      }
      {
#line 4286
      warn(tmp___0, tmp);
      }
    } else
#line 4287
    if (sparse > 0L) {
      {
#line 4287
      tmp___2 = lseek(ofd, - sparse, 1);
      }
#line 4287
      if (tmp___2 < 0L) {
        {
#line 4290
        tmp___1 = syserr();
#line 4290
        warn(to, tmp___1);
        }
      } else {
        {
#line 4287
        tmp___3 = writeall(ofd, (char const   *)(block), (size_t )sparse);
        }
#line 4287
        if (tmp___3 != sparse) {
          {
#line 4290
          tmp___1 = syserr();
#line 4290
          warn(to, tmp___1);
          }
        }
      }
    }
  }
  {
#line 4292
  close(ofd);
  }
#line 4293
  return;
}
}
#line 4300 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int passitem(char *from , Stat *asb , int ifd , char **dir ) 
{ 
  register int ofd ;
  struct utimbuf tstamp ;
  char to[1024] ;
  char **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  Link *tmp___4 ;
  Link *tmp___5 ;
  Link *tmp___6 ;

  {
  {
#line 4316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4316
    if (! *dir) {
#line 4316
      goto while_break;
    }
    {
#line 4318
    tmp = dir;
#line 4318
    dir ++;
#line 4318
    tmp___0 = strcpy((char */* __restrict  */)(to), (char const   */* __restrict  */)*tmp);
#line 4318
    tmp___1 = strcat((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"/");
#line 4318
    tmp___2 = strcat((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)from);
#line 4318
    tmp___3 = nameopt(tmp___2);
    }
#line 4318
    if (tmp___3 < 0) {
#line 4319
      goto while_continue;
    }
#line 4320
    if (lflag) {
      {
#line 4320
      tmp___4 = linkto(from, asb);
#line 4320
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 4320
      tmp___5 = linkfrom(asb, 0);
#line 4320
      tmp___6 = tmp___5;
      }
    }
    {
#line 4320
    ofd = openotty(to, asb, tmp___6, 1, (int )Zflag);
    }
#line 4320
    if (ofd < 0) {
#line 4322
      goto while_continue;
    }
#line 4323
    if (ofd > 0) {
      {
#line 4324
      passdata(from, ifd, to, ofd);
      }
    }
#line 4326
    if (mflag) {
#line 4326
      tstamp.modtime = timenow;
    } else {
#line 4326
      tstamp.modtime = asb->sb_stat.st_mtim.tv_sec;
    }
    {
#line 4326
    tstamp.actime = tstamp.modtime;
#line 4327
    utime((char const   *)(to), (struct utimbuf  const  *)(& tstamp));
    }
#line 4333
    if (uncompressrun) {
      {
#line 4335
      xwait(uncompressrun, (char *)"passitem xwait()", 1);
#line 4336
      uncompressrun = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4339
  return (ifd);
}
}
#line 4342 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void process_arname(char *template ) 
{ 
  int remain ;
  int len ;
  char *sptr ;
  char *dptr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 4349
  sptr = template;
#line 4350
  dptr = proc_arname;
#line 4352
  if (! sflagused) {
    {
#line 4354
    strcpy((char */* __restrict  */)dptr, (char const   */* __restrict  */)sptr);
    }
#line 4355
    return;
  }
#line 4358
  remain = (int )(sizeof(proc_arname) - 10UL);
  {
#line 4360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4360
    if (! (remain >= 0)) {
#line 4360
      goto while_break;
    }
#line 4361
    *dptr = (char )'\000';
#line 4362
    if ((int )*sptr == 37) {
#line 4363
      sptr ++;
      {
#line 4364
      if ((int )*sptr == 86) {
#line 4364
        goto case_86;
      }
#line 4370
      if ((int )*sptr == 83) {
#line 4370
        goto case_83;
      }
#line 4376
      goto switch_default;
      case_86: /* CIL Label */ 
#line 4365
      if (remain < 40) {
#line 4365
        goto switch_break;
      }
      {
#line 4366
      len = sprintf((char */* __restrict  */)dptr, (char const   */* __restrict  */)"%u",
                    arvolume);
#line 4367
      dptr += len;
#line 4368
      remain -= len;
      }
#line 4369
      goto switch_break;
      case_83: /* CIL Label */ 
#line 4371
      if (remain < 40) {
#line 4371
        goto switch_break;
      }
      {
#line 4372
      len = sprintf((char */* __restrict  */)dptr, (char const   */* __restrict  */)"%llu",
                    aruntil);
#line 4373
      dptr += len;
#line 4374
      remain -= len;
      }
#line 4375
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4377
      tmp = dptr;
#line 4377
      dptr ++;
#line 4377
      *tmp = *sptr;
#line 4378
      remain --;
#line 4379
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 4383
      tmp___0 = dptr;
#line 4383
      dptr ++;
#line 4383
      *tmp___0 = *sptr;
#line 4384
      remain --;
    }
#line 4386
    if ((int )*sptr == 0) {
#line 4386
      goto while_break;
    }
#line 4360
    sptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4389
  return;
}
}
#line 4396 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int pipechld(int mode , int *pfd ) 
{ 
  register char **av ;
  char *arg[32] ;
  char **tmp ;
  char *tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 4404
  av = arg;
#line 4405
  tmp___0 = getenv("SHELL");
#line 4405
  *av = tmp___0;
  }
#line 4405
  if (tmp___0) {
#line 4405
    if (*(*av)) {
#line 4406
      av ++;
    } else {
#line 4408
      tmp = av;
#line 4408
      av ++;
#line 4408
      *tmp = (char *)"/bin/sh";
    }
  } else {
#line 4408
    tmp = av;
#line 4408
    av ++;
#line 4408
    *tmp = (char *)"/bin/sh";
  }
  {
#line 4409
  tmp___1 = av;
#line 4409
  av ++;
#line 4409
  *tmp___1 = (char *)"-c";
#line 4410
  process_arname(arname + 1);
#line 4411
  tmp___2 = av;
#line 4411
  av ++;
#line 4411
  *tmp___2 = proc_arname;
#line 4412
  *av = (char *)((void *)0);
  }
#line 4413
  if (mode) {
    {
#line 4415
    close(*(pfd + 1));
#line 4416
    close(0);
#line 4417
    dup(*(pfd + 0));
#line 4418
    close(*(pfd + 0));
#line 4419
    close(1);
#line 4420
    open("/dev/null", 1);
    }
  } else {
    {
#line 4424
    close(0);
#line 4425
    open("/dev/null", 0);
#line 4426
    close(*(pfd + 0));
#line 4427
    close(1);
#line 4428
    dup(*(pfd + 1));
#line 4429
    close(*(pfd + 1));
    }
  }
#line 4431
  if (ttyf >= 0) {
    {
#line 4432
    close(ttyf);
    }
  }
  {
#line 4433
  execvp((char const   *)arg[0], (char * const  *)(arg));
#line 4434
  tmp___3 = syserr();
#line 4434
  warn(arg[0], tmp___3);
#line 4435
  _exit(1);
  }
#line 4436
  return (0);
}
}
#line 4445 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int pipeopen(int mode ) 
{ 
  int pfd[2] ;
  int tmp ;

  {
  {
#line 4451
  tmp = pipe((int *)(pfd));
  }
#line 4451
  if (tmp < 0) {
#line 4452
    return (-1);
  }
  {
#line 4453
  pipepid = xfork((char *)"pipeopen()", 1);
  }
#line 4453
  if (pipepid == 0) {
    {
#line 4454
    pipechld(mode, pfd);
    }
  }
#line 4455
  if (mode) {
    {
#line 4457
    close(pfd[0]);
    }
#line 4458
    return (pfd[1]);
  } else {
    {
#line 4462
    close(pfd[1]);
    }
#line 4463
    return (pfd[0]);
  }
}
}
#line 4472 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void pipewait(void) 
{ 
  register int status ;

  {
#line 4477
  if (pipepid == 0) {
#line 4478
    return;
  }
  {
#line 4479
  status = xwait(pipepid, (char *)"pipewait()", 1);
#line 4480
  pipepid = 0;
  }
#line 4481
  if (status) {
    {
#line 4482
    fatal(arspec, (char *)"Pipeline error");
    }
  }
#line 4483
  return;
}
}
#line 4490 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void prsize(FILE *stream , ulonglong size ) 
{ 
  register ulonglong n ;

  {
#line 4497
  n = size / 1048576ULL;
#line 4497
  if (n) {
    {
#line 4499
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%lum+",
            (unsigned long )n);
#line 4500
    size -= (n * 1024ULL) * 1024ULL;
    }
  }
#line 4502
  n = size / 1024ULL;
#line 4502
  if (n) {
    {
#line 4504
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%luk+",
            (unsigned long )n);
#line 4505
    size -= n * 1024ULL;
    }
  }
  {
#line 4507
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%lu",
          (unsigned long )size);
  }
#line 4508
  return;
}
}
#line 4550 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
ssize_t fswrite(int fd , char *buf , size_t len ) 
{ 
  register char *bidx ;
  register char *bend ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  char *tmp___5 ;
  int tmp___7 ;
  __off64_t tmp___8 ;

  {
#line 4563
  if (jflag) {
#line 4563
    goto _L;
  } else
#line 4563
  if (uncompressrun) {
    _L: /* CIL Label */ 
    {
#line 4564
    tmp___1 = writeall(fd, (char const   *)buf, len);
    }
#line 4564
    if (tmp___1 == (ssize_t )((int )len)) {
#line 4564
      tmp___0 = 0;
    } else {
#line 4564
      tmp___0 = -1;
    }
#line 4564
    return ((ssize_t )tmp___0);
  }
#line 4565
  bidx = buf;
#line 4565
  bend = bidx + len;
  {
#line 4566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4566
    if (! ((unsigned long )bidx < (unsigned long )bend)) {
#line 4566
      goto while_break;
    }
#line 4567
    tmp___5 = bidx;
#line 4567
    bidx ++;
#line 4567
    if (*tmp___5) {
      {
#line 4568
      tmp___4 = writeall(fd, (char const   *)buf, len);
      }
#line 4568
      if (tmp___4 == (ssize_t )((int )len)) {
#line 4568
        tmp___3 = 0;
      } else {
#line 4568
        tmp___3 = -1;
      }
#line 4568
      return ((ssize_t )tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4569
  tmp___8 = lseek(fd, (off_t )len, 1);
  }
#line 4569
  if (tmp___8 < 0L) {
#line 4569
    tmp___7 = -1;
  } else {
#line 4569
    tmp___7 = (int )len;
  }
#line 4569
  return ((ssize_t )tmp___7);
}
}
#line 4580 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static char msg[40]  ;
#line 4577 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
char *syserr(void) 
{ 
  char *pTmp ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 4591
  pTmp = (char *)((void *)0);
#line 4592
  tmp___0 = __errno_location();
#line 4592
  pTmp = strerror(*tmp___0);
  }
#line 4592
  if (! pTmp) {
    {
#line 4594
    tmp = __errno_location();
#line 4594
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Unknown error (errno %d)",
            *tmp);
#line 4595
    pTmp = msg;
    }
  }
#line 4597
  return (pTmp);
}
}
#line 4606 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void toc(char **av ) 
{ 
  Stat sb___0 ;
  char name[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4613
  if (*av) {
    {
#line 4614
    fatal(*av, (char *)"Extraneous argument");
    }
  }
#line 4615
  name[0] = (char )'\000';
  {
#line 4616
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4616
    tmp___4 = inhead(name, & sb___0);
    }
#line 4616
    if (! (tmp___4 == 0)) {
#line 4616
      goto while_break;
    }
#line 4618
    if ((sb___0.sb_stat.st_mode & 61440U) == 32768U) {
#line 4618
      if (sb___0.sb_stat.st_rdev & 2UL) {
        {
#line 4621
        tmp = namecmp(name, & sb___0);
        }
#line 4621
        if (tmp == 0) {
          {
#line 4622
          tocentry(name, & sb___0);
          }
        }
        {
#line 4625
        tmp___1 = inentry(name, & sb___0);
        }
#line 4625
        if (tmp___1 < 0) {
          {
#line 4626
          tmp___0 = inskip(sb___0.sb_stat.st_size);
          }
#line 4626
          if (tmp___0 < 0) {
            {
#line 4627
            warn(name, (char *)"Skipped file data is corrupt");
            }
          }
        }
#line 4629
        goto while_continue;
      }
    }
    {
#line 4632
    tmp___2 = namecmp(name, & sb___0);
    }
#line 4632
    if (tmp___2 == 0) {
      {
#line 4633
      tocentry(name, & sb___0);
      }
    }
    {
#line 4634
    tmp___3 = inskip(sb___0.sb_stat.st_size);
    }
#line 4634
    if (tmp___3 < 0) {
      {
#line 4635
      warn(name, (char *)"File data is corrupt");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4637
  return;
}
}
#line 4653 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static char *month[12]  = 
#line 4653
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 4644 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void tocentry(char *name , Stat *asb ) 
{ 
  register Time *atm ;
  register Link *from ;
  register Passwd *pwp ;
  register Group *grp ;
  int res ;
  Link *linkp ;
  Link *linknext ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  char *namedot ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 4662
  if (printbytepos) {
    {
#line 4662
    printf((char const   */* __restrict  */)"%.0f ", (double )bytepos);
    }
  }
#line 4664
  if (vflag) {
    {
#line 4666
    tocmode(asb->sb_stat.st_mode);
#line 4667
    printf((char const   */* __restrict  */)" %2d", (int )asb->sb_stat.st_nlink);
#line 4668
    atm = localtime((time_t const   *)(& asb->sb_stat.st_mtim.tv_sec));
#line 4669
    pwp = getpwuid(asb->sb_stat.st_uid);
    }
#line 4669
    if (pwp) {
      {
#line 4670
      printf((char const   */* __restrict  */)" %-8s", pwp->pw_name);
      }
    } else {
      {
#line 4672
      printf((char const   */* __restrict  */)" %-8u", asb->sb_stat.st_uid);
      }
    }
    {
#line 4673
    grp = getgrgid(asb->sb_stat.st_gid);
    }
#line 4673
    if (grp) {
      {
#line 4674
      printf((char const   */* __restrict  */)" %-8s", grp->gr_name);
      }
    } else {
      {
#line 4676
      printf((char const   */* __restrict  */)" %-8u", asb->sb_stat.st_gid);
      }
    }
    {
#line 4680
    if ((asb->sb_stat.st_mode & 61440U) == 8192U) {
#line 4680
      goto case_8192;
    }
#line 4680
    if ((asb->sb_stat.st_mode & 61440U) == 24576U) {
#line 4680
      goto case_8192;
    }
#line 4688
    if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 4688
      goto case_32768;
    }
#line 4692
    goto switch_default;
    case_8192: /* CIL Label */ 
    case_24576: /* CIL Label */ 
#line 4684
    if (asb->sb_stat.st_rdev == 0UL) {
#line 4684
      asb->sb_stat.st_rdev = (asb->sb_stat.st_dev << 16) + asb->sb_stat.st_ino;
    }
    {
#line 4685
    tmp = gnu_dev_minor((unsigned long long )asb->sb_stat.st_rdev);
#line 4685
    tmp___0 = gnu_dev_major((unsigned long long )asb->sb_stat.st_rdev);
#line 4685
    printf((char const   */* __restrict  */)" %3d, %3d", (int )tmp___0, (int )tmp);
    }
#line 4687
    goto switch_break;
    case_32768: /* CIL Label */ 
    {
#line 4689
    printf((char const   */* __restrict  */)" %8lld", (long long )asb->sb_stat.st_size);
    }
#line 4691
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 4693
    printf((char const   */* __restrict  */)"         ");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 4695
    printf((char const   */* __restrict  */)" %3s %2d %02d:%02d:%02d %4d ", month[atm->tm_mon],
           atm->tm_mday, atm->tm_hour, atm->tm_min, atm->tm_sec, atm->tm_year + 1900);
    }
  }
  {
#line 4701
  tmp___1 = strrchr((char const   *)name, '.');
#line 4701
  namedot = tmp___1;
  }
#line 4703
  if (Zflag) {
#line 4703
    if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 4703
      if ((asb->sb_stat.st_rdev & 1UL) == 0UL) {
#line 4703
        if (asb->sb_stat.st_size > 0L) {
#line 4703
          if (namedot) {
#line 4703
            if ((int )*(namedot + 1) == 122) {
#line 4703
              if (! *(namedot + 2)) {
#line 4707
                *namedot = (char )'\000';
              } else {
#line 4709
                namedot = (char *)0;
              }
            } else {
#line 4709
              namedot = (char *)0;
            }
          } else {
#line 4709
            namedot = (char *)0;
          }
        } else {
#line 4709
          namedot = (char *)0;
        }
      } else {
#line 4709
        namedot = (char *)0;
      }
    } else {
#line 4709
      namedot = (char *)0;
    }
  } else {
#line 4709
    namedot = (char *)0;
  }
#line 4711
  if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 4711
    if (asb->sb_stat.st_rdev & 2UL) {
      {
#line 4711
      res = printf((char const   */* __restrict  */)"//--");
      }
    }
  }
#line 4713
  if (! useoutmodetoc) {
#line 4713
    if (flag0) {
      {
#line 4714
      res = printf((char const   */* __restrict  */)"%s%c", name, 0);
      }
    } else {
      {
#line 4716
      res = printf((char const   */* __restrict  */)"%s", name);
      }
    }
  } else {
    {
#line 4716
    res = printf((char const   */* __restrict  */)"%s", name);
    }
  }
#line 4719
  if (res > 0) {
    {
#line 4719
    res = fflush(stdout);
    }
  }
#line 4721
  if (res < 0) {
    {
#line 4722
    tmp___3 = __errno_location();
    }
#line 4722
    if (*tmp___3 == 32) {
      {
#line 4723
      tmp___2 = syserr();
#line 4723
      fatal((char *)"<stdout>", tmp___2);
      }
    }
  }
#line 4727
  if (vflag) {
#line 4727
    if (namedot) {
      {
#line 4728
      printf((char const   */* __restrict  */)" -- compressed");
      }
    }
  }
#line 4731
  if (! flag0) {
#line 4731
    if (vflag) {
#line 4731
      goto _L;
    } else
#line 4731
    if (lflag) {
      _L: /* CIL Label */ 
#line 4733
      from = (Link *)((void *)0);
#line 4734
      if (asb->sb_stat.st_nlink > 1UL) {
#line 4737
        if (! useoutmodetoc) {
          {
#line 4739
          from = linkfrom(asb, 1);
          }
#line 4739
          if (from) {
            {
#line 4740
            printf((char const   */* __restrict  */)" -> %s", (from->l_path)->p_name);
            }
          } else {
            {
#line 4742
            linkto(name, asb);
            }
          }
        } else
#line 4751
        if ((asb->sb_stat.st_mode & 61440U) != 16384U) {
#line 4753
          linkp = *(linkbase + (asb->ino_orig & 65535UL) % (sizeof(linkbase) / sizeof(linkbase[0])));
          {
#line 4753
          while (1) {
            while_continue: /* CIL Label */ ;
#line 4753
            if (! linkp) {
#line 4753
              goto while_break;
            }
#line 4755
            if (linkp->l_ino == asb->ino_orig) {
#line 4755
              if (linkp->l_dev == asb->sb_stat.st_dev) {
                {
#line 4755
                tmp___4 = strcmp((char const   *)(linkp->l_path)->p_name, (char const   *)name);
                }
#line 4755
                if (tmp___4) {
                  {
#line 4760
                  printf((char const   */* __restrict  */)" -> %s", (linkp->l_path)->p_name);
                  }
#line 4761
                  goto while_break;
                }
              }
            }
#line 4764
            linknext = linkp->l_forw;
#line 4753
            linkp = linknext;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
#line 4772
      if ((asb->sb_stat.st_mode & 61440U) == 40960U) {
#line 4772
        if ((unsigned long )from == (unsigned long )((void *)0)) {
          {
#line 4773
          printf((char const   */* __restrict  */)" S-> %s", asb->sb_link);
          }
        }
      }
    }
  }
#line 4777
  if (! flag0) {
    {
#line 4778
    putchar('\n');
    }
  } else
#line 4777
  if (useoutmodetoc) {
    {
#line 4778
    putchar('\n');
    }
  }
#line 4779
  return;
}
}
#line 4786 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void tocmode(mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 4792
  if ((mode & 61440U) == 32768U) {
#line 4792
    goto case_32768;
  }
#line 4795
  if ((mode & 61440U) == 16384U) {
#line 4795
    goto case_16384;
  }
#line 4799
  if ((mode & 61440U) == 40960U) {
#line 4799
    goto case_40960;
  }
#line 4804
  if ((mode & 61440U) == 49152U) {
#line 4804
    goto case_49152;
  }
#line 4808
  if ((mode & 61440U) == 24576U) {
#line 4808
    goto case_24576;
  }
#line 4811
  if ((mode & 61440U) == 8192U) {
#line 4811
    goto case_8192;
  }
#line 4815
  if ((mode & 61440U) == 4096U) {
#line 4815
    goto case_4096;
  }
#line 4819
  goto switch_default;
  case_32768: /* CIL Label */ 
  {
#line 4793
  putchar('-');
  }
#line 4794
  goto switch_break;
  case_16384: /* CIL Label */ 
  {
#line 4796
  putchar('d');
  }
#line 4797
  goto switch_break;
  case_40960: /* CIL Label */ 
  {
#line 4800
  putchar('l');
  }
#line 4801
  goto switch_break;
  case_49152: /* CIL Label */ 
  {
#line 4805
  putchar('s');
  }
#line 4806
  goto switch_break;
  case_24576: /* CIL Label */ 
  {
#line 4809
  putchar('b');
  }
#line 4810
  goto switch_break;
  case_8192: /* CIL Label */ 
  {
#line 4812
  putchar('c');
  }
#line 4813
  goto switch_break;
  case_4096: /* CIL Label */ 
  {
#line 4816
  putchar('p');
  }
#line 4817
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 4820
  printf((char const   */* __restrict  */)"[%o]", mode >> 12);
  }
  switch_break: /* CIL Label */ ;
  }
#line 4822
  if (mode & 256U) {
#line 4822
    tmp = 'r';
  } else {
#line 4822
    tmp = '-';
  }
  {
#line 4822
  putchar(tmp);
  }
#line 4823
  if (mode & 128U) {
#line 4823
    tmp___0 = 'w';
  } else {
#line 4823
    tmp___0 = '-';
  }
  {
#line 4823
  putchar(tmp___0);
  }
#line 4824
  if (mode & 64U) {
#line 4824
    if (mode & 2048U) {
#line 4824
      tmp___1 = 's';
    } else {
#line 4824
      tmp___1 = 'x';
    }
#line 4824
    tmp___3 = tmp___1;
  } else {
#line 4824
    if (mode & 2048U) {
#line 4824
      tmp___2 = 'S';
    } else {
#line 4824
      tmp___2 = '-';
    }
#line 4824
    tmp___3 = tmp___2;
  }
  {
#line 4824
  putchar(tmp___3);
  }
#line 4827
  if (mode & 32U) {
#line 4827
    tmp___4 = 'r';
  } else {
#line 4827
    tmp___4 = '-';
  }
  {
#line 4827
  putchar(tmp___4);
  }
#line 4828
  if (mode & 16U) {
#line 4828
    tmp___5 = 'w';
  } else {
#line 4828
    tmp___5 = '-';
  }
  {
#line 4828
  putchar(tmp___5);
  }
#line 4829
  if (mode & 8U) {
#line 4829
    if (mode & 1024U) {
#line 4829
      tmp___6 = 's';
    } else {
#line 4829
      tmp___6 = 'x';
    }
#line 4829
    tmp___8 = tmp___6;
  } else {
#line 4829
    if (mode & 1024U) {
#line 4829
      tmp___7 = 'S';
    } else {
#line 4829
      tmp___7 = '-';
    }
#line 4829
    tmp___8 = tmp___7;
  }
  {
#line 4829
  putchar(tmp___8);
  }
#line 4832
  if (mode & 4U) {
#line 4832
    tmp___9 = 'r';
  } else {
#line 4832
    tmp___9 = '-';
  }
  {
#line 4832
  putchar(tmp___9);
  }
#line 4833
  if (mode & 2U) {
#line 4833
    tmp___10 = 'w';
  } else {
#line 4833
    tmp___10 = '-';
  }
  {
#line 4833
  putchar(tmp___10);
  }
#line 4834
  if (mode & 1U) {
#line 4834
    if (mode & 512U) {
#line 4834
      tmp___11 = 't';
    } else {
#line 4834
      tmp___11 = 'x';
    }
#line 4834
    tmp___13 = tmp___11;
  } else {
#line 4834
    if (mode & 512U) {
#line 4834
      tmp___12 = 'T';
    } else {
#line 4834
      tmp___12 = '-';
    }
#line 4834
    tmp___13 = tmp___12;
  }
  {
#line 4834
  putchar(tmp___13);
  }
#line 4837
  return;
}
}
#line 4844 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void usage(void) 
{ 


  {
  {
#line 4847
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage:\t[filename generator] | %s -o [options] archive  : write archive\n        %s -i [options] archive  : install archive\n        %s -t [options] archive  : list table-of-contents of archive\n        %s -r [options] archive  : verify archive against filesystem\nFrequently used options:\n General: -v : verbose\n          -Z : with -o: gzip files when writing them to the archive,\n               with -i/t/r: handle archive written with -Z option\n          -5 : abort instead of creating archive incompatible with cpio\n Tape:    -s [volsize]   : size of volume, can have suffix k or m or g\n          -b [blocksize] : block size (default is 5120)\n          -c [count]     : buffer count blocks between doing I/O\n Install: -n : protect newer files  -k : skip corrupt data at beginning\n Select:  -y [pattern] : only process files matching pattern\n          -Y [pattern] : do not process files matching pattern\n",
          myname, myname, myname, myname);
#line 4864
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version %s dated %s\n",
          "2.5.1dev", ">05 Feb 2012");
#line 4865
  exit(1);
  }
}
}
#line 4873 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int warn(char *what , char *why ) 
{ 
  time_t dietime ;
  char *tmp ;

  {
  {
#line 4879
  warnings ++;
#line 4880
  dietime = time((time_t *)((void *)0));
#line 4882
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\": %s\n",
          myname, what, why);
  }
#line 4886
  if ((unsigned long )logfile != (unsigned long )((FILE *)0)) {
    {
#line 4887
    tmp = ctime((time_t const   *)(& dietime));
#line 4887
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: \"%s\": %s (disk %u) at %s",
            myname, what, why, arvolume, tmp);
    }
  }
#line 4889
  return (-1);
}
}
#line 4892 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int warn_nocount(char *what , char *why ) 
{ 
  int tmp ;

  {
  {
#line 4896
  warnings --;
#line 4897
  tmp = warn(what, why);
  }
#line 4897
  return (tmp);
}
}
#line 4906 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int warnarch(char *msg___0 , off_t adjust ) 
{ 


  {
  {
#line 4911
  warnings ++;
#line 4912
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\" [offset ",
          myname, arspec);
#line 4913
  prsize(stderr, total - (ulonglong )adjust);
#line 4914
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]: %s\n",
          msg___0);
  }
#line 4915
  return (-1);
}
}
#line 4931 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static unsigned int delay[12]  = 
#line 4931
  {      1U,      1U,      2U,      3U, 
        5U,      8U,      13U,      21U, 
        34U,      55U,      89U,      144U};
#line 4923 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int xfork(char *what , int die ) 
{ 
  register int pid ;
  register Child *cp ;
  register int idx ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 4935
  if ((unsigned long )logfile != (unsigned long )((FILE *)0)) {
    {
#line 4935
    fflush(logfile);
    }
  }
  {
#line 4937
  fflush(stdout);
#line 4938
  fflush(stderr);
#line 4942
  signal(17, (void (*)(int  ))0);
#line 4946
  idx = 0;
  }
  {
#line 4946
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4946
    pid = fork();
    }
#line 4946
    if (! (pid < 0)) {
#line 4946
      goto while_break;
    }
#line 4948
    if ((unsigned long )idx == sizeof(delay)) {
#line 4950
      if (die) {
        {
#line 4951
        tmp = syserr();
#line 4951
        fatal(arspec, tmp);
        }
      } else {
#line 4953
        return (-1);
      }
    }
    {
#line 4956
    warn_nocount(what, (char *)"Trouble forking...");
    }
#line 4957
    if (Fflag) {
#line 4957
      if (! die) {
#line 4958
        return (-1);
      }
    }
    {
#line 4959
    sleep(delay[idx]);
#line 4946
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4961
  if (idx) {
    {
#line 4962
    warn_nocount(what, (char *)"...successful fork");
    }
  }
  {
#line 4963
  tmp___0 = memget((unsigned int )sizeof(*cp));
#line 4963
  cp = (Child *)tmp___0;
#line 4964
  cp->c_pid = pid;
#line 4965
  cp->c_flags = 0;
#line 4966
  cp->c_status = 0;
#line 4967
  cp->c_forw = children;
#line 4968
  children = cp;
  }
#line 4969
  return (pid);
}
}
#line 4977 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void xpause(void) 
{ 
  register Child *cp ;
  register int pid ;
  int status ;

  {
  {
#line 4984
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4986
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4986
      pid = wait((union wait *)(& status));
      }
#line 4986
      if (! (pid < 0)) {
#line 4986
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4988
    cp = children;
    {
#line 4988
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4988
      if (cp) {
#line 4988
        if (! (cp->c_pid != pid)) {
#line 4988
          goto while_break___1;
        }
      } else {
#line 4988
        goto while_break___1;
      }
#line 4988
      cp = cp->c_forw;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4984
    if (! ((unsigned long )cp == (unsigned long )((void *)0))) {
#line 4984
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4992
  cp->c_flags |= 1;
#line 4993
  cp->c_status = status;
#line 4994
  return;
}
}
#line 5001 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int xwait(int pid , char *what , int compstat2 ) 
{ 
  register int status ;
  register Child *cp ;
  register Child **acp ;
  char why[100] ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 5012
  acp = & children;
  {
#line 5012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5012
    cp = *acp;
#line 5012
    if (! cp) {
#line 5012
      goto while_break;
    }
#line 5013
    if (cp->c_pid == pid) {
#line 5014
      goto while_break;
    }
#line 5012
    acp = & cp->c_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 5015
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 5016
    fatal(what, (char *)"Lost child");
    }
  }
  {
#line 5017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5017
    if (! ((cp->c_flags & 1) == 0)) {
#line 5017
      goto while_break___0;
    }
    {
#line 5018
    xpause();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5019
  status = cp->c_status;
#line 5020
  *acp = cp->c_forw;
#line 5021
  free((void *)((char *)cp));
  }
#line 5022
  if (status == 0) {
#line 5023
    return (0);
  }
#line 5024
  if (status & 255) {
#line 5025
    if (status & 128) {
#line 5025
      tmp = " -- core dumped";
    } else {
#line 5025
      tmp = "";
    }
    {
#line 5025
    sprintf((char */* __restrict  */)(why), (char const   */* __restrict  */)"Killed by signal %d%s",
            status & 127, tmp);
    }
  } else {
    {
#line 5028
    sprintf((char */* __restrict  */)(why), (char const   */* __restrict  */)"Exit %d",
            (status >> 8) & 255);
    }
  }
#line 5030
  if (! compstat2) {
#line 5030
    if (((status >> 8) & 255) != 2) {
      {
#line 5031
      tmp___0 = warn(what, why);
      }
#line 5031
      return (tmp___0);
    } else {
#line 5030
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5030
  if (compstat2) {
    {
#line 5031
    tmp___0 = warn(what, why);
    }
#line 5031
    return (tmp___0);
  } else {
#line 5033
    return ((status >> 8) & 255);
  }
}
}
#line 5038 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void verify(int error ) 
{ 
  char *verbuf ;
  char *buf ;
  register time_t began ;
  int got ;
  int len ;
  unsigned int readamt ;
  char msg___0[200] ;
  char answer[20] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  int answernum ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  time_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 5050
  if ((int )*arname == 33) {
    {
#line 5052
    warn((char *)"Can\'t verify a piped command", (char *)"");
    }
#line 5053
    return;
  }
#line 5055
  if (! error) {
    {
#line 5057
    tmp = malloc((size_t )arbsize);
#line 5057
    verbuf = (char *)tmp;
    }
#line 5057
    if ((unsigned long )verbuf == (unsigned long )((void *)0)) {
      {
#line 5058
      fatal(arspec, (char *)"Cannot allocate Verify I/O buffer");
      }
    }
    {
#line 5066
    nextclos();
#line 5067
    verifycnt = (short )((int )verifycnt + 1);
#line 5069
    tmp___3 = nextopen(0);
    }
#line 5069
    if (tmp___3 < 0) {
      {
#line 5071
      warn((char *)"re-open for verify failed", (char *)"");
#line 5072
      error = 1;
      }
    } else {
#line 5078
      if (Fflag) {
        {
#line 5080
        tmp___0 = ioctl(arfd, (unsigned long )((unsigned int )(2 << 8) | 75U), (void *)0);
        }
#line 5080
        if (tmp___0 < 0) {
          {
#line 5081
          warn(arname, (char *)"can\'t flush device cache.");
          }
        }
      }
      {
#line 5085
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Verifying disk %u...\n",
              arvolume);
#line 5086
      buf = buffer;
      }
      {
#line 5086
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5086
        len = (int )(bufidx - buf);
#line 5086
        if (! len) {
#line 5086
          goto while_break;
        }
#line 5088
        if ((unsigned int )len < arbsize) {
#line 5088
          readamt = (unsigned int )len;
        } else {
#line 5088
          readamt = arbsize;
        }
        {
#line 5089
        tmp___2 = read(arfd, (void *)verbuf, (size_t )readamt);
#line 5089
        got = (int )tmp___2;
        }
#line 5089
        if ((unsigned int )got == readamt) {
          {
#line 5092
          tmp___1 = memcmp((void const   *)verbuf, (void const   *)buf, (size_t )got);
          }
#line 5092
          if (tmp___1 != 0) {
            {
#line 5097
            warn((char *)"Verify failed", (char *)"");
#line 5098
            error = 1;
            }
#line 5099
            goto while_break;
          } else {
#line 5102
            buf += got;
          }
        } else {
          {
#line 5106
          warn((char *)"Read returned short", (char *)"");
#line 5107
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read %d wanted %d bytes\n",
                  got, readamt);
#line 5109
          error = 1;
          }
#line 5110
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 5114
    free((void *)verbuf);
    }
  }
#line 5116
  if (error) {
    {
#line 5118
    answernum = 0;
#line 5119
    nextclos();
    }
    {
#line 5121
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 5123
      began = time((time_t *)((void *)0));
      }
#line 5124
      if (hidequit) {
#line 5124
        tmp___4 = "";
      } else {
#line 5124
        tmp___4 = "\tEnter \"quit\" to ABORT the backup\n\a";
      }
#line 5124
      if (error) {
#line 5124
        if ((int )verifycnt == 0) {
#line 5124
          tmp___5 = "Writing";
        } else {
#line 5124
          tmp___5 = "Verify";
        }
      } else {
#line 5124
        tmp___5 = "Verify";
      }
      {
#line 5124
      sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"%s: %s of disk %u has FAILED!\a\n\tEnter 1 to RETRY this disk\n\tEnter 2 to REFORMAT this disk before a RETRY\n\a\n%s",
              myname, tmp___5, arvolume, tmp___4);
#line 5133
      nextask(msg___0, answer, (int )sizeof(answer));
#line 5134
      tmp___6 = time((time_t *)((void *)0));
#line 5134
      timewait += tmp___6 - began;
#line 5135
      answernum = atoi((char const   *)(answer));
      }
#line 5137
      if (answernum == 1) {
        {
#line 5140
        tmp___7 = nextopen(1);
        }
#line 5140
        if (tmp___7 < 0) {
#line 5141
          goto __Cont;
        }
      } else
#line 5143
      if (answernum == 2) {
        {
#line 5145
        tmp___9 = system((char const   *)formatcmd);
        }
#line 5145
        if (tmp___9 != 0) {
          {
#line 5147
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Format failed!\n");
#line 5148
          answernum = 0;
          }
        } else {
          {
#line 5152
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Format successful!\n");
#line 5154
          tmp___8 = nextopen(1);
          }
#line 5154
          if (tmp___8 < 0) {
#line 5155
            goto __Cont;
          }
#line 5156
          return;
        }
      } else {
        {
#line 5159
        tmp___10 = strcmp((char const   *)(answer), "quit");
        }
#line 5159
        if (tmp___10 == 0) {
          {
#line 5160
          fatal(arspec, (char *)"Quiting during a verify");
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 5163
  return;
}
}
#line 5174 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
static int firsttime  =    1;
#line 5166 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
int writedisk(int realwrite ) 
{ 
  register char *buf ;
  register int got ;
  register unsigned int len ;
  int wrstat ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 5180
  if (fflag) {
    {
#line 5181
    outwait();
    }
  }
#line 5187
  if (Fflag) {
#line 5199
    if (! firsttime) {
#line 5199
      if ((unsigned long )bufidx > (unsigned long )buffer) {
        {
#line 5200
        next(1, (char *)"Next disk needed");
        }
      } else {
#line 5199
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 5202
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 5202
        tmp = nextopen(1);
        }
#line 5202
        if (! (tmp < 0)) {
#line 5202
          goto while_break;
        }
        {
#line 5204
        verifycnt = (short)0;
#line 5205
        verify(1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 5207
    firsttime = 0;
  }
#line 5215
  if (fflag) {
    {
#line 5217
    outpid = xfork((char *)"outflush()", 1);
    }
#line 5218
    if (outpid != 0) {
      {
#line 5221
      arleft -= (ulonglong )(bufidx - buffer);
#line 5223
      nextclos();
      }
#line 5225
      return (0);
    } else {
      {
#line 5228
      nice(-10);
      }
    }
  }
  {
#line 5231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5233
    wrstat = 0;
#line 5235
    buf = buffer;
    {
#line 5235
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5235
      len = (unsigned int )(bufidx - buf);
#line 5235
      if (! len) {
#line 5235
        goto while_break___1;
      }
#line 5237
      if ((int )*arname == 33) {
#line 5237
        tmp___8 = len;
      } else {
#line 5237
        if (len < arbsize) {
#line 5237
          tmp___7 = len;
        } else {
#line 5237
          tmp___7 = arbsize;
        }
#line 5237
        tmp___8 = tmp___7;
      }
      {
#line 5237
      tmp___9 = write(arfd, (void const   *)buf, (size_t )tmp___8);
#line 5237
      got = (int )tmp___9;
      }
#line 5237
      if (got > 0) {
#line 5240
        buf += got;
#line 5241
        if (realwrite) {
#line 5242
          arleft -= (ulonglong )got;
        }
      } else
#line 5244
      if (fflag) {
#line 5246
        if (got < 0) {
          {
#line 5246
          tmp___0 = syserr();
#line 5246
          tmp___1 = (char const   *)tmp___0;
          }
        } else {
#line 5246
          tmp___1 = "Apparently full -- archive will be incomplete";
        }
        {
#line 5246
        warn(arspec, (char *)tmp___1);
#line 5249
        _exit(1);
        }
      } else
#line 5251
      if (got < 0) {
        {
#line 5253
        tmp___3 = __errno_location();
        }
#line 5253
        if (*tmp___3 == 32) {
          {
#line 5254
          tmp___2 = syserr();
#line 5254
          fatal(arspec, tmp___2);
          }
        }
        {
#line 5256
        tmp___4 = __errno_location();
        }
#line 5256
        if (*tmp___4 == 28) {
          {
#line 5257
          next(1, (char *)"No space left on device");
          }
#line 5258
          goto __Cont;
        }
#line 5261
        if (! Jflag) {
          {
#line 5262
          tmp___5 = syserr();
#line 5262
          fatal(arspec, tmp___5);
          }
        } else {
          {
#line 5265
          tmp___6 = syserr();
#line 5265
          warn(arspec, tmp___6);
#line 5266
          anycorrupt = 1;
          }
        }
#line 5268
        wrstat = 1;
#line 5269
        goto while_break___1;
      } else {
#line 5273
        if (Fflag) {
#line 5273
          if (verifyflag) {
            {
#line 5277
            warn(arspec, (char *)"Apparently full already");
#line 5279
            wrstat = 1;
            }
#line 5280
            goto while_break___1;
          }
        }
        {
#line 5283
        next(1, (char *)"Apparently full");
        }
#line 5287
        goto __Cont;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5290
    if (Fflag) {
#line 5290
      if (verifyflag) {
        {
#line 5292
        verifycnt = (short)0;
#line 5293
        verify(wrstat);
        }
      }
    }
#line 5303
    if (Fflag) {
#line 5303
      if (! verifyflag) {
#line 5303
        arleft = aruntil;
      }
    }
#line 5231
    if (wrstat) {
#line 5231
      if (Fflag) {
#line 5231
        if (! verifyflag) {
#line 5231
          goto while_break___0;
        }
      } else {
#line 5231
        goto while_break___0;
      }
    } else {
#line 5231
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5308
  if (fflag) {
    {
#line 5309
    _exit(wrstat);
    }
  } else {
#line 5311
    return (wrstat);
  }
#line 5313
  return (0);
}
}
#line 5316 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.c"
void goodbye(int status ) 
{ 
  time_t dietime ;
  char *tmp ;

  {
#line 5321
  if (status) {
#line 5321
    if ((unsigned long )logfile != (unsigned long )((FILE *)0)) {
      {
#line 5324
      dietime = time((time_t *)((void *)0));
#line 5326
      tmp = ctime((time_t const   *)(& dietime));
#line 5326
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: the backup has failed (status %d), died at %s",
              myname, status, tmp);
      }
    }
  }
  {
#line 5330
  exit(status);
  }
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 42 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
int ignoreslash  =    1;
#line 57 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
Pattern *pattern  ;
#line 64 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
void nameadd(char *name , int ptype ) 
{ 
  register Pattern *px ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 71
  tmp = memget((unsigned int )sizeof(Pattern ));
#line 71
  px = (Pattern *)tmp;
#line 72
  px->p_forw = pattern;
#line 73
  px->p_str = strdup((char const   *)name);
  }
#line 74
  if ((unsigned long )px->p_str == (unsigned long )((void *)0)) {
    {
#line 74
    fatal(name, (char *)"out of memory.");
    }
  }
  {
#line 75
  tmp___0 = strlen((char const   *)name);
#line 75
  px->p_len = (int )tmp___0;
#line 76
  px->p_ptype = ptype;
#line 77
  px->p_noglob = (int )noglob;
#line 78
  pattern = px;
  }
#line 81
  return;
}
}
#line 90 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
int nameaddfile(char *fname , int ptype , int parsewith0 ) 
{ 
  FILE *infile ;
  char pat[1025] ;
  int c ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 100
  infile = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 101
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
#line 101
    return (0);
  }
#line 103
  if (parsewith0) {
#line 105
    i = 0;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 106
      c = fgetc(infile);
      }
#line 106
      if (! (c != -1)) {
#line 106
        goto while_break;
      }
#line 108
      if ((unsigned long )i > sizeof(pat)) {
        {
#line 109
        fatal(pat, (char *)"Path name too long");
        }
      }
#line 111
      pat[i] = (char )c;
#line 113
      if (c == 0) {
#line 115
        if (i > 0) {
          {
#line 115
          nameadd(pat, ptype);
          }
        }
#line 116
        i = 0;
#line 117
        goto while_continue;
      }
#line 119
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 122
    if (i > 0) {
#line 122
      if ((unsigned long )i < sizeof(pat)) {
        {
#line 124
        pat[i] = (char)0;
#line 125
        nameadd(pat, ptype);
        }
      }
    }
  } else {
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 130
      tmp___2 = fgets((char */* __restrict  */)(pat), 1024, (FILE */* __restrict  */)infile);
      }
#line 130
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 130
        goto while_break___0;
      }
      {
#line 133
      tmp = strlen((char const   *)(pat));
#line 133
      pat[tmp - 1UL] = (char )'\000';
#line 135
      tmp___0 = strlen((char const   *)(pat));
      }
#line 135
      if (tmp___0 == 0UL) {
#line 135
        goto while_continue___0;
      }
      {
#line 137
      tmp___1 = strlen((char const   *)(pat));
      }
#line 137
      if ((int )pat[tmp___1 - 1UL] == 32) {
        {
#line 139
        warn(pat, (char *)"warning: trailing space in this pattern.");
        }
      }
      {
#line 142
      nameadd(pat, ptype);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 146
  fclose(infile);
  }
#line 147
  return (1);
}
}
#line 167 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
int namecmp(char *name , Stat *asb ) 
{ 
  register Pattern *px ;
  int existpospat ;
  char *namedot ;
  char *p ;
  char *n ;
  char namec[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 181
  if (asb) {
#line 181
    if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 181
      if (asb->sb_stat.st_rdev & 2UL) {
#line 181
        return (0);
      }
    }
  }
  {
#line 183
  strcpy((char */* __restrict  */)(namec), (char const   */* __restrict  */)name);
#line 184
  namedot = strrchr((char const   *)(namec), '.');
  }
#line 185
  if (Zflag) {
#line 185
    if (asb) {
#line 185
      if ((asb->sb_stat.st_mode & 61440U) == 32768U) {
#line 185
        if (asb->sb_stat.st_rdev == 0UL) {
#line 185
          if (namedot) {
#line 185
            if ((int )*(namedot + 1) == 122) {
#line 185
              if (! *(namedot + 2)) {
#line 189
                *namedot = (char )'\000';
              } else {
#line 191
                namedot = (char *)0;
              }
            } else {
#line 191
              namedot = (char *)0;
            }
          } else {
#line 191
            namedot = (char *)0;
          }
        } else {
#line 191
          namedot = (char *)0;
        }
      } else {
#line 191
        namedot = (char *)0;
      }
    } else {
#line 191
      namedot = (char *)0;
    }
  } else {
#line 191
    namedot = (char *)0;
  }
#line 193
  n = namec;
#line 194
  if (ignoreslash) {
#line 194
    if ((int )*(n + 0) == 47) {
#line 194
      n ++;
    }
  }
#line 196
  px = pattern;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! px) {
#line 196
      goto while_break;
    }
#line 197
    if (px->p_ptype == 1) {
#line 199
      p = px->p_str;
#line 200
      if (ignoreslash) {
#line 200
        if ((int )*(p + 0) == 47) {
#line 200
          p ++;
        }
      }
#line 202
      if (px->p_noglob) {
        {
#line 204
        tmp = strcmp((char const   *)p, (char const   *)n);
        }
#line 204
        if (tmp == 0) {
#line 204
          return (-1);
        }
      } else {
        {
#line 208
        tmp___0 = fnmatch((char const   *)p, (char const   *)n, 0);
        }
#line 208
        if (tmp___0 == 0) {
#line 208
          return (-1);
        }
      }
    }
#line 196
    px = px->p_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  existpospat = 0;
#line 214
  px = pattern;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! px) {
#line 214
      goto while_break___0;
    }
#line 215
    if (px->p_ptype == 0) {
#line 217
      existpospat = 1;
#line 219
      p = px->p_str;
#line 220
      if (ignoreslash) {
#line 220
        if ((int )*(p + 0) == 47) {
#line 220
          p ++;
        }
      }
#line 222
      if (px->p_noglob) {
        {
#line 224
        tmp___1 = strcmp((char const   *)p, (char const   *)n);
        }
#line 224
        if (tmp___1 == 0) {
#line 224
          return (0);
        }
      } else {
        {
#line 228
        tmp___2 = fnmatch((char const   *)p, (char const   *)n, 0);
        }
#line 228
        if (tmp___2 == 0) {
#line 228
          return (0);
        }
      }
    }
#line 214
    px = px->p_forw;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  if (! existpospat) {
#line 232
    return (0);
  } else {
#line 232
    return (-1);
  }
}
}
#line 244 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/match.c"
int namecmp_ext(char *name ) 
{ 
  register Pattern *px ;
  char *p ;
  char *n ;
  int tmp ;

  {
#line 251
  n = name;
#line 252
  if (ignoreslash) {
#line 252
    if ((int )*(n + 0) == 47) {
#line 252
      n ++;
    }
  }
#line 254
  px = pattern;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! px) {
#line 254
      goto while_break;
    }
#line 255
    if (px->p_ptype == 2) {
#line 257
      p = px->p_str;
#line 258
      if (ignoreslash) {
#line 258
        if ((int )*(p + 0) == 47) {
#line 258
          p ++;
        }
      }
      {
#line 260
      tmp = fnmatch((char const   *)p, (char const   *)n, 0);
      }
#line 260
      if (tmp == 0) {
#line 260
        return (0);
      }
    }
#line 254
    px = px->p_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (-1);
}
}
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 42 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
int zipfdfd  ;
#line 510 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/afio.h"
char *compress_arg_list[102]  ;
#line 18 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void meminit(void) ;
#line 19
void memwrite(char *buf , int count ) ;
#line 20
int setupgzip(char *name ) ;
#line 25 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int gzipfactor  =    6;
#line 28 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int forceZflag  =    0;
#line 31 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
char *compressprog  =    (char *)((void *)0);
#line 32 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int compressargs  =    0;
#line 36 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
off_t maxmem  =    (off_t )262144000;
#line 39 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
long compthreshold  =    0L;
#line 48 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int compress_arg_no  =    1;
#line 50 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void add_arg(char *arg ) 
{ 
  int tmp ;

  {
#line 52
  if (compress_arg_no == 1) {
#line 52
    if ((int )*arg == 0) {
#line 55
      return;
    }
  }
#line 58
  if (compress_arg_no < 101) {
#line 59
    tmp = compress_arg_no;
#line 59
    compress_arg_no ++;
#line 59
    compress_arg_list[tmp] = arg;
  } else {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"afio: Fatal: maximium number of -Q arguments exceeded.\n");
#line 63
    exit(1);
    }
  }
#line 66
  return;
}
}
#line 72 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int memerror  ;
#line 73 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
char *membank  =    (char *)((void *)0);
#line 74 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
size_t allocsize  =    (size_t )0;
#line 75 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
size_t memsize  ;
#line 75 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
size_t membytesread  ;
#line 75 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
size_t membytesleft  ;
#line 77 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void meminit(void) 
{ 
  void *tmp ;

  {
#line 79
  memerror = 0;
#line 80
  memsize = (size_t )0;
#line 82
  if (! allocsize) {
    {
#line 83
    allocsize = (size_t )100000;
#line 84
    tmp = malloc(allocsize);
#line 84
    membank = (char *)tmp;
    }
#line 85
    if ((unsigned long )membank == (unsigned long )((void *)0)) {
      {
#line 87
      warn_nocount((char *)"Memory", (char *)"Low on virtual memory, zipping twice instead.");
#line 88
      memerror = 1;
#line 89
      allocsize = (size_t )0;
      }
    }
  }
#line 92
  return;
}
}
#line 94 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void memwrite(char *buf , int count ) 
{ 
  char *oldbank ;
  void *tmp ;

  {
#line 98
  if (memerror) {
#line 98
    return;
  }
#line 100
  oldbank = membank;
#line 102
  if (memsize + (size_t )count >= allocsize) {
#line 103
    allocsize = (size_t )(1.25 * (double )(memsize + (size_t )count));
#line 107
    if ((allocsize / 1024UL) / 1024UL > 2000UL) {
#line 114
      membank = (char *)((void *)0);
    } else {
      {
#line 118
      tmp = realloc((void *)membank, allocsize);
#line 118
      membank = (char *)tmp;
      }
    }
#line 120
    if ((unsigned long )membank == (unsigned long )((void *)0)) {
      {
#line 122
      warn_nocount((char *)"Memory", (char *)"Low on virtual memory, zipping twice instead.");
#line 125
      free((void *)oldbank);
#line 126
      memerror = 1;
#line 127
      allocsize = (size_t )0;
      }
#line 128
      return;
    }
  }
  {
#line 132
  memcpy((void */* __restrict  */)(membank + memsize), (void const   */* __restrict  */)buf,
         (size_t )count);
#line 133
  memsize += (size_t )count;
  }
#line 134
  return;
}
}
#line 136 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void memreset(void) 
{ 


  {
#line 138
  membytesread = (size_t )0;
#line 139
  membytesleft = memsize;
#line 140
  return;
}
}
#line 142 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int memread(char *buf , int count ) 
{ 


  {
#line 144
  if (membytesleft == 0UL) {
#line 144
    return (0);
  }
#line 146
  if ((size_t )count > membytesleft) {
#line 146
    count = (int )membytesleft;
  }
  {
#line 147
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(membank + membytesread),
         (size_t )count);
#line 148
  membytesread += (size_t )count;
#line 149
  membytesleft -= (size_t )count;
  }
#line 150
  return (count);
}
}
#line 153 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void memfree(void) 
{ 


  {
#line 160
  return;
}
}
#line 170 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int comppid  ;
#line 172 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
int setupgzip(char *name ) 
{ 
  int pipedes[2] ;
  char farg[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 177
  farg[0] = (char )'-';
#line 178
  farg[1] = (char )(gzipfactor + 48);
#line 179
  farg[2] = (char )'\000';
#line 181
  tmp = pipe((int *)(pipedes));
  }
#line 181
  if (tmp == -1) {
    {
#line 181
    perror("pipe");
    }
#line 181
    return (-1);
  }
  {
#line 183
  mayberewind();
#line 185
  comppid = xfork((char *)"out(), compressing", 0);
  }
#line 185
  if (comppid == 0) {
#line 187
    if (arfd != 0) {
#line 187
      if (arfd != 1) {
        {
#line 187
        close(arfd);
        }
      }
    }
    {
#line 189
    tmp___0 = fileno(stdout);
#line 189
    dup2(pipedes[1], tmp___0);
#line 190
    close(pipedes[1]);
#line 191
    close(pipedes[0]);
#line 193
    tmp___1 = fileno(stdin);
#line 193
    close(tmp___1);
#line 195
    tmp___2 = open((char const   *)name, 0);
    }
#line 195
    if (tmp___2 >= 0) {
#line 197
      if (! compressargs) {
        {
#line 198
        execlp((char const   *)compressprog, (char const   *)compressprog, "-c", farg,
               (void *)0);
        }
      } else {
        {
#line 200
        execvp((char const   *)compressprog, (char * const  *)(compress_arg_list));
        }
      }
    }
    {
#line 202
    exit(1);
    }
  }
  {
#line 205
  close(pipedes[1]);
  }
#line 209
  return (pipedes[0]);
}
}
#line 215 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void waitforgzip(void) 
{ 


  {
  {
#line 219
  xwait(comppid, (char *)"out(), wait for gzip child", 0);
  }
#line 220
  return;
}
}
#line 235 "/home/june/collector/temp/afio-2.5.1.20130626+gite266635/compfile.c"
void compressfile(int *fdp , char *name , Stat *asb , int *cratio ) 
{ 
  int compout ;
  char *tmpcomp ;
  Stat asb2 ;
  int zipfd ;
  ssize_t len ;
  char buf[40960] ;
  off_t ziplen ;
  int usemem ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 246
  if (cratio) {
#line 247
    *cratio = 100;
  }
#line 274
  asb->sb_stat.st_rdev |= 1UL;
#line 286
  if (lflag) {
#line 286
    goto _L___3;
  } else
#line 286
  if (asb->sb_stat.st_nlink == 1UL) {
    _L___3: /* CIL Label */ 
    {
#line 286
    tmp___1 = matchcompext(name);
    }
#line 286
    if (tmp___1) {
      _L___2: /* CIL Label */ 
#line 286
      if (forceZflag) {
        _L___0: /* CIL Label */ 
        {
#line 297
        tmpcomp = strrchr((char const   *)name, '/');
        }
#line 297
        if ((unsigned long )tmpcomp != (unsigned long )((void *)0)) {
#line 298
          tmpcomp ++;
        } else {
#line 300
          tmpcomp = name;
        }
        {
#line 302
        tmp = strlen((char const   *)tmpcomp);
        }
#line 302
        if (tmp + 2UL > 255UL) {
          {
#line 308
          warn(name, (char *)" is too long to tack on .z");
          }
#line 309
          return;
        }
        {
#line 315
        usemem = 1;
#line 317
        zipfd = setupgzip(name);
        }
#line 317
        if (zipfd != -1) {
#line 319
          ziplen = (off_t )0;
#line 320
          if (usemem) {
            {
#line 320
            meminit();
            }
          }
          {
#line 321
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 321
            len = read(zipfd, (void *)(buf), sizeof(buf));
            }
#line 321
            if (! (len != 0L)) {
#line 321
              goto while_break;
            }
#line 323
            if (len < 0L) {
              {
#line 323
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trouble zipping file, storing uncompressed\n");
#line 326
              ziplen = (off_t )0;
              }
#line 326
              goto while_break;
            }
#line 328
            if (usemem) {
              {
#line 328
              memwrite(buf, (int )len);
              }
            }
#line 330
            ziplen += len;
#line 332
            if (usemem) {
#line 332
              if (ziplen > maxmem) {
#line 334
                usemem = 0;
#line 335
                if (! memerror) {
                  {
#line 335
                  memfree();
                  }
                }
              }
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 339
          close(zipfd);
#line 342
          tmp___0 = xwait(comppid, (char *)"out(), wait for gzip child", 0);
          }
#line 342
          if (tmp___0 != 0) {
            {
#line 343
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trouble zipping file, storing uncompressed\n");
#line 345
            ziplen = (off_t )0;
            }
          }
#line 348
          if (memerror) {
#line 348
            usemem = 0;
          }
#line 351
          asb2.sb_stat.st_size = ziplen;
#line 353
          if (ziplen > 0L) {
#line 357
            if (asb2.sb_stat.st_size < asb->sb_stat.st_size) {
#line 357
              goto _L;
            } else
#line 357
            if (forceZflag) {
              _L: /* CIL Label */ 
#line 359
              if (usemem) {
                {
#line 361
                close(*fdp);
#line 362
                strcat((char */* __restrict  */)name, (char const   */* __restrict  */)".z");
#line 364
                asb->sb_stat.st_rdev &= 0xfffffffffffffffeUL;
                }
#line 366
                if (cratio) {
#line 367
                  *cratio = (int )(((double )asb2.sb_stat.st_size * 100.0) / (double )asb->sb_stat.st_size);
                }
#line 368
                asb->sb_stat.st_size = asb2.sb_stat.st_size;
#line 369
                *fdp = 10000;
              } else {
                {
#line 372
                compout = setupgzip(name);
                }
#line 372
                if (compout >= 0) {
                  {
#line 374
                  zipfdfd = compout;
#line 375
                  compout = 10001;
#line 377
                  close(*fdp);
#line 378
                  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)".z");
#line 380
                  asb->sb_stat.st_rdev &= 0xfffffffffffffffeUL;
                  }
#line 382
                  if (cratio) {
#line 383
                    *cratio = (int )(((double )asb2.sb_stat.st_size * 100.0) / (double )asb->sb_stat.st_size);
                  }
#line 384
                  asb->sb_stat.st_size = asb2.sb_stat.st_size;
#line 385
                  *fdp = compout;
                }
              }
            } else
#line 390
            if (usemem) {
              {
#line 390
              memfree();
              }
            }
          }
        }
      }
    } else
#line 286
    if (asb->sb_stat.st_size >= compthreshold) {
#line 286
      if (maxsizetocompress == 0ULL) {
#line 286
        goto _L___0;
      } else
#line 286
      if ((ulonglong )asb->sb_stat.st_size <= maxsizetocompress) {
#line 286
        goto _L___0;
      } else {
#line 286
        goto _L___2;
      }
    } else {
#line 286
      goto _L___2;
    }
  }
#line 396
  return;
}
}
