/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
enum __anonenum_cmos_entry_config_t_29 {
    CMOS_ENTRY_ENUM = 0,
    CMOS_ENTRY_HEX = 1,
    CMOS_ENTRY_STRING = 2,
    CMOS_ENTRY_RESERVED = 3
} ;
#line 48 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
typedef enum __anonenum_cmos_entry_config_t_29 cmos_entry_config_t;
#line 57 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
struct __anonstruct_cmos_entry_t_30 {
   unsigned int bit ;
   unsigned int length ;
   cmos_entry_config_t config ;
   unsigned int config_id ;
   char name[33] ;
};
#line 57 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
typedef struct __anonstruct_cmos_entry_t_30 cmos_entry_t;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.h"
struct cmos_write_t;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.h"
typedef struct cmos_write_t cmos_write_t;
#line 44 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.h"
struct cmos_write_t {
   unsigned int bit ;
   unsigned int length ;
   cmos_entry_config_t config ;
   unsigned long long value ;
   cmos_write_t *next ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_34 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_34 regmatch_t;
#line 69 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
struct __anonstruct_cmos_enum_t_31 {
   unsigned int config_id ;
   unsigned long long value ;
   char text[33] ;
};
#line 69 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
typedef struct __anonstruct_cmos_enum_t_31 cmos_enum_t;
#line 80 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
struct __anonstruct_cmos_checksum_layout_t_32 {
   unsigned int summed_area_start ;
   unsigned int summed_area_end ;
   unsigned int checksum_at ;
};
#line 80 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
typedef struct __anonstruct_cmos_checksum_layout_t_32 cmos_checksum_layout_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 84 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.h"
struct __anonstruct_hexdump_format_t_18 {
   int bytes_per_line ;
   int addrprint_width ;
   char const   *indent ;
   char const   *sep1 ;
   char const   *sep2 ;
   char const   *sep3 ;
   unsigned char nonprintable ;
   int (*is_printable_fn)(unsigned char c ) ;
};
#line 84 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.h"
typedef struct __anonstruct_hexdump_format_t_18 hexdump_format_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 17 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/compute_ip_checksum.c"
union __anonunion_value_1 {
   uint8_t byte[2] ;
   uint16_t word ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_uint64 {
   uint32_t lo ;
   uint32_t hi ;
};
#line 78 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_header {
   uint8_t signature[4] ;
   uint32_t header_bytes ;
   uint32_t header_checksum ;
   uint32_t table_bytes ;
   uint32_t table_checksum ;
   uint32_t table_entries ;
};
#line 94 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_record {
   uint32_t tag ;
   uint32_t size ;
};
#line 103 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_memory_range {
   struct lb_uint64 start ;
   struct lb_uint64 size ;
   uint32_t type ;
};
#line 112 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_memory {
   uint32_t tag ;
   uint32_t size ;
   struct lb_memory_range map[0] ;
};
#line 126 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_mainboard {
   uint32_t tag ;
   uint32_t size ;
   uint8_t vendor_idx ;
   uint8_t part_number_idx ;
   uint8_t strings[0] ;
};
#line 144 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct lb_string {
   uint32_t tag ;
   uint32_t size ;
   uint8_t string[0] ;
};
#line 153 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct cmos_option_table {
   uint32_t tag ;
   uint32_t size ;
   uint32_t header_length ;
};
#line 167 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct cmos_entries {
   uint32_t tag ;
   uint32_t size ;
   uint32_t bit ;
   uint32_t length ;
   uint32_t config ;
   uint32_t config_id ;
   uint8_t name[32] ;
};
#line 185 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct cmos_enums {
   uint32_t tag ;
   uint32_t size ;
   uint32_t config_id ;
   uint32_t value ;
   uint8_t text[32] ;
};
#line 199 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct cmos_defaults {
   uint32_t tag ;
   uint32_t size ;
   uint32_t name_length ;
   uint8_t name[32] ;
   uint8_t default_set[128] ;
};
#line 209 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
struct cmos_checksum {
   uint32_t tag ;
   uint32_t size ;
   uint32_t range_start ;
   uint32_t range_end ;
   uint32_t location ;
   uint32_t type ;
};
#line 47 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
struct __anonstruct_lbtable_choice_t_34 {
   uint32_t tag ;
   char const   *name ;
   char const   *description ;
   char const   *nofound_msg ;
   void (*print_fn)(struct lb_record  const  *rec ) ;
};
#line 47 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
typedef struct __anonstruct_lbtable_choice_t_34 lbtable_choice_t;
#line 56 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
struct __anonstruct_mem_range_t_35 {
   unsigned long start ;
   unsigned long end ;
};
#line 56 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
typedef struct __anonstruct_mem_range_t_35 mem_range_t;
#line 36 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
enum __anonenum_nvramtool_op_t_29 {
    NVRAMTOOL_OP_SHOW_VERSION = 0,
    NVRAMTOOL_OP_SHOW_USAGE = 1,
    NVRAMTOOL_OP_LBTABLE_SHOW_INFO = 2,
    NVRAMTOOL_OP_LBTABLE_DUMP = 3,
    NVRAMTOOL_OP_SHOW_PARAM_VALUES = 4,
    NVRAMTOOL_OP_CMOS_SHOW_ONE_PARAM = 5,
    NVRAMTOOL_OP_CMOS_SHOW_ALL_PARAMS = 6,
    NVRAMTOOL_OP_CMOS_SET_ONE_PARAM = 7,
    NVRAMTOOL_OP_CMOS_SET_PARAMS_STDIN = 8,
    NVRAMTOOL_OP_CMOS_SET_PARAMS_FILE = 9,
    NVRAMTOOL_OP_CMOS_CHECKSUM = 10,
    NVRAMTOOL_OP_SHOW_LAYOUT = 11,
    NVRAMTOOL_OP_WRITE_CMOS_DUMP = 12,
    NVRAMTOOL_OP_READ_CMOS_DUMP = 13,
    NVRAMTOOL_OP_SHOW_CMOS_HEX_DUMP = 14,
    NVRAMTOOL_OP_SHOW_CMOS_DUMPFILE = 15
} ;
#line 36 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
typedef enum __anonenum_nvramtool_op_t_29 nvramtool_op_t;
#line 56 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
struct __anonstruct_nvramtool_op_info_t_30 {
   nvramtool_op_t op ;
   char *param ;
};
#line 56 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
typedef struct __anonstruct_nvramtool_op_info_t_30 nvramtool_op_info_t;
#line 70 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
struct __anonstruct_nvramtool_op_modifier_info_t_32 {
   int found ;
   int found_seq ;
   char *param ;
};
#line 70 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
typedef struct __anonstruct_nvramtool_op_modifier_info_t_32 nvramtool_op_modifier_info_t;
#line 42 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
typedef void (*op_fn_t)(void);
#line 35 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
struct cmos_entry_item_t;
#line 35 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
typedef struct cmos_entry_item_t cmos_entry_item_t;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
struct cmos_entry_item_t {
   cmos_entry_t item ;
   cmos_entry_item_t *next ;
};
#line 42
struct cmos_enum_item_t;
#line 42 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
typedef struct cmos_enum_item_t cmos_enum_item_t;
#line 44 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
struct cmos_enum_item_t {
   cmos_enum_t item ;
   cmos_enum_item_t *next ;
};
#line 62 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
enum __anonenum_nvramtool_op_modifier_t_31 {
    NVRAMTOOL_MOD_SHOW_VALUE_ONLY = 0,
    NVRAMTOOL_MOD_USE_CMOS_LAYOUT_FILE = 1,
    NVRAMTOOL_MOD_USE_CMOS_OPT_TABLE = 2,
    NVRAMTOOL_NUM_OP_MODIFIERS = 3
} ;
#line 62 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
typedef enum __anonenum_nvramtool_op_modifier_t_31 nvramtool_op_modifier_t;
#line 35 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
struct __anonstruct_cmos_bit_op_location_t_33 {
   unsigned int byte_index ;
   unsigned int bit_offset ;
};
#line 35 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
typedef struct __anonstruct_cmos_bit_op_location_t_33 cmos_bit_op_location_t;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 62 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.h"
char const   prog_name[10] ;
#line 67
int get_line_from_file(FILE *f , char *line , int line_buf_size ) ;
#line 68
void out_of_memory(void) ;
#line 100 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
cmos_entry_t const   *find_cmos_entry(char const   *name ) ;
#line 110
int is_checksum_name(char const   *name ) ;
#line 52 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.h"
cmos_write_t *process_input_file(FILE *f ) ;
#line 53
void do_cmos_writes(cmos_write_t *list ) ;
#line 55
char const   assignment_regex[111] ;
#line 45 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.h"
int prepare_cmos_write(cmos_entry_t const   *e , char const   *value_str , unsigned long long *value ) ;
#line 48
void cmos_checksum_write(uint16_t checksum ) ;
#line 49
uint16_t cmos_checksum_compute(void) ;
#line 42 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.h"
void cmos_write(cmos_entry_t const   *e , unsigned long long value ) ;
#line 47
void set_iopl(int level ) ;
#line 577 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/reg_expr.h"
void compile_reg_exprs(int cflags , int num_exprs  , ...) ;
#line 39
void free_reg_exprs(int num_exprs  , ...) ;
#line 38 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static int get_input_file_line(FILE *f , char *line , int line_buf_size ) ;
#line 39
static unsigned long long try_prepare_cmos_write(cmos_entry_t const   *e , char const   *value_str ) ;
#line 43 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static char const   blank_or_comment_regex[37]  = 
#line 43
  {      (char const   )'(',      (char const   )'^',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )'$',      (char const   )')', 
        (char const   )'|',      (char const   )'(',      (char const   )'^',      (char const   )'[', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'*',      (char const   )'#', 
        (char const   )'.',      (char const   )'*',      (char const   )'$',      (char const   )')', 
        (char const   )'\000'};
#line 55 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
char const   assignment_regex[111]  = 
#line 55
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )')', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'*', 
        (char const   )'=',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )'(', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'+', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )')',      (char const   )'*',      (char const   )')', 
        (char const   )'+',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 71 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static int line_num  ;
#line 82 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static int const   LINE_BUF_SIZE  =    (int const   )256;
#line 83 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static unsigned long const   N_MATCHES  =    (size_t const   )4;
#line 80 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
cmos_write_t *process_input_file(FILE *f ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  char const   *name ;
  char const   *value ;
  cmos_write_t *list ;
  cmos_write_t *item ;
  cmos_write_t **p ;
  regex_t blank_or_comment ;
  regex_t assignment ;
  regmatch_t *match ;
  unsigned long __lengthofmatch ;
  void *tmp___0 ;
  cmos_entry_t const   *e ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 84
  __lengthofline = (unsigned long )LINE_BUF_SIZE;
#line 84
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 84
  line = (char *)tmp;
#line 88
  __lengthofmatch = (unsigned long )N_MATCHES;
#line 88
  tmp___0 = __builtin_alloca(sizeof(*match) * __lengthofmatch);
#line 88
  match = (regmatch_t *)tmp___0;
#line 91
  list = (cmos_write_t *)((void *)0);
#line 92
  p = & list;
#line 94
  compile_reg_exprs(1 | ((1 << 1) << 1), 2, blank_or_comment_regex, & blank_or_comment,
                    assignment_regex, & assignment);
#line 98
  line_num = 1;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp___5 = get_input_file_line(f, line, (int )LINE_BUF_SIZE);
    }
#line 98
    if (! (tmp___5 == 0)) {
#line 98
      goto while_break;
    }
    {
#line 102
    tmp___1 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment), (char const   */* __restrict  */)line,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 102
    if (! tmp___1) {
#line 103
      goto __Cont;
    }
    {
#line 108
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& assignment), (char const   */* __restrict  */)line,
                      (size_t )N_MATCHES, (regmatch_t */* __restrict  */)match, 0);
    }
#line 108
    if (tmp___2) {
      {
#line 109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of input file.\n",
              prog_name, line_num);
#line 111
      exit(1);
      }
    }
    {
#line 117
    *(line + (match + 1)->rm_eo) = (char )'\000';
#line 118
    *(line + (match + 2)->rm_eo) = (char )'\000';
#line 119
    name = (char const   *)(line + (match + 1)->rm_so);
#line 120
    value = (char const   *)(line + (match + 2)->rm_so);
#line 123
    tmp___3 = is_checksum_name(name);
    }
#line 123
    if (tmp___3) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: CMOS parameter %s not found.\n",
              prog_name, line_num, name);
#line 126
      exit(1);
      }
    } else {
      {
#line 123
      e = find_cmos_entry(name);
      }
#line 123
      if ((unsigned long )e == (unsigned long )((void *)0)) {
        {
#line 124
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: CMOS parameter %s not found.\n",
                prog_name, line_num, name);
#line 126
        exit(1);
        }
      }
    }
    {
#line 134
    tmp___4 = malloc(sizeof(*item));
#line 134
    item = (cmos_write_t *)tmp___4;
    }
#line 134
    if ((unsigned long )item == (unsigned long )((void *)0)) {
      {
#line 135
      out_of_memory();
      }
    }
    {
#line 137
    item->bit = (unsigned int )e->bit;
#line 138
    item->length = (unsigned int )e->length;
#line 139
    item->config = (cmos_entry_config_t )e->config;
#line 140
    item->value = try_prepare_cmos_write(e, value);
#line 143
    item->next = (cmos_write_t *)((void *)0);
#line 144
    *p = item;
#line 145
    p = & item->next;
    }
    __Cont: /* CIL Label */ 
#line 98
    line_num ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  free_reg_exprs(2, & blank_or_comment, & assignment);
  }
#line 149
  return (list);
}
}
#line 159 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
void do_cmos_writes(cmos_write_t *list ) 
{ 
  cmos_write_t *item ;
  cmos_entry_t e ;
  uint16_t tmp ;

  {
  {
#line 162
  set_iopl(3);
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 164
      goto while_break;
    }
    {
#line 166
    item = list;
#line 167
    e.bit = item->bit;
#line 168
    e.length = item->length;
#line 169
    e.config = item->config;
#line 170
    list = item->next;
#line 171
    cmos_write((cmos_entry_t const   *)(& e), item->value);
#line 172
    free((void *)item);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp = cmos_checksum_compute();
#line 175
  cmos_checksum_write(tmp);
#line 176
  set_iopl(0);
  }
#line 177
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static int get_input_file_line(FILE *f , char *line , int line_buf_size ) 
{ 
  int tmp ;

  {
  {
#line 187
  tmp = get_line_from_file(f, line, line_buf_size);
  }
  {
#line 188
  if (tmp == 0) {
#line 188
    goto case_0;
  }
#line 191
  if (tmp == 65536) {
#line 191
    goto case_65536;
  }
#line 194
  if (tmp == 65537) {
#line 194
    goto case_65537;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
#line 189
  return (0);
  case_65536: /* CIL Label */ 
#line 192
  return (65536);
  case_65537: /* CIL Label */ 
  {
#line 195
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: Maximum line length exceeded.  Max is %d characters.\n",
          prog_name, line_num, line_buf_size - 2);
  }
#line 198
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 201
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c",
                201U, "get_input_file_line");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 204
  exit(1);
  }
#line 205
  return (1);
}
}
#line 215 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/input_file.c"
static unsigned long long try_prepare_cmos_write(cmos_entry_t const   *e , char const   *value_str ) 
{ 
  unsigned long long value ;
  int tmp ;

  {
  {
#line 219
  tmp = prepare_cmos_write(e, value_str, & value);
  }
  {
#line 220
  if (tmp == 0) {
#line 220
    goto case_0;
  }
#line 223
  if (tmp == 262144) {
#line 223
    goto case_262144;
  }
#line 228
  if (tmp == 262145) {
#line 228
    goto case_262145;
  }
#line 234
  if (tmp == 262146) {
#line 234
    goto case_262146;
  }
#line 239
  if (tmp == 262147) {
#line 239
    goto case_262147;
  }
#line 245
  if (tmp == 262148) {
#line 245
    goto case_262148;
  }
#line 251
  if (tmp == 262149) {
#line 251
    goto case_262149;
  }
#line 256
  if (tmp == 196608) {
#line 256
    goto case_196608;
  }
#line 262
  if (tmp == 196609) {
#line 262
    goto case_196609;
  }
#line 268
  if (tmp == 196610) {
#line 268
    goto case_196610;
  }
#line 274
  goto switch_default;
  case_0: /* CIL Label */ 
#line 221
  return (value);
  case_262144: /* CIL Label */ 
  {
#line 224
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: Bad value for parameter %s.",
          prog_name, line_num, e->name);
  }
#line 226
  goto switch_break;
  case_262145: /* CIL Label */ 
  {
#line 229
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: This program does not support assignment of negative numbers to coreboot parameters.",
          prog_name, line_num);
  }
#line 232
  goto switch_break;
  case_262146: /* CIL Label */ 
  {
#line 235
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: %s is not a valid integer.",
          prog_name, line_num, value_str);
  }
#line 237
  goto switch_break;
  case_262147: /* CIL Label */ 
  {
#line 240
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: Can not modify reserved coreboot parameter %s.",
          prog_name, line_num, e->name);
  }
#line 243
  goto switch_break;
  case_262148: /* CIL Label */ 
  {
#line 246
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of input file: Can not write value %s to CMOS parameter %s that is only %d bits wide.",
          prog_name, line_num, value_str, e->name, e->length);
  }
#line 249
  goto switch_break;
  case_262149: /* CIL Label */ 
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: coreboot parameter %s has no matching enums.",
          prog_name, e->name);
  }
#line 254
  goto switch_break;
  case_196608: /* CIL Label */ 
  {
#line 257
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s is out of range.",
          prog_name, e->name);
  }
#line 260
  goto switch_break;
  case_196609: /* CIL Label */ 
  {
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s overlaps the realtime clock area.",
          prog_name, e->name);
  }
#line 266
  goto switch_break;
  case_196610: /* CIL Label */ 
  {
#line 269
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s is too wide.",
          prog_name, e->name);
  }
#line 272
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 275
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown error encountered while attempting to modify coreboot parameter %s.",
          prog_name, e->name);
  }
#line 278
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  No CMOS writes performed.\n");
#line 282
  exit(1);
  }
#line 283
  return (0ULL);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.h"
void set_layout_filename(char const   *filename ) ;
#line 38
void get_layout_from_file(void) ;
#line 39
void write_cmos_layout(FILE *f ) ;
#line 89 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
unsigned int cmos_checksum_start ;
#line 91
unsigned int cmos_checksum_end ;
#line 93
unsigned int cmos_checksum_index ;
#line 99
int add_cmos_entry(cmos_entry_t const   *e , cmos_entry_t const   **conflict ) ;
#line 101
cmos_entry_t const   *first_cmos_entry(void) ;
#line 102
cmos_entry_t const   *next_cmos_entry(cmos_entry_t const   *last ) ;
#line 103
int add_cmos_enum(cmos_enum_t const   *e ) ;
#line 106
cmos_enum_t const   *first_cmos_enum(void) ;
#line 107
cmos_enum_t const   *next_cmos_enum(cmos_enum_t const   *last ) ;
#line 111
int checksum_layout_to_bytes(cmos_checksum_layout_t *layout ) ;
#line 112
void checksum_layout_to_bits(cmos_checksum_layout_t *layout ) ;
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void process_layout_file(FILE *f ) ;
#line 38
static void skip_past_start(FILE *f ) ;
#line 39
static int process_entry(FILE *f , int skip_add ) ;
#line 40
static int process_enum(FILE *f , int skip_add ) ;
#line 41
static void process_checksum_info(FILE *f ) ;
#line 42
static void skip_remaining_lines(FILE *f ) ;
#line 43
static void create_entry(cmos_entry_t *cmos_entry , char const   *start_bit_str ,
                         char const   *length_str , char const   *config_str , char const   *config_id_str ,
                         char const   *name_str ) ;
#line 47
static void try_add_layout_file_entry(cmos_entry_t const   *cmos_entry ) ;
#line 48
static void create_enum(cmos_enum_t *cmos_enum , char const   *id_str , char const   *value_str ,
                        char const   *text_str ) ;
#line 50
static void try_add_cmos_enum(cmos_enum_t const   *cmos_enum ) ;
#line 51
static void set_checksum_info(char const   *start_str , char const   *end_str , char const   *index_str ) ;
#line 53
static char cmos_entry_char_value(cmos_entry_config_t config ) ;
#line 54
static int get_layout_file_line(FILE *f , char *line , int line_buf_size ) ;
#line 55
static unsigned int string_to_unsigned(char const   *str , char const   *str_name ) ;
#line 56
static unsigned long string_to_unsigned_long(char const   *str , char const   *str_name ) ;
#line 58
static unsigned long do_string_to_unsigned_long(char const   *str , char const   *str_name ,
                                                char const   *blurb ) ;
#line 63 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   blank_or_comment_regex___0[37]  = 
#line 63
  {      (char const   )'(',      (char const   )'^',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )'$',      (char const   )')', 
        (char const   )'|',      (char const   )'(',      (char const   )'^',      (char const   )'[', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'*',      (char const   )'#', 
        (char const   )'.',      (char const   )'*',      (char const   )'$',      (char const   )')', 
        (char const   )'\000'};
#line 74 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t blank_or_comment_expr  ;
#line 79 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   start_entries_regex[34]  = 
#line 79
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'e',      (char const   )'s', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'*', 
        (char const   )'$',      (char const   )'\000'};
#line 87 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t start_entries_expr  ;
#line 92 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   start_enums_regex[39]  = 
#line 92
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'e',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 100 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t start_enums_expr  ;
#line 105 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   start_checksums_regex[36]  = 
#line 105
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'u', 
        (char const   )'m',      (char const   )'s',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 113 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t start_checksums_expr  ;
#line 116 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   entries_line_regex[150]  = 
#line 116
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )')', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'+', 
        (char const   )'(',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )')',      (char const   )'[', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )')',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )'(',      (char const   )'[', 
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'+', 
        (char const   )')',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )')', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'*', 
        (char const   )'$',      (char const   )'\000'};
#line 140 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t entries_line_expr  ;
#line 143 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   enums_line_regex[96]  = 
#line 143
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )')', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'+', 
        (char const   )'(',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )')',      (char const   )'[', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )')',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 159 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t enums_line_expr  ;
#line 164 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   checksum_line_regex[116]  = 
#line 164
  {      (char const   )'^',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'*',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'u', 
        (char const   )'m',      (char const   )'[',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )')', 
        (char const   )'[',      (char const   )'[',      (char const   )':',      (char const   )'s', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )':',      (char const   )']',      (char const   )']',      (char const   )'+', 
        (char const   )'(',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'+',      (char const   )')',      (char const   )'[', 
        (char const   )'[',      (char const   )':',      (char const   )'s',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )':', 
        (char const   )']',      (char const   )']',      (char const   )'+',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )':',      (char const   )']',      (char const   )']', 
        (char const   )'+',      (char const   )')',      (char const   )'[',      (char const   )'[', 
        (char const   )':',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )':',      (char const   )']', 
        (char const   )']',      (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 184 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static regex_t checksum_line_expr  ;
#line 186 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static int const   LINE_BUF_SIZE___0  =    (int const   )256;
#line 188 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static int line_num___0  ;
#line 190 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char const   *layout_filename  =    (char const   *)((void *)0);
#line 197 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
void set_layout_filename(char const   *filename ) 
{ 


  {
#line 198
  layout_filename = filename;
#line 198
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
void get_layout_from_file(void) 
{ 
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 208
  if (! ((unsigned long )layout_filename != (unsigned long )((void *)0))) {
    {
#line 208
    __assert_fail("layout_filename != ((void *)0)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c",
                  208U, "get_layout_from_file");
    }
  }
  {
#line 210
  f = fopen((char const   */* __restrict  */)layout_filename, (char const   */* __restrict  */)"r");
  }
#line 210
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 211
    tmp = __errno_location();
#line 211
    tmp___0 = strerror(*tmp);
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open CMOS layout file %s for reading: %s\n",
            prog_name, layout_filename, tmp___0);
#line 213
    exit(1);
    }
  }
  {
#line 216
  process_layout_file(f);
#line 217
  fclose(f);
  }
#line 218
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
void write_cmos_layout(FILE *f ) 
{ 
  cmos_entry_t const   *cmos_entry ;
  cmos_enum_t const   *cmos_enum ;
  cmos_checksum_layout_t layout ;
  char tmp ;

  {
  {
#line 231
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"entries\n");
#line 233
  cmos_entry = first_cmos_entry();
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned long )cmos_entry != (unsigned long )((void *)0))) {
#line 233
      goto while_break;
    }
    {
#line 236
    tmp = cmos_entry_char_value((cmos_entry_config_t )cmos_entry->config);
#line 236
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%u %u %c %u %s\n",
            cmos_entry->bit, cmos_entry->length, (int )tmp, cmos_entry->config_id,
            cmos_entry->name);
#line 233
    cmos_entry = next_cmos_entry(cmos_entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nenumerations\n");
#line 242
  cmos_enum = first_cmos_enum();
  }
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (! ((unsigned long )cmos_enum != (unsigned long )((void *)0))) {
#line 242
      goto while_break___0;
    }
    {
#line 245
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%u %llu %s\n",
            cmos_enum->config_id, cmos_enum->value, cmos_enum->text);
#line 242
    cmos_enum = next_cmos_enum(cmos_enum);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 248
  layout.summed_area_start = cmos_checksum_start;
#line 249
  layout.summed_area_end = cmos_checksum_end;
#line 250
  layout.checksum_at = cmos_checksum_index;
#line 251
  checksum_layout_to_bits(& layout);
#line 252
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nchecksums\nchecksum %u %u %u\n",
          layout.summed_area_start, layout.summed_area_end, layout.checksum_at);
  }
#line 254
  return;
}
}
#line 262 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void process_layout_file(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 263
  compile_reg_exprs(1 | ((1 << 1) << 1), 7, blank_or_comment_regex___0, & blank_or_comment_expr,
                    start_entries_regex, & start_entries_expr, entries_line_regex,
                    & entries_line_expr, start_enums_regex, & start_enums_expr, enums_line_regex,
                    & enums_line_expr, start_checksums_regex, & start_checksums_expr,
                    checksum_line_regex, & checksum_line_expr);
#line 271
  line_num___0 = 1;
#line 272
  skip_past_start(f);
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    tmp = process_entry(f, 1);
    }
#line 277
    if (tmp) {
#line 277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  tmp___0 = process_enum(f, 0);
  }
#line 281
  if (tmp___0) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS layout file contains no enumerations.\n",
            prog_name);
#line 284
    exit(1);
    }
  }
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 287
    tmp___1 = process_enum(f, 0);
    }
#line 287
    if (tmp___1) {
#line 287
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 290
  line_num___0 = 1;
#line 291
  fseek(f, 0L, 0);
#line 293
  skip_past_start(f);
#line 301
  tmp___2 = process_entry(f, 0);
  }
#line 301
  if (tmp___2) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS layout file contains no entries.\n",
            prog_name);
#line 304
    exit(1);
    }
  }
  {
#line 307
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 307
    tmp___3 = process_entry(f, 0);
    }
#line 307
    if (tmp___3) {
#line 307
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 310
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___4 = process_enum(f, 1);
    }
#line 310
    if (tmp___4) {
#line 310
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 313
  process_checksum_info(f);
#line 318
  skip_remaining_lines(f);
#line 320
  free_reg_exprs(7, & blank_or_comment_expr, & start_entries_expr, & entries_line_expr,
                 & start_enums_expr, & enums_line_expr, & start_checksums_expr, & checksum_line_expr);
  }
#line 324
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void skip_past_start(FILE *f ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 332
  __lengthofline = (unsigned long )LINE_BUF_SIZE___0;
#line 332
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 332
  line = (char *)tmp;
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 335
    tmp___0 = get_layout_file_line(f, line, (int )LINE_BUF_SIZE___0);
    }
#line 335
    if (tmp___0) {
      {
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"entries\" line not found in CMOS layout file.\n",
              prog_name);
#line 339
      exit(1);
      }
    }
    {
#line 342
    tmp___1 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 342
    if (! tmp___1) {
#line 343
      goto __Cont;
    }
    {
#line 345
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& start_entries_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 345
    if (! tmp___2) {
#line 346
      goto while_break;
    }
    {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of CMOS layout file.  \"entries\" line expected.\n",
            prog_name, line_num___0);
#line 350
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 334
    line_num___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  line_num___0 ++;
#line 354
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned long const   N_MATCHES___0  =    (size_t const   )6;
#line 363 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static int process_entry(FILE *f , int skip_add ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  regmatch_t *match ;
  unsigned long __lengthofmatch ;
  void *tmp___0 ;
  cmos_entry_t cmos_entry ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 365
  __lengthofline = (unsigned long )LINE_BUF_SIZE___0;
#line 365
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 365
  line = (char *)tmp;
#line 366
  __lengthofmatch = (unsigned long )N_MATCHES___0;
#line 366
  tmp___0 = __builtin_alloca(sizeof(*match) * __lengthofmatch);
#line 366
  match = (regmatch_t *)tmp___0;
#line 370
  result = 1;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 373
    tmp___1 = get_layout_file_line(f, line, (int )LINE_BUF_SIZE___0);
    }
#line 373
    if (tmp___1) {
      {
#line 374
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unexpected end of CMOS layout file reached while reading \"entries\" section.\n",
              prog_name);
#line 377
      exit(1);
      }
    }
    {
#line 380
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 380
    if (! tmp___2) {
#line 381
      goto __Cont;
    }
    {
#line 383
    tmp___4 = regexec((regex_t const   */* __restrict  */)(& entries_line_expr), (char const   */* __restrict  */)line,
                      (size_t )N_MATCHES___0, (regmatch_t */* __restrict  */)match,
                      0);
    }
#line 383
    if (tmp___4) {
      {
#line 384
      tmp___3 = regexec((regex_t const   */* __restrict  */)(& start_enums_expr),
                        (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                        0);
      }
#line 384
      if (tmp___3) {
        {
#line 385
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of CMOS layout file.\n",
                prog_name, line_num___0);
#line 387
        exit(1);
        }
      }
#line 390
      goto while_break;
    }
#line 393
    result = 0;
#line 395
    if (skip_add) {
#line 396
      goto while_break;
    }
    {
#line 398
    *(line + (match + 1)->rm_eo) = (char )'\000';
#line 399
    *(line + (match + 2)->rm_eo) = (char )'\000';
#line 400
    *(line + (match + 3)->rm_eo) = (char )'\000';
#line 401
    *(line + (match + 4)->rm_eo) = (char )'\000';
#line 402
    *(line + (match + 5)->rm_eo) = (char )'\000';
#line 403
    create_entry(& cmos_entry, (char const   *)(line + (match + 1)->rm_so), (char const   *)(line + (match + 2)->rm_so),
                 (char const   *)(line + (match + 3)->rm_so), (char const   *)(line + (match + 4)->rm_so),
                 (char const   *)(line + (match + 5)->rm_so));
#line 406
    try_add_layout_file_entry((cmos_entry_t const   *)(& cmos_entry));
    }
#line 407
    goto while_break;
    __Cont: /* CIL Label */ 
#line 372
    line_num___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  line_num___0 ++;
#line 411
  return (result);
}
}
#line 422 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned long const   N_MATCHES___1  =    (size_t const   )4;
#line 421 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static int process_enum(FILE *f , int skip_add ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  regmatch_t *match ;
  unsigned long __lengthofmatch ;
  void *tmp___0 ;
  cmos_enum_t cmos_enum ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 423
  __lengthofline = (unsigned long )LINE_BUF_SIZE___0;
#line 423
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 423
  line = (char *)tmp;
#line 424
  __lengthofmatch = (unsigned long )N_MATCHES___1;
#line 424
  tmp___0 = __builtin_alloca(sizeof(*match) * __lengthofmatch);
#line 424
  match = (regmatch_t *)tmp___0;
#line 428
  result = 1;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    tmp___1 = get_layout_file_line(f, line, (int )LINE_BUF_SIZE___0);
    }
#line 431
    if (tmp___1) {
      {
#line 432
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unexpected end of CMOS layout file reached while reading \"enumerations\" section.\n",
              prog_name);
#line 435
      exit(1);
      }
    }
    {
#line 438
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 438
    if (! tmp___2) {
#line 439
      goto __Cont;
    }
    {
#line 441
    tmp___4 = regexec((regex_t const   */* __restrict  */)(& enums_line_expr), (char const   */* __restrict  */)line,
                      (size_t )N_MATCHES___1, (regmatch_t */* __restrict  */)match,
                      0);
    }
#line 441
    if (tmp___4) {
      {
#line 442
      tmp___3 = regexec((regex_t const   */* __restrict  */)(& start_checksums_expr),
                        (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                        0);
      }
#line 442
      if (tmp___3) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of CMOS layout file.\n",
                prog_name, line_num___0);
#line 445
        exit(1);
        }
      }
#line 448
      goto while_break;
    }
#line 451
    result = 0;
#line 453
    if (skip_add) {
#line 454
      goto while_break;
    }
    {
#line 456
    *(line + (match + 1)->rm_eo) = (char )'\000';
#line 457
    *(line + (match + 2)->rm_eo) = (char )'\000';
#line 458
    *(line + (match + 3)->rm_eo) = (char )'\000';
#line 459
    create_enum(& cmos_enum, (char const   *)(line + (match + 1)->rm_so), (char const   *)(line + (match + 2)->rm_so),
                (char const   *)(line + (match + 3)->rm_so));
#line 461
    try_add_cmos_enum((cmos_enum_t const   *)(& cmos_enum));
    }
#line 462
    goto while_break;
    __Cont: /* CIL Label */ 
#line 430
    line_num___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  line_num___0 ++;
#line 466
  return (result);
}
}
#line 475 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned long const   N_MATCHES___2  =    (size_t const   )4;
#line 474 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void process_checksum_info(FILE *f ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  regmatch_t *match ;
  unsigned long __lengthofmatch ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 476
  __lengthofline = (unsigned long )LINE_BUF_SIZE___0;
#line 476
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 476
  line = (char *)tmp;
#line 477
  __lengthofmatch = (unsigned long )N_MATCHES___2;
#line 477
  tmp___0 = __builtin_alloca(sizeof(*match) * __lengthofmatch);
#line 477
  match = (regmatch_t *)tmp___0;
  }
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 480
    tmp___1 = get_layout_file_line(f, line, (int )LINE_BUF_SIZE___0);
    }
#line 480
    if (tmp___1) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unexpected end of CMOS layout file reached while reading \"checksums\" section.\n",
              prog_name);
#line 484
      exit(1);
      }
    }
    {
#line 487
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 487
    if (! tmp___2) {
#line 488
      goto __Cont;
    }
    {
#line 490
    tmp___3 = regexec((regex_t const   */* __restrict  */)(& checksum_line_expr),
                      (char const   */* __restrict  */)line, (size_t )N_MATCHES___2,
                      (regmatch_t */* __restrict  */)match, 0);
    }
#line 490
    if (tmp___3) {
      {
#line 491
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of CMOS layout file.  \"checksum\" line expected.\n",
              prog_name, line_num___0);
#line 494
      exit(1);
      }
    }
    {
#line 498
    *(line + (match + 1)->rm_eo) = (char )'\000';
#line 499
    *(line + (match + 2)->rm_eo) = (char )'\000';
#line 500
    *(line + (match + 3)->rm_eo) = (char )'\000';
#line 501
    set_checksum_info((char const   *)(line + (match + 1)->rm_so), (char const   *)(line + (match + 2)->rm_so),
                      (char const   *)(line + (match + 3)->rm_so));
    }
#line 503
    goto while_break;
    __Cont: /* CIL Label */ 
#line 479
    line_num___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return;
}
}
#line 513 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void skip_remaining_lines(FILE *f ) 
{ 
  char *line ;
  unsigned long __lengthofline ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 514
  __lengthofline = (unsigned long )LINE_BUF_SIZE___0;
#line 514
  tmp = __builtin_alloca(sizeof(*line) * __lengthofline);
#line 514
  line = (char *)tmp;
#line 516
  line_num___0 ++;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 516
    tmp___1 = get_layout_file_line(f, line, (int )LINE_BUF_SIZE___0);
    }
#line 516
    if (! (tmp___1 == 0)) {
#line 516
      goto while_break;
    }
    {
#line 519
    tmp___0 = regexec((regex_t const   */* __restrict  */)(& blank_or_comment_expr),
                      (char const   */* __restrict  */)line, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
    }
#line 519
    if (tmp___0) {
      {
#line 520
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Syntax error on line %d of CMOS layout file: Only comments and/or whitespace allowed after \"checksum\" line.\n",
              prog_name, line_num___0);
#line 523
      exit(1);
      }
    }
#line 516
    line_num___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return;
}
}
#line 534 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void create_entry(cmos_entry_t *cmos_entry , char const   *start_bit_str ,
                         char const   *length_str , char const   *config_str , char const   *config_id_str ,
                         char const   *name_str ) 
{ 
  size_t tmp ;

  {
  {
#line 538
  cmos_entry->bit = string_to_unsigned(start_bit_str, "start-bit");
#line 539
  cmos_entry->length = string_to_unsigned(length_str, "length");
  }
#line 541
  if ((int const   )*(config_str + 1) != 0) {
#line 542
    goto bad_config_str;
  }
  {
#line 545
  if ((int const   )*(config_str + 0) == 101) {
#line 545
    goto case_101;
  }
#line 549
  if ((int const   )*(config_str + 0) == 104) {
#line 549
    goto case_104;
  }
#line 553
  if ((int const   )*(config_str + 0) == 115) {
#line 553
    goto case_115;
  }
#line 557
  if ((int const   )*(config_str + 0) == 114) {
#line 557
    goto case_114;
  }
#line 561
  goto switch_default;
  case_101: /* CIL Label */ 
#line 546
  cmos_entry->config = (cmos_entry_config_t )0;
#line 547
  goto switch_break;
  case_104: /* CIL Label */ 
#line 550
  cmos_entry->config = (cmos_entry_config_t )1;
#line 551
  goto switch_break;
  case_115: /* CIL Label */ 
#line 554
  cmos_entry->config = (cmos_entry_config_t )2;
#line 555
  goto switch_break;
  case_114: /* CIL Label */ 
#line 558
  cmos_entry->config = (cmos_entry_config_t )3;
#line 559
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 562
  goto bad_config_str;
  switch_break: /* CIL Label */ ;
  }
  {
#line 565
  cmos_entry->config_id = string_to_unsigned(config_id_str, "config-ID");
#line 567
  tmp = strlen(name_str);
  }
#line 567
  if (tmp >= 32UL) {
    {
#line 568
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: name too long (max length is %d).\n",
            prog_name, line_num___0, 31);
#line 571
    exit(1);
    }
  }
  {
#line 574
  strcpy((char */* __restrict  */)(cmos_entry->name), (char const   */* __restrict  */)name_str);
  }
#line 575
  return;
  bad_config_str: 
  {
#line 578
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: \'e\', \'h\', or \'r\' expected for config value.\n",
          prog_name, line_num___0);
#line 580
  exit(1);
  }
}
}
#line 589 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void try_add_layout_file_entry(cmos_entry_t const   *cmos_entry ) 
{ 
  cmos_entry_t const   *conflict ;
  int tmp ;

  {
  {
#line 592
  tmp = add_cmos_entry(cmos_entry, & conflict);
  }
  {
#line 593
  if (tmp == 0) {
#line 593
    goto case_0;
  }
#line 596
  if (tmp == 196608) {
#line 596
    goto case_196608;
  }
#line 602
  if (tmp == 196610) {
#line 602
    goto case_196610;
  }
#line 608
  if (tmp == 131072) {
#line 608
    goto case_131072;
  }
#line 614
  if (tmp == 131073) {
#line 614
    goto case_131073;
  }
#line 621
  goto switch_default;
  case_0: /* CIL Label */ 
#line 594
  return;
  case_196608: /* CIL Label */ 
  {
#line 597
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  Area covered by entry %s is out of range.\n",
          prog_name, line_num___0, cmos_entry->name);
  }
#line 600
  goto switch_break;
  case_196610: /* CIL Label */ 
  {
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  Area covered by entry %s is too wide.\n",
          prog_name, line_num___0, cmos_entry->name);
  }
#line 606
  goto switch_break;
  case_131072: /* CIL Label */ 
  {
#line 609
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  Layouts overlap for entries %s and %s.\n",
          prog_name, line_num___0, cmos_entry->name, conflict->name);
  }
#line 612
  goto switch_break;
  case_131073: /* CIL Label */ 
#line 619
  return;
  switch_default: /* CIL Label */ 
  {
#line 622
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c",
                622U, "try_add_layout_file_entry");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 625
  exit(1);
  }
}
}
#line 634 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void create_enum(cmos_enum_t *cmos_enum , char const   *id_str , char const   *value_str ,
                        char const   *text_str ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;

  {
  {
#line 636
  cmos_enum->config_id = string_to_unsigned(id_str, "ID");
#line 637
  tmp = string_to_unsigned_long(value_str, "value");
#line 637
  cmos_enum->value = (unsigned long long )tmp;
#line 639
  tmp___0 = strlen(text_str);
  }
#line 639
  if (tmp___0 >= 32UL) {
    {
#line 640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: text too long (max length is %d).\n",
            prog_name, line_num___0, 31);
#line 643
    exit(1);
    }
  }
  {
#line 646
  strcpy((char */* __restrict  */)(cmos_enum->text), (char const   */* __restrict  */)text_str);
  }
#line 647
  return;
}
}
#line 655 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void try_add_cmos_enum(cmos_enum_t const   *cmos_enum ) 
{ 
  int tmp ;

  {
  {
#line 656
  tmp = add_cmos_enum(cmos_enum);
  }
  {
#line 657
  if (tmp == 0) {
#line 657
    goto case_0;
  }
#line 660
  if (tmp == 131074) {
#line 660
    goto case_131074;
  }
#line 666
  goto switch_default;
  case_0: /* CIL Label */ 
#line 658
  return;
  case_131074: /* CIL Label */ 
  {
#line 661
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: Enumeration found with duplicate ID/value combination.\n",
          prog_name, line_num___0);
  }
#line 664
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 667
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c",
                667U, "try_add_cmos_enum");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 670
  exit(1);
  }
}
}
#line 679 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static void set_checksum_info(char const   *start_str , char const   *end_str , char const   *index_str ) 
{ 
  cmos_checksum_layout_t layout ;
  int tmp ;

  {
  {
#line 684
  layout.summed_area_start = string_to_unsigned(start_str, "CMOS checksummed area start");
#line 686
  layout.summed_area_end = string_to_unsigned(end_str, "CMOS checksummed area end");
#line 688
  layout.checksum_at = string_to_unsigned(index_str, "CMOS checksum location");
#line 691
  tmp = checksum_layout_to_bytes(& layout);
  }
  {
#line 692
  if (tmp == 0) {
#line 692
    goto case_0;
  }
#line 695
  if (tmp == 131075) {
#line 695
    goto case_131075;
  }
#line 701
  if (tmp == 131076) {
#line 701
    goto case_131076;
  }
#line 707
  if (tmp == 131077) {
#line 707
    goto case_131077;
  }
#line 713
  if (tmp == 131078) {
#line 713
    goto case_131078;
  }
#line 719
  if (tmp == 131079) {
#line 719
    goto case_131079;
  }
#line 725
  if (tmp == 131080) {
#line 725
    goto case_131080;
  }
#line 730
  if (tmp == 131081) {
#line 730
    goto case_131081;
  }
#line 735
  goto switch_default;
  case_0: /* CIL Label */ 
#line 693
  goto switch_break;
  case_131075: /* CIL Label */ 
  {
#line 696
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksummed area start is not byte-aligned.\n",
          prog_name, line_num___0);
  }
#line 699
  goto fail;
  case_131076: /* CIL Label */ 
  {
#line 702
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksummed area end is not byte-aligned.\n",
          prog_name, line_num___0);
  }
#line 705
  goto fail;
  case_131077: /* CIL Label */ 
  {
#line 708
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksum location is not byte-aligned.\n",
          prog_name, line_num___0);
  }
#line 711
  goto fail;
  case_131078: /* CIL Label */ 
  {
#line 714
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksummed area end must be greater than CMOS checksummed area start.\n",
          prog_name, line_num___0);
  }
#line 717
  goto fail;
  case_131079: /* CIL Label */ 
  {
#line 720
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksum overlaps checksummed area.\n",
          prog_name, line_num___0);
  }
#line 723
  goto fail;
  case_131080: /* CIL Label */ 
  {
#line 726
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksummed area out of range.\n",
          prog_name, line_num___0);
  }
#line 728
  goto fail;
  case_131081: /* CIL Label */ 
  {
#line 731
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file.  CMOS checksum location out of range.\n",
          prog_name, line_num___0);
  }
#line 733
  goto fail;
  switch_default: /* CIL Label */ 
  {
#line 736
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c",
                736U, "set_checksum_info");
  }
  switch_break: /* CIL Label */ ;
  }
#line 739
  cmos_checksum_start = layout.summed_area_start;
#line 740
  cmos_checksum_end = layout.summed_area_end;
#line 741
  cmos_checksum_index = layout.checksum_at;
#line 742
  return;
  fail: 
  {
#line 745
  exit(1);
  }
}
}
#line 753 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static char cmos_entry_char_value(cmos_entry_config_t config ) 
{ 


  {
  {
#line 755
  if ((unsigned int )config == 0U) {
#line 755
    goto case_0;
  }
#line 758
  if ((unsigned int )config == 1U) {
#line 758
    goto case_1;
  }
#line 761
  if ((unsigned int )config == 3U) {
#line 761
    goto case_3;
  }
#line 764
  if ((unsigned int )config == 2U) {
#line 764
    goto case_2;
  }
#line 767
  goto switch_default;
  case_0: /* CIL Label */ 
#line 756
  return ((char )'e');
  case_1: /* CIL Label */ 
#line 759
  return ((char )'h');
  case_3: /* CIL Label */ 
#line 762
  return ((char )'r');
  case_2: /* CIL Label */ 
#line 765
  return ((char )'s');
  switch_default: /* CIL Label */ 
  {
#line 768
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c",
                768U, "cmos_entry_char_value");
  }
  switch_break: /* CIL Label */ ;
  }
#line 771
  return ((char)0);
}
}
#line 781 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static int get_layout_file_line(FILE *f , char *line , int line_buf_size ) 
{ 
  int tmp ;

  {
  {
#line 782
  tmp = get_line_from_file(f, line, line_buf_size);
  }
  {
#line 783
  if (tmp == 0) {
#line 783
    goto case_0;
  }
#line 786
  if (tmp == 65536) {
#line 786
    goto case_65536;
  }
#line 789
  if (tmp == 65537) {
#line 789
    goto case_65537;
  }
#line 782
  goto switch_break;
  case_0: /* CIL Label */ 
#line 784
  return (0);
  case_65536: /* CIL Label */ 
#line 787
  return (65536);
  case_65537: /* CIL Label */ 
  {
#line 790
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: Maximum line length exceeded.  Max is %d characters.\n",
          prog_name, line_num___0, line_buf_size - 2);
  }
#line 793
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 796
  exit(1);
  }
#line 797
  return (1);
}
}
#line 805 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned int string_to_unsigned(char const   *str , char const   *str_name ) 
{ 
  unsigned long n ;
  unsigned int z ;

  {
  {
#line 809
  n = do_string_to_unsigned_long(str, str_name, "");
#line 811
  z = (unsigned int )n;
  }
#line 811
  if ((unsigned long )z != n) {
    {
#line 815
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: %s value is out of range.\n",
            prog_name, line_num___0, str_name);
#line 817
    exit(1);
    }
  }
#line 820
  return (z);
}
}
#line 828 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned long string_to_unsigned_long(char const   *str , char const   *str_name ) 
{ 
  unsigned long tmp ;

  {
  {
#line 830
  tmp = do_string_to_unsigned_long(str, str_name, " long");
  }
#line 830
  return (tmp);
}
}
#line 838 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout_file.c"
static unsigned long do_string_to_unsigned_long(char const   *str , char const   *str_name ,
                                                char const   *blurb ) 
{ 
  unsigned long n ;
  char *p ;

  {
  {
#line 844
  n = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
              0);
  }
#line 846
  if ((int )*p != 0) {
    {
#line 847
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error on line %d of CMOS layout file: %s is not a valid unsigned%s integer.\n",
            prog_name, line_num___0, str_name, blurb);
#line 850
    exit(1);
    }
  }
#line 853
  return (n);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 112 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.h"
void hexdump(void const   *mem , int bytes , uint64_t addrprint_start , FILE *outfile ,
             hexdump_format_t const   *format___0 ) ;
#line 129
int default_is_printable_fn(unsigned char c ) ;
#line 46 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
static void addrprint(FILE *outfile , uint64_t address , int width ) ;
#line 47
static void hexprint(FILE *outfile , unsigned char byte ) ;
#line 48
static void charprint(FILE *outfile , unsigned char byte , unsigned char nonprintable ,
                      int (*is_printable_fn)(unsigned char c ) ) ;
#line 68 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
void hexdump(void const   *mem , int bytes , uint64_t addrprint_start , FILE *outfile ,
             hexdump_format_t const   *format___0 ) 
{ 
  int bytes_left ;
  int index ;
  int i ;
  unsigned char const   *p ;
  int (*is_printable_fn)(unsigned char c ) ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 75
  if (format___0->bytes_per_line <= 0) {
#line 76
    return;
  } else
#line 75
  if (bytes < 0) {
#line 76
    return;
  }
#line 78
  is_printable_fn = (int (*)(unsigned char c ))format___0->is_printable_fn;
#line 80
  if ((unsigned long )is_printable_fn == (unsigned long )((void *)0)) {
#line 81
    is_printable_fn = & default_is_printable_fn;
  }
#line 83
  p = (unsigned char const   *)mem;
#line 84
  index = 0;
#line 90
  bytes_left = bytes;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (bytes_left >= (int )format___0->bytes_per_line)) {
#line 90
      goto while_break;
    }
    {
#line 94
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->indent);
#line 95
    addrprint(outfile, addrprint_start + (uint64_t )index, (int )format___0->addrprint_width);
#line 96
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep1);
#line 99
    i = 0;
    }
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 100
      tmp = index;
#line 100
      index ++;
#line 100
      hexprint(outfile, (unsigned char )*(p + tmp));
#line 102
      i ++;
      }
#line 102
      if (i >= (int )format___0->bytes_per_line) {
#line 103
        goto while_break___0;
      }
      {
#line 105
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 108
    index -= (int )format___0->bytes_per_line;
#line 109
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep3);
#line 112
    i = 0;
    }
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 112
      if (! (i < (int )format___0->bytes_per_line)) {
#line 112
        goto while_break___1;
      }
      {
#line 113
      tmp___0 = index;
#line 113
      index ++;
#line 113
      charprint(outfile, (unsigned char )*(p + tmp___0), (unsigned char )format___0->nonprintable,
                is_printable_fn);
#line 112
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 116
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n");
#line 90
    bytes_left -= (int )format___0->bytes_per_line;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (bytes_left == 0) {
#line 120
    return;
  }
  {
#line 123
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->indent);
#line 124
  addrprint(outfile, addrprint_start + (uint64_t )index, (int )format___0->addrprint_width);
#line 125
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep1);
#line 128
  i = 0;
  }
  {
#line 128
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 128
    if (! (i < bytes_left)) {
#line 128
      goto while_break___2;
    }
    {
#line 129
    tmp___1 = index;
#line 129
    index ++;
#line 129
    hexprint(outfile, (unsigned char )*(p + tmp___1));
#line 130
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep2);
#line 128
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 133
  index -= bytes_left;
  {
#line 136
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 137
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"  ");
#line 139
    i ++;
    }
#line 139
    if (i >= (int )format___0->bytes_per_line) {
#line 140
      goto while_break___3;
    }
    {
#line 142
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep2);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 145
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)format___0->sep3);
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 148
    if (! (i < bytes_left)) {
#line 148
      goto while_break___4;
    }
    {
#line 149
    tmp___2 = index;
#line 149
    index ++;
#line 149
    charprint(outfile, (unsigned char )*(p + tmp___2), (unsigned char )format___0->nonprintable,
              is_printable_fn);
#line 148
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 152
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 152
    if (! (i < (int )format___0->bytes_per_line)) {
#line 152
      goto while_break___5;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" ");
#line 152
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n");
  }
#line 156
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
int default_is_printable_fn(unsigned char c ) 
{ 
  int tmp ;

  {
#line 173
  if ((int )c >= 32) {
#line 173
    if ((int )c <= 126) {
#line 173
      tmp = 1;
    } else {
#line 173
      tmp = 0;
    }
  } else {
#line 173
    tmp = 0;
  }
#line 173
  return (tmp);
}
}
#line 186 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
static void addrprint(FILE *outfile , uint64_t address , int width ) 
{ 
  char s[17] ;
  int i ;

  {
#line 191
  if (width < 1) {
#line 192
    width = 1;
  } else
#line 193
  if (width > 8) {
#line 194
    width = 8;
  }
  {
#line 197
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%016llx",
          (unsigned long long )address);
#line 202
  i = 16 - 2 * width;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%c",
            (int )s[i]);
#line 205
    i ++;
    }
#line 205
    if (i >= 16) {
#line 206
      goto while_break;
    }
#line 208
    if (i % 4 == 0) {
      {
#line 209
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)":");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
static char const   tbl[16]  = 
#line 223
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f'};
#line 222 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
static void hexprint(FILE *outfile , unsigned char byte ) 
{ 


  {
  {
#line 228
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%c%c",
          (int const   )tbl[(int )byte >> 4], (int const   )tbl[(int )byte & 15]);
  }
#line 229
  return;
}
}
#line 244 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/hexdump.c"
static void charprint(FILE *outfile , unsigned char byte , unsigned char nonprintable ,
                      int (*is_printable_fn)(unsigned char c ) ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 247
  tmp___1 = (*is_printable_fn)(byte);
  }
#line 247
  if (tmp___1) {
#line 247
    tmp___0 = (int )byte;
  } else {
#line 247
    tmp___0 = (int )nonprintable;
  }
  {
#line 247
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%c",
          tmp___0);
  }
#line 247
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 42 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/reg_expr.c"
static unsigned long const   ERROR_BUF_SIZE  =    (size_t const   )256;
#line 40 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/reg_expr.c"
void compile_reg_exprs(int cflags , int num_exprs  , ...) 
{ 
  char *error_msg ;
  unsigned long __lengthoferror_msg ;
  void *tmp ;
  va_list ap ;
  regex_t *reg ;
  char const   *expr ;
  int i ;
  int result ;
  char const   *tmp___0 ;
  regex_t *tmp___1 ;

  {
  {
#line 43
  __lengthoferror_msg = (unsigned long )ERROR_BUF_SIZE;
#line 43
  tmp = __builtin_alloca(sizeof(*error_msg) * __lengthoferror_msg);
#line 43
  error_msg = (char *)tmp;
#line 49
  __builtin_va_start(ap, num_exprs);
#line 51
  i = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < num_exprs)) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 52
    expr = tmp___0;
#line 53
    tmp___1 = __builtin_va_arg(ap, regex_t *);
#line 53
    reg = tmp___1;
#line 55
    result = regcomp((regex_t */* __restrict  */)reg, (char const   */* __restrict  */)expr,
                     cflags);
    }
#line 55
    if (result != 0) {
      {
#line 56
      regerror(result, (regex_t const   */* __restrict  */)reg, (char */* __restrict  */)error_msg,
               (size_t )ERROR_BUF_SIZE);
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              prog_name, error_msg);
#line 58
      exit(1);
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  __builtin_va_end(ap);
  }
#line 63
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/reg_expr.c"
void free_reg_exprs(int num_exprs  , ...) 
{ 
  va_list ap ;
  int i ;
  regex_t *tmp___0 ;

  {
  {
#line 74
  __builtin_va_start(ap, num_exprs);
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < num_exprs)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = __builtin_va_arg(ap, regex_t *);
#line 77
    regfree(tmp___0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  __builtin_va_end(ap);
  }
#line 80
  return;
}
}
#line 14 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/ip_checksum.h"
unsigned long compute_ip_checksum(void *addr , unsigned long length ) ;
#line 14 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/compute_ip_checksum.c"
unsigned long compute_ip_checksum(void *addr , unsigned long length ) 
{ 
  uint8_t *ptr ;
  union __anonunion_value_1  volatile  value ;
  unsigned long sum ;
  unsigned long i ;
  unsigned long value___0 ;

  {
#line 26
  sum = 0UL;
#line 27
  ptr = (uint8_t *)addr;
#line 28
  i = 0UL;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < length)) {
#line 28
      goto while_break;
    }
#line 30
    value___0 = (unsigned long )*(ptr + i);
#line 31
    if (i & 1UL) {
#line 32
      value___0 <<= 8;
    }
#line 35
    sum += value___0;
#line 37
    if (sum > 65535UL) {
#line 38
      sum = (sum + (sum >> 16)) & 65535UL;
    }
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  value.byte[0] = (uint8_t )(sum & 255UL);
#line 42
  value.byte[1] = (uint8_t )((sum >> 8) & 255UL);
#line 43
  return ((unsigned long )(~ ((int volatile   )value.word) & (int volatile   )65535));
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 60 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/coreboot_tables.h"
__inline static uint64_t unpack_lb64(struct lb_uint64 value ) 
{ 
  uint64_t result ;

  {
#line 63
  result = (uint64_t )value.hi;
#line 64
  result = (result << 32) + (uint64_t )value.lo;
#line 65
  return (result);
}
}
#line 36 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.h"
void get_lbtable(void) ;
#line 37
void get_layout_from_cmos_table(void) ;
#line 38
void dump_lbtable(void) ;
#line 39
void list_lbtable_choices(void) ;
#line 40
void list_lbtable_item(char const   *item ) ;
#line 87 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
char const   checksum_param_name[10] ;
#line 59 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.h"
__inline static int verify_cmos_byte_index(unsigned int index___0 ) 
{ 
  int tmp ;

  {
#line 60
  if (index___0 < 14U) {
#line 60
    tmp = 1;
  } else
#line 60
  if (index___0 >= 256U) {
#line 60
    tmp = 1;
  } else {
#line 60
    tmp = 0;
  }
#line 60
  return (tmp);
}
}
#line 62 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_header  const  *lbtable_scan(unsigned long start , unsigned long end ,
                                              int *bad_header_count , int *bad_table_count ) ;
#line 66
static void process_cmos_table(void) ;
#line 67
static void get_cmos_checksum_info(void) ;
#line 68
static void try_convert_checksum_layout(cmos_checksum_layout_t *layout ) ;
#line 69
static void try_add_cmos_table_enum(cmos_enum_t *cmos_enum ) ;
#line 70
static void try_add_cmos_table_entry(cmos_entry_t *cmos_entry ) ;
#line 71
static struct lb_record  const  *find_lbrec(uint32_t tag ) ;
#line 72
static char const   *lbrec_tag_to_str(uint32_t tag ) ;
#line 73
static struct cmos_entries  const  *first_cmos_table_entry(void) ;
#line 74
static struct cmos_entries  const  *next_cmos_table_entry(struct cmos_entries  const  *last ) ;
#line 76
static struct cmos_enums  const  *first_cmos_table_enum(void) ;
#line 77
static struct cmos_enums  const  *next_cmos_table_enum(struct cmos_enums  const  *last ) ;
#line 79
static struct lb_record  const  *first_cmos_rec(uint32_t tag ) ;
#line 80
static struct lb_record  const  *next_cmos_rec(struct lb_record  const  *last , uint32_t tag ) ;
#line 82
static void memory_print_fn(struct lb_record  const  *rec ) ;
#line 83
static void mainboard_print_fn(struct lb_record  const  *rec ) ;
#line 84
static void cmos_opt_table_print_fn(struct lb_record  const  *rec ) ;
#line 85
static void print_option_record(struct cmos_entries  const  *cmos_entry ) ;
#line 86
static void print_enum_record(struct cmos_enums  const  *cmos_enum ) ;
#line 87
static void print_defaults_record(struct cmos_defaults  const  *cmos_defaults ) ;
#line 88
static void print_unknown_record(struct lb_record  const  *cmos_item ) ;
#line 89
static void option_checksum_print_fn(struct lb_record  const  *rec ) ;
#line 90
static void string_print_fn(struct lb_record  const  *rec ) ;
#line 91
static void uint64_to_hex_string(char *str , uint64_t n ) ;
#line 93 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   memory_desc[49]  = 
#line 93
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'a', 
        (char const   )'b',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'s',      (char const   )'y',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'m',      (char const   )' ', 
        (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\000'};
#line 96 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   mainboard_desc[50]  = 
#line 96
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'a', 
        (char const   )'b',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'i',      (char const   )'n',      (char const   )'b',      (char const   )'o', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 99 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   version_desc[46]  = 
#line 99
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 102 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   extra_version_desc[52]  = 
#line 102
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 105 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   build_desc[44]  = 
#line 105
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'u',      (char const   )'i',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 108 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   compile_time_desc[44]  = 
#line 108
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'w', 
        (char const   )'h',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'b',      (char const   )'o',      (char const   )'o',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'s', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'d',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 111 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   compile_by_desc[39]  = 
#line 111
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'w', 
        (char const   )'h',      (char const   )'o',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'b',      (char const   )'o',      (char const   )'o',      (char const   )'t', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 114 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   compile_host_desc[64]  = 
#line 114
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'p', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 117 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   compile_domain_desc[71]  = 
#line 117
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'d', 
        (char const   )'o',      (char const   )'m',      (char const   )'a',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'a',      (char const   )'t',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'b',      (char const   )'o',      (char const   )'o',      (char const   )'t', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 120 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   compiler_desc[65]  = 
#line 120
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'b',      (char const   )'u',      (char const   )'i',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'t',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\000'};
#line 123 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   linker_desc[63]  = 
#line 123
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'k',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'b',      (char const   )'u', 
        (char const   )'i',      (char const   )'l',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'b',      (char const   )'o',      (char const   )'o',      (char const   )'t', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 126 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   assembler_desc[66]  = 
#line 126
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'m', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'b',      (char const   )'u',      (char const   )'i', 
        (char const   )'l',      (char const   )'d',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 129 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   cmos_opt_table_desc[170]  = 
#line 129
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )' ', 
        (char const   )'l',      (char const   )'o',      (char const   )'w',      (char const   )'-', 
        (char const   )'l',      (char const   )'e',      (char const   )'v',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'d',      (char const   )'u', 
        (char const   )'m',      (char const   )'p',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'C',      (char const   )'M', 
        (char const   )'O',      (char const   )'S',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
        (char const   )' ',      (char const   )' ',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'s', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'a',      (char const   )'b',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'a',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'n',      (char const   )'v', 
        (char const   )'o',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'R',      (char const   )'A',      (char const   )'M',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 135 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   option_checksum_desc[96]  = 
#line 135
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'C', 
        (char const   )'M',      (char const   )'O',      (char const   )'S',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'c', 
        (char const   )'k',      (char const   )'s',      (char const   )'u',      (char const   )'m', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )' ',      (char const   )'o',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'w', 
        (char const   )'h',      (char const   )'i',      (char const   )'c',      (char const   )'h', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'c',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'d',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 140 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   generic_nofound_msg[42]  = 
#line 140
  {      (char const   )'%',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'I',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 143 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   nofound_msg_cmos_opt_table[141]  = 
#line 143
  {      (char const   )'%',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'I',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
        (char const   )' ',      (char const   )' ',      (char const   )'A',      (char const   )'p', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'l',      (char const   )'y', 
        (char const   )',',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'s',      (char const   )'y',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'m',      (char const   )' ', 
        (char const   )'w',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'b',      (char const   )'u',      (char const   )'i',      (char const   )'l', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'H',      (char const   )'A',      (char const   )'V', 
        (char const   )'E',      (char const   )'_',      (char const   )'O',      (char const   )'P', 
        (char const   )'T',      (char const   )'I',      (char const   )'O',      (char const   )'N', 
        (char const   )'_',      (char const   )'T',      (char const   )'A',      (char const   )'B', 
        (char const   )'L',      (char const   )'E',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\000'};
#line 148 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   nofound_msg_option_checksum[81]  = 
#line 148
  {      (char const   )'%',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'I',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
        (char const   )' ',      (char const   )'A',      (char const   )'p',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )'l',      (char const   )'y',      (char const   )',', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'v',      (char const   )'1',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\000'};
#line 160 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static lbtable_choice_t const   lbtable_choices[14]  = 
#line 160
  {      {(uint32_t )1, "memory", memory_desc, generic_nofound_msg, & memory_print_fn}, 
        {(uint32_t )3,
      "mainboard", mainboard_desc, generic_nofound_msg, & mainboard_print_fn}, 
        {(uint32_t )4, "version", version_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )5,
      "extra_version", extra_version_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )6,
      "build", build_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )7, "compile_time", compile_time_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )8,
      "compile_by", compile_by_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )9, "compile_host", compile_host_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )10,
      "compile_domain", compile_domain_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )11,
      "compiler", compiler_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )12, "linker", linker_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )13,
      "assembler", assembler_desc, generic_nofound_msg, & string_print_fn}, 
        {(uint32_t )200, "cmos_opt_table", cmos_opt_table_desc, nofound_msg_cmos_opt_table,
      & cmos_opt_table_print_fn}, 
        {(uint32_t )204, "option_checksum", option_checksum_desc, nofound_msg_option_checksum,
      & option_checksum_print_fn}};
#line 226 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static mem_range_t const   mem_ranges[2]  = {      {0UL, 4095UL}, 
        {983040UL, 1048575UL}};
#line 237 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static unsigned long const   BYTES_TO_MAP  =    (size_t const   )1048576;
#line 242 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void const   *low_phys_mem  ;
#line 245 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_header  const  *lbtable  =    (struct lb_header  const  *)((void *)0);
#line 250 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct cmos_option_table  const  *cmos_table  =    (struct cmos_option_table  const  *)((void *)0);
#line 252 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct __anonstruct_hexdump_format_t_18  const  format  = 
#line 252
     {12, 4, "            ", " | ", " ", " | ", (unsigned char )'.', (int (*)(unsigned char c ))((void *)0)};
#line 282 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
void get_lbtable(void) 
{ 
  int fd ;
  int i ;
  int bad_header_count ;
  int bad_table_count ;
  int bad_headers ;
  int bad_tables ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 285
  if ((unsigned long )lbtable != (unsigned long )((void *)0)) {
#line 286
    return;
  }
  {
#line 292
  fd = open("/dev/mem", 0, 0);
  }
#line 292
  if (fd < 0) {
    {
#line 293
    tmp = __errno_location();
#line 293
    tmp___0 = strerror(*tmp);
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open /dev/mem for reading: %s\n",
            prog_name, tmp___0);
#line 295
    exit(1);
    }
  }
  {
#line 298
  tmp___3 = mmap((void *)0, (size_t )BYTES_TO_MAP, 1, 1, fd, (__off_t )0);
#line 298
  low_phys_mem = (void const   *)tmp___3;
  }
#line 298
  if ((unsigned long )low_phys_mem == (unsigned long )((void *)-1)) {
    {
#line 300
    tmp___1 = __errno_location();
#line 300
    tmp___2 = strerror(*tmp___1);
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Failed to mmap /dev/mem: %s\n",
            prog_name, tmp___2);
#line 302
    exit(1);
    }
  }
#line 305
  bad_header_count = 0;
#line 306
  bad_table_count = 0;
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 2)) {
#line 308
      goto while_break;
    }
    {
#line 309
    lbtable = lbtable_scan((unsigned long )low_phys_mem + (unsigned long )mem_ranges[i].start,
                           (unsigned long )low_phys_mem + (unsigned long )mem_ranges[i].end,
                           & bad_headers, & bad_tables);
    }
#line 313
    if ((unsigned long )lbtable != (unsigned long )((void *)0)) {
#line 314
      return;
    }
#line 316
    bad_header_count += bad_headers;
#line 317
    bad_table_count += bad_tables;
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: coreboot table not found.  coreboot does not appear to\n        be installed on this system.  Scanning for the table produced the\n        following results:\n\n            %d valid signatures were found with bad header checksums.\n            %d valid headers were found with bad table checksums.\n",
          prog_name, bad_header_count, bad_table_count);
#line 330
  exit(1);
  }
}
}
#line 339 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
void get_layout_from_cmos_table(void) 
{ 
  struct lb_record  const  *tmp ;

  {
  {
#line 342
  get_lbtable();
#line 343
  tmp = find_lbrec((uint32_t )200);
#line 343
  cmos_table = (struct cmos_option_table  const  *)tmp;
  }
#line 346
  if ((unsigned long )cmos_table == (unsigned long )((void *)0)) {
    {
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS option table not found in coreboot table.  Apparently, the coreboot installed on this system was built without specifying HAVE_OPTION_TABLE.\n",
            prog_name);
#line 352
    exit(1);
    }
  }
  {
#line 355
  process_cmos_table();
#line 356
  get_cmos_checksum_info();
  }
#line 357
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
void dump_lbtable(void) 
{ 
  char const   *p ;
  char const   *data ;
  uint32_t bytes_processed ;
  struct lb_record  const  *lbrec ;
  char const   *tmp ;

  {
  {
#line 369
  p = (char const   *)lbtable + lbtable->header_bytes;
#line 370
  printf((char const   */* __restrict  */)"Coreboot table at physical address 0x%lx:\n    signature:       0x%x (ASCII: %c%c%c%c)\n    header_bytes:    0x%x (decimal: %d)\n    header_checksum: 0x%x (decimal: %d)\n    table_bytes:     0x%x (decimal: %d)\n    table_checksum:  0x%x (decimal: %d)\n    table_entries:   0x%x (decimal: %d)\n\n",
         (unsigned long )lbtable - (unsigned long )low_phys_mem, *((uint32_t *)(lbtable->signature)),
         (int )lbtable->signature[0], (int )lbtable->signature[1], (int )lbtable->signature[2],
         (int )lbtable->signature[3], lbtable->header_bytes, lbtable->header_bytes,
         lbtable->header_checksum, lbtable->header_checksum, lbtable->table_bytes,
         lbtable->table_bytes, lbtable->table_checksum, lbtable->table_checksum, lbtable->table_entries,
         lbtable->table_entries);
  }
#line 385
  if ((lbtable->table_bytes == 0U) != (lbtable->table_entries == 0U)) {
    {
#line 386
    printf((char const   */* __restrict  */)"Inconsistent values for table_bytes and table_entries!!!\nThey should be either both 0 or both nonzero.\n");
    }
#line 388
    return;
  }
#line 391
  if (lbtable->table_bytes == 0U) {
    {
#line 392
    printf((char const   */* __restrict  */)"The coreboot table is empty!!!\n");
    }
#line 393
    return;
  }
#line 396
  bytes_processed = (uint32_t )0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 397
    lbrec = (struct lb_record  const  *)(p + bytes_processed);
#line 398
    tmp = lbrec_tag_to_str((uint32_t )lbrec->tag);
#line 398
    printf((char const   */* __restrict  */)"    %s record at physical address 0x%lx:\n        tag:  0x%x (decimal: %d)\n        size: 0x%x (decimal: %d)\n        data:\n",
           tmp, (unsigned long )lbrec - (unsigned long )low_phys_mem, lbrec->tag,
           lbrec->tag, lbrec->size, lbrec->size);
#line 405
    data = (char const   *)lbrec + sizeof(*lbrec);
#line 406
    hexdump((void const   *)data, (int )((unsigned long )lbrec->size - sizeof(*lbrec)),
            (unsigned long )data - (unsigned long )low_phys_mem, stdout, & format);
#line 409
    bytes_processed += (uint32_t )lbrec->size;
    }
#line 411
    if (bytes_processed >= (uint32_t )lbtable->table_bytes) {
#line 412
      goto while_break;
    }
    {
#line 414
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
void list_lbtable_choices(void) 
{ 
  int i ;

  {
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 428
    printf((char const   */* __restrict  */)"%s:\n%s", lbtable_choices[i].name, lbtable_choices[i].description);
#line 431
    i ++;
    }
#line 431
    if (i >= 14) {
#line 432
      goto while_break;
    }
    {
#line 434
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 443 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
void list_lbtable_item(char const   *item ) 
{ 
  int i ;
  struct lb_record  const  *rec ;
  int tmp ;

  {
#line 447
  i = 0;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (i < 14)) {
#line 447
      goto while_break;
    }
    {
#line 448
    tmp = strcmp(item, (char const   *)lbtable_choices[i].name);
    }
#line 448
    if (tmp == 0) {
#line 449
      goto while_break;
    }
#line 447
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  if (i == 14) {
    {
#line 453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Invalid coreboot table item %s.\n",
            prog_name, item);
#line 455
    exit(1);
    }
  }
  {
#line 458
  rec = find_lbrec((uint32_t )lbtable_choices[i].tag);
  }
#line 458
  if ((unsigned long )rec == (unsigned long )((void *)0)) {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)lbtable_choices[i].nofound_msg,
            prog_name, lbtable_choices[i].name);
#line 461
    exit(1);
    }
  }
  {
#line 464
  (*(lbtable_choices[i].print_fn))(rec);
  }
#line 465
  return;
}
}
#line 495 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   signature[4]  = {      (char const   )'L',      (char const   )'B',      (char const   )'I',      (char const   )'O'};
#line 491 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_header  const  *lbtable_scan(unsigned long start , unsigned long end ,
                                              int *bad_header_count , int *bad_table_count ) 
{ 
  struct lb_header  const  *table ;
  uint32_t const   *p ;
  uint32_t sig ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 500
  if (! (end >= start)) {
    {
#line 500
    __assert_fail("end >= start", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c",
                  500U, "lbtable_scan");
    }
  }
#line 501
  sig = (uint32_t )*((uint32_t const   *)(signature));
#line 502
  table = (struct lb_header  const  *)((void *)0);
#line 503
  *bad_header_count = 0;
#line 504
  *bad_table_count = 0;
#line 512
  p = (uint32_t const   *)start;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if ((unsigned long )p <= end) {
#line 512
      if (! (end - (unsigned long )p >= sizeof(uint32_t ) - 1UL)) {
#line 512
        goto while_break;
      }
    } else {
#line 512
      goto while_break;
    }
#line 516
    if (*p != (uint32_t const   )sig) {
#line 517
      goto __Cont;
    }
    {
#line 520
    table = (struct lb_header  const  *)p;
#line 523
    tmp = compute_ip_checksum((void *)table, sizeof(*table));
    }
#line 523
    if (tmp) {
#line 524
      (*bad_header_count) ++;
#line 525
      goto __Cont;
    }
    {
#line 529
    tmp___0 = compute_ip_checksum((void *)((char *)table + sizeof(*table)), (unsigned long )table->table_bytes);
    }
#line 529
    if ((unsigned long )table->table_checksum != tmp___0) {
#line 532
      (*bad_table_count) ++;
#line 533
      goto __Cont;
    }
#line 537
    return (table);
    __Cont: /* CIL Label */ 
#line 512
    p += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  return ((struct lb_header  const  *)((void *)0));
}
}
#line 549 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void process_cmos_table(void) 
{ 
  struct cmos_enums  const  *p ;
  struct cmos_entries  const  *q ;
  cmos_enum_t cmos_enum ;
  cmos_entry_t cmos_entry ;

  {
  {
#line 556
  p = first_cmos_table_enum();
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 556
      goto while_break;
    }
    {
#line 557
    cmos_enum.config_id = (unsigned int )p->config_id;
#line 558
    cmos_enum.value = (unsigned long long )p->value;
#line 559
    strncpy((char */* __restrict  */)(cmos_enum.text), (char const   */* __restrict  */)((char *)(p->text)),
            (size_t )32);
#line 560
    cmos_enum.text[32] = (char )'\000';
#line 561
    try_add_cmos_table_enum(& cmos_enum);
#line 556
    p = next_cmos_table_enum(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 567
  q = first_cmos_table_entry();
  }
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 567
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 567
      goto while_break___0;
    }
#line 568
    cmos_entry.bit = (unsigned int )q->bit;
#line 569
    cmos_entry.length = (unsigned int )q->length;
    {
#line 572
    if (q->config == 101U) {
#line 572
      goto case_101;
    }
#line 576
    if (q->config == 104U) {
#line 576
      goto case_104;
    }
#line 580
    if (q->config == 114U) {
#line 580
      goto case_114;
    }
#line 584
    if (q->config == 115U) {
#line 584
      goto case_115;
    }
#line 588
    goto switch_default;
    case_101: /* CIL Label */ 
#line 573
    cmos_entry.config = (cmos_entry_config_t )0;
#line 574
    goto switch_break;
    case_104: /* CIL Label */ 
#line 577
    cmos_entry.config = (cmos_entry_config_t )1;
#line 578
    goto switch_break;
    case_114: /* CIL Label */ 
#line 581
    cmos_entry.config = (cmos_entry_config_t )3;
#line 582
    goto switch_break;
    case_115: /* CIL Label */ 
#line 585
    cmos_entry.config = (cmos_entry_config_t )2;
#line 586
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 589
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Entry in CMOS option table has unknown config value.\n",
            prog_name);
#line 592
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 595
    cmos_entry.config_id = (unsigned int )q->config_id;
#line 596
    strncpy((char */* __restrict  */)(cmos_entry.name), (char const   */* __restrict  */)((char *)(q->name)),
            (size_t )32);
#line 597
    cmos_entry.name[32] = (char )'\000';
#line 598
    try_add_cmos_table_entry(& cmos_entry);
#line 567
    q = next_cmos_table_entry(q);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 600
  return;
}
}
#line 607 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void get_cmos_checksum_info(void) 
{ 
  cmos_entry_t const   *e ;
  struct cmos_checksum *checksum ;
  cmos_checksum_layout_t layout ;
  unsigned int index___0 ;
  unsigned int index2 ;
  struct lb_record  const  *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 613
  tmp = find_lbrec((uint32_t )204);
#line 613
  checksum = (struct cmos_checksum *)tmp;
  }
#line 615
  if ((unsigned long )checksum != (unsigned long )((void *)0)) {
    {
#line 619
    layout.summed_area_start = checksum->range_start;
#line 620
    layout.summed_area_end = checksum->range_end;
#line 621
    layout.checksum_at = checksum->location;
#line 622
    try_convert_checksum_layout(& layout);
#line 623
    cmos_checksum_start = layout.summed_area_start;
#line 624
    cmos_checksum_end = layout.summed_area_end;
#line 625
    cmos_checksum_index = layout.checksum_at;
    }
#line 626
    return;
  }
  {
#line 629
  e = find_cmos_entry(checksum_param_name);
  }
#line 629
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 630
    return;
  }
#line 638
  if (e->bit % 8U) {
    {
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS checksum is not byte-aligned.\n",
            prog_name);
#line 641
    exit(1);
    }
  }
  {
#line 644
  index___0 = (unsigned int )(e->bit / 8U);
#line 645
  index2 = index___0 + 1U;
#line 647
  tmp___0 = verify_cmos_byte_index(index___0);
  }
#line 647
  if (tmp___0) {
    {
#line 648
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS checksum location out of range.\n",
            prog_name);
#line 650
    exit(1);
    }
  } else {
    {
#line 647
    tmp___1 = verify_cmos_byte_index(index2);
    }
#line 647
    if (tmp___1) {
      {
#line 648
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS checksum location out of range.\n",
              prog_name);
#line 650
      exit(1);
      }
    }
  }
#line 653
  if (index___0 >= cmos_checksum_start) {
#line 653
    if (index___0 <= cmos_checksum_end) {
      {
#line 655
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS checksum overlaps checksummed area.\n",
              prog_name);
#line 657
      exit(1);
      }
    } else {
#line 653
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 653
  if (index2 >= cmos_checksum_start) {
#line 653
    if (index2 <= cmos_checksum_end) {
      {
#line 655
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: CMOS checksum overlaps checksummed area.\n",
              prog_name);
#line 657
      exit(1);
      }
    }
  }
#line 660
  cmos_checksum_index = index___0;
#line 661
  return;
}
}
#line 670 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void try_convert_checksum_layout(cmos_checksum_layout_t *layout ) 
{ 
  int tmp ;

  {
  {
#line 671
  tmp = checksum_layout_to_bytes(layout);
  }
  {
#line 672
  if (tmp == 0) {
#line 672
    goto case_0;
  }
#line 675
  if (tmp == 131075) {
#line 675
    goto case_131075;
  }
#line 681
  if (tmp == 131076) {
#line 681
    goto case_131076;
  }
#line 687
  if (tmp == 131077) {
#line 687
    goto case_131077;
  }
#line 693
  if (tmp == 131078) {
#line 693
    goto case_131078;
  }
#line 700
  if (tmp == 131079) {
#line 700
    goto case_131079;
  }
#line 706
  if (tmp == 131080) {
#line 706
    goto case_131080;
  }
#line 712
  if (tmp == 131081) {
#line 712
    goto case_131081;
  }
#line 718
  goto switch_default;
  case_0: /* CIL Label */ 
#line 673
  return;
  case_131075: /* CIL Label */ 
  {
#line 676
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksummed area start is not byte-aligned.\n",
          prog_name);
  }
#line 679
  goto switch_break;
  case_131076: /* CIL Label */ 
  {
#line 682
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksummed area end is not byte-aligned.\n",
          prog_name);
  }
#line 685
  goto switch_break;
  case_131077: /* CIL Label */ 
  {
#line 688
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksum location is not byte-aligned.\n",
          prog_name);
  }
#line 691
  goto switch_break;
  case_131078: /* CIL Label */ 
  {
#line 694
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksummed area end must be greater than CMOS checksummed area start.\n",
          prog_name);
  }
#line 698
  goto switch_break;
  case_131079: /* CIL Label */ 
  {
#line 701
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksum overlaps checksummed area.\n",
          prog_name);
  }
#line 704
  goto switch_break;
  case_131080: /* CIL Label */ 
  {
#line 707
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksummed area out of range.\n",
          prog_name);
  }
#line 710
  goto switch_break;
  case_131081: /* CIL Label */ 
  {
#line 713
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS checksum location out of range.\n",
          prog_name);
  }
#line 716
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 719
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c", 719U,
                "try_convert_checksum_layout");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 722
  exit(1);
  }
}
}
#line 731 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void try_add_cmos_table_enum(cmos_enum_t *cmos_enum ) 
{ 
  int tmp ;

  {
  {
#line 732
  tmp = add_cmos_enum((cmos_enum_t const   *)cmos_enum);
  }
  {
#line 733
  if (tmp == 0) {
#line 733
    goto case_0;
  }
#line 736
  if (tmp == 131074) {
#line 736
    goto case_131074;
  }
#line 741
  goto switch_default;
  case_0: /* CIL Label */ 
#line 734
  return;
  case_131074: /* CIL Label */ 
  {
#line 737
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Duplicate enum %s found in CMOS option table.\n",
          prog_name, cmos_enum->text);
  }
#line 739
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 742
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c", 742U,
                "try_add_cmos_table_enum");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 745
  exit(1);
  }
}
}
#line 754 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void try_add_cmos_table_entry(cmos_entry_t *cmos_entry ) 
{ 
  cmos_entry_t const   *conflict ;
  int tmp ;

  {
  {
#line 757
  tmp = add_cmos_entry((cmos_entry_t const   *)cmos_entry, & conflict);
  }
  {
#line 758
  if (tmp == 0) {
#line 758
    goto case_0;
  }
#line 761
  if (tmp == 196608) {
#line 761
    goto case_196608;
  }
#line 767
  if (tmp == 196610) {
#line 767
    goto case_196610;
  }
#line 773
  if (tmp == 131072) {
#line 773
    goto case_131072;
  }
#line 779
  if (tmp == 131073) {
#line 779
    goto case_131073;
  }
#line 786
  goto switch_default;
  case_0: /* CIL Label */ 
#line 759
  return;
  case_196608: /* CIL Label */ 
  {
#line 762
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Bad CMOS option layout in CMOS option table entry %s.\n",
          prog_name, cmos_entry->name);
  }
#line 765
  goto switch_break;
  case_196610: /* CIL Label */ 
  {
#line 768
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Area too wide for CMOS option table entry %s.\n",
          prog_name, cmos_entry->name);
  }
#line 771
  goto switch_break;
  case_131072: /* CIL Label */ 
  {
#line 774
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS option table entries %s and %s have overlapping layouts.\n",
          prog_name, cmos_entry->name, conflict->name);
  }
#line 777
  goto switch_break;
  case_131073: /* CIL Label */ 
#line 784
  return;
  switch_default: /* CIL Label */ 
  {
#line 787
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c", 787U,
                "try_add_cmos_table_entry");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 790
  exit(1);
  }
}
}
#line 799 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_record  const  *find_lbrec(uint32_t tag ) 
{ 
  char const   *p ;
  uint32_t bytes_processed ;
  struct lb_record  const  *lbrec ;

  {
#line 804
  p = (char const   *)lbtable + lbtable->header_bytes;
#line 806
  bytes_processed = (uint32_t )0;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (bytes_processed < (uint32_t )lbtable->table_bytes)) {
#line 806
      goto while_break;
    }
#line 809
    lbrec = (struct lb_record  const  *)(p + bytes_processed);
#line 811
    if (lbrec->tag == (uint32_t const   )tag) {
#line 812
      return (lbrec);
    }
#line 806
    bytes_processed += (uint32_t )lbrec->size;
  }
  while_break: /* CIL Label */ ;
  }
#line 815
  return ((struct lb_record  const  *)((void *)0));
}
}
#line 824 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static char const   *lbrec_tag_to_str(uint32_t tag ) 
{ 


  {
  {
#line 826
  if (tag == 0U) {
#line 826
    goto case_0;
  }
#line 829
  if (tag == 1U) {
#line 829
    goto case_1;
  }
#line 832
  if (tag == 2U) {
#line 832
    goto case_2;
  }
#line 835
  if (tag == 3U) {
#line 835
    goto case_3;
  }
#line 838
  if (tag == 4U) {
#line 838
    goto case_4;
  }
#line 841
  if (tag == 5U) {
#line 841
    goto case_5;
  }
#line 844
  if (tag == 6U) {
#line 844
    goto case_6;
  }
#line 847
  if (tag == 7U) {
#line 847
    goto case_7;
  }
#line 850
  if (tag == 8U) {
#line 850
    goto case_8;
  }
#line 853
  if (tag == 9U) {
#line 853
    goto case_9;
  }
#line 856
  if (tag == 10U) {
#line 856
    goto case_10;
  }
#line 859
  if (tag == 11U) {
#line 859
    goto case_11;
  }
#line 862
  if (tag == 12U) {
#line 862
    goto case_12;
  }
#line 865
  if (tag == 13U) {
#line 865
    goto case_13;
  }
#line 868
  if (tag == 200U) {
#line 868
    goto case_200;
  }
#line 871
  if (tag == 204U) {
#line 871
    goto case_204;
  }
#line 874
  goto switch_default;
  case_0: /* CIL Label */ 
#line 827
  return ("UNUSED");
  case_1: /* CIL Label */ 
#line 830
  return ("MEMORY");
  case_2: /* CIL Label */ 
#line 833
  return ("HWRPB");
  case_3: /* CIL Label */ 
#line 836
  return ("MAINBOARD");
  case_4: /* CIL Label */ 
#line 839
  return ("VERSION");
  case_5: /* CIL Label */ 
#line 842
  return ("EXTRA_VERSION");
  case_6: /* CIL Label */ 
#line 845
  return ("BUILD");
  case_7: /* CIL Label */ 
#line 848
  return ("COMPILE_TIME");
  case_8: /* CIL Label */ 
#line 851
  return ("COMPILE_BY");
  case_9: /* CIL Label */ 
#line 854
  return ("COMPILE_HOST");
  case_10: /* CIL Label */ 
#line 857
  return ("COMPILE_DOMAIN");
  case_11: /* CIL Label */ 
#line 860
  return ("COMPILER");
  case_12: /* CIL Label */ 
#line 863
  return ("LINKER");
  case_13: /* CIL Label */ 
#line 866
  return ("ASSEMBLER");
  case_200: /* CIL Label */ 
#line 869
  return ("CMOS_OPTION_TABLE");
  case_204: /* CIL Label */ 
#line 872
  return ("OPTION_CHECKSUM");
  switch_default: /* CIL Label */ 
#line 875
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 878
  return ("UNKNOWN");
}
}
#line 887 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct cmos_entries  const  *first_cmos_table_entry(void) 
{ 
  struct lb_record  const  *tmp ;

  {
  {
#line 888
  tmp = first_cmos_rec((uint32_t )201);
  }
#line 888
  return ((struct cmos_entries  const  *)tmp);
}
}
#line 896 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct cmos_entries  const  *next_cmos_table_entry(struct cmos_entries  const  *last ) 
{ 
  struct lb_record  const  *tmp ;

  {
  {
#line 898
  tmp = next_cmos_rec((struct lb_record  const  *)last, (uint32_t )201);
  }
#line 898
  return ((struct cmos_entries  const  *)tmp);
}
}
#line 909 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct cmos_enums  const  *first_cmos_table_enum(void) 
{ 
  struct lb_record  const  *tmp ;

  {
  {
#line 910
  tmp = first_cmos_rec((uint32_t )202);
  }
#line 910
  return ((struct cmos_enums  const  *)tmp);
}
}
#line 919 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct cmos_enums  const  *next_cmos_table_enum(struct cmos_enums  const  *last ) 
{ 
  struct lb_record  const  *tmp ;

  {
  {
#line 921
  tmp = next_cmos_rec((struct lb_record  const  *)last, (uint32_t )202);
  }
#line 921
  return ((struct cmos_enums  const  *)tmp);
}
}
#line 941 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_record  const  *first_cmos_rec(uint32_t tag ) 
{ 
  char const   *p ;
  uint32_t bytes_processed ;
  uint32_t bytes_for_entries ;
  struct lb_record  const  *lbrec ;

  {
#line 946
  p = (char const   *)cmos_table + cmos_table->header_length;
#line 947
  bytes_for_entries = (uint32_t )(cmos_table->size - cmos_table->header_length);
#line 949
  bytes_processed = (uint32_t )0;
  {
#line 949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 949
    if (! (bytes_processed < bytes_for_entries)) {
#line 949
      goto while_break;
    }
#line 952
    lbrec = (struct lb_record  const  *)(p + bytes_processed);
#line 954
    if (lbrec->tag == (uint32_t const   )tag) {
#line 955
      return (lbrec);
    }
#line 949
    bytes_processed += (uint32_t )lbrec->size;
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  return ((struct lb_record  const  *)((void *)0));
}
}
#line 968 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static struct lb_record  const  *next_cmos_rec(struct lb_record  const  *last , uint32_t tag ) 
{ 
  char const   *p ;
  uint32_t bytes_processed ;
  uint32_t bytes_for_entries ;
  uint32_t last_offset ;
  struct lb_record  const  *lbrec ;

  {
#line 974
  p = (char const   *)cmos_table + cmos_table->header_length;
#line 975
  bytes_for_entries = (uint32_t )(cmos_table->size - cmos_table->header_length);
#line 976
  last_offset = (uint32_t )((char const   *)last - p);
#line 978
  bytes_processed = last_offset + (uint32_t )last->size;
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 978
    if (! (bytes_processed < bytes_for_entries)) {
#line 978
      goto while_break;
    }
#line 981
    lbrec = (struct lb_record  const  *)(p + bytes_processed);
#line 983
    if (lbrec->tag == (uint32_t const   )tag) {
#line 984
      return (lbrec);
    }
#line 978
    bytes_processed += (uint32_t )lbrec->size;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  return ((struct lb_record  const  *)((void *)0));
}
}
#line 995 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void memory_print_fn(struct lb_record  const  *rec ) 
{ 
  char start_str[19] ;
  char end_str[19] ;
  char size_str[19] ;
  struct lb_memory  const  *p ;
  char const   *mem_type ;
  struct lb_memory_range  const  *ranges ;
  uint64_t size ;
  uint64_t start ;
  uint64_t end ;
  int i ;
  int entries ;

  {
#line 1003
  p = (struct lb_memory  const  *)rec;
#line 1004
  entries = (int )(((unsigned long )p->size - sizeof(*p)) / sizeof(p->map[0]));
#line 1005
  ranges = (struct lb_memory_range  const  *)(p->map);
#line 1007
  if (entries == 0) {
    {
#line 1008
    printf((char const   */* __restrict  */)"No memory ranges were found.\n");
    }
#line 1009
    return;
  }
#line 1012
  i = 0;
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1014
    if ((ranges + i)->type == 1U) {
#line 1014
      goto case_1;
    }
#line 1018
    if ((ranges + i)->type == 2U) {
#line 1018
      goto case_2;
    }
#line 1022
    if ((ranges + i)->type == 16U) {
#line 1022
      goto case_16;
    }
#line 1026
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1015
    mem_type = "AVAILABLE";
#line 1016
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1019
    mem_type = "RESERVED";
#line 1020
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1023
    mem_type = "CONFIG_TABLE";
#line 1024
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1027
    mem_type = "UNKNOWN";
#line 1028
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1031
    size = unpack_lb64((struct lb_uint64 )(ranges + i)->size);
#line 1032
    start = unpack_lb64((struct lb_uint64 )(ranges + i)->start);
#line 1033
    end = (start + size) - 1UL;
#line 1034
    uint64_to_hex_string(start_str, start);
#line 1035
    uint64_to_hex_string(end_str, end);
#line 1036
    uint64_to_hex_string(size_str, size);
#line 1037
    printf((char const   */* __restrict  */)"%s memory:\n    from physical addresses %s to %s\n    size is %s bytes (%lld in decimal)\n",
           mem_type, start_str, end_str, size_str, (unsigned long long )size);
#line 1043
    i ++;
    }
#line 1043
    if (i >= entries) {
#line 1044
      goto while_break;
    }
    {
#line 1046
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1048
  return;
}
}
#line 1055 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void mainboard_print_fn(struct lb_record  const  *rec ) 
{ 
  struct lb_mainboard  const  *p ;

  {
  {
#line 1058
  p = (struct lb_mainboard  const  *)rec;
#line 1059
  printf((char const   */* __restrict  */)"Vendor:      %s\nPart number: %s\n", & p->strings[p->vendor_idx],
         & p->strings[p->part_number_idx]);
  }
#line 1063
  return;
}
}
#line 1070 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void cmos_opt_table_print_fn(struct lb_record  const  *rec ) 
{ 
  struct cmos_option_table  const  *p ;
  struct lb_record  const  *cmos_item ;
  uint32_t bytes_processed ;
  uint32_t bytes_for_entries ;
  char const   *q ;

  {
  {
#line 1077
  p = (struct cmos_option_table  const  *)rec;
#line 1078
  q = (char const   *)p + p->header_length;
#line 1079
  bytes_for_entries = (uint32_t )(p->size - p->header_length);
#line 1081
  printf((char const   */* __restrict  */)"CMOS option table at physical address 0x%lx:\n    tag:           0x%x (decimal: %d)\n    size:          0x%x (decimal: %d)\n    header_length: 0x%x (decimal: %d)\n\n",
         (unsigned long )p - (unsigned long )low_phys_mem, p->tag, p->tag, p->size,
         p->size, p->header_length, p->header_length);
  }
#line 1088
  if (p->header_length > p->size) {
    {
#line 1089
    printf((char const   */* __restrict  */)"Header length for CMOS option table is greater than the size of the entire table including header!!!\n");
    }
#line 1091
    return;
  }
#line 1094
  if (bytes_for_entries == 0U) {
    {
#line 1095
    printf((char const   */* __restrict  */)"The CMOS option table is empty!!!\n");
    }
#line 1096
    return;
  }
#line 1099
  bytes_processed = (uint32_t )0;
  {
#line 1099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    cmos_item = (struct lb_record  const  *)(q + bytes_processed);
    {
#line 1103
    if (cmos_item->tag == 201U) {
#line 1103
      goto case_201;
    }
#line 1107
    if (cmos_item->tag == 202U) {
#line 1107
      goto case_202;
    }
#line 1111
    if (cmos_item->tag == 203U) {
#line 1111
      goto case_203;
    }
#line 1115
    goto switch_default;
    case_201: /* CIL Label */ 
    {
#line 1104
    print_option_record((struct cmos_entries  const  *)cmos_item);
    }
#line 1105
    goto switch_break;
    case_202: /* CIL Label */ 
    {
#line 1108
    print_enum_record((struct cmos_enums  const  *)cmos_item);
    }
#line 1109
    goto switch_break;
    case_203: /* CIL Label */ 
    {
#line 1112
    print_defaults_record((struct cmos_defaults  const  *)cmos_item);
    }
#line 1113
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1116
    print_unknown_record(cmos_item);
    }
#line 1117
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1120
    bytes_processed += (uint32_t )cmos_item->size;
#line 1122
    if (bytes_processed >= bytes_for_entries) {
#line 1123
      goto while_break;
    }
    {
#line 1125
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  return;
}
}
#line 1135 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static unsigned long const   S_BUFSIZE  =    (size_t const   )80;
#line 1134 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void print_option_record(struct cmos_entries  const  *cmos_entry ) 
{ 
  char *s ;
  unsigned long __lengthofs ;
  void *tmp ;

  {
  {
#line 1136
  __lengthofs = (unsigned long )S_BUFSIZE;
#line 1136
  tmp = __builtin_alloca(sizeof(*s) * __lengthofs);
#line 1136
  s = (char *)tmp;
  }
  {
#line 1139
  if (cmos_entry->config == 101U) {
#line 1139
    goto case_101;
  }
#line 1143
  if (cmos_entry->config == 104U) {
#line 1143
    goto case_104;
  }
#line 1147
  if (cmos_entry->config == 114U) {
#line 1147
    goto case_114;
  }
#line 1151
  goto switch_default;
  case_101: /* CIL Label */ 
  {
#line 1140
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"ENUM");
  }
#line 1141
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 1144
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"HEX");
  }
#line 1145
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 1148
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"RESERVED");
  }
#line 1149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1152
  snprintf((char */* __restrict  */)s, (size_t )S_BUFSIZE, (char const   */* __restrict  */)"UNKNOWN: value is 0x%x (decimal: %d)",
           cmos_entry->config, cmos_entry->config);
  }
#line 1154
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1157
  printf((char const   */* __restrict  */)"    OPTION record at physical address 0x%lx:\n        tag:       0x%x (decimal: %d)\n        size:      0x%x (decimal: %d)\n        bit:       0x%x (decimal: %d)\n        length:    0x%x (decimal: %d)\n        config:    %s\n        config_id: 0x%x (decimal: %d)\n        name:      %s\n",
         (unsigned long )cmos_entry - (unsigned long )low_phys_mem, cmos_entry->tag,
         cmos_entry->tag, cmos_entry->size, cmos_entry->size, cmos_entry->bit, cmos_entry->bit,
         cmos_entry->length, cmos_entry->length, s, cmos_entry->config_id, cmos_entry->config_id,
         cmos_entry->name);
  }
#line 1169
  return;
}
}
#line 1176 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void print_enum_record(struct cmos_enums  const  *cmos_enum ) 
{ 


  {
  {
#line 1177
  printf((char const   */* __restrict  */)"    ENUM record at physical address 0x%lx:\n        tag:       0x%x (decimal: %d)\n        size:      0x%x (decimal: %d)\n        config_id: 0x%x (decimal: %d)\n        value:     0x%x (decimal: %d)\n        text:      %s\n",
         (unsigned long )cmos_enum - (unsigned long )low_phys_mem, cmos_enum->tag,
         cmos_enum->tag, cmos_enum->size, cmos_enum->size, cmos_enum->config_id, cmos_enum->config_id,
         cmos_enum->value, cmos_enum->value, cmos_enum->text);
  }
#line 1186
  return;
}
}
#line 1193 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void print_defaults_record(struct cmos_defaults  const  *cmos_defaults ) 
{ 


  {
  {
#line 1194
  printf((char const   */* __restrict  */)"    DEFAULTS record at physical address 0x%lx:\n        tag:         0x%x (decimal: %d)\n        size:        0x%x (decimal: %d)\n        name_length: 0x%x (decimal: %d)\n        name:        %s\n        default_set:\n",
         (unsigned long )cmos_defaults - (unsigned long )low_phys_mem, cmos_defaults->tag,
         cmos_defaults->tag, cmos_defaults->size, cmos_defaults->size, cmos_defaults->name_length,
         cmos_defaults->name_length, cmos_defaults->name);
#line 1204
  hexdump((void const   *)(cmos_defaults->default_set), 128, (unsigned long )(cmos_defaults->default_set) - (unsigned long )low_phys_mem,
          stdout, & format);
  }
#line 1206
  return;
}
}
#line 1213 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void print_unknown_record(struct lb_record  const  *cmos_item ) 
{ 
  char const   *data ;

  {
  {
#line 1216
  printf((char const   */* __restrict  */)"    UNKNOWN record at physical address 0x%lx:\n        tag:  0x%x (decimal: %d)\n        size: 0x%x (decimal: %d)\n        data:\n",
         (unsigned long )cmos_item - (unsigned long )low_phys_mem, cmos_item->tag,
         cmos_item->tag, cmos_item->size, cmos_item->size);
#line 1222
  data = (char const   *)cmos_item + sizeof(*cmos_item);
#line 1223
  hexdump((void const   *)data, (int )((unsigned long )cmos_item->size - sizeof(*cmos_item)),
          (unsigned long )data - (unsigned long )low_phys_mem, stdout, & format);
  }
#line 1225
  return;
}
}
#line 1232 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void option_checksum_print_fn(struct lb_record  const  *rec ) 
{ 
  struct cmos_checksum *p ;
  char const   *tmp ;

  {
#line 1235
  p = (struct cmos_checksum *)rec;
#line 1236
  if (p->type == 1U) {
#line 1236
    tmp = "PC BIOS";
  } else {
#line 1236
    tmp = "NONE";
  }
  {
#line 1236
  printf((char const   */* __restrict  */)"CMOS checksum from bit %d to bit %d\nat position %d is type %s.\n",
         p->range_start, p->range_end, p->location, tmp);
  }
#line 1240
  return;
}
}
#line 1248 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void string_print_fn(struct lb_record  const  *rec ) 
{ 
  struct lb_string  const  *p ;

  {
  {
#line 1251
  p = (struct lb_string  const  *)rec;
#line 1252
  printf((char const   */* __restrict  */)"%s\n", p->string);
  }
#line 1253
  return;
}
}
#line 1264 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c"
static void uint64_to_hex_string(char *str , uint64_t n ) 
{ 
  int chars_printed ;

  {
  {
#line 1267
  *(str + 0) = (char )'0';
#line 1268
  *(str + 1) = (char )'x';
#line 1272
  chars_printed = sprintf((char */* __restrict  */)(str + 2), (char const   */* __restrict  */)"%016llx",
                          (unsigned long long )n);
  }
#line 1273
  if (! (chars_printed == 16)) {
    {
#line 1273
    __assert_fail("chars_printed == 16", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/lbtable.c",
                  1273U, "uint64_to_hex_string");
    }
  }
#line 1274
  return;
}
}
#line 214 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 108 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
cmos_enum_t const   *first_cmos_enum_id(unsigned int config_id ) ;
#line 109
cmos_enum_t const   *next_cmos_enum_id(cmos_enum_t const   *last ) ;
#line 44 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.h"
int prepare_cmos_read(cmos_entry_t const   *e ) ;
#line 47
uint16_t cmos_checksum_read(void) ;
#line 50
void cmos_checksum_verify(void) ;
#line 43 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.h"
unsigned char cmos_read_byte(unsigned int index___0 ) ;
#line 44
void cmos_write_byte(unsigned int index___0 , unsigned char value ) ;
#line 48
int verify_cmos_op(unsigned int bit , unsigned int length , cmos_entry_config_t config ) ;
#line 35 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
static int prepare_cmos_op_common(cmos_entry_t const   *e ) ;
#line 42 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
static int prepare_cmos_op_common(cmos_entry_t const   *e ) 
{ 
  int result ;

  {
#line 45
  if ((unsigned int const   )e->config == 3U) {
#line 47
    return (262147);
  }
  {
#line 49
  result = verify_cmos_op((unsigned int )e->bit, (unsigned int )e->length, (cmos_entry_config_t )e->config);
  }
#line 49
  if (result != 0) {
#line 50
    return (result);
  }
#line 52
  if (! (e->length > 0U)) {
    {
#line 52
    __assert_fail("e->length > 0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c",
                  52U, "prepare_cmos_op_common");
    }
  }
#line 53
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
int prepare_cmos_read(cmos_entry_t const   *e ) 
{ 
  int result ;

  {
  {
#line 66
  result = prepare_cmos_op_common(e);
  }
#line 66
  if (result != 0) {
#line 67
    return (result);
  }
  {
#line 72
  if ((unsigned int const   )e->config == 2U) {
#line 72
    goto case_2;
  }
#line 72
  if ((unsigned int const   )e->config == 1U) {
#line 72
    goto case_2;
  }
#line 72
  if ((unsigned int const   )e->config == 0U) {
#line 72
    goto case_2;
  }
#line 75
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 73
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 76
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c",
                76U, "prepare_cmos_read");
  }
  switch_break: /* CIL Label */ ;
  }
#line 79
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
int prepare_cmos_write(cmos_entry_t const   *e , char const   *value_str , unsigned long long *value ) 
{ 
  cmos_enum_t const   *q ;
  unsigned long long out ;
  char const   *p ;
  char *memory ;
  int negative ;
  int result ;
  int found_one ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 98
  result = prepare_cmos_op_common(e);
  }
#line 98
  if (result != 0) {
#line 99
    return (result);
  }
  {
#line 102
  if ((unsigned int const   )e->config == 0U) {
#line 102
    goto case_0;
  }
#line 122
  if ((unsigned int const   )e->config == 1U) {
#line 122
    goto case_1;
  }
#line 143
  if ((unsigned int const   )e->config == 2U) {
#line 143
    goto case_2;
  }
#line 152
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 104
  q = first_cmos_enum_id((unsigned int )e->config_id);
#line 104
  found_one = 0;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 104
      goto while_break;
    }
    {
#line 107
    found_one = 1;
#line 109
    tmp = strncmp((char const   *)(q->text), value_str, (size_t )32);
    }
#line 109
    if (! tmp) {
#line 110
      goto while_break;
    }
    {
#line 104
    q = next_cmos_enum_id(q);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if (! found_one) {
#line 114
    return (262149);
  }
#line 116
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 117
    return (262144);
  }
#line 119
  out = (unsigned long long )q->value;
#line 120
  goto switch_break;
  case_1: /* CIL Label */ 
#line 126
  p = value_str;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp___0 = __ctype_b_loc();
    }
#line 126
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 126
      goto while_break___0;
    }
#line 126
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 127
  negative = (int const   )*p == 45;
#line 129
  out = strtoull((char const   */* __restrict  */)value_str, (char **/* __restrict  */)((char **)(& p)),
                 0);
  }
#line 131
  if (*p) {
#line 132
    return (262146);
  }
#line 138
  if (negative) {
#line 139
    return (262145);
  }
#line 141
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 144
  tmp___1 = strlen(value_str);
  }
#line 144
  if ((size_t )e->length < 8UL * tmp___1) {
#line 145
    return (262148);
  }
  {
#line 146
  tmp___2 = malloc((size_t )(e->length / 8U));
#line 146
  memory = (char *)tmp___2;
#line 147
  memset((void *)memory, 0, (size_t )(e->length / 8U));
#line 148
  strcpy((char */* __restrict  */)memory, (char const   */* __restrict  */)value_str);
#line 149
  out = (unsigned long long )((unsigned long )memory);
  }
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 153
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c",
                153U, "prepare_cmos_write");
  }
  switch_break: /* CIL Label */ ;
  }
#line 156
  if ((unsigned long )e->length < 8UL * sizeof(*value)) {
#line 156
    if (out >= 1ULL << e->length) {
#line 158
      return (262148);
    }
  }
#line 160
  *value = out;
#line 161
  return (0);
}
}
#line 170 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
uint16_t cmos_checksum_read(void) 
{ 
  uint16_t lo ;
  uint16_t hi ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 174
  tmp = cmos_read_byte(cmos_checksum_index);
#line 174
  hi = (uint16_t )tmp;
#line 175
  tmp___0 = cmos_read_byte(cmos_checksum_index + 1U);
#line 175
  lo = (uint16_t )tmp___0;
  }
#line 176
  return ((uint16_t )(((int )hi << 8) + (int )lo));
}
}
#line 185 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
void cmos_checksum_write(uint16_t checksum ) 
{ 
  unsigned char lo ;
  unsigned char hi ;

  {
  {
#line 189
  hi = (unsigned char )((int )checksum >> 8);
#line 190
  lo = (unsigned char )((int )checksum & 255);
#line 191
  cmos_write_byte(cmos_checksum_index, hi);
#line 192
  cmos_write_byte(cmos_checksum_index + 1U, lo);
  }
#line 193
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
uint16_t cmos_checksum_compute(void) 
{ 
  unsigned int i ;
  unsigned int sum ;
  unsigned char tmp ;

  {
#line 204
  sum = 0U;
#line 206
  i = cmos_checksum_start;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i <= cmos_checksum_end)) {
#line 206
      goto while_break;
    }
    {
#line 207
    tmp = cmos_read_byte(i);
#line 207
    sum += (unsigned int )tmp;
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return ((uint16_t )(~ ((int )((uint16_t )(sum & 65535U)))));
}
}
#line 218 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_ops.c"
void cmos_checksum_verify(void) 
{ 
  uint16_t computed ;
  uint16_t actual ;

  {
  {
#line 221
  set_iopl(3);
#line 222
  computed = cmos_checksum_compute();
#line 223
  actual = cmos_checksum_read();
#line 224
  set_iopl(0);
  }
#line 226
  if ((int )computed != (int )actual) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: Coreboot CMOS checksum is bad.\n",
            prog_name);
#line 229
    exit(1);
    }
  }
#line 231
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 65 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.h"
char const   prog_version[4] ;
#line 69
void usage(FILE *outfile ) ;
#line 77 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
nvramtool_op_info_t nvramtool_op ;
#line 79
nvramtool_op_modifier_info_t nvramtool_op_modifiers[3] ;
#line 81
void parse_nvramtool_args(int argc , char **argv ) ;
#line 97 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.h"
void register_cmos_layout_get_fn(void (*fn)(void) ) ;
#line 98
void get_cmos_layout(void) ;
#line 104
cmos_enum_t const   *find_cmos_enum(unsigned int config_id , unsigned long long value ) ;
#line 41 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.h"
unsigned long long cmos_read(cmos_entry_t const   *e ) ;
#line 45
void cmos_read_all(unsigned char *data ) ;
#line 46
void cmos_write_all(unsigned char *data ) ;
#line 44 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_version(void) ;
#line 45
static void op_show_usage(void) ;
#line 46
static void op_lbtable_show_info(void) ;
#line 47
static void op_lbtable_dump(void) ;
#line 48
static void op_show_param_values(void) ;
#line 49
static void op_cmos_show_one_param(void) ;
#line 50
static void op_cmos_show_all_params(void) ;
#line 51
static void op_cmos_set_one_param(void) ;
#line 52
static void op_cmos_set_params_stdin(void) ;
#line 53
static void op_cmos_set_params_file(void) ;
#line 54
static void op_cmos_checksum(void) ;
#line 55
static void op_show_layout(void) ;
#line 56
static void op_write_cmos_dump(void) ;
#line 57
static void op_read_cmos_dump(void) ;
#line 58
static void op_show_cmos_hex_dump(void) ;
#line 59
static void op_show_cmos_dumpfile(void) ;
#line 60
static int list_one_param(char const   *name , int show_name ) ;
#line 61
static int list_all_params(void) ;
#line 62
static void list_param_enums(char const   *name ) ;
#line 63
static void set_one_param(char const   *name , char const   *value ) ;
#line 64
static void set_params(FILE *f ) ;
#line 65
static void parse_assignment(char *arg , char const   **name , char const   **value ) ;
#line 67
static int list_cmos_entry(cmos_entry_t const   *e , int show_name ) ;
#line 68
static uint16_t convert_checksum_value(char const   *value ) ;
#line 70 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static op_fn_t const   op_fns[16]  = 
#line 70
  {      (op_fn_t const   )(& op_show_version),      (op_fn_t const   )(& op_show_usage),      (op_fn_t const   )(& op_lbtable_show_info),      (op_fn_t const   )(& op_lbtable_dump), 
        (op_fn_t const   )(& op_show_param_values),      (op_fn_t const   )(& op_cmos_show_one_param),      (op_fn_t const   )(& op_cmos_show_all_params),      (op_fn_t const   )(& op_cmos_set_one_param), 
        (op_fn_t const   )(& op_cmos_set_params_stdin),      (op_fn_t const   )(& op_cmos_set_params_file),      (op_fn_t const   )(& op_cmos_checksum),      (op_fn_t const   )(& op_show_layout), 
        (op_fn_t const   )(& op_write_cmos_dump),      (op_fn_t const   )(& op_read_cmos_dump),      (op_fn_t const   )(& op_show_cmos_hex_dump),      (op_fn_t const   )(& op_show_cmos_dumpfile)};
#line 89 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static struct __anonstruct_hexdump_format_t_18  const  cmos_dump_format  = 
#line 89
     {16, 2, "", " | ", " ", " | ", (unsigned char )'.', (int (*)(unsigned char c ))((void *)0)};
#line 95 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
int main(int argc , char **argv ) 
{ 
  void (*fn)(void) ;

  {
  {
#line 98
  parse_nvramtool_args(argc, argv);
  }
#line 100
  if (nvramtool_op_modifiers[1].found) {
    {
#line 101
    set_layout_filename((char const   *)nvramtool_op_modifiers[1].param);
#line 103
    fn = & get_layout_from_file;
    }
  } else {
#line 106
    fn = & get_layout_from_cmos_table;
  }
  {
#line 108
  register_cmos_layout_get_fn(fn);
#line 109
  (*(op_fns[nvramtool_op.op]))();
  }
#line 110
  return (0);
}
}
#line 120 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_version(void) 
{ 


  {
  {
#line 121
  printf((char const   */* __restrict  */)"This is %s version %s.\n", prog_name, prog_version);
  }
#line 121
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_usage(void) 
{ 


  {
  {
#line 131
  usage(stdout);
  }
#line 131
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_lbtable_show_info(void) 
{ 


  {
#line 142
  if ((unsigned long )nvramtool_op.param == (unsigned long )((void *)0)) {
    {
#line 143
    list_lbtable_choices();
    }
  } else {
    {
#line 145
    get_lbtable();
#line 146
    list_lbtable_item((char const   *)nvramtool_op.param);
    }
  }
#line 148
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_lbtable_dump(void) 
{ 


  {
  {
#line 158
  get_lbtable();
#line 159
  dump_lbtable();
  }
#line 160
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_param_values(void) 
{ 


  {
  {
#line 170
  get_cmos_layout();
#line 171
  list_param_enums((char const   *)nvramtool_op.param);
  }
#line 172
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_show_one_param(void) 
{ 
  int result ;

  {
  {
#line 185
  get_cmos_layout();
#line 186
  result = list_one_param((char const   *)nvramtool_op.param, ! nvramtool_op_modifiers[0].found);
#line 188
  cmos_checksum_verify();
  }
#line 190
  if (result) {
    {
#line 191
    exit(1);
    }
  }
#line 192
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_show_all_params(void) 
{ 
  int result ;

  {
  {
#line 204
  get_cmos_layout();
#line 205
  result = list_all_params();
#line 206
  cmos_checksum_verify();
  }
#line 208
  if (result) {
    {
#line 209
    exit(1);
    }
  }
#line 210
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_set_one_param(void) 
{ 
  char const   *name ;
  char const   *value ;

  {
  {
#line 222
  get_cmos_layout();
#line 227
  parse_assignment(nvramtool_op.param, & name, & value);
#line 229
  set_one_param(name, value);
  }
#line 230
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_set_params_stdin(void) 
{ 


  {
  {
#line 240
  get_cmos_layout();
#line 241
  set_params(stdin);
  }
#line 242
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_set_params_file(void) 
{ 
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 254
  f = fopen((char const   */* __restrict  */)nvramtool_op.param, (char const   */* __restrict  */)"r");
  }
#line 254
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 255
    tmp = __errno_location();
#line 255
    tmp___0 = strerror(*tmp);
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open file %s for reading: %s\n",
            prog_name, nvramtool_op.param, tmp___0);
#line 257
    exit(1);
    }
  }
  {
#line 260
  get_cmos_layout();
#line 261
  set_params(f);
#line 262
  fclose(f);
  }
#line 263
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_cmos_checksum(void) 
{ 
  uint16_t checksum ;

  {
  {
#line 276
  get_cmos_layout();
  }
#line 278
  if ((unsigned long )nvramtool_op.param == (unsigned long )((void *)0)) {
    {
#line 279
    set_iopl(3);
#line 280
    checksum = cmos_checksum_read();
#line 281
    set_iopl(0);
#line 282
    printf((char const   */* __restrict  */)"0x%x\n", (int )checksum);
    }
  } else {
    {
#line 285
    checksum = convert_checksum_value((char const   *)nvramtool_op.param);
#line 286
    set_iopl(3);
#line 287
    cmos_checksum_write(checksum);
#line 288
    set_iopl(0);
    }
  }
#line 290
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_layout(void) 
{ 


  {
  {
#line 300
  get_cmos_layout();
#line 301
  write_cmos_layout(stdout);
  }
#line 302
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_write_cmos_dump(void) 
{ 
  unsigned char data[256] ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 315
  f = fopen((char const   */* __restrict  */)nvramtool_op.param, (char const   */* __restrict  */)"w");
  }
#line 315
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 316
    tmp = __errno_location();
#line 316
    tmp___0 = strerror(*tmp);
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open file %s for writing: %s\n",
            prog_name, nvramtool_op.param, tmp___0);
#line 318
    exit(1);
    }
  }
  {
#line 321
  set_iopl(3);
#line 322
  cmos_read_all(data);
#line 323
  set_iopl(0);
#line 325
  tmp___3 = fwrite((void const   */* __restrict  */)(data), (size_t )1, (size_t )256,
                   (FILE */* __restrict  */)f);
  }
#line 325
  if (tmp___3 != 256UL) {
    {
#line 326
    tmp___1 = __errno_location();
#line 326
    tmp___2 = strerror(*tmp___1);
#line 326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error writing CMOS data to file %s: %s\n",
            prog_name, nvramtool_op.param, tmp___2);
#line 328
    exit(1);
    }
  }
  {
#line 331
  fclose(f);
  }
#line 332
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_read_cmos_dump(void) 
{ 
  unsigned char data[256] ;
  size_t nr_bytes ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 346
  f = fopen((char const   */* __restrict  */)nvramtool_op.param, (char const   */* __restrict  */)"r");
  }
#line 346
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 347
    tmp = __errno_location();
#line 347
    tmp___0 = strerror(*tmp);
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open file %s for reading: %s\n",
            prog_name, nvramtool_op.param, tmp___0);
#line 349
    exit(1);
    }
  }
  {
#line 352
  nr_bytes = fread((void */* __restrict  */)(data), (size_t )1, (size_t )256, (FILE */* __restrict  */)f);
  }
#line 352
  if (nr_bytes != 256UL) {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error: Only able to read %d bytes of CMOS data from file %s.  CMOS data is unchanged.\n",
            prog_name, (int )nr_bytes, nvramtool_op.param);
#line 356
    exit(1);
    }
  }
  {
#line 359
  fclose(f);
#line 360
  set_iopl(3);
#line 361
  cmos_write_all(data);
#line 362
  set_iopl(0);
  }
#line 363
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_cmos_hex_dump(void) 
{ 
  unsigned char data[256] ;

  {
  {
#line 375
  set_iopl(3);
#line 376
  cmos_read_all(data);
#line 377
  set_iopl(0);
#line 378
  hexdump((void const   *)(data), 256, (uint64_t )0, stdout, & cmos_dump_format);
  }
#line 379
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void op_show_cmos_dumpfile(void) 
{ 
  unsigned char data[256] ;
  size_t nr_bytes ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 394
  f = fopen((char const   */* __restrict  */)nvramtool_op.param, (char const   */* __restrict  */)"r");
  }
#line 394
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 395
    tmp = __errno_location();
#line 395
    tmp___0 = strerror(*tmp);
#line 395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not open file %s for reading: %s\n",
            prog_name, nvramtool_op.param, tmp___0);
#line 397
    exit(1);
    }
  }
  {
#line 400
  nr_bytes = fread((void */* __restrict  */)(data), (size_t )1, (size_t )256, (FILE */* __restrict  */)f);
#line 401
  fclose(f);
#line 402
  hexdump((void const   *)(data), (int )nr_bytes, (uint64_t )0, stdout, & cmos_dump_format);
  }
#line 403
  return;
}
}
#line 412 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static int list_one_param(char const   *name , int show_name ) 
{ 
  cmos_entry_t const   *e ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 415
  tmp = is_checksum_name(name);
  }
#line 415
  if (tmp) {
    {
#line 416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.\n",
            prog_name, name);
#line 417
    exit(1);
    }
  } else {
    {
#line 415
    e = find_cmos_entry(name);
    }
#line 415
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 416
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.\n",
              prog_name, name);
#line 417
      exit(1);
      }
    }
  }
#line 420
  if ((unsigned int const   )e->config == 3U) {
    {
#line 421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Parameter %s is reserved.\n",
            prog_name, name);
#line 422
    exit(1);
    }
  }
  {
#line 425
  tmp___0 = list_cmos_entry(e, show_name);
  }
#line 425
  return (tmp___0 != 0);
}
}
#line 434 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static int list_all_params(void) 
{ 
  cmos_entry_t const   *e ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 438
  result = 0;
#line 440
  e = first_cmos_entry();
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 440
      goto while_break;
    }
#line 441
    if ((unsigned int const   )e->config == 3U) {
#line 442
      goto __Cont;
    } else {
      {
#line 441
      tmp = is_checksum_name((char const   *)(e->name));
      }
#line 441
      if (tmp) {
#line 442
        goto __Cont;
      }
    }
    {
#line 444
    tmp___0 = list_cmos_entry(e, 1);
    }
#line 444
    if (tmp___0) {
#line 445
      result = 1;
    }
    __Cont: /* CIL Label */ 
    {
#line 440
    e = next_cmos_entry(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return (result);
}
}
#line 456 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void list_param_enums(char const   *name ) 
{ 
  cmos_entry_t const   *e ;
  cmos_enum_t const   *p ;
  int tmp ;

  {
  {
#line 460
  tmp = is_checksum_name(name);
  }
#line 460
  if (tmp) {
    {
#line 461
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.\n",
            prog_name, name);
#line 462
    exit(1);
    }
  } else {
    {
#line 460
    e = find_cmos_entry(name);
    }
#line 460
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.\n",
              prog_name, name);
#line 462
      exit(1);
      }
    }
  }
  {
#line 466
  if ((unsigned int const   )e->config == 0U) {
#line 466
    goto case_0;
  }
#line 474
  if ((unsigned int const   )e->config == 1U) {
#line 474
    goto case_1;
  }
#line 479
  if ((unsigned int const   )e->config == 2U) {
#line 479
    goto case_2;
  }
#line 484
  if ((unsigned int const   )e->config == 3U) {
#line 484
    goto case_3;
  }
#line 488
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 467
  p = first_cmos_enum_id((unsigned int )e->config_id);
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 467
      goto while_break;
    }
    {
#line 470
    printf((char const   */* __restrict  */)"%s\n", p->text);
#line 467
    p = next_cmos_enum_id(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 475
  printf((char const   */* __restrict  */)"Parameter %s requires a %u-bit unsigned integer.\n",
         name, e->length);
  }
#line 477
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 480
  printf((char const   */* __restrict  */)"Parameter %s requires a %u-byte string.\n",
         name, e->length / 8U);
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 485
  printf((char const   */* __restrict  */)"Parameter %s is reserved.\n", name);
  }
#line 486
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 489
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c",
                489U, "list_param_enums");
  }
  switch_break: /* CIL Label */ ;
  }
#line 491
  return;
}
}
#line 503 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void set_one_param(char const   *name , char const   *value ) 
{ 
  cmos_entry_t const   *e ;
  unsigned long long n ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 507
  tmp = is_checksum_name(name);
  }
#line 507
  if (tmp) {
    {
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.",
            prog_name, name);
#line 509
    exit(1);
    }
  } else {
    {
#line 507
    e = find_cmos_entry(name);
    }
#line 507
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: CMOS parameter %s not found.",
              prog_name, name);
#line 509
      exit(1);
      }
    }
  }
  {
#line 512
  tmp___0 = prepare_cmos_write(e, value, & n);
  }
  {
#line 513
  if (tmp___0 == 0) {
#line 513
    goto case_0;
  }
#line 516
  if (tmp___0 == 262144) {
#line 516
    goto case_262144;
  }
#line 520
  if (tmp___0 == 262145) {
#line 520
    goto case_262145;
  }
#line 526
  if (tmp___0 == 262146) {
#line 526
    goto case_262146;
  }
#line 530
  if (tmp___0 == 262147) {
#line 530
    goto case_262147;
  }
#line 536
  if (tmp___0 == 262148) {
#line 536
    goto case_262148;
  }
#line 542
  if (tmp___0 == 262149) {
#line 542
    goto case_262149;
  }
#line 548
  if (tmp___0 == 196608) {
#line 548
    goto case_196608;
  }
#line 554
  if (tmp___0 == 196609) {
#line 554
    goto case_196609;
  }
#line 561
  if (tmp___0 == 196610) {
#line 561
    goto case_196610;
  }
#line 568
  goto switch_default;
  case_0: /* CIL Label */ 
#line 514
  goto switch_break;
  case_262144: /* CIL Label */ 
  {
#line 517
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Bad value for parameter %s.",
          prog_name, name);
  }
#line 518
  goto fail;
  case_262145: /* CIL Label */ 
  {
#line 521
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: This program does not support assignment of negative numbers to coreboot parameters.",
          prog_name);
  }
#line 524
  goto fail;
  case_262146: /* CIL Label */ 
  {
#line 527
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a valid integer.",
          prog_name, value);
  }
#line 528
  goto fail;
  case_262147: /* CIL Label */ 
  {
#line 531
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not modify reserved coreboot parameter %s.",
          prog_name, name);
  }
#line 534
  goto fail;
  case_262148: /* CIL Label */ 
  {
#line 537
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not write value %s to CMOS parameter %s that is only %d bits wide.",
          prog_name, value, name, e->length);
  }
#line 540
  goto fail;
  case_262149: /* CIL Label */ 
  {
#line 543
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: coreboot parameter %s has no matching enums.",
          prog_name, name);
  }
#line 546
  goto fail;
  case_196608: /* CIL Label */ 
  {
#line 549
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s is out of range.",
          prog_name, name);
  }
#line 552
  goto fail;
  case_196609: /* CIL Label */ 
  {
#line 555
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s overlaps the realtime clock area.",
          prog_name, name);
  }
#line 559
  goto fail;
  case_196610: /* CIL Label */ 
  {
#line 562
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The CMOS area specified by the layout info for coreboot parameter %s is too wide.",
          prog_name, name);
  }
#line 566
  goto fail;
  switch_default: /* CIL Label */ 
  {
#line 569
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown error encountered while attempting to modify coreboot parameter %s.",
          prog_name, name);
  }
#line 572
  goto fail;
  switch_break: /* CIL Label */ ;
  }
  {
#line 576
  set_iopl(3);
#line 577
  cmos_write(e, n);
#line 578
  tmp___1 = cmos_checksum_compute();
#line 578
  cmos_checksum_write(tmp___1);
#line 579
  set_iopl(0);
  }
#line 580
  return;
  fail: 
  {
#line 583
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  CMOS write not performed.\n");
#line 584
  exit(1);
  }
}
}
#line 592 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void set_params(FILE *f ) 
{ 
  cmos_write_t *tmp ;

  {
  {
#line 597
  tmp = process_input_file(f);
#line 597
  do_cmos_writes(tmp);
  }
#line 598
  return;
}
}
#line 611 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static unsigned long const   N_MATCHES___3  =    (size_t const   )4;
#line 609 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static void parse_assignment(char *arg , char const   **name , char const   **value ) 
{ 
  regmatch_t *match ;
  unsigned long __lengthofmatch ;
  void *tmp ;
  regex_t assignment ;
  int tmp___0 ;

  {
  {
#line 612
  __lengthofmatch = (unsigned long )N_MATCHES___3;
#line 612
  tmp = __builtin_alloca(sizeof(*match) * __lengthofmatch);
#line 612
  match = (regmatch_t *)tmp;
#line 615
  compile_reg_exprs(1 | ((1 << 1) << 1), 1, assignment_regex, & assignment);
#line 621
  tmp___0 = regexec((regex_t const   */* __restrict  */)(& assignment), (char const   */* __restrict  */)arg,
                    (size_t )N_MATCHES___3, (regmatch_t */* __restrict  */)match,
                    0);
  }
#line 621
  if (tmp___0) {
    {
#line 622
    usage(stderr);
    }
  }
  {
#line 627
  *(arg + (match + 1)->rm_eo) = (char )'\000';
#line 628
  *(arg + (match + 2)->rm_eo) = (char )'\000';
#line 629
  *name = (char const   *)(arg + (match + 1)->rm_so);
#line 630
  *value = (char const   *)(arg + (match + 2)->rm_so);
#line 632
  free_reg_exprs(1, & assignment);
  }
#line 633
  return;
}
}
#line 643 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static int list_cmos_entry(cmos_entry_t const   *e , int show_name ) 
{ 
  cmos_enum_t const   *p ;
  unsigned long long value ;
  int tmp ;

  {
  {
#line 648
  tmp = prepare_cmos_read(e);
  }
  {
#line 649
  if (tmp == 0) {
#line 649
    goto case_0;
  }
#line 652
  if (tmp == 262147) {
#line 652
    goto case_262147;
  }
#line 655
  if (tmp == 196608) {
#line 655
    goto case_196608;
  }
#line 661
  if (tmp == 196609) {
#line 661
    goto case_196609;
  }
#line 667
  if (tmp == 196610) {
#line 667
    goto case_196610;
  }
#line 673
  goto switch_default;
  case_0: /* CIL Label */ 
#line 650
  goto switch_break;
  case_262147: /* CIL Label */ 
  {
#line 653
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c",
                653U, "list_cmos_entry");
  }
  case_196608: /* CIL Label */ 
  {
#line 656
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not read coreboot parameter %s because layout info specifies out of range CMOS area.\n",
          prog_name, e->name);
  }
#line 659
  return (1);
  case_196609: /* CIL Label */ 
  {
#line 662
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not read coreboot parameter %s because layout info specifies CMOS area that overlaps realtime clock area.\n",
          prog_name, e->name);
  }
#line 665
  return (1);
  case_196610: /* CIL Label */ 
  {
#line 668
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can not read coreboot parameter %s because layout info specifies CMOS area that is too wide.\n",
          prog_name, e->name);
  }
#line 671
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 674
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown error encountered while attempting to read coreboot parameter %s\n",
          prog_name, e->name);
  }
#line 676
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 680
  set_iopl(3);
#line 681
  value = cmos_read(e);
#line 682
  set_iopl(0);
  }
  {
#line 686
  if ((unsigned int const   )e->config == 0U) {
#line 686
    goto case_0___0;
  }
#line 702
  if ((unsigned int const   )e->config == 1U) {
#line 702
    goto case_1;
  }
#line 710
  if ((unsigned int const   )e->config == 2U) {
#line 710
    goto case_2;
  }
#line 721
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 687
  p = find_cmos_enum((unsigned int )e->config_id, value);
  }
#line 687
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 688
    if (show_name) {
      {
#line 689
      printf((char const   */* __restrict  */)"# Bad value -> %s = 0x%llx\n", e->name,
             value);
      }
    } else {
      {
#line 691
      printf((char const   */* __restrict  */)"Bad value -> 0x%llx\n", value);
      }
    }
  } else
#line 694
  if (show_name) {
    {
#line 695
    printf((char const   */* __restrict  */)"%s = %s\n", e->name, p->text);
    }
  } else {
    {
#line 697
    printf((char const   */* __restrict  */)"%s\n", p->text);
    }
  }
#line 700
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 703
  if (show_name) {
    {
#line 704
    printf((char const   */* __restrict  */)"%s = 0x%llx\n", e->name, value);
    }
  } else {
    {
#line 706
    printf((char const   */* __restrict  */)"0x%llx\n", value);
    }
  }
#line 708
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 711
  if (show_name) {
    {
#line 712
    printf((char const   */* __restrict  */)"%s = %s\n", e->name, (char *)((unsigned long )value));
    }
  } else {
    {
#line 714
    printf((char const   */* __restrict  */)"%s\n", (char *)((unsigned long )value));
    }
  }
  {
#line 716
  free((void *)((unsigned long )value));
  }
#line 718
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 722
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c",
                722U, "list_cmos_entry");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 725
  return (0);
}
}
#line 736 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/nvramtool.c"
static uint16_t convert_checksum_value(char const   *value ) 
{ 
  unsigned long n ;
  char const   *p ;
  uint16_t result ;
  int negative ;
  unsigned short const   **tmp ;

  {
#line 742
  p = value;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 742
    tmp = __ctype_b_loc();
    }
#line 742
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 742
      goto while_break;
    }
#line 742
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 744
  negative = (int const   )*p == 45;
#line 745
  n = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)((char **)(& p)),
              0);
  }
#line 747
  if (*p) {
    {
#line 748
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Checksum value %s is not a valid integer.\n",
            prog_name, value);
#line 750
    exit(1);
    }
  }
#line 753
  if (negative) {
    {
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Checksum must be an unsigned integer.\n",
            prog_name);
#line 756
    exit(1);
    }
  }
#line 759
  result = (uint16_t )n;
#line 761
  if ((unsigned long )result != n) {
    {
#line 762
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Checksum value must fit within 16 bits.\n",
            prog_name);
#line 764
    exit(1);
    }
  }
#line 767
  return (result);
}
}
#line 49 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static void default_cmos_layout_get_fn(void) ;
#line 50
static int areas_overlap(unsigned int area_0_start , unsigned int area_0_length ,
                         unsigned int area_1_start , unsigned int area_1_length ) ;
#line 52
__inline static int entries_overlap(cmos_entry_t const   *p , cmos_entry_t const   *q ) ;
#line 53
static cmos_enum_item_t const   *find_first_cmos_enum_id(unsigned int config_id ) ;
#line 55 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
char const   checksum_param_name[10]  = 
#line 55
  {      (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'s',      (char const   )'u', 
        (char const   )'m',      (char const   )'\000'};
#line 77 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
unsigned int cmos_checksum_start  =    49U;
#line 80 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
unsigned int cmos_checksum_end  =    125U;
#line 83 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
unsigned int cmos_checksum_index  =    126U;
#line 88 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static cmos_entry_item_t *cmos_entry_list  =    (cmos_entry_item_t *)((void *)0);
#line 93 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static cmos_enum_item_t *cmos_enum_list  =    (cmos_enum_item_t *)((void *)0);
#line 95 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static void (*cmos_layout_get_fn)(void)  =    & default_cmos_layout_get_fn;
#line 102 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
__inline static int entries_overlap(cmos_entry_t const   *p , cmos_entry_t const   *q ) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = areas_overlap((unsigned int )p->bit, (unsigned int )p->length, (unsigned int )q->bit,
                      (unsigned int )q->length);
  }
#line 104
  return (tmp);
}
}
#line 113
__inline static cmos_entry_item_t const   *cmos_entry_to_const_item(cmos_entry_t const   *p ) ;
#line 113 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static cmos_entry_t const   *pos  =    (cmos_entry_t const   *)(& ((cmos_entry_item_t *)0)->item);
#line 111 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
__inline static cmos_entry_item_t const   *cmos_entry_to_const_item(cmos_entry_t const   *p ) 
{ 
  unsigned long offset ;
  unsigned long address ;

  {
#line 116
  offset = (unsigned long )pos;
#line 117
  address = (unsigned long )p - offset;
#line 118
  return ((cmos_entry_item_t const   *)address);
}
}
#line 128
__inline static cmos_enum_item_t const   *cmos_enum_to_const_item(cmos_enum_t const   *p ) ;
#line 128 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static cmos_enum_t const   *pos___0  =    (cmos_enum_t const   *)(& ((cmos_enum_item_t *)0)->item);
#line 126 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
__inline static cmos_enum_item_t const   *cmos_enum_to_const_item(cmos_enum_t const   *p ) 
{ 
  unsigned long offset ;
  unsigned long address ;

  {
#line 131
  offset = (unsigned long )pos___0;
#line 132
  address = (unsigned long )p - offset;
#line 133
  return ((cmos_enum_item_t const   *)address);
}
}
#line 142 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
void register_cmos_layout_get_fn(void (*fn)(void) ) 
{ 


  {
#line 143
  cmos_layout_get_fn = fn;
#line 143
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
void get_cmos_layout(void) 
{ 


  {
  {
#line 151
  (*cmos_layout_get_fn)();
  }
#line 151
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
int add_cmos_entry(cmos_entry_t const   *e , cmos_entry_t const   **conflict ) 
{ 
  cmos_entry_item_t *item ;
  cmos_entry_item_t *prev ;
  cmos_entry_item_t *new_entry ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 164
  *conflict = (cmos_entry_t const   *)((void *)0);
#line 166
  if (e->length < 1U) {
#line 167
    return (131073);
  }
  {
#line 169
  tmp = malloc(sizeof(*new_entry));
#line 169
  new_entry = (cmos_entry_item_t *)tmp;
  }
#line 169
  if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
    {
#line 170
    out_of_memory();
    }
  }
#line 172
  new_entry->item = (cmos_entry_t )*e;
#line 174
  if ((unsigned long )cmos_entry_list == (unsigned long )((void *)0)) {
#line 175
    new_entry->next = (cmos_entry_item_t *)((void *)0);
#line 176
    cmos_entry_list = new_entry;
#line 177
    return (0);
  }
#line 183
  item = cmos_entry_list;
#line 183
  prev = (cmos_entry_item_t *)((void *)0);
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 183
      if (! (item->item.bit < (unsigned int )e->bit)) {
#line 183
        goto while_break;
      }
    } else {
#line 183
      goto while_break;
    }
#line 183
    prev = item;
#line 183
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
    {
#line 188
    tmp___0 = entries_overlap(e, (cmos_entry_t const   *)(& cmos_entry_list->item));
    }
#line 188
    if (tmp___0) {
#line 189
      *conflict = (cmos_entry_t const   *)(& cmos_entry_list->item);
#line 190
      goto fail;
    }
#line 193
    new_entry->next = cmos_entry_list;
#line 194
    cmos_entry_list = new_entry;
#line 195
    return (0);
  }
  {
#line 198
  tmp___1 = entries_overlap((cmos_entry_t const   *)(& prev->item), e);
  }
#line 198
  if (tmp___1) {
#line 199
    *conflict = (cmos_entry_t const   *)(& prev->item);
#line 200
    goto fail;
  }
#line 203
  if ((unsigned long )item != (unsigned long )((void *)0)) {
    {
#line 203
    tmp___2 = entries_overlap(e, (cmos_entry_t const   *)(& item->item));
    }
#line 203
    if (tmp___2) {
#line 204
      *conflict = (cmos_entry_t const   *)(& item->item);
#line 205
      goto fail;
    }
  }
#line 208
  new_entry->next = item;
#line 209
  prev->next = new_entry;
#line 210
  return (0);
  fail: 
  {
#line 213
  free((void *)new_entry);
  }
#line 214
  return (131072);
}
}
#line 223 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_entry_t const   *find_cmos_entry(char const   *name ) 
{ 
  cmos_entry_item_t *item ;
  int tmp ;

  {
#line 226
  item = cmos_entry_list;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp = strcmp((char const   *)(item->item.name), name);
    }
#line 227
    if (! tmp) {
#line 228
      return ((cmos_entry_t const   *)(& item->item));
    }
#line 226
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return ((cmos_entry_t const   *)((void *)0));
}
}
#line 240 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_entry_t const   *first_cmos_entry(void) 
{ 
  cmos_entry_t *tmp ;

  {
#line 241
  if ((unsigned long )cmos_entry_list == (unsigned long )((void *)0)) {
#line 241
    tmp = (cmos_entry_t *)((void *)0);
  } else {
#line 241
    tmp = & cmos_entry_list->item;
  }
#line 241
  return ((cmos_entry_t const   *)tmp);
}
}
#line 249 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_entry_t const   *next_cmos_entry(cmos_entry_t const   *last ) 
{ 
  cmos_entry_item_t const   *last_item ;
  cmos_entry_item_t const   *next_item ;
  cmos_entry_t const   *tmp ;

  {
  {
#line 252
  last_item = cmos_entry_to_const_item(last);
#line 253
  next_item = (cmos_entry_item_t const   *)last_item->next;
  }
#line 254
  if ((unsigned long )next_item == (unsigned long )((void *)0)) {
#line 254
    tmp = (cmos_entry_t const   *)((void *)0);
  } else {
#line 254
    tmp = & next_item->item;
  }
#line 254
  return (tmp);
}
}
#line 263 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
int add_cmos_enum(cmos_enum_t const   *e ) 
{ 
  cmos_enum_item_t *item ;
  cmos_enum_item_t *prev ;
  cmos_enum_item_t *new_enum ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*new_enum));
#line 266
  new_enum = (cmos_enum_item_t *)tmp;
  }
#line 266
  if ((unsigned long )new_enum == (unsigned long )((void *)0)) {
    {
#line 267
    out_of_memory();
    }
  }
#line 269
  new_enum->item = (cmos_enum_t )*e;
#line 271
  if ((unsigned long )cmos_enum_list == (unsigned long )((void *)0)) {
#line 272
    new_enum->next = (cmos_enum_item_t *)((void *)0);
#line 273
    cmos_enum_list = new_enum;
#line 274
    return (0);
  }
#line 281
  item = cmos_enum_list;
#line 281
  prev = (cmos_enum_item_t *)((void *)0);
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 281
      if (! (item->item.config_id < (unsigned int )e->config_id)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
#line 281
    prev = item;
#line 281
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 286
    new_enum->next = (cmos_enum_item_t *)((void *)0);
#line 287
    prev->next = new_enum;
#line 288
    return (0);
  }
#line 291
  if (item->item.config_id > (unsigned int )e->config_id) {
#line 292
    new_enum->next = item;
#line 294
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 295
      cmos_enum_list = new_enum;
    } else {
#line 297
      prev->next = new_enum;
    }
#line 299
    return (0);
  }
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 305
    if (! (item->item.value < (unsigned long long )e->value)) {
#line 305
      goto while_break___0;
    }
#line 306
    prev = item;
#line 307
    item = item->next;
#line 309
    if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 310
      new_enum->next = item;
#line 311
      prev->next = new_enum;
#line 312
      return (0);
    } else
#line 309
    if (item->item.config_id != (unsigned int )e->config_id) {
#line 310
      new_enum->next = item;
#line 311
      prev->next = new_enum;
#line 312
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  if (item->item.value == (unsigned long long )e->value) {
    {
#line 317
    free((void *)new_enum);
    }
#line 318
    return (131074);
  }
#line 321
  new_enum->next = item;
#line 323
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 324
    cmos_enum_list = new_enum;
  } else {
#line 326
    prev->next = new_enum;
  }
#line 328
  return (0);
}
}
#line 337 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_enum_t const   *find_cmos_enum(unsigned int config_id , unsigned long long value ) 
{ 
  cmos_enum_item_t const   *item ;
  cmos_enum_t const   *tmp ;

  {
  {
#line 341
  item = find_first_cmos_enum_id(config_id);
  }
#line 341
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 342
    return ((cmos_enum_t const   *)((void *)0));
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (item->item.value < (unsigned long long const   )value)) {
#line 344
      goto while_break;
    }
#line 345
    item = (cmos_enum_item_t const   *)item->next;
#line 347
    if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 348
      return ((cmos_enum_t const   *)((void *)0));
    } else
#line 347
    if (item->item.config_id != (unsigned int const   )config_id) {
#line 348
      return ((cmos_enum_t const   *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  if (item->item.value == (unsigned long long const   )value) {
#line 351
    tmp = & item->item;
  } else {
#line 351
    tmp = (cmos_enum_t const   *)((void *)0);
  }
#line 351
  return (tmp);
}
}
#line 360 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_enum_t const   *first_cmos_enum(void) 
{ 
  cmos_enum_t *tmp ;

  {
#line 361
  if ((unsigned long )cmos_enum_list == (unsigned long )((void *)0)) {
#line 361
    tmp = (cmos_enum_t *)((void *)0);
  } else {
#line 361
    tmp = & cmos_enum_list->item;
  }
#line 361
  return ((cmos_enum_t const   *)tmp);
}
}
#line 369 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_enum_t const   *next_cmos_enum(cmos_enum_t const   *last ) 
{ 
  cmos_enum_item_t const   *last_item ;
  cmos_enum_item_t const   *next_item ;
  cmos_enum_t const   *tmp ;

  {
  {
#line 372
  last_item = cmos_enum_to_const_item(last);
#line 373
  next_item = (cmos_enum_item_t const   *)last_item->next;
  }
#line 374
  if ((unsigned long )next_item == (unsigned long )((void *)0)) {
#line 374
    tmp = (cmos_enum_t const   *)((void *)0);
  } else {
#line 374
    tmp = & next_item->item;
  }
#line 374
  return (tmp);
}
}
#line 383 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_enum_t const   *first_cmos_enum_id(unsigned int config_id ) 
{ 
  cmos_enum_item_t const   *item ;
  cmos_enum_t const   *tmp ;

  {
  {
#line 386
  item = find_first_cmos_enum_id(config_id);
  }
#line 387
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 387
    tmp = (cmos_enum_t const   *)((void *)0);
  } else {
#line 387
    tmp = & item->item;
  }
#line 387
  return (tmp);
}
}
#line 396 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
cmos_enum_t const   *next_cmos_enum_id(cmos_enum_t const   *last ) 
{ 
  cmos_enum_item_t const   *item ;
  cmos_enum_item_t const   *tmp ;
  cmos_enum_t const   *tmp___0 ;

  {
  {
#line 399
  tmp = cmos_enum_to_const_item(last);
#line 399
  item = (cmos_enum_item_t const   *)tmp->next;
  }
#line 400
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 400
    tmp___0 = (cmos_enum_t const   *)((void *)0);
  } else
#line 400
  if (item->item.config_id != last->config_id) {
#line 400
    tmp___0 = (cmos_enum_t const   *)((void *)0);
  } else {
#line 400
    tmp___0 = & item->item;
  }
#line 400
  return (tmp___0);
}
}
#line 410 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
int is_checksum_name(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 411
  tmp = strcmp(name, checksum_param_name);
  }
#line 411
  if (tmp) {
#line 411
    tmp___0 = 0;
  } else {
#line 411
    tmp___0 = 1;
  }
#line 411
  return (tmp___0);
}
}
#line 421 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
int checksum_layout_to_bytes(cmos_checksum_layout_t *layout ) 
{ 
  unsigned int start ;
  unsigned int end ;
  unsigned int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 424
  start = layout->summed_area_start;
#line 425
  end = layout->summed_area_end;
#line 426
  index___0 = layout->checksum_at;
#line 428
  if (start % 8U) {
#line 429
    return (131075);
  }
#line 431
  if (end % 8U != 7U) {
#line 432
    return (131076);
  }
#line 434
  if (index___0 % 8U) {
#line 435
    return (131077);
  }
#line 437
  if (end <= start) {
#line 438
    return (131078);
  }
  {
#line 441
  start /= 8U;
#line 442
  end /= 8U;
#line 443
  index___0 /= 8U;
#line 445
  tmp = verify_cmos_byte_index(start);
  }
#line 445
  if (tmp) {
#line 446
    return (131080);
  } else {
    {
#line 445
    tmp___0 = verify_cmos_byte_index(end);
    }
#line 445
    if (tmp___0) {
#line 446
      return (131080);
    }
  }
  {
#line 448
  tmp___1 = verify_cmos_byte_index(index___0);
  }
#line 448
  if (tmp___1) {
#line 449
    return (131081);
  }
  {
#line 452
  tmp___2 = areas_overlap(start, (end - start) + 1U, index___0, index___0 + 1U);
  }
#line 452
  if (tmp___2) {
#line 453
    return (131079);
  }
#line 455
  layout->summed_area_start = start;
#line 456
  layout->summed_area_end = end;
#line 457
  layout->checksum_at = index___0;
#line 458
  return (0);
}
}
#line 467 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
void checksum_layout_to_bits(cmos_checksum_layout_t *layout ) 
{ 


  {
#line 468
  layout->summed_area_start *= 8U;
#line 469
  layout->summed_area_end = layout->summed_area_end * 8U + 7U;
#line 470
  layout->checksum_at *= 8U;
#line 471
  return;
}
}
#line 480 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static void default_cmos_layout_get_fn(void) 
{ 


  {
  {
#line 481
  __assert_fail("0", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c", 481U,
                "default_cmos_layout_get_fn");
  }
}
}
#line 488 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static int areas_overlap(unsigned int area_0_start , unsigned int area_0_length ,
                         unsigned int area_1_start , unsigned int area_1_length ) 
{ 
  unsigned int area_0_end ;
  unsigned int area_1_end ;
  int tmp ;

  {
#line 492
  area_0_end = (area_0_start + area_0_length) - 1U;
#line 493
  area_1_end = (area_1_start + area_1_length) - 1U;
#line 494
  if (area_1_start <= area_0_end) {
#line 494
    if (area_0_start <= area_1_end) {
#line 494
      tmp = 1;
    } else {
#line 494
      tmp = 0;
    }
  } else {
#line 494
    tmp = 0;
  }
#line 494
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/layout.c"
static cmos_enum_item_t const   *find_first_cmos_enum_id(unsigned int config_id ) 
{ 
  cmos_enum_item_t *item ;
  cmos_enum_item_t *tmp ;

  {
#line 506
  item = cmos_enum_list;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 506
      if (! (item->item.config_id < config_id)) {
#line 506
        goto while_break;
      }
    } else {
#line 506
      goto while_break;
    }
#line 506
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 510
    tmp = (cmos_enum_item_t *)((void *)0);
  } else
#line 510
  if (item->item.config_id > config_id) {
#line 510
    tmp = (cmos_enum_item_t *)((void *)0);
  } else {
#line 510
    tmp = item;
  }
#line 510
  return ((cmos_enum_item_t const   *)tmp);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 77 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
nvramtool_op_info_t nvramtool_op  ;
#line 79 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.h"
nvramtool_op_modifier_info_t nvramtool_op_modifiers[3]  ;
#line 38 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static char *handle_optional_arg(int argc , char **argv ) ;
#line 39
static void register_op(int *op_found , nvramtool_op_t op , char *op_param ) ;
#line 40
static void register_op_modifier(nvramtool_op_modifier_t mod , char *mod_param ) ;
#line 41
static void resolve_op_modifiers(void) ;
#line 42
static void sanity_check_args(void) ;
#line 44 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static char const   getopt_string[33]  = 
#line 44
  {      (char const   )'-',      (char const   )'a',      (char const   )'b',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'c',      (char const   )':', 
        (char const   )':',      (char const   )'d',      (char const   )'e',      (char const   )':', 
        (char const   )'h',      (char const   )'i',      (char const   )'l',      (char const   )':', 
        (char const   )':',      (char const   )'n',      (char const   )'p',      (char const   )':', 
        (char const   )'r',      (char const   )':',      (char const   )'t',      (char const   )'v', 
        (char const   )'w',      (char const   )':',      (char const   )'x',      (char const   )'X', 
        (char const   )':',      (char const   )'y',      (char const   )':',      (char const   )'Y', 
        (char const   )'\000'};
#line 51 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
void parse_nvramtool_args(int argc , char **argv ) 
{ 
  nvramtool_op_modifier_info_t *mod_info ;
  int i ;
  int op_found ;
  char c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 56
  i = 0;
#line 56
  mod_info = nvramtool_op_modifiers;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < 3)) {
#line 56
      goto while_break;
    }
#line 59
    mod_info->found = 0;
#line 60
    mod_info->found_seq = 0;
#line 61
    mod_info->param = (char *)((void *)0);
#line 56
    i ++;
#line 56
    mod_info ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  op_found = 0;
#line 65
  opterr = 0;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 68
    tmp = getopt(argc, (char * const  *)argv, getopt_string);
#line 68
    c = (char )tmp;
    }
    {
#line 69
    if ((int )c == 97) {
#line 69
      goto case_97;
    }
#line 72
    if ((int )c == 98) {
#line 72
      goto case_98;
    }
#line 75
    if ((int )c == 66) {
#line 75
      goto case_66;
    }
#line 78
    if ((int )c == 99) {
#line 78
      goto case_99;
    }
#line 82
    if ((int )c == 100) {
#line 82
      goto case_100;
    }
#line 85
    if ((int )c == 101) {
#line 85
      goto case_101;
    }
#line 88
    if ((int )c == 104) {
#line 88
      goto case_104;
    }
#line 91
    if ((int )c == 105) {
#line 91
      goto case_105;
    }
#line 94
    if ((int )c == 108) {
#line 94
      goto case_108;
    }
#line 98
    if ((int )c == 110) {
#line 98
      goto case_110;
    }
#line 101
    if ((int )c == 112) {
#line 101
      goto case_112;
    }
#line 104
    if ((int )c == 114) {
#line 104
      goto case_114;
    }
#line 107
    if ((int )c == 116) {
#line 107
      goto case_116;
    }
#line 110
    if ((int )c == 118) {
#line 110
      goto case_118;
    }
#line 113
    if ((int )c == 119) {
#line 113
      goto case_119;
    }
#line 116
    if ((int )c == 120) {
#line 116
      goto case_120;
    }
#line 119
    if ((int )c == 88) {
#line 119
      goto case_88;
    }
#line 122
    if ((int )c == 121) {
#line 122
      goto case_121;
    }
#line 125
    if ((int )c == 89) {
#line 125
      goto case_89;
    }
#line 128
    if ((int )c == -1) {
#line 128
      goto case_neg_1;
    }
#line 132
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 70
    register_op(& op_found, (nvramtool_op_t )6, (char *)((void *)0));
    }
#line 71
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 73
    register_op(& op_found, (nvramtool_op_t )12, optarg);
    }
#line 74
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 76
    register_op(& op_found, (nvramtool_op_t )13, optarg);
    }
#line 77
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 79
    tmp___0 = handle_optional_arg(argc, argv);
#line 79
    register_op(& op_found, (nvramtool_op_t )10, tmp___0);
    }
#line 81
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 83
    register_op(& op_found, (nvramtool_op_t )3, (char *)((void *)0));
    }
#line 84
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 86
    register_op(& op_found, (nvramtool_op_t )4, optarg);
    }
#line 87
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 89
    register_op(& op_found, (nvramtool_op_t )1, (char *)((void *)0));
    }
#line 90
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 92
    register_op(& op_found, (nvramtool_op_t )8, (char *)((void *)0));
    }
#line 93
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 95
    tmp___1 = handle_optional_arg(argc, argv);
#line 95
    register_op(& op_found, (nvramtool_op_t )2, tmp___1);
    }
#line 97
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 99
    register_op_modifier((nvramtool_op_modifier_t )0, (char *)((void *)0));
    }
#line 100
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 102
    register_op(& op_found, (nvramtool_op_t )9, optarg);
    }
#line 103
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 105
    register_op(& op_found, (nvramtool_op_t )5, optarg);
    }
#line 106
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 108
    register_op_modifier((nvramtool_op_modifier_t )2, (char *)((void *)0));
    }
#line 109
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 111
    register_op(& op_found, (nvramtool_op_t )0, (char *)((void *)0));
    }
#line 112
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 114
    register_op(& op_found, (nvramtool_op_t )7, optarg);
    }
#line 115
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 117
    register_op(& op_found, (nvramtool_op_t )14, (char *)((void *)0));
    }
#line 118
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 120
    register_op(& op_found, (nvramtool_op_t )15, optarg);
    }
#line 121
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 123
    register_op_modifier((nvramtool_op_modifier_t )1, optarg);
    }
#line 124
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 126
    register_op(& op_found, (nvramtool_op_t )11, (char *)((void *)0));
    }
#line 127
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 129
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 133
    usage(stderr);
    }
#line 134
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 67
    if (! ((int )c != -1)) {
#line 67
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  if (! op_found) {
    {
#line 140
    usage(stderr);
    }
  }
  {
#line 142
  resolve_op_modifiers();
#line 143
  sanity_check_args();
  }
#line 144
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static char *handle_optional_arg(int argc , char **argv ) 
{ 
  char *arg ;

  {
#line 154
  if ((unsigned long )optarg != (unsigned long )((void *)0)) {
#line 159
    return (optarg);
  }
#line 162
  if ((unsigned long )*(argv + optind) == (unsigned long )((void *)0)) {
#line 163
    return ((char *)((void *)0));
  } else
#line 162
  if ((int )*(*(argv + optind) + 0) == 45) {
#line 163
    return ((char *)((void *)0));
  }
  {
#line 165
  arg = *(argv + optind);
#line 170
  getopt(argc, (char * const  *)argv, getopt_string);
  }
#line 172
  return (arg);
}
}
#line 180 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static void register_op(int *op_found , nvramtool_op_t op , char *op_param ) 
{ 


  {
#line 181
  if (*op_found) {
#line 181
    if ((unsigned int )op != (unsigned int )nvramtool_op.op) {
      {
#line 182
      usage(stderr);
      }
    }
  }
#line 184
  *op_found = 1;
#line 185
  nvramtool_op.op = op;
#line 186
  nvramtool_op.param = op_param;
#line 187
  return;
}
}
#line 196 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static int found_seq  =    0;
#line 195 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static void register_op_modifier(nvramtool_op_modifier_t mod , char *mod_param ) 
{ 
  nvramtool_op_modifier_info_t *mod_info ;

  {
#line 199
  mod_info = & nvramtool_op_modifiers[mod];
#line 200
  mod_info->found = 1;
#line 201
  found_seq ++;
#line 201
  mod_info->found_seq = found_seq;
#line 202
  mod_info->param = mod_param;
#line 203
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static void resolve_op_modifiers(void) 
{ 


  {
#line 212
  if (nvramtool_op_modifiers[1].found) {
#line 212
    if (nvramtool_op_modifiers[2].found) {
#line 214
      if (nvramtool_op_modifiers[1].found_seq > nvramtool_op_modifiers[2].found_seq) {
#line 216
        nvramtool_op_modifiers[2].found = 0;
      } else {
#line 218
        nvramtool_op_modifiers[1].found = 0;
      }
    }
  }
#line 220
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/opts.c"
static void sanity_check_args(void) 
{ 


  {
#line 228
  if (nvramtool_op_modifiers[0].found) {
#line 228
    if ((unsigned int )nvramtool_op.op != 5U) {
      {
#line 230
      usage(stderr);
      }
    }
  }
#line 231
  return;
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 34 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
char const   prog_name[10]  = 
#line 34 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
  {      (char const   )'n',      (char const   )'v',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )'t',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
#line 37 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
char const   prog_version[4]  = {      (char const   )'2',      (char const   )'.',      (char const   )'1',      (char const   )'\000'};
#line 45 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
int get_line_from_file(FILE *f , char *line , int line_buf_size ) 
{ 
  char *tmp ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 46
  tmp = fgets((char */* __restrict  */)line, line_buf_size, (FILE */* __restrict  */)f);
  }
#line 46
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 47
    return (65536);
  }
  {
#line 53
  tmp___2 = strlen((char const   *)line);
  }
#line 53
  if (tmp___2 == (size_t )(line_buf_size - 1)) {
#line 53
    tmp___1 = 65537;
  } else {
#line 53
    tmp___1 = 0;
  }
#line 53
  return (tmp___1);
}
}
#line 62 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
void out_of_memory(void) 
{ 


  {
  {
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Out of memory.\n",
          prog_name);
#line 64
  exit(1);
  }
}
}
#line 73 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/common.c"
void usage(FILE *outfile ) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Usage: %s [-y LAYOUT_FILE | -t] PARAMETER ...\n\n       Read/write coreboot parameters or show info from coreboot table.\n\n       -y LAYOUT_FILE: Use CMOS layout specified by LAYOUT_FILE.\n       -t:             Use CMOS layout specified by CMOS option table.\n       [-n] -r NAME:   Show parameter NAME.  If -n is given, show value only.\n       -e NAME:        Show all possible values for parameter NAME.\n       -a:             Show names and values for all parameters.\n       -w NAME=VALUE:  Set parameter NAME to VALUE.\n       -p INPUT_FILE:  Set parameters according to INPUT_FILE.\n       -i:             Same as -p but file contents taken from standard input.\n       -c [VALUE]:     Show CMOS checksum or set checksum to VALUE.\n       -l [ARG]:       Show coreboot table info for ARG, or all ARG choices.\n       -d:             Show low-level dump of coreboot table.\n       -Y:             Show CMOS layout info.\n       -b OUTPUT_FILE: Dump CMOS memory contents to file.\n       -B INPUT_FILE:  Write file contents to CMOS memory.\n       -x:             Show hex dump of CMOS memory.\n       -X DUMPFILE:    Show hex dump of CMOS dumpfile.\n       -v:             Show version info for this program.\n       -h:             Show this message.\n",
          prog_name);
#line 104
  exit((unsigned long )outfile == (unsigned long )stderr);
  }
}
}
#line 38 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
static unsigned int cmos_bit_op_strategy(unsigned int bit , unsigned int bits_left ,
                                         cmos_bit_op_location_t *where ) ;
#line 43
static unsigned char cmos_read_bits(cmos_bit_op_location_t const   *where , unsigned int nr_bits ) ;
#line 45
static void cmos_write_bits(cmos_bit_op_location_t const   *where , unsigned int nr_bits ,
                            unsigned char value ) ;
#line 47
__inline static unsigned char get_bits(unsigned long long value , unsigned int bit ,
                                       unsigned int nr_bits ) ;
#line 49
__inline static void put_bits(unsigned char value , unsigned int bit , unsigned int nr_bits ,
                              unsigned long long *result ) ;
#line 58 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
__inline static unsigned char get_bits(unsigned long long value , unsigned int bit ,
                                       unsigned int nr_bits ) 
{ 


  {
#line 60
  return ((unsigned char )((value >> bit) & (unsigned long long )((unsigned char )((1 << nr_bits) - 1))));
}
}
#line 70 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
__inline static void put_bits(unsigned char value , unsigned int bit , unsigned int nr_bits ,
                              unsigned long long *result ) 
{ 


  {
#line 72
  *result += (unsigned long long )((int )value & (int )((unsigned char )((1 << nr_bits) - 1))) << bit;
#line 72
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
unsigned long long cmos_read(cmos_entry_t const   *e ) 
{ 
  cmos_bit_op_location_t where ;
  unsigned int bit ;
  unsigned int length ;
  unsigned int next_bit ;
  unsigned int bits_left ;
  unsigned int nr_bits ;
  unsigned long long result ;
  unsigned char value ;
  int tmp ;
  char *newstring ;
  void *tmp___0 ;
  unsigned int usize ;
  unsigned int tmp___1 ;

  {
  {
#line 83
  bit = (unsigned int )e->bit;
#line 83
  length = (unsigned int )e->length;
#line 85
  result = 0ULL;
#line 88
  tmp = verify_cmos_op(bit, length, (cmos_entry_config_t )e->config);
  }
#line 88
  if (tmp) {
    {
#line 88
    __assert_fail("!verify_cmos_op(bit, length, e->config)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                  88U, "cmos_read");
    }
  }
#line 89
  result = 0ULL;
#line 91
  if ((unsigned int const   )e->config == 2U) {
    {
#line 92
    tmp___0 = malloc((size_t )((length + 7U) / 8U));
#line 92
    newstring = (char *)tmp___0;
#line 93
    usize = (unsigned int )(8UL * sizeof(unsigned long long ));
    }
#line 95
    if (! newstring) {
      {
#line 95
      out_of_memory();
      }
    }
#line 97
    next_bit = 0U;
#line 97
    bits_left = length;
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;
#line 97
      if (! bits_left) {
#line 97
        goto while_break;
      }
#line 100
      if (bits_left > usize) {
#line 100
        tmp___1 = usize;
      } else {
#line 100
        tmp___1 = bits_left;
      }
      {
#line 100
      nr_bits = cmos_bit_op_strategy(bit + next_bit, tmp___1, & where);
#line 101
      value = cmos_read_bits((cmos_bit_op_location_t const   *)(& where), nr_bits);
#line 102
      put_bits(value, next_bit % usize, nr_bits, (unsigned long long *)newstring + next_bit / usize);
#line 103
      result = (unsigned long long )((unsigned long )newstring);
#line 97
      next_bit += nr_bits;
#line 97
      bits_left -= nr_bits;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 107
    next_bit = 0U;
#line 107
    bits_left = length;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! bits_left) {
#line 107
        goto while_break___0;
      }
      {
#line 110
      nr_bits = cmos_bit_op_strategy(bit + next_bit, bits_left, & where);
#line 111
      value = cmos_read_bits((cmos_bit_op_location_t const   *)(& where), nr_bits);
#line 112
      put_bits(value, next_bit, nr_bits, & result);
#line 107
      next_bit += nr_bits;
#line 107
      bits_left -= nr_bits;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 116
  return (result);
}
}
#line 126 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
void cmos_write(cmos_entry_t const   *e , unsigned long long value ) 
{ 
  cmos_bit_op_location_t where ;
  unsigned int bit ;
  unsigned int length ;
  unsigned int next_bit ;
  unsigned int bits_left ;
  unsigned int nr_bits ;
  int tmp ;
  unsigned long long *data ;
  unsigned int usize ;
  unsigned int tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
  {
#line 128
  bit = (unsigned int )e->bit;
#line 128
  length = (unsigned int )e->length;
#line 131
  tmp = verify_cmos_op(bit, length, (cmos_entry_config_t )e->config);
  }
#line 131
  if (tmp) {
    {
#line 131
    __assert_fail("!verify_cmos_op(bit, length, e->config)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                  131U, "cmos_write");
    }
  }
#line 133
  if ((unsigned int const   )e->config == 2U) {
#line 134
    data = (unsigned long long *)((unsigned long )value);
#line 135
    usize = (unsigned int )(8UL * sizeof(unsigned long long ));
#line 137
    next_bit = 0U;
#line 137
    bits_left = length;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! bits_left) {
#line 137
        goto while_break;
      }
#line 140
      if (bits_left > usize) {
#line 140
        tmp___0 = usize;
      } else {
#line 140
        tmp___0 = bits_left;
      }
      {
#line 140
      nr_bits = cmos_bit_op_strategy(bit + next_bit, tmp___0, & where);
#line 141
      value = *(data + next_bit / usize);
#line 142
      tmp___1 = get_bits(value, next_bit % usize, nr_bits);
#line 142
      cmos_write_bits((cmos_bit_op_location_t const   *)(& where), nr_bits, tmp___1);
#line 137
      next_bit += nr_bits;
#line 137
      bits_left -= nr_bits;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 146
    next_bit = 0U;
#line 146
    bits_left = length;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! bits_left) {
#line 146
        goto while_break___0;
      }
      {
#line 149
      nr_bits = cmos_bit_op_strategy(bit + next_bit, bits_left, & where);
#line 150
      tmp___2 = get_bits(value, next_bit, nr_bits);
#line 150
      cmos_write_bits((cmos_bit_op_location_t const   *)(& where), nr_bits, tmp___2);
#line 146
      next_bit += nr_bits;
#line 146
      bits_left -= nr_bits;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 153
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
unsigned char cmos_read_byte(unsigned int index___0 ) 
{ 
  unsigned short port_0 ;
  unsigned short port_1 ;
  int tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 168
  tmp = verify_cmos_byte_index(index___0);
  }
#line 168
  if (tmp) {
    {
#line 168
    __assert_fail("!verify_cmos_byte_index(index)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                  168U, "cmos_read_byte");
    }
  }
#line 170
  if (index___0 < 128U) {
#line 171
    port_0 = (unsigned short)112;
#line 172
    port_1 = (unsigned short)113;
  } else {
#line 175
    port_0 = (unsigned short)114;
#line 176
    port_1 = (unsigned short)115;
  }
  {
#line 179
  outb((unsigned char )index___0, port_0);
#line 180
  tmp___0 = inb(port_1);
  }
#line 180
  return (tmp___0);
}
}
#line 193 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
void cmos_write_byte(unsigned int index___0 , unsigned char value ) 
{ 
  unsigned short port_0 ;
  unsigned short port_1 ;
  int tmp ;

  {
  {
#line 196
  tmp = verify_cmos_byte_index(index___0);
  }
#line 196
  if (tmp) {
    {
#line 196
    __assert_fail("!verify_cmos_byte_index(index)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                  196U, "cmos_write_byte");
    }
  }
#line 198
  if (index___0 < 128U) {
#line 199
    port_0 = (unsigned short)112;
#line 200
    port_1 = (unsigned short)113;
  } else {
#line 203
    port_0 = (unsigned short)114;
#line 204
    port_1 = (unsigned short)115;
  }
  {
#line 207
  outb((unsigned char )index___0, port_0);
#line 208
  outb(value, port_1);
  }
#line 209
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
void cmos_read_all(unsigned char *data ) 
{ 
  unsigned int i ;

  {
#line 220
  i = 0U;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < 14U)) {
#line 220
      goto while_break;
    }
#line 221
    *(data + i) = (unsigned char)0;
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! (i < 256U)) {
#line 223
      goto while_break___0;
    }
    {
#line 224
    *(data + i) = cmos_read_byte(i);
#line 223
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
void cmos_write_all(unsigned char *data ) 
{ 
  unsigned int i ;

  {
#line 237
  i = 14U;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 256U)) {
#line 237
      goto while_break;
    }
    {
#line 238
    cmos_write_byte(i, *(data + i));
#line 237
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
void set_iopl(int level ) 
{ 
  int tmp ;

  {
#line 251
  if (level >= 0) {
#line 251
    if (! (level <= 3)) {
      {
#line 251
      __assert_fail("(level >= 0) && (level <= 3)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                    251U, "set_iopl");
      }
    }
  } else {
    {
#line 251
    __assert_fail("(level >= 0) && (level <= 3)", "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c",
                  251U, "set_iopl");
    }
  }
  {
#line 253
  tmp = iopl(level);
  }
#line 253
  if (tmp) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: iopl() system call failed.  You must be root to do this.\n",
            prog_name);
#line 258
    exit(1);
    }
  }
#line 260
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
int verify_cmos_op(unsigned int bit , unsigned int length , cmos_entry_config_t config ) 
{ 


  {
#line 272
  if (bit >= 2048U) {
#line 273
    return (196608);
  } else
#line 272
  if (bit + length > 2048U) {
#line 273
    return (196608);
  }
#line 275
  if (bit < 112U) {
#line 276
    return (196609);
  }
#line 278
  if ((unsigned int )config == 2U) {
#line 279
    return (0);
  }
#line 281
  if ((unsigned long )length > 8UL * sizeof(unsigned long long )) {
#line 282
    return (196610);
  }
#line 284
  return (0);
}
}
#line 293 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
static unsigned int cmos_bit_op_strategy(unsigned int bit , unsigned int bits_left ,
                                         cmos_bit_op_location_t *where ) 
{ 
  unsigned int max_bits ;
  unsigned int tmp ;

  {
#line 297
  where->byte_index = bit >> 3;
#line 298
  where->bit_offset = bit & 7U;
#line 299
  max_bits = 8U - where->bit_offset;
#line 300
  if (bits_left > max_bits) {
#line 300
    tmp = max_bits;
  } else {
#line 300
    tmp = bits_left;
  }
#line 300
  return (tmp);
}
}
#line 309 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
static unsigned char cmos_read_bits(cmos_bit_op_location_t const   *where , unsigned int nr_bits ) 
{ 
  unsigned char tmp ;

  {
  {
#line 311
  tmp = cmos_read_byte((unsigned int )where->byte_index);
  }
#line 311
  return ((unsigned char )(((int )tmp >> where->bit_offset) & (int )((unsigned char )((1 << nr_bits) - 1))));
}
}
#line 321 "/home/wheatley/newnew/temp/nvramtool-0.0+r3669/cmos_lowlevel.c"
static void cmos_write_bits(cmos_bit_op_location_t const   *where , unsigned int nr_bits ,
                            unsigned char value ) 
{ 
  unsigned char n ;
  unsigned char mask ;

  {
#line 325
  if (nr_bits == 8U) {
    {
#line 326
    cmos_write_byte((unsigned int )where->byte_index, value);
    }
#line 327
    return;
  }
  {
#line 330
  n = cmos_read_byte((unsigned int )where->byte_index);
#line 331
  mask = (unsigned char )((int )((unsigned char )((1 << nr_bits) - 1)) << where->bit_offset);
#line 332
  n = (unsigned char )(((int )n & ~ ((int )mask)) + (((int )value << where->bit_offset) & (int )mask));
#line 333
  cmos_write_byte((unsigned int )where->byte_index, n);
  }
#line 334
  return;
}
}
