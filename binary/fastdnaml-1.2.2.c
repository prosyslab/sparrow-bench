/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 74 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef char yType;
#line 79 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef int boolean;
#line 80 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef double xtype;
#line 82 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct likelihood_vector {
   xtype a ;
   xtype c ;
   xtype g ;
   xtype t ;
   long exp ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct likelihood_vector likelivector;
#line 87
struct noderec;
#line 87 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct xmantyp {
   struct xmantyp *prev ;
   struct xmantyp *next ;
   struct noderec *owner ;
   likelivector *lv ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct xmantyp xarray;
#line 94 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct noderec {
   double z ;
   double z0 ;
   struct noderec *next ;
   struct noderec *back ;
   int number ;
   xarray *x ;
   int xcoord ;
   int ycoord ;
   int ymin ;
   int ymax ;
   char name[11] ;
   yType *tip ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct noderec node;
#line 94 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct noderec *nodeptr;
#line 105 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_rawdata_8 {
   int numsp ;
   int sites ;
   yType **y ;
   boolean freqread ;
   double freqa ;
   double freqc ;
   double freqg ;
   double freqt ;
   double freqr ;
   double freqy ;
   double invfreqr ;
   double invfreqy ;
   double freqar ;
   double freqcy ;
   double freqgr ;
   double freqty ;
   double ttratio ;
   double xi ;
   double xv ;
   double fracchange ;
   int *wgt ;
   int *wgt2 ;
   int categs ;
   double catrat[36] ;
   int *sitecat ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_rawdata_8 rawdata;
#line 123 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_cruncheddata_9 {
   int *alias ;
   int *aliaswgt ;
   int endsite ;
   int wgtsum ;
   int *patcat ;
   double *patrat ;
   double *wr ;
   double *wr2 ;
};
#line 123 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_cruncheddata_9 cruncheddata;
#line 134 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_tree_10 {
   double likelihood ;
   double *log_f ;
   node **nodep ;
   node *start ;
   node *outgrnode ;
   int mxtips ;
   int ntips ;
   int nextnode ;
   int opt_level ;
   int log_f_valid ;
   int global ;
   int partswap ;
   int outgr ;
   boolean prelabeled ;
   boolean smoothed ;
   boolean rooted ;
   boolean userlen ;
   rawdata *rdta ;
   cruncheddata *cdta ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_tree_10 tree;
#line 156 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct conntyp {
   double z ;
   node *p ;
   node *q ;
   void *valptr ;
   int descend ;
   int sibling ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct conntyp connect;
#line 156 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct conntyp *connptr;
#line 164 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_topol_11 {
   double likelihood ;
   double *log_f ;
   connect *links ;
   node *start ;
   int nextlink ;
   int ntips ;
   int nextnode ;
   int opt_level ;
   int scrNum ;
   int tplNum ;
   int log_f_valid ;
   boolean prelabeled ;
   boolean smoothed ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_topol_11 topol;
#line 181 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_bestlist_12 {
   double best ;
   double worst ;
   topol *start ;
   topol **byScore ;
   topol **byTopol ;
   int nkeep ;
   int nvalid ;
   int ninit ;
   int numtrees ;
   boolean improved ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_bestlist_12 bestlist;
#line 194 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_analdef_13 {
   long boot ;
   int extra ;
   boolean empf ;
   boolean interleaved ;
   long jumble ;
   int nkeep ;
   int numutrees ;
   boolean prdata ;
   boolean qadd ;
   boolean restart ;
   boolean root ;
   boolean trprint ;
   int trout ;
   boolean usertree ;
   boolean userwgt ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_analdef_13 analdef;
#line 212 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
struct __anonstruct_drawdata_14 {
   double tipmax ;
   int tipy ;
};
#line 212 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
typedef struct __anonstruct_drawdata_14 drawdata;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
extern void exit() ;
#line 222
extern char *malloc() ;
#line 231 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
char *likelihood_key  =    (char *)"likelihood";
#line 232 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
char *ntaxa_key  =    (char *)"ntaxa";
#line 233 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
char *opt_level_key  =    (char *)"opt_level";
#line 234 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.h"
char *smoothed_key  =    (char *)"smoothed";
#line 216 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
xarray *usedxtip  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
xarray *freextip  ;
#line 291 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void *tipValPtr(nodeptr p ) 
{ 


  {
#line 292
  return ((void *)(& p->number));
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int cmpTipVal(void *v1 , void *v2 ) 
{ 
  int i1 ;
  int i2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 300
  i1 = *((int *)v1);
#line 301
  i2 = *((int *)v2);
#line 302
  if (i1 < i2) {
#line 302
    tmp___0 = -1;
  } else {
#line 302
    if (i1 == i2) {
#line 302
      tmp = 0;
    } else {
#line 302
      tmp = 1;
    }
#line 302
    tmp___0 = tmp;
  }
#line 302
  return (tmp___0);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
topol *setupTopol(int maxtips , int nsites ) 
{ 
  topol *tpl ;
  char *tmp ;
  connect *tmp___0 ;
  char *tmp___1 ;
  double *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 313
  tmp = malloc((unsigned int )sizeof(topol ));
#line 313
  tpl = (topol *)tmp;
  }
#line 313
  if (tpl) {
    {
#line 313
    tmp___1 = malloc((unsigned int )((unsigned long )(2 * maxtips - 3) * sizeof(connect )));
#line 313
    tmp___0 = (connptr )tmp___1;
#line 313
    tpl->links = tmp___0;
    }
#line 313
    if (tmp___0) {
#line 313
      if (nsites) {
        {
#line 313
        tmp___3 = malloc((unsigned int )((unsigned long )nsites * sizeof(double )));
#line 313
        tmp___2 = (double *)tmp___3;
#line 313
        tpl->log_f = tmp___2;
        }
#line 313
        if (tmp___2) {
#line 313
          goto _L;
        } else {
          {
#line 317
          printf((char const   */* __restrict  */)"ERROR: Unable to get topology memory");
#line 318
          tpl = (topol *)((void *)0);
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 322
        if (nsites == 0) {
#line 322
          tpl->log_f = (double *)((void *)0);
        }
#line 323
        tpl->likelihood = - 1.0E300;
#line 324
        tpl->start = (node *)((void *)0);
#line 325
        tpl->nextlink = 0;
#line 326
        tpl->ntips = 0;
#line 327
        tpl->nextnode = 0;
#line 328
        tpl->opt_level = 0;
#line 329
        tpl->scrNum = 0;
#line 330
        tpl->tplNum = 0;
#line 331
        tpl->log_f_valid = 0;
#line 332
        tpl->prelabeled = 1;
#line 333
        tpl->smoothed = 0;
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"ERROR: Unable to get topology memory");
#line 318
      tpl = (topol *)((void *)0);
      }
    }
  } else {
    {
#line 317
    printf((char const   */* __restrict  */)"ERROR: Unable to get topology memory");
#line 318
    tpl = (topol *)((void *)0);
    }
  }
#line 336
  return (tpl);
}
}
#line 342
extern int ( /* missing proto */  free)() ;
#line 340 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void freeTopol(topol *tpl ) 
{ 


  {
  {
#line 342
  free((char *)tpl->links);
  }
#line 343
  if (tpl->log_f) {
    {
#line 343
    free((char *)tpl->log_f);
    }
  }
  {
#line 344
  free((char *)tpl);
  }
#line 345
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int saveSubtree(nodeptr p , topol *tpl ) 
{ 
  connptr r ;
  connptr r0 ;
  nodeptr q ;
  nodeptr s ;
  int t ;
  int t0 ;
  int t1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 358
  r0 = tpl->links;
#line 359
  tmp = tpl->nextlink;
#line 359
  (tpl->nextlink) ++;
#line 359
  r = r0 + tmp;
#line 360
  r->p = p;
#line 361
  q = p->back;
#line 361
  r->q = q;
#line 362
  r->z = p->z;
#line 363
  r->descend = 0;
#line 365
  if (q->tip) {
    {
#line 366
    r->valptr = tipValPtr(q);
    }
  } else {
#line 370
    s = q->next;
    {
#line 371
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 372
      t = saveSubtree(s, tpl);
#line 374
      t0 = 0;
#line 375
      t1 = r->descend;
      }
      {
#line 376
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 376
        if (t1) {
          {
#line 376
          tmp___0 = cmpTipVal((r0 + t1)->valptr, (r0 + t)->valptr);
          }
#line 376
          if (! (tmp___0 < 0)) {
#line 376
            goto while_break___0;
          }
        } else {
#line 376
          goto while_break___0;
        }
#line 377
        t0 = t1;
#line 378
        t1 = (r0 + t1)->sibling;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 380
      if (t0) {
#line 380
        (r0 + t0)->sibling = t;
      } else {
#line 380
        r->descend = t;
      }
#line 381
      (r0 + t)->sibling = t1;
#line 383
      s = s->next;
#line 371
      if (! ((unsigned long )s != (unsigned long )q)) {
#line 371
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 386
    r->valptr = (r0 + r->descend)->valptr;
  }
#line 389
  return ((int )(r - r0));
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
nodeptr minSubtreeTip(nodeptr p0 ) 
{ 
  nodeptr minTip ;
  nodeptr p ;
  nodeptr testTip ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 397
  if (p0->tip) {
#line 397
    return (p0);
  }
  {
#line 399
  p = p0->next;
#line 400
  minTip = minSubtreeTip(p->back);
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    p = p->next;
#line 401
    if (! ((unsigned long )p != (unsigned long )p0)) {
#line 401
      goto while_break;
    }
    {
#line 402
    testTip = minSubtreeTip(p->back);
#line 403
    tmp = tipValPtr(minTip);
#line 403
    tmp___0 = tipValPtr(testTip);
#line 403
    tmp___1 = cmpTipVal(tmp___0, tmp);
    }
#line 403
    if (tmp___1 < 0) {
#line 404
      minTip = testTip;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (minTip);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
nodeptr minTreeTip(nodeptr p ) 
{ 
  nodeptr minp ;
  nodeptr minpb ;
  nodeptr tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 414
  minp = minSubtreeTip(p);
#line 415
  minpb = minSubtreeTip(p->back);
#line 416
  tmp___3 = tipValPtr(minpb);
#line 416
  tmp___4 = tipValPtr(minp);
#line 416
  tmp___5 = cmpTipVal(tmp___4, tmp___3);
  }
#line 416
  if (tmp___5 < 0) {
#line 416
    tmp___2 = minp;
  } else {
#line 416
    tmp___2 = minpb;
  }
#line 416
  return (tmp___2);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void saveTree(tree *tr , topol *tpl ) 
{ 
  connptr r ;
  double *tr_log_f ;
  double *tpl_log_f ;
  int i ;
  nodeptr tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double *tmp___2 ;
  double *tmp___3 ;

  {
  {
#line 430
  tpl->nextlink = 0;
#line 431
  tmp = minTreeTip(tr->start);
#line 431
  tmp___0 = saveSubtree(tmp, tpl);
#line 431
  r = tpl->links + tmp___0;
#line 432
  r->sibling = 0;
#line 434
  tpl->likelihood = tr->likelihood;
#line 435
  tpl->start = tr->start;
#line 436
  tpl->ntips = tr->ntips;
#line 437
  tpl->nextnode = tr->nextnode;
#line 438
  tpl->opt_level = tr->opt_level;
#line 439
  tpl->prelabeled = tr->prelabeled;
#line 440
  tpl->smoothed = tr->smoothed;
#line 442
  tpl_log_f = tpl->log_f;
  }
#line 442
  if (tpl_log_f) {
#line 443
    tr_log_f = tr->log_f;
#line 444
    tmp___1 = tr->log_f_valid;
#line 444
    tpl->log_f_valid = tmp___1;
#line 444
    i = tmp___1;
    {
#line 445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      i --;
#line 445
      if (! (i >= 0)) {
#line 445
        goto while_break;
      }
#line 445
      tmp___2 = tpl_log_f;
#line 445
      tpl_log_f ++;
#line 445
      tmp___3 = tr_log_f;
#line 445
      tr_log_f ++;
#line 445
      *tmp___2 = *tmp___3;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 448
    tpl->log_f_valid = 0;
  }
#line 450
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void copyTopol(topol *tpl1 , topol *tpl2 ) 
{ 
  connptr r1 ;
  connptr r2 ;
  connptr r10 ;
  connptr r20 ;
  double *tpl1_log_f ;
  double *tpl2_log_f ;
  int i ;
  double *tmp ;
  double *tmp___0 ;

  {
#line 459
  r10 = tpl1->links;
#line 460
  r20 = tpl2->links;
#line 461
  tpl2->nextlink = tpl1->nextlink;
#line 463
  r1 = r10;
#line 464
  r2 = r20;
#line 465
  i = 2 * tpl1->ntips - 3;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    i --;
#line 466
    if (! (i >= 0)) {
#line 466
      goto while_break;
    }
#line 467
    r2->z = r1->z;
#line 468
    r2->p = r1->p;
#line 469
    r2->q = r1->q;
#line 470
    r2->valptr = r1->valptr;
#line 471
    r2->descend = r1->descend;
#line 472
    r2->sibling = r1->sibling;
#line 473
    r1 ++;
#line 474
    r2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  if (tpl1->log_f_valid) {
#line 477
    if (tpl2->log_f) {
#line 478
      tpl1_log_f = tpl1->log_f;
#line 479
      tpl2_log_f = tpl2->log_f;
#line 480
      i = tpl1->log_f_valid;
#line 480
      tpl2->log_f_valid = i;
      {
#line 481
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 481
        i --;
#line 481
        if (! (i >= 0)) {
#line 481
          goto while_break___0;
        }
#line 481
        tmp = tpl2_log_f;
#line 481
        tpl2_log_f ++;
#line 481
        tmp___0 = tpl1_log_f;
#line 481
        tpl1_log_f ++;
#line 481
        *tmp = *tmp___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 484
      tpl2->log_f_valid = 0;
    }
  } else {
#line 484
    tpl2->log_f_valid = 0;
  }
#line 487
  tpl2->likelihood = tpl1->likelihood;
#line 488
  tpl2->start = tpl1->start;
#line 489
  tpl2->ntips = tpl1->ntips;
#line 490
  tpl2->nextnode = tpl1->nextnode;
#line 491
  tpl2->opt_level = tpl1->opt_level;
#line 492
  tpl2->prelabeled = tpl1->prelabeled;
#line 493
  tpl2->scrNum = tpl1->scrNum;
#line 494
  tpl2->tplNum = tpl1->tplNum;
#line 495
  tpl2->smoothed = tpl1->smoothed;
#line 496
  return;
}
}
#line 501
void hookup(nodeptr p , nodeptr q , double z ) ;
#line 502
boolean initrav(tree *tr , nodeptr p ) ;
#line 499 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean restoreTree(topol *tpl , tree *tr ) 
{ 
  connptr r ;
  nodeptr p ;
  nodeptr p0 ;
  double *tr_log_f ;
  double *tpl_log_f ;
  int i ;
  int tmp ;
  double *tmp___0 ;
  double *tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  int tmp___4 ;

  {
#line 511
  i = 1;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! (i <= 2 * tr->mxtips - 2)) {
#line 511
      goto while_break;
    }
#line 512
    p = *(tr->nodep + i);
#line 512
    p0 = p;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 514
      p->back = (nodeptr )((void *)0);
#line 515
      p = p->next;
#line 513
      if (! ((unsigned long )p != (unsigned long )p0)) {
#line 513
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 511
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  r = tpl->links;
#line 521
  i = 0;
  {
#line 521
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 521
    if (! (i < tpl->nextlink)) {
#line 521
      goto while_break___1;
    }
    {
#line 522
    hookup(r->p, r->q, r->z);
#line 521
    r ++;
#line 521
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 525
  tr->likelihood = tpl->likelihood;
#line 526
  tr->start = tpl->start;
#line 527
  tr->ntips = tpl->ntips;
#line 528
  tr->nextnode = tpl->nextnode;
#line 529
  tr->opt_level = tpl->opt_level;
#line 530
  tr->prelabeled = tpl->prelabeled;
#line 531
  tr->smoothed = tpl->smoothed;
#line 533
  tpl_log_f = tpl->log_f;
#line 533
  if (tpl_log_f) {
#line 534
    tr_log_f = tr->log_f;
#line 535
    tmp = tpl->log_f_valid;
#line 535
    tr->log_f_valid = tmp;
#line 535
    i = tmp;
    {
#line 536
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 536
      i --;
#line 536
      if (! (i >= 0)) {
#line 536
        goto while_break___2;
      }
#line 536
      tmp___0 = tr_log_f;
#line 536
      tr_log_f ++;
#line 536
      tmp___1 = tpl_log_f;
#line 536
      tpl_log_f ++;
#line 536
      *tmp___0 = *tmp___1;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 539
    tr->log_f_valid = 0;
  }
  {
#line 542
  tmp___2 = initrav(tr, tr->start);
  }
#line 542
  if (tmp___2) {
    {
#line 542
    tmp___3 = initrav(tr, (tr->start)->back);
    }
#line 542
    if (tmp___3) {
#line 542
      tmp___4 = 1;
    } else {
#line 542
      tmp___4 = 0;
    }
  } else {
#line 542
    tmp___4 = 0;
  }
#line 542
  return (tmp___4);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int initBestTree(bestlist *bt , int newkeep , int numsp , int sites ) 
{ 
  int i ;
  int nlogf ;
  topol *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  topol *tmp___3 ;
  int tmp___4 ;

  {
#line 551
  bt->nkeep = 0;
#line 553
  if (bt->ninit <= 0) {
    {
#line 554
    tmp = setupTopol(numsp, sites);
#line 554
    bt->start = tmp;
    }
#line 554
    if (! tmp) {
#line 554
      return (0);
    }
    {
#line 555
    bt->ninit = -1;
#line 556
    bt->nvalid = 0;
#line 557
    bt->numtrees = 0;
#line 558
    bt->best = - 1.0E300;
#line 559
    bt->improved = 0;
#line 560
    tmp___0 = malloc((unsigned int )((unsigned long )(newkeep + 1) * sizeof(topol *)));
#line 560
    bt->byScore = (topol **)tmp___0;
#line 561
    tmp___1 = malloc((unsigned int )((unsigned long )(newkeep + 1) * sizeof(topol *)));
#line 561
    bt->byTopol = (topol **)tmp___1;
    }
#line 562
    if (! bt->byScore) {
      {
#line 563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"initBestTree: Malloc failure\n");
      }
#line 564
      return (0);
    } else
#line 562
    if (! bt->byTopol) {
      {
#line 563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"initBestTree: Malloc failure\n");
      }
#line 564
      return (0);
    }
  } else {
#line 567
    if (newkeep < 0) {
#line 567
      tmp___2 = - newkeep;
    } else {
#line 567
      tmp___2 = newkeep;
    }
#line 567
    if (tmp___2 > bt->ninit) {
#line 568
      if (newkeep < 0) {
#line 568
        newkeep = - bt->ninit;
      } else {
#line 569
        newkeep = bt->ninit;
      }
    }
  }
#line 572
  if (newkeep < 1) {
#line 573
    newkeep = - newkeep;
#line 574
    if (newkeep < 1) {
#line 574
      newkeep = 1;
    }
#line 575
    bt->nvalid = 0;
#line 576
    bt->best = - 1.0E300;
  }
#line 579
  if (bt->nvalid >= newkeep) {
#line 580
    bt->nvalid = newkeep;
#line 581
    bt->worst = (*(bt->byScore + newkeep))->likelihood;
  } else {
#line 584
    bt->worst = - 1.0E300;
  }
#line 587
  i = bt->ninit + 1;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (i <= newkeep)) {
#line 587
      goto while_break;
    }
#line 588
    if (i <= 1024) {
#line 588
      nlogf = sites;
    } else {
#line 588
      nlogf = 0;
    }
    {
#line 589
    tmp___3 = setupTopol(numsp, nlogf);
#line 589
    *(bt->byScore + i) = tmp___3;
    }
#line 589
    if (! tmp___3) {
#line 589
      goto while_break;
    }
#line 590
    *(bt->byTopol + i) = *(bt->byScore + i);
#line 591
    bt->ninit = i;
#line 587
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  if (newkeep < bt->ninit) {
#line 594
    tmp___4 = newkeep;
  } else {
#line 594
    tmp___4 = bt->ninit;
  }
#line 594
  bt->nkeep = tmp___4;
#line 594
  return (tmp___4);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int resetBestTree(bestlist *bt ) 
{ 


  {
#line 601
  bt->best = - 1.0E300;
#line 602
  bt->worst = - 1.0E300;
#line 603
  bt->nvalid = 0;
#line 604
  bt->improved = 0;
#line 605
  return (0);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean freeBestTree(bestlist *bt ) 
{ 
  int tmp ;

  {
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (bt->ninit >= 0)) {
#line 610
      goto while_break;
    }
    {
#line 610
    tmp = bt->ninit;
#line 610
    (bt->ninit) --;
#line 610
    freeTopol(*(bt->byScore + tmp));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 611
  freeTopol(bt->start);
  }
#line 612
  return (1);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int cmpSubtopol(connptr p10 , connptr p1 , connptr p20 , connptr p2 ) 
{ 
  connptr p1d ;
  connptr p2d ;
  int cmp ;
  int tmp ;

  {
#line 628
  if (! p1->descend) {
#line 628
    if (! p2->descend) {
      {
#line 629
      tmp = cmpTipVal(p1->valptr, p2->valptr);
      }
#line 629
      return (tmp);
    }
  }
#line 631
  if (! p1->descend) {
#line 631
    return (-1);
  }
#line 632
  if (! p2->descend) {
#line 632
    return (1);
  }
#line 634
  p1d = p10 + p1->descend;
#line 635
  p2d = p20 + p2->descend;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 637
    cmp = cmpSubtopol(p10, p1d, p20, p2d);
    }
#line 637
    if (cmp) {
#line 637
      return (cmp);
    }
#line 638
    if (! p1d->sibling) {
#line 638
      if (! p2d->sibling) {
#line 638
        return (0);
      }
    }
#line 639
    if (! p1d->sibling) {
#line 639
      return (-1);
    }
#line 640
    if (! p2d->sibling) {
#line 640
      return (1);
    }
#line 641
    p1d = p10 + p1d->sibling;
#line 642
    p2d = p20 + p2d->sibling;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int cmpTopol(void *tpl1 , void *tpl2 ) 
{ 
  connptr r1 ;
  connptr r2 ;
  int cmp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 653
  r1 = ((topol *)tpl1)->links;
#line 654
  r2 = ((topol *)tpl2)->links;
#line 655
  tmp = tipValPtr(r2->p);
#line 655
  tmp___0 = tipValPtr(r1->p);
#line 655
  cmp = cmpTipVal(tmp___0, tmp);
  }
#line 656
  if (cmp) {
#line 656
    return (cmp);
  }
  {
#line 657
  tmp___1 = cmpSubtopol(r1, r1, r2, r2);
  }
#line 657
  return (tmp___1);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int cmpTplScore(void *tpl1 , void *tpl2 ) 
{ 
  double l1 ;
  double l2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 666
  l1 = ((topol *)tpl1)->likelihood;
#line 667
  l2 = ((topol *)tpl2)->likelihood;
#line 668
  if (l1 > l2) {
#line 668
    tmp___0 = -1;
  } else {
#line 668
    if (l1 == l2) {
#line 668
      tmp = 0;
    } else {
#line 668
      tmp = 1;
    }
#line 668
    tmp___0 = tmp;
  }
#line 668
  return (tmp___0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int findInList(void *item , void **list , int n , int (*cmpFunc)() ) 
{ 
  int mid ;
  int hi ;
  int lo ;
  int cmp ;

  {
#line 682
  if (n < 1) {
#line 682
    return (-1);
  }
#line 684
  lo = 1;
#line 685
  mid = 0;
#line 686
  hi = n;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (lo < hi)) {
#line 687
      goto while_break;
    }
    {
#line 688
    mid = (lo + hi) >> 1;
#line 689
    cmp = (*cmpFunc)(item, *(list + (mid - 1)));
    }
#line 690
    if (cmp) {
#line 691
      if (cmp < 0) {
#line 691
        hi = mid;
      } else {
#line 692
        lo = mid + 1;
      }
    } else {
#line 694
      return (mid);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  if (lo != mid) {
    {
#line 698
    cmp = (*cmpFunc)(item, *(list + (lo - 1)));
    }
#line 699
    if (cmp == 0) {
#line 699
      return (lo);
    }
  }
#line 701
  if (cmp > 0) {
#line 701
    lo ++;
  }
#line 702
  return (- lo);
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int findTreeInList(bestlist *bt , tree *tr ) 
{ 
  topol *tpl ;
  int tmp ;

  {
  {
#line 711
  tpl = *(bt->byScore + 0);
#line 712
  saveTree(tr, tpl);
#line 713
  tmp = findInList((void *)tpl, (void **)(bt->byTopol + 1), bt->nvalid, (int (*)())(& cmpTopol));
  }
#line 713
  return (tmp);
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int saveBestTree(bestlist *bt , tree *tr ) 
{ 
  double *tr_log_f ;
  double *tpl_log_f ;
  topol *tpl ;
  topol *reuse ;
  int tplNum ;
  int scrNum ;
  int reuseScrNum ;
  int reuseTplNum ;
  int i ;
  int oldValid ;
  int newValid ;
  topol *tmp ;
  topol *tmp___0 ;
  topol *tmp___1 ;
  topol *tmp___2 ;
  int tmp___3 ;
  double *tmp___4 ;
  double *tmp___5 ;
  topol *tmp___6 ;

  {
  {
#line 724
  tplNum = findTreeInList(bt, tr);
#line 725
  tpl = *(bt->byScore + 0);
#line 726
  newValid = bt->nvalid;
#line 726
  oldValid = newValid;
  }
#line 728
  if (tplNum > 0) {
#line 729
    reuse = *(bt->byTopol + tplNum);
#line 730
    reuseScrNum = reuse->scrNum;
#line 731
    reuseTplNum = reuse->tplNum;
  } else
#line 734
  if (tr->likelihood < bt->worst) {
#line 734
    return (0);
  } else {
#line 737
    tplNum = - tplNum;
#line 738
    if (newValid < bt->nkeep) {
#line 738
      newValid ++;
#line 738
      bt->nvalid = newValid;
    }
#line 739
    reuseScrNum = newValid;
#line 740
    reuse = *(bt->byScore + reuseScrNum);
#line 741
    if (newValid > oldValid) {
#line 741
      reuseTplNum = newValid;
    } else {
#line 741
      reuseTplNum = reuse->tplNum;
    }
#line 742
    if (tr->likelihood > (bt->start)->likelihood) {
#line 742
      bt->improved = 1;
    }
  }
  {
#line 745
  scrNum = findInList((void *)tpl, (void **)(bt->byScore + 1), oldValid, (int (*)())(& cmpTplScore));
  }
#line 747
  if (scrNum < 0) {
#line 747
    scrNum = - scrNum;
  } else {
#line 747
    scrNum = scrNum;
  }
#line 749
  if (scrNum < reuseScrNum) {
#line 750
    i = reuseScrNum;
    {
#line 750
    while (1) {
      while_continue: /* CIL Label */ ;
#line 750
      if (! (i > scrNum)) {
#line 750
        goto while_break;
      }
#line 751
      tmp = *(bt->byScore + (i - 1));
#line 751
      *(bt->byScore + i) = tmp;
#line 751
      tmp->scrNum = i;
#line 750
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 753
  if (scrNum > reuseScrNum) {
#line 754
    scrNum --;
#line 755
    i = reuseScrNum;
    {
#line 755
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 755
      if (! (i < scrNum)) {
#line 755
        goto while_break___0;
      }
#line 756
      tmp___0 = *(bt->byScore + (i + 1));
#line 756
      *(bt->byScore + i) = tmp___0;
#line 756
      tmp___0->scrNum = i;
#line 755
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 759
  if (tplNum < reuseTplNum) {
#line 760
    i = reuseTplNum;
    {
#line 760
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 760
      if (! (i > tplNum)) {
#line 760
        goto while_break___1;
      }
#line 761
      tmp___1 = *(bt->byTopol + (i - 1));
#line 761
      *(bt->byTopol + i) = tmp___1;
#line 761
      tmp___1->tplNum = i;
#line 760
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 763
  if (tplNum > reuseTplNum) {
#line 764
    tplNum --;
#line 765
    i = reuseTplNum;
    {
#line 765
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 765
      if (! (i < tplNum)) {
#line 765
        goto while_break___2;
      }
#line 766
      tmp___2 = *(bt->byTopol + (i + 1));
#line 766
      *(bt->byTopol + i) = tmp___2;
#line 766
      tmp___2->tplNum = i;
#line 765
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 769
  tpl_log_f = tpl->log_f;
#line 769
  if (tpl_log_f) {
#line 770
    tr_log_f = tr->log_f;
#line 771
    tmp___3 = tr->log_f_valid;
#line 771
    tpl->log_f_valid = tmp___3;
#line 771
    i = tmp___3;
    {
#line 772
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 772
      i --;
#line 772
      if (! (i >= 0)) {
#line 772
        goto while_break___3;
      }
#line 772
      tmp___4 = tpl_log_f;
#line 772
      tpl_log_f ++;
#line 772
      tmp___5 = tr_log_f;
#line 772
      tr_log_f ++;
#line 772
      *tmp___4 = *tmp___5;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 775
    tpl->log_f_valid = 0;
  }
#line 778
  tpl->scrNum = scrNum;
#line 779
  tpl->tplNum = tplNum;
#line 780
  tmp___6 = tpl;
#line 780
  *(bt->byScore + scrNum) = tmp___6;
#line 780
  *(bt->byTopol + tplNum) = tmp___6;
#line 781
  *(bt->byScore + 0) = reuse;
#line 783
  if (scrNum == 1) {
#line 783
    bt->best = tr->likelihood;
  }
#line 784
  if (newValid == bt->nkeep) {
#line 784
    bt->worst = (*(bt->byScore + newValid))->likelihood;
  }
#line 786
  return (scrNum);
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int startOpt(bestlist *bt , tree *tr ) 
{ 
  int scrNum ;

  {
  {
#line 794
  scrNum = saveBestTree(bt, tr);
#line 795
  copyTopol(*(bt->byScore + scrNum), bt->start);
#line 796
  bt->improved = 0;
  }
#line 797
  return (scrNum);
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int setOptLevel(bestlist *bt , int opt_level ) 
{ 
  int tplNum ;
  int scrNum ;

  {
  {
#line 805
  tplNum = findInList((void *)bt->start, (void **)(bt->byTopol + 1), bt->nvalid, (int (*)())(& cmpTopol));
  }
#line 807
  if (tplNum > 0) {
#line 808
    (*(bt->byTopol + tplNum))->opt_level = opt_level;
#line 809
    scrNum = (*(bt->byTopol + tplNum))->scrNum;
  } else {
#line 812
    scrNum = 0;
  }
#line 815
  return (scrNum);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int recallBestTree(bestlist *bt , int rank , tree *tr ) 
{ 
  boolean tmp ;

  {
#line 821
  if (rank < 1) {
#line 821
    rank = 1;
  }
#line 822
  if (rank > bt->nvalid) {
#line 822
    rank = bt->nvalid;
  }
#line 823
  if (rank > 0) {
    {
#line 823
    tmp = restoreTree(*(bt->byScore + rank), tr);
    }
#line 823
    if (! tmp) {
#line 823
      return (0);
    }
  }
#line 824
  return (rank);
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getnums(rawdata *rdta ) 
{ 
  int tmp ;

  {
  {
#line 844
  printf((char const   */* __restrict  */)"\n%s, version %s, %s,\nCopyright (C) 1998, 1999, 2000 by Gary J. Olsen\n\n",
         "fastDNAml", "1.2.2", "January 3, 2000");
#line 848
  printf((char const   */* __restrict  */)"Based in part on Joseph Felsenstein\'s\n\n");
#line 849
  printf((char const   */* __restrict  */)"   Nucleic acid sequence Maximum Likelihood method, version 3.3\n\n\n");
#line 851
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d %d",
               & rdta->numsp, & rdta->sites);
  }
#line 851
  if (tmp != 2) {
    {
#line 852
    printf((char const   */* __restrict  */)"ERROR: Problem reading number of species and sites\n");
    }
#line 853
    return (0);
  }
  {
#line 855
  printf((char const   */* __restrict  */)"%d Species, %d Sites\n\n", rdta->numsp,
         rdta->sites);
  }
#line 857
  if (rdta->numsp < 4) {
    {
#line 858
    printf((char const   */* __restrict  */)"TOO FEW SPECIES\n");
    }
#line 859
    return (0);
  }
#line 862
  if (rdta->sites < 1) {
    {
#line 863
    printf((char const   */* __restrict  */)"TOO FEW SITES\n");
    }
#line 864
    return (0);
  }
#line 867
  return (1);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean digitchar(int ch ) 
{ 
  int tmp ;

  {
#line 871
  if (ch >= 48) {
#line 871
    if (ch <= 57) {
#line 871
      tmp = 1;
    } else {
#line 871
      tmp = 0;
    }
  } else {
#line 871
    tmp = 0;
  }
#line 871
  return (tmp);
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean whitechar(int ch ) 
{ 
  int tmp ;

  {
#line 875
  if (ch == 32) {
#line 875
    tmp = 1;
  } else
#line 875
  if (ch == 10) {
#line 875
    tmp = 1;
  } else
#line 875
  if (ch == 9) {
#line 875
    tmp = 1;
  } else {
#line 875
    tmp = 0;
  }
#line 875
  return (tmp);
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void uppercase(int *chptr ) 
{ 
  int ch ;

  {
#line 884
  ch = *chptr;
#line 885
  if (ch >= 97) {
#line 885
    if (ch <= 105) {
#line 887
      *chptr = (ch + 65) - 97;
    } else {
#line 885
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 885
  if (ch >= 106) {
#line 885
    if (ch <= 114) {
#line 887
      *chptr = (ch + 65) - 97;
    } else {
#line 885
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 885
  if (ch >= 115) {
#line 885
    if (ch <= 122) {
#line 887
      *chptr = (ch + 65) - 97;
    }
  }
#line 888
  return;
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int base36(int ch ) 
{ 


  {
#line 893
  if (ch >= 48) {
#line 893
    if (ch <= 57) {
#line 893
      return (ch - 48);
    } else {
#line 893
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 894
  if (ch >= 65) {
#line 894
    if (ch <= 73) {
#line 894
      return ((ch - 65) + 10);
    } else {
#line 894
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 895
  if (ch >= 74) {
#line 895
    if (ch <= 82) {
#line 895
      return ((ch - 74) + 19);
    } else {
#line 895
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 896
  if (ch >= 83) {
#line 896
    if (ch <= 90) {
#line 896
      return ((ch - 83) + 28);
    } else {
#line 896
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 897
  if (ch >= 97) {
#line 897
    if (ch <= 105) {
#line 897
      return ((ch - 97) + 10);
    } else {
#line 897
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 898
  if (ch >= 106) {
#line 898
    if (ch <= 114) {
#line 898
      return ((ch - 106) + 19);
    } else {
#line 898
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 899
  if (ch >= 115) {
#line 899
    if (ch <= 122) {
#line 899
      return ((ch - 115) + 28);
    } else {
#line 900
      return (-1);
    }
  } else {
#line 900
    return (-1);
  }
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int itobase36(int i ) 
{ 


  {
#line 906
  if (i < 0) {
#line 906
    return ('?');
  } else
#line 907
  if (i < 10) {
#line 907
    return (i + 48);
  } else
#line 908
  if (i < 19) {
#line 908
    return ((i - 10) + 65);
  } else
#line 909
  if (i < 28) {
#line 909
    return ((i - 19) + 74);
  } else
#line 910
  if (i < 36) {
#line 910
    return ((i - 28) + 83);
  } else {
#line 911
    return ('?');
  }
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int findch(int c ) 
{ 
  int ch ;

  {
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 919
    ch = _IO_getc(stdin);
    }
#line 919
    if (ch != -1) {
#line 919
      if (! (ch != c)) {
#line 919
        goto while_break;
      }
    } else {
#line 919
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (ch);
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputboot(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 938
  if (! adef->boot) {
    {
#line 939
    printf((char const   */* __restrict  */)"ERROR: Unexpected Bootstrap auxiliary data line\n");
    }
#line 940
    return (0);
  } else {
    {
#line 942
    tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%ld",
                 & adef->boot);
    }
#line 942
    if (tmp != 1) {
      {
#line 944
      printf((char const   */* __restrict  */)"ERROR: Problem reading boostrap random seed value\n");
      }
#line 945
      return (0);
    } else {
      {
#line 942
      tmp___0 = findch('\n');
      }
#line 942
      if (tmp___0 == -1) {
        {
#line 944
        printf((char const   */* __restrict  */)"ERROR: Problem reading boostrap random seed value\n");
        }
#line 945
        return (0);
      }
    }
  }
#line 948
  return (1);
}
}
#line 952 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputcategories(rawdata *rdta ) 
{ 
  int i ;
  int j ;
  int ch ;
  int ci ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  boolean tmp___3 ;
  int tmp___4 ;

  {
#line 957
  if (rdta->categs >= 0) {
    {
#line 958
    printf((char const   */* __restrict  */)"ERROR: Unexpected Categories auxiliary data line\n");
    }
#line 959
    return (0);
  }
  {
#line 961
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
               & rdta->categs);
  }
#line 961
  if (tmp != 1) {
    {
#line 962
    printf((char const   */* __restrict  */)"ERROR: Problem reading number of rate categories\n");
    }
#line 963
    return (0);
  }
#line 965
  if (rdta->categs < 1) {
    {
#line 966
    printf((char const   */* __restrict  */)"ERROR: Bad number of categories: %d\n",
           rdta->categs);
#line 967
    printf((char const   */* __restrict  */)"Must be in range 1 - %d\n", 35);
    }
#line 968
    return (0);
  } else
#line 965
  if (rdta->categs > 35) {
    {
#line 966
    printf((char const   */* __restrict  */)"ERROR: Bad number of categories: %d\n",
           rdta->categs);
#line 967
    printf((char const   */* __restrict  */)"Must be in range 1 - %d\n", 35);
    }
#line 968
    return (0);
  }
#line 971
  j = 1;
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (j <= rdta->categs) {
      {
#line 971
      tmp___0 = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%lf",
                       & rdta->catrat[j]);
      }
#line 971
      if (! (tmp___0 == 1)) {
#line 971
        goto while_break;
      }
    } else {
#line 971
      goto while_break;
    }
#line 971
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 974
  if (j <= rdta->categs) {
    {
#line 975
    printf((char const   */* __restrict  */)"ERROR: Problem reading rate values\n");
    }
#line 976
    return (0);
  } else {
    {
#line 974
    tmp___1 = findch('\n');
    }
#line 974
    if (tmp___1 == -1) {
      {
#line 975
      printf((char const   */* __restrict  */)"ERROR: Problem reading rate values\n");
      }
#line 976
      return (0);
    }
  }
#line 979
  i = 1;
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 979
    if (! (i <= 10)) {
#line 979
      goto while_break___0;
    }
    {
#line 979
    _IO_getc(stdin);
#line 979
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 981
  i = 1;
  {
#line 982
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 982
    if (! (i <= rdta->sites)) {
#line 982
      goto while_break___1;
    }
    {
#line 983
    ch = _IO_getc(stdin);
#line 984
    ci = base36(ch);
    }
#line 985
    if (ci >= 0) {
#line 985
      if (ci <= rdta->categs) {
#line 986
        tmp___2 = i;
#line 986
        i ++;
#line 986
        *(rdta->sitecat + tmp___2) = ci;
      } else {
#line 985
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 987
      tmp___3 = whitechar(ch);
      }
#line 987
      if (! tmp___3) {
        {
#line 988
        printf((char const   */* __restrict  */)"ERROR: Bad category character (%c) at site %d\n",
               ch, i);
        }
#line 989
        return (0);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 993
  tmp___4 = findch('\n');
  }
#line 993
  if (tmp___4 == -1) {
    {
#line 994
    printf((char const   */* __restrict  */)"ERROR: Missing newline at end of category data\n");
    }
#line 995
    return (0);
  }
#line 998
  return (1);
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputextra(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1004
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
               & adef->extra);
  }
#line 1004
  if (tmp != 1) {
    {
#line 1006
    printf((char const   */* __restrict  */)"ERROR: Problem reading extra info value\n");
    }
#line 1007
    return (0);
  } else {
    {
#line 1004
    tmp___0 = findch('\n');
    }
#line 1004
    if (tmp___0 == -1) {
      {
#line 1006
      printf((char const   */* __restrict  */)"ERROR: Problem reading extra info value\n");
      }
#line 1007
      return (0);
    }
  }
#line 1010
  return (1);
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputfreqs(rawdata *rdta ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1016
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%lf%lf%lf%lf",
               & rdta->freqa, & rdta->freqc, & rdta->freqg, & rdta->freqt);
  }
#line 1016
  if (tmp != 4) {
    {
#line 1020
    printf((char const   */* __restrict  */)"ERROR: Problem reading user base frequencies data\n");
    }
#line 1021
    return (0);
  } else {
    {
#line 1016
    tmp___0 = findch('\n');
    }
#line 1016
    if (tmp___0 == -1) {
      {
#line 1020
      printf((char const   */* __restrict  */)"ERROR: Problem reading user base frequencies data\n");
      }
#line 1021
      return (0);
    }
  }
#line 1024
  rdta->freqread = 1;
#line 1025
  return (1);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputglobal(tree *tr ) 
{ 
  int ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  boolean tmp___2 ;

  {
#line 1034
  if (tr->global != -2) {
    {
#line 1035
    printf((char const   */* __restrict  */)"ERROR: Unexpected Global auxiliary data line\n");
    }
#line 1036
    return (0);
  }
  {
#line 1038
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
               & tr->global);
  }
#line 1038
  if (tmp != 1) {
    {
#line 1039
    printf((char const   */* __restrict  */)"ERROR: Problem reading rearrangement region size\n");
    }
#line 1040
    return (0);
  }
#line 1042
  if (tr->global < 0) {
    {
#line 1043
    printf((char const   */* __restrict  */)"WARNING: Global region size too small;\n");
#line 1044
    printf((char const   */* __restrict  */)"         value reset to local\n\n");
#line 1045
    tr->global = 1;
    }
  } else
#line 1047
  if (tr->global == 0) {
#line 1047
    tr->partswap = 0;
  } else
#line 1048
  if (tr->global > tr->mxtips - 3) {
#line 1049
    tr->global = tr->mxtips - 3;
  }
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1052
    ch = _IO_getc(stdin);
    }
#line 1052
    if (! (ch != 10)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    tmp___2 = whitechar(ch);
    }
#line 1053
    if (! tmp___2) {
#line 1054
      if (ch != -1) {
        {
#line 1054
        ungetc(ch, stdin);
        }
      }
#line 1055
      if (ch == -1) {
        {
#line 1057
        printf((char const   */* __restrict  */)"ERROR: Problem reading insert swap region size\n");
        }
#line 1058
        return (0);
      } else {
        {
#line 1055
        tmp___0 = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
                         & tr->partswap);
        }
#line 1055
        if (tmp___0 != 1) {
          {
#line 1057
          printf((char const   */* __restrict  */)"ERROR: Problem reading insert swap region size\n");
          }
#line 1058
          return (0);
        } else {
          {
#line 1055
          tmp___1 = findch('\n');
          }
#line 1055
          if (tmp___1 == -1) {
            {
#line 1057
            printf((char const   */* __restrict  */)"ERROR: Problem reading insert swap region size\n");
            }
#line 1058
            return (0);
          } else
#line 1060
          if (tr->partswap < 0) {
#line 1060
            tr->partswap = 1;
          } else
#line 1061
          if (tr->partswap > tr->mxtips - 3) {
#line 1062
            tr->partswap = tr->mxtips - 3;
          }
        }
      }
#line 1065
      if (tr->partswap > tr->global) {
#line 1065
        tr->global = tr->partswap;
      }
#line 1066
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (1);
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputjumble(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1076
  if (! adef->jumble) {
    {
#line 1077
    printf((char const   */* __restrict  */)"ERROR: Unexpected Jumble auxiliary data line\n");
    }
#line 1078
    return (0);
  } else {
    {
#line 1080
    tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%ld",
                 & adef->jumble);
    }
#line 1080
    if (tmp != 1) {
      {
#line 1082
      printf((char const   */* __restrict  */)"ERROR: Problem reading jumble random seed value\n");
      }
#line 1083
      return (0);
    } else {
      {
#line 1080
      tmp___0 = findch('\n');
      }
#line 1080
      if (tmp___0 == -1) {
        {
#line 1082
        printf((char const   */* __restrict  */)"ERROR: Problem reading jumble random seed value\n");
        }
#line 1083
        return (0);
      } else
#line 1085
      if (adef->jumble == 0L) {
        {
#line 1086
        printf((char const   */* __restrict  */)"WARNING: Jumble random number seed is zero\n\n");
        }
      }
    }
  }
#line 1089
  return (1);
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputkeep(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1095
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
               & adef->nkeep);
  }
#line 1095
  if (tmp != 1) {
    {
#line 1097
    printf((char const   */* __restrict  */)"ERROR: Problem reading number of kept trees\n");
    }
#line 1098
    return (0);
  } else {
    {
#line 1095
    tmp___0 = findch('\n');
    }
#line 1095
    if (tmp___0 == -1) {
      {
#line 1097
      printf((char const   */* __restrict  */)"ERROR: Problem reading number of kept trees\n");
      }
#line 1098
      return (0);
    } else
#line 1095
    if (adef->nkeep < 1) {
      {
#line 1097
      printf((char const   */* __restrict  */)"ERROR: Problem reading number of kept trees\n");
      }
#line 1098
      return (0);
    }
  }
#line 1101
  return (1);
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputoutgroup(analdef *adef , tree *tr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1107
  if (! adef->root) {
    {
#line 1108
    printf((char const   */* __restrict  */)"ERROR: Unexpected Outgroup auxiliary data line\n");
    }
#line 1109
    return (0);
  } else
#line 1107
  if (tr->outgr > 0) {
    {
#line 1108
    printf((char const   */* __restrict  */)"ERROR: Unexpected Outgroup auxiliary data line\n");
    }
#line 1109
    return (0);
  } else {
    {
#line 1111
    tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
                 & tr->outgr);
    }
#line 1111
    if (tmp != 1) {
      {
#line 1113
      printf((char const   */* __restrict  */)"ERROR: Problem reading outgroup number\n");
      }
#line 1114
      return (0);
    } else {
      {
#line 1111
      tmp___0 = findch('\n');
      }
#line 1111
      if (tmp___0 == -1) {
        {
#line 1113
        printf((char const   */* __restrict  */)"ERROR: Problem reading outgroup number\n");
        }
#line 1114
        return (0);
      } else
#line 1116
      if (tr->outgr < 1) {
        {
#line 1117
        printf((char const   */* __restrict  */)"ERROR: Bad outgroup: \'%d\'\n", tr->outgr);
        }
#line 1118
        return (0);
      } else
#line 1116
      if (tr->outgr > tr->mxtips) {
        {
#line 1117
        printf((char const   */* __restrict  */)"ERROR: Bad outgroup: \'%d\'\n", tr->outgr);
        }
#line 1118
        return (0);
      }
    }
  }
#line 1121
  return (1);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputratio(rawdata *rdta ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1127
  if (rdta->ttratio >= 0.0) {
    {
#line 1128
    printf((char const   */* __restrict  */)"ERROR: Unexpected Transition/transversion auxiliary data\n");
    }
#line 1129
    return (0);
  } else {
    {
#line 1131
    tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%lf",
                 & rdta->ttratio);
    }
#line 1131
    if (tmp != 1) {
      {
#line 1133
      printf((char const   */* __restrict  */)"ERROR: Problem reading transition/transversion ratio\n");
      }
#line 1134
      return (0);
    } else {
      {
#line 1131
      tmp___0 = findch('\n');
      }
#line 1131
      if (tmp___0 == -1) {
        {
#line 1133
        printf((char const   */* __restrict  */)"ERROR: Problem reading transition/transversion ratio\n");
        }
#line 1134
        return (0);
      }
    }
  }
#line 1137
  return (1);
}
}
#line 1147 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputtreeopt(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1149
  if (! adef->trout) {
    {
#line 1150
    printf((char const   */* __restrict  */)"ERROR: Unexpected Treefile auxiliary data\n");
    }
#line 1151
    return (0);
  } else {
    {
#line 1153
    tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
                 & adef->trout);
    }
#line 1153
    if (tmp != 1) {
      {
#line 1155
      printf((char const   */* __restrict  */)"ERROR: Problem reading output tree-type number\n");
      }
#line 1156
      return (0);
    } else {
      {
#line 1153
      tmp___0 = findch('\n');
      }
#line 1153
      if (tmp___0 == -1) {
        {
#line 1155
        printf((char const   */* __restrict  */)"ERROR: Problem reading output tree-type number\n");
        }
#line 1156
        return (0);
      } else
#line 1158
      if (adef->trout < 0) {
        {
#line 1159
        printf((char const   */* __restrict  */)"ERROR: Bad output tree-type number: \'%d\'\n",
               adef->trout);
        }
#line 1160
        return (0);
      } else
#line 1158
      if (adef->trout > 3) {
        {
#line 1159
        printf((char const   */* __restrict  */)"ERROR: Bad output tree-type number: \'%d\'\n",
               adef->trout);
        }
#line 1160
        return (0);
      }
    }
  }
#line 1163
  return (1);
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean inputweights(analdef *adef , rawdata *rdta , cruncheddata *cdta ) 
{ 
  int i ;
  int ch ;
  int wi ;
  int tmp ;
  int tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;

  {
#line 1172
  if (! adef->userwgt) {
    {
#line 1173
    printf((char const   */* __restrict  */)"ERROR: Unexpected Weights auxiliary data\n");
    }
#line 1174
    return (0);
  } else
#line 1172
  if (cdta->wgtsum > 0) {
    {
#line 1173
    printf((char const   */* __restrict  */)"ERROR: Unexpected Weights auxiliary data\n");
    }
#line 1174
    return (0);
  }
#line 1177
  i = 2;
  {
#line 1177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1177
    if (! (i <= 10)) {
#line 1177
      goto while_break;
    }
    {
#line 1177
    _IO_getc(stdin);
#line 1177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  cdta->wgtsum = 0;
#line 1179
  i = 1;
  {
#line 1180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1180
    if (! (i <= rdta->sites)) {
#line 1180
      goto while_break___0;
    }
    {
#line 1181
    ch = _IO_getc(stdin);
#line 1182
    wi = base36(ch);
    }
#line 1183
    if (wi >= 0) {
#line 1184
      tmp = i;
#line 1184
      i ++;
#line 1184
      tmp___0 = wi;
#line 1184
      *(rdta->wgt + tmp) = tmp___0;
#line 1184
      cdta->wgtsum += tmp___0;
    } else {
      {
#line 1185
      tmp___1 = whitechar(ch);
      }
#line 1185
      if (! tmp___1) {
        {
#line 1186
        printf((char const   */* __restrict  */)"ERROR: Bad weight character: \'%c\'",
               ch);
#line 1187
        printf((char const   */* __restrict  */)"       Weights in dnaml must be a digit or a letter.\n");
        }
#line 1188
        return (0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1192
  tmp___2 = findch('\n');
  }
#line 1192
  if (tmp___2 == -1) {
    {
#line 1193
    printf((char const   */* __restrict  */)"ERROR: Missing newline at end of weight data\n");
    }
#line 1194
    return (0);
  }
#line 1197
  return (1);
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getoptions(analdef *adef , rawdata *rdta , cruncheddata *cdta , tree *tr ) 
{ 
  int ch ;
  int i ;
  int extranum ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  boolean tmp___8 ;
  boolean tmp___9 ;
  boolean tmp___10 ;
  boolean tmp___11 ;
  boolean tmp___12 ;
  boolean tmp___13 ;
  boolean tmp___14 ;
  boolean tmp___15 ;
  boolean tmp___16 ;
  boolean tmp___17 ;
  boolean tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;

  {
#line 1205
  adef->boot = 0L;
#line 1206
  adef->empf = 1;
#line 1207
  adef->extra = 0;
#line 1208
  adef->interleaved = 1;
#line 1209
  adef->jumble = 0L;
#line 1210
  adef->nkeep = 0;
#line 1211
  adef->prdata = 0;
#line 1212
  adef->qadd = 1;
#line 1213
  adef->restart = 0;
#line 1214
  adef->root = 0;
#line 1215
  adef->trout = 3;
#line 1216
  adef->trprint = 1;
#line 1217
  rdta->categs = 0;
#line 1218
  rdta->catrat[1] = 1.0;
#line 1219
  rdta->freqread = 0;
#line 1220
  rdta->ttratio = 2.0;
#line 1221
  tr->global = -1;
#line 1222
  tr->mxtips = rdta->numsp;
#line 1223
  tr->outgr = 1;
#line 1224
  tr->partswap = 1;
#line 1225
  tr->userlen = 0;
#line 1226
  adef->usertree = 0;
#line 1227
  adef->userwgt = 0;
#line 1228
  extranum = 0;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1230
    ch = _IO_getc(stdin);
    }
#line 1230
    if (ch != 10) {
#line 1230
      if (! (ch != -1)) {
#line 1230
        goto while_break;
      }
    } else {
#line 1230
      goto while_break;
    }
    {
#line 1231
    uppercase(& ch);
    }
    {
#line 1233
    if (ch == 49) {
#line 1233
      goto case_49;
    }
#line 1234
    if (ch == 51) {
#line 1234
      goto case_51;
    }
#line 1235
    if (ch == 52) {
#line 1235
      goto case_52;
    }
#line 1236
    if (ch == 66) {
#line 1236
      goto case_66;
    }
#line 1237
    if (ch == 67) {
#line 1237
      goto case_67;
    }
#line 1238
    if (ch == 69) {
#line 1238
      goto case_69;
    }
#line 1239
    if (ch == 70) {
#line 1239
      goto case_70;
    }
#line 1240
    if (ch == 71) {
#line 1240
      goto case_71;
    }
#line 1241
    if (ch == 73) {
#line 1241
      goto case_73;
    }
#line 1242
    if (ch == 74) {
#line 1242
      goto case_74;
    }
#line 1243
    if (ch == 75) {
#line 1243
      goto case_75;
    }
#line 1244
    if (ch == 76) {
#line 1244
      goto case_76;
    }
#line 1245
    if (ch == 79) {
#line 1245
      goto case_79;
    }
#line 1246
    if (ch == 81) {
#line 1246
      goto case_81;
    }
#line 1247
    if (ch == 82) {
#line 1247
      goto case_82;
    }
#line 1248
    if (ch == 84) {
#line 1248
      goto case_84;
    }
#line 1249
    if (ch == 85) {
#line 1249
      goto case_85;
    }
#line 1250
    if (ch == 87) {
#line 1250
      goto case_87;
    }
#line 1251
    if (ch == 89) {
#line 1251
      goto case_89;
    }
#line 1252
    if (ch == 32) {
#line 1252
      goto case_32;
    }
#line 1253
    if (ch == 9) {
#line 1253
      goto case_9;
    }
#line 1254
    goto switch_default;
    case_49: /* CIL Label */ 
#line 1233
    adef->prdata = ! adef->prdata;
#line 1233
    goto switch_break;
    case_51: /* CIL Label */ 
#line 1234
    adef->trprint = ! adef->trprint;
#line 1234
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1235
    adef->trout = 3 - adef->trout;
#line 1235
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1236
    adef->boot = 1L;
#line 1236
    extranum ++;
#line 1236
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1237
    rdta->categs = -1;
#line 1237
    extranum ++;
#line 1237
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1238
    adef->extra = -1;
#line 1238
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1239
    adef->empf = ! adef->empf;
#line 1239
    goto switch_break;
    case_71: /* CIL Label */ 
#line 1240
    tr->global = -2;
#line 1240
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1241
    adef->interleaved = ! adef->interleaved;
#line 1241
    goto switch_break;
    case_74: /* CIL Label */ 
#line 1242
    adef->jumble = 1L;
#line 1242
    extranum ++;
#line 1242
    goto switch_break;
    case_75: /* CIL Label */ 
#line 1243
    extranum ++;
#line 1243
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1244
    tr->userlen = 1;
#line 1244
    goto switch_break;
    case_79: /* CIL Label */ 
#line 1245
    adef->root = 1;
#line 1245
    tr->outgr = 0;
#line 1245
    extranum ++;
#line 1245
    goto switch_break;
    case_81: /* CIL Label */ 
#line 1246
    adef->qadd = 0;
#line 1246
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1247
    adef->restart = 1;
#line 1247
    goto switch_break;
    case_84: /* CIL Label */ 
#line 1248
    rdta->ttratio = - 1.0;
#line 1248
    extranum ++;
#line 1248
    goto switch_break;
    case_85: /* CIL Label */ 
#line 1249
    adef->usertree = 1;
#line 1249
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1250
    adef->userwgt = 1;
#line 1250
    cdta->wgtsum = 0;
#line 1250
    extranum ++;
#line 1250
    goto switch_break;
    case_89: /* CIL Label */ 
#line 1251
    adef->trout = 3 - adef->trout;
#line 1251
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1252
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1253
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1255
    printf((char const   */* __restrict  */)"ERROR: Bad option character: \'%c\'\n",
           ch);
    }
#line 1256
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1260
  if (ch == -1) {
    {
#line 1261
    printf((char const   */* __restrict  */)"ERROR: End-of-file in options list\n");
    }
#line 1262
    return (0);
  }
#line 1265
  if (adef->usertree) {
#line 1265
    if (adef->restart) {
      {
#line 1266
      printf((char const   */* __restrict  */)"ERROR:  The restart and user-tree options conflict:\n");
#line 1267
      printf((char const   */* __restrict  */)"        Restart adds rest of taxa to a starting tree;\n");
#line 1268
      printf((char const   */* __restrict  */)"        User-tree does not add any taxa.\n\n");
      }
#line 1269
      return (0);
    }
  }
#line 1272
  if (adef->usertree) {
#line 1272
    if (adef->jumble) {
      {
#line 1273
      printf((char const   */* __restrict  */)"WARNING:  The jumble and user-tree options conflict:\n");
#line 1274
      printf((char const   */* __restrict  */)"          Jumble adds taxa to a tree in random order;\n");
#line 1275
      printf((char const   */* __restrict  */)"          User-tree does not use taxa addition.\n");
#line 1276
      printf((char const   */* __restrict  */)"          Jumble option cancelled for this run.\n\n");
#line 1277
      adef->jumble = 0L;
      }
    }
  }
#line 1280
  if (tr->userlen) {
#line 1280
    if (tr->global != -1) {
      {
#line 1281
      printf((char const   */* __restrict  */)"ERROR:  The global and user-lengths options conflict:\n");
#line 1282
      printf((char const   */* __restrict  */)"        Global optimizes a starting tree;\n");
#line 1283
      printf((char const   */* __restrict  */)"        User-lengths constrain the starting tree.\n\n");
      }
#line 1284
      return (0);
    }
  }
#line 1287
  if (tr->userlen) {
#line 1287
    if (! adef->usertree) {
      {
#line 1288
      printf((char const   */* __restrict  */)"WARNING:  User lengths required user tree option.\n");
#line 1289
      printf((char const   */* __restrict  */)"          User-tree option set for this run.\n\n");
#line 1290
      adef->usertree = 1;
      }
    }
  }
  {
#line 1293
  tmp = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1293
  rdta->wgt = (int *)tmp;
#line 1294
  tmp___0 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1294
  rdta->wgt2 = (int *)tmp___0;
#line 1295
  tmp___1 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1295
  rdta->sitecat = (int *)tmp___1;
#line 1296
  tmp___2 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1296
  cdta->alias = (int *)tmp___2;
#line 1297
  tmp___3 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1297
  cdta->aliaswgt = (int *)tmp___3;
#line 1298
  tmp___4 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(int )));
#line 1298
  cdta->patcat = (int *)tmp___4;
#line 1299
  tmp___5 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(double )));
#line 1299
  cdta->patrat = (double *)tmp___5;
#line 1300
  tmp___6 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(double )));
#line 1300
  cdta->wr = (double *)tmp___6;
#line 1301
  tmp___7 = malloc((unsigned int )((unsigned long )(rdta->sites + 1) * sizeof(double )));
#line 1301
  cdta->wr2 = (double *)tmp___7;
  }
#line 1302
  if (! rdta->wgt) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! rdta->wgt2) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! rdta->sitecat) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->alias) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->aliaswgt) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->patcat) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->patrat) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->wr) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  } else
#line 1302
  if (! cdta->wr2) {
    {
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getoptions: Malloc failure\n");
    }
#line 1306
    return (0);
  }
  {
#line 1311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1311
    tmp___19 = extranum;
#line 1311
    extranum --;
#line 1311
    if (! tmp___19) {
#line 1311
      goto while_break___0;
    }
    {
#line 1312
    ch = _IO_getc(stdin);
#line 1313
    uppercase(& ch);
    }
    {
#line 1315
    if (ch == 66) {
#line 1315
      goto case_66___0;
    }
#line 1316
    if (ch == 67) {
#line 1316
      goto case_67___0;
    }
#line 1317
    if (ch == 69) {
#line 1317
      goto case_69___0;
    }
#line 1318
    if (ch == 70) {
#line 1318
      goto case_70___0;
    }
#line 1319
    if (ch == 71) {
#line 1319
      goto case_71___0;
    }
#line 1320
    if (ch == 74) {
#line 1320
      goto case_74___0;
    }
#line 1321
    if (ch == 75) {
#line 1321
      goto case_75___0;
    }
#line 1322
    if (ch == 79) {
#line 1322
      goto case_79___0;
    }
#line 1323
    if (ch == 84) {
#line 1323
      goto case_84___0;
    }
#line 1324
    if (ch == 87) {
#line 1324
      goto case_87___0;
    }
#line 1325
    if (ch == 89) {
#line 1325
      goto case_89___0;
    }
#line 1327
    goto switch_default___0;
    case_66___0: /* CIL Label */ 
    {
#line 1315
    tmp___8 = inputboot(adef);
    }
#line 1315
    if (! tmp___8) {
#line 1315
      return (0);
    }
#line 1315
    goto switch_break___0;
    case_67___0: /* CIL Label */ 
    {
#line 1316
    tmp___9 = inputcategories(rdta);
    }
#line 1316
    if (! tmp___9) {
#line 1316
      return (0);
    }
#line 1316
    goto switch_break___0;
    case_69___0: /* CIL Label */ 
    {
#line 1317
    tmp___10 = inputextra(adef);
    }
#line 1317
    if (! tmp___10) {
#line 1317
      return (0);
    }
#line 1317
    extranum ++;
#line 1317
    goto switch_break___0;
    case_70___0: /* CIL Label */ 
    {
#line 1318
    tmp___11 = inputfreqs(rdta);
    }
#line 1318
    if (! tmp___11) {
#line 1318
      return (0);
    }
#line 1318
    goto switch_break___0;
    case_71___0: /* CIL Label */ 
    {
#line 1319
    tmp___12 = inputglobal(tr);
    }
#line 1319
    if (! tmp___12) {
#line 1319
      return (0);
    }
#line 1319
    extranum ++;
#line 1319
    goto switch_break___0;
    case_74___0: /* CIL Label */ 
    {
#line 1320
    tmp___13 = inputjumble(adef);
    }
#line 1320
    if (! tmp___13) {
#line 1320
      return (0);
    }
#line 1320
    goto switch_break___0;
    case_75___0: /* CIL Label */ 
    {
#line 1321
    tmp___14 = inputkeep(adef);
    }
#line 1321
    if (! tmp___14) {
#line 1321
      return (0);
    }
#line 1321
    goto switch_break___0;
    case_79___0: /* CIL Label */ 
    {
#line 1322
    tmp___15 = inputoutgroup(adef, tr);
    }
#line 1322
    if (! tmp___15) {
#line 1322
      return (0);
    }
#line 1322
    goto switch_break___0;
    case_84___0: /* CIL Label */ 
    {
#line 1323
    tmp___16 = inputratio(rdta);
    }
#line 1323
    if (! tmp___16) {
#line 1323
      return (0);
    }
#line 1323
    goto switch_break___0;
    case_87___0: /* CIL Label */ 
    {
#line 1324
    tmp___17 = inputweights(adef, rdta, cdta);
    }
#line 1324
    if (! tmp___17) {
#line 1324
      return (0);
    }
#line 1324
    goto switch_break___0;
    case_89___0: /* CIL Label */ 
    {
#line 1325
    tmp___18 = inputtreeopt(adef);
    }
#line 1325
    if (! tmp___18) {
#line 1325
      return (0);
    }
#line 1325
    extranum ++;
#line 1325
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1328
    printf((char const   */* __restrict  */)"ERROR: Auxiliary options line starts with \'%c\'\n",
           ch);
    }
#line 1329
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1333
  if (! adef->userwgt) {
#line 1334
    i = 1;
    {
#line 1334
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1334
      if (! (i <= rdta->sites)) {
#line 1334
        goto while_break___1;
      }
#line 1334
      *(rdta->wgt + i) = 1;
#line 1334
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1335
    cdta->wgtsum = rdta->sites;
  }
#line 1338
  if (adef->userwgt) {
#line 1338
    if (cdta->wgtsum < 1) {
      {
#line 1339
      printf((char const   */* __restrict  */)"ERROR:  Missing or bad user-supplied weight data.\n");
      }
#line 1340
      return (0);
    }
  }
#line 1343
  if (adef->boot) {
    {
#line 1344
    printf((char const   */* __restrict  */)"Bootstrap random number seed = %ld\n\n",
           adef->boot);
    }
  }
#line 1347
  if (adef->jumble) {
    {
#line 1348
    printf((char const   */* __restrict  */)"Jumble random number seed = %ld\n\n",
           adef->jumble);
    }
  }
#line 1351
  if (adef->qadd) {
    {
#line 1352
    printf((char const   */* __restrict  */)"Quick add (only local branches initially optimized) in effect\n\n");
    }
  }
#line 1355
  if (rdta->categs > 0) {
    {
#line 1356
    printf((char const   */* __restrict  */)"Site category   Rate of change\n\n");
#line 1357
    i = 1;
    }
    {
#line 1357
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1357
      if (! (i <= rdta->categs)) {
#line 1357
        goto while_break___2;
      }
      {
#line 1358
      tmp___20 = itobase36(i);
#line 1358
      printf((char const   */* __restrict  */)"           %c%13.3f\n", tmp___20, rdta->catrat[i]);
#line 1357
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1359
    putchar('\n');
#line 1360
    i = 1;
    }
    {
#line 1360
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1360
      if (! (i <= rdta->sites)) {
#line 1360
        goto while_break___3;
      }
#line 1361
      if (*(rdta->wgt + i) > 0) {
#line 1361
        if (*(rdta->sitecat + i) < 1) {
          {
#line 1362
          tmp___21 = itobase36(*(rdta->sitecat + i));
#line 1362
          printf((char const   */* __restrict  */)"ERROR: Bad category (%c) at site %d\n",
                 tmp___21, i);
          }
#line 1364
          return (0);
        }
      }
#line 1360
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 1368
  if (rdta->categs < 0) {
    {
#line 1369
    printf((char const   */* __restrict  */)"ERROR: Category auxiliary data missing from input\n");
    }
#line 1370
    return (0);
  } else {
#line 1373
    i = 1;
    {
#line 1373
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1373
      if (! (i <= rdta->sites)) {
#line 1373
        goto while_break___4;
      }
#line 1373
      *(rdta->sitecat + i) = 1;
#line 1373
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1374
    rdta->categs = 1;
  }
#line 1377
  if (tr->outgr < 1) {
    {
#line 1378
    printf((char const   */* __restrict  */)"ERROR: Outgroup auxiliary data missing from input\n");
    }
#line 1379
    return (0);
  }
#line 1382
  if (rdta->ttratio < 0.0) {
    {
#line 1383
    printf((char const   */* __restrict  */)"ERROR: Transition/transversion auxiliary data missing from input\n");
    }
#line 1384
    return (0);
  }
#line 1387
  if (tr->global < 0) {
#line 1388
    if (tr->global == -2) {
#line 1388
      tr->global = tr->mxtips - 3;
    } else
#line 1389
    if (adef->usertree) {
#line 1389
      tr->global = 0;
    } else {
#line 1389
      tr->global = 1;
    }
  }
#line 1392
  if (adef->restart) {
    {
#line 1393
    printf((char const   */* __restrict  */)"Restart option in effect.  ");
#line 1394
    printf((char const   */* __restrict  */)"Sequence addition will start from appended tree.\n\n");
    }
  }
#line 1397
  if (adef->usertree) {
#line 1397
    if (! tr->global) {
#line 1398
      if (tr->userlen) {
#line 1398
        tmp___22 = " and branch lengths ";
      } else {
#line 1398
        tmp___22 = " ";
      }
      {
#line 1398
      printf((char const   */* __restrict  */)"User-supplied tree topology%swill be used.\n\n",
             tmp___22);
      }
    } else {
#line 1397
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1402
    if (! adef->usertree) {
#line 1403
      if (tr->partswap == 1) {
#line 1403
        tmp___23 = "branch";
      } else {
#line 1403
        tmp___23 = "branches";
      }
      {
#line 1403
      printf((char const   */* __restrict  */)"Rearrangements of partial trees may cross %d %s.\n",
             tr->partswap, tmp___23);
      }
    }
#line 1406
    if (tr->global == 1) {
#line 1406
      tmp___24 = "branch";
    } else {
#line 1406
      tmp___24 = "branches";
    }
    {
#line 1406
    printf((char const   */* __restrict  */)"Rearrangements of full tree may cross %d %s.\n\n",
           tr->global, tmp___24);
    }
  }
#line 1410
  if (! adef->usertree) {
#line 1410
    if (adef->nkeep == 0) {
#line 1410
      adef->nkeep = 1;
    }
  }
#line 1412
  return (1);
}
}
#line 1416 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getbasefreqs(rawdata *rdta ) 
{ 
  int ch ;
  int tmp ;
  int tmp___0 ;

  {
#line 1420
  if (rdta->freqread) {
#line 1420
    return (1);
  }
  {
#line 1422
  ch = _IO_getc(stdin);
  }
#line 1423
  if (! (ch == 70)) {
#line 1423
    if (! (ch == 102)) {
      {
#line 1423
      ungetc(ch, stdin);
      }
    }
  }
  {
#line 1425
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%lf%lf%lf%lf",
               & rdta->freqa, & rdta->freqc, & rdta->freqg, & rdta->freqt);
  }
#line 1425
  if (tmp != 4) {
    {
#line 1429
    printf((char const   */* __restrict  */)"ERROR: Problem reading user base frequencies\n");
    }
#line 1430
    return (0);
  } else {
    {
#line 1425
    tmp___0 = findch('\n');
    }
#line 1425
    if (tmp___0 == -1) {
      {
#line 1429
      printf((char const   */* __restrict  */)"ERROR: Problem reading user base frequencies\n");
      }
#line 1430
      return (0);
    }
  }
#line 1433
  return (1);
}
}
#line 1437 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getyspace(rawdata *rdta ) 
{ 
  long size ;
  int i ;
  yType *y0___0 ;
  yType **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1443
  tmp___0 = malloc((unsigned int )((unsigned long )(rdta->numsp + 1) * sizeof(yType *)));
#line 1443
  tmp = (yType **)tmp___0;
#line 1443
  rdta->y = tmp;
  }
#line 1443
  if (! tmp) {
    {
#line 1444
    printf((char const   */* __restrict  */)"ERROR: Unable to obtain space for data array pointers\n");
    }
#line 1445
    return (0);
  }
  {
#line 1448
  size = (long )(4 * (rdta->sites / 4 + 1));
#line 1449
  tmp___1 = malloc((unsigned int )((unsigned long )((long )(rdta->numsp + 1) * size) * sizeof(yType )));
#line 1449
  y0___0 = tmp___1;
  }
#line 1449
  if (! y0___0) {
    {
#line 1450
    printf((char const   */* __restrict  */)"ERROR: Unable to obtain space for data array\n");
    }
#line 1451
    return (0);
  }
#line 1454
  i = 0;
  {
#line 1454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1454
    if (! (i <= rdta->numsp)) {
#line 1454
      goto while_break;
    }
#line 1455
    *(rdta->y + i) = y0___0;
#line 1456
    y0___0 += size;
#line 1454
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1459
  return (1);
}
}
#line 1463 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean setupTree(tree *tr , int nsites ) 
{ 
  nodeptr p0 ;
  nodeptr p ;
  nodeptr q ;
  int i ;
  int j ;
  int tips ;
  int inter ;
  char *tmp ;
  node **tmp___0 ;
  char *tmp___1 ;
  nodeptr tmp___2 ;
  nodeptr tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1468
  tips = tr->mxtips;
#line 1469
  inter = tr->mxtips - 1;
#line 1471
  tmp = malloc((unsigned int )((unsigned long )(tips + 3 * inter) * sizeof(node )));
#line 1471
  p0 = (nodeptr )tmp;
  }
#line 1471
  if (! p0) {
    {
#line 1472
    printf((char const   */* __restrict  */)"ERROR: Unable to obtain sufficient tree memory\n");
    }
#line 1473
    return (0);
  }
  {
#line 1476
  tmp___1 = malloc((unsigned int )((unsigned long )(2 * tr->mxtips) * sizeof(nodeptr )));
#line 1476
  tmp___0 = (nodeptr *)tmp___1;
#line 1476
  tr->nodep = tmp___0;
  }
#line 1476
  if (! tmp___0) {
    {
#line 1477
    printf((char const   */* __restrict  */)"ERROR: Unable to obtain sufficient tree memory, too\n");
    }
#line 1478
    return (0);
  }
#line 1481
  *(tr->nodep + 0) = (node *)((void *)0);
#line 1483
  i = 1;
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1483
    if (! (i <= tips)) {
#line 1483
      goto while_break;
    }
#line 1484
    tmp___2 = p0;
#line 1484
    p0 ++;
#line 1484
    p = tmp___2;
#line 1485
    p->x = (xarray *)((void *)0);
#line 1486
    p->tip = (yType *)((void *)0);
#line 1487
    p->number = i;
#line 1488
    p->next = p;
#line 1489
    p->back = (node *)((void *)0);
#line 1491
    *(tr->nodep + i) = p;
#line 1483
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  i = tips + 1;
  {
#line 1494
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1494
    if (! (i <= tips + inter)) {
#line 1494
      goto while_break___0;
    }
#line 1495
    q = (node *)((void *)0);
#line 1496
    j = 1;
    {
#line 1496
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1496
      if (! (j <= 3)) {
#line 1496
        goto while_break___1;
      }
#line 1497
      tmp___3 = p0;
#line 1497
      p0 ++;
#line 1497
      p = tmp___3;
#line 1498
      p->x = (xarray *)((void *)0);
#line 1499
      p->tip = (yType *)((void *)0);
#line 1500
      p->number = i;
#line 1501
      p->next = q;
#line 1502
      p->back = (node *)((void *)0);
#line 1503
      q = p;
#line 1496
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1505
    ((p->next)->next)->next = p;
#line 1506
    *(tr->nodep + i) = p;
#line 1494
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1509
  tr->likelihood = - 1.0E300;
#line 1510
  tr->start = (node *)((void *)0);
#line 1511
  tr->outgrnode = *(tr->nodep + tr->outgr);
#line 1512
  tr->ntips = 0;
#line 1513
  tr->nextnode = 0;
#line 1514
  tr->opt_level = 0;
#line 1515
  tr->prelabeled = 1;
#line 1516
  tr->smoothed = 0;
#line 1517
  tr->log_f_valid = 0;
#line 1519
  tmp___4 = malloc((unsigned int )((unsigned long )nsites * sizeof(double )));
#line 1519
  tr->log_f = (double *)tmp___4;
  }
#line 1520
  if (! tr->log_f) {
    {
#line 1521
    printf((char const   */* __restrict  */)"ERROR: Unable to obtain sufficient tree memory, trey\n");
    }
#line 1522
    return (0);
  }
#line 1525
  return (1);
}
}
#line 1529 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void freeTreeNode(nodeptr p ) 
{ 


  {
#line 1531
  if (p) {
#line 1532
    if (p->x) {
#line 1533
      if ((p->x)->lv) {
        {
#line 1533
        free((char *)(p->x)->lv);
        }
      }
      {
#line 1534
      free((char *)p->x);
      }
    }
  }
#line 1537
  return;
}
}
#line 1540 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void freeTree(tree *tr ) 
{ 
  nodeptr p ;
  nodeptr q ;
  int i ;
  int tips ;
  int inter ;

  {
#line 1545
  tips = tr->mxtips;
#line 1546
  inter = tr->mxtips - 1;
#line 1548
  i = 1;
  {
#line 1548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1548
    if (! (i <= tips)) {
#line 1548
      goto while_break;
    }
    {
#line 1548
    freeTreeNode(*(tr->nodep + i));
#line 1548
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1550
  i = tips + 1;
  {
#line 1550
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1550
    if (! (i <= tips + inter)) {
#line 1550
      goto while_break___0;
    }
#line 1551
    p = *(tr->nodep + i);
#line 1551
    if (p) {
#line 1552
      q = p->next;
#line 1552
      if (q) {
        {
#line 1553
        freeTreeNode(q->next);
#line 1554
        freeTreeNode(q);
        }
      }
      {
#line 1556
      freeTreeNode(p);
      }
    }
#line 1550
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1560
  free((char *)*(tr->nodep + 1));
  }
#line 1561
  return;
}
}
#line 1564 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getdata(analdef *adef , rawdata *rdta , tree *tr ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int basesread ;
  int basesnew ;
  int ch ;
  int meaning[256] ;
  char *nameptr ;
  boolean allread ;
  boolean firstpass ;
  boolean tmp ;
  char *tmp___0 ;
  boolean tmp___1 ;
  char *tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 1572
  i = 0;
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1572
    if (! (i <= 255)) {
#line 1572
      goto while_break;
    }
#line 1572
    meaning[i] = 0;
#line 1572
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1573
  meaning['A'] = 1;
#line 1574
  meaning['B'] = 14;
#line 1575
  meaning['C'] = 2;
#line 1576
  meaning['D'] = 13;
#line 1577
  meaning['G'] = 4;
#line 1578
  meaning['H'] = 11;
#line 1579
  meaning['K'] = 12;
#line 1580
  meaning['M'] = 3;
#line 1581
  meaning['N'] = 15;
#line 1582
  meaning['O'] = 15;
#line 1583
  meaning['R'] = 5;
#line 1584
  meaning['S'] = 6;
#line 1585
  meaning['T'] = 8;
#line 1586
  meaning['U'] = 8;
#line 1587
  meaning['V'] = 7;
#line 1588
  meaning['W'] = 9;
#line 1589
  meaning['X'] = 15;
#line 1590
  meaning['Y'] = 10;
#line 1591
  meaning['?'] = 15;
#line 1592
  meaning['-'] = 15;
#line 1594
  basesnew = 0;
#line 1594
  basesread = basesnew;
#line 1596
  allread = 0;
#line 1597
  firstpass = 1;
#line 1598
  ch = ' ';
  {
#line 1600
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1600
    if (! (! allread)) {
#line 1600
      goto while_break___0;
    }
#line 1601
    i = 1;
    {
#line 1601
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1601
      if (! (i <= tr->mxtips)) {
#line 1601
        goto while_break___1;
      }
#line 1603
      if (firstpass) {
#line 1604
        j = 1;
        {
#line 1605
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1605
          ch = _IO_getc(stdin);
#line 1605
          tmp = whitechar(ch);
          }
#line 1605
          if (! tmp) {
#line 1605
            goto while_break___2;
          }
#line 1606
          if (ch == 10) {
#line 1606
            j = 1;
          } else {
#line 1606
            j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1609
        if (j > 10) {
          {
#line 1610
          printf((char const   */* __restrict  */)"ERROR: Blank name for species %d; ",
                 i);
#line 1611
          printf((char const   */* __restrict  */)"check number of species,\n");
#line 1612
          printf((char const   */* __restrict  */)"       number of sites, and interleave option.\n");
          }
#line 1613
          return (0);
        }
#line 1616
        nameptr = (*(tr->nodep + i))->name;
#line 1617
        k = 1;
        {
#line 1617
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1617
          if (! (k < j)) {
#line 1617
            goto while_break___3;
          }
#line 1617
          tmp___0 = nameptr;
#line 1617
          nameptr ++;
#line 1617
          *tmp___0 = (char )' ';
#line 1617
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1619
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1619
          if (ch != 10) {
#line 1619
            if (! (ch != -1)) {
#line 1619
              goto while_break___4;
            }
          } else {
#line 1619
            goto while_break___4;
          }
          {
#line 1620
          tmp___1 = whitechar(ch);
          }
#line 1620
          if (tmp___1) {
#line 1620
            ch = ' ';
          }
#line 1621
          tmp___2 = nameptr;
#line 1621
          nameptr ++;
#line 1621
          *tmp___2 = (char )ch;
#line 1622
          j ++;
#line 1622
          if (j > 10) {
#line 1622
            goto while_break___4;
          }
          {
#line 1623
          ch = _IO_getc(stdin);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1626
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1626
          nameptr --;
#line 1626
          if (! ((int )*nameptr == 32)) {
#line 1626
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1627
        nameptr ++;
#line 1627
        *nameptr = (char )'\000';
#line 1629
        if (ch == -1) {
          {
#line 1630
          printf((char const   */* __restrict  */)"ERROR: End-of-file in name of species %d\n",
                 i);
          }
#line 1631
          return (0);
        }
      }
#line 1635
      j = basesread;
      {
#line 1636
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1636
        if (j < rdta->sites) {
          {
#line 1636
          ch = _IO_getc(stdin);
          }
#line 1636
          if (ch != -1) {
#line 1636
            if (! (! adef->interleaved)) {
#line 1636
              if (! (ch != 10)) {
#line 1636
                goto while_break___6;
              }
            }
          } else {
#line 1636
            goto while_break___6;
          }
        } else {
#line 1636
          goto while_break___6;
        }
        {
#line 1639
        uppercase(& ch);
        }
#line 1640
        if (meaning[ch]) {
#line 1640
          goto _L;
        } else
#line 1640
        if (ch == 46) {
          _L: /* CIL Label */ 
#line 1641
          j ++;
#line 1642
          if (ch == 46) {
#line 1643
            if (i != 1) {
#line 1643
              ch = (int )*(*(rdta->y + 1) + j);
            } else {
              {
#line 1645
              printf((char const   */* __restrict  */)"ERROR: Dot (.) found at site %d of sequence 1\n",
                     j);
              }
#line 1646
              return (0);
            }
          }
#line 1649
          *(*(rdta->y + i) + j) = (yType )ch;
        } else {
          {
#line 1651
          tmp___3 = whitechar(ch);
          }
#line 1651
          if (! tmp___3) {
            {
#line 1651
            tmp___4 = digitchar(ch);
            }
#line 1651
            if (! tmp___4) {
              {
#line 1653
              printf((char const   */* __restrict  */)"ERROR: Bad base (%c) at site %d of sequence %d\n",
                     ch, j, i);
              }
#line 1655
              return (0);
            }
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1659
      if (ch == -1) {
        {
#line 1660
        printf((char const   */* __restrict  */)"ERROR: End-of-file at site %d of sequence %d\n",
               j, i);
        }
#line 1661
        return (0);
      }
#line 1664
      if (! firstpass) {
#line 1664
        if (j == basesread) {
#line 1664
          i --;
        } else {
#line 1664
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1665
      if (i == 1) {
#line 1665
        basesnew = j;
      } else
#line 1666
      if (j != basesnew) {
        {
#line 1667
        printf((char const   */* __restrict  */)"ERROR: Sequences out of alignment\n");
#line 1668
        printf((char const   */* __restrict  */)"%d (instead of %d) residues read in sequence %d\n",
               j - basesread, basesnew - basesread, i);
        }
#line 1670
        return (0);
      }
      {
#line 1673
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1673
        if (ch != 10) {
#line 1673
          if (! (ch != -1)) {
#line 1673
            goto while_break___7;
          }
        } else {
#line 1673
          goto while_break___7;
        }
        {
#line 1673
        ch = _IO_getc(stdin);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1601
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1675
    firstpass = 0;
#line 1676
    basesread = basesnew;
#line 1677
    allread = basesread >= rdta->sites;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1682
  if (adef->prdata) {
#line 1683
    j = 5 + (rdta->sites + (rdta->sites - 1) / 10) / 2;
#line 1684
    if (j < 9) {
#line 1684
      j = 9;
    }
#line 1685
    if (j > 37) {
#line 1685
      j = 37;
    }
    {
#line 1686
    printf((char const   */* __restrict  */)"Name");
#line 1686
    i = 1;
    }
    {
#line 1686
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1686
      if (! (i <= j)) {
#line 1686
        goto while_break___8;
      }
      {
#line 1686
      putchar(' ');
#line 1686
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1686
    printf((char const   */* __restrict  */)"Sequences\n");
#line 1687
    printf((char const   */* __restrict  */)"----");
#line 1687
    i = 1;
    }
    {
#line 1687
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1687
      if (! (i <= j)) {
#line 1687
        goto while_break___9;
      }
      {
#line 1687
      putchar(' ');
#line 1687
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1687
    printf((char const   */* __restrict  */)"---------\n");
#line 1688
    putchar('\n');
#line 1690
    i = 1;
    }
    {
#line 1690
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1690
      if (! (i <= rdta->sites)) {
#line 1690
        goto while_break___10;
      }
#line 1691
      l = i + 59;
#line 1692
      if (l > rdta->sites) {
#line 1692
        l = rdta->sites;
      }
#line 1694
      if (adef->userwgt) {
        {
#line 1695
        printf((char const   */* __restrict  */)"Weights   ");
#line 1696
        j = 11;
        }
        {
#line 1696
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1696
          if (! (j <= 13)) {
#line 1696
            goto while_break___11;
          }
          {
#line 1696
          putchar(' ');
#line 1696
          j ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1697
        k = i;
        {
#line 1697
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1697
          if (! (k <= l)) {
#line 1697
            goto while_break___12;
          }
          {
#line 1698
          tmp___5 = itobase36(*(rdta->wgt + k));
#line 1698
          putchar(tmp___5);
          }
#line 1699
          if (k % 10 == 0) {
#line 1699
            if (k < l) {
              {
#line 1699
              putchar(' ');
              }
            }
          }
#line 1697
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 1701
        putchar('\n');
        }
      }
#line 1704
      if (rdta->categs > 1) {
        {
#line 1705
        printf((char const   */* __restrict  */)"Categories");
#line 1706
        j = 11;
        }
        {
#line 1706
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1706
          if (! (j <= 13)) {
#line 1706
            goto while_break___13;
          }
          {
#line 1706
          putchar(' ');
#line 1706
          j ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 1707
        k = i;
        {
#line 1707
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1707
          if (! (k <= l)) {
#line 1707
            goto while_break___14;
          }
          {
#line 1708
          tmp___6 = itobase36(*(rdta->sitecat + k));
#line 1708
          putchar(tmp___6);
          }
#line 1709
          if (k % 10 == 0) {
#line 1709
            if (k < l) {
              {
#line 1709
              putchar(' ');
              }
            }
          }
#line 1707
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 1711
        putchar('\n');
        }
      }
#line 1714
      j = 1;
      {
#line 1714
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1714
        if (! (j <= tr->mxtips)) {
#line 1714
          goto while_break___15;
        }
#line 1715
        nameptr = (*(tr->nodep + j))->name;
#line 1716
        k = 13;
        {
#line 1717
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1717
          tmp___7 = nameptr;
#line 1717
          nameptr ++;
#line 1717
          ch = (int )*tmp___7;
#line 1717
          if (! ch) {
#line 1717
            goto while_break___16;
          }
          {
#line 1717
          putchar(ch);
#line 1717
          k --;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        {
#line 1718
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 1718
          k --;
#line 1718
          if (! (k >= 0)) {
#line 1718
            goto while_break___17;
          }
          {
#line 1718
          putchar(' ');
          }
        }
        while_break___17: /* CIL Label */ ;
        }
#line 1720
        k = i;
        {
#line 1720
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 1720
          if (! (k <= l)) {
#line 1720
            goto while_break___18;
          }
#line 1721
          ch = (int )*(*(rdta->y + j) + k);
#line 1722
          if (j > 1) {
#line 1722
            if (ch == (int )*(*(rdta->y + 1) + k)) {
#line 1722
              ch = '.';
            }
          }
          {
#line 1723
          putchar(ch);
          }
#line 1724
          if (k % 10 == 0) {
#line 1724
            if (k < l) {
              {
#line 1724
              putchar(' ');
              }
            }
          }
#line 1720
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 1726
        putchar('\n');
#line 1714
        j ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 1728
      putchar('\n');
#line 1690
      i += 60;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 1732
  j = 1;
  {
#line 1732
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1732
    if (! (j <= tr->mxtips)) {
#line 1732
      goto while_break___19;
    }
#line 1733
    i = 1;
    {
#line 1733
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1733
      if (! (i <= rdta->sites)) {
#line 1733
        goto while_break___20;
      }
#line 1734
      *(*(rdta->y + j) + i) = (yType )meaning[*(*(rdta->y + j) + i)];
#line 1733
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 1732
    j ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1737
  return (1);
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getntrees(analdef *adef ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1744
  tmp = fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%d",
               & adef->numutrees);
  }
#line 1744
  if (tmp != 1) {
    {
#line 1745
    printf((char const   */* __restrict  */)"ERROR: Problem reading number of user trees\n");
    }
#line 1746
    return (0);
  } else {
    {
#line 1744
    tmp___0 = findch('\n');
    }
#line 1744
    if (tmp___0 == -1) {
      {
#line 1745
      printf((char const   */* __restrict  */)"ERROR: Problem reading number of user trees\n");
      }
#line 1746
      return (0);
    }
  }
#line 1749
  if (adef->nkeep == 0) {
#line 1749
    adef->nkeep = adef->numutrees;
  }
#line 1751
  return (1);
}
}
#line 1755 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean getinput(analdef *adef , rawdata *rdta , cruncheddata *cdta , tree *tr ) 
{ 
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;

  {
  {
#line 1757
  tmp = getnums(rdta);
  }
#line 1757
  if (! tmp) {
#line 1757
    return (0);
  }
  {
#line 1758
  tmp___0 = getoptions(adef, rdta, cdta, tr);
  }
#line 1758
  if (! tmp___0) {
#line 1758
    return (0);
  }
#line 1759
  if (! adef->empf) {
    {
#line 1759
    tmp___1 = getbasefreqs(rdta);
    }
#line 1759
    if (! tmp___1) {
#line 1759
      return (0);
    }
  }
  {
#line 1760
  tmp___2 = getyspace(rdta);
  }
#line 1760
  if (! tmp___2) {
#line 1760
    return (0);
  }
  {
#line 1761
  tmp___3 = setupTree(tr, rdta->sites);
  }
#line 1761
  if (! tmp___3) {
#line 1761
    return (0);
  }
  {
#line 1762
  tmp___4 = getdata(adef, rdta, tr);
  }
#line 1762
  if (! tmp___4) {
#line 1762
    return (0);
  }
#line 1763
  if (adef->usertree) {
    {
#line 1763
    tmp___5 = getntrees(adef);
    }
#line 1763
    if (! tmp___5) {
#line 1763
      return (0);
    }
  }
#line 1765
  return (1);
}
}
#line 1772
double randum(long *seed ) ;
#line 1769 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void makeboot(analdef *adef , rawdata *rdta , cruncheddata *cdta ) 
{ 
  int i ;
  int j ;
  int nonzero ;
  double tmp ;
  int tmp___0 ;

  {
#line 1774
  nonzero = 0;
#line 1775
  i = 1;
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1775
    if (! (i <= rdta->sites)) {
#line 1775
      goto while_break;
    }
#line 1775
    if (*(rdta->wgt + i) > 0) {
#line 1775
      nonzero ++;
    }
#line 1775
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1777
  j = 1;
  {
#line 1777
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1777
    if (! (j <= nonzero)) {
#line 1777
      goto while_break___0;
    }
#line 1777
    *(cdta->aliaswgt + j) = 0;
#line 1777
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1778
  j = 1;
  {
#line 1778
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1778
    if (! (j <= nonzero)) {
#line 1778
      goto while_break___1;
    }
    {
#line 1779
    tmp = randum(& adef->boot);
#line 1779
    (*(cdta->aliaswgt + ((int )((double )nonzero * tmp) + 1))) ++;
#line 1778
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1781
  j = 0;
#line 1782
  cdta->wgtsum = 0;
#line 1783
  i = 1;
  {
#line 1783
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1783
    if (! (i <= rdta->sites)) {
#line 1783
      goto while_break___2;
    }
#line 1784
    if (*(rdta->wgt + i) > 0) {
#line 1785
      j ++;
#line 1785
      tmp___0 = *(rdta->wgt + i) * *(cdta->aliaswgt + j);
#line 1785
      *(rdta->wgt2 + i) = tmp___0;
#line 1785
      cdta->wgtsum += tmp___0;
    } else {
#line 1787
      *(rdta->wgt2 + i) = 0;
    }
#line 1783
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1789
  return;
}
}
#line 1792 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void sitesort(rawdata *rdta , cruncheddata *cdta ) 
{ 
  int gap ;
  int i ;
  int j ;
  int jj ;
  int jg ;
  int k ;
  int n ;
  int nsp ;
  int *index ;
  int *category ;
  boolean flip ;
  boolean tied ;
  yType **data ;

  {
#line 1804
  index = cdta->alias;
#line 1805
  category = rdta->sitecat;
#line 1806
  data = rdta->y;
#line 1807
  n = rdta->sites;
#line 1808
  nsp = rdta->numsp;
#line 1810
  gap = n / 2;
  {
#line 1810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1810
    if (! (gap > 0)) {
#line 1810
      goto while_break;
    }
#line 1811
    i = gap + 1;
    {
#line 1811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1811
      if (! (i <= n)) {
#line 1811
        goto while_break___0;
      }
#line 1812
      j = i - gap;
      {
#line 1814
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1815
        jj = *(index + j);
#line 1816
        jg = *(index + (j + gap));
#line 1817
        flip = *(category + jj) > *(category + jg);
#line 1818
        tied = *(category + jj) == *(category + jg);
#line 1819
        k = 1;
        {
#line 1819
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1819
          if (k <= nsp) {
#line 1819
            if (! tied) {
#line 1819
              goto while_break___2;
            }
          } else {
#line 1819
            goto while_break___2;
          }
#line 1820
          flip = (int )*(*(data + k) + jj) > (int )*(*(data + k) + jg);
#line 1821
          tied = (int )*(*(data + k) + jj) == (int )*(*(data + k) + jg);
#line 1819
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1823
        if (flip) {
#line 1824
          *(index + j) = jg;
#line 1825
          *(index + (j + gap)) = jj;
#line 1826
          j -= gap;
        }
#line 1814
        if (flip) {
#line 1814
          if (! (j > 0)) {
#line 1814
            goto while_break___1;
          }
        } else {
#line 1814
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1811
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1810
    gap /= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1832
  return;
}
}
#line 1835 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void sitecombcrunch(rawdata *rdta , cruncheddata *cdta ) 
{ 
  int i ;
  int sitei ;
  int j ;
  int sitej ;
  int k ;
  boolean tied ;

  {
#line 1841
  i = 0;
#line 1842
  *(cdta->alias + 0) = *(cdta->alias + 1);
#line 1843
  *(cdta->aliaswgt + 0) = 0;
#line 1845
  j = 1;
  {
#line 1845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1845
    if (! (j <= rdta->sites)) {
#line 1845
      goto while_break;
    }
#line 1846
    sitei = *(cdta->alias + i);
#line 1847
    sitej = *(cdta->alias + j);
#line 1848
    tied = *(rdta->sitecat + sitei) == *(rdta->sitecat + sitej);
#line 1850
    k = 1;
    {
#line 1850
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1850
      if (tied) {
#line 1850
        if (! (k <= rdta->numsp)) {
#line 1850
          goto while_break___0;
        }
      } else {
#line 1850
        goto while_break___0;
      }
#line 1851
      tied = (int )*(*(rdta->y + k) + sitei) == (int )*(*(rdta->y + k) + sitej);
#line 1850
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1853
    if (tied) {
#line 1854
      *(cdta->aliaswgt + i) += *(rdta->wgt2 + sitej);
    } else {
#line 1857
      if (*(cdta->aliaswgt + i) > 0) {
#line 1857
        i ++;
      }
#line 1858
      *(cdta->aliaswgt + i) = *(rdta->wgt2 + sitej);
#line 1859
      *(cdta->alias + i) = sitej;
    }
#line 1845
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1863
  cdta->endsite = i;
#line 1864
  if (*(cdta->aliaswgt + i) > 0) {
#line 1864
    (cdta->endsite) ++;
  }
#line 1865
  return;
}
}
#line 1868 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean makeweights(analdef *adef , rawdata *rdta , cruncheddata *cdta ) 
{ 
  int i ;

  {
#line 1873
  if (adef->boot) {
    {
#line 1873
    makeboot(adef, rdta, cdta);
    }
  } else {
#line 1874
    i = 1;
    {
#line 1874
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1874
      if (! (i <= rdta->sites)) {
#line 1874
        goto while_break;
      }
#line 1874
      *(rdta->wgt2 + i) = *(rdta->wgt + i);
#line 1874
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1876
  i = 1;
  {
#line 1876
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1876
    if (! (i <= rdta->sites)) {
#line 1876
      goto while_break___0;
    }
#line 1876
    *(cdta->alias + i) = i;
#line 1876
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1877
  sitesort(rdta, cdta);
#line 1878
  sitecombcrunch(rdta, cdta);
#line 1880
  printf((char const   */* __restrict  */)"Total weight of positions in analysis = %d\n",
         cdta->wgtsum);
#line 1881
  printf((char const   */* __restrict  */)"There are %d distinct data patterns (columns)\n\n",
         cdta->endsite);
  }
#line 1883
  return (1);
}
}
#line 1887 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean makevalues(rawdata *rdta , cruncheddata *cdta ) 
{ 
  double temp ;
  double wtemp ;
  int i ;
  int j ;

  {
#line 1893
  i = 1;
  {
#line 1893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1893
    if (! (i <= rdta->numsp)) {
#line 1893
      goto while_break;
    }
#line 1894
    j = 0;
    {
#line 1894
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1894
      if (! (j < cdta->endsite)) {
#line 1894
        goto while_break___0;
      }
#line 1895
      *(*(rdta->y + (i - 1)) + j) = *(*(rdta->y + i) + *(cdta->alias + j));
#line 1894
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1893
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1899
  j = 0;
  {
#line 1899
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1899
    if (! (j < cdta->endsite)) {
#line 1899
      goto while_break___1;
    }
#line 1900
    i = *(rdta->sitecat + *(cdta->alias + j));
#line 1900
    *(cdta->patcat + j) = i;
#line 1901
    temp = rdta->catrat[i];
#line 1901
    *(cdta->patrat + j) = temp;
#line 1902
    wtemp = temp * (double )*(cdta->aliaswgt + j);
#line 1902
    *(cdta->wr + j) = wtemp;
#line 1903
    *(cdta->wr2 + j) = temp * wtemp;
#line 1899
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1906
  return (1);
}
}
#line 1910 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean empiricalfreqs(rawdata *rdta , cruncheddata *cdta ) 
{ 
  double sum ;
  double suma ;
  double sumc ;
  double sumg ;
  double sumt ;
  double wj ;
  double fa ;
  double fc ;
  double fg ;
  double ft ;
  int i ;
  int j ;
  int k ;
  int code ;
  yType *yptr ;
  yType *tmp ;

  {
#line 1917
  rdta->freqa = 0.25;
#line 1918
  rdta->freqc = 0.25;
#line 1919
  rdta->freqg = 0.25;
#line 1920
  rdta->freqt = 0.25;
#line 1921
  k = 1;
  {
#line 1921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1921
    if (! (k <= 8)) {
#line 1921
      goto while_break;
    }
#line 1922
    suma = 0.0;
#line 1923
    sumc = 0.0;
#line 1924
    sumg = 0.0;
#line 1925
    sumt = 0.0;
#line 1926
    i = 0;
    {
#line 1926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1926
      if (! (i < rdta->numsp)) {
#line 1926
        goto while_break___0;
      }
#line 1927
      yptr = *(rdta->y + i);
#line 1928
      j = 0;
      {
#line 1928
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1928
        if (! (j < cdta->endsite)) {
#line 1928
          goto while_break___1;
        }
#line 1929
        tmp = yptr;
#line 1929
        yptr ++;
#line 1929
        code = (int )*tmp;
#line 1930
        fa = rdta->freqa * (double )(code & 1);
#line 1931
        fc = rdta->freqc * (double )((code >> 1) & 1);
#line 1932
        fg = rdta->freqg * (double )((code >> 2) & 1);
#line 1933
        ft = rdta->freqt * (double )((code >> 3) & 1);
#line 1934
        wj = (double )*(cdta->aliaswgt + j) / (((fa + fc) + fg) + ft);
#line 1935
        suma += wj * fa;
#line 1936
        sumc += wj * fc;
#line 1937
        sumg += wj * fg;
#line 1938
        sumt += wj * ft;
#line 1928
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1926
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1941
    sum = ((suma + sumc) + sumg) + sumt;
#line 1942
    rdta->freqa = suma / sum;
#line 1943
    rdta->freqc = sumc / sum;
#line 1944
    rdta->freqg = sumg / sum;
#line 1945
    rdta->freqt = sumt / sum;
#line 1921
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1948
  return (1);
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void reportfreqs(analdef *adef , rawdata *rdta ) 
{ 
  double suma ;
  double sumb ;

  {
#line 1956
  if (adef->empf) {
    {
#line 1956
    printf((char const   */* __restrict  */)"Empirical ");
    }
  }
  {
#line 1957
  printf((char const   */* __restrict  */)"Base Frequencies:\n\n");
#line 1958
  printf((char const   */* __restrict  */)"   A    %10.5f\n", rdta->freqa);
#line 1959
  printf((char const   */* __restrict  */)"   C    %10.5f\n", rdta->freqc);
#line 1960
  printf((char const   */* __restrict  */)"   G    %10.5f\n", rdta->freqg);
#line 1961
  printf((char const   */* __restrict  */)"  T(U)  %10.5f\n\n", rdta->freqt);
#line 1962
  rdta->freqr = rdta->freqa + rdta->freqg;
#line 1963
  rdta->invfreqr = 1.0 / rdta->freqr;
#line 1964
  rdta->freqar = rdta->freqa * rdta->invfreqr;
#line 1965
  rdta->freqgr = rdta->freqg * rdta->invfreqr;
#line 1966
  rdta->freqy = rdta->freqc + rdta->freqt;
#line 1967
  rdta->invfreqy = 1.0 / rdta->freqy;
#line 1968
  rdta->freqcy = rdta->freqc * rdta->invfreqy;
#line 1969
  rdta->freqty = rdta->freqt * rdta->invfreqy;
#line 1970
  printf((char const   */* __restrict  */)"Transition/transversion ratio = %10.6f\n\n",
         rdta->ttratio);
#line 1971
  suma = (rdta->ttratio * rdta->freqr) * rdta->freqy - (rdta->freqa * rdta->freqg + rdta->freqc * rdta->freqt);
#line 1973
  sumb = rdta->freqa * rdta->freqgr + rdta->freqc * rdta->freqty;
#line 1974
  rdta->xi = suma / (suma + sumb);
#line 1975
  rdta->xv = 1.0 - rdta->xi;
  }
#line 1976
  if (rdta->xi <= 0.0) {
    {
#line 1977
    printf((char const   */* __restrict  */)"WARNING: This transition/transversion ratio\n");
#line 1978
    printf((char const   */* __restrict  */)"         is impossible with these base frequencies!\n");
#line 1979
    printf((char const   */* __restrict  */)"Transition/transversion parameter reset\n\n");
#line 1980
    rdta->xi = 0.000001;
#line 1981
    rdta->xv = 1.0 - rdta->xi;
#line 1982
    rdta->ttratio = (((sumb * rdta->xi) / rdta->xv + rdta->freqa * rdta->freqg) + rdta->freqc * rdta->freqt) / (rdta->freqr * rdta->freqy);
#line 1986
    printf((char const   */* __restrict  */)"Transition/transversion ratio = %10.6f\n\n",
           rdta->ttratio);
    }
  }
  {
#line 1988
  printf((char const   */* __restrict  */)"(Transition/transversion parameter = %10.6f)\n\n",
         rdta->xi / rdta->xv);
#line 1990
  rdta->fracchange = (2.0 * rdta->xi) * (rdta->freqa * rdta->freqgr + rdta->freqc * rdta->freqty) + rdta->xv * ((((1.0 - rdta->freqa * rdta->freqa) - rdta->freqc * rdta->freqc) - rdta->freqg * rdta->freqg) - rdta->freqt * rdta->freqt);
  }
#line 1996
  return;
}
}
#line 1999 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean linkdata2tree(rawdata *rdta , cruncheddata *cdta , tree *tr ) 
{ 
  int i ;

  {
#line 2004
  i = 1;
  {
#line 2004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2004
    if (! (i <= tr->mxtips)) {
#line 2004
      goto while_break;
    }
#line 2005
    (*(tr->nodep + i))->tip = *(rdta->y + (i - 1)) + 0;
#line 2004
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2008
  tr->rdta = rdta;
#line 2009
  tr->cdta = cdta;
#line 2010
  return (1);
}
}
#line 2014 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
xarray *setupxarray(int npat ) 
{ 
  xarray *x ;
  likelivector *data ;
  char *tmp ;
  char *tmp___0 ;
  struct xmantyp *tmp___1 ;

  {
  {
#line 2019
  tmp = malloc((unsigned int )sizeof(xarray ));
#line 2019
  x = (xarray *)tmp;
  }
#line 2020
  if (x) {
    {
#line 2021
    tmp___0 = malloc((unsigned int )((unsigned long )npat * sizeof(likelivector )));
#line 2021
    data = (likelivector *)tmp___0;
    }
#line 2022
    if (data) {
#line 2023
      x->lv = data;
#line 2024
      tmp___1 = x;
#line 2024
      x->next = tmp___1;
#line 2024
      x->prev = tmp___1;
#line 2025
      x->owner = (node *)((void *)0);
    } else {
      {
#line 2028
      free((char *)x);
      }
#line 2029
      return ((xarray *)((void *)0));
    }
  }
#line 2032
  return (x);
}
}
#line 2036 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean linkxarray(int req , int min , int npat , xarray **freexptr , xarray **usedxptr ) 
{ 
  xarray *first ;
  xarray *prev ;
  xarray *x ;
  int i ;

  {
#line 2043
  prev = (xarray *)((void *)0);
#line 2043
  first = prev;
#line 2044
  i = 0;
  {
#line 2046
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2047
    x = setupxarray(npat);
    }
#line 2048
    if (x) {
#line 2049
      if (! first) {
#line 2049
        first = x;
      } else {
#line 2051
        prev->next = x;
#line 2052
        x->prev = prev;
      }
#line 2054
      prev = x;
#line 2055
      i ++;
    } else {
      {
#line 2058
      printf((char const   */* __restrict  */)"ERROR: Failure to get requested xarray memory\n");
      }
#line 2059
      if (i < min) {
#line 2059
        return (0);
      }
    }
#line 2046
    if (i < req) {
#line 2046
      if (! x) {
#line 2046
        goto while_break;
      }
    } else {
#line 2046
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2063
  if (first) {
#line 2064
    first->prev = prev;
#line 2065
    prev->next = first;
  }
#line 2068
  *freexptr = first;
#line 2069
  *usedxptr = (xarray *)((void *)0);
#line 2071
  return (1);
}
}
#line 2075 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean setupnodex(tree *tr ) 
{ 
  nodeptr p ;
  int i ;
  xarray *tmp ;

  {
#line 2080
  i = tr->mxtips + 1;
  {
#line 2080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2080
    if (! (i <= 2 * tr->mxtips - 2)) {
#line 2080
      goto while_break;
    }
    {
#line 2081
    p = *(tr->nodep + i);
#line 2082
    tmp = setupxarray((tr->cdta)->endsite);
#line 2082
    p->x = tmp;
    }
#line 2082
    if (! tmp) {
      {
#line 2083
      printf((char const   */* __restrict  */)"ERROR: Failure to get internal node xarray memory\n");
      }
#line 2084
      return (0);
    }
#line 2080
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2088
  return (1);
}
}
#line 2092 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
xarray *getxtip(nodeptr p ) 
{ 
  xarray *new ;
  boolean splice ;
  struct xmantyp *tmp ;
  struct xmantyp *tmp___0 ;

  {
#line 2097
  if (! p) {
#line 2097
    return ((xarray *)((void *)0));
  }
#line 2099
  splice = 0;
#line 2101
  if (p->x) {
#line 2102
    new = p->x;
#line 2103
    if (! ((unsigned long )new == (unsigned long )new->prev)) {
#line 2104
      if ((unsigned long )new == (unsigned long )usedxtip) {
#line 2104
        usedxtip = usedxtip->next;
      } else
#line 2105
      if (! ((unsigned long )new == (unsigned long )usedxtip->prev)) {
#line 2107
        (new->prev)->next = new->next;
#line 2108
        (new->next)->prev = new->prev;
#line 2109
        splice = 1;
      }
    }
  } else
#line 2113
  if (freextip) {
#line 2114
    new = freextip;
#line 2114
    p->x = new;
#line 2115
    new->owner = p;
#line 2116
    if ((unsigned long )new->prev != (unsigned long )new) {
#line 2117
      (new->prev)->next = new->next;
#line 2118
      (new->next)->prev = new->prev;
#line 2119
      freextip = new->next;
    } else {
#line 2122
      freextip = (xarray *)((void *)0);
    }
#line 2124
    splice = 1;
  } else
#line 2127
  if (usedxtip) {
#line 2128
    (usedxtip->owner)->x = (xarray *)((void *)0);
#line 2129
    new = usedxtip;
#line 2129
    p->x = new;
#line 2130
    new->owner = p;
#line 2131
    usedxtip = usedxtip->next;
  } else {
    {
#line 2135
    printf((char const   */* __restrict  */)"ERROR: Unable to locate memory for tip %d.\n",
           p->number);
    }
#line 2136
    return ((xarray *)((void *)0));
  }
#line 2139
  if (splice) {
#line 2140
    if (usedxtip) {
#line 2141
      (usedxtip->prev)->next = new;
#line 2142
      new->prev = usedxtip->prev;
#line 2143
      usedxtip->prev = new;
#line 2144
      new->next = usedxtip;
    } else {
#line 2147
      tmp___0 = new;
#line 2147
      new->next = tmp___0;
#line 2147
      tmp = tmp___0;
#line 2147
      new->prev = tmp;
#line 2147
      usedxtip = tmp;
    }
  }
#line 2150
  return (new);
}
}
#line 2154 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
xarray *getxnode(nodeptr p ) 
{ 
  nodeptr s ;

  {
#line 2159
  if (! p->x) {
#line 2160
    s = p->next;
#line 2160
    if (s->x) {
#line 2161
      p->x = s->x;
#line 2162
      s->x = (xarray *)((void *)0);
    } else {
#line 2160
      s = s->next;
#line 2160
      if (s->x) {
#line 2161
        p->x = s->x;
#line 2162
        s->x = (xarray *)((void *)0);
      } else {
        {
#line 2165
        printf((char const   */* __restrict  */)"ERROR: Unable to locate memory at node %d.\n",
               p->number);
#line 2166
        exit(1);
        }
      }
    }
  }
#line 2169
  return (p->x);
}
}
#line 2173 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean newview(tree *tr , nodeptr p ) 
{ 
  double zq ;
  double lzq ;
  double xvlzq ;
  double zr ;
  double lzr ;
  double xvlzr ;
  nodeptr q ;
  nodeptr r ;
  likelivector *lp ;
  likelivector *lq ;
  likelivector *lr ;
  int i ;
  likelivector *l ;
  int code ;
  yType *yptr ;
  xarray *tmp ;
  yType *tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  xarray *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double zzqtable[36] ;
  double zvqtable[36] ;
  double zzrtable[36] ;
  double zvrtable[36] ;
  double *zzqptr ;
  double *zvqptr ;
  double *zzrptr ;
  double *zvrptr ;
  double *rptr ;
  double fxqr ;
  double fxqy ;
  double fxqn ;
  double sumaq ;
  double sumgq ;
  double sumcq ;
  double sumtq ;
  double fxrr ;
  double fxry ;
  double fxrn ;
  double ki ;
  double tempi ;
  double tempj ;
  int *cptr ;
  double zzq ;
  double zvq ;
  double zzr ;
  double zvr ;
  int cat ;
  double *tmp___8 ;
  double *tmp___9 ;
  double *tmp___10 ;
  double *tmp___11 ;
  double *tmp___12 ;
  int *tmp___13 ;

  {
#line 2180
  if (p->tip) {
#line 2185
    if (p->x) {
#line 2185
      return (1);
    }
    {
#line 2187
    tmp = getxtip(p);
    }
#line 2187
    if (! tmp) {
#line 2187
      return (0);
    }
#line 2188
    l = (p->x)->lv;
#line 2189
    yptr = p->tip;
#line 2190
    i = 0;
    {
#line 2190
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2190
      if (! (i < (tr->cdta)->endsite)) {
#line 2190
        goto while_break;
      }
#line 2191
      tmp___0 = yptr;
#line 2191
      yptr ++;
#line 2191
      code = (int )*tmp___0;
#line 2192
      l->a = (xtype )(code & 1);
#line 2193
      l->c = (xtype )((code >> 1) & 1);
#line 2194
      l->g = (xtype )((code >> 2) & 1);
#line 2195
      l->t = (xtype )((code >> 3) & 1);
#line 2196
      l->exp = 0L;
#line 2197
      l ++;
#line 2190
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2199
    return (1);
  }
#line 2204
  q = (p->next)->back;
#line 2205
  r = ((p->next)->next)->back;
  {
#line 2207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2207
    if (! (! p->x)) {
#line 2207
      if (! (! q->x)) {
#line 2207
        if (! (! r->x)) {
#line 2207
          goto while_break___0;
        }
      }
    }
#line 2208
    if (! q->x) {
      {
#line 2208
      tmp___1 = newview(tr, q);
      }
#line 2208
      if (! tmp___1) {
#line 2208
        return (0);
      }
    }
#line 2209
    if (! r->x) {
      {
#line 2209
      tmp___2 = newview(tr, r);
      }
#line 2209
      if (! tmp___2) {
#line 2209
        return (0);
      }
    }
#line 2210
    if (! p->x) {
      {
#line 2210
      tmp___3 = getxnode(p);
      }
#line 2210
      if (! tmp___3) {
#line 2210
        return (0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2213
  lp = (p->x)->lv;
#line 2215
  lq = (q->x)->lv;
#line 2216
  zq = q->z;
#line 2217
  if (zq > 1.0E-15) {
    {
#line 2217
    tmp___4 = log(zq);
#line 2217
    lzq = tmp___4;
    }
  } else {
    {
#line 2217
    tmp___5 = log(1.0E-15);
#line 2217
    lzq = tmp___5;
    }
  }
#line 2218
  xvlzq = (tr->rdta)->xv * lzq;
#line 2220
  lr = (r->x)->lv;
#line 2221
  zr = r->z;
#line 2222
  if (zr > 1.0E-15) {
    {
#line 2222
    tmp___6 = log(zr);
#line 2222
    lzr = tmp___6;
    }
  } else {
    {
#line 2222
    tmp___7 = log(1.0E-15);
#line 2222
    lzr = tmp___7;
    }
  }
#line 2223
  xvlzr = (tr->rdta)->xv * lzr;
#line 2241
  rptr = & (tr->rdta)->catrat[1];
#line 2242
  zzqptr = & zzqtable[1];
#line 2243
  zvqptr = & zvqtable[1];
#line 2244
  zzrptr = & zzrtable[1];
#line 2245
  zvrptr = & zvrtable[1];
#line 2251
  i = 1;
  {
#line 2251
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2251
    if (! (i <= (tr->rdta)->categs)) {
#line 2251
      goto while_break___1;
    }
    {
#line 2252
    tmp___8 = rptr;
#line 2252
    rptr ++;
#line 2252
    ki = *tmp___8;
#line 2253
    tmp___9 = zzqptr;
#line 2253
    zzqptr ++;
#line 2253
    *tmp___9 = exp(ki * lzq);
#line 2254
    tmp___10 = zvqptr;
#line 2254
    zvqptr ++;
#line 2254
    *tmp___10 = exp(ki * xvlzq);
#line 2255
    tmp___11 = zzrptr;
#line 2255
    zzrptr ++;
#line 2255
    *tmp___11 = exp(ki * lzr);
#line 2256
    tmp___12 = zvrptr;
#line 2256
    zvrptr ++;
#line 2256
    *tmp___12 = exp(ki * xvlzr);
#line 2251
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2259
  cptr = (tr->cdta)->patcat + 0;
#line 2312
  i = 0;
  {
#line 2312
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2312
    if (! (i < (tr->cdta)->endsite)) {
#line 2312
      goto while_break___2;
    }
#line 2313
    tmp___13 = cptr;
#line 2313
    cptr ++;
#line 2313
    cat = *tmp___13;
#line 2314
    zzq = zzqtable[cat];
#line 2315
    zvq = zvqtable[cat];
#line 2316
    fxqr = (tr->rdta)->freqa * lq->a + (tr->rdta)->freqg * lq->g;
#line 2317
    fxqy = (tr->rdta)->freqc * lq->c + (tr->rdta)->freqt * lq->t;
#line 2318
    fxqn = fxqr + fxqy;
#line 2319
    tempi = fxqr * (tr->rdta)->invfreqr;
#line 2320
    tempj = zvq * (tempi - fxqn) + fxqn;
#line 2321
    sumaq = zzq * (lq->a - tempi) + tempj;
#line 2322
    sumgq = zzq * (lq->g - tempi) + tempj;
#line 2323
    tempi = fxqy * (tr->rdta)->invfreqy;
#line 2324
    tempj = zvq * (tempi - fxqn) + fxqn;
#line 2325
    sumcq = zzq * (lq->c - tempi) + tempj;
#line 2326
    sumtq = zzq * (lq->t - tempi) + tempj;
#line 2328
    zzr = zzrtable[cat];
#line 2329
    zvr = zvrtable[cat];
#line 2330
    fxrr = (tr->rdta)->freqa * lr->a + (tr->rdta)->freqg * lr->g;
#line 2331
    fxry = (tr->rdta)->freqc * lr->c + (tr->rdta)->freqt * lr->t;
#line 2332
    fxrn = fxrr + fxry;
#line 2333
    tempi = fxrr * (tr->rdta)->invfreqr;
#line 2334
    tempj = zvr * (tempi - fxrn) + fxrn;
#line 2335
    lp->a = sumaq * (zzr * (lr->a - tempi) + tempj);
#line 2336
    lp->g = sumgq * (zzr * (lr->g - tempi) + tempj);
#line 2337
    tempi = fxry * (tr->rdta)->invfreqy;
#line 2338
    tempj = zvr * (tempi - fxrn) + fxrn;
#line 2339
    lp->c = sumcq * (zzr * (lr->c - tempi) + tempj);
#line 2340
    lp->t = sumtq * (zzr * (lr->t - tempi) + tempj);
#line 2341
    lp->exp = lq->exp + lr->exp;
#line 2343
    if (lp->a < 1.0 / 115792089237316195423570985008687907853269984665640564039457584007913129639936.0) {
#line 2343
      if (lp->g < 1.0 / 115792089237316195423570985008687907853269984665640564039457584007913129639936.0) {
#line 2343
        if (lp->c < 1.0 / 115792089237316195423570985008687907853269984665640564039457584007913129639936.0) {
#line 2343
          if (lp->t < 1.0 / 115792089237316195423570985008687907853269984665640564039457584007913129639936.0) {
#line 2345
            lp->a *= 115792089237316195423570985008687907853269984665640564039457584007913129639936.0;
#line 2346
            lp->g *= 115792089237316195423570985008687907853269984665640564039457584007913129639936.0;
#line 2347
            lp->c *= 115792089237316195423570985008687907853269984665640564039457584007913129639936.0;
#line 2348
            lp->t *= 115792089237316195423570985008687907853269984665640564039457584007913129639936.0;
#line 2349
            (lp->exp) ++;
          }
        }
      }
    }
#line 2351
    lp ++;
#line 2352
    lq ++;
#line 2353
    lr ++;
#line 2312
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2357
  return (1);
}
}
#line 2362 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
double evaluate(tree *tr , nodeptr p ) 
{ 
  double sum ;
  double z ;
  double lz ;
  double xvlz ;
  double ki ;
  double fxpa ;
  double fxpc ;
  double fxpg ;
  double fxpt ;
  double fxpr ;
  double fxpy ;
  double fxqr ;
  double fxqy ;
  double suma ;
  double sumb ;
  double sumc ;
  double term ;
  double zz ;
  double zv ;
  double zztable[36] ;
  double zvtable[36] ;
  double *zzptr ;
  double *zvptr ;
  double *log_f ;
  double *rptr ;
  likelivector *lp ;
  likelivector *lq ;
  nodeptr q ;
  int cat ;
  int *cptr ;
  int i ;
  int *wptr ;
  boolean tmp ;
  boolean tmp___0 ;
  double *tmp___1 ;
  double *tmp___2 ;
  double *tmp___3 ;
  int *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  int *tmp___7 ;
  double *tmp___8 ;

  {
#line 2381
  q = p->back;
  {
#line 2382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2382
    if (! (! p->x)) {
#line 2382
      if (! (! q->x)) {
#line 2382
        goto while_break;
      }
    }
#line 2383
    if (! p->x) {
      {
#line 2383
      tmp = newview(tr, p);
      }
#line 2383
      if (! tmp) {
#line 2383
        return (1.0);
      }
    }
#line 2384
    if (! q->x) {
      {
#line 2384
      tmp___0 = newview(tr, q);
      }
#line 2384
      if (! tmp___0) {
#line 2384
        return (1.0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2387
  lp = (p->x)->lv;
#line 2388
  lq = (q->x)->lv;
#line 2390
  z = p->z;
#line 2391
  if (z < 1.0E-15) {
#line 2391
    z = 1.0E-15;
  }
  {
#line 2392
  lz = log(z);
#line 2393
  xvlz = (tr->rdta)->xv * lz;
#line 2395
  rptr = & (tr->rdta)->catrat[1];
#line 2396
  zzptr = & zztable[1];
#line 2397
  zvptr = & zvtable[1];
#line 2403
  i = 1;
  }
  {
#line 2403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2403
    if (! (i <= (tr->rdta)->categs)) {
#line 2403
      goto while_break___0;
    }
    {
#line 2404
    tmp___1 = rptr;
#line 2404
    rptr ++;
#line 2404
    ki = *tmp___1;
#line 2405
    tmp___2 = zzptr;
#line 2405
    zzptr ++;
#line 2405
    *tmp___2 = exp(ki * lz);
#line 2406
    tmp___3 = zvptr;
#line 2406
    zvptr ++;
#line 2406
    *tmp___3 = exp(ki * xvlz);
#line 2403
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2409
  wptr = (tr->cdta)->aliaswgt + 0;
#line 2410
  cptr = (tr->cdta)->patcat + 0;
#line 2411
  log_f = tr->log_f;
#line 2412
  tr->log_f_valid = (tr->cdta)->endsite;
#line 2413
  sum = 0.0;
#line 2446
  i = 0;
  {
#line 2446
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2446
    if (! (i < (tr->cdta)->endsite)) {
#line 2446
      goto while_break___1;
    }
    {
#line 2447
    tmp___4 = cptr;
#line 2447
    cptr ++;
#line 2447
    cat = *tmp___4;
#line 2448
    zz = zztable[cat];
#line 2449
    zv = zvtable[cat];
#line 2450
    fxpa = (tr->rdta)->freqa * lp->a;
#line 2451
    fxpg = (tr->rdta)->freqg * lp->g;
#line 2452
    fxpc = (tr->rdta)->freqc * lp->c;
#line 2453
    fxpt = (tr->rdta)->freqt * lp->t;
#line 2454
    suma = ((fxpa * lq->a + fxpc * lq->c) + fxpg * lq->g) + fxpt * lq->t;
#line 2455
    fxqr = (tr->rdta)->freqa * lq->a + (tr->rdta)->freqg * lq->g;
#line 2456
    fxqy = (tr->rdta)->freqc * lq->c + (tr->rdta)->freqt * lq->t;
#line 2457
    fxpr = fxpa + fxpg;
#line 2458
    fxpy = fxpc + fxpt;
#line 2459
    sumc = (fxpr + fxpy) * (fxqr + fxqy);
#line 2460
    sumb = (fxpr * fxqr) * (tr->rdta)->invfreqr + (fxpy * fxqy) * (tr->rdta)->invfreqy;
#line 2461
    suma -= sumb;
#line 2462
    sumb -= sumc;
#line 2463
    tmp___5 = log((zz * suma + zv * sumb) + sumc);
#line 2463
    tmp___6 = log(1.0 / 115792089237316195423570985008687907853269984665640564039457584007913129639936.0);
#line 2463
    term = tmp___5 + (double )(lp->exp + lq->exp) * tmp___6;
#line 2465
    tmp___7 = wptr;
#line 2465
    wptr ++;
#line 2465
    sum += (double )*tmp___7 * term;
#line 2466
    tmp___8 = log_f;
#line 2466
    log_f ++;
#line 2466
    *tmp___8 = term;
#line 2467
    lp ++;
#line 2468
    lq ++;
#line 2446
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2472
  tr->likelihood = sum;
#line 2473
  return (sum);
}
}
#line 2477 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
double makenewz(tree *tr , nodeptr p , nodeptr q , double z0 , int maxiter ) 
{ 
  likelivector *lp ;
  likelivector *lq ;
  double *abi ;
  double *bci ;
  double *sumci ;
  double *abptr ;
  double *bcptr ;
  double *sumcptr ;
  double dlnLidlz ;
  double dlnLdlz ;
  double d2lnLdlz2 ;
  double z ;
  double zprev ;
  double zstep ;
  double lz ;
  double xvlz ;
  double ki ;
  double suma ;
  double sumb ;
  double sumc ;
  double ab ;
  double bc ;
  double inv_Li ;
  double t1 ;
  double t2 ;
  double fx1a ;
  double fx1c ;
  double fx1g ;
  double fx1t ;
  double fx1r ;
  double fx1y ;
  double fx2r ;
  double fx2y ;
  double zztable[36] ;
  double zvtable[36] ;
  double *zzptr ;
  double *zvptr ;
  double *rptr ;
  double *wrptr ;
  double *wr2ptr ;
  int cat ;
  int *cptr ;
  int i ;
  int curvatOK ;
  boolean tmp ;
  boolean tmp___0 ;
  unsigned int scratch_size ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  double *tmp___4 ;
  double *tmp___5 ;
  double *tmp___6 ;
  double *tmp___7 ;
  double *tmp___8 ;
  double *tmp___9 ;
  int *tmp___10 ;
  double *tmp___11 ;
  double *tmp___12 ;
  double *tmp___13 ;
  double *tmp___14 ;
  double *tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;

  {
  {
#line 2490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2490
    if (! (! p->x)) {
#line 2490
      if (! (! q->x)) {
#line 2490
        goto while_break;
      }
    }
#line 2491
    if (! p->x) {
      {
#line 2491
      tmp = newview(tr, p);
      }
#line 2491
      if (! tmp) {
#line 2491
        return (0.0);
      }
    }
#line 2492
    if (! q->x) {
      {
#line 2492
      tmp___0 = newview(tr, q);
      }
#line 2492
      if (! tmp___0) {
#line 2492
        return (0.0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2495
  lp = (p->x)->lv;
#line 2496
  lq = (q->x)->lv;
#line 2499
  scratch_size = (unsigned int )(sizeof(double ) * (unsigned long )(tr->cdta)->endsite);
#line 2500
  tmp___1 = malloc(scratch_size);
#line 2500
  abi = (double *)tmp___1;
  }
#line 2500
  if (abi) {
    {
#line 2500
    tmp___2 = malloc(scratch_size);
#line 2500
    bci = (double *)tmp___2;
    }
#line 2500
    if (bci) {
      {
#line 2500
      tmp___3 = malloc(scratch_size);
#line 2500
      sumci = (double *)tmp___3;
      }
#line 2500
      if (! sumci) {
        {
#line 2504
        printf((char const   */* __restrict  */)"ERROR: makenewz unable to obtain space for arrays\n");
        }
#line 2505
        return (0.0);
      }
    } else {
      {
#line 2504
      printf((char const   */* __restrict  */)"ERROR: makenewz unable to obtain space for arrays\n");
      }
#line 2505
      return (0.0);
    }
  } else {
    {
#line 2504
    printf((char const   */* __restrict  */)"ERROR: makenewz unable to obtain space for arrays\n");
    }
#line 2505
    return (0.0);
  }
#line 2508
  abptr = abi;
#line 2509
  bcptr = bci;
#line 2510
  sumcptr = sumci;
#line 2516
  i = 0;
  {
#line 2516
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2516
    if (! (i < (tr->cdta)->endsite)) {
#line 2516
      goto while_break___0;
    }
#line 2517
    fx1a = (tr->rdta)->freqa * lp->a;
#line 2518
    fx1g = (tr->rdta)->freqg * lp->g;
#line 2519
    fx1c = (tr->rdta)->freqc * lp->c;
#line 2520
    fx1t = (tr->rdta)->freqt * lp->t;
#line 2521
    suma = ((fx1a * lq->a + fx1c * lq->c) + fx1g * lq->g) + fx1t * lq->t;
#line 2522
    fx2r = (tr->rdta)->freqa * lq->a + (tr->rdta)->freqg * lq->g;
#line 2523
    fx2y = (tr->rdta)->freqc * lq->c + (tr->rdta)->freqt * lq->t;
#line 2524
    fx1r = fx1a + fx1g;
#line 2525
    fx1y = fx1c + fx1t;
#line 2526
    tmp___4 = sumcptr;
#line 2526
    sumcptr ++;
#line 2526
    sumc = (fx1r + fx1y) * (fx2r + fx2y);
#line 2526
    *tmp___4 = sumc;
#line 2527
    sumb = (fx1r * fx2r) * (tr->rdta)->invfreqr + (fx1y * fx2y) * (tr->rdta)->invfreqy;
#line 2528
    tmp___5 = abptr;
#line 2528
    abptr ++;
#line 2528
    *tmp___5 = suma - sumb;
#line 2529
    tmp___6 = bcptr;
#line 2529
    bcptr ++;
#line 2529
    *tmp___6 = sumb - sumc;
#line 2530
    lp ++;
#line 2531
    lq ++;
#line 2516
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2534
  z = z0;
  {
#line 2535
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2536
    zprev = z;
#line 2537
    zstep = (1.0 - (1.0 - 1.0E-6)) * z + 1.0E-15;
#line 2538
    curvatOK = 0;
    {
#line 2540
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2541
      if (z < 1.0E-15) {
#line 2541
        z = 1.0E-15;
      } else
#line 2542
      if (z > 1.0 - 1.0E-6) {
#line 2542
        z = 1.0 - 1.0E-6;
      }
      {
#line 2544
      lz = log(z);
#line 2545
      xvlz = (tr->rdta)->xv * lz;
#line 2546
      rptr = & (tr->rdta)->catrat[1];
#line 2547
      zzptr = & zztable[1];
#line 2548
      zvptr = & zvtable[1];
#line 2554
      i = 1;
      }
      {
#line 2554
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2554
        if (! (i <= (tr->rdta)->categs)) {
#line 2554
          goto while_break___3;
        }
        {
#line 2555
        tmp___7 = rptr;
#line 2555
        rptr ++;
#line 2555
        ki = *tmp___7;
#line 2556
        tmp___8 = zzptr;
#line 2556
        zzptr ++;
#line 2556
        *tmp___8 = exp(ki * lz);
#line 2557
        tmp___9 = zvptr;
#line 2557
        zvptr ++;
#line 2557
        *tmp___9 = exp(ki * xvlz);
#line 2554
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2560
      abptr = abi;
#line 2561
      bcptr = bci;
#line 2562
      sumcptr = sumci;
#line 2563
      cptr = (tr->cdta)->patcat + 0;
#line 2564
      wrptr = (tr->cdta)->wr + 0;
#line 2565
      wr2ptr = (tr->cdta)->wr2 + 0;
#line 2566
      dlnLdlz = 0.0;
#line 2567
      d2lnLdlz2 = 0.0;
#line 2573
      i = 0;
      {
#line 2573
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2573
        if (! (i < (tr->cdta)->endsite)) {
#line 2573
          goto while_break___4;
        }
#line 2574
        tmp___10 = cptr;
#line 2574
        cptr ++;
#line 2574
        cat = *tmp___10;
#line 2575
        tmp___11 = abptr;
#line 2575
        abptr ++;
#line 2575
        ab = *tmp___11 * zztable[cat];
#line 2576
        tmp___12 = bcptr;
#line 2576
        bcptr ++;
#line 2576
        bc = *tmp___12 * zvtable[cat];
#line 2577
        tmp___13 = sumcptr;
#line 2577
        sumcptr ++;
#line 2577
        sumc = *tmp___13;
#line 2578
        inv_Li = 1.0 / ((ab + bc) + sumc);
#line 2579
        t1 = ab * inv_Li;
#line 2580
        t2 = ((tr->rdta)->xv * bc) * inv_Li;
#line 2581
        dlnLidlz = t1 + t2;
#line 2582
        tmp___14 = wrptr;
#line 2582
        wrptr ++;
#line 2582
        dlnLdlz += *tmp___14 * dlnLidlz;
#line 2583
        tmp___15 = wr2ptr;
#line 2583
        wr2ptr ++;
#line 2583
        d2lnLdlz2 += *tmp___15 * ((t1 + (tr->rdta)->xv * t2) - dlnLidlz * dlnLidlz);
#line 2573
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2586
      if (d2lnLdlz2 >= 0.0) {
#line 2586
        if (z < 1.0 - 1.0E-6) {
#line 2587
          z = 0.37 * z + 0.63;
#line 2587
          zprev = z;
        } else {
#line 2589
          curvatOK = 1;
        }
      } else {
#line 2589
        curvatOK = 1;
      }
#line 2540
      if (! (! curvatOK)) {
#line 2540
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2593
    if (d2lnLdlz2 < 0.0) {
      {
#line 2594
      tmp___16 = exp(- dlnLdlz / d2lnLdlz2);
#line 2594
      z *= tmp___16;
      }
#line 2595
      if (z < 1.0E-15) {
#line 2595
        z = 1.0E-15;
      }
#line 2596
      if (z > 0.25 * zprev + 0.75) {
#line 2597
        z = 0.25 * zprev + 0.75;
      }
    }
#line 2600
    if (z > 1.0 - 1.0E-6) {
#line 2600
      z = 1.0 - 1.0E-6;
    }
#line 2535
    maxiter --;
#line 2535
    if (maxiter > 0) {
#line 2535
      if (z - zprev < (double )0) {
#line 2535
        tmp___17 = - (z - zprev);
      } else {
#line 2535
        tmp___17 = z - zprev;
      }
#line 2535
      if (! (tmp___17 > zstep)) {
#line 2535
        goto while_break___1;
      }
    } else {
#line 2535
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2604
  free((char *)abi);
#line 2605
  free((char *)bci);
#line 2606
  free((char *)sumci);
  }
#line 2610
  return (z);
}
}
#line 2614 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean update(tree *tr , nodeptr p ) 
{ 
  nodeptr q ;
  double z0 ;
  double z ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 2619
  q = p->back;
#line 2620
  z0 = q->z;
#line 2621
  z = makenewz(tr, p, q, z0, 1);
  }
#line 2621
  if (z == 0.0) {
#line 2621
    return (0);
  }
#line 2622
  tmp = z;
#line 2622
  q->z = tmp;
#line 2622
  p->z = tmp;
#line 2623
  if (z - z0 < (double )0) {
#line 2623
    tmp___0 = - (z - z0);
  } else {
#line 2623
    tmp___0 = z - z0;
  }
#line 2623
  if (tmp___0 > 0.00001) {
#line 2623
    tr->smoothed = 0;
  }
#line 2624
  return (1);
}
}
#line 2628 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean smooth(tree *tr , nodeptr p ) 
{ 
  nodeptr q ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
  {
#line 2632
  tmp = update(tr, p);
  }
#line 2632
  if (! tmp) {
#line 2632
    return (0);
  }
#line 2633
  if (! p->tip) {
#line 2634
    q = p->next;
    {
#line 2635
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2635
      if (! ((unsigned long )q != (unsigned long )p)) {
#line 2635
        goto while_break;
      }
      {
#line 2636
      tmp___0 = smooth(tr, q->back);
      }
#line 2636
      if (! tmp___0) {
#line 2636
        return (0);
      }
#line 2637
      q = q->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2641
    tmp___1 = newview(tr, p);
    }
#line 2641
    if (! tmp___1) {
#line 2641
      return (0);
    }
  }
#line 2645
  return (1);
}
}
#line 2649 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean smoothTree(tree *tr , int maxtimes ) 
{ 
  nodeptr p ;
  nodeptr q ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 2653
  p = tr->start;
  {
#line 2655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2655
    maxtimes --;
#line 2655
    if (! (maxtimes >= 0)) {
#line 2655
      goto while_break;
    }
    {
#line 2656
    tr->smoothed = 1;
#line 2657
    tmp = smooth(tr, p->back);
    }
#line 2657
    if (! tmp) {
#line 2657
      return (0);
    }
#line 2658
    if (! p->tip) {
#line 2659
      q = p->next;
      {
#line 2660
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2660
        if (! ((unsigned long )q != (unsigned long )p)) {
#line 2660
          goto while_break___0;
        }
        {
#line 2661
        tmp___0 = smooth(tr, q->back);
        }
#line 2661
        if (! tmp___0) {
#line 2661
          return (0);
        }
#line 2662
        q = q->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2665
    if (tr->smoothed) {
#line 2665
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2668
  return (1);
}
}
#line 2672 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean localSmooth(tree *tr , nodeptr p , int maxtimes ) 
{ 
  nodeptr q ;
  boolean tmp ;

  {
#line 2676
  if (p->tip) {
#line 2676
    return (0);
  }
  {
#line 2678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2678
    maxtimes --;
#line 2678
    if (! (maxtimes >= 0)) {
#line 2678
      goto while_break;
    }
#line 2679
    tr->smoothed = 1;
#line 2680
    q = p;
    {
#line 2681
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2682
      tmp = update(tr, q);
      }
#line 2682
      if (! tmp) {
#line 2682
        return (0);
      }
#line 2683
      q = q->next;
#line 2681
      if (! ((unsigned long )q != (unsigned long )p)) {
#line 2681
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2685
    if (tr->smoothed) {
#line 2685
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2688
  tr->smoothed = 0;
#line 2689
  return (1);
}
}
#line 2693 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void hookup(nodeptr p , nodeptr q , double z ) 
{ 
  double tmp ;

  {
#line 2695
  p->back = q;
#line 2696
  q->back = p;
#line 2697
  tmp = z;
#line 2697
  q->z = tmp;
#line 2697
  p->z = tmp;
#line 2698
  return;
}
}
#line 2703 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean insert(tree *tr , nodeptr p , nodeptr q , boolean glob ) 
{ 
  nodeptr r ;
  nodeptr s ;
  double zqr ;
  double zqs ;
  double zrs ;
  double lzqr ;
  double lzqs ;
  double lzrs ;
  double lzsum ;
  double lzq ;
  double lzr ;
  double lzs ;
  double lzmax ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  boolean tmp___8 ;
  boolean tmp___9 ;
  boolean tmp___10 ;

  {
  {
#line 2722
  r = q->back;
#line 2723
  s = p->back;
#line 2728
  zqr = makenewz(tr, q, r, q->z, 10);
  }
#line 2728
  if (zqr == 0.0) {
#line 2728
    return (0);
  }
  {
#line 2729
  zqs = makenewz(tr, q, s, 0.9, 10);
  }
#line 2729
  if (zqs == 0.0) {
#line 2729
    return (0);
  }
  {
#line 2730
  zrs = makenewz(tr, r, s, 0.9, 10);
  }
#line 2730
  if (zrs == 0.0) {
#line 2730
    return (0);
  }
#line 2732
  if (zqr > 1.0E-15) {
    {
#line 2732
    tmp = log(zqr);
#line 2732
    lzqr = tmp;
    }
  } else {
    {
#line 2732
    tmp___0 = log(1.0E-15);
#line 2732
    lzqr = tmp___0;
    }
  }
#line 2733
  if (zqs > 1.0E-15) {
    {
#line 2733
    tmp___1 = log(zqs);
#line 2733
    lzqs = tmp___1;
    }
  } else {
    {
#line 2733
    tmp___2 = log(1.0E-15);
#line 2733
    lzqs = tmp___2;
    }
  }
#line 2734
  if (zrs > 1.0E-15) {
    {
#line 2734
    tmp___3 = log(zrs);
#line 2734
    lzrs = tmp___3;
    }
  } else {
    {
#line 2734
    tmp___4 = log(1.0E-15);
#line 2734
    lzrs = tmp___4;
    }
  }
  {
#line 2735
  lzsum = 0.5 * ((lzqr + lzqs) + lzrs);
#line 2737
  lzq = lzsum - lzrs;
#line 2738
  lzr = lzsum - lzqs;
#line 2739
  lzs = lzsum - lzqr;
#line 2740
  lzmax = log(1.0 - 1.0E-6);
  }
#line 2742
  if (lzq > lzmax) {
#line 2742
    lzq = lzmax;
#line 2742
    lzr = lzqr;
#line 2742
    lzs = lzqs;
  } else
#line 2743
  if (lzr > lzmax) {
#line 2743
    lzr = lzmax;
#line 2743
    lzq = lzqr;
#line 2743
    lzs = lzrs;
  } else
#line 2744
  if (lzs > lzmax) {
#line 2744
    lzs = lzmax;
#line 2744
    lzq = lzqs;
#line 2744
    lzr = lzrs;
  }
  {
#line 2746
  tmp___5 = exp(lzq);
#line 2746
  hookup(p->next, q, tmp___5);
#line 2747
  tmp___6 = exp(lzr);
#line 2747
  hookup((p->next)->next, r, tmp___6);
#line 2748
  tmp___7 = exp(lzs);
#line 2748
  hookup(p, s, tmp___7);
#line 2760
  tmp___8 = newview(tr, p);
  }
#line 2760
  if (! tmp___8) {
#line 2760
    return (0);
  }
#line 2761
  tr->opt_level = 0;
#line 2764
  if (glob) {
    {
#line 2765
    tmp___9 = smoothTree(tr, 32);
    }
#line 2765
    if (! tmp___9) {
#line 2765
      return (0);
    }
  } else {
    {
#line 2768
    tmp___10 = localSmooth(tr, p, 32);
    }
#line 2768
    if (! tmp___10) {
#line 2768
      return (0);
    }
  }
#line 2774
  return (1);
}
}
#line 2778 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
nodeptr removeNode(tree *tr , nodeptr p ) 
{ 
  double zqr ;
  nodeptr q ;
  nodeptr r ;
  struct noderec *tmp ;

  {
  {
#line 2798
  q = (p->next)->back;
#line 2799
  r = ((p->next)->next)->back;
#line 2800
  zqr = q->z * r->z;
#line 2802
  zqr = makenewz(tr, q, r, zqr, 10);
  }
#line 2802
  if (zqr == 0.0) {
#line 2802
    return ((node *)((void *)0));
  }
  {
#line 2804
  hookup(q, r, zqr);
#line 2806
  tmp = (node *)((void *)0);
#line 2806
  (p->next)->back = tmp;
#line 2806
  ((p->next)->next)->back = tmp;
  }
#line 2807
  return (q);
}
}
#line 2811 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean initrav(tree *tr , nodeptr p ) 
{ 
  nodeptr q ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 2815
  if (! p->tip) {
#line 2816
    q = p->next;
    {
#line 2817
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2818
      tmp = initrav(tr, q->back);
      }
#line 2818
      if (! tmp) {
#line 2818
        return (0);
      }
#line 2819
      q = q->next;
#line 2817
      if (! ((unsigned long )q != (unsigned long )p)) {
#line 2817
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2821
    tmp___0 = newview(tr, p);
    }
#line 2821
    if (! tmp___0) {
#line 2821
      return (0);
    }
  }
#line 2824
  return (1);
}
}
#line 2828 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
nodeptr buildNewTip(tree *tr , nodeptr p ) 
{ 
  nodeptr q ;
  int tmp ;

  {
  {
#line 2832
  tmp = tr->nextnode;
#line 2832
  (tr->nextnode) ++;
#line 2832
  q = *(tr->nodep + tmp);
#line 2833
  hookup(p, q, 0.9);
  }
#line 2834
  return (q);
}
}
#line 2838 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean buildSimpleTree(tree *tr , int ip , int iq , int ir ) 
{ 
  nodeptr p ;
  nodeptr s ;
  int i ;
  boolean tmp ;

  {
#line 2844
  if (ip < iq) {
#line 2844
    i = ip;
  } else {
#line 2844
    i = iq;
  }
#line 2845
  if (ir < i) {
#line 2845
    i = ir;
  }
  {
#line 2846
  tr->start = *(tr->nodep + i);
#line 2847
  tr->ntips = 3;
#line 2848
  p = *(tr->nodep + ip);
#line 2849
  hookup(p, *(tr->nodep + iq), 0.9);
#line 2850
  s = buildNewTip(tr, *(tr->nodep + ir));
#line 2852
  tmp = insert(tr, s, p, 0);
  }
#line 2852
  return (tmp);
}
}
#line 2856 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
char *strchr(char *str , int chr ) 
{ 
  int c ;

  {
  {
#line 2860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2860
    c = (int )*str;
#line 2860
    if (! c) {
#line 2860
      goto while_break;
    }
#line 2860
    if (c == chr) {
#line 2860
      return (str);
    }
#line 2860
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2861
  return ((char *)((void *)0));
}
}
#line 2865 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
char *strstr(char *str1 , char *str2 ) 
{ 
  char *s1 ;
  char *s2 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 2870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2870
    s1 = str1;
#line 2870
    if (! *s1) {
#line 2870
      goto while_break;
    }
#line 2871
    s2 = str2;
    {
#line 2872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2873
      tmp = s2;
#line 2873
      s2 ++;
#line 2873
      c = (int )*tmp;
#line 2873
      if (! c) {
#line 2873
        return (str1);
      }
#line 2872
      tmp___0 = s1;
#line 2872
      s1 ++;
#line 2872
      if (! ((int )*tmp___0 == c)) {
#line 2872
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2876
    str1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2878
  return ((char *)((void *)0));
}
}
#line 2886
extern int ( /* missing proto */  strlen)() ;
#line 2882 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean readKeyValue(char *string , char *key , char *format , void *value ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2885
  string = strstr(string, key);
  }
#line 2885
  if (! string) {
#line 2885
    return (0);
  }
  {
#line 2886
  tmp = strlen(key);
#line 2886
  string += tmp;
#line 2887
  string = strchr(string, '=');
  }
#line 2887
  if (! string) {
#line 2887
    return (0);
  }
  {
#line 2888
  string ++;
#line 2889
  tmp___0 = sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)format,
                   value);
  }
#line 2889
  return (tmp___0);
}
}
#line 3039 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void cacheZ(tree *tr ) 
{ 
  nodeptr p ;
  int nodes ;
  int tmp ;

  {
#line 3044
  nodes = tr->mxtips + 3 * (tr->mxtips - 2);
#line 3045
  p = *(tr->nodep + 1);
  {
#line 3046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3046
    tmp = nodes;
#line 3046
    nodes --;
#line 3046
    if (! (tmp > 0)) {
#line 3046
      goto while_break;
    }
#line 3046
    p->z0 = p->z;
#line 3046
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3047
  return;
}
}
#line 3050 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void restoreZ(tree *tr ) 
{ 
  nodeptr p ;
  int nodes ;
  int tmp ;

  {
#line 3055
  nodes = tr->mxtips + 3 * (tr->mxtips - 2);
#line 3056
  p = *(tr->nodep + 1);
  {
#line 3057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3057
    tmp = nodes;
#line 3057
    nodes --;
#line 3057
    if (! (tmp > 0)) {
#line 3057
      goto while_break;
    }
#line 3057
    p->z = p->z0;
#line 3057
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3058
  return;
}
}
#line 3061 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean testInsert(tree *tr , nodeptr p , nodeptr q , bestlist *bt , boolean fast ) 
{ 
  double qz ;
  nodeptr r ;
  boolean tmp ;
  struct noderec *tmp___0 ;
  double tmp___1 ;
  struct noderec *tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;

  {
  {
#line 3066
  r = q->back;
#line 3067
  qz = q->z;
#line 3068
  tmp = insert(tr, p, q, ! fast);
  }
#line 3068
  if (! tmp) {
#line 3068
    return (0);
  }
#line 3071
  if (fast) {
#line 3071
    tmp___0 = (p->next)->next;
  } else {
#line 3071
    tmp___0 = tr->start;
  }
  {
#line 3071
  tmp___1 = evaluate(tr, tmp___0);
  }
#line 3071
  if (tmp___1 == 1.0) {
#line 3071
    return (0);
  }
  {
#line 3072
  saveBestTree(bt, tr);
#line 3080
  hookup(q, r, qz);
#line 3081
  tmp___2 = (nodeptr )((void *)0);
#line 3081
  (p->next)->back = tmp___2;
#line 3081
  ((p->next)->next)->back = tmp___2;
  }
#line 3082
  if (! fast) {
    {
#line 3083
    restoreZ(tr);
#line 3085
    tmp___3 = initrav(tr, p->back);
    }
#line 3085
    if (! tmp___3) {
#line 3085
      return (0);
    }
    {
#line 3086
    tmp___4 = initrav(tr, q);
    }
#line 3086
    if (! tmp___4) {
#line 3086
      return (0);
    }
    {
#line 3087
    tmp___5 = initrav(tr, r);
    }
#line 3087
    if (! tmp___5) {
#line 3087
      return (0);
    }
  }
#line 3091
  return (1);
}
}
#line 3095 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int addTraverse(tree *tr , nodeptr p , nodeptr q , int mintrav , int maxtrav , bestlist *bt ,
                boolean fast ) 
{ 
  int tested ;
  int newtested ;
  boolean tmp ;

  {
#line 3100
  tested = 0;
#line 3101
  mintrav --;
#line 3101
  if (mintrav <= 0) {
    {
#line 3102
    tmp = testInsert(tr, p, q, bt, fast);
    }
#line 3102
    if (! tmp) {
#line 3102
      return (-1);
    }
#line 3103
    tested ++;
  }
#line 3106
  if (! q->tip) {
#line 3106
    maxtrav --;
#line 3106
    if (maxtrav > 0) {
      {
#line 3107
      newtested = addTraverse(tr, p, (q->next)->back, mintrav, maxtrav, bt, fast);
      }
#line 3109
      if (newtested == -1) {
#line 3109
        return (-1);
      }
      {
#line 3110
      tested += newtested;
#line 3111
      newtested = addTraverse(tr, p, ((q->next)->next)->back, mintrav, maxtrav, bt,
                              fast);
      }
#line 3113
      if (newtested == -1) {
#line 3113
        return (-1);
      }
#line 3114
      tested += newtested;
    }
  }
#line 3117
  return (tested);
}
}
#line 3121 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int rearrange(tree *tr , nodeptr p , int mintrav , int maxtrav , bestlist *bt ) 
{ 
  double p1z ;
  double p2z ;
  double q1z ;
  double q2z ;
  nodeptr p1 ;
  nodeptr p2 ;
  nodeptr q ;
  nodeptr q1 ;
  nodeptr q2 ;
  int tested ;
  int mintrav2 ;
  int newtested ;
  nodeptr tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  nodeptr tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;

  {
#line 3128
  tested = 0;
#line 3129
  if (maxtrav < 1) {
#line 3129
    return (tested);
  } else
#line 3129
  if (mintrav > maxtrav) {
#line 3129
    return (tested);
  }
#line 3133
  if (! p->tip) {
#line 3134
    p1 = (p->next)->back;
#line 3135
    p2 = ((p->next)->next)->back;
#line 3136
    if (! p1->tip) {
#line 3136
      goto _L;
    } else
#line 3136
    if (! p2->tip) {
      _L: /* CIL Label */ 
      {
#line 3137
      p1z = p1->z;
#line 3138
      p2z = p2->z;
#line 3139
      tmp = removeNode(tr, p);
      }
#line 3139
      if (! tmp) {
#line 3139
        return (-1);
      }
      {
#line 3140
      cacheZ(tr);
      }
#line 3141
      if (! p1->tip) {
        {
#line 3142
        newtested = addTraverse(tr, p, (p1->next)->back, mintrav, maxtrav, bt, 0);
        }
#line 3144
        if (newtested == -1) {
#line 3144
          return (-1);
        }
        {
#line 3145
        tested += newtested;
#line 3146
        newtested = addTraverse(tr, p, ((p1->next)->next)->back, mintrav, maxtrav,
                                bt, 0);
        }
#line 3148
        if (newtested == -1) {
#line 3148
          return (-1);
        }
#line 3149
        tested += newtested;
      }
#line 3152
      if (! p2->tip) {
        {
#line 3153
        newtested = addTraverse(tr, p, (p2->next)->back, mintrav, maxtrav, bt, 0);
        }
#line 3155
        if (newtested == -1) {
#line 3155
          return (-1);
        }
        {
#line 3156
        tested += newtested;
#line 3157
        newtested = addTraverse(tr, p, ((p2->next)->next)->back, mintrav, maxtrav,
                                bt, 0);
        }
#line 3159
        if (newtested == -1) {
#line 3159
          return (-1);
        }
#line 3160
        tested += newtested;
      }
      {
#line 3163
      hookup(p->next, p1, p1z);
#line 3164
      hookup((p->next)->next, p2, p2z);
#line 3165
      tmp___0 = initrav(tr, tr->start);
      }
#line 3165
      if (tmp___0) {
        {
#line 3165
        tmp___1 = initrav(tr, (tr->start)->back);
        }
#line 3165
        if (! tmp___1) {
#line 3166
          return (-1);
        }
      } else {
#line 3166
        return (-1);
      }
    }
  }
#line 3172
  q = p->back;
#line 3173
  if (! q->tip) {
#line 3173
    if (maxtrav > 1) {
#line 3174
      q1 = (q->next)->back;
#line 3175
      q2 = ((q->next)->next)->back;
#line 3176
      if (! q1->tip) {
#line 3176
        if (! ((q1->next)->back)->tip) {
#line 3176
          goto _L___1;
        } else
#line 3176
        if (! (((q1->next)->next)->back)->tip) {
#line 3176
          goto _L___1;
        } else {
#line 3176
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 3176
      if (! q2->tip) {
#line 3176
        if (! ((q2->next)->back)->tip) {
#line 3176
          goto _L___1;
        } else
#line 3176
        if (! (((q2->next)->next)->back)->tip) {
          _L___1: /* CIL Label */ 
          {
#line 3178
          q1z = q1->z;
#line 3179
          q2z = q2->z;
#line 3180
          tmp___2 = removeNode(tr, q);
          }
#line 3180
          if (! tmp___2) {
#line 3180
            return (-1);
          }
          {
#line 3181
          cacheZ(tr);
          }
#line 3182
          if (mintrav > 2) {
#line 3182
            mintrav2 = mintrav;
          } else {
#line 3182
            mintrav2 = 2;
          }
#line 3184
          if (! q1->tip) {
            {
#line 3185
            newtested = addTraverse(tr, q, (q1->next)->back, mintrav2, maxtrav, bt,
                                    0);
            }
#line 3187
            if (newtested == -1) {
#line 3187
              return (-1);
            }
            {
#line 3188
            tested += newtested;
#line 3189
            newtested = addTraverse(tr, q, ((q1->next)->next)->back, mintrav2, maxtrav,
                                    bt, 0);
            }
#line 3191
            if (newtested == -1) {
#line 3191
              return (-1);
            }
#line 3192
            tested += newtested;
          }
#line 3195
          if (! q2->tip) {
            {
#line 3196
            newtested = addTraverse(tr, q, (q2->next)->back, mintrav2, maxtrav, bt,
                                    0);
            }
#line 3198
            if (newtested == -1) {
#line 3198
              return (-1);
            }
            {
#line 3199
            tested += newtested;
#line 3200
            newtested = addTraverse(tr, q, ((q2->next)->next)->back, mintrav2, maxtrav,
                                    bt, 0);
            }
#line 3202
            if (newtested == -1) {
#line 3202
              return (-1);
            }
#line 3203
            tested += newtested;
          }
          {
#line 3206
          hookup(q->next, q1, q1z);
#line 3207
          hookup((q->next)->next, q2, q2z);
#line 3208
          tmp___3 = initrav(tr, tr->start);
          }
#line 3208
          if (tmp___3) {
            {
#line 3208
            tmp___4 = initrav(tr, (tr->start)->back);
            }
#line 3208
            if (! tmp___4) {
#line 3209
              return (-1);
            }
          } else {
#line 3209
            return (-1);
          }
        }
      }
    }
  }
#line 3215
  if (! p->tip) {
    {
#line 3216
    newtested = rearrange(tr, (p->next)->back, mintrav, maxtrav, bt);
    }
#line 3217
    if (newtested == -1) {
#line 3217
      return (-1);
    }
    {
#line 3218
    tested += newtested;
#line 3219
    newtested = rearrange(tr, ((p->next)->next)->back, mintrav, maxtrav, bt);
    }
#line 3220
    if (newtested == -1) {
#line 3220
      return (-1);
    }
#line 3221
    tested += newtested;
  }
#line 3224
  return (tested);
}
}
#line 3231
extern int ( /* missing proto */  getpid)() ;
#line 3228 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
FILE *fopen_pid(char *filenm , char *mode , char *name_pid ) 
{ 
  int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 3231
  tmp = getpid();
#line 3231
  sprintf((char */* __restrict  */)name_pid, (char const   */* __restrict  */)"%s.%d",
          filenm, tmp);
#line 3232
  tmp___0 = fopen((char const   */* __restrict  */)name_pid, (char const   */* __restrict  */)mode);
  }
#line 3232
  return (tmp___0);
}
}
#line 3251
void treeOut(FILE *treefile , tree *tr , int form ) ;
#line 3247 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void writeCheckpoint(tree *tr ) 
{ 
  char filename[128] ;
  FILE *checkpointf ;

  {
  {
#line 3253
  checkpointf = fopen_pid((char *)"checkpoint", (char *)"a", filename);
  }
#line 3254
  if (checkpointf) {
    {
#line 3255
    treeOut(checkpointf, tr, 1);
#line 3256
    fclose(checkpointf);
    }
  }
#line 3258
  return;
}
}
#line 3261 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
node *findAnyTip(nodeptr p ) 
{ 
  node *tmp ;
  nodeptr tmp___0 ;

  {
#line 3263
  if (p->tip) {
#line 3263
    tmp___0 = p;
  } else {
    {
#line 3263
    tmp = findAnyTip((p->next)->back);
#line 3263
    tmp___0 = tmp;
    }
  }
#line 3263
  return (tmp___0);
}
}
#line 3267 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean optimize(tree *tr , int maxtrav , bestlist *bt ) 
{ 
  nodeptr p ;
  int mintrav ;
  int tested ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 3272
  if (tr->ntips < 4) {
#line 3272
    return (1);
  }
  {
#line 3274
  writeCheckpoint(tr);
  }
#line 3276
  if (maxtrav > tr->ntips - 3) {
#line 3276
    maxtrav = tr->ntips - 3;
  }
#line 3277
  if (maxtrav <= tr->opt_level) {
#line 3277
    return (1);
  }
#line 3279
  if (maxtrav == 1) {
#line 3279
    tmp___0 = "local";
  } else {
#line 3279
    if (maxtrav < tr->ntips - 3) {
#line 3279
      tmp = "regional";
    } else {
#line 3279
      tmp = "global";
    }
#line 3279
    tmp___0 = tmp;
  }
  {
#line 3279
  printf((char const   */* __restrict  */)"      Doing %s rearrangements\n", tmp___0);
  }
  {
#line 3285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3286
    startOpt(bt, tr);
#line 3287
    mintrav = tr->opt_level + 1;
#line 3291
    p = findAnyTip(tr->start);
#line 3292
    tested = rearrange(tr, p->back, mintrav, maxtrav, bt);
    }
#line 3293
    if (tested == -1) {
#line 3293
      return (0);
    }
    {
#line 3299
    bt->numtrees += tested;
#line 3300
    setOptLevel(bt, maxtrav);
#line 3301
    tmp___1 = recallBestTree(bt, 1, tr);
    }
#line 3301
    if (! tmp___1) {
#line 3301
      return (0);
    }
    {
#line 3303
    printf((char const   */* __restrict  */)"      Tested %d alternative trees\n",
           tested);
    }
#line 3304
    if (bt->improved) {
      {
#line 3305
      printf((char const   */* __restrict  */)"      Ln Likelihood =%14.5f\n", tr->likelihood);
      }
    }
    {
#line 3308
    writeCheckpoint(tr);
    }
#line 3285
    if (! (maxtrav > tr->opt_level)) {
#line 3285
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3311
  return (1);
}
}
#line 3315 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void coordinates(tree *tr , nodeptr p , double lengthsum , drawdata *tdptr ) 
{ 
  double x ;
  double z ;
  nodeptr q ;
  nodeptr first ;
  nodeptr last ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;

  {
#line 3321
  if (p->tip) {
#line 3322
    if ((double )60 * lengthsum > (double )0) {
#line 3322
      tmp = (double )60 * lengthsum + 0.5;
    } else {
#line 3322
      tmp = (double )60 * lengthsum - 0.5;
    }
#line 3322
    p->xcoord = (int )tmp;
#line 3323
    tmp___1 = tdptr->tipy;
#line 3323
    p->ycoord = tmp___1;
#line 3323
    tmp___0 = tmp___1;
#line 3323
    p->ymin = tmp___0;
#line 3323
    p->ymax = tmp___0;
#line 3324
    tdptr->tipy += 2;
#line 3325
    if (lengthsum > tdptr->tipmax) {
#line 3325
      tdptr->tipmax = lengthsum;
    }
  } else {
#line 3329
    q = p->next;
    {
#line 3330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3331
      z = q->z;
#line 3332
      if (z < 1.0E-15) {
#line 3332
        z = 1.0E-15;
      }
      {
#line 3333
      tmp___2 = log(z);
#line 3333
      x = lengthsum - (tr->rdta)->fracchange * tmp___2;
#line 3334
      coordinates(tr, q->back, x, tdptr);
#line 3335
      q = q->next;
      }
#line 3330
      if ((unsigned long )p == (unsigned long )(tr->start)->back) {
#line 3330
        tmp___3 = (unsigned long )q != (unsigned long )p->next;
      } else {
#line 3330
        tmp___3 = (unsigned long )q != (unsigned long )p;
      }
#line 3330
      if (! tmp___3) {
#line 3330
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3338
    first = (p->next)->back;
#line 3339
    q = p;
    {
#line 3340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3340
      if (! ((unsigned long )q->next != (unsigned long )p)) {
#line 3340
        goto while_break___0;
      }
#line 3340
      q = q->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3341
    last = q->back;
#line 3342
    if ((double )60 * lengthsum > (double )0) {
#line 3342
      tmp___4 = (double )60 * lengthsum + 0.5;
    } else {
#line 3342
      tmp___4 = (double )60 * lengthsum - 0.5;
    }
#line 3342
    p->xcoord = (int )tmp___4;
#line 3343
    p->ycoord = (first->ycoord + last->ycoord) / 2;
#line 3344
    p->ymin = first->ymin;
#line 3345
    p->ymax = last->ymax;
  }
#line 3347
  return;
}
}
#line 3350 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void drawline(tree *tr , int i , double scale ) 
{ 
  nodeptr p ;
  nodeptr q ;
  nodeptr r ;
  nodeptr first ;
  nodeptr last ;
  int n ;
  int j ;
  int k ;
  int l ;
  int extra ;
  boolean done ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;

  {
#line 3358
  q = (tr->start)->back;
#line 3358
  p = q;
#line 3359
  extra = 0;
#line 3361
  if (i == p->ycoord) {
#line 3362
    k = q->number - tr->mxtips;
#line 3363
    j = k;
    {
#line 3363
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3363
      if (! (j < 1000)) {
#line 3363
        goto while_break;
      }
      {
#line 3363
      putchar('-');
#line 3363
      j *= 10;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3364
    printf((char const   */* __restrict  */)"%d", k);
#line 3365
    extra = 1;
    }
  } else {
    {
#line 3367
    printf((char const   */* __restrict  */)"   ");
    }
  }
  {
#line 3369
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3370
    if (! p->tip) {
#line 3371
      r = p->next;
#line 3372
      done = 0;
      {
#line 3373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3374
        if (i >= (r->back)->ymin) {
#line 3374
          if (i <= (r->back)->ymax) {
#line 3375
            q = r->back;
#line 3376
            done = 1;
          }
        }
#line 3378
        r = r->next;
#line 3373
        if (! done) {
#line 3373
          if ((unsigned long )p == (unsigned long )(tr->start)->back) {
#line 3373
            tmp = (unsigned long )r != (unsigned long )p->next;
          } else {
#line 3373
            tmp = (unsigned long )r != (unsigned long )p;
          }
#line 3373
          if (! tmp) {
#line 3373
            goto while_break___1;
          }
        } else {
#line 3373
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3381
      first = (p->next)->back;
#line 3382
      r = p;
      {
#line 3383
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3383
        if (! ((unsigned long )r->next != (unsigned long )p)) {
#line 3383
          goto while_break___2;
        }
#line 3383
        r = r->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3384
      last = r->back;
#line 3385
      if ((unsigned long )p == (unsigned long )(tr->start)->back) {
#line 3385
        last = p->back;
      }
    }
#line 3388
    if (p->tip) {
#line 3388
      tmp___0 = 1;
    } else
#line 3388
    if ((unsigned long )p == (unsigned long )q) {
#line 3388
      tmp___0 = 1;
    } else {
#line 3388
      tmp___0 = 0;
    }
#line 3388
    done = tmp___0;
#line 3389
    if (scale * (double )(q->xcoord - p->xcoord) > (double )0) {
#line 3389
      tmp___1 = scale * (double )(q->xcoord - p->xcoord) + 0.5;
    } else {
#line 3389
      tmp___1 = scale * (double )(q->xcoord - p->xcoord) - 0.5;
    }
#line 3389
    n = (int )tmp___1;
#line 3390
    if (n < 3) {
#line 3390
      if (! q->tip) {
#line 3390
        n = 3;
      }
    }
#line 3391
    n -= extra;
#line 3392
    extra = 0;
#line 3394
    if (q->ycoord == i) {
#line 3394
      if (! done) {
#line 3395
        if (p->ycoord != q->ycoord) {
          {
#line 3395
          putchar('+');
          }
        } else {
          {
#line 3396
          putchar('-');
          }
        }
#line 3398
        if (! q->tip) {
#line 3399
          k = q->number - tr->mxtips;
#line 3400
          l = n - 3;
#line 3401
          j = k;
          {
#line 3401
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3401
            if (! (j < 100)) {
#line 3401
              goto while_break___3;
            }
#line 3401
            l ++;
#line 3401
            j *= 10;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 3402
          j = 1;
          {
#line 3402
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3402
            if (! (j <= l)) {
#line 3402
              goto while_break___4;
            }
            {
#line 3402
            putchar('-');
#line 3402
            j ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 3403
          printf((char const   */* __restrict  */)"%d", k);
#line 3404
          extra = 1;
          }
        } else {
#line 3406
          j = 1;
          {
#line 3406
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3406
            if (! (j <= n - 1)) {
#line 3406
              goto while_break___5;
            }
            {
#line 3406
            putchar('-');
#line 3406
            j ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      } else {
#line 3394
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3409
    if (! p->tip) {
#line 3410
      if (last->ycoord > i) {
#line 3410
        if (first->ycoord < i) {
#line 3410
          if (i != p->ycoord) {
            {
#line 3411
            putchar('!');
#line 3412
            j = 1;
            }
            {
#line 3412
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3412
              if (! (j <= n - 1)) {
#line 3412
                goto while_break___6;
              }
              {
#line 3412
              putchar(' ');
#line 3412
              j ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 3410
            goto _L___0;
          }
        } else {
#line 3410
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 3414
        j = 1;
        {
#line 3414
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3414
          if (! (j <= n)) {
#line 3414
            goto while_break___7;
          }
          {
#line 3414
          putchar(' ');
#line 3414
          j ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 3418
      j = 1;
      {
#line 3418
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 3418
        if (! (j <= n)) {
#line 3418
          goto while_break___8;
        }
        {
#line 3418
        putchar(' ');
#line 3418
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 3420
    p = q;
#line 3369
    if (! (! done)) {
#line 3369
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3423
  if (p->ycoord == i) {
#line 3423
    if (p->tip) {
      {
#line 3424
      printf((char const   */* __restrict  */)" %s", p->name);
      }
    }
  }
  {
#line 3427
  putchar('\n');
  }
#line 3428
  return;
}
}
#line 3431 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void printTree(tree *tr , analdef *adef ) 
{ 
  drawdata tipdata ;
  double scale ;
  int i ;
  int imax ;

  {
#line 3438
  if (adef->trprint) {
    {
#line 3439
    putchar('\n');
#line 3440
    tipdata.tipy = 1;
#line 3441
    tipdata.tipmax = 0.0;
#line 3442
    coordinates(tr, (tr->start)->back, 0.0, & tipdata);
#line 3443
    scale = 1.0 / tipdata.tipmax;
#line 3444
    imax = tipdata.tipy - 2;
#line 3445
    i = 1;
    }
    {
#line 3445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3445
      if (! (i <= imax)) {
#line 3445
        goto while_break;
      }
      {
#line 3445
      drawline(tr, i, scale);
#line 3445
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3446
    printf((char const   */* __restrict  */)"\nRemember: ");
    }
#line 3447
    if (adef->root) {
      {
#line 3447
      printf((char const   */* __restrict  */)"(although rooted by outgroup) ");
      }
    }
    {
#line 3448
    printf((char const   */* __restrict  */)"this is an unrooted tree!\n\n");
    }
  }
#line 3450
  return;
}
}
#line 3453 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
double sigma(tree *tr , nodeptr p , double *sumlrptr ) 
{ 
  likelivector *lp ;
  likelivector *lq ;
  double slope ;
  double sum ;
  double sumlr ;
  double z ;
  double zv ;
  double zz ;
  double lz ;
  double rat ;
  double suma ;
  double sumb ;
  double sumc ;
  double d2 ;
  double d ;
  double li ;
  double temp ;
  double abzz ;
  double bczv ;
  double t3 ;
  double fxpa ;
  double fxpc ;
  double fxpg ;
  double fxpt ;
  double fxpr ;
  double fxpy ;
  double fxqr ;
  double fxqy ;
  double w ;
  double *rptr ;
  nodeptr q ;
  int i ;
  int *wptr ;
  boolean tmp ;
  boolean tmp___0 ;
  double *tmp___1 ;
  int *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 3464
  q = p->back;
  {
#line 3465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3465
    if (! (! p->x)) {
#line 3465
      if (! (! q->x)) {
#line 3465
        goto while_break;
      }
    }
#line 3466
    if (! p->x) {
      {
#line 3466
      tmp = newview(tr, p);
      }
#line 3466
      if (! tmp) {
#line 3466
        return (- 1.0);
      }
    }
#line 3467
    if (! q->x) {
      {
#line 3467
      tmp___0 = newview(tr, q);
      }
#line 3467
      if (! tmp___0) {
#line 3467
        return (- 1.0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3470
  lp = (p->x)->lv;
#line 3471
  lq = (q->x)->lv;
#line 3473
  z = p->z;
#line 3474
  if (z < 1.0E-15) {
#line 3474
    z = 1.0E-15;
  }
  {
#line 3475
  lz = log(z);
#line 3477
  wptr = (tr->cdta)->aliaswgt + 0;
#line 3478
  rptr = (tr->cdta)->patrat + 0;
#line 3479
  slope = 0.0;
#line 3479
  sumlr = slope;
#line 3479
  sum = sumlr;
#line 3485
  i = 0;
  }
  {
#line 3485
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3485
    if (! (i < (tr->cdta)->endsite)) {
#line 3485
      goto while_break___0;
    }
    {
#line 3486
    tmp___1 = rptr;
#line 3486
    rptr ++;
#line 3486
    rat = *tmp___1;
#line 3487
    zz = exp(rat * lz);
#line 3488
    zv = exp((rat * (tr->rdta)->xv) * lz);
#line 3490
    fxpa = (tr->rdta)->freqa * lp->a;
#line 3491
    fxpg = (tr->rdta)->freqg * lp->g;
#line 3492
    fxpc = (tr->rdta)->freqc * lp->c;
#line 3493
    fxpt = (tr->rdta)->freqt * lp->t;
#line 3494
    fxpr = fxpa + fxpg;
#line 3495
    fxpy = fxpc + fxpt;
#line 3496
    suma = ((fxpa * lq->a + fxpc * lq->c) + fxpg * lq->g) + fxpt * lq->t;
#line 3497
    fxqr = (tr->rdta)->freqa * lq->a + (tr->rdta)->freqg * lq->g;
#line 3498
    fxqy = (tr->rdta)->freqc * lq->c + (tr->rdta)->freqt * lq->t;
#line 3499
    sumc = (fxpr + fxpy) * (fxqr + fxqy);
#line 3500
    sumb = (fxpr * fxqr) * (tr->rdta)->invfreqr + (fxpy * fxqy) * (tr->rdta)->invfreqy;
#line 3501
    abzz = zz * (suma - sumb);
#line 3502
    bczv = zv * (sumb - sumc);
#line 3503
    li = (sumc + abzz) + bczv;
#line 3504
    t3 = (tr->rdta)->xv * bczv;
#line 3505
    d = abzz + t3;
#line 3506
    d2 = rat * (abzz * (rat - 1.0) + t3 * (rat * (tr->rdta)->xv - 1.0));
#line 3508
    temp = (rat * d) / li;
#line 3509
    tmp___2 = wptr;
#line 3509
    wptr ++;
#line 3509
    w = (double )*tmp___2;
#line 3510
    slope += w * temp;
#line 3511
    sum += w * (temp * temp - d2 / li);
#line 3512
    tmp___3 = log(li / (suma + 1.0E-300));
#line 3512
    sumlr += w * tmp___3;
#line 3513
    lp ++;
#line 3514
    lq ++;
#line 3485
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3517
  *sumlrptr = sumlr;
#line 3518
  if (sum > 1.0E-300) {
    {
#line 3518
    tmp___4 = sqrt(slope * slope + 3.841 * sum);
#line 3518
    tmp___5 = (z * (- slope + tmp___4)) / sum;
    }
  } else {
#line 3518
    tmp___5 = 1.0;
  }
#line 3518
  return (tmp___5);
}
}
#line 3523 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void describe(tree *tr , nodeptr p ) 
{ 
  double z ;
  double s ;
  double sumlr ;
  nodeptr q ;
  char *nameptr ;
  int k ;
  int ch ;
  char *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 3531
  q = p->back;
#line 3532
  printf((char const   */* __restrict  */)"%4d          ", q->number - tr->mxtips);
  }
#line 3533
  if (p->tip) {
#line 3534
    nameptr = p->name;
#line 3535
    k = 10;
    {
#line 3536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3536
      tmp = nameptr;
#line 3536
      nameptr ++;
#line 3536
      ch = (int )*tmp;
#line 3536
      if (! ch) {
#line 3536
        goto while_break;
      }
      {
#line 3536
      putchar(ch);
#line 3536
      k --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3537
      k --;
#line 3537
      if (! (k >= 0)) {
#line 3537
        goto while_break___0;
      }
      {
#line 3537
      putchar(' ');
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3540
    printf((char const   */* __restrict  */)"%4d", p->number - tr->mxtips);
#line 3541
    k = 4;
    }
    {
#line 3541
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3541
      if (! (k < 10)) {
#line 3541
        goto while_break___1;
      }
      {
#line 3541
      putchar(' ');
#line 3541
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 3544
  z = q->z;
#line 3545
  if (z <= 1.0E-15) {
    {
#line 3545
    printf((char const   */* __restrict  */)"    infinity");
    }
  } else {
    {
#line 3546
    tmp___0 = log(z);
#line 3546
    printf((char const   */* __restrict  */)"%15.5f", - tmp___0 * (tr->rdta)->fracchange);
    }
  }
  {
#line 3548
  s = sigma(tr, q, & sumlr);
#line 3549
  printf((char const   */* __restrict  */)"     (");
  }
#line 3550
  if (z + s >= 1.0 - 1.0E-6) {
    {
#line 3550
    printf((char const   */* __restrict  */)"     zero");
    }
  } else {
    {
#line 3551
    tmp___1 = log(z + s);
#line 3551
    printf((char const   */* __restrict  */)"%9.5f", - tmp___1 * (tr->rdta)->fracchange);
    }
  }
  {
#line 3552
  putchar(',');
  }
#line 3553
  if (z - s <= 1.0E-15) {
    {
#line 3553
    printf((char const   */* __restrict  */)"    infinity");
    }
  } else {
    {
#line 3554
    tmp___2 = log(z - s);
#line 3554
    printf((char const   */* __restrict  */)"%12.5f", - tmp___2 * (tr->rdta)->fracchange);
    }
  }
  {
#line 3555
  putchar(')');
  }
#line 3557
  if (sumlr > 2.995) {
    {
#line 3557
    printf((char const   */* __restrict  */)" **");
    }
  } else
#line 3558
  if (sumlr > 1.9205) {
    {
#line 3558
    printf((char const   */* __restrict  */)" *");
    }
  }
  {
#line 3559
  putchar('\n');
  }
#line 3561
  if (! p->tip) {
    {
#line 3562
    describe(tr, (p->next)->back);
#line 3563
    describe(tr, ((p->next)->next)->back);
    }
  }
#line 3565
  return;
}
}
#line 3568 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void summarize(tree *tr ) 
{ 


  {
  {
#line 3571
  printf((char const   */* __restrict  */)"Ln Likelihood =%14.5f\n", tr->likelihood);
#line 3572
  putchar('\n');
#line 3573
  printf((char const   */* __restrict  */)" Between        And             Length");
#line 3574
  printf((char const   */* __restrict  */)"      Approx. Confidence Limits\n");
#line 3575
  printf((char const   */* __restrict  */)" -------        ---             ------");
#line 3576
  printf((char const   */* __restrict  */)"      ------- ---------- ------\n");
#line 3578
  describe(tr, (((tr->start)->back)->next)->back);
#line 3579
  describe(tr, ((((tr->start)->back)->next)->next)->back);
#line 3580
  describe(tr, tr->start);
#line 3581
  putchar('\n');
#line 3582
  printf((char const   */* __restrict  */)"     *  = significantly positive, P < 0.05\n");
#line 3583
  printf((char const   */* __restrict  */)"     ** = significantly positive, P < 0.01\n\n\n");
  }
#line 3584
  return;
}
}
#line 3590 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
char *treeString(char *treestr , tree *tr , nodeptr p , int form ) 
{ 
  double x ;
  double z ;
  char *nameptr ;
  int c ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  double tmp___10 ;

  {
#line 3600
  if ((unsigned long )p == (unsigned long )(tr->start)->back) {
#line 3601
    if (form != 3) {
#line 3602
      if (form == 2) {
        {
#line 3603
        sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)"phylip_tree(");
        }
        {
#line 3604
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3604
          if (! *treestr) {
#line 3604
            goto while_break;
          }
#line 3604
          treestr ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 3607
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)"[&&%s: version = \'%s\'",
              "fastDNAml", "1.2.2");
      }
      {
#line 3609
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3609
        if (! *treestr) {
#line 3609
          goto while_break___0;
        }
#line 3609
        treestr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3611
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)", %s = %15.13g",
              likelihood_key, tr->likelihood);
      }
      {
#line 3613
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3613
        if (! *treestr) {
#line 3613
          goto while_break___1;
        }
#line 3613
        treestr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3615
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)", %s = %d",
              ntaxa_key, tr->ntips);
      }
      {
#line 3616
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3616
        if (! *treestr) {
#line 3616
          goto while_break___2;
        }
#line 3616
        treestr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 3618
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)", %s = %d",
              opt_level_key, tr->opt_level);
      }
      {
#line 3619
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3619
        if (! *treestr) {
#line 3619
          goto while_break___3;
        }
#line 3619
        treestr ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 3621
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)", %s = %d",
              smoothed_key, tr->smoothed);
      }
      {
#line 3622
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3622
        if (! *treestr) {
#line 3622
          goto while_break___4;
        }
#line 3622
        treestr ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3624
      if (form == 2) {
#line 3624
        tmp = ", ";
      } else {
#line 3624
        tmp = " ";
      }
      {
#line 3624
      sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)"]%s",
              tmp);
      }
      {
#line 3625
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3625
        if (! *treestr) {
#line 3625
          goto while_break___5;
        }
#line 3625
        treestr ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 3629
  if (p->tip) {
#line 3630
    if (form != 3) {
#line 3630
      tmp___0 = treestr;
#line 3630
      treestr ++;
#line 3630
      *tmp___0 = (char )'\'';
    }
#line 3631
    nameptr = p->name;
    {
#line 3632
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3632
      tmp___3 = nameptr;
#line 3632
      nameptr ++;
#line 3632
      c = (int )*tmp___3;
#line 3632
      if (! c) {
#line 3632
        goto while_break___6;
      }
#line 3633
      if (form != 3) {
#line 3633
        if (c == 39) {
#line 3633
          tmp___1 = treestr;
#line 3633
          treestr ++;
#line 3633
          *tmp___1 = (char )'\'';
        }
      } else
#line 3634
      if (c == 32) {
#line 3634
        c = '_';
      }
#line 3635
      tmp___2 = treestr;
#line 3635
      treestr ++;
#line 3635
      *tmp___2 = (char )c;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3637
    if (form != 3) {
#line 3637
      tmp___4 = treestr;
#line 3637
      treestr ++;
#line 3637
      *tmp___4 = (char )'\'';
    }
  } else {
    {
#line 3641
    tmp___5 = treestr;
#line 3641
    treestr ++;
#line 3641
    *tmp___5 = (char )'(';
#line 3642
    treestr = treeString(treestr, tr, (p->next)->back, form);
#line 3643
    tmp___6 = treestr;
#line 3643
    treestr ++;
#line 3643
    *tmp___6 = (char )',';
#line 3644
    treestr = treeString(treestr, tr, ((p->next)->next)->back, form);
    }
#line 3645
    if ((unsigned long )p == (unsigned long )(tr->start)->back) {
      {
#line 3646
      tmp___7 = treestr;
#line 3646
      treestr ++;
#line 3646
      *tmp___7 = (char )',';
#line 3647
      treestr = treeString(treestr, tr, p->back, form);
      }
    }
#line 3649
    tmp___8 = treestr;
#line 3649
    treestr ++;
#line 3649
    *tmp___8 = (char )')';
  }
#line 3652
  if ((unsigned long )p == (unsigned long )(tr->start)->back) {
#line 3653
    if (form != 2) {
#line 3653
      tmp___9 = ";";
    } else {
#line 3653
      tmp___9 = ").";
    }
    {
#line 3653
    sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)":0.0%s\n",
            tmp___9);
    }
  } else {
#line 3656
    z = p->z;
#line 3657
    if (z < 1.0E-15) {
#line 3657
      z = 1.0E-15;
    }
    {
#line 3658
    tmp___10 = log(z);
#line 3658
    x = - tmp___10 * (tr->rdta)->fracchange;
#line 3659
    sprintf((char */* __restrict  */)treestr, (char const   */* __restrict  */)": %8.6f",
            x);
    }
  }
  {
#line 3662
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3662
    if (! *treestr) {
#line 3662
      goto while_break___7;
    }
#line 3662
    treestr ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3663
  return (treestr);
}
}
#line 3667 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void treeOut(FILE *treefile , tree *tr , int form ) 
{ 
  int c ;
  char *cptr ;
  char *treestr ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 3673
  tmp = malloc((unsigned int )(tr->ntips * 42 + 256));
#line 3673
  treestr = tmp;
  }
#line 3674
  if (! treestr) {
    {
#line 3675
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"treeOut: Malloc failure\n");
#line 3676
    exit(1);
    }
  }
  {
#line 3679
  treeString(treestr, tr, (tr->start)->back, form);
#line 3680
  cptr = treestr;
  }
  {
#line 3681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3681
    tmp___0 = cptr;
#line 3681
    cptr ++;
#line 3681
    c = (int )*tmp___0;
#line 3681
    if (! c) {
#line 3681
      goto while_break;
    }
    {
#line 3681
    _IO_putc(c, treefile);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3683
  free(treestr);
  }
#line 3684
  return;
}
}
#line 3695 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int treeFinishCom(FILE *fp , char **strp ) 
{ 
  int ch ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 3699
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3699
    ch = _IO_getc(fp);
    }
#line 3699
    if (ch != -1) {
#line 3699
      if (! (ch != 93)) {
#line 3699
        goto while_break;
      }
    } else {
#line 3699
      goto while_break;
    }
#line 3700
    if ((unsigned long )strp != (unsigned long )((void *)0)) {
#line 3700
      tmp = *strp;
#line 3700
      (*strp) ++;
#line 3700
      *tmp = (char )ch;
    }
#line 3701
    if (ch == 91) {
      {
#line 3702
      ch = treeFinishCom(fp, strp);
      }
#line 3702
      if (ch == -1) {
#line 3702
        goto while_break;
      }
#line 3703
      if ((unsigned long )strp != (unsigned long )((void *)0)) {
#line 3703
        tmp___0 = *strp;
#line 3703
        (*strp) ++;
#line 3703
        *tmp___0 = (char )ch;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3707
  if ((unsigned long )strp != (unsigned long )((void *)0)) {
#line 3707
    *(*strp) = (char )'\000';
  }
#line 3708
  return (ch);
}
}
#line 3712 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int treeGetCh(FILE *fp ) 
{ 
  int ch ;
  boolean tmp ;

  {
  {
#line 3716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3716
    ch = _IO_getc(fp);
    }
#line 3716
    if (! (ch != -1)) {
#line 3716
      goto while_break;
    }
    {
#line 3717
    tmp = whitechar(ch);
    }
#line 3717
    if (! tmp) {
#line 3718
      if (ch == 91) {
        {
#line 3719
        ch = treeFinishCom(fp, (char **)((void *)0));
        }
#line 3719
        if (ch == -1) {
#line 3719
          goto while_break;
        }
      } else {
#line 3721
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3724
  return (ch);
}
}
#line 3728 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeLabelEnd(int ch ) 
{ 


  {
  {
#line 3733
  if (ch == 59) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 91) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 41) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 40) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 44) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 58) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 32) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 10) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 9) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == 0) {
#line 3733
    goto case_59;
  }
#line 3733
  if (ch == -1) {
#line 3733
    goto case_59;
  }
#line 3735
  goto switch_default;
  case_59: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 3734
  return (1);
  switch_default: /* CIL Label */ 
#line 3736
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3738
  return (0);
}
}
#line 3742 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeGetLabel(FILE *fp , char *lblPtr , int maxlen ) 
{ 
  int ch ;
  boolean done ;
  boolean quoted ;
  boolean lblfound ;
  boolean tmp ;
  char *tmp___0 ;

  {
#line 3747
  maxlen --;
#line 3747
  if (maxlen < 0) {
#line 3747
    lblPtr = (char *)((void *)0);
  } else
#line 3748
  if ((unsigned long )lblPtr == (unsigned long )((void *)0)) {
#line 3748
    maxlen = 0;
  }
  {
#line 3750
  ch = _IO_getc(fp);
#line 3751
  done = treeLabelEnd(ch);
#line 3753
  lblfound = ! done;
#line 3754
  quoted = ch == 39;
  }
#line 3755
  if (quoted) {
#line 3755
    if (! done) {
      {
#line 3755
      ch = _IO_getc(fp);
#line 3755
      done = ch == -1;
      }
    }
  }
  {
#line 3757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3757
    if (! (! done)) {
#line 3757
      goto while_break;
    }
#line 3758
    if (quoted) {
#line 3759
      if (ch == 39) {
        {
#line 3759
        ch = _IO_getc(fp);
        }
#line 3759
        if (ch != 39) {
#line 3759
          goto while_break;
        }
      }
    } else {
      {
#line 3762
      tmp = treeLabelEnd(ch);
      }
#line 3762
      if (tmp) {
#line 3762
        goto while_break;
      } else
#line 3764
      if (ch == 95) {
#line 3764
        ch = ' ';
      }
    }
#line 3766
    maxlen --;
#line 3766
    if (maxlen >= 0) {
#line 3766
      tmp___0 = lblPtr;
#line 3766
      lblPtr ++;
#line 3766
      *tmp___0 = (char )ch;
    }
    {
#line 3767
    ch = _IO_getc(fp);
    }
#line 3768
    if (ch == -1) {
#line 3768
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3771
  if (ch != -1) {
    {
#line 3771
    ungetc(ch, fp);
    }
  }
#line 3773
  if ((unsigned long )lblPtr != (unsigned long )((void *)0)) {
#line 3773
    *lblPtr = (char )'\000';
  }
#line 3775
  return (lblfound);
}
}
#line 3779 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeFlushLabel(FILE *fp ) 
{ 
  boolean tmp ;

  {
  {
#line 3781
  tmp = treeGetLabel(fp, (char *)((void *)0), 0);
  }
#line 3781
  return (tmp);
}
}
#line 3785 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int treeFindTipByLabel(char *str , tree *tr ) 
{ 
  nodeptr q ;
  char *nameptr ;
  int ch ;
  int i ;
  int n ;
  boolean found ;
  int tmp ;
  char *tmp___0 ;

  {
#line 3793
  n = 1;
  {
#line 3793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3793
    if (! (n <= tr->mxtips)) {
#line 3793
      goto while_break;
    }
#line 3794
    q = *(tr->nodep + n);
#line 3795
    if (! q->back) {
#line 3796
      i = 0;
#line 3797
      nameptr = q->name;
      {
#line 3798
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3798
        tmp = i;
#line 3798
        i ++;
#line 3798
        tmp___0 = nameptr;
#line 3798
        nameptr ++;
#line 3798
        ch = (int )*tmp___0;
#line 3798
        found = (int )*(str + tmp) == ch;
#line 3798
        if (found) {
#line 3798
          if (! ch) {
#line 3798
            goto while_break___0;
          }
        } else {
#line 3798
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3799
      if (found) {
#line 3799
        return (n);
      }
    }
#line 3793
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3803
  printf((char const   */* __restrict  */)"ERROR: Cannot find tree species: %s\n",
         str);
  }
#line 3805
  return (0);
}
}
#line 3809 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int treeFindTipName(FILE *fp , tree *tr ) 
{ 
  char *nameptr ;
  char str[12] ;
  int n ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 3814
  if (tr->prelabeled) {
    {
#line 3815
    tmp = treeGetLabel(fp, str, 12);
    }
#line 3815
    if (tmp) {
      {
#line 3816
      n = treeFindTipByLabel(str, tr);
      }
    } else {
#line 3818
      n = 0;
    }
  } else
#line 3821
  if (tr->ntips < tr->mxtips) {
    {
#line 3822
    n = tr->ntips + 1;
#line 3823
    nameptr = (*(tr->nodep + n))->name;
#line 3824
    tmp___0 = treeGetLabel(fp, nameptr, 11);
    }
#line 3824
    if (! tmp___0) {
#line 3824
      n = 0;
    }
  } else {
#line 3828
    n = 0;
  }
#line 3831
  return (n);
}
}
#line 3835 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
void treeEchoContext(FILE *fp1 , FILE *fp2 , int n ) 
{ 
  int ch ;
  boolean waswhite ;
  boolean tmp ;

  {
#line 3840
  waswhite = 1;
  {
#line 3842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3842
    if (n > 0) {
      {
#line 3842
      ch = _IO_getc(fp1);
      }
#line 3842
      if (! (ch != -1)) {
#line 3842
        goto while_break;
      }
    } else {
#line 3842
      goto while_break;
    }
    {
#line 3843
    tmp = whitechar(ch);
    }
#line 3843
    if (tmp) {
#line 3844
      if (waswhite) {
#line 3844
        ch = '\000';
      } else {
#line 3844
        ch = ' ';
      }
#line 3845
      waswhite = 1;
    } else {
#line 3848
      waswhite = 0;
    }
#line 3851
    if (ch > 0) {
      {
#line 3851
      _IO_putc(ch, fp2);
#line 3851
      n --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3853
  return;
}
}
#line 3856 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeProcessLength(FILE *fp , double *dptr ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 3860
  ch = treeGetCh(fp);
  }
#line 3860
  if (ch == -1) {
#line 3860
    return (0);
  }
  {
#line 3861
  ungetc(ch, fp);
#line 3863
  tmp = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lf",
               dptr);
  }
#line 3863
  if (tmp != 1) {
    {
#line 3864
    printf((char const   */* __restrict  */)"ERROR: treeProcessLength: Problem reading branch length\n");
#line 3865
    treeEchoContext(fp, stdout, 40);
#line 3866
    printf((char const   */* __restrict  */)"\n");
    }
#line 3867
    return (0);
  }
#line 3870
  return (1);
}
}
#line 3874 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeFlushLen(FILE *fp ) 
{ 
  double dummy ;
  int ch ;
  boolean tmp ;

  {
  {
#line 3879
  ch = treeGetCh(fp);
  }
#line 3879
  if (ch == 58) {
    {
#line 3879
    tmp = treeProcessLength(fp, & dummy);
    }
#line 3879
    return (tmp);
  }
#line 3881
  if (ch != -1) {
    {
#line 3881
    ungetc(ch, fp);
    }
  }
#line 3882
  return (1);
}
}
#line 3886 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeNeedCh(FILE *fp , int c1 , char *where ) 
{ 
  int c2 ;

  {
  {
#line 3890
  c2 = treeGetCh(fp);
  }
#line 3890
  if (c2 == c1) {
#line 3890
    return (1);
  }
  {
#line 3892
  printf((char const   */* __restrict  */)"ERROR: Expecting \'%c\' %s tree; found:",
         c1, where);
  }
#line 3893
  if (c2 == -1) {
    {
#line 3894
    printf((char const   */* __restrict  */)"End-of-File");
    }
  } else {
    {
#line 3897
    ungetc(c2, fp);
#line 3898
    treeEchoContext(fp, stdout, 40);
    }
  }
  {
#line 3900
  putchar('\n');
  }
#line 3901
  return (0);
}
}
#line 3905 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean addElementLen(FILE *fp , tree *tr , nodeptr p ) 
{ 
  double z ;
  double branch ;
  nodeptr q ;
  int n ;
  int ch ;
  int tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;

  {
  {
#line 3911
  ch = treeGetCh(fp);
  }
#line 3911
  if (ch == 40) {
#line 3912
    tmp = tr->nextnode;
#line 3912
    (tr->nextnode) ++;
#line 3912
    n = tmp;
#line 3913
    if (n > 2 * tr->mxtips - 2) {
#line 3914
      if (tr->rooted) {
        {
#line 3915
        printf((char const   */* __restrict  */)"ERROR: Too many internal nodes.  Is tree rooted?\n");
#line 3916
        printf((char const   */* __restrict  */)"       Deepest splitting should be a trifurcation.\n");
        }
#line 3917
        return (0);
      } else
#line 3914
      if (n > 2 * tr->mxtips - 1) {
        {
#line 3915
        printf((char const   */* __restrict  */)"ERROR: Too many internal nodes.  Is tree rooted?\n");
#line 3916
        printf((char const   */* __restrict  */)"       Deepest splitting should be a trifurcation.\n");
        }
#line 3917
        return (0);
      } else {
#line 3920
        tr->rooted = 1;
      }
    }
    {
#line 3923
    q = *(tr->nodep + n);
#line 3924
    tmp___0 = addElementLen(fp, tr, q->next);
    }
#line 3924
    if (! tmp___0) {
#line 3924
      return (0);
    }
    {
#line 3925
    tmp___1 = treeNeedCh(fp, ',', (char *)"in");
    }
#line 3925
    if (! tmp___1) {
#line 3925
      return (0);
    }
    {
#line 3926
    tmp___2 = addElementLen(fp, tr, (q->next)->next);
    }
#line 3926
    if (! tmp___2) {
#line 3926
      return (0);
    }
    {
#line 3927
    tmp___3 = treeNeedCh(fp, ')', (char *)"in");
    }
#line 3927
    if (! tmp___3) {
#line 3927
      return (0);
    }
    {
#line 3928
    treeFlushLabel(fp);
    }
  } else {
    {
#line 3932
    ungetc(ch, fp);
#line 3933
    n = treeFindTipName(fp, tr);
    }
#line 3933
    if (n <= 0) {
#line 3933
      return (0);
    }
#line 3934
    q = *(tr->nodep + n);
#line 3935
    if ((tr->start)->number > n) {
#line 3935
      tr->start = q;
    }
#line 3936
    (tr->ntips) ++;
  }
#line 3939
  if (tr->userlen) {
    {
#line 3940
    tmp___4 = treeNeedCh(fp, ':', (char *)"in");
    }
#line 3940
    if (! tmp___4) {
#line 3940
      return (0);
    }
    {
#line 3941
    tmp___5 = treeProcessLength(fp, & branch);
    }
#line 3941
    if (! tmp___5) {
#line 3941
      return (0);
    }
    {
#line 3942
    z = exp(- branch / (tr->rdta)->fracchange);
    }
#line 3943
    if (z > 1.0 - 1.0E-6) {
#line 3943
      z = 1.0 - 1.0E-6;
    }
    {
#line 3944
    hookup(p, q, z);
    }
  } else {
    {
#line 3947
    tmp___6 = treeFlushLen(fp);
    }
#line 3947
    if (! tmp___6) {
#line 3947
      return (0);
    }
    {
#line 3948
    hookup(p, q, 0.9);
    }
  }
#line 3951
  return (1);
}
}
#line 3955 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int saveTreeCom(char **comstrp ) 
{ 
  int ch ;
  boolean inquote ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 3960
  inquote = 0;
  {
#line 3961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3961
    ch = _IO_getc(stdin);
    }
#line 3961
    if (ch != -1) {
#line 3961
      if (! inquote) {
#line 3961
        if (! (ch != 93)) {
#line 3961
          goto while_break;
        }
      }
    } else {
#line 3961
      goto while_break;
    }
#line 3962
    tmp = *comstrp;
#line 3962
    (*comstrp) ++;
#line 3962
    *tmp = (char )ch;
#line 3963
    if (ch == 91) {
#line 3963
      if (! inquote) {
        {
#line 3964
        ch = saveTreeCom(comstrp);
        }
#line 3964
        if (ch == -1) {
#line 3964
          goto while_break;
        }
#line 3965
        tmp___0 = *comstrp;
#line 3965
        (*comstrp) ++;
#line 3965
        *tmp___0 = (char )ch;
      } else {
#line 3963
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3967
    if (ch == 39) {
#line 3967
      inquote = ! inquote;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3970
  return (ch);
}
}
#line 3974 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean processTreeCom(FILE *fp , tree *tr ) 
{ 
  int text_started ;
  int functor_read ;
  int com_open ;
  char com[1024] ;
  char *com_end ;
  int tmp ;

  {
  {
#line 3980
  text_started = 0;
#line 3980
  functor_read = text_started;
#line 3981
  fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" p%nhylip_tree(%n",
         & text_started, & functor_read);
  }
#line 3982
  if (text_started) {
#line 3982
    if (! functor_read) {
      {
#line 3983
      fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"seudoNewick(%n",
             & functor_read);
      }
#line 3984
      if (! functor_read) {
        {
#line 3985
        printf((char const   */* __restrict  */)"Start of tree \'p...\' not understood.\n");
        }
#line 3986
        return (0);
      }
    }
  }
  {
#line 3990
  com_open = 0;
#line 3991
  fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%n", & com_open);
  }
#line 3993
  if (com_open) {
    {
#line 3996
    com_end = com;
#line 3997
    tmp = treeFinishCom(fp, & com_end);
    }
#line 3997
    if (tmp == -1) {
      {
#line 3998
      printf((char const   */* __restrict  */)"Missing end of tree comment\n");
      }
#line 3999
      return (0);
    }
    {
#line 4002
    readKeyValue(com, likelihood_key, (char *)"%lg", (void *)(& tr->likelihood));
#line 4004
    readKeyValue(com, opt_level_key, (char *)"%d", (void *)(& tr->opt_level));
#line 4006
    readKeyValue(com, smoothed_key, (char *)"%d", (void *)(& tr->smoothed));
    }
#line 4009
    if (functor_read) {
      {
#line 4009
      fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ,");
      }
    }
  }
#line 4012
  return (functor_read > 0);
}
}
#line 4016 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
nodeptr uprootTree(tree *tr , nodeptr p ) 
{ 
  nodeptr q ;
  nodeptr r ;
  nodeptr s ;
  nodeptr start ;
  int n ;
  double tmp ;
  struct noderec *tmp___0 ;
  struct noderec *tmp___1 ;
  struct noderec *tmp___2 ;
  struct noderec *tmp___3 ;

  {
#line 4021
  if (p->tip) {
    {
#line 4022
    printf((char const   */* __restrict  */)"ERROR: Unable to uproot tree.\n");
#line 4023
    printf((char const   */* __restrict  */)"       Inappropriate node marked for removal.\n");
    }
#line 4024
    return ((nodeptr )((void *)0));
  } else
#line 4021
  if (p->back) {
    {
#line 4022
    printf((char const   */* __restrict  */)"ERROR: Unable to uproot tree.\n");
#line 4023
    printf((char const   */* __restrict  */)"       Inappropriate node marked for removal.\n");
    }
#line 4024
    return ((nodeptr )((void *)0));
  }
#line 4027
  (tr->nextnode) --;
#line 4027
  n = tr->nextnode;
#line 4028
  if (n != (tr->mxtips + tr->ntips) - 1) {
    {
#line 4029
    printf((char const   */* __restrict  */)"ERROR: Unable to uproot tree.  Inconsistent\n");
#line 4030
    printf((char const   */* __restrict  */)"       number of tips and nodes for rooted tree.\n");
    }
#line 4031
    return ((nodeptr )((void *)0));
  }
#line 4034
  q = (p->next)->back;
#line 4035
  r = ((p->next)->next)->back;
#line 4036
  if (tr->userlen) {
#line 4036
    tmp = q->z * r->z;
  } else {
#line 4036
    tmp = 0.9;
  }
  {
#line 4036
  hookup(q, r, tmp);
  }
#line 4038
  if (r->tip) {
#line 4038
    start = r;
  } else
#line 4038
  if (! q->tip) {
#line 4038
    start = r;
  } else {
#line 4038
    start = ((r->next)->next)->back;
  }
#line 4040
  if (tr->ntips > 2) {
#line 4040
    if (p->number != n) {
      {
#line 4041
      q = *(tr->nodep + n);
#line 4042
      r = q->next;
#line 4043
      s = (q->next)->next;
#line 4044
      hookup(p, q->back, q->z);
#line 4045
      hookup(p->next, r->back, r->z);
#line 4046
      hookup((p->next)->next, s->back, s->z);
      }
#line 4047
      if (start->number == q->number) {
#line 4047
        start = (start->back)->back;
      }
#line 4048
      tmp___1 = (nodeptr )((void *)0);
#line 4048
      s->back = tmp___1;
#line 4048
      tmp___0 = tmp___1;
#line 4048
      r->back = tmp___0;
#line 4048
      q->back = tmp___0;
    } else {
#line 4051
      tmp___3 = (nodeptr )((void *)0);
#line 4051
      ((p->next)->next)->back = tmp___3;
#line 4051
      tmp___2 = tmp___3;
#line 4051
      (p->next)->back = tmp___2;
#line 4051
      p->back = tmp___2;
    }
  } else {
#line 4051
    tmp___3 = (nodeptr )((void *)0);
#line 4051
    ((p->next)->next)->back = tmp___3;
#line 4051
    tmp___2 = tmp___3;
#line 4051
    (p->next)->back = tmp___2;
#line 4051
    p->back = tmp___2;
  }
#line 4054
  tr->rooted = 0;
#line 4055
  return (start);
}
}
#line 4059 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeReadLen(FILE *fp , tree *tr ) 
{ 
  nodeptr p ;
  int i ;
  int ch ;
  boolean is_fact ;
  int tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;
  boolean tmp___8 ;
  boolean tmp___9 ;
  boolean tmp___10 ;
  boolean tmp___11 ;
  int tmp___12 ;

  {
#line 4065
  i = 1;
  {
#line 4065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4065
    if (! (i <= tr->mxtips)) {
#line 4065
      goto while_break;
    }
#line 4065
    (*(tr->nodep + i))->back = (node *)((void *)0);
#line 4065
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4066
  tr->start = *(tr->nodep + tr->mxtips);
#line 4067
  tr->ntips = 0;
#line 4068
  tr->nextnode = tr->mxtips + 1;
#line 4069
  tr->opt_level = 0;
#line 4070
  tr->log_f_valid = 0;
#line 4071
  tr->smoothed = 0;
#line 4072
  tr->rooted = 0;
#line 4074
  is_fact = processTreeCom(fp, tr);
#line 4076
  tmp = tr->nextnode;
#line 4076
  (tr->nextnode) ++;
#line 4076
  p = *(tr->nodep + tmp);
#line 4077
  tmp___0 = treeNeedCh(fp, '(', (char *)"at start of");
  }
#line 4077
  if (! tmp___0) {
#line 4077
    return (0);
  }
  {
#line 4078
  tmp___1 = addElementLen(fp, tr, p);
  }
#line 4078
  if (! tmp___1) {
#line 4078
    return (0);
  }
  {
#line 4079
  tmp___2 = treeNeedCh(fp, ',', (char *)"in");
  }
#line 4079
  if (! tmp___2) {
#line 4079
    return (0);
  }
  {
#line 4080
  tmp___3 = addElementLen(fp, tr, p->next);
  }
#line 4080
  if (! tmp___3) {
#line 4080
    return (0);
  }
#line 4081
  if (! tr->rooted) {
    {
#line 4082
    ch = treeGetCh(fp);
    }
#line 4082
    if (ch == 44) {
      {
#line 4083
      tmp___4 = addElementLen(fp, tr, (p->next)->next);
      }
#line 4083
      if (! tmp___4) {
#line 4083
        return (0);
      }
    } else {
#line 4086
      tr->rooted = 1;
#line 4087
      if (ch != -1) {
        {
#line 4087
        ungetc(ch, fp);
        }
      }
    }
  } else {
#line 4091
    ((p->next)->next)->back = (nodeptr )((void *)0);
  }
  {
#line 4093
  tmp___5 = treeNeedCh(fp, ')', (char *)"in");
  }
#line 4093
  if (! tmp___5) {
#line 4093
    return (0);
  }
  {
#line 4094
  treeFlushLabel(fp);
#line 4095
  tmp___6 = treeFlushLen(fp);
  }
#line 4095
  if (! tmp___6) {
#line 4095
    return (0);
  }
#line 4096
  if (is_fact) {
    {
#line 4097
    tmp___7 = treeNeedCh(fp, ')', (char *)"at end of");
    }
#line 4097
    if (! tmp___7) {
#line 4097
      return (0);
    }
    {
#line 4098
    tmp___8 = treeNeedCh(fp, '.', (char *)"at end of");
    }
#line 4098
    if (! tmp___8) {
#line 4098
      return (0);
    }
  } else {
    {
#line 4101
    tmp___9 = treeNeedCh(fp, ';', (char *)"at end of");
    }
#line 4101
    if (! tmp___9) {
#line 4101
      return (0);
    }
  }
#line 4104
  if (tr->rooted) {
    {
#line 4105
    ((p->next)->next)->back = (nodeptr )((void *)0);
#line 4106
    tr->start = uprootTree(tr, (p->next)->next);
    }
#line 4107
    if (! tr->start) {
#line 4107
      return (0);
    }
  } else {
#line 4110
    tr->start = ((p->next)->next)->back;
  }
  {
#line 4113
  tmp___10 = initrav(tr, tr->start);
  }
#line 4113
  if (tmp___10) {
    {
#line 4113
    tmp___11 = initrav(tr, (tr->start)->back);
    }
#line 4113
    if (tmp___11) {
#line 4113
      tmp___12 = 1;
    } else {
#line 4113
      tmp___12 = 0;
    }
  } else {
#line 4113
    tmp___12 = 0;
  }
#line 4113
  return (tmp___12);
}
}
#line 4437 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean treeEvaluate(tree *tr , bestlist *bt ) 
{ 
  boolean tmp ;
  double tmp___0 ;

  {
#line 4440
  if (! tr->userlen) {
    {
#line 4441
    tmp = smoothTree(tr, 128);
    }
#line 4441
    if (! tmp) {
#line 4441
      return (0);
    }
  }
  {
#line 4444
  tmp___0 = evaluate(tr, tr->start);
  }
#line 4444
  if (tmp___0 == 1.0) {
#line 4444
    return (0);
  }
  {
#line 4447
  saveBestTree(bt, tr);
  }
#line 4449
  return (1);
}
}
#line 4464 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean showBestTrees(bestlist *bt , tree *tr , analdef *adef , FILE *treefile ) 
{ 
  int rank ;
  int tmp ;
  double tmp___0 ;

  {
#line 4468
  rank = 1;
  {
#line 4468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4468
    if (! (rank <= bt->nvalid)) {
#line 4468
      goto while_break;
    }
#line 4469
    if (rank > 1) {
      {
#line 4470
      tmp = recallBestTree(bt, rank, tr);
      }
#line 4470
      if (rank != tmp) {
#line 4470
        goto while_break;
      }
    }
    {
#line 4472
    tmp___0 = evaluate(tr, tr->start);
    }
#line 4472
    if (tmp___0 == 1.0) {
#line 4472
      return (0);
    }
#line 4473
    if ((tr->outgrnode)->back) {
#line 4473
      tr->start = tr->outgrnode;
    }
    {
#line 4474
    printTree(tr, adef);
#line 4475
    summarize(tr);
    }
#line 4476
    if (treefile) {
      {
#line 4476
      treeOut(treefile, tr, adef->trout);
      }
    }
#line 4468
    rank ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4479
  return (1);
}
}
#line 4483 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean cmpBestTrees(bestlist *bt , tree *tr ) 
{ 
  double sum ;
  double sum2 ;
  double sd ;
  double temp ;
  double wtemp ;
  double bestscore ;
  double *log_f0 ;
  double *log_f0_ptr ;
  double *log_f_ptr ;
  int i ;
  int j ;
  int num ;
  int besttips ;
  char *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double *tmp___2 ;
  double *tmp___3 ;
  double *tmp___4 ;
  double *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 4490
  num = bt->nvalid;
#line 4491
  if (num <= 1) {
#line 4491
    return (1);
  } else
#line 4491
  if ((tr->cdta)->wgtsum <= 1) {
#line 4491
    return (1);
  }
  {
#line 4493
  tmp = malloc((unsigned int )(sizeof(double ) * (unsigned long )(tr->cdta)->endsite));
#line 4493
  log_f0 = (double *)tmp;
  }
#line 4493
  if (! log_f0) {
    {
#line 4494
    printf((char const   */* __restrict  */)"ERROR: cmpBestTrees unable to obtain space for log_f0\n");
    }
#line 4495
    return (0);
  }
  {
#line 4498
  printf((char const   */* __restrict  */)"Tree      Ln L        Diff Ln L       Its S.D.");
#line 4499
  printf((char const   */* __restrict  */)"   Significantly worse?\n\n");
#line 4501
  i = 1;
  }
  {
#line 4501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4501
    if (! (i <= num)) {
#line 4501
      goto while_break;
    }
    {
#line 4502
    tmp___0 = recallBestTree(bt, i, tr);
    }
#line 4502
    if (i != tmp___0) {
#line 4502
      goto while_break;
    }
#line 4503
    if (! tr->log_f_valid) {
      {
#line 4504
      tmp___1 = evaluate(tr, tr->start);
      }
#line 4504
      if (tmp___1 == 1.0) {
#line 4504
        return (0);
      }
    }
    {
#line 4507
    printf((char const   */* __restrict  */)"%3d%14.5f", i, tr->likelihood);
    }
#line 4508
    if (i == 1) {
      {
#line 4509
      printf((char const   */* __restrict  */)"  <------ best\n");
#line 4510
      besttips = tr->ntips;
#line 4511
      bestscore = tr->likelihood;
#line 4512
      log_f0_ptr = log_f0;
#line 4513
      log_f_ptr = tr->log_f;
#line 4514
      j = 0;
      }
      {
#line 4514
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4514
        if (! (j < (tr->cdta)->endsite)) {
#line 4514
          goto while_break___0;
        }
#line 4514
        tmp___2 = log_f0_ptr;
#line 4514
        log_f0_ptr ++;
#line 4514
        tmp___3 = log_f_ptr;
#line 4514
        log_f_ptr ++;
#line 4514
        *tmp___2 = *tmp___3;
#line 4514
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 4516
    if (tr->ntips != besttips) {
      {
#line 4517
      printf((char const   */* __restrict  */)"  (different number of species)\n");
      }
    } else {
#line 4519
      sum2 = 0.0;
#line 4519
      sum = sum2;
#line 4520
      log_f0_ptr = log_f0;
#line 4521
      log_f_ptr = tr->log_f;
#line 4522
      j = 0;
      {
#line 4522
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4522
        if (! (j < (tr->cdta)->endsite)) {
#line 4522
          goto while_break___1;
        }
#line 4523
        tmp___4 = log_f0_ptr;
#line 4523
        log_f0_ptr ++;
#line 4523
        tmp___5 = log_f_ptr;
#line 4523
        log_f_ptr ++;
#line 4523
        temp = *tmp___4 - *tmp___5;
#line 4524
        wtemp = (double )*((tr->cdta)->aliaswgt + j) * temp;
#line 4525
        sum += wtemp;
#line 4526
        sum2 += wtemp * temp;
#line 4522
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 4528
      sd = sqrt(((double )(tr->cdta)->wgtsum * (sum2 - (sum * sum) / (double )(tr->cdta)->wgtsum)) / (double )((tr->cdta)->wgtsum - 1));
#line 4530
      printf((char const   */* __restrict  */)"%14.5f%14.4f", tr->likelihood - bestscore,
             sd);
      }
#line 4531
      if (sum > 1.95996 * sd) {
#line 4531
        tmp___6 = "Yes";
      } else {
#line 4531
        tmp___6 = " No";
      }
      {
#line 4531
      printf((char const   */* __restrict  */)"           %s\n", tmp___6);
      }
    }
#line 4501
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4535
  free((char *)log_f0);
#line 4536
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 4538
  return (1);
}
}
#line 4542 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean makeUserTree(tree *tr , bestlist *bt , analdef *adef ) 
{ 
  char filename[128] ;
  FILE *treefile ;
  int nusertrees ;
  int which ;
  char const   *tmp ;
  FILE *tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  int tmp___3 ;
  boolean tmp___4 ;

  {
#line 4548
  nusertrees = adef->numutrees;
#line 4550
  if (nusertrees == 1) {
#line 4550
    tmp = "tree";
  } else {
#line 4550
    tmp = "trees";
  }
  {
#line 4550
  printf((char const   */* __restrict  */)"User-defined %s:\n\n", tmp);
  }
#line 4552
  if (adef->trout) {
    {
#line 4552
    tmp___0 = fopen_pid((char *)"treefile", (char *)"w", filename);
#line 4552
    treefile = tmp___0;
    }
  } else {
#line 4552
    treefile = (FILE *)((void *)0);
  }
#line 4554
  which = 1;
  {
#line 4554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4554
    if (! (which <= nusertrees)) {
#line 4554
      goto while_break;
    }
    {
#line 4555
    tmp___1 = treeReadLen(stdin, tr);
    }
#line 4555
    if (! tmp___1) {
#line 4555
      return (0);
    }
    {
#line 4556
    tmp___2 = treeEvaluate(tr, bt);
    }
#line 4556
    if (! tmp___2) {
#line 4556
      return (0);
    }
#line 4557
    if (tr->global <= 0) {
#line 4558
      if ((tr->outgrnode)->back) {
#line 4558
        tr->start = tr->outgrnode;
      }
      {
#line 4559
      printTree(tr, adef);
#line 4560
      summarize(tr);
      }
#line 4561
      if (treefile) {
        {
#line 4561
        treeOut(treefile, tr, adef->trout);
        }
      }
    } else {
      {
#line 4564
      printf((char const   */* __restrict  */)"%6d:  Ln Likelihood =%14.5f\n", which,
             tr->likelihood);
      }
    }
#line 4554
    which ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4568
  if (tr->global > 0) {
    {
#line 4569
    putchar('\n');
#line 4570
    tmp___3 = recallBestTree(bt, 1, tr);
    }
#line 4570
    if (! tmp___3) {
#line 4570
      return (0);
    }
    {
#line 4571
    printf((char const   */* __restrict  */)"      Ln Likelihood =%14.5f\n", tr->likelihood);
#line 4572
    tmp___4 = optimize(tr, tr->global, bt);
    }
#line 4572
    if (! tmp___4) {
#line 4572
      return (0);
    }
#line 4573
    if ((tr->outgrnode)->back) {
#line 4573
      tr->start = tr->outgrnode;
    }
    {
#line 4574
    printTree(tr, adef);
#line 4575
    summarize(tr);
    }
#line 4576
    if (treefile) {
      {
#line 4576
      treeOut(treefile, tr, adef->trout);
      }
    }
  }
#line 4579
  if (treefile) {
    {
#line 4580
    fclose(treefile);
#line 4581
    printf((char const   */* __restrict  */)"Tree also written to %s\n", filename);
    }
  }
  {
#line 4584
  putchar('\n');
#line 4586
  cmpBestTrees(bt, tr);
  }
#line 4587
  return (1);
}
}
#line 4611 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
double randum(long *seed ) 
{ 
  long sum ;
  long mult0 ;
  long mult1 ;
  long seed0 ;
  long seed1 ;
  long seed2 ;
  long newseed0 ;
  long newseed1 ;
  long newseed2 ;

  {
#line 4616
  mult0 = 1549L;
#line 4617
  seed0 = *seed & 4095L;
#line 4618
  sum = mult0 * seed0;
#line 4619
  newseed0 = sum & 4095L;
#line 4620
  sum >>= 12;
#line 4621
  seed1 = (*seed >> 12) & 4095L;
#line 4622
  mult1 = 406L;
#line 4623
  sum += mult0 * seed1 + mult1 * seed0;
#line 4624
  newseed1 = sum & 4095L;
#line 4625
  sum >>= 12;
#line 4626
  seed2 = (*seed >> 24) & 255L;
#line 4627
  sum += mult0 * seed2 + mult1 * seed1;
#line 4628
  newseed2 = sum & 255L;
#line 4630
  *seed = ((newseed2 << 24) | (newseed1 << 12)) | newseed0;
#line 4631
  return (0.00390625 * ((double )newseed2 + 0.000244140625 * ((double )newseed1 + 0.000244140625 * (double )newseed0)));
}
}
#line 4637 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
boolean makeDenovoTree(tree *tr , bestlist *bt , analdef *adef ) 
{ 
  char filename[128] ;
  FILE *treefile ;
  nodeptr p ;
  int *enterorder ;
  int i ;
  int j ;
  int k ;
  int nextsp ;
  int newsp ;
  int maxtrav ;
  int tested ;
  char *tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  boolean tmp___5 ;
  node *tmp___6 ;
  boolean tmp___7 ;
  double tmp___8 ;
  boolean tmp___9 ;
  char const   *tmp___10 ;
  FILE *tmp___11 ;

  {
  {
#line 4648
  tmp = malloc((unsigned int )(sizeof(int ) * (unsigned long )(tr->mxtips + 1)));
#line 4648
  enterorder = (int *)tmp;
  }
#line 4649
  if (! enterorder) {
    {
#line 4650
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"makeDenovoTree: Malloc failure for enterorder\n");
    }
#line 4651
    return (0);
  }
#line 4654
  if (adef->restart) {
    {
#line 4655
    printf((char const   */* __restrict  */)"Restarting from tree with the following sequences:\n");
#line 4656
    tr->userlen = 1;
#line 4657
    tmp___0 = treeReadLen(stdin, tr);
    }
#line 4657
    if (! tmp___0) {
#line 4657
      return (0);
    }
    {
#line 4658
    tmp___1 = smoothTree(tr, 32);
    }
#line 4658
    if (! tmp___1) {
#line 4658
      return (0);
    }
    {
#line 4659
    tmp___2 = evaluate(tr, tr->start);
    }
#line 4659
    if (tmp___2 == 1.0) {
#line 4659
      return (0);
    }
    {
#line 4660
    tmp___3 = saveBestTree(bt, tr);
    }
#line 4660
    if (tmp___3 < 1) {
#line 4660
      return (0);
    }
#line 4662
    i = 1;
#line 4662
    j = tr->ntips;
    {
#line 4662
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4662
      if (! (i <= tr->mxtips)) {
#line 4662
        goto while_break;
      }
#line 4663
      if (! (*(tr->nodep + i))->back) {
#line 4664
        j ++;
#line 4664
        *(enterorder + j) = i;
      } else {
        {
#line 4667
        printf((char const   */* __restrict  */)"   %s\n", (*(tr->nodep + i))->name);
        }
      }
#line 4662
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4674
    putchar('\n');
    }
  } else {
#line 4678
    tr->ntips = 0;
#line 4679
    i = 1;
    {
#line 4679
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4679
      if (! (i <= tr->mxtips)) {
#line 4679
        goto while_break___0;
      }
#line 4679
      *(enterorder + i) = i;
#line 4679
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4682
  if (adef->jumble) {
#line 4682
    i = tr->ntips + 1;
    {
#line 4682
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4682
      if (! (i <= tr->mxtips)) {
#line 4682
        goto while_break___1;
      }
      {
#line 4683
      tmp___4 = randum(& adef->jumble);
#line 4683
      j = (int )((tmp___4 * (double )(tr->mxtips - tr->ntips) + (double )tr->ntips) + (double )1);
#line 4684
      k = *(enterorder + j);
#line 4685
      *(enterorder + j) = *(enterorder + i);
#line 4686
      *(enterorder + i) = k;
#line 4682
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4689
  bt->numtrees = 1;
#line 4690
  if (tr->ntips < tr->mxtips) {
    {
#line 4690
    printf((char const   */* __restrict  */)"Adding species:\n");
    }
  }
#line 4692
  if (tr->ntips == 0) {
#line 4693
    i = 1;
    {
#line 4693
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4693
      if (! (i <= 3)) {
#line 4693
        goto while_break___2;
      }
      {
#line 4694
      printf((char const   */* __restrict  */)"   %s\n", (*(tr->nodep + *(enterorder + i)))->name);
#line 4693
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 4696
    tr->nextnode = tr->mxtips + 1;
#line 4697
    tmp___5 = buildSimpleTree(tr, *(enterorder + 1), *(enterorder + 2), *(enterorder + 3));
    }
#line 4697
    if (! tmp___5) {
#line 4698
      return (0);
    }
  }
  {
#line 4701
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4701
    if (! (tr->ntips < tr->mxtips)) {
#line 4701
      if (! (tr->opt_level < tr->global)) {
#line 4701
        goto while_break___3;
      }
    }
#line 4702
    if (tr->ntips == tr->mxtips) {
#line 4702
      maxtrav = tr->global;
    } else {
#line 4702
      maxtrav = tr->partswap;
    }
#line 4703
    if (maxtrav > tr->ntips - 3) {
#line 4703
      maxtrav = tr->ntips - 3;
    }
#line 4705
    if (tr->opt_level >= maxtrav) {
      {
#line 4706
      (tr->ntips) ++;
#line 4706
      nextsp = tr->ntips;
#line 4707
      newsp = *(enterorder + nextsp);
#line 4708
      p = *(tr->nodep + newsp);
#line 4709
      printf((char const   */* __restrict  */)"   %s\n", p->name);
#line 4718
      buildNewTip(tr, p);
#line 4720
      resetBestTree(bt);
#line 4721
      cacheZ(tr);
#line 4722
      tmp___6 = findAnyTip(tr->start);
#line 4722
      tested = addTraverse(tr, p->back, tmp___6->back, 1, tr->ntips - 2, bt, adef->qadd);
      }
#line 4724
      if (tested == -1) {
#line 4724
        return (0);
      }
      {
#line 4725
      bt->numtrees += tested;
#line 4731
      printf((char const   */* __restrict  */)"      Tested %d alternative trees\n",
             tested);
#line 4733
      recallBestTree(bt, 1, tr);
      }
#line 4734
      if (! tr->smoothed) {
        {
#line 4735
        tmp___7 = smoothTree(tr, 32);
        }
#line 4735
        if (! tmp___7) {
#line 4735
          return (0);
        }
        {
#line 4736
        tmp___8 = evaluate(tr, tr->start);
        }
#line 4736
        if (tmp___8 == 1.0) {
#line 4736
          return (0);
        }
        {
#line 4737
        saveBestTree(bt, tr);
        }
      }
#line 4740
      if (tr->ntips == 4) {
#line 4740
        tr->opt_level = 1;
      }
#line 4741
      if (tr->ntips == tr->mxtips) {
#line 4741
        maxtrav = tr->global;
      } else {
#line 4741
        maxtrav = tr->partswap;
      }
#line 4742
      if (maxtrav > tr->ntips - 3) {
#line 4742
        maxtrav = tr->ntips - 3;
      }
    }
    {
#line 4745
    printf((char const   */* __restrict  */)"      Ln Likelihood =%14.5f\n", tr->likelihood);
#line 4746
    tmp___9 = optimize(tr, maxtrav, bt);
    }
#line 4746
    if (! tmp___9) {
#line 4746
      return (0);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 4749
  if (bt->numtrees != 1) {
#line 4749
    tmp___10 = "trees";
  } else {
#line 4749
    tmp___10 = "tree";
  }
  {
#line 4749
  printf((char const   */* __restrict  */)"\nExamined %d %s\n", bt->numtrees, tmp___10);
  }
#line 4752
  if (adef->trout) {
    {
#line 4752
    tmp___11 = fopen_pid((char *)"treefile", (char *)"w", filename);
#line 4752
    treefile = tmp___11;
    }
  } else {
#line 4752
    treefile = (FILE *)((void *)0);
  }
  {
#line 4753
  showBestTrees(bt, tr, adef, treefile);
  }
#line 4754
  if (treefile) {
    {
#line 4755
    fclose(treefile);
#line 4756
    printf((char const   */* __restrict  */)"Tree also written to %s\n\n", filename);
    }
  }
  {
#line 4759
  cmpBestTrees(bt, tr);
#line 4765
  free((char *)enterorder);
  }
#line 4767
  return (1);
}
}
#line 4775 "/home/june/repo/benchmarks/collector/temp/fastdnaml-1.2.2/source/fastDNAml.c"
int main(void) 
{ 
  analdef *adef ;
  rawdata *rdta ;
  cruncheddata *cdta ;
  tree *tr ;
  bestlist *bt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  boolean tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;
  boolean tmp___8 ;
  boolean tmp___9 ;
  boolean tmp___10 ;
  int tmp___11 ;
  boolean tmp___12 ;
  boolean tmp___13 ;
  boolean tmp___14 ;

  {
  {
#line 4863
  tmp = malloc((unsigned int )sizeof(analdef ));
#line 4863
  adef = (analdef *)tmp;
  }
#line 4863
  if (! adef) {
    {
#line 4864
    printf((char const   */* __restrict  */)"ERROR: Unable to get memory for analysis definition\n\n");
    }
#line 4865
    return (1);
  }
  {
#line 4868
  tmp___0 = malloc((unsigned int )sizeof(rawdata ));
#line 4868
  rdta = (rawdata *)tmp___0;
  }
#line 4868
  if (! rdta) {
    {
#line 4869
    printf((char const   */* __restrict  */)"ERROR: Unable to get memory for raw DNA\n\n");
    }
#line 4870
    return (1);
  }
  {
#line 4873
  tmp___1 = malloc((unsigned int )sizeof(cruncheddata ));
#line 4873
  cdta = (cruncheddata *)tmp___1;
  }
#line 4873
  if (! cdta) {
    {
#line 4874
    printf((char const   */* __restrict  */)"ERROR: Unable to get memory for crunched DNA\n\n");
    }
#line 4875
    return (1);
  }
  {
#line 4878
  tmp___2 = malloc((unsigned int )sizeof(tree ));
#line 4878
  tr = (tree *)tmp___2;
  }
#line 4878
  if (tr) {
    {
#line 4878
    tmp___3 = malloc((unsigned int )sizeof(bestlist ));
#line 4878
    bt = (bestlist *)tmp___3;
    }
#line 4878
    if (! bt) {
      {
#line 4881
      printf((char const   */* __restrict  */)"ERROR: Unable to get memory for trees\n\n");
      }
#line 4882
      return (1);
    }
  } else {
    {
#line 4881
    printf((char const   */* __restrict  */)"ERROR: Unable to get memory for trees\n\n");
    }
#line 4882
    return (1);
  }
  {
#line 4884
  bt->ninit = 0;
#line 4886
  tmp___4 = getinput(adef, rdta, cdta, tr);
  }
#line 4886
  if (! tmp___4) {
#line 4886
    return (1);
  }
  {
#line 4900
  tmp___5 = makeweights(adef, rdta, cdta);
  }
#line 4900
  if (! tmp___5) {
#line 4900
    return (1);
  }
  {
#line 4901
  tmp___6 = makevalues(rdta, cdta);
  }
#line 4901
  if (! tmp___6) {
#line 4901
    return (1);
  }
#line 4902
  if (adef->empf) {
    {
#line 4902
    tmp___7 = empiricalfreqs(rdta, cdta);
    }
#line 4902
    if (! tmp___7) {
#line 4902
      return (1);
    }
  }
  {
#line 4903
  reportfreqs(adef, rdta);
#line 4904
  tmp___8 = linkdata2tree(rdta, cdta, tr);
  }
#line 4904
  if (! tmp___8) {
#line 4904
    return (1);
  }
  {
#line 4906
  tmp___9 = linkxarray(3, 3, cdta->endsite, & freextip, & usedxtip);
  }
#line 4906
  if (! tmp___9) {
#line 4906
    return (1);
  }
  {
#line 4907
  tmp___10 = setupnodex(tr);
  }
#line 4907
  if (! tmp___10) {
#line 4907
    return (1);
  }
  {
#line 4912
  tmp___11 = initBestTree(bt, adef->nkeep, tr->mxtips, (tr->cdta)->endsite);
  }
#line 4912
  if (! tmp___11) {
#line 4912
    return (1);
  }
#line 4913
  if (! adef->usertree) {
    {
#line 4914
    tmp___12 = makeDenovoTree(tr, bt, adef);
    }
#line 4914
    if (! tmp___12) {
#line 4914
      return (1);
    }
  } else {
    {
#line 4917
    tmp___13 = makeUserTree(tr, bt, adef);
    }
#line 4917
    if (! tmp___13) {
#line 4917
      return (1);
    }
  }
  {
#line 4919
  tmp___14 = freeBestTree(bt);
  }
#line 4919
  if (! tmp___14) {
#line 4919
    return (1);
  }
  {
#line 4929
  freeTree(tr);
  }
#line 4953
  return (0);
}
}
