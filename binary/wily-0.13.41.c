/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 15 "./../include/libg.h"
struct Bitmap;
#line 15 "./../include/libg.h"
typedef struct Bitmap Bitmap;
#line 16
struct Point;
#line 16 "./../include/libg.h"
typedef struct Point Point;
#line 17
struct Rectangle;
#line 17 "./../include/libg.h"
typedef struct Rectangle Rectangle;
#line 28 "./../include/libg.h"
struct Point {
   int x ;
   int y ;
};
#line 34 "./../include/libg.h"
struct Rectangle {
   Point min ;
   Point max ;
};
#line 40 "./../include/libg.h"
struct Bitmap {
   Rectangle r ;
   Rectangle clipr ;
   int ldepth ;
   int id ;
   Bitmap *cache ;
   int flag ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_33 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_33 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_34 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_34 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_35 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_35 Screen;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_37 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_37 XSetWindowAttributes;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_50 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_50 XModifierKeymap;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_52 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_53 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_54 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_55 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_56 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_57 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_58 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_59 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_60 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_61 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_62 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_63 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_64 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_65 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_66 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_66 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_67 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_68 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_69 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_70 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_71 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_72 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_73 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_74 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_75 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_76 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_77 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_78 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_80 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_80 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_79 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_81 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_82 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_82 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_83 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_84 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_85 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_86 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_86 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_87 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_87 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_88 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_88 XFontStruct;
#line 273 "/usr/include/X11/Xutil.h"
struct _XRegion;
#line 273 "/usr/include/X11/Xutil.h"
typedef struct _XRegion *Region;
#line 84 "/usr/include/X11/Xresource.h"
typedef int XrmQuark;
#line 136 "/usr/include/X11/Xresource.h"
typedef XrmQuark XrmName;
#line 142 "/usr/include/X11/Xresource.h"
typedef XrmQuark XrmClass;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_120 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_120 XrmValue;
#line 66 "/usr/include/X11/Intrinsic.h"
typedef char *String;
#line 107
struct _WidgetRec;
#line 107 "/usr/include/X11/Intrinsic.h"
typedef struct _WidgetRec *Widget;
#line 108 "/usr/include/X11/Intrinsic.h"
typedef Widget *WidgetList;
#line 109
struct _WidgetClassRec;
#line 109 "/usr/include/X11/Intrinsic.h"
typedef struct _WidgetClassRec *WidgetClass;
#line 111
struct _XtActionsRec;
#line 111 "/usr/include/X11/Intrinsic.h"
typedef struct _XtActionsRec *XtActionList;
#line 112
struct _XtEventRec;
#line 112 "/usr/include/X11/Intrinsic.h"
typedef struct _XtEventRec *XtEventTable;
#line 114
struct _XtAppStruct;
#line 114 "/usr/include/X11/Intrinsic.h"
typedef struct _XtAppStruct *XtAppContext;
#line 115 "/usr/include/X11/Intrinsic.h"
typedef unsigned long XtValueMask;
#line 120 "/usr/include/X11/Intrinsic.h"
typedef unsigned int XtGeometryMask;
#line 122 "/usr/include/X11/Intrinsic.h"
typedef unsigned long Pixel;
#line 155 "/usr/include/X11/Intrinsic.h"
typedef char Boolean;
#line 156 "/usr/include/X11/Intrinsic.h"
typedef long XtArgVal;
#line 157 "/usr/include/X11/Intrinsic.h"
typedef unsigned char XtEnum;
#line 160 "/usr/include/X11/Intrinsic.h"
typedef unsigned int Cardinal;
#line 161 "/usr/include/X11/Intrinsic.h"
typedef unsigned short Dimension;
#line 162 "/usr/include/X11/Intrinsic.h"
typedef short Position;
#line 164 "/usr/include/X11/Intrinsic.h"
typedef void *XtPointer;
#line 176
struct _TranslationData;
#line 176 "/usr/include/X11/Intrinsic.h"
typedef struct _TranslationData *XtTranslations;
#line 178 "/usr/include/X11/Intrinsic.h"
typedef unsigned int Modifiers;
#line 180 "/usr/include/X11/Intrinsic.h"
typedef void (*XtActionProc)(Widget  , XEvent * , String * , Cardinal * );
#line 187 "/usr/include/X11/Intrinsic.h"
typedef XtActionProc *XtBoundActions;
#line 189 "/usr/include/X11/Intrinsic.h"
struct _XtActionsRec {
   String string ;
   void (*proc)(Widget  , XEvent * , String * , Cardinal * ) ;
};
#line 189 "/usr/include/X11/Intrinsic.h"
typedef struct _XtActionsRec XtActionsRec;
#line 218 "/usr/include/X11/Intrinsic.h"
struct __anonstruct_XtWidgetGeometry_125 {
   XtGeometryMask request_mode ;
   Position x ;
   Position y ;
   Dimension width ;
   Dimension height ;
   Dimension border_width ;
   Widget sibling ;
   int stack_mode ;
};
#line 218 "/usr/include/X11/Intrinsic.h"
typedef struct __anonstruct_XtWidgetGeometry_125 XtWidgetGeometry;
#line 300 "/usr/include/X11/Intrinsic.h"
typedef unsigned long XtInputMask;
#line 322 "/usr/include/X11/Intrinsic.h"
struct __anonstruct_Arg_127 {
   String name ;
   XtArgVal value ;
};
#line 322 "/usr/include/X11/Intrinsic.h"
typedef struct __anonstruct_Arg_127 *ArgList;
#line 335 "/usr/include/X11/Intrinsic.h"
struct _XtCallbackRec {
   void (*callback)(Widget  , XtPointer  , XtPointer  ) ;
   XtPointer closure ;
};
#line 335 "/usr/include/X11/Intrinsic.h"
typedef struct _XtCallbackRec *XtCallbackList;
#line 346
enum __anonenum_XtGeometryResult_129 {
    XtGeometryYes = 0,
    XtGeometryNo = 1,
    XtGeometryAlmost = 2,
    XtGeometryDone = 3
} ;
#line 346 "/usr/include/X11/Intrinsic.h"
typedef enum __anonenum_XtGeometryResult_129 XtGeometryResult;
#line 360 "/usr/include/X11/Intrinsic.h"
struct _XtResource {
   String resource_name ;
   String resource_class ;
   String resource_type ;
   Cardinal resource_size ;
   Cardinal resource_offset ;
   String default_type ;
   XtPointer default_addr ;
};
#line 360 "/usr/include/X11/Intrinsic.h"
typedef struct _XtResource XtResource;
#line 360 "/usr/include/X11/Intrinsic.h"
typedef struct _XtResource *XtResourceList;
#line 68 "/usr/include/X11/IntrinsicP.h"
typedef unsigned long XtVersionType;
#line 187
struct _XtStateRec;
#line 189 "/usr/include/X11/IntrinsicP.h"
struct _XtTMRec {
   XtTranslations translations ;
   XtBoundActions proc_table ;
   struct _XtStateRec *current_state ;
   unsigned long lastEventTime ;
};
#line 189 "/usr/include/X11/IntrinsicP.h"
typedef struct _XtTMRec XtTMRec;
#line 72 "/usr/include/X11/CoreP.h"
struct _CorePart {
   Widget self ;
   WidgetClass widget_class ;
   Widget parent ;
   XrmName xrm_name ;
   Boolean being_destroyed ;
   XtCallbackList destroy_callbacks ;
   XtPointer constraints ;
   Position x ;
   Position y ;
   Dimension width ;
   Dimension height ;
   Dimension border_width ;
   Boolean managed ;
   Boolean sensitive ;
   Boolean ancestor_sensitive ;
   XtEventTable event_table ;
   XtTMRec tm ;
   XtTranslations accelerators ;
   Pixel border_pixel ;
   Pixmap border_pixmap ;
   WidgetList popup_list ;
   Cardinal num_popups ;
   String name ;
   Screen *screen ;
   Colormap colormap ;
   Window window ;
   Cardinal depth ;
   Pixel background_pixel ;
   Pixmap background_pixmap ;
   Boolean visible ;
   Boolean mapped_when_managed ;
};
#line 72 "/usr/include/X11/CoreP.h"
typedef struct _CorePart CorePart;
#line 104 "/usr/include/X11/CoreP.h"
struct _WidgetRec {
   CorePart core ;
};
#line 125 "/usr/include/X11/CoreP.h"
struct _CoreClassPart {
   WidgetClass superclass ;
   String class_name ;
   Cardinal widget_size ;
   void (*class_initialize)(void) ;
   void (*class_part_initialize)(WidgetClass  ) ;
   XtEnum class_inited ;
   void (*initialize)(Widget  , Widget  , ArgList  , Cardinal * ) ;
   void (*initialize_hook)(Widget  , ArgList  , Cardinal * ) ;
   void (*realize)(Widget  , XtValueMask * , XSetWindowAttributes * ) ;
   XtActionList actions ;
   Cardinal num_actions ;
   XtResourceList resources ;
   Cardinal num_resources ;
   XrmClass xrm_class ;
   Boolean compress_motion ;
   XtEnum compress_exposure ;
   Boolean compress_enterleave ;
   Boolean visible_interest ;
   void (*destroy)(Widget  ) ;
   void (*resize)(Widget  ) ;
   void (*expose)(Widget  , XEvent * , Region  ) ;
   Boolean (*set_values)(Widget  , Widget  , Widget  , ArgList  , Cardinal * ) ;
   Boolean (*set_values_hook)(Widget  , ArgList  , Cardinal * ) ;
   void (*set_values_almost)(Widget  , Widget  , XtWidgetGeometry * , XtWidgetGeometry * ) ;
   void (*get_values_hook)(Widget  , ArgList  , Cardinal * ) ;
   Boolean (*accept_focus)(Widget  , Time * ) ;
   XtVersionType version ;
   XtPointer callback_private ;
   String tm_table ;
   XtGeometryResult (*query_geometry)(Widget  , XtWidgetGeometry * , XtWidgetGeometry * ) ;
   void (*display_accelerator)(Widget  , String  ) ;
   XtPointer extension ;
};
#line 125 "/usr/include/X11/CoreP.h"
typedef struct _CoreClassPart CoreClassPart;
#line 160 "/usr/include/X11/CoreP.h"
struct _WidgetClassRec {
   CoreClassPart core_class ;
};
#line 160 "/usr/include/X11/CoreP.h"
typedef struct _WidgetClassRec WidgetClassRec;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
struct _GwinRec;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
typedef struct _GwinRec *GwinWidget;
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
struct __anonstruct_xy_145 {
   int x ;
   int y ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
struct __anonstruct_Gwinmouse_144 {
   int buttons ;
   struct __anonstruct_xy_145 xy ;
   unsigned long msec ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
typedef struct __anonstruct_Gwinmouse_144 Gwinmouse;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
struct __anonstruct_GwinPart_146 {
   Pixel foreground ;
   Font font ;
   Boolean forwardr ;
   void (*reshaped)(int  , int  , int  , int  ) ;
   void (*gotchar)(int  ) ;
   void (*gotmouse)(Gwinmouse * ) ;
   String selection ;
   String p9font ;
   String p9fixed ;
   int compose ;
};
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
typedef struct __anonstruct_GwinPart_146 GwinPart;
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
struct _GwinRec {
   CorePart core ;
   GwinPart gwin ;
};
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
typedef struct _GwinRec GwinRec;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
struct __anonstruct_GwinClassPart_147 {
   String (*select_swap)(Widget  , String  ) ;
   XtPointer extension ;
};
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
typedef struct __anonstruct_GwinClassPart_147 GwinClassPart;
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
struct _GwinClassRec {
   CoreClassPart core_class ;
   GwinClassPart gwin_class ;
};
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
typedef struct _GwinClassRec GwinClassRec;
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
typedef struct _GwinClassRec *GwinWidgetClass;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 5 "./../include/libc.h"
typedef unsigned short Rune;
#line 6 "./../include/msg.h"
enum Bool {
    false = 0,
    true = 1
} ;
#line 6 "./../include/msg.h"
typedef enum Bool Bool;
#line 7
struct Range;
#line 7 "./../include/msg.h"
typedef struct Range Range;
#line 46 "./../include/msg.h"
struct Range {
   ulong p0 ;
   ulong p1 ;
};
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
struct View;
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct View View;
#line 27
struct Text;
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Text Text;
#line 28
struct Data;
#line 28 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Data Data;
#line 29
struct Undo;
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Undo Undo;
#line 31
struct Rstring;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Rstring Rstring;
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
struct Rstring {
   Rune *r0 ;
   Rune *r1 ;
};
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.h"
enum __anonenum_undoing_61 {
    NoUndo = 0,
    StartUndo = 1,
    MoreUndo = 2
} ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.h"
struct Text {
   Rune *text ;
   ulong alloced ;
   ulong length ;
   Range gap ;
   Data *data ;
   Bool isbody ;
   View *v ;
   Bool needsbackup ;
   ulong pos ;
   Undo *did ;
   Undo *undone ;
   Undo *mark ;
   enum __anonenum_undoing_61 undoing ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef long Posn;
#line 30
struct Address;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct Address Address;
#line 31
struct File;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct File File;
#line 32
struct samRange;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct samRange samRange;
#line 33
struct samRangeset;
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct samRangeset samRangeset;
#line 34
struct String;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct String String___0;
#line 35
struct Inst;
#line 35 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef struct Inst Inst;
#line 37
enum __anonenum_Err_62 {
    Etoolong = 0,
    Eleftpar = 1,
    Erightpar = 2,
    Emissop = 3,
    Ebadregexp = 4,
    Ebadclass = 5,
    Eoverflow = 6
} ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
typedef enum __anonenum_Err_62 Err;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
struct String {
   int n ;
   Rune *s ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
struct samRange {
   Posn p1 ;
   Posn w2 ;
};
#line 58 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
struct samRangeset {
   samRange w[10] ;
};
#line 63 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
struct Address {
   samRange r ;
   File *f ;
};
#line 90 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
struct File {
   Text *t ;
   Posn nrunes ;
   Address dot ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 27 "./../include/u.h"
typedef unsigned char uchar;
#line 21 "./../include/libg.h"
struct Font;
#line 21 "./../include/libg.h"
typedef struct Font Font___0;
#line 22
struct Fontchar;
#line 22 "./../include/libg.h"
typedef struct Fontchar Fontchar;
#line 23
struct Subfont;
#line 23 "./../include/libg.h"
typedef struct Subfont Subfont;
#line 24
struct Cachesubf;
#line 24 "./../include/libg.h"
typedef struct Cachesubf Cachesubf;
#line 83 "./../include/libg.h"
struct Fontchar {
   short cwidth ;
   unsigned char top ;
   unsigned char bottom ;
   signed char left ;
   unsigned char width ;
};
#line 92 "./../include/libg.h"
struct Subfont {
   int minrow ;
   int mincol ;
   int minchar ;
   int maxchar ;
   int width ;
   int n ;
   unsigned char height ;
   char ascent ;
   Fontchar *info ;
   int id ;
};
#line 106 "./../include/libg.h"
struct Cachesubf {
   Rune min ;
   Rune max ;
   char *name ;
   Subfont *f ;
};
#line 114 "./../include/libg.h"
struct Font {
   char *name ;
   unsigned char height ;
   char ascent ;
   char width ;
   char ldepth ;
   short id ;
   unsigned short nsubf ;
   Cachesubf *subf ;
};
#line 3 "./../include/frame.h"
struct Frbox;
#line 3 "./../include/frame.h"
typedef struct Frbox Frbox;
#line 4
struct Frame;
#line 4 "./../include/frame.h"
typedef struct Frame Frame;
#line 6 "./../include/frame.h"
struct __anonstruct_b_33 {
   short bc ;
   short minwid ;
};
#line 6 "./../include/frame.h"
union __anonunion_a_32 {
   uchar *ptr ;
   struct __anonstruct_b_33 b ;
};
#line 6 "./../include/frame.h"
struct Frbox {
   long wid ;
   long nrune ;
   union __anonunion_a_32 a ;
};
#line 19 "./../include/frame.h"
struct Frame {
   Font___0 *font ;
   Bitmap *b ;
   Rectangle r ;
   Rectangle entire ;
   Frbox *box ;
   ulong p0 ;
   ulong p1 ;
   short left ;
   ushort nbox ;
   ushort nalloc ;
   ushort maxtab ;
   ushort nchars ;
   ushort nlines ;
   ushort maxlines ;
   ushort lastlinefull ;
   ushort modified ;
};
#line 154 "./../include/libg.h"
enum Fcode {
    Zero = 0,
    DnorS = 1,
    DandnotS = 2,
    notS = 3,
    notDandS = 4,
    notD = 5,
    DxorS = 6,
    DnandS = 7,
    DandS = 8,
    DxnorS = 9,
    D = 10,
    DornotS = 11,
    S = 12,
    notDorS = 13,
    DorS = 14,
    F = 15
} ;
#line 154 "./../include/libg.h"
typedef enum Fcode Fcode;
#line 22 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef char Path[4096];
#line 26
struct Scroll;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Scroll Scroll;
#line 30
struct Tile;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Tile Tile;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.h"
struct View {
   Rectangle r ;
   Text *t ;
   Frame f ;
   Range visible ;
   Range sel ;
   ulong anchor ;
   Scroll *scroll ;
   Tile *tile ;
   View *next ;
   Bool selecting ;
   Bool autoindent ;
};
#line 214 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
struct Cmd;
#line 214 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
typedef struct Cmd Cmd;
#line 215 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
struct Cmd {
   char *name ;
   void (*cmd)(View * , char * ) ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct stat Stat;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 19 "./../include/libg.h"
struct Mouse;
#line 19 "./../include/libg.h"
typedef struct Mouse Mouse;
#line 50 "./../include/libg.h"
struct Mouse {
   int buttons ;
   Point xy ;
   unsigned long msec ;
};
#line 18
struct Cursor;
#line 18 "./../include/libg.h"
typedef struct Cursor Cursor___0;
#line 57 "./../include/libg.h"
struct Cursor {
   Point offset ;
   unsigned char clr[32] ;
   unsigned char set[32] ;
   int id ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 4 "./../include/msg.h"
struct Msg;
#line 4 "./../include/msg.h"
typedef struct Msg Msg;
#line 5 "./../include/msg.h"
typedef int Id;
#line 18
enum Mtype {
    WEexec = 1,
    WEgoto = 2,
    WEdestroy = 4,
    WEreplace = 8,
    WEfencepost = 9,
    WRerror = 10,
    WMlist = 11,
    WRlist = 12,
    WMnew = 13,
    WRnew = 14,
    WMattach = 15,
    WRattach = 16,
    WMsetname = 17,
    WRsetname = 18,
    WMgetname = 19,
    WRgetname = 20,
    WMsettools = 21,
    WRsettools = 22,
    WMgettools = 23,
    WRgettools = 24,
    WMread = 25,
    WRread = 26,
    WMreplace = 27,
    WRreplace = 28,
    WMexec = 29,
    WRexec = 30,
    WMgoto = 31,
    WRgoto = 32,
    WMfencepost = 33
} ;
#line 18 "./../include/msg.h"
typedef enum Mtype Mtype;
#line 56 "./../include/msg.h"
struct Msg {
   Mtype t ;
   Id m ;
   Id w ;
   Range r ;
   ushort flag ;
   char *s ;
};
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
struct Mbuf;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef struct Mbuf Mbuf;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
struct Mbuf {
   char *buf ;
   int alloced ;
   int n ;
};
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.h"
struct Data {
   Text *t ;
   Text *tag ;
   Data *next ;
   Path label ;
   Path cachedlabel ;
   Bool has_stat ;
   Stat stat ;
   char *backupto ;
   int fd ;
   ushort emask ;
   Id id ;
   char **names ;
};
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
enum Ori {
    H = 0,
    V = 1
} ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
typedef enum Ori Ori;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
struct Tile {
   View *tag ;
   View *body ;
   int min ;
   int max ;
   int base ;
   Ori ori ;
   Bool ishidden ;
   Tile *up ;
   Tile *down ;
   Tile *left ;
   Tile *right ;
   int cmin ;
   int cmax ;
};
#line 25 "./../include/libg.h"
struct Event;
#line 25 "./../include/libg.h"
typedef struct Event Event;
#line 126 "./../include/libg.h"
struct Event {
   int kbdc ;
   Mouse mouse ;
   int n ;
   unsigned char data[8320] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 20 "./../include/libg.h"
struct Menu;
#line 20 "./../include/libg.h"
typedef struct Menu Menu;
#line 65 "./../include/libg.h"
struct Menu {
   char **item ;
   char *(*gen)(int  ) ;
   int lasthit ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
struct Key;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
typedef struct Key Key;
#line 12
enum Keytype {
    Kfree = 0,
    Klisten = 1,
    Kout = 2,
    Kmsg = 3
} ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
typedef enum Keytype Keytype;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
struct Key {
   Keytype t ;
   int fd ;
   ulong key ;
   Mbuf buf ;
   int pid ;
   Path cmd ;
   Path olabel ;
   View *v ;
   Bool first ;
};
#line 84 "./../include/msg.h"
struct Handle;
#line 84 "./../include/msg.h"
typedef struct Handle Handle;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
struct MsgQ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
typedef struct MsgQ MsgQ;
#line 15
struct MsgSet;
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
typedef struct MsgSet MsgSet;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
struct MsgQ {
   Msg msg[20] ;
   int read ;
   int write ;
};
#line 28 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
struct MsgSet {
   Msg msg[20] ;
   Bool inuse[20] ;
   int n ;
};
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
struct Handle {
   int fd ;
   char err[1024] ;
   Id id ;
   char *buf ;
   int n ;
   int alloced ;
   MsgQ event ;
   MsgSet reply ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 1076 "/usr/include/X11/Xlib.h"
struct __anonstruct_XChar2b_85 {
   unsigned char byte1 ;
   unsigned char byte2 ;
};
#line 1076 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XChar2b_85 XChar2b;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.h"
typedef Rune RPath[4096];
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_27 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_27 XGCValues;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_40 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_40 XRectangle;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
struct Undo {
   Undo *next ;
   Range r ;
   Rstring s ;
   ulong alloced ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
struct Pair;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
typedef struct Pair Pair;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
struct Pair {
   char *regex ;
   char *tools ;
};
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_37 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_37 XColor;
#line 64 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
typedef int (*SizeAdjust)(Tile * , int  );
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 26 "./../include/libg.h"
struct RGB;
#line 26 "./../include/libg.h"
typedef struct RGB RGB;
#line 134 "./../include/libg.h"
struct RGB {
   unsigned long red ;
   unsigned long green ;
   unsigned long blue ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 1865 "/usr/include/X11/Xlib.h"
typedef int (*XIOErrorHandler)(Display * );
#line 287 "/usr/include/X11/Xutil.h"
struct __anonstruct_XVisualInfo_116 {
   Visual *visual ;
   VisualID visualid ;
   int screen ;
   int depth ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int colormap_size ;
   int bits_per_rgb ;
};
#line 287 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XVisualInfo_116 XVisualInfo;
#line 326 "/usr/include/X11/Xresource.h"
enum __anonenum_XrmOptionKind_122 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
#line 326 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmOptionKind_122 XrmOptionKind;
#line 338 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmOptionDescRec_123 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_123 XrmOptionDescRec;
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_123 *XrmOptionDescList;
#line 116 "/usr/include/X11/Intrinsic.h"
typedef unsigned long XtIntervalId;
#line 117 "/usr/include/X11/Intrinsic.h"
typedef unsigned long XtInputId;
#line 322 "/usr/include/X11/Intrinsic.h"
typedef struct __anonstruct_Arg_127 Arg;
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
struct Ebuf {
   struct Ebuf *next ;
   int n ;
   unsigned char buf[2] ;
};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
typedef struct Ebuf Ebuf;
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
struct Esrc {
   int inuse ;
   int size ;
   int count ;
   Ebuf *head ;
   Ebuf *tail ;
   XtInputId id ;
};
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
typedef struct Esrc Esrc;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_39 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_39 XPoint;
#line 127 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
enum __anonenum_state_61 {
    Cancut = 1,
    Canpaste = 2
} ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
union __anonunion_r_64 {
   int rsid ;
   int rsubid ;
   int class ;
   struct Inst *rother ;
   struct Inst *rright ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
union __anonunion_l_65 {
   struct Inst *lleft ;
   struct Inst *lnext ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
struct Inst {
   long type ;
   union __anonunion_r_64 r ;
   union __anonunion_l_65 l ;
};
#line 46
struct Ilist;
#line 46 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
typedef struct Ilist Ilist;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
struct Ilist {
   Inst *inst ;
   samRangeset se ;
   Posn startp ;
};
#line 91
struct Node;
#line 91 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
typedef struct Node Node;
#line 92 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
struct Node {
   Inst *first ;
   Inst *last ;
};
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/latin1.c"
struct latin {
   unsigned short l ;
   unsigned char c[2] ;
};
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
struct Abbrev;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
typedef struct Abbrev Abbrev;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
struct Abbrev {
   Path env ;
   Stat buf ;
};
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
struct __anonstruct_pts_34 {
   Point pt0 ;
   Point pt1 ;
};
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
struct Scroll {
   Rectangle r ;
   Bitmap *b ;
   ulong thumb ;
   ulong extent ;
   ulong max ;
};
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
struct Linedesc {
   int x0 ;
   int y0 ;
   char xmajor ;
   char slopeneg ;
   long dminor ;
   long dmajor ;
};
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
typedef struct Linedesc Linedesc;
#line 1081 "/usr/include/X11/Xlib.h"
struct __anonstruct_XTextItem16_86 {
   XChar2b *chars ;
   int nchars ;
   int delta ;
   Font font ;
};
#line 1081 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XTextItem16_86 XTextItem16;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/bitbltclip.c"
struct bbcarg {
   Bitmap *dm ;
   Point p ;
   Bitmap *sm ;
   Rectangle r ;
   Fcode f ;
};
#line 193 "./../include/libg.h"
Bitmap *balloc(Rectangle r , int ldepth ) ;
#line 194
void bfree(Bitmap *b ) ;
#line 198
void berror(char *s ) ;
#line 220
void wrbitmap(Bitmap *b , int miny , int maxy , unsigned char *data ) ;
#line 223
Bitmap *rdbitmapfile(int fd ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdbitmapfile.c"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdbitmapfile.c"
Bitmap *rdbitmapfile(int fd ) 
{ 
  char hdr[61] ;
  unsigned char *data ;
  long dy ;
  long px ;
  unsigned long l ;
  unsigned long t___0 ;
  unsigned long n ;
  long miny ;
  long maxy ;
  Rectangle r ;
  int ld ;
  Bitmap *b ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 20
  tmp = (int )read(fd, hdr, 60);
  }
#line 20
  if (tmp != 60) {
    {
#line 21
    berror((char *)"rdbitmapfile read");
    }
  }
  {
#line 22
  ld = atoi((char const   *)(hdr + 0));
#line 23
  r.min.x = atoi((char const   *)(hdr + 12));
#line 24
  r.min.y = atoi((char const   *)(hdr + 24));
#line 25
  r.max.x = atoi((char const   *)(hdr + 36));
#line 26
  r.max.y = atoi((char const   *)(hdr + 48));
  }
#line 27
  if (ld < 0) {
    {
#line 28
    berror((char *)"rdbitmapfile ldepth");
    }
  } else
#line 27
  if (ld > 1) {
    {
#line 28
    berror((char *)"rdbitmapfile ldepth");
    }
  }
#line 29
  if (r.min.x > r.max.x) {
    {
#line 30
    berror((char *)"rdbitmapfile rectangle");
    }
  } else
#line 29
  if (r.min.y > r.max.y) {
    {
#line 30
    berror((char *)"rdbitmapfile rectangle");
    }
  }
#line 32
  miny = (long )r.min.y;
#line 33
  maxy = (long )r.max.y;
#line 34
  px = (long )(1 << (3 - ld));
#line 36
  if (r.min.x >= 0) {
#line 37
    l = (unsigned long )((((long )r.max.x + px) - 1L) / px - (long )r.min.x / px);
  } else {
#line 39
    t___0 = (unsigned long )(((long )(- r.min.x) + px) - 1L);
#line 40
    t___0 = (t___0 / (unsigned long )px) * (unsigned long )px;
#line 41
    l = (((t___0 + (unsigned long )r.max.x) + (unsigned long )px) - 1UL) / (unsigned long )px;
  }
  {
#line 43
  b = balloc(r, ld);
  }
#line 44
  if ((unsigned long )b == (unsigned long )((Bitmap *)0)) {
#line 45
    return ((Bitmap *)0);
  }
  {
#line 46
  tmp___0 = malloc((size_t )6000);
#line 46
  data = (unsigned char *)tmp___0;
  }
#line 47
  if ((unsigned long )data == (unsigned long )((unsigned char *)0)) {
    {
#line 48
    berror((char *)"rdbitmapfile malloc");
    }
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (maxy > miny)) {
#line 49
      goto while_break;
    }
#line 50
    dy = maxy - miny;
#line 51
    if ((unsigned long )dy * l > 6000UL) {
#line 52
      dy = (long )(6000UL / l);
    }
    {
#line 53
    n = (unsigned long )dy * l;
#line 54
    tmp___1 = (int )read(fd, data, n);
    }
#line 54
    if ((unsigned long )tmp___1 != n) {
      {
#line 55
      free((void *)data);
#line 56
      bfree(b);
#line 57
      berror((char *)"rdbitmapfile read");
      }
    }
    {
#line 59
    wrbitmap(b, (int )miny, (int )(miny + dy), data);
#line 60
    miny += dy;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  free((void *)data);
  }
#line 63
  return (b);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 1435 "/usr/include/X11/Xlib.h"
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 2578
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 500 "/usr/include/X11/Intrinsic.h"
extern Boolean XtConvertAndStore(Widget  , char const   * , XrmValue * , char const   * ,
                                 XrmValue * ) ;
#line 569
extern Boolean XtOwnSelection(Widget  , Atom  , Time  , Boolean (*)(Widget  , Atom * ,
                                                                    Atom * , Atom * ,
                                                                    XtPointer * ,
                                                                    unsigned long * ,
                                                                    int * ) , void (*)(Widget  ,
                                                                                       Atom * ) ,
                              void (*)(Widget  , Atom * , Atom * ) ) ;
#line 787
extern void XtTranslateKeycode(Display * , KeyCode  , Modifiers  , Modifiers * , KeySym * ) ;
#line 937
extern void XtAppProcessEvent(XtAppContext  , XtInputMask  ) ;
#line 955
extern void XtSetKeyboardFocus(Widget  , Widget  ) ;
#line 968
extern Time XtLastTimestampProcessed(Display * ) ;
#line 1210
extern Window XtWindowOfObject(Widget  ) ;
#line 1534
extern XtAppContext XtWidgetToApplicationContext(Widget  ) ;
#line 1840
extern char *XtMalloc(Cardinal  ) ;
#line 1854
extern void XtFree(char * ) ;
#line 2019
extern void XtGetSelectionValue(Widget  , Atom  , Atom  , void (*)(Widget  , XtPointer  ,
                                                                   Atom * , Atom * ,
                                                                   XtPointer  , unsigned long * ,
                                                                   int * ) , XtPointer  ,
                                Time  ) ;
#line 164 "/usr/include/X11/CoreP.h"
extern WidgetClassRec widgetClassRec ;
#line 269 "/usr/include/X11/IntrinsicP.h"
extern void _XtInherit(void) ;
#line 279
extern void XtCreateWindow(Widget  , unsigned int  , Visual * , XtValueMask  , XSetWindowAttributes * ) ;
#line 316 "/usr/include/X11/StringDefs.h"
extern char const   XtStrings[] ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/Gwin.h"
WidgetClass gwinWidgetClass ;
#line 43
String GwinSelectionSwap(Widget w , String s ) ;
#line 44
char *Gwinselect_get(Widget w ) ;
#line 45
void Gwinselect_put(Widget w , char *s ) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/GwinP.h"
GwinClassRec gwinClassRec ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Realize(Widget w , XtValueMask *valueMask , XSetWindowAttributes *attrs ) ;
#line 21
static void Resize(Widget w ) ;
#line 22
static void Redraw(Widget w , XEvent *e , Region r ) ;
#line 23
static void Mappingaction(Widget w , XEvent *e , String *p , Cardinal *np ) ;
#line 24
static void Keyaction(Widget w , XEvent *e , String *p , Cardinal *np ) ;
#line 25
static void Mouseaction(Widget w , XEvent *e , String *p , Cardinal *np ) ;
#line 26
static String SelectSwap(Widget w , String s ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static XtResource resources[10]  = 
#line 32
  {      {(char *)(& XtStrings[214]), (char *)(& XtStrings[1022]), (char *)(& XtStrings[1754]),
      (Cardinal )sizeof(Pixel ), (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.foreground)),
      (char *)(& XtStrings[1797]), (XtPointer )"XtDefaultForeground"}, 
        {(char *)(& XtStrings[199]), (char *)(& XtStrings[1017]), (char *)(& XtStrings[1666]),
      (Cardinal )sizeof(XFontStruct *), (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.font)),
      (char *)(& XtStrings[1797]), (XtPointer )"XtDefaultFont"}, 
        {(String )"scrollForwardR", (String )"ScrollForwardR", (char *)(& XtStrings[1561]),
      (Cardinal )sizeof(Boolean ), (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.forwardr)),
      (char *)(& XtStrings[1695]), (XtPointer )1}, 
        {(String )"reshaped", (String )"Reshaped", (char *)(& XtStrings[1677]), (Cardinal )sizeof(void (*)(int  ,
                                                                                                        int  ,
                                                                                                        int  ,
                                                                                                        int  )),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.reshaped)), (char *)(& XtStrings[1677]),
      (void *)0}, 
        {(String )"gotchar", (String )"Gotchar", (char *)(& XtStrings[1677]), (Cardinal )sizeof(void (*)(int  )),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.gotchar)), (char *)(& XtStrings[1677]),
      (void *)0}, 
        {(String )"gotmouse", (String )"Gotmouse", (char *)(& XtStrings[1677]), (Cardinal )sizeof(void (*)(Gwinmouse * )),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.gotmouse)), (char *)(& XtStrings[1677]),
      (void *)0}, 
        {(char *)(& XtStrings[686]), (char *)(& XtStrings[1375]), (char *)(& XtStrings[1797]),
      (Cardinal )sizeof(String ), (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.selection)),
      (char *)(& XtStrings[1797]), (void *)0}, 
        {(String )"p9font", (String )"P9font", (char *)(& XtStrings[1797]), (Cardinal )sizeof(String ),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.p9font)), (char *)(& XtStrings[1797]),
      (void *)0}, 
        {(String )"p9fixed", (String )"P9fixed", (char *)(& XtStrings[1797]), (Cardinal )sizeof(String ),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.p9fixed)), (char *)(& XtStrings[1797]),
      (void *)0}, 
        {(String )"composeMod", (String )"ComposeMod", (char *)(& XtStrings[1718]), (Cardinal )sizeof(int ),
      (Cardinal )((unsigned long )(& ((GwinRec *)0)->gwin.compose)), (char *)(& XtStrings[1695]),
      (XtPointer )0}};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static XtActionsRec actions[3]  = {      {(String )"key", & Keyaction}, 
        {(String )"mouse", & Mouseaction}, 
        {(String )"mapping", & Mappingaction}};
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static char tms[103]  = 
#line 62
  {      (char )'<',      (char )'K',      (char )'e',      (char )'y', 
        (char )'>',      (char )' ',      (char )':',      (char )' ', 
        (char )'k',      (char )'e',      (char )'y',      (char )'(', 
        (char )')',      (char )' ',      (char )'\n',      (char )'\t', 
        (char )'<',      (char )'M',      (char )'o',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'>', 
        (char )' ',      (char )':',      (char )' ',      (char )'m', 
        (char )'o',      (char )'u',      (char )'s',      (char )'e', 
        (char )'(',      (char )')',      (char )' ',      (char )'\n', 
        (char )'\t',      (char )'<',      (char )'B',      (char )'t', 
        (char )'n',      (char )'D',      (char )'o',      (char )'w', 
        (char )'n',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'m',      (char )'o',      (char )'u', 
        (char )'s',      (char )'e',      (char )'(',      (char )')', 
        (char )' ',      (char )'\n',      (char )'\t',      (char )'<', 
        (char )'B',      (char )'t',      (char )'n',      (char )'U', 
        (char )'p',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'m',      (char )'o',      (char )'u', 
        (char )'s',      (char )'e',      (char )'(',      (char )')', 
        (char )' ',      (char )'\n',      (char )'\t',      (char )'<', 
        (char )'M',      (char )'a',      (char )'p',      (char )'p', 
        (char )'i',      (char )'n',      (char )'g',      (char )'>', 
        (char )' ',      (char )':',      (char )' ',      (char )'m', 
        (char )'a',      (char )'p',      (char )'p',      (char )'i', 
        (char )'n',      (char )'g',      (char )'(',      (char )')', 
        (char )' ',      (char )'\n',      (char )'\000'};
#line 71 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
GwinClassRec gwinClassRec  =    {{& widgetClassRec, (String )"Gwin", (Cardinal )sizeof(GwinRec ), (void (*)(void))((void *)0),
     (void (*)(WidgetClass  ))((void *)0), (XtEnum )0, (void (*)(Widget  , Widget  ,
                                                                 ArgList  , Cardinal * ))((void *)0),
     (void (*)(Widget  , ArgList  , Cardinal * ))((void *)0), & Realize, actions,
     (Cardinal )(sizeof(actions) / sizeof(actions[0])), resources, (Cardinal )(sizeof(resources) / sizeof(resources[0])),
     0, (Boolean )1, (XtEnum )2, (Boolean )1, (Boolean )0, (void (*)(Widget  ))((void *)0),
     & Resize, & Redraw, (Boolean (*)(Widget  , Widget  , Widget  , ArgList  , Cardinal * ))((void *)0),
     (Boolean (*)(Widget  , ArgList  , Cardinal * ))((void *)0), (void (*)(Widget  ,
                                                                           Widget  ,
                                                                           XtWidgetGeometry * ,
                                                                           XtWidgetGeometry * ))(& _XtInherit),
     (void (*)(Widget  , ArgList  , Cardinal * ))((void *)0), (Boolean (*)(Widget  ,
                                                                           Time * ))(& _XtInherit),
     (XtVersionType )11006, (void *)0, tms, (XtGeometryResult (*)(Widget  , XtWidgetGeometry * ,
                                                                  XtWidgetGeometry * ))(& _XtInherit),
     (void (*)(Widget  , String  ))((void *)0), (void *)0}, {& SelectSwap, (void *)0}};
#line 114 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
WidgetClass gwinWidgetClass  =    (WidgetClass )(& gwinClassRec);
#line 116 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static XModifierKeymap *modmap  ;
#line 117 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static int keypermod  ;
#line 119 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Realize(Widget w , XtValueMask *valueMask , XSetWindowAttributes *attrs ) 
{ 


  {
  {
#line 124
  *valueMask |= (unsigned long )(1L << 6);
#line 125
  attrs->backing_store = 2;
#line 127
  XtCreateWindow(w, 1U, (Visual *)0, *valueMask, attrs);
#line 128
  XtSetKeyboardFocus(w->core.parent, w);
#line 129
  modmap = XGetModifierMapping((w->core.screen)->display);
  }
#line 129
  if (modmap) {
#line 130
    keypermod = modmap->max_keypermod;
  }
  {
#line 132
  Resize(w);
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Resize(Widget w ) 
{ 
  Window tmp ;

  {
  {
#line 138
  tmp = XtWindowOfObject(w);
  }
#line 138
  if (tmp != 0UL) {
    {
#line 139
    (*((w->core.widget_class)->core_class.expose))(w, (XEvent *)((void *)0), (Region )((void *)0));
    }
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Redraw(Widget w , XEvent *e , Region r ) 
{ 
  void (*f)(int  , int  , int  , int  ) ;

  {
#line 147
  f = ((GwinWidget )w)->gwin.reshaped;
#line 148
  if (f) {
    {
#line 149
    (*f)((int )w->core.x, (int )w->core.y, (int )w->core.x + (int )w->core.width,
         (int )w->core.y + (int )w->core.height);
    }
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Mappingaction(Widget w , XEvent *e , String *p , Cardinal *np ) 
{ 


  {
#line 156
  if (modmap) {
    {
#line 157
    XFreeModifiermap(modmap);
    }
  }
  {
#line 158
  modmap = XGetModifierMapping(e->xany.display);
  }
#line 159
  if (modmap) {
#line 160
    keypermod = modmap->max_keypermod;
  }
#line 161
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static unsigned char compose[5]  ;
#line 173 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static int composing  =    -2;
#line 295
long unicode(unsigned char *k ) ;
#line 303
long latin1(unsigned char *k ) ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Keyaction(Widget w , XEvent *e , String *p , Cardinal *np ) 
{ 
  int c ;
  int minmod ;
  KeySym k ;
  KeySym mk ;
  void (*f)(int  ) ;
  Modifiers md ;
  int tmp ;
  int tmp___0 ;

  {
#line 185
  if (e->xany.type != 2) {
#line 186
    return;
  }
  {
#line 187
  XtTranslateKeycode(e->xany.display, (KeyCode )e->xkey.keycode, e->xkey.state, & md,
                     & k);
  }
#line 195
  if (k >= 65505UL) {
#line 195
    if (k <= 65518UL) {
#line 195
      goto _L;
    } else {
#line 195
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 195
  if (k >= 65025UL) {
#line 195
    if (k <= 65043UL) {
#line 195
      goto _L;
    } else {
#line 195
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 195
  if (k == 65406UL) {
#line 195
    goto _L;
  } else
#line 195
  if (k == 65407UL) {
    _L: /* CIL Label */ 
#line 195
    if (((GwinWidget )w)->gwin.compose) {
#line 195
      if (composing == -2) {
#line 195
        if (modmap) {
#line 197
          minmod = (((GwinWidget )w)->gwin.compose + 2) * keypermod;
#line 198
          c = minmod;
          {
#line 198
          while (1) {
            while_continue: /* CIL Label */ ;
#line 198
            if (! (c < minmod + keypermod)) {
#line 198
              goto while_break;
            }
            {
#line 199
            XtTranslateKeycode(e->xany.display, *(modmap->modifiermap + c), e->xkey.state,
                               & md, & mk);
            }
#line 202
            if (k == mk) {
#line 203
              composing = -1;
#line 204
              goto while_break;
            }
#line 198
            c ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 207
          return;
        }
      }
    }
  }
#line 210
  if (k == 65312UL) {
#line 211
    composing = -1;
#line 212
    return;
  }
#line 214
  if (k == 0UL) {
#line 215
    return;
  }
#line 216
  if (k & 65280UL) {
    {
#line 236
    if (k == 65454UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65451UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65453UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65450UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65455UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65465UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65464UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65463UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65462UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65461UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65460UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65459UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65458UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65457UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65456UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65535UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65307UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65289UL) {
#line 236
      goto case_65454;
    }
#line 236
    if (k == 65288UL) {
#line 236
      goto case_65454;
    }
#line 239
    if (k == 65290UL) {
#line 239
      goto case_65290;
    }
#line 243
    if (k == 65293UL) {
#line 243
      goto case_65293;
    }
#line 243
    if (k == 65421UL) {
#line 243
      goto case_65293;
    }
#line 246
    if (k == 65366UL) {
#line 246
      goto case_65366;
    }
#line 249
    if (k == 65365UL) {
#line 249
      goto case_65365;
    }
#line 252
    if (k == 65361UL) {
#line 252
      goto case_65361;
    }
#line 255
    if (k == 65363UL) {
#line 255
      goto case_65363;
    }
#line 258
    if (k == 65364UL) {
#line 258
      goto case_65364;
    }
#line 261
    if (k == 65362UL) {
#line 261
      goto case_65362;
    }
#line 264
    if (k == 65360UL) {
#line 264
      goto case_65360;
    }
#line 267
    if (k == 65367UL) {
#line 267
      goto case_65367;
    }
#line 270
    goto switch_default;
    case_65454: /* CIL Label */ 
    case_65451: /* CIL Label */ 
    case_65453: /* CIL Label */ 
    case_65450: /* CIL Label */ 
    case_65455: /* CIL Label */ 
    case_65465: /* CIL Label */ 
    case_65464: /* CIL Label */ 
    case_65463: /* CIL Label */ 
    case_65462: /* CIL Label */ 
    case_65461: /* CIL Label */ 
    case_65460: /* CIL Label */ 
    case_65459: /* CIL Label */ 
    case_65458: /* CIL Label */ 
    case_65457: /* CIL Label */ 
    case_65456: /* CIL Label */ 
    case_65535: /* CIL Label */ 
    case_65307: /* CIL Label */ 
    case_65289: /* CIL Label */ 
    case_65288: /* CIL Label */ 
#line 237
    k &= 127UL;
#line 238
    goto switch_break;
    case_65290: /* CIL Label */ 
#line 240
    k = (KeySym )'\r';
#line 241
    goto switch_break;
    case_65293: /* CIL Label */ 
    case_65421: /* CIL Label */ 
#line 244
    k = (KeySym )'\n';
#line 245
    goto switch_break;
    case_65366: /* CIL Label */ 
#line 247
    k = (KeySym )128;
#line 248
    goto switch_break;
    case_65365: /* CIL Label */ 
#line 250
    k = (KeySym )129;
#line 251
    goto switch_break;
    case_65361: /* CIL Label */ 
#line 253
    k = (KeySym )130;
#line 254
    goto switch_break;
    case_65363: /* CIL Label */ 
#line 256
    k = (KeySym )131;
#line 257
    goto switch_break;
    case_65364: /* CIL Label */ 
#line 259
    k = (KeySym )132;
#line 260
    goto switch_break;
    case_65362: /* CIL Label */ 
#line 262
    k = (KeySym )133;
#line 263
    goto switch_break;
    case_65360: /* CIL Label */ 
#line 265
    k = (KeySym )134;
#line 266
    goto switch_break;
    case_65367: /* CIL Label */ 
#line 268
    k = (KeySym )135;
#line 269
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 271
    return;
    switch_break: /* CIL Label */ ;
    }
  }
#line 275
  if (k == 173UL) {
#line 276
    k = (KeySym )45;
  }
#line 278
  if (e->xkey.state & (unsigned int )(1 << 2)) {
#line 278
    if (! (md & (unsigned int )(1 << 2))) {
#line 279
      k &= 159UL;
    }
  }
#line 280
  if (k == 0UL) {
#line 281
    return;
  }
#line 283
  if (! ((GwinWidget )w)->gwin.compose) {
#line 283
    if (e->xkey.state & (unsigned int )(1 << 3)) {
#line 283
      if (composing == -2) {
#line 285
        composing = -1;
      }
    }
  }
#line 286
  if (composing > -2) {
#line 287
    composing ++;
#line 287
    compose[composing] = (unsigned char )k;
#line 288
    if ((int )compose[0] == 88) {
#line 288
      if (composing > 0) {
#line 289
        if (k < 48UL) {
#line 289
          goto _L___2;
        } else
#line 289
        if (k > 102UL) {
#line 289
          goto _L___2;
        } else
#line 289
        if (k > 57UL) {
#line 289
          if (k < 97UL) {
            _L___2: /* CIL Label */ 
#line 291
            f = ((GwinWidget )w)->gwin.gotchar;
#line 291
            if (f) {
#line 291
              c = 0;
              {
#line 291
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 291
                if (! (c < composing)) {
#line 291
                  goto while_break___0;
                }
                {
#line 291
                (*f)((int )compose[c]);
#line 291
                c ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
            }
#line 292
            c = (int )((unsigned short )k);
#line 293
            composing = -2;
          } else {
#line 289
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 294
        if (composing == 4) {
          {
#line 295
          tmp = (int )unicode(compose);
#line 295
          c = tmp;
          }
#line 296
          if (c == -1) {
#line 297
            f = ((GwinWidget )w)->gwin.gotchar;
#line 297
            if (f) {
#line 297
              c = 0;
              {
#line 297
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 297
                if (! (c < composing)) {
#line 297
                  goto while_break___1;
                }
                {
#line 297
                (*f)((int )compose[c]);
#line 297
                c ++;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 298
            c = (int )((unsigned short )compose[4]);
          }
#line 300
          composing = -2;
        }
      } else {
#line 288
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 302
    if (composing == 1) {
      {
#line 303
      tmp___0 = (int )latin1(compose);
#line 303
      c = tmp___0;
      }
#line 304
      if (c == -1) {
#line 305
        f = ((GwinWidget )w)->gwin.gotchar;
#line 305
        if (f) {
#line 305
          c = 0;
          {
#line 305
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 305
            if (! (c < composing)) {
#line 305
              goto while_break___2;
            }
            {
#line 305
            (*f)((int )compose[c]);
#line 305
            c ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 306
        c = (int )((unsigned short )compose[1]);
      }
#line 308
      composing = -2;
    }
  } else {
#line 311
    if (composing >= 0) {
#line 312
      composing ++;
#line 313
      f = ((GwinWidget )w)->gwin.gotchar;
#line 313
      if (f) {
#line 313
        c = 0;
        {
#line 313
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 313
          if (! (c < composing)) {
#line 313
            goto while_break___3;
          }
          {
#line 313
          (*f)((int )compose[c]);
#line 313
          c ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 315
    c = (int )((unsigned short )k);
#line 316
    composing = -2;
  }
#line 319
  if (composing >= -1) {
#line 320
    return;
  }
#line 322
  f = ((GwinWidget )w)->gwin.gotchar;
#line 323
  if (f) {
    {
#line 324
    (*f)(c);
    }
  }
#line 325
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void LoseSel(Widget w , Atom *sel___0 ) 
{ 
  GwinWidget gw ;

  {
#line 330
  gw = (GwinWidget )w;
#line 332
  if (gw->gwin.selection) {
    {
#line 333
    XtFree(gw->gwin.selection);
#line 334
    gw->gwin.selection = (String )0;
    }
  }
#line 336
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void Mouseaction(Widget w , XEvent *e , String *p , Cardinal *np ) 
{ 
  int s ;
  XButtonEvent *be ;
  XMotionEvent *me ;
  Gwinmouse m ;
  void (*f)(Gwinmouse * ) ;

  {
  {
#line 348
  if (e->type == 4) {
#line 348
    goto case_4;
  }
#line 360
  if (e->type == 5) {
#line 360
    goto case_5;
  }
#line 372
  if (e->type == 6) {
#line 372
    goto case_6;
  }
#line 379
  goto switch_default;
  case_4: /* CIL Label */ 
#line 349
  be = (XButtonEvent *)e;
#line 350
  m.xy.x = be->x;
#line 351
  m.xy.y = be->y;
#line 352
  m.msec = be->time;
#line 353
  s = (int )be->state;
  {
#line 355
  if (be->button == 1U) {
#line 355
    goto case_1;
  }
#line 356
  if (be->button == 2U) {
#line 356
    goto case_2;
  }
#line 357
  if (be->button == 3U) {
#line 357
    goto case_3;
  }
#line 354
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 355
  s |= 1 << 8;
#line 355
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 356
  s |= 1 << 9;
#line 356
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 357
  s |= 1 << 10;
#line 357
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 359
  goto switch_break;
  case_5: /* CIL Label */ 
#line 361
  be = (XButtonEvent *)e;
#line 362
  m.xy.x = be->x;
#line 363
  m.xy.y = be->y;
#line 364
  m.msec = be->time;
#line 365
  s = (int )be->state;
  {
#line 367
  if (be->button == 1U) {
#line 367
    goto case_1___0;
  }
#line 368
  if (be->button == 2U) {
#line 368
    goto case_2___0;
  }
#line 369
  if (be->button == 3U) {
#line 369
    goto case_3___0;
  }
#line 366
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
#line 367
  s &= ~ (1 << 8);
#line 367
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
#line 368
  s &= ~ (1 << 9);
#line 368
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
#line 369
  s &= ~ (1 << 10);
#line 369
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 371
  goto switch_break;
  case_6: /* CIL Label */ 
#line 373
  me = (XMotionEvent *)e;
#line 374
  s = (int )me->state;
#line 375
  m.xy.x = me->x;
#line 376
  m.xy.y = me->y;
#line 377
  m.msec = me->time;
#line 378
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 380
  return;
  switch_break: /* CIL Label */ ;
  }
#line 382
  m.buttons = 0;
#line 383
  if (s & (1 << 8)) {
#line 383
    m.buttons |= 1;
  }
#line 384
  if (s & (1 << 9)) {
#line 384
    m.buttons |= 2;
  }
#line 385
  if (s & (1 << 10)) {
#line 385
    m.buttons |= 4;
  }
#line 386
  f = ((GwinWidget )w)->gwin.gotmouse;
#line 387
  if (f) {
    {
#line 388
    (*f)(& m);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void SelCallback(Widget w , XtPointer cldata , Atom *sel___0 , Atom *seltype ,
                        XtPointer val , unsigned long *len , int *fmt ) 
{ 
  String s ;
  int n ;
  GwinWidget gw ;
  char *tmp ;

  {
#line 397
  gw = (GwinWidget )w;
#line 399
  if (gw->gwin.selection) {
    {
#line 400
    XtFree(gw->gwin.selection);
    }
  }
#line 401
  if (*seltype != 31UL) {
#line 402
    n = 0;
  } else {
#line 404
    n = (int )(*len * (unsigned long )(*fmt / 8));
  }
  {
#line 405
  tmp = XtMalloc((Cardinal )(n + 1));
#line 405
  s = tmp;
  }
#line 406
  if (n > 0) {
    {
#line 407
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)((char *)val),
           (size_t )n);
    }
  }
  {
#line 408
  *(s + n) = (char)0;
#line 409
  gw->gwin.selection = s;
#line 410
  XtFree((char *)val);
  }
#line 411
  return;
}
}
#line 418
static Boolean SendSel(Widget w , Atom *sel___0 , Atom *target , Atom *rtype , XtPointer *ans ,
                       unsigned long *anslen , int *ansfmt ) ;
#line 418 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static Atom targets  =    (Atom )0;
#line 413 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static Boolean SendSel(Widget w , Atom *sel___0 , Atom *target , Atom *rtype , XtPointer *ans ,
                       unsigned long *anslen , int *ansfmt ) 
{ 
  GwinWidget gw ;
  XrmValue src ;
  XrmValue dst ;
  char *s ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 417
  gw = (GwinWidget )w;
#line 422
  if (*target == 31UL) {
#line 423
    s = gw->gwin.selection;
#line 424
    if (! s) {
#line 425
      s = (char *)"";
    }
#line 426
    *rtype = (Atom )31;
#line 427
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
#line 427
      tmp = strlen((char const   *)s);
#line 427
      tmp___0 = XtMalloc((unsigned int )tmp + 1U);
#line 427
      tmp___1 = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)s);
#line 427
      tmp___2 = tmp___1;
      }
    } else {
#line 427
      tmp___2 = (char *)((void *)0);
    }
    {
#line 427
    *ans = (XtPointer )tmp___2;
#line 428
    *anslen = strlen((char const   *)*ans);
#line 429
    *ansfmt = 8;
    }
#line 430
    return ((Boolean )1);
  }
#line 433
  if (targets == 0UL) {
    {
#line 434
    src.addr = (XPointer )"TARGETS";
#line 435
    tmp___3 = strlen((char const   *)src.addr);
#line 435
    src.size = (unsigned int )(tmp___3 + 1UL);
#line 436
    dst.size = (unsigned int )sizeof(Atom );
#line 437
    dst.addr = (XPointer )((XtPointer )(& targets));
#line 438
    XtConvertAndStore(w, (char const   *)((char *)(& XtStrings[1797])), & src, (char const   *)((char *)(& XtStrings[1544])),
                      & dst);
    }
  }
#line 440
  if (*target == targets) {
    {
#line 441
    *rtype = (Atom )4;
#line 442
    tmp___4 = XtMalloc((unsigned int )sizeof(Atom ));
#line 442
    *ans = (XtPointer )((Atom *)tmp___4);
#line 443
    *((Atom *)*ans) = (Atom )31;
#line 444
    *anslen = 1UL;
#line 445
    *ansfmt = 32;
    }
#line 446
    return ((Boolean )1);
  }
#line 449
  return ((Boolean )0);
}
}
#line 452 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static String SelectSwap(Widget w , String s ) 
{ 
  GwinWidget gw ;
  String ans ;
  Time tmp ;
  XtAppContext tmp___0 ;
  size_t tmp___1 ;
  Time tmp___2 ;

  {
#line 458
  gw = (GwinWidget )w;
#line 460
  if (! gw->gwin.selection) {
    {
#line 465
    tmp = XtLastTimestampProcessed((w->core.screen)->display);
#line 465
    XtGetSelectionValue(w, (Atom )1, (Atom )31, & SelCallback, (XtPointer )0, tmp);
    }
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      if (! ((unsigned long )gw->gwin.selection == (unsigned long )((String )0))) {
#line 468
        goto while_break;
      }
      {
#line 469
      tmp___0 = XtWidgetToApplicationContext(w);
#line 469
      XtAppProcessEvent(tmp___0, (XtInputMask )15);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 471
  ans = gw->gwin.selection;
#line 472
  tmp___1 = strlen((char const   *)s);
#line 472
  gw->gwin.selection = XtMalloc((Cardinal )(tmp___1 + 1UL));
#line 473
  strcpy((char */* __restrict  */)gw->gwin.selection, (char const   */* __restrict  */)s);
#line 477
  tmp___2 = XtLastTimestampProcessed((w->core.screen)->display);
#line 477
  XtOwnSelection(w, (Atom )1, tmp___2, & SendSel, & LoseSel, (void (*)(Widget  , Atom * ,
                                                                       Atom * ))((void *)0));
  }
#line 480
  return (ans);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
String GwinSelectionSwap(Widget w , String s ) 
{ 
  String tmp ;

  {
  {
#line 488
  tmp = (*(((GwinWidgetClass )w->core.widget_class)->gwin_class.select_swap))(w, s);
  }
#line 488
  return (tmp);
}
}
#line 491 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void own_selection(Widget w ) 
{ 
  Time tmp ;

  {
  {
#line 497
  tmp = XtLastTimestampProcessed((w->core.screen)->display);
#line 497
  XtOwnSelection(w, (Atom )1, tmp, & SendSel, & LoseSel, (void (*)(Widget  , Atom * ,
                                                                   Atom * ))((void *)0));
  }
#line 500
  return;
}
}
#line 502 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
static void get_selection(Widget w ) 
{ 
  Time tmp ;

  {
  {
#line 509
  tmp = XtLastTimestampProcessed((w->core.screen)->display);
#line 509
  XtGetSelectionValue(w, (Atom )1, (Atom )31, & SelCallback, (XtPointer )0, tmp);
  }
#line 512
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
char *Gwinselect_get(Widget w ) 
{ 
  GwinWidget gw ;
  XtAppContext tmp ;

  {
#line 520
  gw = (GwinWidget )w;
#line 522
  if (! gw->gwin.selection) {
    {
#line 523
    get_selection(w);
    }
    {
#line 524
    while (1) {
      while_continue: /* CIL Label */ ;
#line 524
      if (! ((unsigned long )gw->gwin.selection == (unsigned long )((String )0))) {
#line 524
        goto while_break;
      }
      {
#line 525
      tmp = XtWidgetToApplicationContext(w);
#line 525
      XtAppProcessEvent(tmp, (XtInputMask )15);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 527
  own_selection(w);
  }
#line 528
  return (gw->gwin.selection);
}
}
#line 532 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gwin.c"
void Gwinselect_put(Widget w , char *s ) 
{ 
  GwinWidget gw ;
  size_t tmp ;

  {
#line 535
  gw = (GwinWidget )w;
#line 536
  if (gw->gwin.selection) {
    {
#line 537
    XtFree(gw->gwin.selection);
    }
  }
  {
#line 538
  tmp = strlen((char const   *)s);
#line 538
  gw->gwin.selection = XtMalloc((Cardinal )(tmp + 1UL));
#line 539
  strcpy((char */* __restrict  */)gw->gwin.selection, (char const   */* __restrict  */)s);
#line 540
  own_selection(w);
  }
#line 541
  return;
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 117 "./../include/msg.h"
void *srealloc(void *orig , int size ) ;
#line 121
Range range(ulong p0 , ulong p1 ) ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Bool text_regexp(Text *t___0 , Rstring re , Range *r , Bool fwd ) ;
#line 102
Bool text_utfregexp(Text *t___0 , char *re , Range *r , Bool fwd ) ;
#line 103
long Tchars(Text *t___0 , Rune *buf___3 , ulong p0 , ulong p1 ) ;
#line 141
void text_copy(Text *t___0 , Range r , Rune *buf___3 ) ;
#line 221
ulong utftotext(Rune *r , char *s1 , char *s2 ) ;
#line 106 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
int bexecute(File *f , Posn startp ) ;
#line 107
void compile(String___0 *s ) ;
#line 108
int execute(File *f , Posn startp , Posn eof ) ;
#line 110
void error_c(Err e , int c ) ;
#line 111
void panic(char *str___1 ) ;
#line 112
void Strduplstr(String___0 *s0 , String___0 *s1 ) ;
#line 113
int Strcmp(String___0 *s0 , String___0 *s1 ) ;
#line 114
void Strzero(String___0 *s ) ;
#line 115
void samerror(Err e ) ;
#line 117
samRangeset sel ;
#line 118
Inst *startinst ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static jmp_buf regexp_state  ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static char *errs[7]  = {      (char *)"Etoolong",      (char *)"Eleftpar",      (char *)"Erightpar",      (char *)"Emissop", 
        (char *)"Ebadregexp",      (char *)"Ebadclass",      (char *)"Eoverflow"};
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void Finit(File *f , Text *t___0 , Range *r ) 
{ 


  {
#line 29
  f->t = t___0;
#line 30
  f->nrunes = (Posn )t___0->length;
#line 31
  f->dot.r.p1 = (Posn )r->p0;
#line 32
  f->dot.r.w2 = (Posn )r->p1;
#line 33
  f->dot.f = f;
#line 34
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static int do_compile(String___0 *s ) 
{ 


  {
  {
#line 43
  compile(s);
  }
#line 44
  return ((unsigned long )startinst == (unsigned long )((Inst *)0));
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void panic(char *str___1 ) 
{ 


  {
  {
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"panic:%s\n",
          str___1);
#line 51
  exit(1);
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void samerror(Err e ) 
{ 


  {
  {
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"regexp error: %s\n",
          errs[e]);
#line 58
  longjmp((struct __jmp_buf_tag *)(regexp_state), 1);
  }
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void Strduplstr(String___0 *s0 , String___0 *s1 ) 
{ 
  ulong n ;
  void *tmp ;

  {
#line 66
  n = (ulong )s1->n;
#line 67
  if (s0->n < s1->n) {
    {
#line 68
    tmp = srealloc((void *)s0->s, (int )(n * 2UL));
#line 68
    s0->s = (Rune *)tmp;
    }
  }
  {
#line 69
  s0->n = s1->n;
#line 70
  memcpy((void */* __restrict  */)s0->s, (void const   */* __restrict  */)s1->s, n);
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
int Strcmp(String___0 *s0 , String___0 *s1 ) 
{ 
  Rune *i ;
  Rune *j ;

  {
#line 78
  if (! s0->s) {
#line 79
    return (1);
  } else
#line 78
  if (! s1->s) {
#line 79
    return (1);
  }
#line 80
  i = s0->s;
#line 80
  j = s1->s;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (*i) {
#line 80
      if (! ((int )*i == (int )*j)) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    i ++;
#line 80
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return ((int )*i != (int )*j);
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void error_c(Err e , int c ) 
{ 


  {
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"regexp: %s, %c\n",
          errs[e], c);
#line 89
  longjmp((struct __jmp_buf_tag *)(regexp_state), 1);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
void Strzero(String___0 *s ) 
{ 


  {
  {
#line 95
  memset((void *)s->s, 0, (size_t )(s->n * 2));
  }
#line 96
  return;
}
}
#line 123
static Bool text_strregexp(Text *t___0 , String___0 str___1 , Range *r , Bool fwd ) ;
#line 123 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static Bool active  =    (Bool )0;
#line 111 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static Bool text_strregexp(Text *t___0 , String___0 str___1 , Range *r , Bool fwd ) 
{ 
  File f ;
  Bool found ;
  ulong q0 ;
  ulong q1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 126
  active = (Bool )1;
#line 127
  tmp = _setjmp((struct __jmp_buf_tag *)(regexp_state));
  }
#line 127
  if (tmp) {
#line 128
    found = (Bool )0;
#line 129
    goto out;
  }
  {
#line 131
  found = (Bool )0;
#line 132
  tmp___0 = do_compile(& str___1);
  }
#line 132
  if (tmp___0) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"regexp: compilation failed\n");
    }
#line 134
    goto out;
  }
  {
#line 136
  q0 = r->p0;
#line 137
  q1 = r->p1;
#line 138
  Finit(& f, t___0, r);
  }
#line 140
  if (fwd) {
    {
#line 140
    tmp___1 = execute(& f, (Posn )q1, (Posn )t___0->length);
#line 140
    found = (Bool )tmp___1;
    }
  } else {
    {
#line 140
    tmp___2 = bexecute(& f, (Posn )q0);
#line 140
    found = (Bool )tmp___2;
    }
  }
#line 141
  if (found) {
#line 142
    r->p0 = (ulong )sel.w[0].p1;
#line 143
    r->p1 = (ulong )sel.w[0].w2;
#line 144
    goto out;
  }
#line 147
  if (fwd) {
    {
#line 147
    tmp___3 = execute(& f, (Posn )0, (Posn )t___0->length);
#line 147
    found = (Bool )tmp___3;
    }
  } else {
    {
#line 147
    tmp___4 = bexecute(& f, (Posn )t___0->length);
#line 147
    found = (Bool )tmp___4;
    }
  }
#line 148
  if (found) {
#line 149
    r->p0 = (ulong )sel.w[0].p1;
#line 150
    r->p1 = (ulong )sel.w[0].w2;
  }
  out: 
#line 153
  active = (Bool )0;
#line 154
  return (found);
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static String___0 str  ;
#line 157 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
Bool text_utfregexp(Text *t___0 , char *re , Range *r , Bool fwd ) 
{ 
  int l ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  ulong tmp___2 ;
  Bool tmp___3 ;

  {
  {
#line 161
  tmp = strlen((char const   *)re);
#line 161
  l = (int )((1UL + tmp) * sizeof(Rune ));
  }
#line 163
  if (str.n <= l) {
    {
#line 164
    str.n = l;
#line 165
    tmp___0 = srealloc((void *)str.s, str.n);
#line 165
    str.s = (Rune *)tmp___0;
    }
  }
  {
#line 167
  tmp___1 = strlen((char const   *)re);
#line 167
  tmp___2 = utftotext(str.s, re, re + tmp___1);
#line 167
  *(str.s + tmp___2) = (Rune )0;
#line 168
  tmp___3 = text_strregexp(t___0, str, r, fwd);
  }
#line 168
  return (tmp___3);
}
}
#line 174 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
static String___0 str___0  ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
Bool text_regexp(Text *t___0 , Rstring re , Range *r , Bool fwd ) 
{ 
  int l ;
  void *tmp ;
  Bool tmp___0 ;

  {
#line 175
  l = (int )((unsigned long )(1L + (re.r1 - re.r0)) * sizeof(Rune ));
#line 177
  if (str___0.n <= l) {
    {
#line 178
    str___0.n = l;
#line 179
    tmp = srealloc((void *)str___0.s, str___0.n);
#line 179
    str___0.s = (Rune *)tmp;
    }
  }
  {
#line 181
  memcpy((void */* __restrict  */)str___0.s, (void const   */* __restrict  */)re.r0,
         (unsigned long )(re.r1 - re.r0) * sizeof(Rune ));
#line 182
  *(str___0.s + (re.r1 - re.r0)) = (Rune )0;
#line 184
  tmp___0 = text_strregexp(t___0, str___0, r, fwd);
  }
#line 184
  return (tmp___0);
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.c"
long Tchars(Text *t___0 , Rune *buf___3 , ulong p0 , ulong p1 ) 
{ 
  Range r ;
  ulong tmp ;

  {
#line 191
  if (p1 < t___0->length) {
#line 191
    tmp = p1;
  } else {
#line 191
    tmp = t___0->length;
  }
  {
#line 191
  r = range(p0, tmp);
#line 192
  text_copy(t___0, r, buf___3);
  }
#line 193
  return ((long )(r.p1 - r.p0));
}
}
#line 40 "./../include/libc.h"
int chartorune(Rune *rune , char *str___1 ) ;
#line 218 "./../include/libg.h"
long charwidth(Font___0 *f , Rune r ) ;
#line 268
Point Pt(int x , int y ) ;
#line 37 "./../include/frame.h"
ulong frcharofpt(Frame *f , Point pt ) ;
#line 38
Point frptofchar(Frame *f , ulong p ) ;
#line 61
void _frcklinewrap(Frame *f , Point *p , Frbox *b ) ;
#line 63
void _fradvance(Frame *f , Point *p , Frbox *b ) ;
#line 68
Point _frptofcharptb(Frame *f , ulong p , Point pt , int bn ) ;
#line 69
Point _frptofcharnb(Frame *f , ulong p , int nb ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frptofchar.c"
Point _frptofcharptb(Frame *f , ulong p , Point pt , int bn ) 
{ 
  uchar *s ;
  Frbox *b ;
  int w ;
  int l ;
  Rune r ;
  long tmp ;

  {
#line 15
  b = f->box + bn;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (bn < (int )f->nbox)) {
#line 15
      goto while_break;
    }
    {
#line 16
    _frcklinewrap(f, & pt, b);
    }
#line 17
    if (b->nrune < 0L) {
#line 17
      l = 1;
    } else {
#line 17
      l = (int )b->nrune;
    }
#line 17
    if (p < (ulong )l) {
#line 18
      if (b->nrune > 0L) {
#line 19
        s = b->a.ptr;
        {
#line 19
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 19
          if (! (p > 0UL)) {
#line 19
            goto while_break___0;
          }
#line 20
          r = (Rune )*s;
#line 20
          if ((int )r < 128) {
#line 21
            w = 1;
          } else {
            {
#line 23
            w = chartorune(& r, (char *)s);
            }
          }
          {
#line 24
          tmp = charwidth(f->font, r);
#line 24
          pt.x = (int )((long )pt.x + tmp);
          }
#line 25
          if ((int )r == 0) {
            {
#line 26
            berror((char *)"frptofchar");
            }
          } else
#line 25
          if (pt.x > f->r.max.x) {
            {
#line 26
            berror((char *)"frptofchar");
            }
          }
#line 19
          s += w;
#line 19
          p --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 28
      goto while_break;
    }
    {
#line 30
    p -= (ulong )l;
#line 31
    _fradvance(f, & pt, b);
#line 15
    bn ++;
#line 15
    b ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  return (pt);
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frptofchar.c"
Point frptofchar(Frame *f , ulong p ) 
{ 
  Point tmp ;
  Point tmp___0 ;

  {
  {
#line 39
  tmp = Pt((int )f->left, f->r.min.y);
#line 39
  tmp___0 = _frptofcharptb(f, p, tmp, 0);
  }
#line 39
  return (tmp___0);
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frptofchar.c"
Point _frptofcharnb(Frame *f , ulong p , int nb ) 
{ 
  Point pt ;
  int nbox ;
  Point tmp ;

  {
  {
#line 48
  nbox = (int )f->nbox;
#line 49
  f->nbox = (ushort )nb;
#line 50
  tmp = Pt((int )f->left, f->r.min.y);
#line 50
  pt = _frptofcharptb(f, p, tmp, 0);
#line 51
  f->nbox = (ushort )nbox;
  }
#line 52
  return (pt);
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frptofchar.c"
static Point _frgrid(Frame *f , Point p ) 
{ 


  {
#line 59
  p.y -= f->r.min.y;
#line 60
  p.y -= p.y % (int )(f->font)->height;
#line 61
  p.y += f->r.min.y;
#line 62
  if (p.x > f->r.max.x) {
#line 63
    p.x = f->r.max.x;
  }
#line 64
  return (p);
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frptofchar.c"
ulong frcharofpt(Frame *f , Point pt ) 
{ 
  Point qt ;
  int w ;
  int bn ;
  uchar *s ;
  Frbox *b ;
  ulong p ;
  Rune r ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 77
  pt = _frgrid(f, pt);
#line 78
  qt.x = (int )f->left;
#line 79
  qt.y = f->r.min.y;
#line 80
  b = f->box;
#line 80
  bn = 0;
#line 80
  p = (ulong )0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (bn < (int )f->nbox) {
#line 80
      if (! (qt.y < pt.y)) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
    {
#line 81
    _frcklinewrap(f, & qt, b);
    }
#line 82
    if (qt.y >= pt.y) {
#line 83
      goto while_break;
    }
    {
#line 84
    _fradvance(f, & qt, b);
    }
#line 85
    if (b->nrune < 0L) {
#line 85
      tmp = 1L;
    } else {
#line 85
      tmp = b->nrune;
    }
#line 85
    p += (ulong )tmp;
#line 80
    bn ++;
#line 80
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (bn < (int )f->nbox) {
#line 87
      if (! (qt.x <= pt.x)) {
#line 87
        goto while_break___0;
      }
    } else {
#line 87
      goto while_break___0;
    }
    {
#line 88
    _frcklinewrap(f, & qt, b);
    }
#line 89
    if (qt.y > pt.y) {
#line 90
      goto while_break___0;
    }
#line 91
    if ((long )qt.x + b->wid > (long )pt.x) {
#line 92
      if (b->nrune < 0L) {
        {
#line 93
        _fradvance(f, & qt, b);
        }
      } else {
#line 95
        s = b->a.ptr;
        {
#line 96
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 97
          r = (Rune )*s;
#line 97
          if ((int )r < 128) {
#line 98
            w = 1;
          } else {
            {
#line 100
            w = chartorune(& r, (char *)s);
            }
          }
#line 101
          if ((int )r == 0) {
            {
#line 102
            berror((char *)"end of string in frcharofpt");
            }
          }
          {
#line 103
          s += w;
#line 104
          tmp___0 = charwidth(f->font, r);
#line 104
          qt.x = (int )((long )qt.x + tmp___0);
          }
#line 105
          if (qt.x > pt.x) {
#line 106
            goto while_break___1;
          }
#line 107
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 111
      if (b->nrune < 0L) {
#line 111
        tmp___1 = 1L;
      } else {
#line 111
        tmp___1 = b->nrune;
      }
      {
#line 111
      p += (ulong )tmp___1;
#line 112
      _fradvance(f, & qt, b);
      }
    }
#line 87
    bn ++;
#line 87
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  return (p);
}
}
#line 210 "./../include/libg.h"
void point(Bitmap *b , Point p , int v , Fcode f ) ;
#line 2373 "/usr/include/X11/Xlib.h"
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
GC _getfillgc(Fcode f , Bitmap *b , unsigned long val ) ;
#line 48
Display *_dpy ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/point.c"
void point(Bitmap *b , Point p , int v , Fcode f ) 
{ 
  int x ;
  int y ;
  GC g ;

  {
#line 12
  x = p.x;
#line 13
  y = p.y;
#line 14
  if (b->flag & 32) {
#line 15
    x -= b->r.min.x;
#line 16
    y -= b->r.min.y;
  }
  {
#line 18
  g = _getfillgc(f, b, (unsigned long )v);
#line 19
  XDrawPoint(_dpy, (Drawable )b->id, g, x, y);
  }
#line 20
  return;
}
}
#line 182 "./../include/libg.h"
Point sub(Point a , Point b ) ;
#line 230
void cursorset(Point p ) ;
#line 276
Bitmap screen ;
#line 3526 "/usr/include/X11/Xlib.h"
extern int XWarpPointer(Display * , Window  , Window  , int  , int  , unsigned int  ,
                        unsigned int  , int  , int  ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorset.c"
void cursorset(Point p ) 
{ 


  {
  {
#line 13
  p = sub(p, screen.r.min);
#line 14
  XWarpPointer(_dpy, (Window )0L, (Window )screen.id, 0, 0, 0U, 0U, p.x, p.y);
  }
#line 15
  return;
}
}
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
Bool show_dot_files ;
#line 7
Bool autoindent_enabled ;
#line 8
View *last_selection ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Bool builtin(View *v , char *cmd , char *arg ) ;
#line 19
Tile *tile_col(Tile *tile ) ;
#line 20
void col_new(View *v , char *arg ) ;
#line 21
void col_del(Tile *t___0 ) ;
#line 28
int data_putall(void) ;
#line 30
int data_put(Data *d , char *label ) ;
#line 43
void kill_all(char *s ) ;
#line 44
void kill_list(void) ;
#line 51
View *data_open(char *label , Bool create ) ;
#line 52
int data_get(Data *d , char *label ) ;
#line 63
void data_addcontext(Data *d , char *dest , char *orig ) ;
#line 66
View *data_find(char *label ) ;
#line 143
Range text_replace(Text *t___0 , Range r , Rstring s ) ;
#line 167
Range text_all(Text *t___0 ) ;
#line 184
void tile_setfont(Tile *t___0 , char *arg ) ;
#line 191
Range undo_undo(Text *t___0 , Bool all ) ;
#line 192
Range undo_redo(Text *t___0 , Bool all ) ;
#line 215
Rstring rstring(Rune *r0 , Rune *r1___0 ) ;
#line 218
void snarf(Text *t___0 , Range r ) ;
#line 224
void cleanup_and_die(int n ) ;
#line 240
void view_paste(View *v ) ;
#line 246
Data *view_data(View *v ) ;
#line 247
View *view_body(View *v ) ;
#line 248
Tile *view_win(View *v ) ;
#line 249
Tile *view_tile(View *v ) ;
#line 254
void view_cut(View *v , Range r ) ;
#line 259
void view_select(View *v , Range r ) ;
#line 267
void view_look(View *v , char *arg ) ;
#line 271
void view_show(View *v , Range r ) ;
#line 280
int win_del(Tile *w ) ;
#line 282
void win_clone(Tile *win ) ;
#line 283
void win_anchor(Tile *w , char *arg ) ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void builtin_kill(View *v , char *s ) 
{ 


  {
#line 21
  if (s) {
    {
#line 22
    kill_all(s);
    }
  } else {
    {
#line 24
    kill_list();
    }
  }
#line 25
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void dotfiles(View *v , char *arg ) 
{ 


  {
#line 35
  show_dot_files = (Bool )(! show_dot_files);
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void builtin_font(View *v , char *arg ) 
{ 
  Tile *tmp ;

  {
  {
#line 40
  tmp = view_tile(v);
#line 40
  tile_setfont(tmp, arg);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void builtin_autoindent(View *v , char *arg ) 
{ 
  View *body ;

  {
  {
#line 47
  body = view_body(v);
  }
#line 47
  if (body) {
#line 48
    body->autoindent = (Bool )(! body->autoindent);
  } else {
#line 50
    autoindent_enabled = (Bool )(! autoindent_enabled);
  }
#line 52
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void undo_ops(View *v , char *arg , Range (*undofn)(Text * , Bool  ) ) 
{ 
  Range r ;

  {
  {
#line 63
  v = view_body(v);
  }
#line 63
  if (! v) {
#line 64
    return;
  }
  {
#line 65
  r = (*undofn)(v->t, (Bool )arg);
  }
#line 66
  if (r.p1 >= r.p0) {
    {
#line 67
    view_show(v, r);
#line 68
    view_select(v, r);
    }
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void undo(View *v , char *arg ) 
{ 


  {
  {
#line 72
  undo_ops(v, arg, & undo_undo);
  }
#line 72
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void redo(View *v , char *arg ) 
{ 


  {
  {
#line 73
  undo_ops(v, arg, & undo_redo);
  }
#line 73
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void getorput(View *v , char *arg , int (*fn)(Data * , char * ) ) 
{ 
  Data *d ;
  Path dest ;
  char *s ;
  size_t tmp ;

  {
  {
#line 86
  d = view_data(v);
  }
#line 86
  if (! d) {
#line 87
    return;
  }
#line 89
  if (arg) {
    {
#line 89
    tmp = strlen((char const   *)arg);
    }
#line 89
    if (tmp) {
      {
#line 90
      data_addcontext(d, dest, arg);
#line 91
      s = dest;
      }
    } else {
#line 93
      s = (char *)0;
    }
  } else {
#line 93
    s = (char *)0;
  }
  {
#line 95
  (*fn)(d, s);
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void put(View *v , char *arg ) 
{ 


  {
  {
#line 98
  getorput(v, arg, & data_put);
  }
#line 98
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void get(View *v , char *arg ) 
{ 


  {
  {
#line 99
  getorput(v, arg, & data_get);
  }
#line 99
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void putall(View *v , char *arg ) 
{ 


  {
  {
#line 107
  data_putall();
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void quit(View *v , char *arg ) 
{ 


  {
  {
#line 112
  cleanup_and_die(0);
  }
#line 113
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void del(View *v , char *arg ) 
{ 
  Tile *tmp ;

  {
  {
#line 121
  tmp = view_win(v);
#line 121
  win_del(tmp);
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void delcol(View *v , char *arg ) 
{ 
  Tile *tmp ;

  {
  {
#line 126
  tmp = tile_col(v->tile);
#line 126
  col_del(tmp);
  }
#line 127
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void cut(View *v , char *arg ) 
{ 


  {
#line 134
  v = last_selection;
#line 134
  if (v) {
    {
#line 135
    view_cut(v, v->sel);
    }
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void builtin_snarf(View *v , char *arg ) 
{ 


  {
#line 140
  v = last_selection;
#line 140
  if (v) {
    {
#line 141
    snarf(v->t, v->sel);
    }
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void builtin_paste(View *v , char *arg ) 
{ 


  {
#line 146
  v = last_selection;
#line 146
  if (v) {
    {
#line 147
    view_paste(v);
    }
  }
#line 148
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void anchor(View *v , char *arg ) 
{ 
  Tile *win ;

  {
  {
#line 158
  win = view_win(v);
  }
#line 158
  if (win) {
    {
#line 159
    win_anchor(win, arg);
    }
  } else {
    {
#line 158
    win = view_win(last_selection);
    }
#line 158
    if (win) {
      {
#line 159
      win_anchor(win, arg);
      }
    }
  }
#line 161
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void split(View *v , char *arg ) 
{ 
  Tile *win ;

  {
  {
#line 169
  win = view_win(v);
  }
#line 169
  if (win) {
    {
#line 170
    win_clone(win);
    }
  } else {
    {
#line 169
    win = view_win(last_selection);
    }
#line 169
    if (win) {
      {
#line 170
      win_clone(win);
      }
    }
  }
#line 172
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void clear(View *v , char *arg ) 
{ 
  View *body ;
  Rstring tmp ;
  Range tmp___0 ;

  {
  {
#line 182
  body = view_body(v);
  }
#line 182
  if (body) {
    {
#line 183
    tmp = rstring((Rune *)0, (Rune *)0);
#line 183
    tmp___0 = text_all(body->t);
#line 183
    text_replace(body->t, tmp___0, tmp);
    }
  }
#line 184
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void look(View *v , char *arg ) 
{ 


  {
  {
#line 191
  v = view_body(v);
  }
#line 191
  if (v) {
    {
#line 192
    view_look(v, arg);
    }
  }
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static void new(View *v , char *arg ) 
{ 
  Path label ;
  Tile *tmp ;
  Data *tmp___0 ;
  View *tmp___1 ;

  {
#line 203
  if (! arg) {
#line 204
    arg = (char *)"New";
  }
  {
#line 207
  tmp = view_win(v);
  }
#line 207
  if (! tmp) {
#line 208
    v = last_selection;
  }
  {
#line 209
  tmp___0 = view_data(v);
#line 209
  data_addcontext(tmp___0, label, arg);
#line 210
  tmp___1 = data_find(label);
  }
#line 210
  if (! tmp___1) {
    {
#line 211
    data_open(label, (Bool )1);
    }
  }
#line 212
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static Cmd builtins[21]  = 
#line 221
  {      {(char *)"Anchor", & anchor}, 
        {(char *)"Clear", & clear}, 
        {(char *)"Cut", & cut}, 
        {(char *)"Del", & del}, 
        {(char *)"Delcol", & delcol}, 
        {(char *)"Dotfiles", & dotfiles}, 
        {(char *)"Font", & builtin_font}, 
        {(char *)"Get", & get}, 
        {(char *)"Indent", & builtin_autoindent}, 
        {(char *)"Kill", & builtin_kill}, 
        {(char *)"Look", & look}, 
        {(char *)"New", & new}, 
        {(char *)"Newcol", & col_new}, 
        {(char *)"Paste", & builtin_paste}, 
        {(char *)"Put", & put}, 
        {(char *)"Putall", & putall}, 
        {(char *)"Quit", & quit}, 
        {(char *)"Redo", & redo}, 
        {(char *)"Snarf", & builtin_snarf}, 
        {(char *)"Split", & split}, 
        {(char *)"Undo", & undo}};
#line 245 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
static int cmd_compare(Cmd *a , Cmd *b ) 
{ 
  int tmp ;

  {
  {
#line 248
  tmp = strcmp((char const   *)a->name, (char const   *)b->name);
  }
#line 248
  return (tmp);
}
}
#line 255 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/builtins.c"
Bool builtin(View *v , char *cmd , char *arg ) 
{ 
  Cmd key ;
  Cmd *c ;
  void *tmp ;

  {
  {
#line 263
  key.name = cmd;
#line 264
  tmp = bsearch((void const   *)(& key), (void const   *)(builtins), sizeof(builtins) / sizeof(Cmd ),
                sizeof(Cmd ), (int (*)(void const   * , void const   * ))(& cmd_compare));
#line 264
  c = (Cmd *)tmp;
  }
#line 268
  if (c) {
    {
#line 269
    (*(c->cmd))(v, arg);
    }
  }
#line 270
  return ((Bool )c);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 39 "./../include/libc.h"
int runetochar(char *str___1 , Rune *rune ) ;
#line 41
int runelen(long c ) ;
#line 47
long utflen(char *s ) ;
#line 216 "./../include/libg.h"
long strwidth(Font___0 *f , char *s ) ;
#line 259
char *select_get(void) ;
#line 260
void select_put(char *s ) ;
#line 47 "./../include/frame.h"
void frgetmouse(void) ;
#line 70 "./../include/msg.h"
void fifo_cleanup(void) ;
#line 116
void *salloc(int size ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
Path wilydir ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void error(char *fmt  , ...) ;
#line 8
void fatal(char *fmt  , ...) ;
#line 29
int data_backupall(void) ;
#line 88
void labelclean(char *label ) ;
#line 89
void label2path(char *path , char *label ) ;
#line 91
View *openlabel(char *label , Bool create ) ;
#line 151
ulong text_length(Text *t___0 ) ;
#line 170
Range text_replaceutf(Text *t___0 , Range r , char *utf ) ;
#line 171
char *text_duputf(Text *t___0 , Range r ) ;
#line 201
void dirnametrunc(char *s ) ;
#line 202
void addcontext(char *dest , char *context , char *add___0 ) ;
#line 203
void olabel(char *out , char *label ) ;
#line 204
int statcmp(Stat *a , Stat *b ) ;
#line 205
Bool isdir(char *path ) ;
#line 206
int backup_name(char *orig , char *back ) ;
#line 207
char *columnate(int totalwidth , int tabwidth , Font___0 *f , char **item ) ;
#line 208
void noutput(char *context , char *base , int n ) ;
#line 209
void add_slash(char *s ) ;
#line 210
int distance(Point p1 , Point p2 ) ;
#line 211
Bool frame_isfull(Frame *f ) ;
#line 213
char *mybasename(char *f ) ;
#line 214
Range paste(Text *t___0 , Range r ) ;
#line 220
ulong texttoutf(char *s , Rune *r1___0 , Rune *r2___0 ) ;
#line 222
int diag(char *context , char *fmt  , ...) ;
#line 223
void cleanup_and_abort(int n ) ;
#line 225
Rstring utf2rstring(char *utf ) ;
#line 250
Text *view_text(View *v ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void dirnametrunc(char *s ) 
{ 


  {
  {
#line 13
  s = strrchr((char const   *)s, '/');
  }
#line 13
  if (s) {
#line 14
    s ++;
#line 14
    *s = (char)0;
  }
#line 15
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void addcontext(char *dest , char *context , char *add___0 ) 
{ 
  char *s ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 21
  tmp = strchr("/$~", (int )*(add___0 + 0));
  }
#line 21
  if (tmp) {
    {
#line 22
    strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)add___0);
    }
#line 23
    return;
  }
  {
#line 25
  strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)context);
#line 26
  s = strrchr((char const   *)dest, '/');
  }
#line 26
  if (! s) {
    {
#line 27
    label2path(dest, context);
#line 28
    s = strrchr((char const   *)dest, '/');
    }
#line 28
    if (! s) {
      {
#line 29
      tmp___0 = strlen((char const   *)dest);
#line 29
      s = (dest + tmp___0) - 1;
      }
    }
  }
  {
#line 32
  strcpy((char */* __restrict  */)(s + 1), (char const   */* __restrict  */)add___0);
#line 33
  labelclean(dest);
  }
#line 34
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void olabel(char *out , char *label ) 
{ 


  {
  {
#line 41
  addcontext(out, label, (char *)"+Errors");
  }
#line 42
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
int statcmp(Stat *a , Stat *b ) 
{ 


  {
#line 49
  if (a->st_ino != b->st_ino) {
#line 50
    return (-1);
  } else
#line 49
  if (a->st_dev != b->st_dev) {
#line 50
    return (-1);
  } else {
#line 52
    return (0);
  }
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Bool isdir(char *path ) 
{ 
  struct stat buf___3 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf___3));
  }
#line 59
  if (tmp) {
#line 59
    tmp___0 = 0;
  } else
#line 59
  if ((buf___3.st_mode & 61440U) == 16384U) {
#line 59
    tmp___0 = 1;
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((Bool )tmp___0);
}
}
#line 66 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Rstring utf2rstring(char *utf ) 
{ 
  Rstring s ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  ulong tmp___1 ;
  long tmp___2 ;

  {
  {
#line 72
  tmp___2 = utflen(utf);
#line 72
  len = (int )tmp___2;
  }
#line 72
  if (len) {
    {
#line 73
    tmp = salloc((int )((unsigned long )len * sizeof(Rune )));
#line 73
    s.r0 = (Rune *)tmp;
#line 74
    tmp___0 = strlen((char const   *)utf);
#line 74
    tmp___1 = utftotext(s.r0, utf, utf + tmp___0);
#line 74
    s.r1 = s.r0 + tmp___1;
    }
  } else {
#line 76
    s.r1 = (Rune *)0;
#line 76
    s.r0 = s.r1;
  }
#line 78
  return (s);
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
int backup_name(char *orig , char *back ) 
{ 
  Path dir ;
  Path guide ;
  char *home ;
  DIR *dirp ;
  struct dirent *direntp ;
  FILE *fp ;
  int max ;
  int n ;
  int init_guide ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 92
  init_guide = 0;
#line 94
  home = getenv("WILYBAK");
  }
#line 94
  if (home) {
    {
#line 100
    strcpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)home);
    }
  } else {
    {
#line 95
    home = getenv("HOME");
    }
#line 95
    if (! home) {
      {
#line 96
      tmp = diag((char *)0, (char *)"getenv HOME");
      }
#line 96
      return (tmp);
    }
    {
#line 98
    sprintf((char */* __restrict  */)(dir), (char const   */* __restrict  */)"%s/.wilybak",
            home);
    }
  }
  {
#line 104
  tmp___1 = access((char const   *)(dir), 2);
  }
#line 104
  if (tmp___1) {
    {
#line 104
    tmp___2 = mkdir((char const   *)(dir), (__mode_t )448);
    }
#line 104
    if (tmp___2) {
      {
#line 105
      tmp___0 = diag((char *)0, (char *)"couldn\'t create backup directory %s", dir);
      }
#line 105
      return (tmp___0);
    }
  }
  {
#line 110
  max = 0;
#line 111
  dirp = opendir((char const   *)(dir));
  }
#line 111
  if (! dirp) {
    {
#line 112
    tmp___3 = diag((char *)0, (char *)"couldn\'t opendir %s", dir);
    }
#line 112
    return (tmp___3);
  }
  {
#line 114
  rewinddir(dirp);
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    direntp = readdir(dirp);
    }
#line 115
    if (! direntp) {
#line 115
      goto while_break;
    }
    {
#line 116
    n = atoi((char const   *)(direntp->d_name));
    }
#line 116
    if (n > max) {
#line 117
      max = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  closedir(dirp);
#line 120
  max ++;
#line 122
  sprintf((char */* __restrict  */)back, (char const   */* __restrict  */)"%s/%d",
          dir, max);
#line 126
  sprintf((char */* __restrict  */)(guide), (char const   */* __restrict  */)"%s/guide",
          dir);
#line 127
  tmp___4 = access((char const   *)(guide), 2);
  }
#line 127
  if (tmp___4 < 0) {
#line 128
    init_guide = 1;
  }
  {
#line 129
  fp = fopen((char const   */* __restrict  */)(guide), (char const   */* __restrict  */)"a+");
  }
#line 130
  if (fp) {
#line 131
    if (init_guide) {
      {
#line 132
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"diff\tcp\trm *\n");
      }
    }
    {
#line 133
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d\t%s\n",
            max, orig);
#line 134
    fclose(fp);
    }
  } else {
    {
#line 136
    diag(guide, (char *)"couldn\'t update backup guide file");
    }
  }
#line 138
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void noutput(char *context , char *base , int n ) 
{ 
  Path errwin ;
  View *v ;
  Range r ;
  char *s ;
  Text *t___0 ;
  ulong p ;
  char *tmp ;
  size_t tmp___0 ;
  Range tmp___1 ;

  {
#line 151
  if (context) {
#line 151
    tmp = context;
  } else {
#line 151
    tmp = wilydir;
  }
  {
#line 151
  strcpy((char */* __restrict  */)(errwin), (char const   */* __restrict  */)tmp);
#line 152
  s = strrchr((char const   *)(errwin), '/');
  }
#line 152
  if (s) {
#line 153
    s ++;
  } else {
    {
#line 155
    tmp___0 = strlen((char const   *)(errwin));
#line 155
    s = errwin + tmp___0;
    }
  }
  {
#line 156
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"+Errors");
#line 158
  v = openlabel(errwin, (Bool )1);
#line 159
  *(base + n) = (char)0;
#line 160
  t___0 = view_text(v);
#line 161
  p = text_length(t___0);
#line 162
  tmp___1 = range(p, p);
#line 162
  r = text_replaceutf(t___0, tmp___1, base);
#line 163
  r.p0 = r.p1;
#line 164
  view_show(v, r);
  }
#line 165
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
char *columnate(int totalwidth , int tabwidth , Font___0 *f , char **item ) 
{ 
  int rows ;
  int columns ;
  int row ;
  int column ;
  int maxwidth ;
  int j ;
  int widest ;
  int nitems ;
  int ntabs ;
  int biggest ;
  int *width ;
  char *buf___3 ;
  char *s ;
  char **c ;
  int remaining ;
  char **tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int current ;
  int deficit ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 185
  nitems = 0;
#line 186
  c = item;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    tmp = c;
#line 187
    c ++;
#line 187
    if (! *tmp) {
#line 187
      goto while_break;
    }
#line 188
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if (! nitems) {
    {
#line 191
    tmp___0 = strdup("");
    }
#line 191
    return (tmp___0);
  }
  {
#line 197
  widest = 0;
#line 198
  tmp___1 = salloc((int )((unsigned long )nitems * sizeof(int )));
#line 198
  width = (int *)tmp___1;
#line 199
  j = 0;
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (! (j < nitems)) {
#line 199
      goto while_break___0;
    }
    {
#line 200
    tmp___2 = strwidth(f, *(item + j));
#line 200
    *(width + j) = (int )tmp___2;
    }
#line 201
    if (*(width + j) > *(width + widest)) {
#line 202
      widest = j;
    }
#line 199
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 205
  tmp___3 = strwidth(f, (char *)"W");
#line 205
  biggest = (int )((long )*(width + widest) + tmp___3);
#line 206
  ntabs = biggest / tabwidth;
  }
#line 207
  if (biggest % tabwidth) {
#line 208
    ntabs ++;
  }
#line 209
  maxwidth = ntabs * tabwidth;
#line 210
  columns = (totalwidth - biggest) / maxwidth + 1;
#line 211
  rows = nitems / columns;
#line 212
  if (nitems % columns) {
#line 213
    rows ++;
  }
  {
#line 215
  tmp___4 = strlen((char const   *)*(item + widest));
#line 215
  tmp___5 = salloc((int )((size_t )nitems * (tmp___4 + 4UL)));
#line 215
  buf___3 = (char *)tmp___5;
#line 215
  s = buf___3;
#line 217
  remaining = nitems;
#line 218
  row = 0;
  }
  {
#line 218
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 219
    column = 0;
    {
#line 219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 219
      if (! (column < columns)) {
#line 219
        goto while_break___2;
      }
#line 222
      current = column * rows + row;
#line 223
      if (current >= nitems) {
#line 224
        goto while_break___2;
      }
#line 225
      deficit = maxwidth - *(width + current);
#line 226
      ntabs = deficit / tabwidth;
#line 227
      if (deficit % tabwidth) {
#line 228
        ntabs ++;
      }
#line 229
      if (column == columns - 1) {
#line 230
        ntabs = 0;
      }
      {
#line 232
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)*(item + current));
#line 233
      tmp___6 = strlen((char const   *)*(item + current));
#line 233
      s += tmp___6;
      }
      {
#line 234
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 234
        tmp___8 = ntabs;
#line 234
        ntabs --;
#line 234
        if (! (tmp___8 > 0)) {
#line 234
          goto while_break___3;
        }
#line 235
        tmp___7 = s;
#line 235
        s ++;
#line 235
        *tmp___7 = (char )'\t';
      }
      while_break___3: /* CIL Label */ ;
      }
#line 236
      remaining --;
#line 236
      if (! remaining) {
#line 237
        goto done;
      }
#line 219
      column ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 239
    tmp___9 = s;
#line 239
    s ++;
#line 239
    *tmp___9 = (char )'\n';
#line 218
    row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
#line 242
  if (column) {
#line 243
    tmp___10 = s;
#line 243
    s ++;
#line 243
    *tmp___10 = (char )'\n';
  }
  {
#line 244
  tmp___11 = s;
#line 244
  s ++;
#line 244
  *tmp___11 = (char )'\000';
#line 245
  free((void *)width);
  }
#line 246
  return (buf___3);
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
static void cleanup(void) 
{ 


  {
  {
#line 251
  data_backupall();
#line 252
  fifo_cleanup();
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void cleanup_and_die(int n ) 
{ 


  {
  {
#line 258
  cleanup();
#line 259
  exit(0);
  }
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void cleanup_and_abort(int n ) 
{ 


  {
  {
#line 265
  perror("wily: something horrible happened:");
#line 266
  cleanup();
#line 267
  abort();
  }
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
int diag(char *context , char *fmt  , ...) 
{ 
  va_list args___0 ;
  Path msg ;
  char *err ;
  char *s ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 280
  s = msg;
#line 281
  tmp___0 = __errno_location();
  }
#line 281
  if (*tmp___0) {
    {
#line 281
    tmp___1 = __errno_location();
#line 281
    err = strerror(*tmp___1);
    }
#line 281
    if (err) {
      {
#line 282
      sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"diag: %s: ",
              err);
#line 283
      tmp = strlen((char const   *)s);
#line 283
      s += tmp;
      }
    }
  }
  {
#line 285
  __builtin_va_start(args___0, fmt);
#line 286
  vsprintf((char */* __restrict  */)s, (char const   */* __restrict  */)fmt, args___0);
#line 287
  __builtin_va_end(args___0);
#line 288
  strcat((char */* __restrict  */)(msg), (char const   */* __restrict  */)"\n");
#line 290
  tmp___2 = strlen((char const   *)(msg));
#line 290
  noutput(context, msg, (int )tmp___2);
  }
#line 291
  return (1);
}
}
#line 294 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Rstring rstring(Rune *r0 , Rune *r1___0 ) 
{ 
  Rstring s ;

  {
#line 298
  s.r0 = r0;
#line 299
  s.r1 = r1___0;
#line 300
  return (s);
}
}
#line 303 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
char *mybasename(char *f ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 306
  s = strrchr((char const   *)f, '/');
  }
#line 307
  if (s) {
#line 307
    tmp = s + 1;
  } else {
#line 307
    tmp = f;
  }
#line 307
  return (tmp);
}
}
#line 310 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
ulong texttoutf(char *s , Rune *r1___0 , Rune *r2___0 ) 
{ 
  Rune *q ;
  char *t___0 ;
  int tmp ;

  {
#line 315
  if ((unsigned long )r2___0 <= (unsigned long )r1___0) {
#line 316
    return ((ulong )0);
  }
#line 317
  t___0 = s;
#line 317
  q = r1___0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )q < (unsigned long )r2___0)) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp = runetochar(t___0, q);
#line 318
    t___0 += tmp;
#line 317
    q ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return ((ulong )(t___0 - s));
}
}
#line 322 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
int distance(Point p1 , Point p2 ) 
{ 


  {
#line 325
  return ((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
}
#line 330 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void error(char *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 335
  perror("wily:");
#line 336
  __builtin_va_start(args___0, fmt);
#line 337
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args___0);
#line 338
  __builtin_va_end(args___0);
  }
#line 339
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void fatal(char *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 347
  perror("wily:");
#line 348
  __builtin_va_start(args___0, fmt);
#line 349
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args___0);
#line 350
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 351
  cleanup_and_abort(0);
  }
#line 352
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void frgetmouse(void) 
{ 


  {
#line 357
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void snarf(Text *t___0 , Range r ) 
{ 
  char *buf___3 ;

  {
#line 367
  if (r.p1 - r.p0) {
    {
#line 368
    buf___3 = text_duputf(t___0, r);
#line 369
    select_put(buf___3);
#line 370
    free((void *)buf___3);
    }
  }
#line 372
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Range paste(Text *t___0 , Range r ) 
{ 
  char *cbuf ;
  Rune *rbuf ;
  int n ;
  Rstring s ;
  long tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  ulong tmp___2 ;

  {
  {
#line 388
  cbuf = select_get();
#line 389
  tmp = utflen(cbuf);
#line 389
  tmp___0 = salloc((int )(sizeof(Rune ) * (unsigned long )(tmp + 1L)));
#line 389
  rbuf = (Rune *)tmp___0;
#line 390
  tmp___1 = strlen((char const   *)cbuf);
#line 390
  tmp___2 = utftotext(rbuf, cbuf, cbuf + tmp___1);
#line 390
  n = (int )tmp___2;
#line 391
  s.r0 = rbuf;
#line 392
  s.r1 = rbuf + n;
#line 393
  text_replace(t___0, r, s);
#line 395
  r.p1 = r.p0 + (ulong )n;
#line 396
  free((void *)rbuf);
  }
#line 397
  return (r);
}
}
#line 400 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
void add_slash(char *s ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 405
  tmp = strlen((char const   *)s);
#line 405
  n = (int )tmp;
  }
#line 406
  if ((int )*(s + (n - 1)) != 47) {
#line 407
    tmp___0 = n;
#line 407
    n ++;
#line 407
    *(s + tmp___0) = (char )'/';
#line 408
    *(s + n) = (char )'\000';
  }
#line 410
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Bool frame_isfull(Frame *f ) 
{ 
  int tmp ;

  {
#line 415
  if ((int )f->nlines == (int )f->maxlines) {
#line 415
    if (f->lastlinefull) {
#line 415
      tmp = 1;
    } else {
#line 415
      tmp = 0;
    }
  } else {
#line 415
    tmp = 0;
  }
#line 415
  return ((Bool )tmp);
}
}
#line 418 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
Bool utfHadNulls  ;
#line 419 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
int utftotext_unconverted  ;
#line 426 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/util.c"
ulong utftotext(Rune *r , char *s1 , char *s2 ) 
{ 
  Rune *q ;
  char *v ;
  char *tmp ;
  int tmp___0 ;
  int length ;

  {
#line 432
  utfHadNulls = (Bool )0;
#line 433
  if ((unsigned long )s2 <= (unsigned long )s1) {
#line 434
    return ((ulong )0);
  }
#line 435
  v = s1;
#line 435
  q = r;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! ((unsigned long )v < (unsigned long )s2)) {
#line 435
      goto while_break;
    }
#line 436
    if (! *((uchar *)v)) {
#line 437
      utfHadNulls = (Bool )1;
#line 438
      v ++;
#line 439
      goto __Cont;
    } else
#line 440
    if ((int )*((uchar *)v) < 128) {
#line 441
      tmp = v;
#line 441
      v ++;
#line 441
      *q = (Rune )*tmp;
    } else {
      {
#line 443
      tmp___0 = chartorune(q, v);
#line 443
      v += tmp___0;
      }
    }
#line 446
    q ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if ((unsigned long )v > (unsigned long )s2) {
    {
#line 450
    q --;
#line 451
    length = runelen((long )*q);
#line 452
    utftotext_unconverted = (int )(s2 - (v - length));
    }
  }
#line 454
  return ((ulong )(q - r));
}
}
#line 39 "./../include/frame.h"
int frdelete(Frame *f , ulong p0 , ulong p1 ) ;
#line 114 "./../include/msg.h"
int clip(int orig , int low , int high ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void view_pagedown(View *v , Bool down ) ;
#line 60
void view_linesdown(View *v , int n , Bool down ) ;
#line 72
ulong text_nl(Text *t___0 , ulong pos , int delta ) ;
#line 73
ulong text_startOfLine(Text *t___0 , ulong p ) ;
#line 166
int back_height(Text *t___0 , ulong p , Font___0 *f , int width , int height ) ;
#line 179
View *tile_body(Tile *t___0 ) ;
#line 185
void tile_show(Tile *tile ) ;
#line 231
void fill(View *v ) ;
#line 272
void view_scroll(View *v , Mouse *m ) ;
#line 273
void view_hscroll(View *v , Bool left___0 ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
void view_linesdown(View *v , int n , Bool down ) 
{ 
  Mouse m ;
  Rectangle r ;
  Tile *tmp ;

  {
  {
#line 13
  tmp = view_win(v);
#line 13
  v = tile_body(tmp);
  }
#line 13
  if (! v) {
#line 14
    return;
  }
#line 16
  r = v->r;
#line 17
  m.xy.x = r.min.x;
#line 18
  m.xy.y = r.min.y + (int )(v->f.font)->height * n;
#line 19
  if (down) {
#line 19
    m.buttons = 4;
  } else {
#line 19
    m.buttons = 1;
  }
  {
#line 20
  view_scroll(v, & m);
  }
#line 21
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
void view_pagedown(View *v , Bool down ) 
{ 
  Mouse m ;
  Rectangle r ;
  Tile *tmp ;

  {
  {
#line 28
  tmp = view_win(v);
#line 28
  v = tile_body(tmp);
  }
#line 28
  if (! v) {
#line 29
    return;
  }
#line 31
  r = v->r;
#line 32
  m.xy.x = r.min.x;
#line 33
  m.xy.y = (r.min.y + r.max.y) / 2;
#line 34
  if (down) {
#line 34
    m.buttons = 4;
  } else {
#line 34
    m.buttons = 1;
  }
  {
#line 35
  view_scroll(v, & m);
  }
#line 36
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
static void view_set(View *v , ulong n ) 
{ 
  ulong ndelete ;

  {
#line 47
  if (n == v->visible.p0) {
#line 48
    return;
  }
#line 50
  if (n >= v->visible.p0) {
#line 50
    if (n < v->visible.p1) {
#line 50
      ndelete = n - v->visible.p0;
    } else {
#line 50
      ndelete = (ulong )v->f.nchars;
    }
  } else {
#line 50
    ndelete = (ulong )v->f.nchars;
  }
#line 53
  v->visible.p0 = n;
#line 54
  if ((unsigned long )v->f.b != (unsigned long )((Bitmap *)0)) {
    {
#line 55
    frdelete(& v->f, (ulong )0, ndelete);
#line 56
    fill(v);
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
static Bool tag_isfull(Frame *f ) 
{ 
  Point pt ;
  Point tmp ;
  Point max ;

  {
  {
#line 64
  tmp = frptofchar(f, (ulong )f->nchars);
#line 64
  pt = tmp;
#line 65
  max = f->r.max;
  }
#line 66
  return ((Bool )(max.x - pt.x < 30));
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
static void tag_show(View *v , Range r ) 
{ 
  Frame *f ;
  Bool tmp ;

  {
#line 72
  f = & v->f;
#line 80
  if (r.p0 >= v->visible.p0) {
#line 80
    if (r.p1 <= v->visible.p1) {
#line 81
      goto done;
    } else {
#line 80
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 80
  if (v->visible.p0 >= r.p0) {
#line 80
    if (v->visible.p1 <= r.p1) {
#line 81
      goto done;
    }
  }
#line 88
  if (r.p1 > v->visible.p1) {
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 90
      if (! (r.p1 > v->visible.p1)) {
#line 90
        goto while_break;
      }
      {
#line 91
      frdelete(f, (ulong )0, (ulong )f->nchars);
#line 92
      v->visible.p0 += 5UL;
#line 93
      fill(v);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 99
    frdelete(f, (ulong )0, (ulong )f->nchars);
#line 100
    v->visible.p0 = r.p0;
#line 101
    fill(v);
    }
  }
  done: 
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 107
    tmp = tag_isfull(f);
    }
#line 107
    if (tmp) {
#line 107
      goto while_break___0;
    } else
#line 107
    if (! v->visible.p0) {
#line 107
      goto while_break___0;
    }
    {
#line 108
    frdelete(f, (ulong )0, (ulong )f->nchars);
#line 109
    (v->visible.p0) --;
#line 110
    fill(v);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
void view_show(View *v , Range r ) 
{ 
  ulong dest ;

  {
#line 121
  if (v->scroll) {
    {
#line 122
    tile_show(v->tile);
    }
  }
#line 125
  if (! v->scroll) {
    {
#line 126
    tag_show(v, r);
    }
#line 127
    return;
  }
#line 130
  if (r.p0 >= v->visible.p0) {
#line 130
    if (! (r.p1 <= v->visible.p1)) {
#line 130
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 134
    dest = text_nl(v->t, r.p0, - ((int )v->f.maxlines) / 2);
#line 135
    view_set(v, dest);
    }
#line 137
    if (r.p1 >= v->visible.p0) {
#line 137
      if (! (r.p0 <= v->visible.p1)) {
        {
#line 139
        dest = text_startOfLine(v->t, r.p0);
#line 140
        view_set(v, dest);
        }
      }
    } else {
      {
#line 139
      dest = text_startOfLine(v->t, r.p0);
#line 140
      view_set(v, dest);
      }
    }
#line 142
    if (r.p1 >= v->visible.p0) {
#line 142
      if (! (r.p0 <= v->visible.p1)) {
        {
#line 144
        view_set(v, r.p0);
        }
      }
    } else {
      {
#line 144
      view_set(v, r.p0);
      }
    }
  }
#line 152
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
void view_scroll(View *v , Mouse *m ) 
{ 
  int y ;
  ulong n ;
  ulong base ;
  int lineheight ;
  ulong runepos ;
  int tmp ;
  ulong tmp___0 ;

  {
  {
#line 158
  base = v->visible.p0;
#line 159
  lineheight = (int )(v->f.font)->height;
#line 164
  y = clip(m->xy.y - v->f.r.min.y, 0, v->f.r.max.y - v->f.r.min.y);
  }
#line 165
  if (y < (int )(v->f.font)->height) {
#line 165
    if (m->buttons != 2) {
#line 166
      y = lineheight;
#line 167
      m->xy.y += lineheight;
    }
  }
  {
#line 170
  runepos = frcharofpt(& v->f, m->xy);
  }
  {
#line 178
  if (m->buttons == 4) {
#line 178
    goto case_4;
  }
#line 181
  if (m->buttons == 1) {
#line 181
    goto case_1;
  }
#line 185
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 179
  view_set(v, base + runepos);
  }
#line 180
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 182
  tmp = back_height(v->t, v->visible.p0, v->f.font, v->f.r.max.x - v->f.r.min.x, m->xy.y - v->f.r.min.y);
#line 182
  n = (ulong )tmp;
#line 183
  view_set(v, n);
  }
#line 184
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 186
  tmp___0 = text_length(v->t);
#line 186
  runepos = (tmp___0 * (ulong )y) / (ulong )(v->f.r.max.y - v->f.r.min.y);
#line 187
  n = text_startOfLine(v->t, runepos);
#line 188
  view_set(v, n);
  }
#line 189
  if (runepos > v->visible.p1) {
    {
#line 190
    view_set(v, runepos);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vshow.c"
void view_hscroll(View *v , Bool left___0 ) 
{ 
  ulong old ;
  ulong tmp ;

  {
#line 198
  old = v->visible.p0;
#line 203
  if (left___0) {
#line 204
    if (v->visible.p0) {
#line 205
      (v->visible.p0) --;
    }
  } else {
    {
#line 207
    tmp = text_length(v->t);
    }
#line 207
    if (v->visible.p1 < tmp) {
#line 208
      (v->visible.p0) ++;
    }
  }
#line 211
  if (old != v->visible.p0) {
    {
#line 212
    frdelete(& v->f, (ulong )0, (ulong )v->f.nchars);
#line 213
    fill(v);
    }
  }
#line 215
  return;
}
}
#line 192 "./../include/libg.h"
Rectangle rcanon(Rectangle r ) ;
#line 228
void border(Bitmap *l , Rectangle r , int i , Fcode c ) ;
#line 229
void cursorswitch(Cursor___0 *c ) ;
#line 244
Mouse emouse(void) ;
#line 252
Rectangle getrect(int but , Mouse *m ) ;
#line 2741 "/usr/include/X11/Xlib.h"
extern int XGrabPointer(Display * , Window  , int  , unsigned int  , int  , int  ,
                        Window  , Cursor  , Time  ) ;
#line 3263
extern int XSetInputFocus(Display * , Window  , int  , Time  ) ;
#line 3493
extern int XUngrabPointer(Display * , Time  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/getrect.c"
static Cursor___0 sweep  =    {{-7, -7}, {(unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)224, (unsigned char)7,
               (unsigned char)224, (unsigned char)7, (unsigned char)224, (unsigned char)7,
               (unsigned char)227, (unsigned char)247, (unsigned char)227, (unsigned char)247,
               (unsigned char)227, (unsigned char)231, (unsigned char)227, (unsigned char)247,
               (unsigned char)227, (unsigned char)255, (unsigned char)227, (unsigned char)127,
               (unsigned char)224, (unsigned char)63, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255},
    {(unsigned char)0, (unsigned char)0, (unsigned char)127, (unsigned char)254, (unsigned char)64,
     (unsigned char)2, (unsigned char)64, (unsigned char)2, (unsigned char)64, (unsigned char)2,
     (unsigned char)64, (unsigned char)2, (unsigned char)64, (unsigned char)2, (unsigned char)65,
     (unsigned char)226, (unsigned char)65, (unsigned char)194, (unsigned char)65,
     (unsigned char)226, (unsigned char)65, (unsigned char)114, (unsigned char)64,
     (unsigned char)56, (unsigned char)64, (unsigned char)28, (unsigned char)64, (unsigned char)14,
     (unsigned char)127, (unsigned char)230, (unsigned char)0, (unsigned char)0},
    0};
#line 27
extern int ( /* missing proto */  sleep)() ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/getrect.c"
static void grabcursor(void) 
{ 
  int tmp ;

  {
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 22
    tmp = XGrabPointer(_dpy, (Window )screen.id, 0, (unsigned int )((((1L << 2) | (1L << 3)) | (1L << 13)) | (1L << 17)),
                       1, 1, (Window )0L, (Cursor )0L, (Time )0L);
    }
#line 22
    if (! (tmp != 0)) {
#line 22
      goto while_break;
    }
    {
#line 27
    sleep(2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 29
  XSetInputFocus(_dpy, (Window )screen.id, 2, (Time )0L);
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/getrect.c"
static void ungrabcursor(void) 
{ 


  {
  {
#line 35
  XUngrabPointer(_dpy, (Time )0L);
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/getrect.c"
Rectangle getrect(int but , Mouse *m ) 
{ 
  Rectangle r ;
  Rectangle rc ;

  {
  {
#line 42
  but = 1 << (but - 1);
#line 43
  cursorswitch(& sweep);
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! m->buttons) {
#line 44
      goto while_break;
    }
    {
#line 45
    *m = emouse();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  grabcursor();
  }
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! (! (m->buttons & but))) {
#line 47
      goto while_break___0;
    }
    {
#line 48
    *m = emouse();
    }
#line 49
    if (m->buttons & (7 ^ but)) {
#line 50
      goto Return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  r.min = m->xy;
#line 53
  r.max = m->xy;
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 55
    rc = rcanon(r);
#line 56
    border(& screen, rc, 2, (Fcode )5);
#line 57
    *m = emouse();
#line 58
    border(& screen, rc, 2, (Fcode )5);
#line 59
    r.max = m->xy;
    }
#line 54
    if (! (m->buttons & but)) {
#line 54
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  Return: 
  {
#line 63
  cursorswitch((Cursor___0 *)0);
  }
#line 64
  if (m->buttons & (7 ^ but)) {
#line 65
    rc.max.x = 0;
#line 65
    rc.min.x = rc.max.x;
#line 66
    rc.max.y = 0;
#line 66
    rc.min.y = rc.max.y;
    {
#line 67
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 67
      if (! m->buttons) {
#line 67
        goto while_break___2;
      }
      {
#line 68
      *m = emouse();
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 70
  ungrabcursor();
  }
#line 71
  return (rc);
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 75 "./../include/msg.h"
int msg_size(Msg *m ) ;
#line 76
void msg_flatten(Msg *m , uchar *buf___3 ) ;
#line 77
int msg_init(Msg *m , uchar *buf___3 ) ;
#line 78
ulong msg_bufsize(uchar *buf___3 ) ;
#line 79
void msg_print(Msg *m ) ;
#line 85
Range nr ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void run(View *v , char *cmd , char *arg ) ;
#line 79
void mbuf_init(Mbuf *m ) ;
#line 80
void mbuf_clear(Mbuf *m ) ;
#line 81
int partialmsg(Mbuf *m , int fd , int n , char *s ) ;
#line 82
Bool data_sendreplace(Data *d , Range r , Rstring s ) ;
#line 83
Bool data_sendgoto(Data *d , Range r , char *s ) ;
#line 84
Bool data_sendexec(Data *d , char *cmd , char *arg ) ;
#line 85
void data_fdstop(int fd ) ;
#line 129
void tag_setlabel(Text *t___0 , char *s ) ;
#line 130
void tag_settools(Text *t___0 , char *s ) ;
#line 131
char *tag_gettools(Text *t___0 ) ;
#line 149
Data *text_data(Text *t___0 ) ;
#line 150
View *text_view(Text *t___0 ) ;
#line 157
Bool text_badrange(Text *t___0 , Range r ) ;
#line 251
Range view_getsel(View *v ) ;
#line 260
void view_warp(View *v , Range r ) ;
#line 268
Bool view_goto(View **vp , Range *r , char *s ) ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.h"
void data_setbackup(Data *d , char *bfile ) ;
#line 65
Data *data_findid(Id id___0 ) ;
#line 66
Data *dataroot ;
#line 67
Bool data_senddestroy(Data *d ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *badrange  =    (char *)"bad range";
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *unknown  =    (char *)"unknown message type";
#line 10
static char *data_attach(Data *d , int fd , ushort emask ) ;
#line 11
static void data_changelabel(Data *d , char *label ) ;
#line 12
static char *data_getname(Data *d ) ;
#line 13
static char *data_list(void) ;
#line 14
static int msg_send(Msg *m , int fd ) ;
#line 15
static void msg_new(Msg *m ) ;
#line 16
static void msg_fillfd(Msg *m , int fd ) ;
#line 17
static Bool msg_form_and_send(Mtype t___0 , Id m , Id w , Range r , ushort flag ,
                              char *s , int fd ) ;
#line 18
static void msg_process(Msg *m , int fd ) ;
#line 19
static void msg_error(Msg *m , char *s ) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
void mbuf_init(Mbuf *m ) 
{ 


  {
#line 26
  m->buf = (char *)0;
#line 27
  m->alloced = 0;
#line 28
  m->n = 0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
void mbuf_clear(Mbuf *m ) 
{ 


  {
#line 33
  m->n = 0;
#line 34
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
int partialmsg(Mbuf *m , int fd , int n , char *s ) 
{ 
  char *ptr ;
  int left___0 ;
  void *tmp ;
  Msg msg ;
  int eaten ;
  ulong tmp___0 ;
  int tmp___1 ;
  ulong tmp___2 ;

  {
#line 49
  if (m->alloced < m->n + n) {
    {
#line 49
    m->alloced = (int )((double )(m->n + n) * 1.5);
#line 49
    tmp = srealloc((void *)m->buf, m->alloced);
#line 49
    m->buf = (char *)tmp;
    }
  }
  {
#line 50
  memcpy((void */* __restrict  */)(m->buf + m->n), (void const   */* __restrict  */)s,
         (size_t )n);
#line 51
  m->n += n;
#line 54
  ptr = m->buf;
#line 55
  left___0 = m->n;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (left___0 >= 12) {
      {
#line 56
      tmp___2 = msg_bufsize((uchar *)ptr);
      }
#line 56
      if (! ((ulong )left___0 >= tmp___2)) {
#line 56
        goto while_break;
      }
    } else {
#line 56
      goto while_break;
    }
    {
#line 58
    tmp___0 = msg_bufsize((uchar *)ptr);
#line 58
    eaten = (int )tmp___0;
#line 60
    tmp___1 = msg_init(& msg, (uchar *)ptr);
    }
#line 60
    if (tmp___1) {
#line 61
      return (-1);
    }
    {
#line 63
    ptr += eaten;
#line 64
    left___0 -= eaten;
#line 65
    msg_process(& msg, fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (left___0) {
#line 69
    if (left___0 != m->n) {
      {
#line 70
      memmove((void *)m->buf, (void const   *)ptr, (size_t )left___0);
      }
    }
  }
#line 71
  m->n = left___0;
#line 72
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
void data_fdstop(int fd ) 
{ 
  Data *d ;

  {
#line 83
  d = dataroot;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! d) {
#line 83
      goto while_break;
    }
#line 84
    if (d->fd == fd) {
#line 85
      d->fd = 0;
#line 86
      d->emask = (ushort )0;
    }
#line 83
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
Bool data_sendreplace(Data *d , Range r , Rstring s ) 
{ 
  char *buf___3 ;
  Bool retval ;
  void *tmp ;
  ulong tmp___0 ;

  {
#line 104
  if (d) {
#line 104
    if (! ((int )d->emask & 8)) {
#line 105
      return ((Bool )0);
    }
  } else {
#line 105
    return ((Bool )0);
  }
  {
#line 107
  tmp = salloc((int )((s.r1 - s.r0) * 3L));
#line 107
  buf___3 = (char *)tmp;
#line 108
  tmp___0 = texttoutf(buf___3, s.r0, s.r1);
#line 108
  *(buf___3 + tmp___0) = (char )'\000';
#line 109
  retval = msg_form_and_send((Mtype )8, 0, d->id, r, (ushort )0, buf___3, d->fd);
#line 110
  free((void *)buf___3);
  }
#line 111
  return (retval);
}
}
#line 115 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
Bool data_senddestroy(Data *d ) 
{ 
  Bool tmp ;

  {
#line 117
  if (d) {
#line 117
    if (! ((int )d->emask & 4)) {
#line 118
      return ((Bool )0);
    }
  } else {
#line 118
    return ((Bool )0);
  }
  {
#line 119
  tmp = msg_form_and_send((Mtype )4, 0, d->id, nr, (ushort )0, (char *)0, d->fd);
  }
#line 119
  return (tmp);
}
}
#line 123 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
Bool data_sendgoto(Data *d , Range r , char *s ) 
{ 
  Bool tmp ;

  {
#line 125
  if (d) {
#line 125
    if (! ((int )d->emask & 2)) {
#line 126
      return ((Bool )0);
    }
  } else {
#line 126
    return ((Bool )0);
  }
  {
#line 127
  tmp = msg_form_and_send((Mtype )2, 0, d->id, r, (ushort )0, s, d->fd);
  }
#line 127
  return (tmp);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
Bool data_sendexec(Data *d , char *cmd , char *arg ) 
{ 
  Bool retval ;
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 136
  if (d) {
#line 136
    if (! ((int )d->emask & 1)) {
#line 137
      return ((Bool )0);
    }
  } else {
#line 137
    return ((Bool )0);
  }
#line 139
  if (arg) {
    {
#line 140
    tmp = strlen((char const   *)cmd);
#line 140
    tmp___0 = strlen((char const   *)arg);
#line 140
    tmp___1 = salloc((int )((tmp + tmp___0) + 2UL));
#line 140
    s = (char *)tmp___1;
#line 141
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s %s",
            cmd, arg);
    }
  } else {
#line 143
    s = cmd;
  }
  {
#line 145
  retval = msg_form_and_send((Mtype )1, 0, d->id, nr, (ushort )0, s, d->fd);
  }
#line 146
  if (arg) {
    {
#line 147
    free((void *)s);
    }
  }
#line 148
  return (retval);
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *data_attach(Data *d , int fd , ushort emask ) 
{ 


  {
#line 157
  if (d->fd) {
#line 158
    return ((char *)"This window already attached");
  } else {
#line 160
    d->fd = fd;
#line 161
    d->emask = emask;
#line 162
    return ((char *)0);
  }
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void data_changelabel(Data *d , char *label ) 
{ 


  {
  {
#line 171
  strcpy((char */* __restrict  */)(d->label), (char const   */* __restrict  */)label);
#line 172
  tag_setlabel(d->tag, d->label);
  }
#line 173
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static Path buf  ;
#line 175 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *data_getname(Data *d ) 
{ 


  {
  {
#line 179
  label2path(buf, d->label);
  }
#line 180
  return (buf);
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *buf___0  =    (char *)0;
#line 188 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static int alloced  =    0;
#line 185 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static char *data_list(void) 
{ 
  int size ;
  Data *d ;
  char *ptr ;
  Path path ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 189
  size = 0;
#line 195
  size = 0;
#line 196
  d = dataroot;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! d) {
#line 196
      goto while_break;
    }
    {
#line 197
    label2path(path, d->label);
#line 198
    tmp = strlen((char const   *)(path));
#line 198
    size = (int )((size_t )size + (tmp + 15UL));
#line 196
    d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (size > alloced) {
    {
#line 202
    alloced = size;
#line 203
    tmp___0 = srealloc((void *)buf___0, alloced);
#line 203
    buf___0 = (char *)tmp___0;
    }
  }
#line 206
  ptr = buf___0;
#line 207
  d = dataroot;
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! d) {
#line 207
      goto while_break___0;
    }
    {
#line 208
    label2path(path, d->label);
#line 209
    sprintf((char */* __restrict  */)ptr, (char const   */* __restrict  */)"%s\t%d\n",
            path, d->id);
#line 210
    tmp___1 = strlen((char const   *)ptr);
#line 210
    ptr += tmp___1;
#line 207
    d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  return (buf___0);
}
}
#line 218 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static uchar *buf___1  =    (uchar *)0;
#line 219 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static int alloced___0  =    0;
#line 216 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static int msg_send(Msg *m , int fd ) 
{ 
  ulong size ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 220
  tmp = msg_size(m);
#line 220
  size = (ulong )tmp;
  }
#line 222
  if ((ulong )alloced___0 < size) {
    {
#line 222
    alloced___0 = (int )((double )size * 1.5);
#line 222
    tmp___0 = srealloc((void *)buf___1, alloced___0);
#line 222
    buf___1 = (uchar *)tmp___0;
    }
  }
  {
#line 223
  msg_flatten(m, buf___1);
#line 224
  tmp___1 = write(fd, (void const   *)buf___1, size);
  }
#line 224
  return ((ulong )tmp___1 != size);
}
}
#line 227 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void msg_new(Msg *m ) 
{ 
  View *v ;
  Data *d ;

  {
  {
#line 232
  v = data_find(m->s);
  }
#line 232
  if (! v) {
    {
#line 233
    v = data_open(m->s, (Bool )1);
    }
  }
  {
#line 234
  d = view_data(v);
  }
#line 236
  if (! m->flag) {
    {
#line 237
    data_setbackup(d, (char *)0);
    }
  }
#line 238
  m->w = d->id;
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void handleattach(Msg *m , Data *d , int fd ) 
{ 


  {
  {
#line 243
  m->s = data_attach(d, fd, m->flag);
  }
#line 244
  if (m->s) {
#line 245
    m->t = (Mtype )10;
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void handleread(Msg *m , Text *t___0 ) 
{ 
  Bool tmp ;

  {
  {
#line 250
  tmp = text_badrange(t___0, m->r);
  }
#line 250
  if (tmp) {
    {
#line 251
    msg_error(m, badrange);
    }
  } else {
    {
#line 253
    m->s = text_duputf(t___0, m->r);
    }
  }
#line 255
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void handlereplace(Msg *m , Text *t___0 ) 
{ 
  Bool tmp ;

  {
  {
#line 259
  tmp = text_badrange(t___0, m->r);
  }
#line 259
  if (tmp) {
    {
#line 260
    msg_error(m, badrange);
    }
  } else {
    {
#line 262
    text_replaceutf(t___0, m->r, m->s);
    }
  }
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void handlegoto(Msg *m , View *v ) 
{ 
  Bool show ;
  Range r ;
  int tmp ;
  Text *tmp___0 ;
  Data *tmp___1 ;
  Bool tmp___2 ;

  {
#line 271
  if ((unsigned int )m->t == 2U) {
#line 271
    tmp = 1;
  } else
#line 271
  if (m->flag) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  show = (Bool )tmp;
#line 276
  r = m->r;
#line 277
  if (r.p0 > r.p1) {
    {
#line 278
    r = view_getsel(v);
    }
  }
  {
#line 280
  tmp___2 = view_goto(& v, & r, m->s);
  }
#line 280
  if (tmp___2) {
#line 281
    if (show) {
      {
#line 282
      view_show(v, r);
#line 283
      view_select(v, r);
#line 284
      view_warp(v, r);
      }
    }
    {
#line 286
    m->r = r;
#line 287
    tmp___0 = view_text(v);
#line 287
    tmp___1 = text_data(tmp___0);
#line 287
    m->w = tmp___1->id;
    }
  } else {
#line 290
    m->r.p0 = (ulong )-1;
#line 291
    m->r.p1 = (ulong )0;
  }
#line 293
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void msg_error(Msg *m , char *s ) 
{ 


  {
#line 297
  m->s = s;
#line 298
  m->t = (Mtype )10;
#line 299
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void msg_fillfd(Msg *m , int fd ) 
{ 
  Data *d ;
  View *v ;

  {
#line 304
  d = (Data *)0;
  {
#line 310
  if ((unsigned int )m->t == 11U) {
#line 310
    goto case_11;
  }
#line 311
  if ((unsigned int )m->t == 13U) {
#line 311
    goto case_13;
  }
#line 312
  goto switch_default;
  case_11: /* CIL Label */ 
  {
#line 310
  m->s = data_list();
  }
#line 310
  return;
  case_13: /* CIL Label */ 
  {
#line 311
  msg_new(m);
  }
#line 311
  return;
  switch_default: /* CIL Label */ 
#line 312
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 315
  d = data_findid(m->w);
  }
#line 315
  if (! d) {
    {
#line 316
    msg_error(m, (char *)"No window with this id");
    }
#line 317
    return;
  }
  {
#line 320
  v = text_view(d->t);
  }
  {
#line 323
  if ((unsigned int )m->t == 15U) {
#line 323
    goto case_15;
  }
#line 324
  if ((unsigned int )m->t == 17U) {
#line 324
    goto case_17;
  }
#line 325
  if ((unsigned int )m->t == 19U) {
#line 325
    goto case_19;
  }
#line 326
  if ((unsigned int )m->t == 21U) {
#line 326
    goto case_21;
  }
#line 327
  if ((unsigned int )m->t == 23U) {
#line 327
    goto case_23;
  }
#line 328
  if ((unsigned int )m->t == 25U) {
#line 328
    goto case_25;
  }
#line 329
  if ((unsigned int )m->t == 8U) {
#line 329
    goto case_8;
  }
#line 330
  if ((unsigned int )m->t == 27U) {
#line 330
    goto case_27;
  }
#line 332
  if ((unsigned int )m->t == 1U) {
#line 332
    goto case_1;
  }
#line 332
  if ((unsigned int )m->t == 29U) {
#line 332
    goto case_1;
  }
#line 334
  if ((unsigned int )m->t == 2U) {
#line 334
    goto case_2;
  }
#line 334
  if ((unsigned int )m->t == 31U) {
#line 334
    goto case_2;
  }
#line 335
  goto switch_default___0;
  case_15: /* CIL Label */ 
  {
#line 323
  handleattach(m, d, fd);
  }
#line 323
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
#line 324
  data_changelabel(d, m->s);
  }
#line 324
  goto switch_break___0;
  case_19: /* CIL Label */ 
  {
#line 325
  m->s = data_getname(d);
  }
#line 325
  goto switch_break___0;
  case_21: /* CIL Label */ 
  {
#line 326
  tag_settools(d->tag, m->s);
  }
#line 326
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 327
  m->s = tag_gettools(d->tag);
  }
#line 327
  goto switch_break___0;
  case_25: /* CIL Label */ 
  {
#line 328
  handleread(m, d->t);
  }
#line 328
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 329
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 330
  handlereplace(m, d->t);
  }
#line 330
  goto switch_break___0;
  case_1: /* CIL Label */ 
  case_29: /* CIL Label */ 
  {
#line 332
  run(v, m->s, (char *)0);
  }
#line 332
  goto switch_break___0;
  case_2: /* CIL Label */ 
  case_31: /* CIL Label */ 
  {
#line 334
  handlegoto(m, v);
  }
#line 334
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 335
  msg_error(m, unknown);
  }
#line 335
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 337
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static Bool msg_form_and_send(Mtype t___0 , Id m , Id w , Range r , ushort flag ,
                              char *s , int fd ) 
{ 
  Msg msg ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 343
  msg.t = t___0;
#line 344
  msg.m = m;
#line 345
  msg.w = w;
#line 346
  msg.r = r;
#line 347
  msg.flag = flag;
#line 348
  msg.s = s;
#line 350
  tmp = msg_send(& msg, fd);
  }
#line 350
  if (tmp) {
#line 350
    tmp___0 = 0;
  } else {
#line 350
    tmp___0 = 1;
  }
#line 350
  return ((Bool )tmp___0);
}
}
#line 354 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/msg.c"
static void msg_process(Msg *m , int fd ) 
{ 
  Bool isbounce ;

  {
  {
#line 358
  isbounce = (Bool )((unsigned int )m->t < 9U);
#line 360
  msg_fillfd(m, fd);
  }
#line 362
  if (! isbounce) {
#line 363
    if ((unsigned int )m->t != 10U) {
#line 364
      m->t = (Mtype )((unsigned int )m->t + 1U);
    }
    {
#line 365
    msg_send(m, fd);
    }
  } else
#line 366
  if ((unsigned int )m->t == 10U) {
    {
#line 367
    diag((char *)0, (char *)"error from bounced event %s", m->s);
#line 368
    msg_print(m);
    }
  }
#line 370
  return;
}
}
#line 181 "./../include/libg.h"
Point add(Point a , Point b ) ;
#line 183
Point mul(Point a , int b ) ;
#line 184
Point divpt(Point a , int b ) ;
#line 185
Rectangle rsubp(Rectangle r , Point p ) ;
#line 186
Rectangle raddp(Rectangle r , Point p ) ;
#line 187
Rectangle inset(Rectangle r , int n ) ;
#line 188
Rectangle rmul(Rectangle r , int a ) ;
#line 189
Rectangle rdiv(Rectangle r , int a ) ;
#line 190
Rectangle rshift(Rectangle r , int a ) ;
#line 191
int rectinrect(Rectangle r , Rectangle s ) ;
#line 224
int ptinrect(Point p , Rectangle r ) ;
#line 225
int rectXrect(Rectangle r , Rectangle s ) ;
#line 226
int eqpt(Point p , Point q ) ;
#line 227
int eqrect(Rectangle r , Rectangle s ) ;
#line 269
Rectangle Rect(int x1 , int y1 , int x2 , int y2 ) ;
#line 270
Rectangle Rpt(Point p1 , Point p2 ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Point add(Point a , Point b ) 
{ 


  {
#line 8
  a.x += b.x;
#line 9
  a.y += b.y;
#line 10
  return (a);
}
}
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Point sub(Point a , Point b ) 
{ 


  {
#line 16
  a.x -= b.x;
#line 17
  a.y -= b.y;
#line 18
  return (a);
}
}
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle inset(Rectangle r , int n ) 
{ 


  {
#line 24
  r.min.x += n;
#line 25
  r.min.y += n;
#line 26
  r.max.x -= n;
#line 27
  r.max.y -= n;
#line 28
  return (r);
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Point divpt(Point a , int b ) 
{ 


  {
#line 34
  a.x /= b;
#line 35
  a.y /= b;
#line 36
  return (a);
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Point mul(Point a , int b ) 
{ 


  {
#line 42
  a.x *= b;
#line 43
  a.y *= b;
#line 44
  return (a);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle rsubp(Rectangle r , Point p ) 
{ 


  {
#line 50
  r.min.x -= p.x;
#line 51
  r.min.y -= p.y;
#line 52
  r.max.x -= p.x;
#line 53
  r.max.y -= p.y;
#line 54
  return (r);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle raddp(Rectangle r , Point p ) 
{ 


  {
#line 60
  r.min.x += p.x;
#line 61
  r.min.y += p.y;
#line 62
  r.max.x += p.x;
#line 63
  r.max.y += p.y;
#line 64
  return (r);
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle rmul(Rectangle r , int a ) 
{ 


  {
#line 70
  if (a != 1) {
#line 71
    r.min.x *= a;
#line 72
    r.min.y *= a;
#line 73
    r.max.x *= a;
#line 74
    r.max.y *= a;
  }
#line 76
  return (r);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle rdiv(Rectangle r , int a ) 
{ 


  {
#line 82
  if (a != 1) {
#line 83
    r.min.x /= a;
#line 84
    r.min.y /= a;
#line 85
    r.max.x /= a;
#line 86
    r.max.y /= a;
  }
#line 88
  return (r);
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle rshift(Rectangle r , int a ) 
{ 


  {
#line 94
  if (a > 0) {
#line 95
    r.min.x <<= a;
#line 96
    r.min.y <<= a;
#line 97
    r.max.x <<= a;
#line 98
    r.max.y <<= a;
  } else
#line 100
  if (a < 0) {
#line 101
    a = - a;
#line 102
    r.min.x >>= a;
#line 103
    r.min.y >>= a;
#line 104
    r.max.x >>= a;
#line 105
    r.max.y >>= a;
  }
#line 107
  return (r);
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
int eqpt(Point p , Point q ) 
{ 
  int tmp ;

  {
#line 112
  if (p.x == q.x) {
#line 112
    if (p.y == q.y) {
#line 112
      tmp = 1;
    } else {
#line 112
      tmp = 0;
    }
  } else {
#line 112
    tmp = 0;
  }
#line 112
  return (tmp);
}
}
#line 115 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
int eqrect(Rectangle r , Rectangle s ) 
{ 
  int tmp ;

  {
#line 117
  if (r.min.x == s.min.x) {
#line 117
    if (r.max.x == s.max.x) {
#line 117
      if (r.min.y == s.min.y) {
#line 117
        if (r.max.y == s.max.y) {
#line 117
          tmp = 1;
        } else {
#line 117
          tmp = 0;
        }
      } else {
#line 117
        tmp = 0;
      }
    } else {
#line 117
      tmp = 0;
    }
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
int rectXrect(Rectangle r , Rectangle s ) 
{ 
  int tmp ;

  {
#line 123
  if (r.min.x < s.max.x) {
#line 123
    if (s.min.x < r.max.x) {
#line 123
      if (r.min.y < s.max.y) {
#line 123
        if (s.min.y < r.max.y) {
#line 123
          tmp = 1;
        } else {
#line 123
          tmp = 0;
        }
      } else {
#line 123
        tmp = 0;
      }
    } else {
#line 123
      tmp = 0;
    }
  } else {
#line 123
    tmp = 0;
  }
#line 123
  return (tmp);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
int rectinrect(Rectangle r , Rectangle s ) 
{ 
  int tmp ;

  {
#line 131
  if (r.min.x >= s.min.x) {
#line 131
    if (r.min.x < s.max.x) {
#line 131
      if (r.min.y >= s.min.y) {
#line 131
        if (! (r.min.y < s.max.y)) {
#line 133
          return (0);
        }
      } else {
#line 133
        return (0);
      }
    } else {
#line 133
      return (0);
    }
  } else {
#line 133
    return (0);
  }
#line 134
  if (r.max.x <= s.max.x) {
#line 134
    if (r.max.y <= s.max.y) {
#line 134
      tmp = 1;
    } else {
#line 134
      tmp = 0;
    }
  } else {
#line 134
    tmp = 0;
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
int ptinrect(Point p , Rectangle r ) 
{ 
  int tmp ;

  {
#line 139
  if (p.x >= r.min.x) {
#line 139
    if (p.x < r.max.x) {
#line 139
      if (p.y >= r.min.y) {
#line 139
        if (p.y < r.max.y) {
#line 139
          tmp = 1;
        } else {
#line 139
          tmp = 0;
        }
      } else {
#line 139
        tmp = 0;
      }
    } else {
#line 139
      tmp = 0;
    }
  } else {
#line 139
    tmp = 0;
  }
#line 139
  return (tmp);
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle rcanon(Rectangle r ) 
{ 
  int t___0 ;

  {
#line 147
  if (r.max.x < r.min.x) {
#line 148
    t___0 = r.min.x;
#line 149
    r.min.x = r.max.x;
#line 150
    r.max.x = t___0;
  }
#line 152
  if (r.max.y < r.min.y) {
#line 153
    t___0 = r.min.y;
#line 154
    r.min.y = r.max.y;
#line 155
    r.max.y = t___0;
  }
#line 157
  return (r);
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle Rect(int x1 , int y1 , int x2 , int y2 ) 
{ 
  Rectangle r ;

  {
#line 165
  r.min.x = x1;
#line 166
  r.min.y = y1;
#line 167
  r.max.x = x2;
#line 168
  r.max.y = y2;
#line 169
  return (r);
}
}
#line 172 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Rectangle Rpt(Point p1 , Point p2 ) 
{ 
  Rectangle r ;

  {
#line 177
  r.min = p1;
#line 178
  r.max = p2;
#line 179
  return (r);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arith.c"
Point Pt(int x , int y ) 
{ 
  Point p ;

  {
#line 187
  p.x = x;
#line 188
  p.y = y;
#line 189
  return (p);
}
}
#line 199 "./../include/libg.h"
void bitblt(Bitmap *d , Point p , Bitmap *s , Rectangle r , Fcode f ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/border.c"
void border(Bitmap *l , Rectangle r , int i , Fcode c ) 
{ 
  Rectangle tmp ;
  Rectangle tmp___0 ;
  Point tmp___1 ;
  Rectangle tmp___2 ;
  Point tmp___3 ;
  Rectangle tmp___4 ;
  Point tmp___5 ;
  Rectangle tmp___6 ;
  Point tmp___7 ;
  Rectangle tmp___8 ;
  Point tmp___9 ;
  Rectangle tmp___10 ;
  Point tmp___11 ;
  Rectangle tmp___12 ;
  Point tmp___13 ;

  {
#line 8
  if (i > 0) {
    {
#line 9
    tmp = Rect(r.min.x, r.min.y, r.max.x, r.min.y + i);
#line 9
    bitblt(l, r.min, l, tmp, c);
#line 11
    tmp___0 = Rect(r.min.x, r.max.y - i, r.max.x, r.max.y);
#line 11
    tmp___1 = Pt(r.min.x, r.max.y - i);
#line 11
    bitblt(l, tmp___1, l, tmp___0, c);
#line 13
    tmp___2 = Rect(r.min.x, r.min.y + i, r.min.x + i, r.max.y - i);
#line 13
    tmp___3 = Pt(r.min.x, r.min.y + i);
#line 13
    bitblt(l, tmp___3, l, tmp___2, c);
#line 15
    tmp___4 = Rect(r.max.x - i, r.min.y + i, r.max.x, r.max.y - i);
#line 15
    tmp___5 = Pt(r.max.x - i, r.min.y + i);
#line 15
    bitblt(l, tmp___5, l, tmp___4, c);
    }
  } else
#line 17
  if (i < 0) {
    {
#line 18
    tmp___6 = Rect(r.min.x, r.min.y + i, r.max.x, r.min.y);
#line 18
    tmp___7 = Pt(r.min.x, r.min.y + i);
#line 18
    bitblt(l, tmp___7, l, tmp___6, c);
#line 20
    tmp___8 = Rect(r.min.x, r.max.y, r.max.x, r.max.y - i);
#line 20
    tmp___9 = Pt(r.min.x, r.max.y);
#line 20
    bitblt(l, tmp___9, l, tmp___8, c);
#line 22
    tmp___10 = Rect(r.min.x + i, r.min.y + i, r.min.x, r.max.y - i);
#line 22
    tmp___11 = Pt(r.min.x + i, r.min.y + i);
#line 22
    bitblt(l, tmp___11, l, tmp___10, c);
#line 24
    tmp___12 = Rect(r.max.x, r.min.y + i, r.max.x - i, r.max.y - i);
#line 24
    tmp___13 = Pt(r.max.x, r.min.y + i);
#line 24
    bitblt(l, tmp___13, l, tmp___12, c);
    }
  }
#line 27
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
Tile *wily ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Tile *findcol(char *label ) ;
#line 95
void placedcol(char *label , Tile *c ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
Tile *biggest_visible(Tile *start , Tile *end ) ;
#line 51
Tile *last_visible(Tile *start , Tile *end ) ;
#line 64
Bool list_contains(Tile *start , Tile *end , Tile *want ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static Tile *placetable[401]  ;
#line 11
static Bool iserror(char *label ) ;
#line 12
static Bool validcolumn(Tile *c ) ;
#line 13
static unsigned long hashpath(char *path ) ;
#line 14
static Tile *find(char *label ) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
void placedcol(char *label , Tile *c ) 
{ 
  unsigned long tmp ;
  Bool tmp___0 ;

  {
#line 19
  if (label) {
    {
#line 19
    tmp___0 = iserror(label);
    }
#line 19
    if (! tmp___0) {
      {
#line 20
      tmp = hashpath(label);
#line 20
      placetable[tmp] = c;
      }
    }
  }
#line 21
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
Tile *findcol(char *label ) 
{ 
  Tile *c ;
  Tile *tmp ;
  Bool tmp___0 ;

  {
#line 28
  if (! wily->down) {
    {
#line 29
    col_new(wily->tag, (char *)0);
    }
#line 30
    return (wily->down);
  }
  {
#line 33
  tmp___0 = iserror(label);
  }
#line 33
  if (tmp___0) {
    {
#line 34
    tmp = last_visible(wily->down, (Tile *)0);
    }
#line 34
    return (tmp);
  }
  {
#line 36
  c = find(label);
  }
#line 36
  if (! c) {
    {
#line 37
    c = biggest_visible(wily->down, (Tile *)0);
#line 39
    placedcol(label, c);
    }
  }
#line 41
  return (c);
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static char *errors  =    (char *)"+Errors";
#line 48 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static Bool iserror(char *label ) 
{ 
  int elen ;
  size_t tmp ;
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 51
  tmp = strlen((char const   *)errors);
#line 51
  elen = (int )tmp;
#line 52
  tmp___0 = strlen((char const   *)label);
#line 52
  len = (int )tmp___0;
  }
#line 54
  if (len >= elen) {
    {
#line 54
    tmp___1 = strncmp((char const   *)(label + (len - elen)), (char const   *)errors,
                      (size_t )elen);
    }
#line 54
    if (tmp___1) {
#line 54
      tmp___2 = 0;
    } else {
#line 54
      tmp___2 = 1;
    }
  } else {
#line 54
    tmp___2 = 0;
  }
#line 54
  return ((Bool )tmp___2);
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static Bool validcolumn(Tile *c ) 
{ 
  Bool tmp ;

  {
  {
#line 61
  tmp = list_contains(wily->down, (Tile *)0, c);
  }
#line 61
  return (tmp);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static unsigned long hashpath(char *path ) 
{ 
  char *s ;
  unsigned long hash ;

  {
  {
#line 69
  hash = 0UL;
#line 73
  s = strrchr((char const   *)path, '/');
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )path < (unsigned long )s)) {
#line 73
      goto while_break;
    }
#line 74
    hash = (hash << 5) ^ (unsigned long )*path;
#line 73
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (hash % 401UL);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/place.c"
static Tile *find(char *label ) 
{ 
  Tile *c ;
  unsigned long tmp ;
  Bool tmp___0 ;

  {
#line 83
  if (label) {
    {
#line 84
    tmp = hashpath(label);
#line 84
    c = placetable[tmp];
#line 85
    tmp___0 = validcolumn(c);
    }
#line 85
    if (tmp___0) {
#line 86
      return (c);
    }
  }
#line 88
  return ((Tile *)0);
}
}
#line 207 "./../include/libg.h"
int cachechars(Font___0 *f , char **s , void *cp , int max , int *wp , unsigned short *fp ) ;
#line 217
Point strsize(Font___0 *f , char *s ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/strwidth.c"
long strwidth(Font___0 *f , char *s ) 
{ 
  int wid ;
  int twid ;
  Rune cbuf[128] ;
  unsigned short fbuf[128] ;
  Rune r ;
  int tmp ;
  int tmp___0 ;

  {
#line 15
  twid = 0;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! *s) {
#line 16
      goto while_break;
    }
    {
#line 18
    tmp___0 = cachechars(f, & s, (void *)(cbuf), 128, & wid, fbuf);
    }
#line 18
    if (tmp___0 <= 0) {
      {
#line 19
      tmp = chartorune(& r, s);
#line 19
      s += tmp;
      }
    } else {
#line 21
      twid += wid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return ((long )twid);
}
}
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/strwidth.c"
Point strsize(Font___0 *f , char *s ) 
{ 
  long tmp ;
  Point tmp___0 ;

  {
  {
#line 29
  tmp = strwidth(f, s);
#line 29
  tmp___0 = Pt((int )tmp, (int )f->height);
  }
#line 29
  return (tmp___0);
}
}
#line 40 "./../include/frame.h"
void frinsert(Frame *f , Rune *sp , Rune *ep , ulong p0 ) ;
#line 42
void frselectp(Frame *f , Fcode c ) ;
#line 44
void frinit(Frame *f , Rectangle r , Font___0 *ft , Bitmap *b ) ;
#line 46
void frclear(Frame *f ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
int tagheight ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Bool data_isdirty(Data *d ) ;
#line 109
void scroll_setrects(Scroll *s , Bitmap *b , Rectangle r ) ;
#line 110
void scroll_set(Scroll *s , ulong thumb , ulong extent , ulong max ) ;
#line 169
ulong text_ncopy(Text *t___0 , Rune *buf___3 , ulong p , ulong n ) ;
#line 174
Bool text_refreshdir(Text *t___0 ) ;
#line 230
void view_fillbutton(View *v , Fcode f ) ;
#line 233
int snapheight(View *v , int h ) ;
#line 234
void view_reshaped(View *v , Rectangle r ) ;
#line 235
int view_lastlinepos(View *v ) ;
#line 236
int view_stripwhitespace(View *v ) ;
#line 258
void view_border(View *v , Bool set ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static Rectangle snap(View *v , Rectangle r ) ;
#line 9
static Rectangle resizebox(Rectangle r ) ;
#line 10
static void rfill(Rectangle r , Fcode f ) ;
#line 11
static void button_set(View *v ) ;
#line 12
static void setrects(View *v , Rectangle r ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
void view_fillbutton(View *v , Fcode f ) 
{ 
  Rectangle tmp ;

  {
  {
#line 16
  tmp = resizebox(v->r);
#line 16
  rfill(tmp, f);
  }
#line 17
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
void fill(View *v ) 
{ 
  Frame *f ;
  ulong p ;
  Rune buf___3[512] ;
  int n ;
  Text *t___0 ;
  Bool tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 29
  f = & v->f;
#line 33
  t___0 = v->t;
#line 37
  if (! f->b) {
#line 38
    return;
  }
#line 41
  p = v->visible.p0 + (ulong )f->nchars;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp = frame_isfull(f);
    }
#line 42
    if (tmp) {
#line 42
      goto while_break;
    } else {
      {
#line 42
      tmp___0 = text_ncopy(t___0, buf___3, p, (ulong )512);
#line 42
      n = (int )tmp___0;
      }
#line 42
      if (! n) {
#line 42
        goto while_break;
      }
    }
    {
#line 43
    frinsert(f, buf___3, buf___3 + n, (ulong )f->nchars);
#line 44
    p += (ulong )n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  v->visible.p1 = v->visible.p0 + (ulong )f->nchars;
#line 49
  if (v->scroll) {
    {
#line 50
    tmp___1 = text_length(v->t);
#line 50
    scroll_set(v->scroll, v->visible.p0, (ulong )f->nchars, tmp___1);
    }
  } else {
    {
#line 54
    button_set(v);
    }
  }
  {
#line 57
  frselectp(f, (Fcode )5);
#line 58
  tmp___2 = clip((int )(v->sel.p0 - v->visible.p0), 0, (int )f->nchars);
#line 58
  f->p0 = (ulong )tmp___2;
#line 59
  tmp___3 = clip((int )(v->sel.p1 - v->visible.p0), 0, (int )f->nchars);
#line 59
  f->p1 = (ulong )tmp___3;
#line 60
  frselectp(f, (Fcode )5);
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
int snapheight(View *v , int h ) 
{ 
  int lines ;
  int fh ;
  int brdr ;

  {
#line 68
  fh = (int )(v->f.font)->height;
#line 69
  brdr = 8;
#line 71
  if (v->scroll) {
#line 72
    lines = (h - brdr) / fh;
#line 73
    if (lines == 0) {
#line 74
      return (0);
    } else {
#line 76
      return (h);
    }
  } else {
#line 78
    return (brdr + fh);
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
void view_reshaped(View *v , Rectangle r ) 
{ 
  Frame *f ;
  ulong tmp ;
  ulong tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 88
  r = snap(v, r);
#line 89
  setrects(v, r);
  }
#line 90
  if ((unsigned long )v->f.b != (unsigned long )((Bitmap *)0)) {
    {
#line 91
    tmp___1 = text_refreshdir(v->t);
    }
#line 91
    if (tmp___1) {
      {
#line 92
      tmp___0 = (ulong )0;
#line 92
      v->sel.p1 = tmp___0;
#line 92
      tmp = tmp___0;
#line 92
      v->sel.p0 = tmp;
#line 92
      v->visible.p0 = tmp;
#line 93
      frdelete(& v->f, (ulong )0, (ulong )v->f.nchars);
      }
    }
    {
#line 95
    fill(v);
#line 98
    f = & v->f;
#line 101
    r.min = frptofchar(f, (ulong )((int )f->nchars + 1));
#line 101
    r.max = r.min;
#line 102
    r.max.x = f->r.max.x;
#line 103
    r.max.y += (int )(f->font)->height;
    }
#line 104
    if (r.min.x != r.max.x) {
      {
#line 105
      bitblt(& screen, r.min, & screen, r, (Fcode )0);
      }
    }
#line 108
    r.min.x = f->r.min.x;
#line 109
    r.min.y = r.max.y;
#line 110
    r.max.y = v->r.max.y;
#line 111
    if (r.min.y != r.max.y) {
      {
#line 112
      bitblt(& screen, r.min, & screen, r, (Fcode )0);
      }
    }
    {
#line 114
    view_border(v, (Bool )((unsigned long )v == (unsigned long )last_selection));
    }
  }
#line 116
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
int view_lastlinepos(View *v ) 
{ 
  Frame *f ;
  Point p ;
  Point tmp ;
  int y ;
  int tmp___0 ;

  {
  {
#line 121
  f = & v->f;
#line 122
  tmp = frptofchar(f, (ulong )f->nchars);
#line 122
  p = tmp;
#line 123
  y = p.y + (int )(f->font)->height;
  }
#line 125
  if (y < f->r.max.y) {
#line 125
    tmp___0 = y;
  } else {
#line 125
    tmp___0 = f->r.max.y;
  }
#line 125
  return (tmp___0);
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
int view_stripwhitespace(View *v ) 
{ 
  Frame *f ;
  int blanklines ;

  {
#line 134
  if (v) {
#line 134
    if ((unsigned long )v->f.b != (unsigned long )((Bitmap *)0)) {
#line 135
      f = & v->f;
#line 137
      blanklines = (int )f->maxlines - (int )f->nlines;
#line 138
      if (blanklines > 0) {
#line 139
        return (blanklines * (int )(f->font)->height);
      }
    }
  }
#line 142
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static Rectangle snap(View *v , Rectangle r ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = snapheight(v, r.max.y - r.min.y);
#line 147
  r.max.y = r.min.y + tmp;
  }
#line 148
  return (r);
}
}
#line 152 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static void rfill(Rectangle r , Fcode f ) 
{ 


  {
  {
#line 154
  r = inset(r, 2);
#line 155
  bitblt(& screen, r.min, & screen, r, f);
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static Rectangle resizebox(Rectangle r ) 
{ 


  {
  {
#line 160
  r = inset(r, 4);
#line 161
  r.max.x = r.min.x + 13;
  }
#line 162
  return (r);
}
}
#line 165 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static void button_set(View *v ) 
{ 
  Rectangle r ;
  View *tmp ;
  Data *tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 170
  r = resizebox(v->r);
#line 171
  border(& screen, r, 1, (Fcode )15);
#line 172
  tmp = tile_body(v->tile);
#line 172
  tmp___0 = view_data(tmp);
#line 172
  tmp___1 = data_isdirty(tmp___0);
  }
#line 172
  if (tmp___1) {
    {
#line 173
    rfill(r, (Fcode )15);
    }
  }
#line 174
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vgeom.c"
static void setrects(View *v , Rectangle r ) 
{ 
  Frame *f ;
  Font___0 *ft ;
  Rectangle scrollr ;
  Rectangle framer ;
  Bitmap *b ;

  {
  {
#line 182
  f = & v->f;
#line 183
  ft = f->font;
#line 189
  scrollr = inset(r, 4);
#line 190
  scrollr.max.x = scrollr.min.x + 13;
#line 192
  framer = inset(r, 4);
#line 193
  framer.min.x += 13;
#line 194
  framer.min.x += 4;
  }
#line 197
  if (r.max.y - r.min.y < tagheight) {
#line 197
    b = (Bitmap *)0;
  } else {
#line 197
    b = & screen;
  }
  {
#line 199
  v->r = r;
#line 200
  scroll_setrects(v->scroll, b, scrollr);
#line 201
  frclear(f);
#line 202
  frinit(f, framer, ft, b);
  }
#line 203
  return;
}
}
#line 42 "./../include/libc.h"
int fullrune(char *str___1 , int n ) ;
#line 48
char *utfrune(char *s , long c ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
int chartorune(Rune *rune , char *str___1 ) 
{ 
  int c ;
  int c1 ;
  int c2 ;
  long l ;

  {
#line 40
  c = (int )*((uchar *)str___1);
#line 41
  if (c < 128) {
#line 42
    *rune = (Rune )c;
#line 43
    return (1);
  }
#line 50
  c1 = (int )*((uchar *)(str___1 + 1)) ^ 128;
#line 51
  if (c1 & 192) {
#line 52
    goto bad;
  }
#line 53
  if (c < 224) {
#line 54
    if (c < 192) {
#line 55
      goto bad;
    }
#line 56
    l = (long )(((c << 6) | c1) & 2047);
#line 57
    if (l <= 127L) {
#line 58
      goto bad;
    }
#line 59
    *rune = (Rune )l;
#line 60
    return (2);
  }
#line 67
  c2 = (int )*((uchar *)(str___1 + 2)) ^ 128;
#line 68
  if (c2 & 192) {
#line 69
    goto bad;
  }
#line 70
  if (c < 240) {
#line 71
    l = (long )(((((c << 6) | c1) << 6) | c2) & 65535);
#line 72
    if (l <= 2047L) {
#line 73
      goto bad;
    }
#line 74
    *rune = (Rune )l;
#line 75
    return (3);
  }
  bad: 
#line 82
  *rune = (Rune )128;
#line 83
  return (1);
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
int runetochar(char *str___1 , Rune *rune ) 
{ 
  long c ;

  {
#line 95
  c = (long )*rune;
#line 96
  if (c <= 127L) {
#line 97
    *(str___1 + 0) = (char )c;
#line 98
    return (1);
  }
#line 105
  if (c <= 2047L) {
#line 106
    *(str___1 + 0) = (char )(192L | (c >> 6));
#line 107
    *(str___1 + 1) = (char )(128L | (c & 63L));
#line 108
    return (2);
  }
#line 115
  *(str___1 + 0) = (char )(224L | (c >> 12));
#line 116
  *(str___1 + 1) = (char )(128L | ((c >> 6) & 63L));
#line 117
  *(str___1 + 2) = (char )(128L | (c & 63L));
#line 118
  return (3);
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
int runelen(long c ) 
{ 
  Rune rune ;
  char str___1[10] ;
  int tmp ;

  {
  {
#line 127
  rune = (Rune )c;
#line 128
  tmp = runetochar(str___1, & rune);
  }
#line 128
  return (tmp);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
int fullrune(char *str___1 , int n ) 
{ 
  int c ;

  {
#line 136
  if (n > 0) {
#line 137
    c = (int )*((uchar *)str___1);
#line 138
    if (c < 128) {
#line 139
      return (1);
    }
#line 140
    if (n > 1) {
#line 141
      if (c < 224) {
#line 142
        return (1);
      } else
#line 141
      if (n > 2) {
#line 142
        return (1);
      }
    }
  }
#line 144
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
char *utfrune(char *s , long c ) 
{ 
  long c1 ;
  Rune r ;
  int n ;
  char *tmp ;

  {
#line 154
  if (c < 128L) {
    {
#line 155
    tmp = strchr((char const   *)s, (int )c);
    }
#line 155
    return (tmp);
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    c1 = (long )*((uchar *)s);
#line 159
    if (c1 < 128L) {
#line 160
      if (c1 == 0L) {
#line 161
        return ((char *)0);
      }
#line 162
      if (c1 == c) {
#line 163
        return (s);
      }
#line 164
      s ++;
#line 165
      goto __Cont;
    }
    {
#line 167
    n = chartorune(& r, s);
    }
#line 168
    if ((long )r == c) {
#line 169
      return (s);
    }
#line 170
    s += n;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return ((char *)0);
}
}
#line 175 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rune.c"
long utflen(char *s ) 
{ 
  int c ;
  long n ;
  Rune rune ;
  int tmp ;

  {
#line 182
  n = 0L;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    c = (int )*((uchar *)s);
#line 185
    if (c < 128) {
#line 186
      if (c == 0) {
#line 187
        return (n);
      }
#line 188
      s ++;
    } else {
      {
#line 190
      tmp = chartorune(& rune, s);
#line 190
      s += tmp;
      }
    }
#line 191
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (0L);
}
}
#line 240 "./../include/libg.h"
unsigned long etimer(unsigned long key , long n ) ;
#line 241
void estoptimer(unsigned long key ) ;
#line 243
unsigned long eread(unsigned long keys , Event *e ) ;
#line 43 "./../include/frame.h"
void frselectf(Frame *f , Point p0 , Point p1 , Fcode c ) ;
#line 120 "./../include/msg.h"
ulong pclipr(ulong p , Range r ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Range text_doubleclick(Text *t___0 , ulong p0 ) ;
#line 121
Range vselect(View *v , Mouse *m ) ;
#line 261
void view_setlastselection(View *v ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void frselectf2(Frame *f , Point p0 , Point p1 , Fcode c ) ;
#line 10
static void dclick(View *v , ulong click , ulong *p0 , ulong *p1 ) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static ulong usub(ulong a , ulong b ) 
{ 
  ulong tmp ;

  {
#line 20
  if (a > b) {
#line 20
    tmp = a - b;
  } else {
#line 20
    tmp = (ulong )0;
  }
#line 20
  return (tmp);
}
}
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void update(View *v , void (*fn)(Frame * , Point  , Point  , Fcode  ) , ulong p0 ,
                   ulong p1 , ulong q ) 
{ 
  Frame *f ;
  Point pt0 ;
  Point pt1 ;
  Point qt ;
  ulong tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;

  {
  {
#line 29
  f = & v->f;
#line 32
  tmp = usub(p0, v->visible.p0);
#line 32
  pt0 = frptofchar(f, tmp);
#line 33
  tmp___0 = usub(p1, v->visible.p0);
#line 33
  pt1 = frptofchar(f, tmp___0);
#line 34
  tmp___1 = usub(q, v->visible.p0);
#line 34
  qt = frptofchar(f, tmp___1);
  }
#line 36
  if (p0 == p1) {
    {
#line 37
    (*fn)(f, pt0, pt1, (Fcode )5);
    }
  }
#line 38
  if (p1 < q) {
    {
#line 39
    (*fn)(f, pt1, qt, (Fcode )5);
    }
  } else {
    {
#line 41
    (*fn)(f, qt, pt1, (Fcode )5);
    }
  }
#line 42
  if (p0 == q) {
    {
#line 43
    (*fn)(f, pt0, qt, (Fcode )5);
    }
  }
#line 45
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void toggle(View *v , void (*fn)(Frame * , Point  , Point  , Fcode  ) , ulong p0 ,
                   ulong p1 ) 
{ 
  Frame *f ;
  Point pt0 ;
  Point pt1 ;
  ulong tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;
  ulong tmp___2 ;

  {
#line 51
  f = & v->f;
#line 54
  if (p0 < p1) {
#line 54
    tmp = p0;
  } else {
#line 54
    tmp = p1;
  }
  {
#line 54
  tmp___0 = usub(tmp, v->visible.p0);
#line 54
  pt0 = frptofchar(f, tmp___0);
  }
#line 55
  if (p0 > p1) {
#line 55
    tmp___1 = p0;
  } else {
#line 55
    tmp___1 = p1;
  }
  {
#line 55
  tmp___2 = usub(tmp___1, v->visible.p0);
#line 55
  pt1 = frptofchar(f, tmp___2);
#line 57
  (*fn)(f, pt0, pt1, (Fcode )5);
  }
#line 58
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void move(View *v , void (*fn)(Frame * , Point  , Point  , Fcode  ) , Point pt ,
                 ulong p0 , ulong p1 ) 
{ 
  Rectangle r ;
  Text *tmp ;
  ulong tmp___0 ;

  {
#line 65
  r = v->f.r;
#line 86
  if (v->scroll) {
#line 86
    if (pt.y >= r.min.y) {
#line 86
      if (pt.y <= r.max.y) {
#line 89
        return;
      } else {
#line 86
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 86
    if (pt.y < r.min.y) {
#line 86
      if (v->visible.p0 == 0UL) {
#line 89
        return;
      } else {
#line 86
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 86
    if (pt.y > r.max.y) {
      {
#line 86
      tmp = view_text(v);
      }
#line 86
      if (v->visible.p1 == tmp->length) {
#line 89
        return;
      }
    }
  }
  {
#line 91
  toggle(v, fn, p0, p1);
#line 92
  tmp___0 = (ulong )0;
#line 92
  v->f.p1 = tmp___0;
#line 92
  v->f.p0 = tmp___0;
  }
#line 94
  if (v->scroll) {
#line 95
    if (pt.y < r.min.y) {
      {
#line 96
      view_linesdown(v, 2, (Bool )0);
      }
    } else
#line 97
    if (pt.y > r.max.y) {
      {
#line 98
      view_linesdown(v, 2, (Bool )1);
      }
    }
  } else
#line 100
  if (pt.x < r.min.x) {
    {
#line 101
    view_hscroll(v, (Bool )1);
    }
  } else
#line 102
  if (pt.x > r.max.x) {
    {
#line 103
    view_hscroll(v, (Bool )0);
    }
  }
  {
#line 105
  toggle(v, fn, p0, p1);
  }
#line 106
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static Range follow(View *v , ulong oldq , ulong p0 , ulong p1 , Bool selecting ,
                    Mouse *m ) 
{ 
  ulong buttons ;
  Frame *f ;
  ulong q ;
  Event e ;
  ulong type ;
  ulong timer ;
  void (*fn)(Frame * , Point  , Point  , Fcode  ) ;
  ulong tmp ;
  int tmp___0 ;
  ulong tmp___1 ;
  ulong tmp___2 ;
  Range tmp___3 ;

  {
#line 115
  buttons = (ulong )m->buttons;
#line 116
  f = & v->f;
#line 119
  timer = (ulong )0;
#line 122
  if (selecting) {
#line 122
    fn = & frselectf;
  } else {
#line 122
    fn = & frselectf2;
  }
  {
#line 123
  toggle(v, fn, p0, p1);
#line 124
  v->selecting = (Bool )1;
#line 126
  *m = emouse();
#line 127
  type = (ulong )0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((ulong )m->buttons == buttons)) {
#line 128
      goto while_break;
    }
    {
#line 129
    tmp = frcharofpt(f, m->xy);
#line 129
    q = tmp + v->visible.p0;
    }
#line 132
    if (selecting) {
      {
#line 134
      tmp___0 = ptinrect(m->xy, f->r);
      }
#line 134
      if (tmp___0) {
#line 135
        if (timer) {
          {
#line 136
          estoptimer(timer);
#line 137
          timer = (ulong )0;
          }
        }
      } else {
#line 141
        if (timer == type) {
          {
#line 142
          move(v, fn, m->xy, p0, p1);
          }
        } else
#line 141
        if (timer == 0UL) {
          {
#line 142
          move(v, fn, m->xy, p0, p1);
          }
        }
#line 143
        if (timer == 0UL) {
          {
#line 144
          timer = etimer(0UL, 100L);
          }
        }
      }
    }
#line 147
    if (q != oldq) {
#line 147
      if (p1 != q) {
        {
#line 148
        update(v, fn, p0, p1, q);
#line 149
        p1 = q;
#line 149
        oldq = p1;
        }
      }
    }
    {
#line 151
    type = eread(1UL | timer, & e);
    }
#line 151
    if (type == 1UL) {
#line 152
      *m = e.mouse;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  v->selecting = (Bool )0;
#line 155
  if (timer) {
    {
#line 156
    estoptimer(timer);
    }
  }
#line 158
  if (p0 > p1) {
#line 158
    tmp___1 = p0;
  } else {
#line 158
    tmp___1 = p1;
  }
#line 158
  if (p0 < p1) {
#line 158
    tmp___2 = p0;
  } else {
#line 158
    tmp___2 = p1;
  }
  {
#line 158
  tmp___3 = range(tmp___2, tmp___1);
  }
#line 158
  return (tmp___3);
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
Range vselect(View *v , Mouse *m ) 
{ 
  Frame *f ;
  Bool selecting ;
  ulong orig ;
  ulong p0 ;
  ulong p1 ;
  Range sel___0 ;
  ulong tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;
  Point tmp___2 ;
  Point tmp___3 ;

  {
  {
#line 167
  f = & v->f;
#line 172
  tmp = frcharofpt(f, m->xy);
#line 172
  p1 = tmp + v->visible.p0;
#line 172
  p0 = p1;
#line 172
  orig = p0;
#line 174
  selecting = (Bool )(m->buttons & 1);
  }
#line 176
  if (selecting) {
    {
#line 177
    frselectp(f, (Fcode )5);
#line 178
    view_setlastselection(v);
#line 179
    dclick(v, m->msec, & p0, & p1);
    }
  }
  {
#line 182
  sel___0 = follow(v, orig, p0, p1, selecting, m);
  }
#line 184
  if (selecting) {
    {
#line 185
    v->sel = sel___0;
#line 186
    v->anchor = sel___0.p1;
#line 187
    tmp___0 = pclipr(sel___0.p0, v->visible);
#line 187
    f->p0 = tmp___0 - v->visible.p0;
#line 188
    tmp___1 = pclipr(sel___0.p1, v->visible);
#line 188
    f->p1 = tmp___1 - v->visible.p0;
    }
  } else {
    {
#line 190
    tmp___2 = frptofchar(f, sel___0.p1 - v->visible.p0);
#line 190
    tmp___3 = frptofchar(f, sel___0.p0 - v->visible.p0);
#line 190
    frselectf2(f, tmp___3, tmp___2, (Fcode )5);
    }
  }
#line 195
  return (sel___0);
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void frselectf2(Frame *f , Point p0 , Point p1 , Fcode c ) 
{ 
  int n ;
  int ht ;
  Rectangle tmp ;
  Rectangle tmp___0 ;
  Rectangle tmp___1 ;
  Point tmp___2 ;
  Rectangle tmp___3 ;
  Point tmp___4 ;

  {
#line 205
  if (p0.x == (int )f->left) {
#line 206
    p0.x = f->r.min.x;
  }
#line 207
  if (p1.x == (int )f->left) {
#line 208
    p1.x = f->r.min.x;
  }
#line 209
  ht = (int )(f->font)->height;
#line 210
  n = (p1.y - p0.y) / ht;
#line 215
  p1.y = p0.y + ht;
#line 217
  p0.y = p1.y - 2;
#line 218
  if ((unsigned long )f->b == (unsigned long )((Bitmap *)0)) {
    {
#line 219
    berror((char *)"frselect2 b==0");
    }
  }
#line 220
  if (p0.y == f->r.max.y) {
#line 221
    return;
  }
#line 222
  if (n == 0) {
#line 223
    if (p0.x == p1.x) {
#line 224
      if (p0.x == f->r.min.x) {
#line 225
        (p1.x) ++;
      } else {
#line 227
        (p0.x) --;
      }
    }
    {
#line 228
    tmp = Rpt(p0, p1);
#line 228
    bitblt(f->b, p0, f->b, tmp, c);
    }
  } else {
#line 231
    if (p0.x >= f->r.max.x) {
#line 232
      p0.x = f->r.max.x - 1;
    }
    {
#line 233
    tmp___0 = Rect(p0.x, p0.y, f->r.max.x, p1.y);
#line 233
    bitblt(f->b, p0, f->b, tmp___0, c);
    }
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
#line 234
      n --;
#line 234
      if (! (n > 0)) {
#line 234
        goto while_break;
      }
      {
#line 235
      p0.y += ht;
#line 236
      p1.y += ht;
#line 237
      tmp___1 = Rect(f->r.min.x, p0.y, f->r.max.x, p1.y);
#line 237
      tmp___2 = Pt(f->r.min.x, p0.y);
#line 237
      bitblt(f->b, tmp___2, f->b, tmp___1, c);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 240
    p0.y += ht;
#line 241
    p1.y += ht;
#line 242
    tmp___3 = Rect(f->r.min.x, p0.y, p1.x, p1.y);
#line 242
    tmp___4 = Pt(f->r.min.x, p0.y);
#line 242
    bitblt(f->b, tmp___4, f->b, tmp___3, c);
    }
  }
#line 245
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static ulong lastclick  ;
#line 250 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/select.c"
static void dclick(View *v , ulong click , ulong *p0 , ulong *p1 ) 
{ 
  Range sel___0 ;

  {
#line 257
  if (v->sel.p0 == *p0) {
#line 257
    if (click < lastclick + 500UL) {
      {
#line 258
      sel___0 = text_doubleclick(v->t, *p0);
#line 259
      *p0 = sel___0.p0;
#line 260
      *p1 = sel___0.p1;
#line 261
      lastclick = (ulong )0;
      }
    } else {
#line 263
      lastclick = click;
    }
  } else {
#line 263
    lastclick = click;
  }
#line 265
  return;
}
}
#line 209 "./../include/libg.h"
void segment(Bitmap *d , Point p1 , Point p2 , int v , Fcode f ) ;
#line 2354 "/usr/include/X11/Xlib.h"
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/segment.c"
void segment(Bitmap *d , Point p1 , Point p2 , int v , Fcode f ) 
{ 
  int x1 ;
  int y1 ;
  int x2 ;
  int y2 ;
  GC g ;

  {
#line 12
  x1 = p1.x;
#line 13
  y1 = p1.y;
#line 14
  x2 = p2.x;
#line 15
  y2 = p2.y;
#line 16
  if (d->flag & 32) {
#line 17
    x1 -= d->r.min.x;
#line 18
    y1 -= d->r.min.y;
#line 19
    x2 -= d->r.min.x;
#line 20
    y2 -= d->r.min.y;
  }
  {
#line 22
  g = _getfillgc(f, d, (unsigned long )v);
#line 23
  XDrawLine(_dpy, (Drawable )d->id, g, x1, y1, x2, y2);
  }
#line 24
  return;
}
}
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/path.c"
static char *gettilde(char const   *s ) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/path.c"
static void expand(char *dest , char *orig , char *(*expansion)(char const   * ) ) 
{ 
  Path key ;
  char *val ;
  char *slash ;
  char const   *tmp ;

  {
  {
#line 22
  strcpy((char */* __restrict  */)(key), (char const   */* __restrict  */)(orig + 1));
#line 23
  slash = strchr((char const   *)(key), '/');
  }
#line 23
  if (slash) {
#line 24
    *slash = (char)0;
  }
  {
#line 26
  val = (*expansion)((char const   *)(key));
  }
#line 27
  if (slash) {
#line 28
    *slash = (char )'/';
  }
#line 29
  if (val) {
#line 30
    if (slash) {
#line 30
      tmp = (char const   *)slash;
    } else {
#line 30
      tmp = "";
    }
    {
#line 30
    sprintf((char */* __restrict  */)dest, (char const   */* __restrict  */)"%s%s",
            val, tmp);
    }
  } else {
    {
#line 32
    strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)orig);
    }
  }
#line 34
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/path.c"
void label2path(char *path , char *label ) 
{ 


  {
#line 39
  if (! label) {
    {
#line 40
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)(wilydir));
    }
#line 41
    return;
  }
  {
#line 44
  if ((int )*(label + 0) == 36) {
#line 44
    goto case_36;
  }
#line 45
  if ((int )*(label + 0) == 126) {
#line 45
    goto case_126;
  }
#line 46
  if ((int )*(label + 0) == 47) {
#line 46
    goto case_47;
  }
#line 47
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 44
  expand(path, label, (char *(*)(char const   * ))(& getenv));
  }
#line 44
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 45
  expand(path, label, & gettilde);
  }
#line 45
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 46
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)label);
  }
#line 46
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 47
  sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s%s",
          wilydir, label);
  }
#line 47
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 49
  labelclean(path);
  }
#line 50
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/path.c"
void labelclean(char *label ) 
{ 
  char *slash ;
  char *from ;
  char *to ;
  char c ;
  char *back ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 62
  slash = strchr((char const   *)label, '/');
  }
#line 63
  if (slash) {
#line 64
    to = slash + 1;
#line 64
    from = to;
  } else {
#line 66
    return;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((int )*(from + 0) != 0)) {
#line 69
      goto while_break;
    }
    {
#line 72
    if ((int )*(from + 0) == 47) {
#line 72
      goto case_47;
    }
#line 75
    if ((int )*(from + 0) == 46) {
#line 75
      goto case_46;
    }
#line 94
    goto switch_default;
    case_47: /* CIL Label */ 
#line 73
    from ++;
#line 74
    goto while_continue;
    case_46: /* CIL Label */ 
    {
#line 78
    if ((int )*(from + 1) == 47) {
#line 78
      goto case_47___0;
    }
#line 78
    if ((int )*(from + 1) == 0) {
#line 78
      goto case_47___0;
    }
#line 81
    if ((int )*(from + 1) == 46) {
#line 81
      goto case_46___0;
    }
#line 76
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 79
    from ++;
#line 80
    goto while_continue;
    case_46___0: /* CIL Label */ 
#line 82
    if ((int )*(from + 2) == 0) {
#line 82
      goto _L;
    } else
#line 82
    if ((int )*(from + 2) == 47) {
      _L: /* CIL Label */ 
      {
#line 83
      from += 2;
#line 84
      *(to + -1) = (char )'\000';
#line 85
      back = strrchr((char const   *)label, '/');
      }
#line 86
      if (back) {
#line 87
        to = back + 1;
      } else {
#line 89
        *(to + -1) = (char )'/';
      }
#line 91
      goto while_continue;
    }
    switch_break___0: /* CIL Label */ ;
    }
    switch_default: /* CIL Label */ 
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      tmp = to;
#line 96
      to ++;
#line 96
      tmp___1 = from;
#line 96
      from ++;
#line 96
      tmp___0 = *tmp___1;
#line 96
      *tmp = tmp___0;
#line 96
      c = tmp___0;
#line 95
      if ((int )c != 0) {
#line 95
        if (! ((int )c != 47)) {
#line 95
          goto while_break___0;
        }
      } else {
#line 95
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 98
    from --;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  *to = (char )'\000';
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/path.c"
static char *gettilde(char const   *s ) 
{ 
  struct passwd *pw ;
  struct passwd *tmp___0 ;
  __uid_t tmp___1 ;
  struct passwd *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 108
  tmp___3 = strlen(s);
  }
#line 108
  if (tmp___3) {
    {
#line 108
    tmp___0 = getpwnam(s);
#line 108
    pw = tmp___0;
    }
  } else {
    {
#line 108
    tmp___1 = getuid();
#line 108
    tmp___2 = getpwuid(tmp___1);
#line 108
    pw = tmp___2;
    }
  }
#line 109
  if (pw) {
#line 109
    tmp___4 = pw->pw_dir;
  } else {
#line 109
    tmp___4 = (char *)0;
  }
#line 109
  return (tmp___4);
}
}
#line 208 "./../include/libg.h"
Point string(Bitmap *b , Point p , Font___0 *ft , char *s , Fcode f ) ;
#line 219
void texture(Bitmap *d , Rectangle r , Bitmap *s , Fcode f ) ;
#line 234
int clipr(Bitmap *d , Rectangle r ) ;
#line 251
int menuhit(int but , Mouse *m , Menu *menu ) ;
#line 277
Font___0 *font ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static Bitmap *menutxt  ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static uchar menutxtbits[32]  = 
#line 21
  {      (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136, 
        (uchar )34,      (uchar )34,      (uchar )136,      (uchar )136};
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static Rectangle menurect(Rectangle r , int i ) 
{ 
  Rectangle tmp ;
  Rectangle tmp___0 ;

  {
#line 35
  if (i < 0) {
    {
#line 36
    tmp = Rect(0, 0, 0, 0);
    }
#line 36
    return (tmp);
  }
  {
#line 37
  r.min.y += ((int )font->height + 1) * i;
#line 38
  r.max.y = (r.min.y + (int )font->height) + 1;
#line 39
  tmp___0 = inset(r, -1);
  }
#line 39
  return (tmp___0);
}
}
#line 46 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static int menusel(Rectangle r , Point p ) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = ptinrect(p, r);
  }
#line 49
  if (! tmp) {
#line 50
    return (-1);
  }
#line 51
  return ((p.y - r.min.y) / ((int )font->height + 1));
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static int menuscan(int but , Mouse *m , Rectangle menur , int lasti ) 
{ 
  int i ;
  Rectangle r ;

  {
  {
#line 66
  r = menurect(menur, lasti);
#line 67
  bitblt(& screen, r.min, & screen, r, (Fcode )5);
#line 68
  *m = emouse();
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (m->buttons & (1 << (but - 1)))) {
#line 69
      goto while_break;
    }
    {
#line 70
    *m = emouse();
#line 71
    i = menusel(menur, m->xy);
    }
#line 72
    if (i == lasti) {
#line 73
      goto while_continue;
    }
    {
#line 74
    bitblt(& screen, r.min, & screen, r, (Fcode )5);
    }
#line 75
    if (i == -1) {
#line 76
      return (i);
    }
    {
#line 77
    r = menurect(menur, i);
#line 78
    bitblt(& screen, r.min, & screen, r, (Fcode )5);
#line 79
    lasti = i;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (lasti);
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
void menupaint(Menu *menu , Rectangle textr , int off , int nitemdrawn ) 
{ 
  int i ;
  Point pt ;
  Rectangle r ;
  char *item ;
  char *tmp ;
  long tmp___0 ;
  Point tmp___1 ;

  {
  {
#line 92
  r = inset(textr, -1);
#line 93
  bitblt(& screen, r.min, & screen, r, (Fcode )0);
#line 94
  pt = Pt(textr.min.x + textr.max.x, textr.min.y);
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < nitemdrawn)) {
#line 95
      goto while_break;
    }
#line 96
    if (menu->item) {
#line 96
      item = *(menu->item + (i + off));
    } else {
      {
#line 96
      tmp = (*(menu->gen))(i + off);
#line 96
      item = tmp;
      }
    }
    {
#line 97
    tmp___0 = strwidth(font, item);
#line 97
    tmp___1 = Pt((int )(((long )pt.x - tmp___0) / 2L), pt.y);
#line 97
    string(& screen, tmp___1, font, item, (Fcode )12);
#line 95
    i ++;
#line 95
    pt.y += (int )font->height + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
static void menuscrollpaint(Rectangle scrollr , int off , int nitem , int nitemdrawn ) 
{ 
  Rectangle r ;
  Rectangle tmp ;
  Rectangle tmp___0 ;

  {
  {
#line 108
  bitblt(& screen, scrollr.min, & screen, scrollr, (Fcode )0);
#line 109
  r.min.x = scrollr.min.x;
#line 110
  r.max.x = scrollr.max.x;
#line 111
  r.min.y = scrollr.min.y + ((scrollr.max.y - scrollr.min.y) * off) / nitem;
#line 112
  r.max.y = scrollr.min.y + ((scrollr.max.y - scrollr.min.y) * (off + nitemdrawn)) / nitem;
  }
#line 113
  if (r.max.y < r.min.y + 2) {
#line 114
    r.max.y = r.min.y + 2;
  }
  {
#line 115
  border(& screen, r, 1, (Fcode )15);
  }
#line 116
  if ((unsigned long )menutxt == (unsigned long )((Bitmap *)0)) {
    {
#line 117
    tmp = Rect(0, 0, 16, 16);
#line 117
    menutxt = balloc(tmp, 0);
    }
#line 118
    if (menutxt) {
      {
#line 119
      wrbitmap(menutxt, 0, 16, menutxtbits);
      }
    }
  }
#line 121
  if (menutxt) {
    {
#line 122
    tmp___0 = inset(r, 1);
#line 122
    texture(& screen, tmp___0, menutxt, (Fcode )12);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/menuhit.c"
int menuhit(int but , Mouse *m , Menu *menu ) 
{ 
  int i ;
  int nitem ;
  int nitemdrawn ;
  int maxwid ;
  int lasti ;
  int off ;
  int noff ;
  int wid ;
  int screenitem ;
  int scrolling ;
  Rectangle r ;
  Rectangle menur ;
  Rectangle sc ;
  Rectangle textr ;
  Rectangle scrollr ;
  Bitmap *b ;
  Point pt ;
  char *item ;
  long tmp ;
  char *tmp___0 ;
  Rectangle tmp___1 ;
  Point tmp___2 ;
  Point tmp___3 ;
  Point tmp___4 ;
  Point tmp___5 ;
  Point tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 135
  sc = screen.clipr;
#line 136
  clipr(& screen, screen.r);
#line 137
  maxwid = 0;
#line 138
  nitem = 0;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (menu->item) {
#line 138
      item = *(menu->item + nitem);
    } else {
      {
#line 138
      tmp___0 = (*(menu->gen))(nitem);
#line 138
      item = tmp___0;
      }
    }
#line 138
    if (! item) {
#line 138
      goto while_break;
    }
    {
#line 141
    tmp = strwidth(font, item);
#line 141
    i = (int )tmp;
    }
#line 142
    if (i > maxwid) {
#line 143
      maxwid = i;
    }
#line 138
    nitem ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (menu->lasthit < 0) {
#line 146
    menu->lasthit = 0;
  } else
#line 145
  if (menu->lasthit >= nitem) {
#line 146
    menu->lasthit = 0;
  }
#line 147
  screenitem = ((screen.r.max.y - screen.r.min.y) - 10) / ((int )font->height + 1);
#line 148
  if (nitem > 25) {
#line 148
    goto _L;
  } else
#line 148
  if (nitem > screenitem) {
    _L: /* CIL Label */ 
#line 149
    scrolling = 1;
#line 150
    nitemdrawn = 20;
#line 151
    if (nitemdrawn > screenitem) {
#line 152
      nitemdrawn = screenitem;
    }
#line 153
    wid = (maxwid + 4) + 14;
#line 154
    off = menu->lasthit - nitemdrawn / 2;
#line 155
    if (off < 0) {
#line 156
      off = 0;
    }
#line 157
    if (off > nitem - nitemdrawn) {
#line 158
      off = nitem - nitemdrawn;
    }
#line 159
    lasti = menu->lasthit - off;
  } else {
#line 161
    scrolling = 0;
#line 162
    nitemdrawn = nitem;
#line 163
    wid = maxwid;
#line 164
    off = 0;
#line 165
    lasti = menu->lasthit;
  }
  {
#line 167
  tmp___1 = Rect(0, 0, wid, nitemdrawn * ((int )font->height + 1));
#line 167
  r = inset(tmp___1, -3);
#line 168
  tmp___2 = Pt(wid / 2, lasti * ((int )font->height + 1) + (int )font->height / 2);
#line 168
  r = rsubp(r, tmp___2);
#line 169
  r = raddp(r, m->xy);
#line 170
  pt = Pt(0, 0);
  }
#line 171
  if (r.max.x > screen.r.max.x) {
#line 172
    pt.x = screen.r.max.x - r.max.x;
  }
#line 173
  if (r.max.y > screen.r.max.y) {
#line 174
    pt.y = screen.r.max.y - r.max.y;
  }
#line 175
  if (r.min.x < screen.r.min.x) {
#line 176
    pt.x = screen.r.min.x - r.min.x;
  }
#line 177
  if (r.min.y < screen.r.min.y) {
#line 178
    pt.y = screen.r.min.y - r.min.y;
  }
  {
#line 179
  menur = raddp(r, pt);
#line 180
  textr.max.x = menur.max.x - 3;
#line 181
  textr.min.x = textr.max.x - maxwid;
#line 182
  textr.min.y = menur.min.y + 3;
#line 183
  textr.max.y = textr.min.y + nitemdrawn * ((int )font->height + 1);
  }
#line 184
  if (scrolling) {
    {
#line 185
    scrollr = inset(menur, 2);
#line 186
    scrollr.max.x = scrollr.min.x + 14;
    }
  } else {
    {
#line 188
    scrollr = Rect(0, 0, 0, 0);
    }
  }
  {
#line 190
  b = balloc(menur, screen.ldepth);
  }
#line 191
  if ((unsigned long )b == (unsigned long )((Bitmap *)0)) {
#line 192
    b = & screen;
  }
  {
#line 193
  bitblt(b, menur.min, & screen, menur, (Fcode )12);
#line 194
  bitblt(& screen, menur.min, & screen, menur, (Fcode )0);
#line 195
  border(& screen, menur, 1, (Fcode )15);
#line 196
  r = menurect(textr, lasti);
#line 197
  tmp___3 = add(r.min, r.max);
#line 197
  tmp___4 = divpt(tmp___3, 2);
#line 197
  cursorset(tmp___4);
#line 198
  menupaint(menu, textr, off, nitemdrawn);
  }
#line 199
  if (scrolling) {
    {
#line 200
    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    }
  }
  {
#line 201
  r = menurect(textr, lasti);
#line 202
  tmp___5 = add(r.min, r.max);
#line 202
  tmp___6 = divpt(tmp___5, 2);
#line 202
  cursorset(tmp___6);
#line 203
  menupaint(menu, textr, off, nitemdrawn);
  }
#line 204
  if (scrolling) {
    {
#line 205
    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    }
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 206
    if (! (m->buttons & (1 << (but - 1)))) {
#line 206
      goto while_break___0;
    }
    {
#line 207
    lasti = menuscan(but, m, textr, lasti);
    }
#line 208
    if (lasti >= 0) {
#line 209
      goto while_break___0;
    }
    {
#line 210
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 210
      tmp___8 = ptinrect(m->xy, textr);
      }
#line 210
      if (tmp___8) {
#line 210
        goto while_break___1;
      } else
#line 210
      if (! (m->buttons & (1 << (but - 1)))) {
#line 210
        goto while_break___1;
      }
#line 211
      if (scrolling) {
        {
#line 211
        tmp___7 = ptinrect(m->xy, scrollr);
        }
#line 211
        if (tmp___7) {
#line 212
          noff = ((m->xy.y - scrollr.min.y) * nitem) / (scrollr.max.y - scrollr.min.y);
#line 213
          noff -= nitemdrawn / 2;
#line 214
          if (noff < 0) {
#line 215
            noff = 0;
          }
#line 216
          if (noff > nitem - nitemdrawn) {
#line 217
            noff = nitem - nitemdrawn;
          }
#line 218
          if (noff != off) {
            {
#line 219
            off = noff;
#line 220
            menupaint(menu, textr, off, nitemdrawn);
#line 221
            menuscrollpaint(scrollr, off, nitem, nitemdrawn);
            }
          }
        }
      }
      {
#line 224
      *m = emouse();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 227
  bitblt(& screen, menur.min, b, menur, (Fcode )12);
  }
#line 228
  if ((unsigned long )b != (unsigned long )(& screen)) {
    {
#line 229
    bfree(b);
    }
  }
  {
#line 230
  clipr(& screen, sc);
  }
#line 231
  if (lasti >= 0) {
#line 232
    menu->lasthit = lasti + off;
#line 233
    return (menu->lasthit);
  }
#line 235
  return (-1);
}
}
#line 2196 "/usr/include/X11/Xlib.h"
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2216
extern int XCopyPlane(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                      unsigned int  , int  , int  , unsigned long  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
GC _getcopygc(Fcode f , Bitmap *db , Bitmap *sb , int *bltfunc ) ;
#line 45
Bitmap *_balloc(Rectangle r , int ldepth ) ;
#line 56
unsigned long _ld2dmask[6] ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/bitblt.c"
void bitblt(Bitmap *d , Point p , Bitmap *s , Rectangle r , Fcode f ) 
{ 
  int sx ;
  int sy ;
  int dx ;
  int dy ;
  int bfunc ;
  GC g ;
  unsigned long plane ;
  Bitmap *btmp ;
  Rectangle tmp ;

  {
#line 14
  if (r.max.x - r.min.x <= 0) {
#line 15
    return;
  } else
#line 14
  if (r.max.y - r.min.y <= 0) {
#line 15
    return;
  }
#line 16
  sx = r.min.x;
#line 17
  sy = r.min.y;
#line 18
  if (s->flag & 32) {
#line 19
    sx -= s->r.min.x;
#line 20
    sy -= s->r.min.y;
  }
#line 22
  dx = p.x;
#line 23
  dy = p.y;
#line 24
  if (d->flag & 32) {
#line 25
    dx -= d->r.min.x;
#line 26
    dy -= d->r.min.y;
  }
  {
#line 28
  g = _getcopygc(f, d, s, & bfunc);
  }
#line 29
  if (bfunc == 0) {
    {
#line 30
    XCopyArea(_dpy, (Drawable )s->id, (Drawable )d->id, g, sx, sy, (unsigned int )(r.max.x - r.min.x),
              (unsigned int )(r.max.y - r.min.y), dx, dy);
    }
  } else
#line 32
  if (bfunc == 2) {
    {
#line 33
    XFillRectangle(_dpy, (Drawable )d->id, g, dx, dy, (unsigned int )(r.max.x - r.min.x),
                   (unsigned int )(r.max.y - r.min.y));
    }
  } else {
    {
#line 37
    plane = _ld2dmask[s->ldepth];
#line 38
    plane &= ~ (plane >> 1);
#line 50
    tmp = Rect(0, 0, r.max.x - r.min.x, r.max.y - r.min.y);
#line 50
    btmp = _balloc(tmp, d->ldepth);
#line 51
    XCopyPlane(_dpy, (Drawable )s->id, (Drawable )btmp->id, g, sx, sy, (unsigned int )(r.max.x - r.min.x),
               (unsigned int )(r.max.y - r.min.y), 0, 0, plane);
#line 53
    bitblt(d, p, btmp, btmp->r, f);
#line 54
    bfree(btmp);
    }
  }
#line 58
  return;
}
}
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 238 "./../include/libg.h"
unsigned long estart(unsigned long key , int fd , int n ) ;
#line 239
void estop(unsigned long key ) ;
#line 71 "./../include/msg.h"
int wily_connect(char *addrname , int n ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *whitespace ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void event_wellknown(int fd ) ;
#line 40
int event_outputstart(int fd , int pid , char *cmd , char *label , View *v ) ;
#line 41
void keytab_init(void) ;
#line 42
void dofd(ulong key , int n , char *s ) ;
#line 256
void view_pipe(View *v , Bool *first , char *s , int n ) ;
#line 276
void addrunning(char *cmd ) ;
#line 277
void rmrunning(char *cmd ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static Key keytab[16]  ;
#line 61
static Key *key_find(ulong key ) ;
#line 62
static void outmsg(Key *k , int n , char *s ) ;
#line 63
static void key_del(Key *k ) ;
#line 64
static Key *key_new(ulong key , int fd , Keytype t___0 ) ;
#line 65
static Key *key_findcmd(char *cmd ) ;
#line 66
static void oneword(char *s , char *l ) ;
#line 67
static void output(Key *k , int n , char *s ) ;
#line 68
static void ex_accept(int n , char *s ) ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
void keytab_init(void) 
{ 
  Key *k ;
  ulong key ;

  {
#line 74
  key = (ulong )1;
#line 76
  k = keytab;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )k < (unsigned long )(keytab + 16))) {
#line 76
      goto while_break;
    }
    {
#line 77
    k->t = (Keytype )0;
#line 78
    k->key = key;
#line 79
    key *= 2UL;
#line 80
    mbuf_init(& k->buf);
#line 76
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
int event_outputstart(int fd , int pid , char *cmd , char *label , View *v ) 
{ 
  ulong key ;
  Key *k ;

  {
  {
#line 95
  key = estart(0UL, fd, 0);
  }
#line 95
  if (! key) {
    {
#line 96
    diag((char *)0, (char *)"estart");
    }
#line 97
    return (-1);
  }
  {
#line 99
  k = key_new(key, fd, (Keytype )2);
#line 100
  k->pid = pid;
#line 101
  k->v = v;
  }
#line 106
  if (k->v) {
#line 107
    k->first = (Bool )1;
  } else {
    {
#line 109
    oneword(k->cmd, cmd);
#line 110
    olabel(k->olabel, label);
#line 111
    addrunning(k->cmd);
    }
  }
#line 113
  return (0);
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
void event_wellknown(int fd ) 
{ 
  ulong key ;

  {
  {
#line 121
  key = estart(0UL, fd, 0);
  }
#line 121
  if (! key) {
    {
#line 122
    error((char *)"estart");
    }
  }
  {
#line 123
  key_new(key, fd, (Keytype )1);
  }
#line 124
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
void dofd(ulong key , int n , char *s ) 
{ 
  Key *k ;
  Key *tmp ;

  {
  {
#line 132
  tmp = key_find(key);
#line 132
  k = tmp;
  }
#line 134
  if (! n) {
    {
#line 135
    key_del(k);
    }
#line 136
    return;
  }
  {
#line 140
  if ((unsigned int )k->t == 1U) {
#line 140
    goto case_1;
  }
#line 141
  if ((unsigned int )k->t == 2U) {
#line 141
    goto case_2;
  }
#line 142
  if ((unsigned int )k->t == 3U) {
#line 142
    goto case_3;
  }
#line 143
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 140
  ex_accept(n, s);
  }
#line 140
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 141
  output(k, n, s);
  }
#line 141
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 142
  outmsg(k, n, s);
  }
#line 142
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 143
  error((char *)"bad key type %d", (unsigned int )k->t);
  }
#line 143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
void kill_all(char *s ) 
{ 
  Key *k ;
  char const   *sep ;
  int tmp ;

  {
  {
#line 153
  k = (Key *)0;
#line 154
  sep = " \t\n";
#line 156
  s = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)sep);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! s) {
#line 156
      goto while_break;
    }
    {
#line 157
    k = key_findcmd(s);
    }
#line 157
    if (k) {
      {
#line 160
      tmp = kill(- k->pid, 9);
      }
#line 160
      if (tmp) {
        {
#line 161
        diag((char *)0, (char *)"kill %s", s);
        }
      }
    }
    {
#line 156
    s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)sep);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
void kill_list(void) 
{ 
  Key *k ;

  {
#line 171
  k = keytab;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )k < (unsigned long )(keytab + 16))) {
#line 171
      goto while_break;
    }
#line 172
    if ((unsigned int )k->t == 2U) {
#line 172
      if (! k->v) {
        {
#line 173
        diag((char *)0, (char *)"Kill %s", k->cmd);
        }
      }
    }
#line 171
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static void outmsg(Key *k , int n , char *s ) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = partialmsg(& k->buf, k->fd, n, s);
  }
#line 181
  if (tmp) {
    {
#line 182
    diag((char *)0, (char *)"Received bad message, closing connection");
#line 183
    key_del(k);
    }
  }
#line 185
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static void key_del(Key *k ) 
{ 


  {
  {
#line 190
  close(k->fd);
#line 191
  estop(k->key);
  }
  {
#line 194
  if ((unsigned int )k->t == 2U) {
#line 194
    goto case_2;
  }
#line 195
  if ((unsigned int )k->t == 3U) {
#line 195
    goto case_3;
  }
#line 196
  if ((unsigned int )k->t == 1U) {
#line 196
    goto case_1;
  }
#line 197
  goto switch_default;
  case_2: /* CIL Label */ 
#line 194
  if (! k->v) {
    {
#line 194
    rmrunning(k->cmd);
    }
  }
#line 194
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 195
  data_fdstop(k->fd);
  }
#line 195
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 196
  error((char *)"Klisten closed");
  }
  switch_default: /* CIL Label */ 
  {
#line 197
  error((char *)"bad key type %d", (unsigned int )k->t);
  }
  switch_break: /* CIL Label */ ;
  }
#line 199
  k->t = (Keytype )0;
#line 200
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static Key *key_new(ulong key , int fd , Keytype t___0 ) 
{ 
  Key *k ;

  {
  {
#line 207
  k = key_find(key);
#line 209
  k->fd = fd;
#line 210
  k->t = t___0;
  }
#line 211
  return (k);
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static Key *key_findcmd(char *cmd ) 
{ 
  Key *k ;
  int tmp ;

  {
#line 220
  k = keytab;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ((unsigned long )k < (unsigned long )(keytab + 16))) {
#line 220
      goto while_break;
    }
#line 221
    if ((unsigned int )k->t == 2U) {
      {
#line 221
      tmp = strcmp((char const   *)cmd, (char const   *)(k->cmd));
      }
#line 221
      if (! tmp) {
#line 222
        return (k);
      }
    }
#line 220
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return ((Key *)0);
}
}
#line 227 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static void oneword(char *s , char *l ) 
{ 


  {
  {
#line 229
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)l);
#line 232
  s = strpbrk((char const   *)s, (char const   *)whitespace);
  }
#line 232
  if (s) {
#line 233
    *s = (char )'\000';
  }
#line 234
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static void output(Key *k , int n , char *s ) 
{ 


  {
#line 241
  if (k->v) {
    {
#line 242
    view_pipe(k->v, & k->first, s, n);
    }
  } else {
    {
#line 244
    noutput(k->olabel, s, n);
    }
  }
#line 245
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static void ex_accept(int n , char *s ) 
{ 
  int fd ;
  ulong key ;
  Key *k ;

  {
  {
#line 254
  fd = wily_connect(s, n);
  }
#line 254
  if (fd < 0) {
    {
#line 255
    diag((char *)0, (char *)"failed connection attempt");
    }
#line 256
    return;
  }
  {
#line 259
  key = estart(0UL, fd, 0);
  }
#line 259
  if (! key) {
    {
#line 260
    diag((char *)0, (char *)"couldn\'t estart to accept connection");
#line 261
    close(fd);
    }
#line 262
    return;
  }
  {
#line 264
  k = key_new(key, fd, (Keytype )3);
#line 265
  mbuf_clear(& k->buf);
  }
#line 266
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/event.c"
static Key *key_find(ulong key ) 
{ 
  Key *k ;

  {
#line 277
  k = keytab;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! ((unsigned long )k < (unsigned long )(keytab + 16))) {
#line 277
      goto while_break;
    }
#line 278
    if (k->key == key) {
#line 279
      return (k);
    }
#line 277
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return ((Key *)0);
}
}
#line 80 "./../include/msg.h"
void msg_fill(Msg *m , Mtype t___0 , Id w , Range r , ushort flag , char *s ) ;
#line 87
Handle *rpc_init(int fd ) ;
#line 88
int rpc_fileno(Handle *h ) ;
#line 89
Bool rpc_isconnected(Handle *h ) ;
#line 92
char *rpc_list(Handle *h , char **bufptr ) ;
#line 93
char *rpc_new(Handle *h , char *s , Id *id___0 , ushort backup ) ;
#line 94
char *rpc_attach(Handle *h , Id w , ushort mask ) ;
#line 95
char *rpc_setname(Handle *h , Id w , char *name ) ;
#line 96
char *rpc_getname(Handle *h , Id w , char **s ) ;
#line 97
char *rpc_settools(Handle *h , Id w , char *name ) ;
#line 98
char *rpc_gettools(Handle *h , Id w , char **s ) ;
#line 99
char *rpc_read(Handle *h , Id w , Range r , char *buf___3 ) ;
#line 100
char *rpc_replace(Handle *h , Id w , Range r , char *s ) ;
#line 101
char *rpc_exec(Handle *h , Id w , char *s ) ;
#line 102
char *rpc_goto(Handle *h , Id *w , Range *r , char *s , Bool setdot ) ;
#line 104
int rpc_event(Handle *h , Msg *m ) ;
#line 105
int rpc_bounce(Handle *h , Msg *m ) ;
#line 106
Bool rpc_wouldblock(Handle *h ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static void msgq_init(MsgQ *q ) ;
#line 23
static Bool msgq_empty(MsgQ *q ) ;
#line 24
static Bool msgq_full(MsgQ *q ) ;
#line 25
static Msg msgq_pop(MsgQ *q ) ;
#line 26
static void msgq_push(MsgQ *q , Msg m ) ;
#line 34
static void msgset_init(MsgSet *s ) ;
#line 35
static Bool msgset_full(MsgSet *s ) ;
#line 36
static Bool msgset_find(MsgSet *s , Id m , Msg *msg ) ;
#line 37
static void msgset_push(MsgSet *s , Msg m ) ;
#line 53
static char *rpc(Handle *h , Msg *m ) ;
#line 54
static int getbytes(Handle *h ) ;
#line 55
static char *simple(Handle *h , Mtype t___0 , Id w , Range r , char *s , ushort flag ) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
Range nr  =    {(ulong )0, (ulong )0};
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
Handle *rpc_init(int fd ) 
{ 
  Handle *h ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 65
  tmp = salloc((int )sizeof(Handle ));
#line 65
  h = (Handle *)tmp;
  }
#line 67
  if (! (fd >= 0)) {
    {
#line 67
    __assert_fail("fd>=0", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c",
                  67U, "rpc_init");
    }
  }
  {
#line 69
  h->fd = fd;
#line 70
  h->alloced = 128;
#line 71
  tmp___0 = salloc(h->alloced);
#line 71
  h->buf = (char *)tmp___0;
#line 72
  h->n = 0;
#line 73
  h->id = 0;
#line 74
  msgset_init(& h->reply);
#line 75
  msgq_init(& h->event);
  }
#line 77
  return (h);
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
int rpc_fileno(Handle *h ) 
{ 


  {
#line 83
  return (h->fd);
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
Bool rpc_isconnected(Handle *h ) 
{ 


  {
#line 89
  return ((Bool )(h->fd >= 0));
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
void rpc_freehandle(Handle *h ) 
{ 


  {
  {
#line 95
  free((void *)h->buf);
#line 96
  close(h->fd);
#line 97
  free((void *)h);
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
Bool rpc_wouldblock(Handle *h ) 
{ 
  Bool tmp ;

  {
  {
#line 103
  tmp = msgq_empty(& h->event);
  }
#line 103
  return (tmp);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
int rpc_event(Handle *h , Msg *m ) 
{ 
  int tmp ;
  Bool tmp___0 ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp___0 = msgq_empty(& h->event);
    }
#line 112
    if (! tmp___0) {
#line 112
      goto while_break;
    }
    {
#line 113
    tmp = getbytes(h);
    }
#line 113
    if (tmp) {
#line 114
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  *m = msgq_pop(& h->event);
  }
#line 116
  return (0);
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
int rpc_bounce(Handle *h , Msg *m ) 
{ 
  int size ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
#line 126
  if ((unsigned int )m->t > 9U) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can only bounce events\n");
    }
#line 128
    return (-1);
  }
  {
#line 132
  size = msg_size(m);
  }
#line 133
  if (h->n + size > h->alloced) {
    {
#line 134
    h->alloced = (h->n + size) + 128;
#line 135
    tmp = srealloc((void *)h->buf, h->alloced);
#line 135
    h->buf = (char *)tmp;
    }
  }
  {
#line 137
  msg_flatten(m, (uchar *)(h->buf + h->n));
#line 138
  tmp___0 = write(h->fd, (void const   *)(h->buf + h->n), (size_t )size);
  }
#line 138
  if (tmp___0 != (ssize_t )size) {
    {
#line 139
    perror("rpc write");
#line 140
    close(h->fd);
#line 141
    h->fd = -1;
    }
#line 142
    return (-1);
  }
#line 144
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_fill(Handle *h , Msg *msg , Mtype t___0 , Id w , Range r , ushort flag ,
               char *s ) 
{ 
  char *tmp ;

  {
  {
#line 149
  msg_fill(msg, t___0, w, r, flag, s);
#line 150
  tmp = rpc(h, msg);
  }
#line 150
  return (tmp);
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_list(Handle *h , char **bufptr ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 164
  err = rpc_fill(h, & m, (Mtype )11, 0, nr, (ushort )0, (char *)0);
  }
#line 164
  if (! err) {
#line 165
    *bufptr = m.s;
  }
#line 166
  return (err);
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_new(Handle *h , char *s , Id *id___0 , ushort backup ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 175
  err = rpc_fill(h, & m, (Mtype )13, 0, nr, backup, s);
  }
#line 175
  if (! err) {
    {
#line 176
    *id___0 = m.w;
#line 177
    free((void *)m.s);
    }
  }
#line 179
  return (err);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_read(Handle *h , Id w , Range r , char *buf___3 ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 188
  err = rpc_fill(h, & m, (Mtype )25, w, r, (ushort )0, (char *)0);
  }
#line 188
  if (! err) {
    {
#line 189
    strcpy((char */* __restrict  */)buf___3, (char const   */* __restrict  */)m.s);
#line 190
    free((void *)m.s);
    }
  }
#line 192
  return (err);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_goto(Handle *h , Id *w , Range *r , char *s , Bool setdot ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 201
  err = rpc_fill(h, & m, (Mtype )31, *w, *r, (ushort )setdot, s);
  }
#line 201
  if (! err) {
    {
#line 202
    *w = m.w;
#line 203
    *r = m.r;
#line 204
    free((void *)m.s);
    }
  }
#line 206
  return (err);
}
}
#line 209 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_getname(Handle *h , Id w , char **s ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 214
  err = rpc_fill(h, & m, (Mtype )19, w, nr, (ushort )0, (char *)0);
  }
#line 214
  if (! err) {
#line 215
    *s = m.s;
  }
#line 217
  return (err);
}
}
#line 220 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_gettools(Handle *h , Id w , char **s ) 
{ 
  Msg m ;
  char *err ;

  {
  {
#line 225
  err = rpc_fill(h, & m, (Mtype )23, w, nr, (ushort )0, (char *)0);
  }
#line 225
  if (! err) {
#line 226
    *s = m.s;
  }
#line 228
  return (err);
}
}
#line 231 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_replace(Handle *h , Id w , Range r , char *s ) 
{ 
  char *tmp ;

  {
  {
#line 234
  tmp = simple(h, (Mtype )27, w, r, s, (ushort )0);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_exec(Handle *h , Id w , char *s ) 
{ 
  char *tmp ;

  {
  {
#line 240
  tmp = simple(h, (Mtype )29, w, nr, s, (ushort )0);
  }
#line 240
  return (tmp);
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_attach(Handle *h , Id w , ushort mask ) 
{ 
  char *tmp ;

  {
  {
#line 246
  tmp = simple(h, (Mtype )15, w, nr, (char *)0, mask);
  }
#line 246
  return (tmp);
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_setname(Handle *h , Id w , char *name ) 
{ 
  char *tmp ;

  {
  {
#line 252
  tmp = simple(h, (Mtype )17, w, nr, name, (ushort )0);
  }
#line 252
  return (tmp);
}
}
#line 255 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
char *rpc_settools(Handle *h , Id w , char *name ) 
{ 
  char *tmp ;

  {
  {
#line 258
  tmp = simple(h, (Mtype )21, w, nr, name, (ushort )0);
  }
#line 258
  return (tmp);
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static char *rpc(Handle *h , Msg *m ) 
{ 
  int size ;
  Id tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  Bool tmp___3 ;

  {
#line 272
  if (h->fd < 0) {
#line 273
    return ((char *)"handle not connected");
  }
  {
#line 275
  tmp = h->id;
#line 275
  (h->id) ++;
#line 275
  m->m = tmp;
#line 277
  size = msg_size(m);
  }
#line 278
  if (h->n + size > h->alloced) {
    {
#line 279
    h->alloced = (h->n + size) + 128;
#line 280
    tmp___0 = srealloc((void *)h->buf, h->alloced);
#line 280
    h->buf = (char *)tmp___0;
    }
  }
  {
#line 284
  msg_flatten(m, (uchar *)(h->buf + h->n));
#line 285
  tmp___1 = write(h->fd, (void const   *)(h->buf + h->n), (size_t )size);
  }
#line 285
  if (tmp___1 != (ssize_t )size) {
    {
#line 286
    perror("rpc write");
#line 287
    close(h->fd);
#line 288
    h->fd = -1;
    }
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___3 = msgset_find(& h->reply, m->m, m);
    }
#line 292
    if (tmp___3) {
#line 292
      goto while_break;
    }
    {
#line 293
    tmp___2 = getbytes(h);
    }
#line 293
    if (tmp___2) {
#line 294
      return ((char *)"lost connection");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if ((unsigned int )m->t == 10U) {
    {
#line 297
    strcpy((char */* __restrict  */)(h->err), (char const   */* __restrict  */)m->s);
#line 298
    free((void *)m->s);
    }
#line 299
    return (h->err);
  } else {
#line 301
    return ((char *)0);
  }
}
}
#line 307 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static char *simple(Handle *h , Mtype t___0 , Id w , Range r , char *s , ushort flag ) 
{ 
  char *err ;
  Msg m ;

  {
  {
#line 313
  m.t = t___0;
#line 314
  m.w = w;
#line 315
  m.r = r;
#line 316
  m.s = s;
#line 317
  m.flag = flag;
#line 319
  err = rpc(h, & m);
  }
#line 319
  if (! err) {
    {
#line 320
    free((void *)m.s);
    }
  }
#line 321
  return (err);
}
}
#line 327 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static int getbytes(Handle *h ) 
{ 
  int left___0 ;
  int nread ;
  char *ptr ;
  int size ;
  ssize_t tmp ;
  Msg m ;
  ulong tmp___0 ;
  int tmp___1 ;
  MsgQ *q ;
  Bool tmp___2 ;
  MsgSet *set ;
  Bool tmp___3 ;
  ulong tmp___4 ;
  ulong tmp___5 ;
  void *tmp___6 ;

  {
#line 335
  if (h->fd < 0) {
#line 336
    return (-1);
  }
  {
#line 338
  tmp = read(h->fd, (void *)(h->buf + h->n), (size_t )(h->alloced - h->n));
#line 338
  nread = (int )tmp;
  }
#line 338
  if (nread < 1) {
#line 339
    return (-1);
  }
#line 340
  h->n += nread;
#line 343
  ptr = h->buf;
#line 344
  left___0 = h->n;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (left___0 >= 12) {
      {
#line 346
      tmp___4 = msg_bufsize((uchar *)ptr);
      }
#line 346
      if (! ((ulong )left___0 >= tmp___4)) {
#line 346
        goto while_break;
      }
    } else {
#line 346
      goto while_break;
    }
    {
#line 349
    tmp___0 = msg_bufsize((uchar *)ptr);
#line 349
    size = (int )tmp___0;
#line 352
    tmp___1 = msg_init(& m, (uchar *)ptr);
    }
#line 352
    if (tmp___1) {
      {
#line 353
      perror("msg_init failed:  closing connection");
#line 354
      close(h->fd);
#line 355
      h->fd = -1;
      }
#line 356
      return (-1);
    }
    {
#line 358
    ptr += size;
#line 359
    left___0 -= size;
#line 360
    m.s = strdup((char const   *)m.s);
    }
#line 363
    if ((unsigned int )m.t < 9U) {
      {
#line 364
      q = & h->event;
#line 366
      tmp___2 = msgq_full(q);
      }
#line 366
      if (tmp___2) {
        {
#line 367
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rpc event queue overflow\n");
#line 368
        free((void *)m.s);
        }
      } else {
        {
#line 370
        msgq_push(q, m);
        }
      }
    } else {
      {
#line 373
      set = & h->reply;
#line 375
      tmp___3 = msgset_full(set);
      }
#line 375
      if (tmp___3) {
        {
#line 376
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rpc reply set overflow\n");
#line 377
        free((void *)m.s);
        }
      } else {
        {
#line 379
        msgset_push(set, m);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (left___0) {
#line 385
    if (left___0 != h->n) {
      {
#line 386
      memmove((void *)h->buf, (void const   *)ptr, (size_t )left___0);
      }
    }
  }
#line 387
  h->n = left___0;
#line 390
  if (left___0 > 12) {
    {
#line 391
    tmp___5 = msg_bufsize((uchar *)h->buf);
#line 391
    size = (int )tmp___5;
    }
#line 392
    if (size > h->alloced) {
      {
#line 393
      h->alloced = size + 128;
#line 394
      tmp___6 = srealloc((void *)h->buf, h->alloced);
#line 394
      h->buf = (char *)tmp___6;
      }
    }
  }
#line 397
  return (0);
}
}
#line 403 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static void msgq_init(MsgQ *q ) 
{ 
  int tmp ;

  {
#line 406
  tmp = 0;
#line 406
  q->write = tmp;
#line 406
  q->read = tmp;
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static Bool msgq_full(MsgQ *q ) 
{ 


  {
#line 412
  return ((Bool )((q->write + 1) % 20 == q->read));
}
}
#line 415 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static Bool msgq_empty(MsgQ *q ) 
{ 


  {
#line 418
  return ((Bool )(q->write == q->read));
}
}
#line 421 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static Msg msgq_pop(MsgQ *q ) 
{ 
  Msg m ;
  Bool tmp ;

  {
  {
#line 426
  tmp = msgq_empty(q);
  }
#line 426
  if (tmp) {
    {
#line 426
    __assert_fail("!msgq_empty(q)", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c",
                  426U, "msgq_pop");
    }
  }
#line 428
  m = q->msg[q->read];
#line 429
  q->read = (q->read + 1) % 20;
#line 430
  return (m);
}
}
#line 433 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static void msgq_push(MsgQ *q , Msg m ) 
{ 
  Bool tmp ;

  {
  {
#line 436
  tmp = msgq_full(q);
  }
#line 436
  if (tmp) {
    {
#line 436
    __assert_fail("!msgq_full(q)", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c",
                  436U, "msgq_push");
    }
  }
#line 438
  q->msg[q->write] = m;
#line 439
  q->write = (q->write + 1) % 20;
#line 440
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static void msgset_init(MsgSet *s ) 
{ 
  int j ;

  {
#line 449
  j = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (j < 20)) {
#line 449
      goto while_break;
    }
#line 450
    s->inuse[j] = (Bool )0;
#line 449
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  s->n = 0;
#line 452
  return;
}
}
#line 454 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static void msgset_push(MsgSet *s , Msg m ) 
{ 
  int j ;
  Bool tmp ;

  {
  {
#line 459
  tmp = msgset_full(s);
  }
#line 459
  if (tmp) {
    {
#line 459
    __assert_fail("!msgset_full(s)", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c",
                  459U, "msgset_push");
    }
  }
#line 461
  j = 0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (j < 20)) {
#line 461
      goto while_break;
    }
#line 462
    if (! s->inuse[j]) {
#line 463
      s->msg[j] = m;
#line 464
      s->inuse[j] = (Bool )1;
#line 465
      (s->n) ++;
#line 466
      return;
    }
#line 461
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  __assert_fail("false", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c",
                468U, "msgset_push");
  }
}
}
#line 471 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static Bool msgset_find(MsgSet *s , Id m , Msg *msg ) 
{ 
  int j ;

  {
#line 476
  if (! s->n) {
#line 477
    return ((Bool )0);
  }
#line 479
  j = 0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (j < 20)) {
#line 479
      goto while_break;
    }
#line 480
    if (s->inuse[j]) {
#line 480
      if (s->msg[j].m == m) {
#line 481
        s->inuse[j] = (Bool )0;
#line 482
        (s->n) --;
#line 483
        *msg = s->msg[j];
#line 484
        return ((Bool )1);
      }
    }
#line 479
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return ((Bool )0);
}
}
#line 489 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/rpc.c"
static Bool msgset_full(MsgSet *s ) 
{ 


  {
#line 492
  return ((Bool )(s->n == 20));
}
}
#line 1453 "/usr/include/X11/Xlib.h"
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
void _ldconvert(char *in , int inld , char *out , int outld , int w , int h ) ;
#line 51
unsigned long _bgpixel ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/wrbitmap.c"
void wrbitmap(Bitmap *b , int miny , int maxy , unsigned char *data ) 
{ 
  XImage *im ;
  int w ;
  int h ;
  int inld ;
  int outld ;
  int l ;
  int offset ;
  int px ;
  GC g ;
  char *tdata ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 19
  w = b->r.max.x - b->r.min.x;
#line 20
  h = maxy - miny;
#line 21
  inld = b->ldepth;
#line 22
  if (b->ldepth == 0) {
#line 22
    outld = 0;
  } else {
#line 22
    outld = screen.ldepth;
  }
#line 23
  px = 1 << (3 - outld);
#line 25
  if (b->r.min.x >= 0) {
#line 26
    offset = b->r.min.x % px;
  } else {
#line 28
    offset = px - b->r.min.x % px;
  }
#line 29
  l = ((- b->r.min.x + px) - 1) / px;
#line 30
  if (b->r.max.x >= 0) {
#line 31
    l += ((b->r.max.x + px) - 1) / px;
  } else {
#line 33
    l -= b->r.max.x / px;
  }
  {
#line 34
  l *= h;
#line 36
  tmp = malloc((size_t )l);
#line 36
  tdata = (char *)tmp;
  }
#line 37
  if ((unsigned long )tdata == (unsigned long )((char *)0)) {
    {
#line 38
    berror((char *)"wrbitmap malloc");
    }
  }
#line 39
  if (inld == outld) {
    {
#line 40
    memcpy((void */* __restrict  */)((void *)tdata), (void const   */* __restrict  */)((void *)data),
           (size_t )l);
    }
  } else {
    {
#line 42
    _ldconvert((char *)data, inld, tdata, outld, w, h);
    }
  }
  {
#line 44
  im = XCreateImage(_dpy, (Visual *)0, (unsigned int )(1 << outld), 2, 0, tdata, (unsigned int )w,
                    (unsigned int )h, 8, 0);
#line 47
  im->bitmap_bit_order = 1;
#line 48
  im->byte_order = 1;
#line 50
  g = _getfillgc((Fcode )12, b, (unsigned long )(~ 0));
  }
#line 51
  if (b->flag & 1) {
#line 51
    tmp___0 = 0UL;
  } else {
#line 51
    tmp___0 = _bgpixel;
  }
  {
#line 51
  XSetBackground(_dpy, g, tmp___0);
#line 52
  XPutImage(_dpy, (Drawable )b->id, g, im, offset, 0, 0, miny - b->r.min.y, (unsigned int )(w - offset),
            (unsigned int )h);
#line 53
  (*(im->f.destroy_image))(im);
  }
#line 54
  return;
}
}
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "./../include/msg.h"
int wilyfifolisten(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void ex_init(void) ;
#line 64
void data_getlabel(Data *d , char *dest ) ;
#line 162
int text_fd(Text *t___0 , Range sel___0 ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static char *historyfile  ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static char *shell  ;
#line 13
static int ex_run(View *v , char *cmd ) ;
#line 14
static int pipe_views(char **cmd , View **vout , View **vin ) ;
#line 15
static int openpipes(int *out , int *err , Bool is_pipe_operation ) ;
#line 16
static int ex_parent(int fderr , int fdout , char *label , char *cmd , View *vout ,
                     int pid ) ;
#line 17
static void ex_child(int fderr , int fdout , char *label , char *cmd , View *vin ) ;
#line 18
static void history(char *cmd ) ;
#line 19
static void childenv(char *label , char *path ) ;
#line 20
static void childfds(int fderr , int fdout , View *vin ) ;
#line 21
static void reap(void) ;
#line 22
static void signal_init(void) ;
#line 23
static void well_known_init(void) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
void ex_init(void) 
{ 


  {
  {
#line 31
  keytab_init();
#line 32
  well_known_init();
#line 33
  signal_init();
#line 35
  historyfile = getenv("HISTORY");
  }
#line 36
  if (! historyfile) {
    {
#line 37
    historyfile = getenv("history");
    }
  }
  {
#line 39
  shell = getenv("SHELL");
  }
#line 40
  if (! shell) {
#line 41
    shell = (char *)"/bin/sh";
  }
#line 42
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
void run(View *v , char *cmd , char *arg ) 
{ 
  char *buf___3 ;
  char *buf2 ;
  char *a2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  Bool tmp___3 ;

  {
  {
#line 54
  tmp = strspn((char const   *)cmd, (char const   *)whitespace);
#line 54
  cmd += tmp;
  }
#line 55
  if (! *cmd) {
#line 56
    return;
  }
#line 63
  if (arg) {
    {
#line 64
    tmp___0 = strlen((char const   *)cmd);
#line 64
    tmp___1 = strlen((char const   *)arg);
#line 64
    tmp___2 = salloc((int )((tmp___0 + tmp___1) + 2UL));
#line 64
    buf___3 = (char *)tmp___2;
#line 65
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%s %s",
            cmd, arg);
    }
  } else {
    {
#line 67
    buf___3 = strdup((char const   *)cmd);
    }
  }
  {
#line 69
  buf2 = strdup((char const   *)buf___3);
#line 71
  cmd = strtok((char */* __restrict  */)buf___3, (char const   */* __restrict  */)whitespace);
#line 74
  a2 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)"");
  }
#line 75
  if (! a2) {
#line 76
    a2 = arg;
  }
  {
#line 78
  tmp___3 = builtin(v, cmd, a2);
  }
#line 78
  if (! tmp___3) {
    {
#line 79
    ex_run(v, buf2);
    }
  }
  {
#line 81
  free((void *)buf___3);
#line 82
  free((void *)buf2);
  }
#line 83
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static int ex_run(View *v , char *cmd ) 
{ 
  View *vout ;
  View *vin ;
  int pout[2] ;
  int perr[2] ;
  Path label ;
  int pid ;
  int tmp ;
  int tmp___0 ;
  Data *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 101
  tmp = pipe_views(& cmd, & vout, & vin);
  }
#line 101
  if (tmp) {
#line 102
    return (-1);
  }
  {
#line 104
  tmp___0 = openpipes(pout, perr, (Bool )vout);
  }
#line 104
  if (tmp___0) {
#line 105
    return (-1);
  }
  {
#line 107
  tmp___1 = view_data(v);
#line 107
  data_getlabel(tmp___1, label);
#line 109
  pid = fork();
  }
  {
#line 110
  if (pid == -1) {
#line 110
    goto case_neg_1;
  }
#line 118
  if (pid == 0) {
#line 118
    goto case_0;
  }
#line 114
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 111
  close(perr[0]);
#line 111
  close(perr[1]);
#line 112
  close(pout[0]);
#line 112
  close(pout[1]);
  }
#line 113
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 115
  close(perr[1]);
#line 116
  close(pout[1]);
#line 117
  tmp___2 = ex_parent(perr[0], pout[0], label, cmd, vout, pid);
  }
#line 117
  return (tmp___2);
  case_0: /* CIL Label */ 
  {
#line 119
  close(perr[0]);
#line 120
  close(pout[0]);
#line 121
  ex_child(perr[1], pout[1], label, cmd, vin);
#line 125
  exit(1);
  }
#line 126
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static int pipe_views(char **cmd , View **vout , View **vin ) 
{ 
  char op ;
  View *vpipe ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 141
  op = *(*cmd);
#line 142
  *vout = (View *)0;
#line 143
  *vin = (View *)0;
#line 144
  if (! ((int )op == 124)) {
#line 144
    if (! ((int )op == 60)) {
#line 144
      if (! ((int )op == 62)) {
#line 145
        return (0);
      }
    }
  }
  {
#line 149
  vpipe = view_body(last_selection);
  }
#line 149
  if (! vpipe) {
#line 150
    return (-1);
  }
  {
#line 155
  tmp = strspn((char const   *)(*cmd + 1), (char const   *)whitespace);
#line 155
  *cmd += 1UL + tmp;
#line 158
  tmp___0 = strlen((char const   *)*cmd);
  }
#line 158
  if (! tmp___0) {
#line 159
    return (-1);
  }
#line 161
  if ((int )op == 124) {
#line 162
    *vout = vpipe;
  } else
#line 161
  if ((int )op == 60) {
#line 162
    *vout = vpipe;
  }
#line 163
  if ((int )op == 124) {
#line 164
    *vin = vpipe;
  } else
#line 163
  if ((int )op == 62) {
#line 164
    *vin = vpipe;
  }
#line 165
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static int openpipes(int *out , int *err , Bool is_pipe_operation ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 179
  tmp = pipe((int *)err);
  }
#line 179
  if (tmp < 0) {
    {
#line 180
    diag((char *)0, (char *)"pipe");
    }
#line 181
    return (-1);
  }
#line 184
  if (is_pipe_operation) {
    {
#line 185
    tmp___0 = pipe((int *)out);
    }
#line 185
    if (tmp___0 < 0) {
      {
#line 186
      diag((char *)0, (char *)"pipe");
#line 187
      close(*(err + 0));
#line 188
      close(*(err + 1));
      }
#line 189
      return (-1);
    }
  } else {
#line 192
    *(out + 0) = *(err + 0);
#line 193
    *(out + 1) = *(err + 1);
  }
#line 195
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static int ex_parent(int fderr , int fdout , char *label , char *cmd , View *vout ,
                     int pid ) 
{ 


  {
  {
#line 214
  reap();
#line 215
  event_outputstart(fderr, pid, cmd, label, (View *)0);
  }
#line 216
  if (vout) {
    {
#line 217
    event_outputstart(fdout, pid, cmd, label, vout);
    }
  }
#line 218
  return (0);
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void ex_child(int fderr , int fdout , char *label , char *cmd , View *vin ) 
{ 
  Path dir ;
  Path path ;
  __pid_t tmp ;
  Path buf___3 ;
  int tmp___0 ;

  {
  {
#line 238
  childfds(fderr, fdout, vin);
#line 241
  tmp = setsid();
  }
#line 241
  if (tmp < 0) {
    {
#line 242
    perror("setsid");
    }
  }
  {
#line 244
  label2path(path, label);
#line 245
  strcpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)(path));
#line 246
  dirnametrunc(dir);
#line 251
  tmp___0 = chdir((char const   *)(dir));
  }
#line 251
  if (tmp___0) {
    {
#line 254
    sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"chdir(%s)",
            dir);
#line 255
    perror((char const   *)(buf___3));
#line 256
    exit(1);
    }
  }
  {
#line 259
  childenv(label, path);
#line 260
  history(cmd);
#line 261
  execl((char const   *)shell, (char const   *)shell, "-c", cmd, 0);
#line 262
  perror((char const   *)shell);
#line 263
  exit(1);
  }
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void history(char *cmd ) 
{ 
  FILE *fp ;

  {
#line 271
  if (! historyfile) {
#line 272
    return;
  }
  {
#line 274
  fp = fopen((char const   */* __restrict  */)historyfile, (char const   */* __restrict  */)"a");
#line 275
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", cmd);
#line 276
  fclose(fp);
  }
#line 277
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void childenv(char *label , char *path ) 
{ 
  Path buf___3 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 284
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"WILYLABEL=%s",
          label);
#line 285
  tmp = strdup((char const   *)(buf___3));
#line 285
  putenv(tmp);
#line 286
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"WILYPATH=%s",
          path);
#line 287
  tmp___0 = strdup((char const   *)(buf___3));
#line 287
  putenv(tmp___0);
#line 288
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"w=%s",
          path);
#line 289
  tmp___1 = strdup((char const   *)(buf___3));
#line 289
  putenv(tmp___1);
  }
#line 290
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void childfds(int fderr , int fdout , View *vin ) 
{ 
  int j ;
  int fdin ;
  int tmp ;
  int tmp___0 ;
  Range tmp___1 ;
  Text *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 307
  tmp = dup2(fderr, 2);
  }
#line 307
  if (tmp < 0) {
    {
#line 308
    perror("dup2");
#line 309
    exit(1);
    }
  } else {
    {
#line 307
    tmp___0 = dup2(fdout, 1);
    }
#line 307
    if (tmp___0 < 0) {
      {
#line 308
      perror("dup2");
#line 309
      exit(1);
      }
    }
  }
#line 312
  if (vin) {
    {
#line 314
    tmp___1 = view_getsel(vin);
#line 314
    tmp___2 = view_text(vin);
#line 314
    fdin = text_fd(tmp___2, tmp___1);
    }
#line 315
    if (fdin < 0) {
      {
#line 316
      exit(1);
      }
    }
  } else {
    {
#line 317
    fdin = open("/dev/null", 0, 0);
    }
#line 317
    if (fdin < 0) {
      {
#line 318
      perror("open /dev/null");
#line 319
      fdin = 0;
      }
    }
  }
#line 322
  if (fdin) {
    {
#line 323
    tmp___3 = dup2(fdin, 0);
    }
#line 323
    if (tmp___3 < 0) {
      {
#line 324
      perror("input dup2");
#line 325
      fdin = 0;
      }
    }
  }
#line 328
  if (! fdin) {
    {
#line 330
    tmp___4 = close(0);
    }
#line 330
    if (tmp___4 < 0) {
      {
#line 332
      perror("close fdin");
#line 333
      exit(1);
      }
    }
  }
#line 338
  j = 3;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (j < 16)) {
#line 338
      goto while_break;
    }
    {
#line 339
    close(j);
#line 338
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void reap(void) 
{ 
  int stat_loc ;
  __pid_t tmp ;

  {
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp = waitpid(-1, & stat_loc, 1);
    }
#line 347
    if (! (tmp > 0)) {
#line 347
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void signal_init(void) 
{ 


  {
  {
#line 355
  signal(13, (void (*)(int  ))1);
#line 357
  signal(1, & cleanup_and_die);
#line 358
  signal(2, & cleanup_and_die);
#line 359
  signal(15, & cleanup_and_die);
#line 361
  signal(11, & cleanup_and_abort);
#line 363
  signal(4, & cleanup_and_abort);
  }
#line 364
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/exec.c"
static void well_known_init(void) 
{ 
  int fd ;

  {
  {
#line 371
  fd = wilyfifolisten();
  }
#line 371
  if (fd < 0) {
    {
#line 372
    diag((char *)0, (char *)"couldn\'t open fifo");
    }
  } else {
    {
#line 374
    event_wellknown(fd);
    }
  }
#line 376
  return;
}
}
#line 45 "./../include/frame.h"
void frsetrects(Frame *f , Rectangle r , Bitmap *b ) ;
#line 48
void frfont(Frame *f , Font___0 *ft ) ;
#line 56
void _frdelbox(Frame *f , int n0 , int n1 ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinit.c"
int tabsize  =    4;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinit.c"
void frinit(Frame *f , Rectangle r , Font___0 *ft , Bitmap *b ) 
{ 


  {
  {
#line 11
  frfont(f, ft);
#line 12
  f->nbox = (ushort )0;
#line 13
  f->nalloc = (ushort )0;
#line 14
  f->nchars = (ushort )0;
#line 15
  f->nlines = (ushort )0;
#line 16
  f->p0 = (ulong )0;
#line 17
  f->p1 = (ulong )0;
#line 18
  f->box = (Frbox *)0;
#line 19
  f->lastlinefull = (ushort )0;
#line 20
  frsetrects(f, r, b);
  }
#line 21
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinit.c"
void frfont(Frame *f , Font___0 *ft ) 
{ 
  long tmp ;

  {
  {
#line 26
  f->font = ft;
#line 27
  tmp = charwidth(ft, (Rune )'0');
#line 27
  f->maxtab = (ushort )((long )tabsize * tmp);
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinit.c"
void frsetrects(Frame *f , Rectangle r , Bitmap *b ) 
{ 


  {
#line 33
  f->b = b;
#line 34
  f->entire = r;
#line 35
  f->r = r;
#line 36
  f->r.max.y -= (r.max.y - r.min.y) % (int )(f->font)->height;
#line 37
  f->left = (short )(r.min.x + 1);
#line 38
  f->maxlines = (ushort )((r.max.y - r.min.y) / (int )(f->font)->height);
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinit.c"
void frclear(Frame *f ) 
{ 


  {
#line 44
  if (f->nbox) {
    {
#line 45
    _frdelbox(f, 0, (int )f->nbox - 1);
    }
  }
#line 46
  if (f->box) {
    {
#line 47
    free((void *)f->box);
    }
  }
#line 48
  f->box = (Frbox *)0;
#line 49
  return;
}
}
#line 202 "./../include/libg.h"
Subfont *getsubfont(char *s ) ;
#line 206
void subffree(Subfont *f ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/font.c"
static Cachesubf *findsubfont(Font___0 *f , Rune r , int *cn ) 
{ 
  int n ;
  int i ;
  int c ;
  Rune rx ;
  Cachesubf *csf ;
  Subfont *sf ;

  {
#line 16
  i = 0;
#line 16
  rx = r;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (i < 2)) {
#line 16
      goto while_break;
    }
#line 17
    n = 0;
#line 17
    csf = f->subf;
    {
#line 17
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17
      if (! (n < (int )f->nsubf)) {
#line 17
        goto while_break___0;
      }
#line 18
      if ((int )csf->min <= (int )rx) {
#line 18
        if ((int )rx <= (int )csf->max) {
#line 19
          if (! csf->f) {
            {
#line 20
            csf->f = getsubfont(csf->name);
            }
#line 21
            if (! csf->f) {
#line 22
              return ((Cachesubf *)0);
            }
          }
#line 24
          sf = csf->f;
#line 25
          c = ((int )rx - (int )csf->min) + sf->minchar;
#line 26
          c = (((c >> 8) - sf->minrow) * sf->width + (c & 255)) - sf->mincol;
#line 27
          if (c < 0) {
#line 28
            goto while_break___0;
          } else
#line 27
          if (c >= sf->n) {
#line 28
            goto while_break___0;
          }
#line 30
          if ((int )(sf->info + c)->cwidth == 0) {
#line 30
            if ((int )(sf->info + c)->width == 0) {
#line 31
              goto while_break___0;
            }
          }
#line 32
          *cn = c;
#line 33
          return (csf);
        }
      }
#line 17
      n ++;
#line 17
      csf ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 16
    i ++;
#line 16
    rx = (Rune )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return ((Cachesubf *)0);
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/font.c"
int cachechars(Font___0 *f , char **s , void *cp , int max , int *wp , unsigned short *fp ) 
{ 
  int i ;
  int w ;
  int wid ;
  int charnum ;
  Rune r ;
  char *sp ;
  Cachesubf *csf ;

  {
#line 46
  sp = *s;
#line 47
  wid = 0;
#line 49
  i = 0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (*sp) {
#line 49
      if (! (i < max)) {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
#line 50
    r = (Rune )*((unsigned char *)sp);
#line 51
    if ((int )r < 128) {
#line 52
      w = 1;
    } else {
      {
#line 54
      w = chartorune(& r, sp);
      }
    }
    {
#line 55
    csf = findsubfont(f, r, & charnum);
    }
#line 56
    if (! csf) {
#line 57
      goto while_break;
    }
#line 58
    wid += (int )((csf->f)->info + charnum)->width;
#line 59
    *(fp + i) = (unsigned short )(csf - f->subf);
#line 60
    ((XChar2b *)cp + i)->byte1 = (unsigned char )(charnum / (csf->f)->width + (csf->f)->minrow);
#line 61
    ((XChar2b *)cp + i)->byte2 = (unsigned char )(charnum % (csf->f)->width + (csf->f)->mincol);
#line 62
    i ++;
#line 49
    sp += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  *s = sp;
#line 65
  *wp = wid;
#line 66
  return (i);
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/font.c"
long charwidth(Font___0 *f , Rune r ) 
{ 
  Cachesubf *csf ;
  int charnum ;

  {
#line 75
  if ((int )r == 0) {
    {
#line 76
    berror((char *)"NUL in charwidth");
    }
  }
  {
#line 78
  csf = findsubfont(f, r, & charnum);
  }
#line 79
  if (! csf) {
#line 80
    return (0L);
  } else {
#line 82
    return ((long )((csf->f)->info + charnum)->width);
  }
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/font.c"
void subffree(Subfont *f ) 
{ 


  {
#line 88
  if (f->info) {
    {
#line 89
    free((void *)f->info);
    }
  }
  {
#line 90
  free((void *)f);
  }
#line 91
  return;
}
}
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 196 "./../include/libg.h"
void xtbinit(void (*f)(char * ) , char *class___0 , int *pargc , char **argv , char **fallbacks ) ;
#line 237
void einit(unsigned long keys ) ;
#line 249
void ereshaped(Rectangle r ) ;
#line 2 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *filetools ;
#line 3
char *dirtools ;
#line 17
Cursor___0 *cursor ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
int tagheight  ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void env_init(char **envp ) ;
#line 58
void dokeyboard(View *v , Rune r ) ;
#line 76
void domouse(View *v , Mouse *m ) ;
#line 107
void scroll_init(void) ;
#line 125
void tag_rmtool(Text *t___0 , char *s ) ;
#line 132
void tag_addrunning(Text *t___0 , char *cmd ) ;
#line 135
void tag_init(char *filename ) ;
#line 142
Text *text_alloc(Data *d , Bool isbody ) ;
#line 187
void wily_init(void) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
View *point2view(Point p ) ;
#line 38
void tile_reshaped(Tile *t___0 ) ;
#line 60
Tile *tile_new(Ori ori , int min , int max , int base , Tile *parent , Text *tagt ,
               Text *bodyt ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
static int ncolumns  =    2;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
Tile *wily  =    (Tile *)0;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
char *wilytools  =    (char *)"Kill | Newcol Quit Putall wily-0.13.41 Dotfiles Font ";
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
char *filetools  =    (char *)"Del Look .";
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
char *dirtools  =    (char *)"Del Look ..";
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
char *columntools  =    (char *)"Delcol New Cut Paste Snarf Anchor Split | ";
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
void _allocerror(char *s ) 
{ 


  {
  {
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          s);
#line 20
  abort();
  }
}
}
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
void addrunning(char *cmd ) 
{ 
  Text *tmp ;

  {
  {
#line 26
  tmp = view_text(wily->tag);
#line 26
  tag_addrunning(tmp, cmd);
  }
#line 27
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
void rmrunning(char *cmd ) 
{ 
  Text *tmp ;

  {
  {
#line 32
  tmp = view_text(wily->tag);
#line 32
  tag_rmtool(tmp, cmd);
  }
#line 33
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
static void tools_init(void) 
{ 
  char *s ;
  char t___0[200] ;
  Path p ;
  char *tmp ;

  {
  {
#line 45
  s = getenv("WILYTOOLS");
  }
#line 45
  if (s) {
    {
#line 46
    tag_init(s);
    }
  } else {
    {
#line 49
    tmp = getenv("HOME");
#line 49
    sprintf((char */* __restrict  */)(p), (char const   */* __restrict  */)"%s/%s",
            tmp, ".wilytools");
#line 50
    tag_init(p);
    }
  }
  {
#line 53
  s = getenv("WCOLTAG");
  }
#line 53
  if (s) {
    {
#line 54
    columntools = strdup((char const   *)s);
    }
  }
  {
#line 55
  s = getenv("WMAINTAG");
  }
#line 55
  if (s) {
    {
#line 56
    strcpy((char */* __restrict  */)(t___0), (char const   */* __restrict  */)wilytools);
#line 57
    strcat((char */* __restrict  */)(t___0), (char const   */* __restrict  */)s);
#line 58
    wilytools = strdup((char const   *)(t___0));
    }
  }
  {
#line 60
  s = getenv("WFILETAG");
  }
#line 60
  if (s) {
    {
#line 61
    filetools = strdup((char const   *)s);
    }
  }
  {
#line 62
  s = getenv("WDIRTAG");
  }
#line 62
  if (s) {
    {
#line 63
    dirtools = strdup((char const   *)s);
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
static void usage(void) 
{ 


  {
  {
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wily [-c ncolumns] [-a tabsize] [-e command] [file1 ...]\n");
#line 69
  exit(1);
  }
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
static void args(int argc , char **argv , char **envp ) 
{ 
  int c ;
  char *cmd ;
  Path label ;

  {
  {
#line 78
  cmd = (char *)0;
#line 80
  tabsize = 4;
#line 83
  xtbinit((void (*)(char * ))(& error), (char *)"Wily", & argc, argv, (char **)0);
#line 84
  tagheight = (int )font->height + 8;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    c = getopt(argc, (char * const  *)argv, "c:a:e:");
    }
#line 86
    if (! (c != -1)) {
#line 86
      goto while_break;
    }
    {
#line 88
    if (c == 99) {
#line 88
      goto case_99;
    }
#line 89
    if (c == 97) {
#line 89
      goto case_97;
    }
#line 90
    if (c == 101) {
#line 90
      goto case_101;
    }
#line 91
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 88
    ncolumns = atoi((char const   *)optarg);
    }
#line 88
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 89
    tabsize = atoi((char const   *)optarg);
    }
#line 89
    goto switch_break;
    case_101: /* CIL Label */ 
#line 90
    cmd = optarg;
#line 90
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 91
    usage();
    }
#line 91
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  scroll_init();
#line 95
  einit(3UL);
#line 96
  cursorswitch(cursor);
#line 97
  wily_init();
#line 99
  ex_init();
  }
#line 101
  if (optind < argc) {
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (! (optind < argc)) {
#line 102
        goto while_break___0;
      }
      {
#line 105
      data_addcontext((Data *)0, label, *(argv + optind));
#line 106
      data_open(label, (Bool )1);
#line 102
      optind ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 108
  if ((unsigned long )cmd == (unsigned long )((char *)0)) {
    {
#line 109
    data_open(wilydir, (Bool )0);
    }
  }
#line 112
  if ((unsigned long )cmd != (unsigned long )((char *)0)) {
    {
#line 113
    run(wily->tag, cmd, (char *)0);
    }
  }
#line 114
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
void wily_init(void) 
{ 
  Text *t___0 ;
  int j ;

  {
  {
#line 123
  t___0 = text_alloc((Data *)0, (Bool )0);
#line 124
  text_replaceutf(t___0, nr, wilytools);
#line 125
  wily = tile_new((Ori )1, 0, screen.r.max.y, 0, (Tile *)0, t___0, (Text *)0);
#line 126
  tile_reshaped(wily);
#line 127
  last_selection = (View *)0;
#line 128
  view_setlastselection(wily->tag);
#line 129
  j = 0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (j < ncolumns)) {
#line 129
      goto while_break;
    }
    {
#line 130
    col_new(wily->tag, (char *)0);
#line 129
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
void ereshaped(Rectangle r ) 
{ 


  {
#line 137
  if (! wily) {
#line 138
    return;
  }
  {
#line 139
  wily->cmax = r.max.x;
#line 140
  wily->max = r.max.y;
#line 141
  tile_reshaped(wily);
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
static void mainloop(void) 
{ 
  ulong type ;
  Event e ;
  Bool mouseaction ;
  Point lastp ;
  View *v ;

  {
#line 150
  mouseaction = (Bool )1;
#line 151
  lastp.x = 0;
#line 151
  lastp.y = 0;
#line 152
  v = (View *)0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    type = eread((unsigned long )(~ 0), & e);
    }
#line 154
    if (! type) {
#line 154
      goto while_break;
    }
    {
#line 156
    if (type == 2UL) {
#line 156
      goto case_2;
    }
#line 169
    if (type == 1UL) {
#line 169
      goto case_1;
    }
#line 176
    goto switch_default;
    case_2: /* CIL Label */ 
#line 157
    if (mouseaction) {
      {
#line 162
      v = point2view(lastp);
#line 163
      mouseaction = (Bool )0;
      }
    }
#line 165
    if (v) {
      {
#line 166
      dokeyboard(v, (Rune )e.kbdc);
      }
    }
#line 167
    goto switch_break;
    case_1: /* CIL Label */ 
#line 170
    lastp = e.mouse.xy;
#line 171
    mouseaction = (Bool )1;
#line 172
    if (e.mouse.buttons) {
      {
#line 172
      v = point2view(e.mouse.xy);
      }
#line 172
      if (v) {
        {
#line 173
        domouse(v, & e.mouse);
        }
      }
    }
#line 174
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 177
    dofd(type, e.n, (char *)(e.data));
    }
#line 178
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/wily.c"
int main(int argc , char **argv , char **envp ) 
{ 
  char *tmp ;

  {
  {
#line 186
  tmp = getcwd(wilydir, (size_t )4096);
  }
#line 186
  if (! tmp) {
    {
#line 187
    fatal((char *)"couldn\'t find out what directory this is");
    }
  }
  {
#line 188
  add_slash(wilydir);
#line 189
  env_init(envp);
#line 190
  tools_init();
#line 191
  args(argc, argv, envp);
#line 192
  mainloop();
  }
#line 193
  return (0);
}
}
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 70 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Bool text_findline(Text *t___0 , Range *r , ulong n ) ;
#line 71
Range text_lastline(Text *t___0 ) ;
#line 113
Bool text_look(Text *t___0 , Range *r , Range dot ) ;
#line 114
Bool text_findliteralutf(Text *t___0 , Range *r , char *lit ) ;
#line 115
Bool text_findwordutf(Text *t___0 , Range *r , char *lit ) ;
#line 116
Bool text_findliteral(Text *t___0 , Range *r , Rstring s ) ;
#line 117
Bool text_findword(Text *t___0 , Range *r , Rstring s ) ;
#line 118
Bool text_search(Text *t___0 , Range *r , char *addr , Range dot ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static char *endword  =    (char *)"[^a-zA-Z0-9][^a-zA-Z0-9|]*";
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static char *startword  =    (char *)"[^a-zA-Z0-9]";
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static char *special  =    (char *)".*+?(|)\\[]^$";
#line 12
static Bool findend(Text *t___0 , Range *r , char *addr , Range dot ) ;
#line 13
static Rstring word(Rstring s ) ;
#line 14
static Rstring literal(Rstring s ) ;
#line 15
static void strip_re_slash(char *re ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_look(Text *t___0 , Range *r , Range dot ) 
{ 
  RPath buf___3 ;
  ulong len ;
  Rstring tmp ;
  Bool tmp___0 ;

  {
#line 28
  len = dot.p1 - dot.p0;
#line 30
  if (len > 4096UL) {
#line 31
    return ((Bool )0);
  }
  {
#line 33
  text_copy(t___0, dot, buf___3);
#line 34
  tmp = rstring(buf___3, buf___3 + len);
#line 34
  tmp___0 = text_findliteral(t___0, r, tmp);
  }
#line 34
  return (tmp___0);
}
}
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_findliteralutf(Text *t___0 , Range *r , char *lit ) 
{ 
  Rstring s ;
  Bool found ;

  {
  {
#line 43
  s = utf2rstring(lit);
#line 44
  r->p0 = r->p1;
#line 45
  found = text_findliteral(t___0, r, s);
#line 46
  free((void *)s.r0);
  }
#line 48
  return (found);
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_findwordutf(Text *t___0 , Range *r , char *lit ) 
{ 
  Rstring s ;
  Bool found ;

  {
  {
#line 57
  s = utf2rstring(lit);
#line 58
  found = text_findword(t___0, r, s);
#line 59
  free((void *)s.r0);
  }
#line 61
  return (found);
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_findliteral(Text *t___0 , Range *r , Rstring s ) 
{ 
  Rstring s2 ;
  Bool found ;

  {
  {
#line 74
  s2 = literal(s);
#line 75
  found = text_regexp(t___0, s2, r, (Bool )1);
#line 76
  free((void *)s2.r0);
  }
#line 77
  return (found);
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_findword(Text *t___0 , Range *r , Rstring s ) 
{ 
  Rstring s2 ;
  Bool found ;

  {
  {
#line 85
  s2 = word(s);
#line 86
  found = text_regexp(t___0, s2, r, (Bool )1);
#line 87
  free((void *)s2.r0);
#line 88
  (r->p0) ++;
  }
#line 89
  return (found);
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
Bool text_search(Text *t___0 , Range *r , char *addr , Range dot ) 
{ 
  char *addr2 ;
  char *tmp ;
  Bool tmp___0 ;
  Range range2 ;
  Bool tmp___1 ;

  {
#line 107
  if ((int )*addr == 47) {
#line 109
    addr2 = addr + 1;
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 109
      addr2 = strchr((char const   *)addr2, '/');
      }
#line 109
      if (addr2) {
#line 109
        if (! ((int )*(addr2 + -1) == 92)) {
#line 109
          goto while_break;
        }
      } else {
#line 109
        goto while_break;
      }
#line 109
      addr2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 114
    if (addr2) {
#line 114
      addr2 ++;
#line 114
      if ((int )*addr2 != 44) {
#line 115
        addr2 = (char *)0;
      }
    }
  } else {
    {
#line 118
    addr2 = strchr((char const   *)addr, ',');
    }
  }
#line 120
  if (addr2) {
#line 121
    tmp = addr2;
#line 121
    addr2 ++;
#line 121
    *tmp = (char )'\000';
  }
#line 123
  if ((int )*addr == 0) {
#line 124
    r->p0 = (ulong )0;
  } else {
    {
#line 125
    tmp___0 = findend(t___0, r, addr, dot);
    }
#line 125
    if (! tmp___0) {
#line 126
      return ((Bool )0);
    }
  }
#line 128
  if (addr2) {
#line 129
    range2 = *r;
#line 131
    if ((int )*addr2 == 0) {
#line 132
      r->p1 = t___0->length;
    } else {
      {
#line 133
      tmp___1 = findend(t___0, & range2, addr2, dot);
      }
#line 133
      if (tmp___1) {
#line 135
        if (range2.p1 < r->p0) {
#line 136
          return ((Bool )0);
        } else {
#line 138
          r->p1 = range2.p1;
        }
      } else {
#line 134
        return ((Bool )0);
      }
    }
  }
#line 140
  return ((Bool )1);
}
}
#line 148 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static Bool findend(Text *t___0 , Range *r , char *addr , Range dot ) 
{ 
  char *tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  ulong tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Bool tmp___5 ;

  {
  {
#line 150
  tmp = strchr("/-#$.0123456789", (int )*addr);
  }
#line 150
  if (! tmp) {
#line 151
    return ((Bool )0);
  }
  {
#line 154
  if ((int )*addr == 47) {
#line 154
    goto case_47;
  }
#line 157
  if ((int )*addr == 45) {
#line 157
    goto case_45;
  }
#line 162
  if ((int )*addr == 35) {
#line 162
    goto case_35;
  }
#line 165
  if ((int )*addr == 36) {
#line 165
    goto case_36;
  }
#line 170
  if ((int )*addr == 46) {
#line 170
    goto case_46;
  }
#line 175
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 155
  strip_re_slash(addr);
#line 156
  tmp___0 = text_utfregexp(t___0, addr + 1, r, (Bool )1);
  }
#line 156
  return (tmp___0);
  case_45: /* CIL Label */ 
#line 158
  if ((int )*(addr + 1) != 47) {
#line 159
    return ((Bool )0);
  }
  {
#line 160
  strip_re_slash(addr);
#line 161
  tmp___1 = text_utfregexp(t___0, addr + 2, r, (Bool )0);
  }
#line 161
  return (tmp___1);
  case_35: /* CIL Label */ 
  {
#line 163
  tmp___3 = atol((char const   *)(addr + 1));
#line 163
  tmp___2 = (ulong )tmp___3;
#line 163
  r->p1 = tmp___2;
#line 163
  r->p0 = tmp___2;
  }
#line 164
  return ((Bool )(r->p0 <= t___0->length));
  case_36: /* CIL Label */ 
#line 166
  if ((int )*(addr + 1) != 0) {
#line 167
    return ((Bool )0);
  }
  {
#line 168
  *r = text_lastline(t___0);
  }
#line 169
  return ((Bool )1);
  case_46: /* CIL Label */ 
#line 171
  if ((int )*(addr + 1) != 0) {
#line 172
    return ((Bool )0);
  }
#line 173
  *r = dot;
#line 174
  return ((Bool )1);
  switch_default: /* CIL Label */ 
  {
#line 176
  tmp___4 = atol((char const   *)addr);
#line 176
  tmp___5 = text_findline(t___0, r, (ulong )tmp___4);
  }
#line 176
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static void strip_re_slash(char *re ) 
{ 


  {
  {
#line 187
  re = strrchr((char const   *)re, '/');
  }
#line 187
  if (re) {
#line 187
    if ((int )*(re + 1) == 0) {
#line 187
      if ((int )*(re + -1) != 92) {
#line 188
        *(re + 0) = (char )'\000';
      }
    }
  }
#line 189
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static Rstring literal(Rstring s ) 
{ 
  Rstring s2 ;
  Rune *r ;
  void *tmp ;
  Rune *tmp___0 ;
  char *tmp___1 ;
  Rune *tmp___2 ;

  {
  {
#line 197
  tmp = salloc((int )((unsigned long )((s.r1 - s.r0) * 2L) * sizeof(Rune )));
#line 197
  s2.r1 = (Rune *)tmp;
#line 197
  s2.r0 = s2.r1;
#line 198
  r = s.r0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )r < (unsigned long )s.r1)) {
#line 198
      goto while_break;
    }
    {
#line 199
    tmp___1 = utfrune(special, (long )*r);
    }
#line 199
    if (tmp___1) {
#line 200
      tmp___0 = s2.r1;
#line 200
      (s2.r1) ++;
#line 200
      *tmp___0 = (Rune )'\\';
    }
#line 201
    tmp___2 = s2.r1;
#line 201
    (s2.r1) ++;
#line 201
    *tmp___2 = *r;
#line 198
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (s2);
}
}
#line 206 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/search.c"
static Rstring word(Rstring s ) 
{ 
  Rstring s2 ;
  Rune *r ;
  int nrunes ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  ulong tmp___3 ;
  Rune *tmp___4 ;
  char *tmp___5 ;
  Rune *tmp___6 ;
  size_t tmp___7 ;
  ulong tmp___8 ;

  {
  {
#line 212
  tmp = strlen((char const   *)startword);
#line 212
  tmp___0 = strlen((char const   *)endword);
#line 212
  nrunes = (int )(((size_t )((s.r1 - s.r0) * 2L) + tmp) + tmp___0);
#line 213
  tmp___1 = salloc((int )((unsigned long )nrunes * sizeof(Rune )));
#line 213
  s2.r1 = (Rune *)tmp___1;
#line 213
  s2.r0 = s2.r1;
#line 215
  tmp___2 = strlen((char const   *)startword);
#line 215
  tmp___3 = utftotext(s2.r1, startword, startword + tmp___2);
#line 215
  s2.r1 += tmp___3;
#line 217
  r = s.r0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )r < (unsigned long )s.r1)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp___5 = utfrune(special, (long )*r);
    }
#line 218
    if (tmp___5) {
#line 219
      tmp___4 = s2.r1;
#line 219
      (s2.r1) ++;
#line 219
      *tmp___4 = (Rune )'\\';
    }
#line 220
    tmp___6 = s2.r1;
#line 220
    (s2.r1) ++;
#line 220
    *tmp___6 = *r;
#line 217
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp___7 = strlen((char const   *)endword);
#line 222
  tmp___8 = utftotext(s2.r1, endword, endword + tmp___7);
#line 222
  s2.r1 += tmp___8;
  }
#line 223
  return (s2);
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void tag_addtool(Text *t___0 , char *s ) ;
#line 181
void tile_del(Tile *tile ) ;
#line 239
void view_getdot(View *v , char *buf___3 , Bool isLine ) ;
#line 243
int view_delete(View *v ) ;
#line 281
Tile *tile_win(Tile *tile ) ;
#line 284
void win_new(char *path , Text *tag___0 , Text *body ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
void findplace(Tile *list___0 , int *min , int *max ) ;
#line 62
void list_add(Tile *list___0 , Tile *tile ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
static void win_place(Tile *col , Text *tag___0 , Text *body ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
int win_del(Tile *w ) 
{ 
  int tmp ;

  {
#line 11
  if (! w) {
#line 12
    return (0);
  }
  {
#line 17
  tmp = view_delete(w->body);
  }
#line 17
  if (tmp) {
#line 18
    return (-1);
  }
  {
#line 21
  view_delete(w->tag);
#line 22
  tile_del(w);
  }
#line 23
  return (0);
}
}
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
Tile *tile_win(Tile *tile ) 
{ 
  Tile *tmp ;

  {
#line 29
  if (tile) {
#line 29
    if (tile->body) {
#line 29
      tmp = tile;
    } else {
#line 29
      tmp = (Tile *)0;
    }
  } else {
#line 29
    tmp = (Tile *)0;
  }
#line 29
  return (tmp);
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
void win_clone(Tile *win ) 
{ 
  Text *tag___0 ;
  Text *body ;

  {
  {
#line 39
  tag___0 = view_text(win->tag);
#line 40
  body = view_text(win->body);
#line 41
  win_place(win->up, tag___0, body);
  }
#line 42
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
void win_new(char *path , Text *tag___0 , Text *body ) 
{ 
  Tile *col ;

  {
  {
#line 49
  col = findcol(path);
#line 50
  win_place(col, tag___0, body);
  }
#line 51
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
void win_anchor(Tile *w , char *arg ) 
{ 
  char buf___3[80] ;
  Text *tmp ;

  {
  {
#line 60
  view_getdot(w->body, buf___3, (Bool )((unsigned long )arg != (unsigned long )((char *)0)));
#line 61
  tmp = view_text(w->tag);
#line 61
  tag_addtool(tmp, buf___3);
  }
#line 62
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/win.c"
static void win_place(Tile *col , Text *tag___0 , Text *body ) 
{ 
  Tile *win ;
  int max ;
  int min ;

  {
  {
#line 72
  findplace(col, & min, & max);
#line 73
  win = tile_new((Ori )1, min, max, tagheight, col, tag___0, body);
#line 74
  list_add(col, win);
  }
#line 76
  return;
}
}
#line 54 "./../include/frame.h"
void _frfreebox(Frame *f , int n0 , int n1 ) ;
#line 57
void _frsplitbox(Frame *f , int bn , int n ) ;
#line 58
int _frfindbox(Frame *f , int bn , ulong p , ulong q ) ;
#line 59
void _frclosebox(Frame *f , int n0 , int n1 ) ;
#line 60
int _frcanfit(Frame *f , Point pt , Frbox *b ) ;
#line 62
void _frcklinewrap0(Frame *f , Point *p , Frbox *b ) ;
#line 64
int _frnewwid(Frame *f , Point pt , Frbox *b ) ;
#line 65
void _frclean(Frame *f , Point pt , int n0 , int n1 ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frdelete.c"
int frdelete(Frame *f , ulong p0 , ulong p1 ) 
{ 
  Point pt0 ;
  Point pt1 ;
  Point ppt0 ;
  Frbox *b ;
  int n0 ;
  int n1 ;
  int n ;
  Rectangle r ;
  int nn0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Point pt2 ;
  int q0 ;
  int q1 ;
  int q2 ;
  Rectangle tmp___2 ;
  Rectangle tmp___3 ;
  Point tmp___4 ;
  Point tmp___5 ;
  int tmp___6 ;

  {
#line 16
  if (p0 >= (ulong )f->nchars) {
#line 17
    return (0);
  } else
#line 16
  if (p0 == p1) {
#line 17
    return (0);
  } else
#line 16
  if ((unsigned long )f->b == (unsigned long )((Bitmap *)0)) {
#line 17
    return (0);
  }
#line 18
  if (p1 > (ulong )f->nchars) {
#line 19
    p1 = (ulong )f->nchars;
  }
  {
#line 20
  n0 = _frfindbox(f, 0, 0UL, p0);
#line 21
  n1 = _frfindbox(f, n0, p0, p1);
#line 22
  pt0 = _frptofcharnb(f, p0, n0);
#line 23
  pt1 = frptofchar(f, p1);
  }
#line 24
  if (f->p0 != p0) {
    {
#line 25
    frselectp(f, (Fcode )5);
    }
  } else
#line 24
  if (f->p1 != p1) {
    {
#line 25
    frselectp(f, (Fcode )5);
    }
  }
  {
#line 26
  frselectf(f, pt0, pt1, (Fcode )0);
  }
#line 27
  if (n0 == (int )f->nbox) {
    {
#line 28
    berror((char *)"off end in frdelete");
    }
  }
  {
#line 29
  nn0 = n0;
#line 30
  ppt0 = pt0;
#line 31
  _frfreebox(f, n0, n1 - 1);
#line 32
  f->modified = (ushort )1;
#line 41
  b = f->box + n1;
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (pt1.x != pt0.x) {
#line 42
      if (! (n1 < (int )f->nbox)) {
#line 42
        goto while_break;
      }
    } else {
#line 42
      goto while_break;
    }
    {
#line 43
    _frcklinewrap0(f, & pt0, b);
#line 44
    _frcklinewrap(f, & pt1, b);
    }
#line 45
    if (b->nrune > 0L) {
      {
#line 46
      n = _frcanfit(f, pt0, b);
      }
#line 47
      if (n == 0) {
        {
#line 48
        berror((char *)"_frcanfit==0");
        }
      }
#line 49
      if ((long )n != b->nrune) {
        {
#line 50
        _frsplitbox(f, n1, n);
#line 51
        b = f->box + n1;
        }
      }
      {
#line 53
      r.min = pt1;
#line 54
      r.max = pt1;
#line 55
      r.max.x = (int )((long )r.max.x + b->wid);
#line 56
      r.max.y += (int )(f->font)->height;
#line 57
      bitblt(f->b, pt0, f->b, r, (Fcode )12);
      }
#line 58
      if (pt0.y == pt1.y) {
#line 59
        r.min.x = r.max.x - (pt1.x - pt0.x);
      }
      {
#line 60
      bitblt(f->b, r.min, f->b, r, (Fcode )0);
      }
    }
    {
#line 62
    _fradvance(f, & pt1, b);
#line 63
    tmp = _frnewwid(f, pt0, b);
#line 63
    pt0.x += tmp;
#line 64
    tmp___0 = n0;
#line 64
    n0 ++;
#line 64
    tmp___1 = n1;
#line 64
    n1 ++;
#line 64
    *(f->box + tmp___0) = *(f->box + tmp___1);
#line 65
    b ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if (pt1.y != pt0.y) {
    {
#line 70
    pt2 = _frptofcharptb(f, (ulong )32767, pt1, n1);
    }
#line 71
    if (pt2.y > f->r.max.y) {
      {
#line 72
      berror((char *)"frptofchar in frdelete");
      }
    }
#line 73
    if (n1 < (int )f->nbox) {
      {
#line 76
      q0 = pt0.y + (int )(f->font)->height;
#line 77
      q1 = pt1.y + (int )(f->font)->height;
#line 78
      q2 = pt2.y + (int )(f->font)->height;
#line 79
      tmp___2 = Rect(pt1.x, pt1.y, f->r.max.x, q1);
#line 79
      bitblt(f->b, pt0, f->b, tmp___2, (Fcode )12);
#line 80
      tmp___3 = Rect(f->r.min.x, q1, f->r.max.x, q2);
#line 80
      tmp___4 = Pt(f->r.min.x, q0);
#line 80
      bitblt(f->b, tmp___4, f->b, tmp___3, (Fcode )12);
#line 81
      tmp___5 = Pt(pt2.x, pt2.y - (pt1.y - pt0.y));
#line 81
      frselectf(f, tmp___5, pt2, (Fcode )0);
      }
    } else {
      {
#line 83
      frselectf(f, pt0, pt2, (Fcode )0);
      }
    }
  }
  {
#line 85
  _frclosebox(f, n0, n1 - 1);
  }
#line 86
  if (nn0 > 0) {
#line 86
    if ((f->box + (nn0 - 1))->nrune >= 0L) {
#line 86
      if ((long )ppt0.x - (f->box + (nn0 - 1))->wid >= (long )((int )f->left)) {
#line 87
        nn0 --;
#line 88
        ppt0.x = (int )((long )ppt0.x - (f->box + nn0)->wid);
      }
    }
  }
#line 90
  if (n0 < (int )f->nbox - 1) {
#line 90
    tmp___6 = n0 + 1;
  } else {
#line 90
    tmp___6 = n0;
  }
  {
#line 90
  _frclean(f, ppt0, nn0, tmp___6);
  }
#line 91
  if (f->p1 > p1) {
#line 92
    f->p1 -= p1 - p0;
  } else
#line 93
  if (f->p1 > p0) {
#line 94
    f->p1 = p0;
  }
#line 95
  if (f->p0 > p1) {
#line 96
    f->p0 -= p1 - p0;
  } else
#line 97
  if (f->p0 > p0) {
#line 98
    f->p0 = p0;
  }
  {
#line 99
  frselectp(f, (Fcode )5);
#line 100
  f->nchars = (ushort )((ulong )f->nchars - (p1 - p0));
#line 101
  pt0 = frptofchar(f, (ulong )f->nchars);
#line 102
  n = (int )f->nlines;
#line 103
  f->nlines = (ushort )((pt0.y - f->r.min.y) / (int )(f->font)->height + (pt0.x > (int )f->left));
  }
#line 104
  return (n - (int )f->nlines);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void tile_grow(Tile *tile , int buttons ) ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
void list_unhide(Tile *list___0 ) ;
#line 42
void list_reshaped(Tile *l , Tile *tile ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/grow.c"
static void gsome(Tile *tile ) 
{ 


  {
#line 20
  tile->min -= tile->base * 2;
#line 21
  tile->max += tile->base * 2;
#line 22
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/grow.c"
static void gmost(Tile *tile ) 
{ 
  Tile *t___0 ;
  Tile *up ;
  int space ;

  {
#line 27
  up = tile->up;
#line 28
  space = 0;
#line 30
  t___0 = up->down;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! t___0) {
#line 30
      goto while_break;
    }
#line 31
    if ((unsigned long )t___0 != (unsigned long )tile) {
#line 32
      space += t___0->base;
#line 33
      t___0->max = t___0->min + t___0->base;
    } else {
#line 35
      t___0->min = space + up->cmin;
#line 36
      space = 0;
    }
#line 30
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  tile->max = up->cmax - space;
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/grow.c"
static void gall(Tile *tile ) 
{ 
  Tile *t___0 ;
  Tile *up ;

  {
#line 45
  up = tile->up;
#line 46
  t___0 = up->down;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! t___0) {
#line 46
      goto while_break;
    }
#line 47
    if ((unsigned long )t___0 != (unsigned long )tile) {
#line 48
      t___0->ishidden = (Bool )1;
    }
#line 46
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  tile->min = up->cmin;
#line 51
  tile->max = up->cmax;
#line 52
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/grow.c"
void tile_grow(Tile *tile , int buttons ) 
{ 


  {
  {
#line 63
  list_unhide(tile->up);
  }
  {
#line 72
  if (buttons == 1) {
#line 72
    goto case_1;
  }
#line 73
  if (buttons == 2) {
#line 73
    goto case_2;
  }
#line 74
  if (buttons == 4) {
#line 74
    goto case_4;
  }
#line 75
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 72
  gsome(tile);
  }
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 73
  gmost(tile);
  }
#line 73
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 74
  gall(tile);
  }
#line 74
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 75
  gsome(tile);
  }
#line 75
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 78
  list_reshaped(tile->up, tile);
  }
#line 81
  return;
}
}
#line 1596 "/usr/include/X11/Xlib.h"
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 3185
extern int XSetClipRectangles(Display * , GC  , int  , int  , XRectangle * , int  ,
                              int  ) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
GC _getgc(Bitmap *b , unsigned long gcvm , XGCValues *pgcv ) ;
#line 51
unsigned long _fgpixel ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int gx[16]  = 
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
  {      0,      8,      4,      12, 
        2,      10,      6,      14, 
        1,      9,      5,      13, 
        3,      11,      7,      15};
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int d0s1gx[16]  = 
#line 62
  {      15,      11,      7,      3, 
        14,      10,      6,      2, 
        13,      9,      5,      1, 
        12,      8,      4,      0};
#line 86 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int d1s0gx[16]  = 
#line 86
  {      0,      2,      1,      3, 
        8,      10,      9,      11, 
        4,      6,      5,      7, 
        12,      14,      13,      15};
#line 111 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int d0s0gx[16]  = 
#line 111
  {      15,      14,      13,      12, 
        11,      10,      9,      8, 
        7,      6,      5,      4, 
        3,      2,      1,      0};
#line 133 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int degengc[16]  = 
#line 133
  {      1,      0,      0,      0, 
        0,      1,      0,      0, 
        0,      0,      1,      0, 
        0,      0,      0,      1};
#line 162 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static GC gc0  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static GC gcn  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
static int clipset  =    0;
#line 159 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
GC _getgc(Bitmap *b , unsigned long gcvm , XGCValues *pgcv ) 
{ 
  GC g ;
  XRectangle xr ;

  {
#line 167
  if (b->ldepth == 0) {
#line 167
    g = gc0;
  } else {
#line 167
    g = gcn;
  }
#line 168
  if (! g) {
    {
#line 169
    g = XCreateGC(_dpy, (Drawable )b->id, gcvm, pgcv);
    }
#line 170
    if (b->ldepth == 0) {
#line 171
      gc0 = g;
    } else {
#line 173
      gcn = g;
    }
  } else {
    {
#line 175
    XChangeGC(_dpy, g, gcvm, pgcv);
    }
  }
#line 176
  if (b->flag & 64) {
#line 177
    xr.x = (short )b->clipr.min.x;
#line 178
    xr.y = (short )b->clipr.min.y;
#line 179
    xr.width = (unsigned short )(b->clipr.max.x - b->clipr.min.x);
#line 180
    xr.height = (unsigned short )(b->clipr.max.y - b->clipr.min.y);
#line 181
    if (b->flag & 32) {
#line 182
      xr.x = (short )((int )xr.x - b->r.min.x);
#line 183
      xr.y = (short )((int )xr.y - b->r.min.y);
    }
    {
#line 185
    XSetClipRectangles(_dpy, g, 0, 0, & xr, 1, 3);
#line 186
    clipset = 1;
    }
  } else
#line 187
  if (clipset) {
    {
#line 188
    pgcv->clip_mask = (Pixmap )0L;
#line 189
    XChangeGC(_dpy, g, (unsigned long )(1L << 19), pgcv);
#line 190
    clipset = 0;
    }
  }
#line 192
  return (g);
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
GC _getfillgc(Fcode f , Bitmap *b , unsigned long val ) 
{ 
  int xf ;
  int m ;
  unsigned long v ;
  unsigned long fg ;
  unsigned long bg ;
  unsigned long spix ;
  unsigned long vmax ;
  XGCValues gcv ;
  GC tmp ;

  {
#line 207
  f = (Fcode )((unsigned int )f & 15U);
#line 208
  vmax = _ld2dmask[b->ldepth];
#line 209
  v = val & vmax;
#line 210
  spix = v;
#line 211
  xf = 3;
#line 212
  m = b->flag;
#line 213
  if (m & 1) {
#line 214
    if (m & 2) {
#line 214
      xf = gx[f];
    } else {
#line 214
      xf = d0s1gx[f];
    }
  } else {
#line 216
    fg = _fgpixel;
#line 217
    bg = _bgpixel;
    {
#line 219
    if ((unsigned int )f == 0U) {
#line 219
      goto labZero;
    }
#line 223
    if ((unsigned int )f == 15U) {
#line 223
      goto labF;
    }
#line 227
    if ((unsigned int )f == 10U) {
#line 227
      goto labD;
    }
#line 231
    if ((unsigned int )f == 5U) {
#line 231
      goto labnotD;
    }
#line 236
    if ((unsigned int )f == 12U) {
#line 236
      goto case_12;
    }
#line 242
    if ((unsigned int )f == 3U) {
#line 242
      goto case_3;
    }
#line 248
    if ((unsigned int )f == 6U) {
#line 248
      goto case_6;
    }
#line 255
    if ((unsigned int )f == 9U) {
#line 255
      goto case_9;
    }
#line 262
    goto switch_default;
    labZero: 
    case_0: /* CIL Label */ 
#line 221
    spix = bg;
#line 222
    goto switch_break;
    labF: 
    case_15: /* CIL Label */ 
#line 225
    spix = fg;
#line 226
    goto switch_break;
    labD: 
    case_10: /* CIL Label */ 
#line 229
    xf = 5;
#line 230
    goto switch_break;
    labnotD: 
    case_5: /* CIL Label */ 
#line 233
    xf = 6;
#line 234
    spix = fg ^ bg;
#line 235
    goto switch_break;
    case_12: /* CIL Label */ 
#line 237
    if (val == 0xffffffffffffffffUL) {
#line 238
      spix = fg;
    } else {
#line 240
      spix = v;
    }
#line 241
    goto switch_break;
    case_3: /* CIL Label */ 
#line 243
    if (val == 0xffffffffffffffffUL) {
#line 244
      spix = bg;
    } else {
#line 246
      spix = v;
    }
#line 247
    goto switch_break;
    case_6: /* CIL Label */ 
#line 249
    xf = 6;
#line 250
    if (val == 0xffffffffffffffffUL) {
#line 251
      spix = fg ^ bg;
    } else {
#line 253
      spix = v;
    }
#line 254
    goto switch_break;
    case_9: /* CIL Label */ 
#line 256
    xf = 6;
#line 257
    if (val == 0UL) {
#line 258
      spix = fg ^ bg;
    } else {
#line 260
      spix = v;
    }
#line 261
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 264
    if (v < vmax - v) {
      {
#line 267
      if (((unsigned int )f & 4294967283U) == 2U) {
#line 267
        goto case_2;
      }
#line 268
      if (((unsigned int )f & 4294967283U) == 1U) {
#line 268
        goto case_1;
      }
#line 269
      if (((unsigned int )f & 4294967283U) == 0U) {
#line 269
        goto case_0___0;
      }
#line 270
      if (((unsigned int )f & 4294967283U) == 3U) {
#line 270
        goto case_3___0;
      }
#line 266
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 267
      goto labD;
      case_1: /* CIL Label */ 
#line 268
      goto labnotD;
      case_0___0: /* CIL Label */ 
#line 269
      goto labZero;
      case_3___0: /* CIL Label */ 
#line 270
      goto labF;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 275
      if (((unsigned int )f & 12U) == 8U) {
#line 275
        goto case_8;
      }
#line 276
      if (((unsigned int )f & 12U) == 4U) {
#line 276
        goto case_4;
      }
#line 277
      if (((unsigned int )f & 12U) == 0U) {
#line 277
        goto case_0___1;
      }
#line 278
      if (((unsigned int )f & 12U) == 12U) {
#line 278
        goto case_12___0;
      }
#line 274
      goto switch_break___1;
      case_8: /* CIL Label */ 
#line 275
      goto labD;
      case_4: /* CIL Label */ 
#line 276
      goto labnotD;
      case_0___1: /* CIL Label */ 
#line 277
      goto labZero;
      case_12___0: /* CIL Label */ 
#line 278
      goto labF;
      switch_break___1: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 284
  gcv.foreground = spix;
#line 285
  gcv.function = xf;
#line 286
  tmp = _getgc(b, (unsigned long )((1L << 2) | 1L), & gcv);
  }
#line 286
  return (tmp);
}
}
#line 296 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/gcs.c"
GC _getcopygc(Fcode f , Bitmap *db , Bitmap *sb , int *bltfunc ) 
{ 
  unsigned long spix ;
  unsigned long bg ;
  unsigned long fg ;
  unsigned long df ;
  unsigned long sf ;
  int xf ;
  int c ;
  XGCValues gcv ;
  unsigned long gcvm ;
  GC tmp ;

  {
#line 304
  f = (Fcode )((unsigned int )f & 15U);
#line 305
  gcvm = 0UL;
#line 306
  df = (unsigned long )db->flag;
#line 307
  if (degengc[f]) {
#line 308
    *bltfunc = 2;
#line 309
    if (df & 4UL) {
#line 310
      fg = _fgpixel;
#line 311
      bg = _bgpixel;
    } else
#line 309
    if (! (df & 1UL)) {
#line 310
      fg = _fgpixel;
#line 311
      bg = _bgpixel;
    } else {
#line 314
      fg = 1UL;
#line 315
      bg = 0UL;
    }
    {
#line 318
    if ((unsigned int )f == 0U) {
#line 318
      goto case_0;
    }
#line 322
    if ((unsigned int )f == 15U) {
#line 322
      goto case_15;
    }
#line 326
    if ((unsigned int )f == 10U) {
#line 326
      goto case_10;
    }
#line 330
    if ((unsigned int )f == 5U) {
#line 330
      goto case_5;
    }
#line 317
    goto switch_break;
    case_0: /* CIL Label */ 
#line 319
    xf = 3;
#line 320
    spix = bg;
#line 321
    goto switch_break;
    case_15: /* CIL Label */ 
#line 323
    xf = 3;
#line 324
    spix = fg;
#line 325
    goto switch_break;
    case_10: /* CIL Label */ 
#line 327
    xf = 5;
#line 328
    spix = fg;
#line 329
    goto switch_break;
    case_5: /* CIL Label */ 
#line 331
    xf = 6;
#line 332
    spix = fg ^ bg;
#line 333
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 335
    gcv.function = xf;
#line 336
    gcv.foreground = spix;
#line 337
    gcvm = (unsigned long )(1L | (1L << 2));
  } else {
#line 343
    sf = (unsigned long )sb->flag;
#line 344
    c = (int )(((df & 3UL) << 2) | (sf & 3UL));
#line 345
    *bltfunc = 0;
    {
#line 348
    if ((((df & 3UL) << 2) | (sf & 3UL)) == (unsigned long )((2 << 2) | 2)) {
#line 348
      goto case_exp;
    }
#line 348
    if ((((df & 3UL) << 2) | (sf & 3UL)) == (unsigned long )((3 << 2) | 3)) {
#line 348
      goto case_exp;
    }
#line 351
    if ((((df & 3UL) << 2) | (sf & 3UL)) == (unsigned long )((3 << 2) | 1)) {
#line 351
      goto case_exp___1;
    }
#line 354
    if ((((df & 3UL) << 2) | (sf & 3UL)) == (unsigned long )((1 << 2) | 3)) {
#line 354
      goto case_exp___2;
    }
#line 358
    if ((((df & 3UL) << 2) | (sf & 3UL)) == 0UL) {
#line 358
      goto case_0___0;
    }
#line 358
    if ((((df & 3UL) << 2) | (sf & 3UL)) == (unsigned long )((1 << 2) | 1)) {
#line 358
      goto case_0___0;
    }
#line 361
    goto switch_default;
    case_exp: /* CIL Label */ 
    case_exp___0: /* CIL Label */ 
#line 349
    xf = gx[f];
#line 350
    goto switch_break___0;
    case_exp___1: /* CIL Label */ 
#line 352
    xf = d1s0gx[f];
#line 353
    goto switch_break___0;
    case_exp___2: /* CIL Label */ 
#line 355
    xf = d0s1gx[f];
#line 356
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
#line 359
    xf = d0s0gx[f];
#line 360
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 369
    *bltfunc = 1;
#line 370
    xf = 3;
    {
#line 374
    if (c == ((2 << 2) | 3)) {
#line 374
      goto case_exp___4;
    }
#line 374
    if (c == 3) {
#line 374
      goto case_exp___4;
    }
#line 378
    if (c == 3 << 2) {
#line 378
      goto case_exp___5;
    }
#line 382
    if (c == ((3 << 2) | 2)) {
#line 382
      goto case_exp___6;
    }
#line 386
    goto switch_default___0;
    case_exp___4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 375
    fg = _fgpixel;
#line 376
    bg = _bgpixel;
#line 377
    goto switch_break___1;
    case_exp___5: /* CIL Label */ 
#line 379
    fg = 0UL;
#line 380
    bg = 1UL;
#line 381
    goto switch_break___1;
    case_exp___6: /* CIL Label */ 
#line 383
    fg = 1UL;
#line 384
    bg = 0UL;
#line 385
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 387
    berror((char *)"bad combination of copy bitmaps");
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 389
    gcv.foreground = fg;
#line 390
    gcv.background = bg;
#line 391
    gcvm |= (unsigned long )((1L << 2) | (1L << 3));
    switch_break___0: /* CIL Label */ ;
    }
#line 393
    gcv.function = xf;
#line 394
    gcvm |= 1UL;
  }
  {
#line 399
  tmp = _getgc(db, gcvm, & gcv);
  }
#line 399
  return (tmp);
}
}
#line 231 "./../include/libg.h"
Rectangle bscreenrect(Rectangle *clipr___0 ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/bscreenrect.c"
Rectangle bscreenrect(Rectangle *clipr___0 ) 
{ 


  {
#line 14
  if (clipr___0) {
#line 15
    *clipr___0 = screen.clipr;
  }
#line 16
  return (screen.r);
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Text *data_tag(Data *d ) ;
#line 190
void undo_record(Text *t___0 , Range r , Rstring s ) ;
#line 193
void undo_free(Text *t___0 ) ;
#line 194
void undo_reset(Text *t___0 ) ;
#line 195
void undo_start(Text *t___0 ) ;
#line 196
void undo_break(Text *t___0 ) ;
#line 197
void undo_mark(Text *t___0 ) ;
#line 198
Bool undo_atmark(Text *t___0 ) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Bool undoing  =    (Bool )0;
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Range illegal_range  =    {(ulong )10, (ulong )1};
#line 27
static Undo *reverse(Text *t___0 , Range r , Rstring s ) ;
#line 28
static Bool append(Text *t___0 , Range r , Rstring s ) ;
#line 29
static void reset(Undo **head ) ;
#line 30
static void save_state(Text *t___0 ) ;
#line 31
static void update_state(Text *t___0 ) ;
#line 32
static Range shift(Text *t___0 , Undo **from , Undo **to , Bool change_text ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void text_rmtool(Text *t___0 , char *s ) 
{ 
  Text *tmp ;

  {
#line 36
  if (t___0->data) {
    {
#line 37
    tmp = data_tag(t___0->data);
#line 37
    tag_rmtool(tmp, s);
    }
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void text_addtool(Text *t___0 , char *s ) 
{ 
  Text *tmp ;

  {
  {
#line 42
  tmp = data_tag(t___0->data);
#line 42
  tag_addtool(tmp, s);
  }
#line 43
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_record(Text *t___0 , Range r , Rstring s ) 
{ 
  Undo *u ;
  Bool tmp ;

  {
#line 58
  if (undoing) {
#line 59
    return;
  } else
#line 58
  if ((unsigned int )t___0->undoing == 0U) {
#line 59
    return;
  }
  {
#line 61
  save_state(t___0);
#line 63
  tmp = append(t___0, r, s);
  }
#line 63
  if (! tmp) {
    {
#line 65
    reset(& t___0->undone);
#line 67
    u = reverse(t___0, r, s);
#line 68
    u->next = t___0->did;
#line 69
    t___0->did = u;
    }
  }
  {
#line 71
  t___0->undoing = (enum __anonenum_undoing_61 )2;
#line 73
  update_state(t___0);
  }
#line 74
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
Range undo_undo(Text *t___0 , Bool all ) 
{ 
  Range r ;
  Range tmp ;

  {
#line 85
  if (! t___0->did) {
#line 86
    return (illegal_range);
  }
  {
#line 88
  save_state(t___0);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    r = shift(t___0, & t___0->did, & t___0->undone, (Bool )1);
    }
#line 90
    if (all) {
#line 90
      if (t___0->did) {
#line 90
        if (! ((unsigned long )t___0->did != (unsigned long )t___0->mark)) {
#line 90
          goto while_break;
        }
      } else {
#line 90
        goto while_break;
      }
    } else {
#line 90
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  update_state(t___0);
  }
#line 95
  if (all) {
#line 95
    tmp = illegal_range;
  } else {
#line 95
    tmp = r;
  }
#line 95
  return (tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
Range undo_redo(Text *t___0 , Bool all ) 
{ 
  Range r ;
  Undo *tmp ;

  {
  {
#line 105
  save_state(t___0);
#line 107
  tmp = t___0->did;
#line 108
  t___0->did = t___0->undone;
#line 109
  t___0->undone = tmp;
#line 111
  r = undo_undo(t___0, all);
#line 113
  tmp = t___0->did;
#line 114
  t___0->did = t___0->undone;
#line 115
  t___0->undone = tmp;
#line 117
  update_state(t___0);
  }
#line 118
  return (r);
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_free(Text *t___0 ) 
{ 


  {
  {
#line 124
  reset(& t___0->did);
#line 125
  reset(& t___0->undone);
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_reset(Text *t___0 ) 
{ 


  {
  {
#line 132
  undo_free(t___0);
#line 133
  t___0->undoing = (enum __anonenum_undoing_61 )0;
#line 134
  text_rmtool(t___0, (char *)"Put");
#line 135
  text_rmtool(t___0, (char *)"Undo");
#line 136
  text_rmtool(t___0, (char *)"Redo");
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_start(Text *t___0 ) 
{ 


  {
#line 143
  t___0->undoing = (enum __anonenum_undoing_61 )1;
#line 144
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_break(Text *t___0 ) 
{ 


  {
#line 153
  if ((unsigned int )t___0->undoing == 2U) {
#line 154
    t___0->undoing = (enum __anonenum_undoing_61 )1;
  }
#line 155
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
void undo_mark(Text *t___0 ) 
{ 


  {
#line 163
  t___0->mark = t___0->did;
#line 164
  t___0->undoing = (enum __anonenum_undoing_61 )1;
#line 165
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
Bool undo_atmark(Text *t___0 ) 
{ 


  {
#line 172
  return ((Bool )((unsigned long )t___0->mark == (unsigned long )t___0->did));
}
}
#line 178
static void tag(Text *t___0 , Bool before , Bool after , char *s ) ;
#line 179
static Bool undo_eq(Undo *u , Range r , Rstring s ) ;
#line 186 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Bool append(Text *t___0 , Range r , Rstring s ) 
{ 
  Undo *u ;
  Rune *buf___3 ;
  int rlen ;
  int slen ;
  Bool tmp ;
  void *tmp___0 ;
  ulong tmp___1 ;

  {
  {
#line 193
  tmp = undo_eq(t___0->did, r, s);
  }
#line 193
  if (tmp) {
    {
#line 199
    save_state(t___0);
#line 200
    shift(t___0, & t___0->did, & t___0->undone, (Bool )0);
#line 201
    update_state(t___0);
    }
#line 203
    return ((Bool )1);
  }
#line 205
  if (t___0->did) {
#line 205
    if ((unsigned int )t___0->undoing == 2U) {
#line 205
      if (! ((unsigned long )t___0->did != (unsigned long )t___0->mark)) {
#line 206
        return ((Bool )0);
      }
    } else {
#line 206
      return ((Bool )0);
    }
  } else {
#line 206
    return ((Bool )0);
  }
#line 208
  u = t___0->did;
#line 210
  if (u->r.p1 == r.p0) {
#line 210
    if (r.p1 - r.p0 == 0UL) {
#line 210
      if (u->s.r1 - u->s.r0 == 0L) {
#line 211
        u->r.p1 += (ulong )(s.r1 - s.r0);
#line 212
        return ((Bool )1);
      }
    }
  }
#line 214
  if (u->r.p1 - u->r.p0 == 0UL) {
#line 214
    if (s.r1 - s.r0 == 0L) {
#line 214
      if (u->r.p0 == r.p1) {
        {
#line 215
        slen = (int )(u->s.r1 - u->s.r0);
#line 216
        rlen = (int )(r.p1 - r.p0);
#line 217
        tmp___0 = salloc((int )((unsigned long )(slen + rlen) * sizeof(Rune )));
#line 217
        buf___3 = (Rune *)tmp___0;
#line 218
        text_copy(t___0, r, buf___3);
#line 219
        memcpy((void */* __restrict  */)(buf___3 + rlen), (void const   */* __restrict  */)u->s.r0,
               (unsigned long )slen * sizeof(Rune ));
#line 220
        free((void *)u->s.r0);
#line 221
        u->s.r0 = buf___3;
#line 222
        u->s.r1 = (buf___3 + slen) + rlen;
#line 223
        tmp___1 = r.p0;
#line 223
        u->r.p1 = tmp___1;
#line 223
        u->r.p0 = tmp___1;
        }
#line 224
        return ((Bool )1);
      }
    }
  }
#line 226
  return ((Bool )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void reset(Undo **head ) 
{ 
  Undo *u ;
  Undo *next ;

  {
#line 235
  u = *head;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! u) {
#line 235
      goto while_break;
    }
    {
#line 236
    next = u->next;
#line 237
    free((void *)u->s.r0);
#line 238
    free((void *)u);
#line 235
    u = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  *head = (Undo *)0;
#line 241
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Undo *did  ;
#line 248 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Undo *undone  ;
#line 249 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Bool state_count  =    (Bool )0;
#line 250 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void save_state(Text *t___0 ) 
{ 
  Bool tmp ;

  {
#line 253
  tmp = state_count;
#line 253
  state_count = (Bool )((unsigned int )state_count + 1U);
#line 253
  if (tmp) {
#line 254
    return;
  }
#line 255
  did = t___0->did;
#line 256
  undone = t___0->undone;
#line 257
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void update_state(Text *t___0 ) 
{ 


  {
#line 261
  state_count = (Bool )((unsigned int )state_count - 1U);
#line 261
  if (state_count) {
#line 262
    return;
  }
#line 263
  if (t___0->needsbackup) {
    {
#line 264
    tag(t___0, (Bool )did, (Bool )t___0->did, (char *)"Undo");
#line 265
    tag(t___0, (Bool )undone, (Bool )t___0->undone, (char *)"Redo");
#line 266
    tag(t___0, (Bool )((unsigned long )t___0->did == (unsigned long )t___0->mark),
        (Bool )((unsigned long )did == (unsigned long )t___0->mark), (char *)"Put");
    }
  }
#line 268
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Range shift(Text *t___0 , Undo **from , Undo **to , Bool change_text ) 
{ 
  Range r ;
  Undo *u ;
  Undo *rev ;

  {
  {
#line 284
  u = *from;
#line 286
  *from = u->next;
#line 288
  rev = reverse(t___0, u->r, u->s);
  }
#line 290
  if (change_text) {
    {
#line 291
    undoing = (Bool )1;
#line 292
    r = text_replace(t___0, u->r, u->s);
#line 293
    undoing = (Bool )0;
    }
  }
  {
#line 296
  free((void *)u->s.r0);
#line 297
  free((void *)u);
#line 299
  rev->next = *to;
#line 300
  *to = rev;
  }
#line 302
  return (r);
}
}
#line 308 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static void tag(Text *t___0 , Bool before , Bool after , char *s ) 
{ 
  void (*tmp)(Text *t , char *s ) ;

  {
#line 311
  if ((unsigned int )before != (unsigned int )after) {
#line 312
    if (after) {
#line 312
      tmp = & text_addtool;
    } else {
#line 312
      tmp = & text_rmtool;
    }
    {
#line 312
    (*tmp)(t___0, s);
    }
  }
#line 313
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
int rstrcmp(Rstring s1 , Rstring s2 ) 
{ 
  Rune *p1 ;
  Rune *p2 ;
  int diff ;

  {
#line 325
  p1 = s1.r0;
#line 325
  p2 = s2.r0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if ((unsigned long )p1 < (unsigned long )s1.r1) {
#line 325
      if (! ((unsigned long )p2 < (unsigned long )s2.r1)) {
#line 325
        goto while_break;
      }
    } else {
#line 325
      goto while_break;
    }
#line 326
    diff = (int )*p1 - (int )*p2;
#line 326
    if (diff) {
#line 327
      return (diff);
    }
#line 325
    p1 ++;
#line 325
    p2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return ((int )((s1.r1 - s1.r0) - (s2.r1 - s2.r0)));
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Bool undo_eq(Undo *u , Range r , Rstring s ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 334
  if (u) {
#line 334
    if (r.p0 == u->r.p0) {
#line 334
      if (r.p1 == u->r.p1) {
        {
#line 334
        tmp = rstrcmp(u->s, s);
        }
#line 334
        if (tmp) {
#line 334
          tmp___0 = 0;
        } else {
#line 334
          tmp___0 = 1;
        }
      } else {
#line 334
        tmp___0 = 0;
      }
    } else {
#line 334
      tmp___0 = 0;
    }
  } else {
#line 334
    tmp___0 = 0;
  }
#line 334
  return ((Bool )tmp___0);
}
}
#line 341 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/undo.c"
static Undo *reverse(Text *t___0 , Range r , Rstring s ) 
{ 
  Undo *u ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 346
  tmp = salloc((int )sizeof(Undo ));
#line 346
  u = (Undo *)tmp;
#line 347
  u->r.p0 = r.p0;
#line 348
  u->r.p1 = r.p0 + (ulong )(s.r1 - s.r0);
#line 349
  u->alloced = r.p1 - r.p0;
#line 350
  tmp___0 = salloc((int )(u->alloced * sizeof(Rune )));
#line 350
  u->s.r0 = (Rune *)tmp___0;
#line 351
  text_copy(t___0, r, u->s.r0);
#line 352
  u->s.r1 = u->s.r0 + (r.p1 - r.p0);
  }
#line 353
  return (u);
}
}
#line 50 "./../include/frame.h"
uchar *_frallocstr(unsigned int n ) ;
#line 51
void _frinsure(Frame *f , int bn , unsigned int n ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frstr.c"
uchar *_frallocstr(unsigned int n ) 
{ 
  uchar *p ;
  void *tmp ;

  {
  {
#line 19
  tmp = malloc((size_t )((n + 16U) & 4294967280U));
#line 19
  p = (uchar *)tmp;
  }
#line 20
  if ((unsigned long )p == (unsigned long )((uchar *)0)) {
    {
#line 21
    berror((char *)"out of memory");
    }
  }
#line 22
  return (p);
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frstr.c"
void _frinsure(Frame *f , int bn , unsigned int n ) 
{ 
  Frbox *b ;
  uchar *p ;
  size_t tmp ;

  {
#line 31
  b = f->box + bn;
#line 32
  if (b->nrune < 0L) {
    {
#line 33
    berror((char *)"_frinsure");
    }
  }
#line 34
  if (((b->nrune + 16L) & -16L) > (long )n) {
#line 35
    return;
  }
  {
#line 36
  p = _frallocstr(n);
#line 37
  b = f->box + bn;
#line 38
  tmp = strlen((char const   *)((char *)b->a.ptr));
#line 38
  memmove((void *)p, (void const   *)b->a.ptr, tmp + 1UL);
#line 39
  free((void *)b->a.ptr);
#line 40
  b->a.ptr = p;
  }
#line 41
  return;
}
}
#line 209 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Text *data_body(Data *d ) ;
#line 26
char **data_names(Data *d ) ;
#line 31
int data_del(Data *d ) ;
#line 140
int text_write_range(Text *t___0 , Range r , int fd ) ;
#line 144
void text_free(Text *t___0 ) ;
#line 147
void text_allread(Text *t___0 ) ;
#line 152
Bool text_needsbackup(Text *t___0 ) ;
#line 154
View *text_body(Text *t___0 ) ;
#line 156
void text_setneedsbackup(Text *t___0 , Bool b ) ;
#line 158
void text_addview(Text *t___0 , View *v ) ;
#line 159
int text_rmview(Text *t___0 , View *v ) ;
#line 161
int text_write(Text *t___0 , char *fname ) ;
#line 164
Rstring text_autoindent(Text *t___0 , ulong p ) ;
#line 168
void text_fillbutton(Text *t___0 , Fcode f ) ;
#line 172
int text_copyutf(Text *t___0 , Range r , char *buf___3 ) ;
#line 175
void text_formatdir(Text *t___0 , char **names ) ;
#line 262
void viewlist_refresh(View *v ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
void text_allread(Text *t___0 ) 
{ 


  {
  {
#line 15
  undo_reset(t___0);
#line 16
  undo_start(t___0);
#line 17
  viewlist_refresh(t___0->v);
  }
#line 18
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Data *text_data(Text *t___0 ) 
{ 
  Data *tmp ;

  {
#line 25
  if (t___0) {
#line 25
    tmp = t___0->data;
  } else {
#line 25
    tmp = (Data *)0;
  }
#line 25
  return (tmp);
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
View *text_view(Text *t___0 ) 
{ 


  {
#line 30
  return (t___0->v);
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
ulong text_length(Text *t___0 ) 
{ 


  {
#line 35
  return (t___0->length);
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Bool text_needsbackup(Text *t___0 ) 
{ 


  {
#line 40
  return (t___0->needsbackup);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
View *text_body(Text *t___0 ) 
{ 


  {
#line 49
  if (t___0->data) {
#line 50
    if (! t___0->isbody) {
      {
#line 51
      t___0 = data_body(t___0->data);
      }
#line 52
      return (t___0->v);
    } else {
#line 54
      return (t___0->v);
    }
  } else {
#line 57
    return ((View *)0);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
void text_setneedsbackup(Text *t___0 , Bool b ) 
{ 


  {
#line 67
  t___0->needsbackup = b;
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Bool text_badrange(Text *t___0 , Range r ) 
{ 
  int tmp ;

  {
#line 72
  if (r.p1 > t___0->length) {
#line 72
    tmp = 1;
  } else
#line 72
  if (r.p0 > r.p1) {
#line 72
    tmp = 1;
  } else {
#line 72
    tmp = 0;
  }
#line 72
  return ((Bool )tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
void text_addview(Text *t___0 , View *v ) 
{ 


  {
#line 77
  v->next = t___0->v;
#line 78
  t___0->v = v;
#line 79
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
int text_rmview(Text *t___0 , View *v ) 
{ 
  View **ptr ;
  int tmp ;

  {
#line 90
  if ((unsigned long )t___0->v == (unsigned long )v) {
#line 90
    if ((unsigned long )v->next == (unsigned long )((View *)0)) {
#line 92
      if (t___0->isbody) {
        {
#line 92
        tmp = data_del(t___0->data);
        }
#line 92
        if (tmp) {
#line 93
          return (-1);
        }
      }
    }
  }
#line 96
  ptr = & t___0->v;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ((unsigned long )*ptr != (unsigned long )v)) {
#line 96
      goto while_break;
    }
#line 96
    ptr = & (*ptr)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *ptr = v->next;
#line 100
  if (! t___0->v) {
    {
#line 101
    text_free(t___0);
#line 102
    free((void *)t___0);
    }
  }
#line 104
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
int text_write(Text *t___0 , char *fname ) 
{ 
  int fd ;
  int retval ;
  Range tmp ;

  {
  {
#line 118
  fd = open((char const   *)fname, 578, 438);
  }
#line 118
  if (fd < 0) {
    {
#line 119
    diag(fname, (char *)"couldn\'t open %s for write", fname);
    }
#line 120
    return (1);
  }
  {
#line 122
  tmp = range((ulong )0, t___0->length);
#line 122
  retval = text_write_range(t___0, tmp, fd);
  }
#line 123
  if (retval) {
    {
#line 124
    diag(fname, (char *)"couldn\'t write %s", fname);
    }
  }
  {
#line 125
  close(fd);
  }
#line 126
  return (retval);
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
int text_fd(Text *t___0 , Range sel___0 ) 
{ 
  char *file ;
  char *tmp ;
  int fd ;
  int input ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 139
  tmp = tmpnam((char *)0);
#line 139
  file = tmp;
#line 143
  fd = open((char const   *)file, 65, 384);
  }
#line 143
  if (fd < 0) {
    {
#line 144
    perror("open temp file");
#line 145
    unlink((char const   *)file);
    }
#line 146
    return (-1);
  }
  {
#line 150
  input = open((char const   *)file, 0);
  }
#line 150
  if (input < 0) {
    {
#line 151
    perror("open temp file");
#line 152
    unlink((char const   *)file);
    }
#line 153
    return (-1);
  }
  {
#line 156
  tmp___0 = unlink((char const   *)file);
  }
#line 156
  if (tmp___0 < 0) {
    {
#line 157
    perror("unlink temp file");
    }
  }
  {
#line 164
  tmp___1 = text_write_range(t___0, sel___0, fd);
  }
#line 164
  if (tmp___1) {
    {
#line 165
    perror("write temp file");
    }
#line 166
    return (-1);
  }
  {
#line 168
  tmp___2 = close(fd);
  }
#line 168
  if (tmp___2 < 0) {
    {
#line 169
    perror("close temp file");
    }
  }
#line 171
  return (input);
}
}
#line 188 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
static Rune buf___2[128]  ;
#line 185 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Rstring text_autoindent(Text *t___0 , ulong p ) 
{ 
  Rstring s ;
  Range r ;
  int i ;
  ulong tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 193
  buf___2[0] = (Rune )'\n';
#line 194
  s.r0 = buf___2;
#line 196
  tmp = text_startOfLine(t___0, p);
#line 196
  r = range(tmp, p);
  }
#line 197
  if (r.p1 - r.p0 > 128UL) {
#line 198
    r.p1 = r.p0 + 128UL;
  }
  {
#line 199
  text_copy(t___0, r, buf___2 + 1);
#line 201
  i = 1;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if ((ulong )i <= r.p1 - r.p0) {
      {
#line 202
      tmp___0 = __ctype_b_loc();
      }
#line 202
      if (! ((int const   )*(*tmp___0 + (int )buf___2[i]) & 8192)) {
#line 202
        goto while_break;
      }
    } else {
#line 202
      goto while_break;
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  s.r1 = buf___2 + i;
#line 206
  return (s);
}
}
#line 219 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
int back_height(Text *t___0 , ulong p , Font___0 *f , int width , int height ) 
{ 
  int c ;
  int hpos ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  ulong tmp___3 ;

  {
#line 223
  if (p > 0UL) {
#line 223
    p --;
  }
#line 224
  hpos = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (p > 0UL) {
#line 224
      if (! (height > 0)) {
#line 224
        goto while_break;
      }
    } else {
#line 224
      goto while_break;
    }
#line 225
    t___0->pos = p;
#line 226
    if (t___0->pos < t___0->gap.p0) {
#line 226
      tmp = t___0->pos;
#line 226
      (t___0->pos) ++;
#line 226
      c = (int )*(t___0->text + tmp);
    } else {
#line 226
      if (t___0->pos < t___0->length) {
#line 226
        tmp___0 = t___0->pos;
#line 226
        (t___0->pos) ++;
#line 226
        tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 226
        tmp___1 = -1;
      }
#line 226
      c = tmp___1;
    }
    {
#line 228
    if (c == 9) {
#line 228
      goto case_9;
    }
#line 229
    if (c == 10) {
#line 229
      goto case_10;
    }
#line 230
    goto switch_default;
    case_9: /* CIL Label */ 
#line 228
    hpos += tabsize;
#line 228
    goto switch_break;
    case_10: /* CIL Label */ 
#line 229
    hpos = 0;
#line 229
    height -= (int )f->height;
#line 229
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 230
    tmp___2 = charwidth(f, (Rune )c);
#line 230
    hpos = (int )((long )hpos + tmp___2);
    }
#line 230
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 232
    if (hpos >= width) {
#line 233
      hpos = 0;
#line 234
      height -= (int )f->height;
    }
#line 224
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  if (p) {
#line 237
    tmp___3 = p + 2UL;
  } else {
#line 237
    tmp___3 = p;
  }
#line 237
  return ((int )tmp___3);
}
}
#line 240 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Range text_all(Text *t___0 ) 
{ 
  Range r ;

  {
#line 244
  r.p0 = (ulong )0;
#line 245
  r.p1 = t___0->length;
#line 246
  return (r);
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
void text_fillbutton(Text *t___0 , Fcode f ) 
{ 
  View *v ;

  {
#line 252
  v = t___0->v;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! v) {
#line 252
      goto while_break;
    }
    {
#line 253
    view_fillbutton(v, f);
#line 252
    v = v->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
ulong text_ncopy(Text *t___0 , Rune *buf___3 , ulong p , ulong n ) 
{ 
  Range r ;
  ulong tmp ;

  {
#line 263
  if (p >= t___0->length) {
#line 264
    return ((ulong )0);
  }
#line 265
  if (p + n < t___0->length) {
#line 265
    tmp = p + n;
  } else {
#line 265
    tmp = t___0->length;
  }
  {
#line 265
  r = range(p, tmp);
#line 266
  text_copy(t___0, r, buf___3);
  }
#line 267
  return (r.p1 - r.p0);
}
}
#line 271 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Range text_replaceutf(Text *t___0 , Range r , char *utf ) 
{ 
  Rstring s ;

  {
  {
#line 275
  s = utf2rstring(utf);
#line 276
  r = text_replace(t___0, r, s);
  }
#line 277
  if (s.r0) {
    {
#line 278
    free((void *)s.r0);
    }
  }
#line 279
  return (r);
}
}
#line 285 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
char *text_duputf(Text *t___0 , Range r ) 
{ 
  ulong len ;
  ulong n ;
  char *buf___3 ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 287
  len = r.p1 - r.p0;
#line 291
  if (! len) {
    {
#line 292
    tmp = strdup("");
    }
#line 292
    return (tmp);
  }
  {
#line 294
  tmp___0 = salloc((int )(len * 3UL));
#line 294
  buf___3 = (char *)tmp___0;
#line 295
  tmp___1 = text_copyutf(t___0, r, buf___3);
#line 295
  n = (ulong )tmp___1;
#line 296
  *(buf___3 + n) = (char )'\000';
  }
#line 297
  return (buf___3);
}
}
#line 304 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
int text_copyutf(Text *t___0 , Range r , char *buf___3 ) 
{ 
  Rune *rbuf ;
  int rlen ;
  int n ;
  void *tmp ;
  ulong tmp___0 ;

  {
  {
#line 311
  rlen = (int )(r.p1 - r.p0);
#line 313
  tmp = salloc((int )((unsigned long )rlen * sizeof(Rune )));
#line 313
  rbuf = (Rune *)tmp;
#line 314
  text_copy(t___0, r, rbuf);
#line 315
  tmp___0 = texttoutf(buf___3, rbuf, rbuf + rlen);
#line 315
  n = (int )tmp___0;
#line 316
  free((void *)rbuf);
  }
#line 317
  return (n);
}
}
#line 323 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
static void text_getdir(Text *t___0 , char **names ) 
{ 
  Frame *f ;
  char *s ;
  Range tmp ;

  {
  {
#line 328
  f = & (t___0->v)->f;
#line 329
  s = columnate(f->r.max.x - f->r.min.x, (int )f->maxtab, f->font, names);
#line 331
  undo_reset(t___0);
#line 332
  tmp = range((ulong )0, t___0->length);
#line 332
  text_replaceutf(t___0, tmp, s);
#line 333
  undo_start(t___0);
#line 334
  free((void *)s);
  }
#line 335
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
Bool text_refreshdir(Text *t___0 ) 
{ 
  char **names ;
  Bool tmp ;

  {
#line 346
  if (t___0->isbody) {
    {
#line 346
    names = data_names(t___0->data);
    }
#line 346
    if (names) {
      {
#line 346
      tmp = undo_atmark(t___0);
      }
#line 346
      if (tmp) {
#line 346
        if (t___0->v) {
          {
#line 347
          text_getdir(t___0, names);
          }
#line 348
          return ((Bool )1);
        } else {
#line 350
          return ((Bool )0);
        }
      } else {
#line 350
        return ((Bool )0);
      }
    } else {
#line 350
      return ((Bool )0);
    }
  } else {
#line 350
    return ((Bool )0);
  }
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text2.c"
void text_formatdir(Text *t___0 , char **names ) 
{ 


  {
#line 359
  if (t___0->v) {
#line 359
    if (! names) {
#line 360
      return;
    }
  } else {
#line 360
    return;
  }
  {
#line 362
  text_getdir(t___0, names);
#line 363
  viewlist_refresh(t___0->v);
  }
#line 364
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 115 "./../include/msg.h"
void eprintf(char *fmt  , ...) ;
#line 118
Range intersect(Range a , Range b ) ;
#line 119
Range rclip(Range r , Range c ) ;
#line 122
ulong ladjust(ulong val , Range r , int len ) ;
#line 123
ulong radjust(ulong val , Range r , int len ) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
ulong ladjust(ulong val , Range r , int len ) 
{ 


  {
#line 13
  if (val > r.p1) {
#line 14
    return ((val + (ulong )len) - (r.p1 - r.p0));
  } else
#line 15
  if (val > r.p0) {
#line 16
    return (r.p0);
  } else {
#line 18
    return (val);
  }
}
}
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
ulong radjust(ulong val , Range r , int len ) 
{ 


  {
#line 24
  if (val > r.p1) {
#line 25
    return ((val + (ulong )len) - (r.p1 - r.p0));
  } else
#line 26
  if (val >= r.p0) {
#line 27
    return (r.p0 + (ulong )len);
  } else {
#line 29
    return (val);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
int clip(int orig , int low , int high ) 
{ 


  {
#line 36
  if (! (low <= high)) {
    {
#line 36
    __assert_fail("low<= high", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c",
                  36U, "clip");
    }
  }
#line 38
  if (orig < low) {
#line 39
    orig = low;
  }
#line 40
  if (orig > high) {
#line 41
    orig = high;
  }
#line 42
  return (orig);
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
Range rclip(Range r , Range c ) 
{ 
  ulong tmp ;
  ulong tmp___0 ;
  Range tmp___1 ;

  {
  {
#line 48
  tmp = pclipr(r.p1, c);
#line 48
  tmp___0 = pclipr(r.p0, c);
#line 48
  tmp___1 = range(tmp___0, tmp);
  }
#line 48
  return (tmp___1);
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
ulong pclipr(ulong p , Range r ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = clip((int )p, (int )r.p0, (int )r.p1);
  }
#line 54
  return ((ulong )tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
Range intersect(Range a , Range b ) 
{ 
  ulong tmp ;
  ulong tmp___0 ;
  Range tmp___1 ;

  {
#line 60
  if (a.p1 < b.p1) {
#line 60
    tmp = a.p1;
  } else {
#line 60
    tmp = b.p1;
  }
#line 60
  if (a.p0 > b.p0) {
#line 60
    tmp___0 = a.p0;
  } else {
#line 60
    tmp___0 = b.p0;
  }
  {
#line 60
  tmp___1 = range(tmp___0, tmp);
  }
#line 60
  return (tmp___1);
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
Range range(ulong p0 , ulong p1 ) 
{ 
  Range r ;

  {
#line 68
  r.p0 = p0;
#line 69
  r.p1 = p1;
#line 70
  return (r);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
void *srealloc(void *orig , int size ) 
{ 
  void *p ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 81
  if (! (size >= 0)) {
    {
#line 81
    __assert_fail("size>=0", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c",
                  81U, "srealloc");
    }
  }
#line 83
  if (size) {
#line 83
    size = size;
  } else {
#line 83
    size = 2;
  }
#line 84
  if (orig) {
    {
#line 84
    tmp = realloc(orig, (size_t )size);
#line 84
    p = tmp;
    }
  } else {
    {
#line 84
    tmp___0 = malloc((size_t )size);
#line 84
    p = tmp___0;
    }
  }
#line 86
  if (! p) {
    {
#line 87
    perror("alloc");
#line 88
    abort();
    }
  }
#line 90
  return (p);
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
void *salloc(int size ) 
{ 
  void *p ;

  {
#line 101
  if (! (size >= 0)) {
    {
#line 101
    __assert_fail("size>=0", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c",
                  101U, "salloc");
    }
  }
#line 103
  if (size) {
#line 103
    size = size;
  } else {
#line 103
    size = (int )sizeof(int );
  }
  {
#line 104
  p = malloc((size_t )size);
  }
#line 105
  if (! p) {
    {
#line 106
    abort();
    }
  }
#line 107
  return (p);
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/util.c"
void eprintf(char *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 117
  __builtin_va_start(args___0, fmt);
#line 118
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args___0);
  }
#line 119
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void data_setlabel(Data *d , char *s ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
static void data_restat(Data *d ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
void data_addcontext(Data *d , char *dest , char *orig ) 
{ 
  char *tmp ;

  {
#line 14
  if (d) {
#line 14
    tmp = d->label;
  } else {
#line 14
    tmp = wilydir;
  }
  {
#line 14
  addcontext(dest, tmp, orig);
#line 15
  labelclean(dest);
  }
#line 16
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
void data_getlabel(Data *d , char *dest ) 
{ 
  char *tmp ;

  {
#line 21
  if (d) {
#line 21
    tmp = d->label;
  } else {
#line 21
    tmp = wilydir;
  }
  {
#line 21
  strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)tmp);
  }
#line 22
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
void data_setlabel(Data *d , char *s ) 
{ 
  Bool tmp ;
  int tmp___0 ;

  {
  {
#line 34
  strcpy((char */* __restrict  */)(d->label), (char const   */* __restrict  */)s);
#line 35
  tmp___0 = strcmp((char const   *)(d->label), (char const   *)(d->cachedlabel));
  }
#line 35
  if (tmp___0) {
    {
#line 40
    tag_addtool(d->tag, (char *)"Get");
#line 41
    tag_addtool(d->tag, (char *)"Put");
    }
  } else {
    {
#line 36
    tmp = data_isdirty(d);
    }
#line 36
    if (! tmp) {
      {
#line 37
      tag_rmtool(d->tag, (char *)"Put");
      }
    }
  }
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
View *data_find(char *label ) 
{ 
  Data *d ;
  Stat buf___3 ;
  Path path ;
  View *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  View *tmp___2 ;
  int tmp___3 ;

  {
#line 53
  d = dataroot;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! d) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp___0 = strcmp((char const   *)(d->label), (char const   *)label);
    }
#line 54
    if (! tmp___0) {
      {
#line 55
      tmp = text_view(d->t);
      }
#line 55
      return (tmp);
    }
#line 53
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  label2path(path, label);
#line 60
  tmp___1 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& buf___3));
  }
#line 60
  if (tmp___1) {
#line 61
    return ((View *)0);
  }
#line 63
  d = dataroot;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! d) {
#line 63
      goto while_break___0;
    }
    {
#line 64
    data_restat(d);
    }
#line 65
    if (d->has_stat) {
      {
#line 65
      tmp___3 = statcmp(& buf___3, & d->stat);
      }
#line 65
      if (! tmp___3) {
        {
#line 66
        tmp___2 = text_view(d->t);
        }
#line 66
        return (tmp___2);
      }
    }
#line 63
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  return ((View *)0);
}
}
#line 75 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/label.c"
static void data_restat(Data *d ) 
{ 
  Path path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 77
  tmp___1 = strcmp((char const   *)(d->label), (char const   *)(d->cachedlabel));
  }
#line 77
  if (tmp___1) {
    {
#line 80
    strcpy((char */* __restrict  */)(d->cachedlabel), (char const   */* __restrict  */)(d->label));
#line 81
    label2path(path, d->label);
#line 82
    tmp = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& d->stat));
    }
#line 82
    if (tmp) {
#line 82
      tmp___0 = 0;
    } else {
#line 82
      tmp___0 = 1;
    }
#line 82
    d->has_stat = (Bool )tmp___0;
  }
#line 84
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Point buttonpos(Tile *tile ) ;
#line 178
Bool tile_hidden(Tile *t___0 ) ;
#line 183
void tile_move(Tile *tile , Point p ) ;
#line 186
View *tile_tag(Tile *t___0 ) ;
#line 242
View *view_new(Font___0 *f , Bool istag , Text *text , Tile *tile ) ;
#line 252
int view_height(View *v ) ;
#line 257
void view_setfont(View *v , char *arg ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
Bool tile_invariant(Tile *tile ) ;
#line 36
Bool list_invariant(Tile *list___0 ) ;
#line 39
Tile *point2tile(Tile *tile , Point p ) ;
#line 41
Tile *last_visible_body(Tile *start , Tile *end ) ;
#line 43
Tile *newparent(Tile *tile , Point p ) ;
#line 48
void list_slide(Tile *t___0 ) ;
#line 52
int list_size(Tile *start , Tile *end ) ;
#line 53
int list_basesize(Tile *start , Tile *end ) ;
#line 54
Tile *list_find(Tile *parent , int n ) ;
#line 55
Tile *next_visible(Tile *t___0 ) ;
#line 56
void setcminmax(Tile *list___0 , int *cmin , int *cmax ) ;
#line 57
void moveto(Tile *t___0 , int pos ) ;
#line 58
Rectangle rectangle(Tile *t___0 ) ;
#line 59
int adjust_sizes_in_range(Tile *start , Tile *end , int available ) ;
#line 61
int tile_minsize(Tile *t___0 ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
Bool tile_hidden(Tile *t___0 ) 
{ 
  Bool tmp ;
  int tmp___0 ;

  {
#line 11
  if (t___0->ishidden) {
#line 11
    tmp___0 = 1;
  } else
#line 11
  if (t___0->up) {
    {
#line 11
    tmp = tile_hidden(t___0->up);
    }
#line 11
    if (tmp) {
#line 11
      tmp___0 = 1;
    } else {
#line 11
      tmp___0 = 0;
    }
  } else {
#line 11
    tmp___0 = 0;
  }
#line 11
  return ((Bool )tmp___0);
}
}
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
Bool tile_invariant(Tile *tile ) 
{ 
  int size ;
  int body ;
  int tag___0 ;
  int diff ;
  Tile *last ;

  {
#line 24
  if (tile->ishidden) {
#line 25
    return ((Bool )1);
  }
#line 28
  size = tile->max - tile->min;
#line 31
  if (! tile->body) {
#line 32
    return ((Bool )1);
  }
  {
#line 42
  body = view_height(tile->body);
#line 43
  tag___0 = view_height(tile->tag);
#line 44
  last = last_visible_body(tile, (Tile *)0);
  }
#line 46
  if (! ((unsigned long )tile != (unsigned long )last)) {
#line 50
    diff = size - (body + tag___0);
  }
#line 55
  return ((Bool )1);
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
Bool list_invariant(Tile *list___0 ) 
{ 
  int prev ;
  Tile *t___0 ;
  int diff ;

  {
#line 68
  prev = list___0->cmin;
#line 68
  t___0 = list___0->down;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! t___0) {
#line 68
      goto while_break;
    }
#line 70
    if (t___0->ishidden) {
#line 71
      goto __Cont;
    }
#line 76
    prev = t___0->max;
    __Cont: /* CIL Label */ 
#line 68
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if (list___0->down) {
#line 79
    diff = list___0->cmax - prev;
  }
#line 83
  return ((Bool )1);
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
static void quantize(Tile *t___0 ) 
{ 
  int tag___0 ;
  int body ;
  int size ;

  {
#line 93
  if (! t___0->body) {
#line 94
    return;
  }
  {
#line 96
  size = t___0->max - t___0->min;
#line 97
  tag___0 = snapheight(t___0->tag, size);
#line 100
  body = snapheight(t___0->body, size - tag___0);
#line 101
  t___0->max = (t___0->min + tag___0) + body;
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
static void crop(Tile *t___0 , Tile *list___0 ) 
{ 
  int size ;
  int listsize ;

  {
#line 107
  size = t___0->max - t___0->min;
#line 108
  listsize = list___0->cmax - list___0->cmin;
#line 113
  if (size > listsize) {
#line 114
    t___0->max = t___0->min + listsize;
#line 115
    size = listsize;
  }
#line 118
  if (t___0->min < list___0->cmin) {
    {
#line 119
    moveto(t___0, list___0->cmin);
    }
  }
#line 120
  if (t___0->max > list___0->cmax) {
#line 121
    t___0->max = list___0->cmax;
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_reshaped(Tile *t___0 ) 
{ 
  Rectangle r ;
  Rectangle tmp ;
  int tmp___0 ;

  {
  {
#line 131
  tmp = rectangle(t___0);
#line 131
  r = tmp;
#line 134
  bitblt(& screen, r.min, & screen, r, (Fcode )0);
#line 135
  view_reshaped(t___0->tag, r);
  }
#line 136
  if (t___0->body) {
    {
#line 137
    tmp___0 = view_height(t___0->tag);
#line 137
    r.min.y += tmp___0;
#line 138
    view_reshaped(t___0->body, r);
    }
  } else {
    {
#line 140
    list_reshaped(t___0, (Tile *)0);
    }
  }
#line 143
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void list_add(Tile *list___0 , Tile *tile ) 
{ 
  Tile *left___0 ;
  Tile *next ;
  int max ;
  Path buf___3 ;
  Data *d ;
  Tile *tmp ;

  {
#line 160
  if (tile->body) {
    {
#line 164
    d = view_data(tile->body);
#line 165
    data_getlabel(d, buf___3);
#line 166
    placedcol(buf___3, list___0);
    }
  }
  {
#line 169
  tile->up = list___0;
#line 170
  crop(tile, list___0);
#line 172
  left___0 = list_find(list___0, tile->min);
  }
#line 172
  if (left___0) {
#line 174
    left___0->max = tile->min;
#line 175
    if (left___0->max - left___0->min < tile->base) {
#line 176
      left___0->ishidden = (Bool )1;
    } else {
      {
#line 178
      quantize(left___0);
      }
    }
#line 179
    tile->left = left___0;
#line 180
    tile->right = left___0->right;
#line 181
    left___0->right = tile;
#line 182
    if (tile->right) {
#line 183
      (tile->right)->left = tile;
    }
  } else {
#line 186
    tmp = (Tile *)0;
#line 186
    tile->left = tmp;
#line 186
    tile->right = tmp;
#line 187
    list___0->down = tile;
#line 188
    tile->min = list___0->cmin;
#line 189
    tile->max = list___0->cmax;
  }
  {
#line 193
  next = next_visible(tile);
  }
#line 194
  if (next) {
#line 194
    max = next->min;
  } else {
#line 194
    max = list___0->cmax;
  }
#line 195
  if (tile->max > max) {
#line 195
    tile->max = tile->max;
  } else {
#line 195
    tile->max = max;
  }
#line 196
  if (tile->max - tile->base < tile->min) {
#line 196
    tile->min = tile->max - tile->base;
  } else {
#line 196
    tile->min = tile->min;
  }
  {
#line 197
  list_reshaped(list___0, tile);
  }
#line 198
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
static void adjust_position(Tile *t___0 ) 
{ 
  Tile *l ;
  int size ;
  int available ;
  int before ;
  int after ;
  int minsize ;
  int diff ;
  int move___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 206
  l = t___0->up;
#line 209
  before = list_basesize(l->down, t___0);
#line 210
  after = list_basesize(t___0->right, (Tile *)0);
#line 211
  size = t___0->max - t___0->min;
#line 217
  tmp___1 = tile_minsize(t___0);
  }
#line 217
  if (size / 2 > tmp___1) {
#line 217
    minsize = size / 2;
  } else {
    {
#line 217
    tmp___0 = tile_minsize(t___0);
#line 217
    minsize = tmp___0;
    }
  }
#line 218
  available = size - minsize;
#line 221
  diff = (l->cmin + before) - t___0->min;
#line 222
  if (diff > 0) {
#line 223
    if (available < diff) {
#line 223
      move___0 = available;
    } else {
#line 223
      move___0 = diff;
    }
#line 224
    if (move___0 > 0) {
#line 225
      t___0->min += move___0;
#line 226
      available -= move___0;
    }
  }
#line 231
  diff = t___0->max - (l->cmax - after);
#line 232
  if (diff > 0) {
#line 233
    if (available < diff) {
#line 233
      move___0 = available;
    } else {
#line 233
      move___0 = diff;
    }
#line 234
    if (move___0 > 0) {
#line 235
      t___0->max -= move___0;
    }
  }
#line 238
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void list_reshaped(Tile *l , Tile *tile ) 
{ 
  Tile *t___0 ;
  int cmin ;
  int cmax ;
  Tile *slop ;
  int diff ;
  int tmp ;

  {
#line 254
  if (tile) {
    {
#line 255
    crop(tile, l);
#line 256
    adjust_position(tile);
#line 257
    adjust_sizes_in_range(l->down, tile, tile->min - l->cmin);
#line 258
    adjust_sizes_in_range(tile->right, (Tile *)0, l->cmax - tile->max);
    }
  } else {
    {
#line 260
    adjust_sizes_in_range(l->down, (Tile *)0, l->cmax - l->cmin);
    }
  }
#line 265
  t___0 = l->down;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 265
      goto while_break;
    }
#line 265
    if (! t___0->ishidden) {
      {
#line 266
      quantize(t___0);
      }
    }
#line 265
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  tmp = list_size(l->down, (Tile *)0);
#line 269
  diff = (l->cmax - l->cmin) - tmp;
#line 273
  slop = last_visible_body(l->down, (Tile *)0);
  }
#line 273
  if (slop) {
#line 275
    slop->max += diff;
  } else {
    {
#line 273
    slop = last_visible(l->down, (Tile *)0);
    }
#line 273
    if (slop) {
#line 275
      slop->max += diff;
    }
  }
  {
#line 278
  list_slide(l);
#line 280
  setcminmax(l, & cmin, & cmax);
#line 281
  t___0 = l->down;
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 281
      goto while_break___0;
    }
#line 282
    t___0->cmin = cmin;
#line 283
    t___0->cmax = cmax;
#line 284
    if (! t___0->ishidden) {
      {
#line 285
      tile_reshaped(t___0);
      }
    }
#line 281
    t___0 = t___0->right;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_setfont(Tile *t___0 , char *arg ) 
{ 


  {
#line 298
  if (t___0->body) {
    {
#line 299
    view_setfont(t___0->body, arg);
    }
  } else {
#line 301
    t___0 = t___0->down;
    {
#line 301
    while (1) {
      while_continue: /* CIL Label */ ;
#line 301
      if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 301
        goto while_break;
      }
      {
#line 302
      tile_setfont(t___0, arg);
#line 301
      t___0 = t___0->right;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 305
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_unlink(Tile *tile ) 
{ 
  Rectangle tmp ;
  Rectangle tmp___0 ;

  {
#line 313
  if (tile->right) {
#line 314
    (tile->right)->left = tile->left;
  }
#line 315
  if (tile->left) {
#line 316
    (tile->left)->right = tile->right;
#line 318
    (tile->left)->max = tile->max;
  } else {
#line 320
    (tile->up)->down = tile->right;
  }
  {
#line 323
  list_unhide(tile->up);
#line 324
  tmp = rectangle(tile);
#line 324
  tmp___0 = rectangle(tile);
#line 324
  bitblt(& screen, tmp___0.min, & screen, tmp, (Fcode )0);
#line 325
  list_reshaped(tile->up, (Tile *)0);
  }
#line 326
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_free(Tile *tile ) 
{ 


  {
  {
#line 334
  free((void *)tile->body);
#line 335
  free((void *)tile->tag);
#line 336
  free((void *)tile);
  }
#line 337
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_del(Tile *tile ) 
{ 


  {
  {
#line 345
  tile_unlink(tile);
#line 346
  tile_free(tile);
  }
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
Tile *newparent(Tile *tile , Point p ) 
{ 
  Tile *t___0 ;
  Tile *tmp ;

  {
  {
#line 352
  tmp = point2tile(wily, p);
#line 352
  t___0 = tmp;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned int )t___0->ori == (unsigned int )tile->ori)) {
#line 354
      if (! t___0->body) {
#line 354
        goto while_break;
      }
    }
#line 355
    t___0 = t___0->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (t___0);
}
}
#line 359 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_move(Tile *tile , Point p ) 
{ 
  Tile *parent ;
  int dest ;
  Point tmp ;

  {
  {
#line 365
  parent = point2tile(wily, p);
  }
#line 366
  if ((unsigned long )parent == (unsigned long )((Tile *)0)) {
#line 367
    return;
  } else
#line 366
  if ((unsigned long )parent == (unsigned long )wily) {
#line 367
    return;
  }
  {
#line 369
  tile_unlink(tile);
  }
#line 370
  if ((unsigned int )tile->ori == 0U) {
#line 370
    dest = p.x;
  } else {
#line 370
    dest = p.y;
  }
#line 371
  if (tile->min < dest) {
#line 371
    if (dest < tile->max) {
#line 372
      tile->min = dest;
    } else {
      {
#line 374
      moveto(tile, dest);
      }
    }
  } else {
    {
#line 374
    moveto(tile, dest);
    }
  }
  {
#line 376
  parent = newparent(tile, p);
#line 377
  list_add(parent, tile);
#line 378
  tmp = buttonpos(tile);
#line 378
  cursorset(tmp);
  }
#line 379
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void tile_show(Tile *tile ) 
{ 
  int tmp ;

  {
#line 383
  if (tile->up) {
    {
#line 384
    tile_show(tile->up);
    }
  }
#line 385
  if (tile->ishidden) {
    {
#line 386
    tile_grow(tile, 1);
    }
  } else {
    {
#line 385
    tmp = tile_minsize(tile);
    }
#line 385
    if (tile->max - tile->min < tmp) {
      {
#line 386
      tile_grow(tile, 1);
      }
    }
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
View *tile_body(Tile *t___0 ) 
{ 
  View *tmp ;

  {
#line 391
  if (t___0) {
#line 391
    tmp = t___0->body;
  } else {
#line 391
    tmp = (View *)0;
  }
#line 391
  return (tmp);
}
}
#line 394 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
View *tile_tag(Tile *t___0 ) 
{ 
  View *tmp ;

  {
#line 396
  if (t___0) {
#line 396
    tmp = t___0->tag;
  } else {
#line 396
    tmp = (View *)0;
  }
#line 396
  return (tmp);
}
}
#line 400 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
static void tile_split(Tile *tile , int *min , int *max ) 
{ 
  int lastline ;
  int average ;

  {
#line 405
  *max = tile->max;
#line 406
  average = (tile->max + tile->min) / 2;
#line 408
  if (tile->body) {
    {
#line 409
    lastline = view_lastlinepos(tile->body);
    }
#line 411
    if (average < lastline) {
#line 411
      *min = average;
    } else {
#line 411
      *min = lastline;
    }
  } else {
#line 413
    *min = average;
  }
#line 415
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void findplace(Tile *list___0 , int *min , int *max ) 
{ 
  Tile *biggest ;

  {
  {
#line 426
  biggest = biggest_visible(list___0->down, (Tile *)0);
  }
#line 426
  if (biggest) {
    {
#line 427
    tile_split(biggest, min, max);
    }
  } else {
#line 429
    *max = list___0->cmax;
#line 430
    *min = list___0->cmin;
  }
#line 432
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
void moveto(Tile *t___0 , int pos ) 
{ 
  int size ;

  {
#line 438
  size = t___0->max - t___0->min;
#line 439
  t___0->min = pos;
#line 440
  t___0->max = t___0->min + size;
#line 441
  return;
}
}
#line 444 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
Tile *tile_new(Ori ori , int min , int max , int base , Tile *parent , Text *tagt ,
               Text *bodyt ) 
{ 
  Tile *tile ;
  void *tmp ;
  int minsize ;
  Tile *tmp___0 ;
  Tile *tmp___1 ;
  View *tmp___2 ;

  {
  {
#line 448
  tmp = salloc((int )sizeof(Tile ));
#line 448
  tile = (Tile *)tmp;
#line 451
  tile->ishidden = (Bool )0;
#line 452
  tile->ori = ori;
#line 453
  tile->min = min;
#line 454
  tile->max = max;
#line 455
  tile->base = base;
#line 456
  tile->up = parent;
#line 457
  setcminmax(parent, & tile->cmin, & tile->cmax);
#line 458
  tmp___1 = (Tile *)0;
#line 458
  tile->right = tmp___1;
#line 458
  tmp___0 = tmp___1;
#line 458
  tile->left = tmp___0;
#line 458
  tile->down = tmp___0;
#line 459
  tile->tag = view_new(font, (Bool )1, tagt, tile);
  }
#line 460
  if (bodyt) {
    {
#line 460
    tmp___2 = view_new(font, (Bool )0, bodyt, tile);
#line 460
    tile->body = tmp___2;
    }
  } else {
#line 460
    tile->body = (View *)0;
  }
  {
#line 462
  minsize = tile_minsize(tile);
  }
#line 463
  if (tile->max - tile->min < minsize) {
#line 464
    tile->max = tile->min + minsize;
  }
#line 466
  return (tile);
}
}
#line 470 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.c"
int tile_minsize(Tile *t___0 ) 
{ 


  {
#line 473
  return (3 * t___0->base);
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
char *tag_match(char *label ) ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static Pair *pair  ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static int npairs  =    0;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static int maxpairs  =    0;
#line 26
static Bool match(char *regex , char *s ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static Text *t  =    (Text *)0;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static Bool match(char *regex , char *s ) 
{ 
  Range r ;
  Bool retval ;
  Range tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;
  Range tmp___2 ;

  {
#line 30
  if (! t) {
    {
#line 31
    t = text_alloc((Data *)0, (Bool )0);
    }
  }
  {
#line 32
  r = nr;
#line 33
  tmp = text_all(t);
#line 33
  text_replaceutf(t, tmp, s);
#line 34
  tmp___0 = text_length(t);
#line 34
  tmp___1 = text_length(t);
#line 34
  tmp___2 = range(tmp___1, tmp___0);
#line 34
  text_replaceutf(t, tmp___2, (char *)"\n");
#line 35
  retval = text_utfregexp(t, regex, & r, (Bool )1);
  }
#line 37
  return (retval);
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static void addpair(char *regex , char *tools ) 
{ 
  Pair p ;
  char *nl___0 ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 45
  p.regex = regex;
#line 46
  p.tools = tools;
#line 47
  nl___0 = strchr((char const   *)p.tools, '\n');
  }
#line 47
  if (nl___0) {
#line 48
    *nl___0 = (char)0;
  }
#line 50
  if (npairs == maxpairs) {
#line 51
    if (maxpairs) {
#line 51
      maxpairs *= 2;
    } else {
#line 51
      maxpairs += 10;
    }
    {
#line 52
    tmp = srealloc((void *)pair, (int )((unsigned long )maxpairs * sizeof(Pair )));
#line 52
    pair = (Pair *)tmp;
    }
  }
#line 54
  tmp___0 = npairs;
#line 54
  npairs ++;
#line 54
  *(pair + tmp___0) = p;
#line 55
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static Bool inprogress  ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
char *tag_match(char *label ) 
{ 
  int j ;
  Bool tmp ;
  char const   *tmp___0 ;

  {
#line 62
  if (inprogress) {
#line 63
    j = npairs;
  } else {
#line 65
    inprogress = (Bool )1;
#line 66
    j = 0;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! (j < npairs)) {
#line 66
        goto while_break;
      }
      {
#line 67
      tmp = match((pair + j)->regex, label);
      }
#line 67
      if (tmp) {
#line 68
        goto while_break;
      }
#line 66
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 69
    inprogress = (Bool )0;
  }
#line 71
  if (j < npairs) {
#line 71
    tmp___0 = (char const   *)(pair + j)->tools;
  } else {
#line 71
    tmp___0 = "";
  }
#line 71
  return ((char *)tmp___0);
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
static char *readfile(char *filename ) 
{ 
  char *buf___3 ;
  struct stat statbuf ;
  int fd ;
  off_t size ;
  int nread ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 85
  fd = open((char const   *)filename, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return ((char *)0);
  } else {
    {
#line 86
    tmp = fstat(fd, & statbuf);
    }
#line 86
    if (tmp) {
#line 87
      return ((char *)0);
    }
  }
  {
#line 90
  size = statbuf.st_size;
#line 91
  tmp___0 = salloc((int )(size + 10L));
#line 91
  buf___3 = (char *)tmp___0;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (size > 0L)) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___1 = read(fd, (void *)buf___3, (size_t )size);
#line 93
    nread = (int )tmp___1;
    }
#line 94
    if (nread <= 0) {
      {
#line 95
      perror((char const   *)filename);
#line 96
      free((void *)buf___3);
      }
#line 97
      return ((char *)0);
    }
#line 99
    size -= (off_t )nread;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  close(fd);
  }
#line 102
  return (buf___3);
}
}
#line 111 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tagmatch.c"
void tag_init(char *filename ) 
{ 
  char *buf___3 ;
  char *ptr ;
  char *tab ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 115
  buf___3 = readfile(filename);
  }
#line 115
  if (! buf___3) {
#line 116
    return;
  }
  {
#line 118
  ptr = strtok((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"\n");
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ptr) {
#line 118
      goto while_break;
    }
#line 120
    if ((int )*(ptr + 0) == 35) {
#line 121
      goto __Cont;
    } else {
      {
#line 120
      tmp = __ctype_b_loc();
      }
#line 120
      if ((int const   )*(*tmp + (int )*(ptr + 0)) & 8192) {
#line 121
        goto __Cont;
      }
    }
    {
#line 122
    tab = strchr((char const   *)ptr, '\t');
    }
#line 122
    if (tab) {
      {
#line 123
      tmp___0 = tab;
#line 123
      tab ++;
#line 123
      *tmp___0 = (char)0;
#line 125
      tmp___1 = strspn((char const   *)tab, (char const   *)whitespace);
#line 125
      tab += tmp___1;
#line 126
      addpair(ptr, tab);
      }
    } else {
      {
#line 128
      addpair(ptr, (char *)"");
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 118
    ptr = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 203 "./../include/libg.h"
Font___0 *rdfontfile(char *name , int ldepth ) ;
#line 204
void ffree(Font___0 *f ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdfontfile.c"
static char *skip(char *s ) 
{ 


  {
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! ((int )*s == 32)) {
#line 12
      if (! ((int )*s == 10)) {
#line 12
        if (! ((int )*s == 9)) {
#line 12
          goto while_break;
        }
      }
    }
#line 13
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return (s);
}
}
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdfontfile.c"
Font___0 *rdfontfile(char *name , int ldepth ) 
{ 
  Font___0 *fnt ;
  Cachesubf *c ;
  int fd ;
  int i ;
  char *buf___3 ;
  char *s ;
  char *t___0 ;
  struct stat sbuf ;
  unsigned long min ;
  unsigned long max ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 27
  fd = open((char const   *)name, 0);
  }
#line 28
  if (fd < 0) {
#line 29
    return ((Font___0 *)0);
  }
  {
#line 30
  tmp = fstat(fd, & sbuf);
  }
#line 30
  if (tmp < 0) {
    Err0: 
    {
#line 33
    close(fd);
    }
#line 34
    return ((Font___0 *)0);
  }
  {
#line 36
  tmp___0 = malloc((size_t )(sbuf.st_size + 1L));
#line 36
  buf___3 = (char *)tmp___0;
  }
#line 37
  if ((unsigned long )buf___3 == (unsigned long )((char *)0)) {
#line 38
    goto Err0;
  }
  {
#line 39
  *(buf___3 + sbuf.st_size) = (char)0;
#line 40
  tmp___1 = read(fd, (void *)buf___3, (size_t )sbuf.st_size);
#line 40
  i = (int )tmp___1;
#line 41
  close(fd);
  }
#line 42
  if ((__off_t )i != sbuf.st_size) {
    Err1: 
    {
#line 45
    free((void *)buf___3);
    }
#line 46
    return ((Font___0 *)0);
  }
  {
#line 49
  s = buf___3;
#line 50
  tmp___2 = malloc(sizeof(Font___0 ));
#line 50
  fnt = (Font___0 *)tmp___2;
  }
#line 51
  if ((unsigned long )fnt == (unsigned long )((Font___0 *)0)) {
#line 52
    goto Err1;
  }
  {
#line 53
  memset((void *)fnt, 0, sizeof(Font___0 ));
#line 54
  tmp___3 = strlen((char const   *)name);
#line 54
  tmp___4 = malloc(tmp___3 + 1UL);
#line 54
  fnt->name = (char *)tmp___4;
  }
#line 55
  if ((unsigned long )fnt->name == (unsigned long )((char *)0)) {
    Err2: 
    {
#line 58
    free((void *)fnt->name);
#line 59
    free((void *)fnt);
    }
#line 60
    goto Err1;
  }
  {
#line 62
  strcpy((char */* __restrict  */)fnt->name, (char const   */* __restrict  */)name);
#line 63
  tmp___5 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& s),
                   0);
#line 63
  fnt->height = (unsigned char )tmp___5;
#line 64
  s = skip(s);
#line 65
  tmp___6 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& s),
                   0);
#line 65
  fnt->ascent = (char )tmp___6;
#line 66
  s = skip(s);
  }
#line 67
  if ((int )fnt->height <= 0) {
#line 68
    goto Err2;
  } else
#line 67
  if ((int )fnt->ascent <= 0) {
#line 68
    goto Err2;
  }
#line 69
  fnt->width = (char)0;
#line 70
  fnt->ldepth = (char )ldepth;
#line 72
  fnt->id = (short)0;
#line 73
  fnt->nsubf = (unsigned short)0;
#line 74
  fnt->subf = (Cachesubf *)0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    tmp___7 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& s),
                     0);
#line 77
    min = (unsigned long )tmp___7;
#line 78
    s = skip(s);
#line 79
    tmp___8 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& s),
                     0);
#line 79
    max = (unsigned long )tmp___8;
#line 80
    s = skip(s);
    }
#line 81
    if ((int )*s == 0) {
#line 81
      goto Err3;
    } else
#line 81
    if (min >= 65536UL) {
#line 81
      goto Err3;
    } else
#line 81
    if (max >= 65536UL) {
#line 81
      goto Err3;
    } else
#line 81
    if (min > max) {
      Err3: 
      {
#line 84
      ffree(fnt);
      }
#line 85
      return ((Font___0 *)0);
    }
#line 87
    if (fnt->subf) {
      {
#line 88
      tmp___9 = realloc((void *)fnt->subf, (unsigned long )((int )fnt->nsubf + 1) * sizeof(Cachesubf ));
#line 88
      fnt->subf = (Cachesubf *)tmp___9;
      }
    } else {
      {
#line 90
      tmp___10 = malloc(sizeof(Cachesubf ));
#line 90
      fnt->subf = (Cachesubf *)tmp___10;
      }
    }
#line 91
    if ((unsigned long )fnt->subf == (unsigned long )((Cachesubf *)0)) {
#line 94
      fnt->nsubf = (unsigned short)0;
#line 95
      goto Err3;
    }
#line 97
    c = fnt->subf + fnt->nsubf;
#line 98
    c->min = (Rune )min;
#line 99
    c->max = (Rune )max;
#line 100
    t___0 = s;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (*s) {
#line 101
        if ((int )*s != 32) {
#line 101
          if ((int )*s != 10) {
#line 101
            if (! ((int )*s != 9)) {
#line 101
              goto while_break___0;
            }
          } else {
#line 101
            goto while_break___0;
          }
        } else {
#line 101
          goto while_break___0;
        }
      } else {
#line 101
        goto while_break___0;
      }
#line 102
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 103
    tmp___11 = s;
#line 103
    s ++;
#line 103
    *tmp___11 = (char)0;
#line 104
    c->f = (Subfont *)0;
#line 105
    tmp___12 = strlen((char const   *)t___0);
#line 105
    tmp___13 = malloc(tmp___12 + 1UL);
#line 105
    c->name = (char *)tmp___13;
    }
#line 106
    if ((unsigned long )c->name == (unsigned long )((char *)0)) {
      {
#line 108
      free((void *)c);
      }
#line 109
      goto Err3;
    }
    {
#line 111
    strcpy((char */* __restrict  */)c->name, (char const   */* __restrict  */)t___0);
#line 112
    s = skip(s);
#line 113
    fnt->nsubf = (unsigned short )((int )fnt->nsubf + 1);
    }
#line 76
    if (! *s) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  free((void *)buf___3);
  }
#line 116
  return (fnt);
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdfontfile.c"
void ffree(Font___0 *f ) 
{ 
  int i ;
  Cachesubf *c ;

  {
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < (int )f->nsubf)) {
#line 126
      goto while_break;
    }
#line 127
    c = f->subf + i;
#line 128
    if (c->f) {
      {
#line 129
      subffree(c->f);
      }
    }
    {
#line 130
    free((void *)c->name);
#line 131
    free((void *)c);
#line 126
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  free((void *)f->subf);
#line 134
  free((void *)f);
  }
#line 135
  return;
}
}
#line 1570 "/usr/include/X11/Xlib.h"
extern Cursor XCreatePixmapCursor(Display * , Pixmap  , Pixmap  , XColor * , XColor * ,
                                  unsigned int  , unsigned int  ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
XColor _fgcolor ;
#line 52
XColor _bgcolor ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorswitch.c"
static Cursor___0 arrow  =    {{-1, -1}, {(unsigned char)255, (unsigned char)224, (unsigned char)255, (unsigned char)224,
               (unsigned char)255, (unsigned char)192, (unsigned char)255, (unsigned char)0,
               (unsigned char)255, (unsigned char)0, (unsigned char)255, (unsigned char)128,
               (unsigned char)255, (unsigned char)192, (unsigned char)255, (unsigned char)224,
               (unsigned char)231, (unsigned char)240, (unsigned char)227, (unsigned char)248,
               (unsigned char)193, (unsigned char)252, (unsigned char)0, (unsigned char)254,
               (unsigned char)0, (unsigned char)127, (unsigned char)0, (unsigned char)62,
               (unsigned char)0, (unsigned char)28, (unsigned char)0, (unsigned char)8},
    {(unsigned char)0, (unsigned char)0, (unsigned char)127, (unsigned char)192, (unsigned char)127,
     (unsigned char)0, (unsigned char)124, (unsigned char)0, (unsigned char)126, (unsigned char)0,
     (unsigned char)127, (unsigned char)0, (unsigned char)111, (unsigned char)128,
     (unsigned char)103, (unsigned char)192, (unsigned char)67, (unsigned char)224,
     (unsigned char)65, (unsigned char)240, (unsigned char)0, (unsigned char)248,
     (unsigned char)0, (unsigned char)124, (unsigned char)0, (unsigned char)62, (unsigned char)0,
     (unsigned char)28, (unsigned char)0, (unsigned char)8, (unsigned char)0, (unsigned char)0},
    0};
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorswitch.c"
static Bitmap *bsrc  ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorswitch.c"
static Bitmap *bmask  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorswitch.c"
static Rectangle crect  =    {{0, 0}, {16, 16}};
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/cursorswitch.c"
void cursorswitch(Cursor___0 *c ) 
{ 
  Point tmp ;
  Cursor tmp___0 ;

  {
#line 37
  if ((unsigned long )c == (unsigned long )((Cursor___0 *)0)) {
#line 38
    c = & arrow;
  }
#line 39
  if (c->id == 0) {
#line 40
    if ((unsigned long )bsrc == (unsigned long )((Bitmap *)0)) {
      {
#line 41
      bsrc = balloc(crect, 0);
#line 42
      bmask = balloc(crect, 0);
      }
    }
    {
#line 49
    wrbitmap(bsrc, 0, 16, c->set);
#line 58
    wrbitmap(bmask, 0, 16, c->clr);
#line 59
    tmp = Pt(0, 0);
#line 59
    bitblt(bmask, tmp, bsrc, crect, (Fcode )14);
#line 61
    tmp___0 = XCreatePixmapCursor(_dpy, (Pixmap )bsrc->id, (Pixmap )bmask->id, & _fgcolor,
                                  & _bgcolor, (unsigned int )(- c->offset.x), (unsigned int )(- c->offset.y));
#line 61
    c->id = (int )tmp___0;
    }
  }
  {
#line 64
  XDefineCursor(_dpy, (Window )screen.id, (Cursor )c->id);
  }
#line 65
  return;
}
}
#line 1609 "/usr/include/X11/Xlib.h"
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
int _ld2d[6] ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/balloc.c"
Bitmap *balloc(Rectangle r , int ldepth ) 
{ 
  Bitmap *b ;

  {
  {
#line 11
  b = _balloc(r, ldepth);
#line 12
  bitblt(b, r.min, b, r, (Fcode )0);
  }
#line 13
  return (b);
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/balloc.c"
Bitmap *_balloc(Rectangle r , int ldepth ) 
{ 
  int id___0 ;
  Bitmap *b ;
  int ld ;
  Rectangle rx ;
  void *tmp ;
  Pixmap tmp___0 ;

  {
  {
#line 24
  tmp = malloc(sizeof(Bitmap ));
#line 24
  b = (Bitmap *)tmp;
  }
#line 25
  if ((unsigned long )b == (unsigned long )((Bitmap *)0)) {
    {
#line 26
    berror((char *)"balloc malloc");
    }
  }
#line 27
  if (ldepth == 0) {
#line 28
    ld = 0;
  } else {
#line 30
    ld = screen.ldepth;
  }
#line 31
  rx = r;
#line 32
  if (rx.max.x - rx.min.x == 0) {
#line 33
    (rx.max.x) ++;
  }
#line 34
  if (rx.max.y - rx.min.y == 0) {
#line 35
    (rx.max.y) ++;
  }
  {
#line 36
  tmp___0 = XCreatePixmap(_dpy, (Drawable )screen.id, (unsigned int )(rx.max.x - rx.min.x),
                          (unsigned int )(rx.max.y - rx.min.y), (unsigned int )_ld2d[ld]);
#line 36
  id___0 = (int )tmp___0;
#line 38
  b->ldepth = ldepth;
#line 39
  b->r = r;
#line 40
  b->clipr = r;
#line 41
  b->id = id___0;
#line 42
  b->cache = (Bitmap *)0;
  }
#line 43
  if (ldepth == 0) {
#line 44
    b->flag = 3;
  } else {
#line 46
    b->flag = screen.flag & 2;
  }
#line 47
  if (r.min.x == 0) {
#line 47
    if (r.min.y == 0) {
#line 48
      b->flag |= 8;
    } else {
#line 50
      b->flag |= 32;
    }
  } else {
#line 50
    b->flag |= 32;
  }
#line 51
  return (b);
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/balloc.c"
void bfree(Bitmap *b ) 
{ 


  {
  {
#line 57
  XFreePixmap(_dpy, (Pixmap )b->id);
#line 58
  free((void *)b);
  }
#line 59
  return;
}
}
#line 232 "./../include/libg.h"
void bflush(void) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
Cursor___0 boxcursor ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
int data_backup(Data *d ) ;
#line 36
void pathcontract(char *dest , char *orig ) ;
#line 124
void tag_set(Text *t___0 , char *s ) ;
#line 139
int text_read(Text *t___0 , int fd , int len ) ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.h"
void data_listremove(Data *d ) ;
#line 71
void dirnames_free(char **names ) ;
#line 72
char **dirnames(DIR *dirp , char *path ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static int data_getstat(Data *d , char *label , char *path , Stat *buf___3 ) ;
#line 9
static void data_opennew(Data *d , char *label , char *path ) ;
#line 10
static int data_getdir(Data *d , char *label , char *path , Stat *buf___3 ) ;
#line 11
static int data_getfile(Data *d , char *label , char *path , Stat *buf___3 ) ;
#line 12
static void data_settag(Data *d , char *path ) ;
#line 13
static Data *data_alloc(void) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
View *data_open(char *label , Bool create ) 
{ 
  Data *d ;
  Stat buf___3 ;
  Path path ;
  Bool failure ;
  int tmp ;
  int tmp___0 ;
  View *tmp___1 ;

  {
  {
#line 30
  label2path(path, label);
#line 32
  d = data_alloc();
#line 33
  failure = (Bool )0;
#line 35
  tmp___0 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& buf___3));
  }
#line 35
  if (tmp___0) {
#line 36
    if (create) {
      {
#line 37
      data_opennew(d, label, path);
      }
    } else {
#line 39
      failure = (Bool )1;
    }
  } else {
    {
#line 41
    tmp = data_getstat(d, label, path, & buf___3);
#line 41
    failure = (Bool )tmp;
    }
  }
#line 44
  if (failure) {
    {
#line 45
    data_listremove(d);
#line 46
    free((void *)d);
    }
#line 47
    return ((View *)0);
  } else {
#line 49
    if (d->names) {
      {
#line 50
      add_slash(path);
      }
    }
    {
#line 51
    data_settag(d, path);
#line 52
    win_new(path, d->tag, d->t);
#line 53
    tmp___1 = text_view(d->t);
    }
#line 53
    return (tmp___1);
  }
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
int data_get(Data *d , char *label ) 
{ 
  Stat buf___3 ;
  Path path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 66
  tmp = data_backup(d);
  }
#line 66
  if (tmp) {
#line 67
    return (-1);
  }
#line 69
  if (! label) {
#line 70
    label = d->label;
  }
  {
#line 71
  label2path(path, label);
#line 72
  tmp___1 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& buf___3));
  }
#line 72
  if (tmp___1) {
    {
#line 73
    diag((char *)0, (char *)"Couldn\'t stat [%s (%s)]", path, label);
    }
#line 74
    return (-1);
  } else {
    {
#line 76
    tmp___0 = data_getstat(d, label, path, & buf___3);
    }
#line 76
    return (tmp___0);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static int data_getstat(Data *d , char *label , char *path , Stat *buf___3 ) 
{ 
  int failed ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 87
  cursorswitch(& boxcursor);
#line 88
  bflush();
#line 89
  undo_reset(d->t);
  }
#line 90
  if ((buf___3->st_mode & 61440U) == 16384U) {
    {
#line 90
    tmp = data_getdir(d, label, path, buf___3);
#line 90
    failed = tmp;
    }
  } else {
    {
#line 90
    tmp___0 = data_getfile(d, label, path, buf___3);
#line 90
    failed = tmp___0;
    }
  }
  {
#line 94
  undo_start(d->t);
  }
#line 95
  if (! failed) {
    {
#line 96
    undo_mark(d->t);
    }
  }
  {
#line 98
  cursorswitch(cursor);
  }
#line 99
  return (failed);
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static void data_opennew(Data *d , char *label , char *path ) 
{ 
  Rstring tmp ;
  Range tmp___0 ;

  {
  {
#line 106
  pathcontract(d->label, label);
#line 107
  strcpy((char */* __restrict  */)(d->cachedlabel), (char const   */* __restrict  */)(d->label));
#line 108
  d->has_stat = (Bool )0;
#line 109
  data_setbackup(d, path);
#line 110
  dirnames_free(d->names);
#line 111
  d->names = (char **)0;
#line 114
  tmp = rstring((Rune *)0, (Rune *)0);
#line 114
  tmp___0 = text_all(d->t);
#line 114
  text_replace(d->t, tmp___0, tmp);
#line 115
  undo_start(d->t);
#line 116
  undo_mark(d->t);
#line 119
  tag_setlabel(d->tag, d->label);
#line 120
  tag_rmtool(d->tag, (char *)"Put");
  }
#line 121
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static int data_getdir(Data *d , char *label , char *path , Stat *buf___3 ) 
{ 
  DIR *dirp ;

  {
  {
#line 130
  dirp = opendir((char const   *)path);
  }
#line 130
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
#line 131
    diag((char *)0, (char *)"opendir [%s]", path);
    }
#line 132
    return (-1);
  }
  {
#line 136
  pathcontract(d->label, label);
#line 137
  add_slash(d->label);
#line 138
  strcpy((char */* __restrict  */)(d->cachedlabel), (char const   */* __restrict  */)(d->label));
#line 140
  d->has_stat = (Bool )1;
#line 141
  d->stat = *buf___3;
#line 142
  data_setbackup(d, (char *)0);
#line 143
  dirnames_free(d->names);
#line 144
  d->names = dirnames(dirp, path);
#line 147
  text_formatdir(d->t, d->names);
#line 150
  tag_rmtool(d->tag, (char *)"Put");
#line 151
  tag_addtool(d->tag, (char *)"Get");
#line 152
  tag_setlabel(d->tag, d->label);
  }
#line 153
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static int data_getfile(Data *d , char *label , char *path , Stat *buf___3 ) 
{ 
  int fd ;

  {
  {
#line 163
  fd = open((char const   *)path, 0);
  }
#line 163
  if (fd == -1) {
    {
#line 164
    diag(path, (char *)"open [%s]", path);
    }
#line 165
    return (-1);
  }
  {
#line 169
  pathcontract(d->label, label);
#line 170
  strcpy((char */* __restrict  */)(d->cachedlabel), (char const   */* __restrict  */)(d->label));
#line 172
  d->has_stat = (Bool )1;
#line 173
  d->stat = *buf___3;
#line 174
  data_setbackup(d, path);
#line 175
  dirnames_free(d->names);
#line 176
  d->names = (char **)0;
#line 179
  text_read(d->t, fd, (int )buf___3->st_size);
#line 180
  close(fd);
  }
#line 181
  if (utfHadNulls) {
    {
#line 182
    diag(path, (char *)"removed nulls from [%s]", path);
#line 183
    data_setbackup(d, (char *)0);
    }
  }
  {
#line 187
  tag_rmtool(d->tag, (char *)"Put");
#line 188
  tag_rmtool(d->tag, (char *)"Get");
#line 189
  tag_setlabel(d->tag, d->label);
  }
#line 190
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static void data_settag(Data *d , char *path ) 
{ 
  Path buf___3 ;
  char *common ;
  char *specific ;
  char const   *tmp ;

  {
#line 200
  if (d->names) {
#line 200
    common = dirtools;
  } else {
#line 200
    common = filetools;
  }
  {
#line 201
  specific = tag_match(path);
  }
#line 203
  if (d->names) {
#line 203
    tmp = "Get";
  } else {
#line 203
    tmp = "";
  }
  {
#line 203
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%s %s | %s %s ",
          d->label, tmp, filetools, specific);
#line 206
  tag_set(d->tag, buf___3);
  }
#line 207
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static Id id  ;
#line 209 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/file.c"
static Data *data_alloc(void) 
{ 
  Data *d ;
  void *tmp ;
  Id tmp___0 ;

  {
  {
#line 214
  tmp = salloc((int )sizeof(Data ));
#line 214
  d = (Data *)tmp;
#line 215
  tmp___0 = id;
#line 215
  id ++;
#line 215
  d->id = tmp___0;
#line 216
  d->next = dataroot;
#line 217
  dataroot = d;
#line 218
  d->t = text_alloc(d, (Bool )1);
#line 219
  d->tag = text_alloc(d, (Bool )0);
#line 220
  d->names = (char **)0;
#line 221
  d->backupto = (char *)0;
#line 222
  d->fd = 0;
#line 223
  d->emask = (ushort )0;
#line 224
  d->has_stat = (Bool )0;
#line 226
  strcpy((char */* __restrict  */)(d->label), (char const   */* __restrict  */)"");
#line 227
  strcpy((char */* __restrict  */)(d->cachedlabel), (char const   */* __restrict  */)"");
  }
#line 229
  return (d);
}
}
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
static int stripwhitespace(Tile *t___0 , int excess ) 
{ 
  int saving ;
  int size ;
  int tmp ;
  int tmp___0 ;

  {
#line 14
  if (! t___0->body) {
#line 15
    return (0);
  }
  {
#line 17
  size = t___0->max - t___0->min;
#line 22
  tmp = view_height(t___0->body);
#line 22
  tmp___0 = view_height(t___0->tag);
  }
#line 22
  if (size < tmp + tmp___0) {
#line 23
    return (0);
  }
  {
#line 25
  saving = view_stripwhitespace(t___0->body);
  }
#line 25
  if (saving) {
#line 27
    if (saving < excess) {
#line 27
      saving = saving;
    } else {
#line 27
      saving = excess;
    }
#line 28
    t___0->max -= saving;
  }
#line 31
  return (saving);
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
static int halve(Tile *t___0 , int excess ) 
{ 
  int saving ;
  int size ;
  int extra ;

  {
#line 37
  size = t___0->max - t___0->min;
#line 38
  extra = size - t___0->base;
#line 40
  if (extra > 0) {
#line 41
    if (extra / 2 < excess) {
#line 41
      saving = extra / 2;
    } else {
#line 41
      saving = excess;
    }
#line 42
    t___0->max -= saving;
#line 43
    return (size - (t___0->max - t___0->min));
  }
#line 45
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
static int shrink(Tile *t___0 , int excess ) 
{ 
  int saving ;
  int tmp ;

  {
#line 51
  if ((t___0->max - t___0->min) - t___0->base < excess) {
#line 51
    tmp = (t___0->max - t___0->min) - t___0->base;
  } else {
#line 51
    tmp = excess;
  }
#line 51
  saving = tmp;
#line 52
  t___0->max -= saving;
#line 53
  return (saving);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
static int hide(Tile *t___0 , int excess ) 
{ 


  {
#line 60
  t___0->ishidden = (Bool )1;
#line 61
  return (t___0->base);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
SizeAdjust method[5]  = {      & stripwhitespace,      & halve,      & shrink,      & hide, 
        (SizeAdjust )0};
#line 77 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/adjust.c"
int adjust_sizes_in_range(Tile *start , Tile *end , int available ) 
{ 
  Tile *t___0 ;
  int size ;
  int saving ;
  int excess ;
  int now ;
  int j ;
  int (*m)(Tile * , int  ) ;

  {
  {
#line 88
  size = list_size(start, end);
#line 90
  j = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    m = method[j];
#line 90
    if (! m) {
#line 90
      goto while_break;
    }
#line 91
    t___0 = start;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 91
        goto while_break___0;
      }
#line 91
      if (! t___0->ishidden) {
#line 93
        if (size - available > 0) {
#line 93
          excess = size - available;
        } else {
#line 93
          excess = 0;
        }
        {
#line 94
        saving = (*m)(t___0, excess);
#line 96
        size -= saving;
        }
#line 101
        if (size <= available) {
#line 103
          goto out;
        }
      }
#line 91
      t___0 = t___0->right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  out: ;
#line 114
  if (size < available) {
    {
#line 114
    t___0 = last_visible(start, end);
    }
#line 114
    if (t___0) {
      {
#line 115
      t___0->max += available - size;
#line 116
      size = available;
#line 117
      now = list_size(start, end);
      }
    }
  }
#line 123
  return (size);
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
ulong text_startofword(Text *t___0 , ulong p0 ) ;
#line 266
void b3(View *v , Range r ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void view_cursor(View *v , Rune r ) ;
#line 9
static void addrune(View *v , Rune r ) ;
#line 10
static void tag_cr(View *v ) ;
#line 11
static void backspace(View *v ) ;
#line 12
static void deleteline(View *v ) ;
#line 13
static void deleteword(View *v ) ;
#line 14
static void esc(View *v ) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
void dokeyboard(View *v , Rune r ) 
{ 


  {
  {
#line 24
  if ((int )r == 131) {
#line 24
    goto case_131;
  }
#line 24
  if ((int )r == 130) {
#line 24
    goto case_131;
  }
#line 24
  if ((int )r == 135) {
#line 24
    goto case_131;
  }
#line 24
  if ((int )r == 134) {
#line 24
    goto case_131;
  }
#line 24
  if ((int )r == 133) {
#line 24
    goto case_131;
  }
#line 24
  if ((int )r == 132) {
#line 24
    goto case_131;
  }
#line 27
  if ((int )r == 129) {
#line 27
    goto case_129;
  }
#line 27
  if ((int )r == 128) {
#line 27
    goto case_129;
  }
#line 30
  if ((int )r == 127) {
#line 30
    goto case_127;
  }
#line 30
  if ((int )r == 8) {
#line 30
    goto case_127;
  }
#line 31
  if ((int )r == 21) {
#line 31
    goto case_21;
  }
#line 32
  if ((int )r == 23) {
#line 32
    goto case_23;
  }
#line 33
  if ((int )r == 27) {
#line 33
    goto case_27;
  }
#line 35
  if ((int )r == 10) {
#line 35
    goto case_10;
  }
#line 36
  goto switch_default;
  case_131: /* CIL Label */ 
  case_130: /* CIL Label */ 
  case_135: /* CIL Label */ 
  case_134: /* CIL Label */ 
  case_133: /* CIL Label */ 
  case_132: /* CIL Label */ 
  {
#line 24
  view_cursor(v, r);
  }
#line 24
  goto switch_break;
  case_129: /* CIL Label */ 
  case_128: /* CIL Label */ 
  {
#line 27
  view_pagedown(v, (Bool )((int )r == 128));
  }
#line 27
  goto switch_break;
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 30
  backspace(v);
  }
#line 30
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 31
  deleteline(v);
  }
#line 31
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 32
  deleteword(v);
  }
#line 32
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 33
  esc(v);
  }
#line 33
  goto switch_break;
  case_10: /* CIL Label */ 
#line 35
  if (! v->scroll) {
    {
#line 35
    tag_cr(v);
    }
#line 35
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 36
  addrune(v, r);
  }
  switch_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void tag_cr(View *v ) 
{ 
  char *cmd ;
  Range tmp ;
  Data *tmp___0 ;
  Bool tmp___1 ;

  {
#line 54
  if (! (v->sel.p1 - v->sel.p0)) {
    {
#line 56
    tmp = range(v->anchor, v->sel.p0);
#line 56
    view_select(v, tmp);
    }
  }
  {
#line 58
  cmd = text_duputf(v->t, v->sel);
  }
#line 59
  if ((int )*(cmd + 0) == 58) {
    {
#line 60
    b3(v, v->sel);
    }
  } else {
    {
#line 62
    tmp___0 = view_data(v);
#line 62
    tmp___1 = data_sendexec(tmp___0, cmd, (char *)0);
    }
#line 62
    if (! tmp___1) {
      {
#line 63
      run(v, cmd, (char *)0);
      }
    }
  }
  {
#line 65
  free((void *)cmd);
  }
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void backspace(View *v ) 
{ 
  Range del___0 ;

  {
#line 71
  del___0 = v->sel;
#line 73
  if (del___0.p0) {
#line 74
    (del___0.p0) --;
  }
  {
#line 75
  view_cut(v, del___0);
  }
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void deleteline(View *v ) 
{ 
  Range del___0 ;

  {
  {
#line 81
  del___0 = v->sel;
#line 83
  del___0.p0 = text_startOfLine(v->t, del___0.p0);
#line 84
  view_cut(v, del___0);
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void deleteword(View *v ) 
{ 
  Range del___0 ;

  {
  {
#line 90
  del___0 = v->sel;
#line 92
  del___0.p0 = text_startofword(v->t, del___0.p0);
#line 93
  view_cut(v, del___0);
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void esc(View *v ) 
{ 
  Range del___0 ;
  Range tmp ;

  {
#line 98
  del___0 = v->sel;
#line 100
  if (del___0.p1 - del___0.p0) {
    {
#line 102
    view_cut(v, del___0);
    }
  } else {
    {
#line 105
    tmp = range(v->anchor, v->sel.p0);
#line 105
    view_select(v, tmp);
#line 106
    view_setlastselection(v);
    }
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void addrune(View *v , Rune r ) 
{ 
  Rstring s ;

  {
#line 114
  if ((int )r == 10) {
#line 114
    if (v->autoindent) {
      {
#line 115
      s = text_autoindent(v->t, v->sel.p0);
      }
    } else {
#line 117
      s.r0 = & r;
#line 118
      s.r1 = & r + 1;
    }
  } else {
#line 117
    s.r0 = & r;
#line 118
    s.r1 = & r + 1;
  }
#line 120
  if (v->sel.p1 - v->sel.p0) {
    {
#line 121
    snarf(v->t, v->sel);
    }
  }
  {
#line 123
  text_replace(v->t, v->sel, s);
#line 124
  view_show(v, v->sel);
  }
#line 125
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/keyboard.c"
static void view_cursor(View *v , Rune r ) 
{ 
  ulong p ;
  Point pt ;
  ulong tmp ;
  ulong tmp___0 ;
  Range tmp___1 ;

  {
#line 138
  p = v->sel.p0;
  {
#line 140
  if ((int )r == 130) {
#line 140
    goto case_130;
  }
#line 144
  if ((int )r == 131) {
#line 144
    goto case_131;
  }
#line 149
  if ((int )r == 133) {
#line 149
    goto case_133;
  }
#line 149
  if ((int )r == 132) {
#line 149
    goto case_133;
  }
#line 157
  if ((int )r == 134) {
#line 157
    goto case_134;
  }
#line 160
  if ((int )r == 135) {
#line 160
    goto case_135;
  }
#line 139
  goto switch_break;
  case_130: /* CIL Label */ 
#line 141
  if (p) {
#line 142
    p --;
  }
#line 143
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 145
  tmp = text_length(v->t);
  }
#line 145
  if (p < tmp) {
#line 146
    p ++;
  }
#line 147
  goto switch_break;
  case_133: /* CIL Label */ 
  case_132: /* CIL Label */ 
  {
#line 150
  pt = frptofchar(& v->f, p - v->visible.p0);
  }
#line 151
  if ((int )r == 132) {
#line 152
    pt.y += (int )(v->f.font)->height;
  } else {
#line 154
    pt.y -= (int )(v->f.font)->height;
  }
  {
#line 155
  tmp___0 = frcharofpt(& v->f, pt);
#line 155
  p = tmp___0 + v->visible.p0;
  }
#line 156
  goto switch_break;
  case_134: /* CIL Label */ 
#line 158
  p = (ulong )0;
#line 159
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 161
  p = text_length(v->t);
  }
#line 162
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 164
  tmp___1 = range(p, p);
#line 164
  view_select(v, tmp___1);
#line 165
  view_show(v, v->sel);
  }
#line 166
  return;
}
}
#line 214 "./../include/libg.h"
void ellipse(Bitmap *bp , Point p , int a , int b , int v , Fcode f ) ;
#line 2314 "/usr/include/X11/Xlib.h"
extern int XDrawArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/ellipse.c"
void ellipse(Bitmap *bp , Point p , int a , int b , int v , Fcode f ) 
{ 
  int x ;
  int y ;
  GC g ;

  {
#line 14
  x = p.x - a;
#line 15
  y = p.y - b;
#line 16
  if (bp->flag & 32) {
#line 17
    x -= bp->r.min.x;
#line 18
    y -= bp->r.min.y;
  }
  {
#line 20
  g = _getfillgc(f, bp, (unsigned long )v);
#line 21
  XDrawArc(_dpy, (Drawable )bp->id, g, x, y, (unsigned int )(2 * a), (unsigned int )(2 * b),
           0, 23040);
  }
#line 22
  return;
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 66 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.h"
Data *dataroot  ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
Text *data_body(Data *d ) 
{ 


  {
#line 13
  return (d->t);
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
Text *data_tag(Data *d ) 
{ 


  {
#line 18
  return (d->tag);
}
}
#line 22 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
char **data_names(Data *d ) 
{ 
  char **tmp ;

  {
#line 24
  if (d) {
#line 24
    tmp = d->names;
  } else {
#line 24
    tmp = (char **)0;
  }
#line 24
  return (tmp);
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
Bool data_isdirty(Data *d ) 
{ 
  Bool tmp ;
  int tmp___0 ;

  {
#line 30
  if (d) {
#line 30
    if (d->backupto) {
      {
#line 30
      tmp = undo_atmark(d->t);
      }
#line 30
      if (tmp) {
#line 30
        tmp___0 = 0;
      } else {
#line 30
        tmp___0 = 1;
      }
    } else {
#line 30
      tmp___0 = 0;
    }
  } else {
#line 30
    tmp___0 = 0;
  }
#line 30
  return ((Bool )tmp___0);
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
int data_putall(void) 
{ 
  Data *d ;
  int retval ;
  int tmp ;
  Bool tmp___0 ;

  {
#line 37
  retval = 0;
#line 39
  d = dataroot;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! d) {
#line 39
      goto while_break;
    }
#line 40
    if (d->backupto) {
      {
#line 40
      tmp___0 = undo_atmark(d->t);
      }
#line 40
      if (! tmp___0) {
        {
#line 41
        tmp = data_put(d, (char *)0);
        }
#line 41
        if (tmp) {
#line 42
          retval = -1;
        }
      }
    }
#line 39
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (retval);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
int data_backupall(void) 
{ 
  Data *d ;
  int retval ;
  int tmp ;

  {
#line 50
  retval = 0;
#line 52
  d = dataroot;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! d) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp = data_backup(d);
    }
#line 53
    if (tmp) {
#line 54
      retval = 1;
    }
#line 52
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (retval);
}
}
#line 64 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
int data_put(Data *d , char *label ) 
{ 
  int fd ;
  Stat buf___3 ;
  Path path ;
  Bool statfailed ;
  Bool writefailed ;
  int tmp ;
  Range tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 71
  if (! label) {
#line 72
    label = d->label;
  }
  {
#line 73
  label2path(path, label);
#line 75
  tmp = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& buf___3));
#line 75
  statfailed = (Bool )tmp;
#line 77
  fd = open((char const   *)(path), 578, 438);
  }
#line 77
  if (fd < 0) {
    {
#line 78
    diag(path, (char *)"couldn\'t open \"%s\" for write", path);
    }
#line 79
    return (-1);
  }
  {
#line 81
  tmp___0 = text_all(d->t);
#line 81
  tmp___1 = text_write_range(d->t, tmp___0, fd);
#line 81
  writefailed = (Bool )tmp___1;
#line 82
  close(fd);
  }
#line 83
  if (writefailed) {
    {
#line 84
    diag(path, (char *)"write failed: \"%s\"", path);
    }
#line 85
    return (-1);
  }
  {
#line 88
  tmp___2 = strcmp((char const   *)(d->label), (char const   *)label);
  }
#line 88
  if (tmp___2) {
    {
#line 88
    tmp___3 = statcmp(& buf___3, & d->stat);
    }
#line 88
    if (! tmp___3) {
      _L: /* CIL Label */ 
#line 89
      if (! d->names) {
        {
#line 90
        tag_rmtool(d->tag, (char *)"Put");
#line 91
        undo_mark(d->t);
        }
      }
#line 93
      return (0);
    }
  } else {
#line 88
    goto _L;
  }
#line 95
  return (-1);
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
void data_listremove(Data *d ) 
{ 
  Data **ptr ;

  {
#line 102
  ptr = & dataroot;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )*ptr != (unsigned long )d)) {
#line 102
      goto while_break;
    }
#line 102
    ptr = & (*ptr)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  *ptr = d->next;
#line 105
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
int data_del(Data *d ) 
{ 
  int tmp ;

  {
  {
#line 112
  tmp = data_backup(d);
  }
#line 112
  if (tmp) {
#line 113
    return (1);
  }
  {
#line 115
  data_senddestroy(d);
#line 116
  data_listremove(d);
#line 117
  dirnames_free(d->names);
  }
#line 118
  if (d->backupto) {
    {
#line 119
    free((void *)d->backupto);
    }
  }
  {
#line 120
  free((void *)d);
  }
#line 121
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
int data_backup(Data *d ) 
{ 
  Path fname ;
  Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 129
  if (d->backupto) {
    {
#line 129
    tmp = undo_atmark(d->t);
    }
#line 129
    if (tmp) {
#line 130
      return (0);
    }
  } else {
#line 130
    return (0);
  }
  {
#line 132
  tmp___0 = backup_name(d->backupto, fname);
  }
#line 132
  if (tmp___0) {
#line 133
    return (-1);
  }
  {
#line 134
  tmp___1 = text_write(d->t, fname);
  }
#line 134
  if (tmp___1) {
#line 135
    return (-1);
  }
  {
#line 137
  tmp___2 = __errno_location();
#line 137
  *tmp___2 = 0;
#line 138
  tmp___3 = mybasename(fname);
#line 138
  diag(fname, (char *)"backup %s %s", tmp___3, d->backupto);
  }
#line 139
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
void data_setbackup(Data *d , char *bfile ) 
{ 
  char *tmp ;

  {
#line 147
  if (d->backupto) {
    {
#line 148
    free((void *)d->backupto);
    }
  }
#line 149
  if (bfile) {
    {
#line 149
    tmp = strstr((char const   *)bfile, "+Errors");
    }
#line 149
    if (tmp) {
      {
#line 153
      d->backupto = (char *)0;
#line 154
      text_setneedsbackup(d->t, (Bool )0);
      }
    } else {
      {
#line 150
      d->backupto = strdup((char const   *)bfile);
#line 151
      text_setneedsbackup(d->t, (Bool )1);
      }
    }
  } else {
    {
#line 153
    d->backupto = (char *)0;
#line 154
    text_setneedsbackup(d->t, (Bool )0);
    }
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/data.c"
Data *data_findid(Id id___0 ) 
{ 
  Data *d ;

  {
#line 162
  d = dataroot;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! d) {
#line 162
      goto while_break;
    }
#line 163
    if (d->id == id___0) {
#line 164
      goto while_break;
    }
#line 162
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 350 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 67 "./../include/msg.h"
int client_connect(void) ;
#line 69
int wilyfifotalk(void) ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
static int findname(char *buf___3 ) ;
#line 20
static void addenv(char *key , char *val ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
static char *myfifo  =    (char *)0;
#line 27 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
int wilyfifolisten(void) 
{ 
  int fd ;
  char name[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 30
  fd = -1;
#line 33
  tmp = findname(name);
  }
#line 33
  if (tmp) {
#line 34
    return (-1);
  }
  {
#line 36
  tmp___0 = mkfifo((char const   *)(name), (__mode_t )384);
  }
#line 36
  if (tmp___0) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"try\n\trm %s\n",
            name);
#line 38
    perror((char const   *)(name));
    }
#line 39
    return (-1);
  }
  {
#line 42
  fd = open((char const   *)(name), 2048);
  }
#line 44
  if (fd < 0) {
    {
#line 45
    perror((char const   *)(name));
    }
#line 46
    return (-1);
  }
  {
#line 49
  tmp___1 = open((char const   *)(name), 1);
  }
#line 49
  if (tmp___1 < 0) {
    {
#line 50
    perror((char const   *)(name));
    }
#line 51
    return (-1);
  }
  {
#line 54
  addenv((char *)"WILYFIFO", name);
#line 55
  myfifo = strdup((char const   *)(name));
  }
#line 57
  return (fd);
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
void fifo_cleanup(void) 
{ 
  int tmp ;

  {
#line 65
  if (myfifo) {
    {
#line 66
    tmp = unlink((char const   *)myfifo);
    }
#line 66
    if (tmp) {
      {
#line 67
      perror((char const   *)myfifo);
      }
    }
  }
#line 68
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
int wilyfifotalk(void) 
{ 
  char name[4096] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 77
  tmp = findname(name);
  }
#line 77
  if (tmp) {
#line 78
    return (-1);
  }
  {
#line 79
  tmp___0 = open((char const   *)(name), 1);
  }
#line 79
  return (tmp___0);
}
}
#line 94 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
int client_connect(void) 
{ 
  int s ;
  int fd ;
  int size ;
  struct sockaddr_un addr ;
  int len ;
  int nwritten ;
  char *path ;
  size_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 104
  s = socket(1, 1, 0);
  }
#line 104
  if (! s) {
#line 105
    return (-1);
  }
  {
#line 108
  addr.sun_family = (sa_family_t )1;
#line 109
  tmpnam(addr.sun_path);
#line 110
  path = strdup((char const   *)(addr.sun_path));
#line 111
  tmp = strlen((char const   *)(addr.sun_path));
#line 111
  len = (int )tmp;
#line 113
  tmp___0 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 113
  if (tmp___0 < 0) {
    {
#line 114
    perror("bind");
    }
#line 115
    return (-1);
  }
  {
#line 118
  listen(s, 1);
#line 120
  fd = wilyfifotalk();
  }
#line 121
  if (fd < 0) {
#line 122
    return (-1);
  }
  {
#line 123
  tmp___1 = write(fd, (void const   *)(addr.sun_path), (size_t )len);
#line 123
  nwritten = (int )tmp___1;
#line 124
  close(fd);
  }
#line 125
  if (nwritten != len) {
    {
#line 126
    perror("write to wily");
    }
#line 127
    return (-1);
  }
  {
#line 130
  size = (int )sizeof(addr);
#line 131
  fd = accept(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
              (socklen_t */* __restrict  */)(& size));
#line 132
  close(s);
#line 133
  tmp___2 = unlink((char const   *)path);
  }
#line 133
  if (tmp___2) {
    {
#line 134
    perror((char const   *)path);
    }
  }
  {
#line 135
  free((void *)path);
  }
#line 136
  return (fd);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
int wily_connect(char *addrname , int n ) 
{ 
  int s ;
  struct sockaddr_un addr ;
  int tmp ;

  {
  {
#line 149
  s = socket(1, 1, 0);
  }
#line 150
  if (s < 0) {
#line 151
    return (-1);
  }
  {
#line 153
  addr.sun_family = (sa_family_t )1;
#line 154
  memcpy((void */* __restrict  */)(addr.sun_path), (void const   */* __restrict  */)addrname,
         (size_t )n);
#line 155
  addr.sun_path[n] = (char )'\000';
#line 157
  tmp = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 157
  if (tmp) {
#line 158
    return (-1);
  }
#line 159
  return (s);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
static int findname(char *buf___3 ) 
{ 
  char *name ;
  struct passwd *pw ;
  char *disp ;
  char *dir ;
  __uid_t tmp ;

  {
  {
#line 170
  name = (char *)0;
#line 175
  name = getenv("WILYFIFO");
  }
#line 175
  if (name) {
    {
#line 176
    strcpy((char */* __restrict  */)buf___3, (char const   */* __restrict  */)name);
    }
#line 177
    return (0);
  }
  {
#line 180
  tmp = getuid();
#line 180
  pw = getpwuid(tmp);
  }
#line 180
  if (! pw) {
    {
#line 181
    perror("getpwuid or getuid");
    }
#line 182
    return (-1);
  }
  {
#line 184
  disp = getenv("DISPLAY");
  }
#line 184
  if (! disp) {
    {
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"$DISPLAY not set");
    }
#line 186
    return (-1);
  }
  {
#line 188
  dir = getenv("TMPDIR");
  }
#line 188
  if (! dir) {
#line 189
    dir = (char *)"/tmp";
  }
  {
#line 191
  sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%s/wily%s%s",
          dir, pw->pw_name, disp);
  }
#line 192
  return (0);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/connect.c"
static void addenv(char *key , char *val ) 
{ 
  char *buf___3 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 200
  tmp = strlen((char const   *)key);
#line 200
  tmp___0 = strlen((char const   *)val);
#line 200
  tmp___1 = salloc((int )((tmp + tmp___0) + 2UL));
#line 200
  buf___3 = (char *)tmp___1;
#line 201
  sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%s=%s",
          key, val);
#line 202
  putenv(buf___3);
  }
#line 203
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/point.c"
void setcminmax(Tile *list___0 , int *cmin , int *cmax ) 
{ 


  {
#line 11
  if (list___0) {
#line 12
    if ((unsigned int )list___0->ori == 1U) {
#line 12
      *cmin = (list___0->tag)->r.max.y + tagheight;
    } else {
#line 12
      *cmin = list___0->min;
    }
#line 13
    *cmax = list___0->max;
  } else {
#line 15
    *cmin = 0;
#line 16
    *cmax = screen.r.max.x;
  }
#line 18
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/point.c"
Rectangle rectangle(Tile *t___0 ) 
{ 
  Rectangle tmp ;
  Rectangle tmp___0 ;
  Rectangle tmp___1 ;

  {
#line 23
  if ((unsigned int )t___0->ori == 0U) {
    {
#line 24
    tmp = Rect(t___0->min, ((t___0->up)->tag)->r.max.y, t___0->max, (t___0->up)->max);
    }
#line 24
    return (tmp);
  } else
#line 26
  if (t___0->up) {
    {
#line 27
    tmp___0 = Rect((t___0->up)->min, t___0->min, (t___0->up)->max, t___0->max);
    }
#line 27
    return (tmp___0);
  } else {
    {
#line 29
    tmp___1 = Rect(0, t___0->min, t___0->cmax, t___0->max);
    }
#line 29
    return (tmp___1);
  }
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/point.c"
Point buttonpos(Tile *tile ) 
{ 
  Point tmp ;
  Point tmp___0 ;

  {
  {
#line 36
  tmp = Pt(6, 6);
#line 36
  tmp___0 = add((tile->tag)->r.min, tmp);
  }
#line 36
  return (tmp___0);
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/point.c"
Tile *point2tile(Tile *tile , Point p ) 
{ 
  int pos ;
  Tile *t___0 ;
  int tmp ;
  Bool tmp___0 ;
  Tile *tmp___1 ;
  Bool tmp___2 ;

  {
#line 46
  if (tile->body) {
#line 47
    return (tile);
  } else {
    {
#line 46
    tmp = ptinrect(p, (tile->tag)->r);
    }
#line 46
    if (tmp) {
#line 47
      return (tile);
    }
  }
#line 48
  if ((unsigned int )tile->ori == 1U) {
#line 48
    pos = p.x;
  } else {
#line 48
    pos = p.y;
  }
#line 49
  t___0 = tile->down;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! t___0) {
#line 49
      goto while_break;
    }
    {
#line 50
    tmp___0 = tile_hidden(t___0);
    }
#line 50
    if (! tmp___0) {
#line 50
      if (pos < t___0->max) {
#line 50
        if (pos >= t___0->min) {
#line 51
          goto while_break;
        }
      }
    }
#line 49
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  if (t___0) {
    {
#line 53
    tmp___2 = tile_hidden(t___0);
    }
#line 53
    if (! tmp___2) {
#line 53
      if (pos > t___0->min) {
        {
#line 54
        tmp___1 = point2tile(t___0, p);
        }
#line 54
        return (tmp___1);
      }
    }
  }
#line 55
  return (tile);
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/point.c"
View *point2view(Point p ) 
{ 
  Tile *t___0 ;
  View *v ;
  int tmp ;

  {
  {
#line 64
  t___0 = point2tile(wily, p);
#line 65
  tmp = ptinrect(p, (t___0->tag)->r);
  }
#line 65
  if (tmp) {
#line 66
    v = t___0->tag;
  } else {
#line 68
    v = t___0->body;
  }
#line 70
  return (v);
}
}
#line 195 "./../include/libg.h"
int rectclip(Rectangle *rp , Rectangle b ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rectclip.c"
int rectclip(Rectangle *rp , Rectangle b ) 
{ 
  Rectangle *bp ;
  int tmp ;

  {
#line 7
  bp = & b;
#line 11
  if (rp->min.x < bp->max.x) {
#line 11
    if (bp->min.x < rp->max.x) {
#line 11
      if (rp->min.y < bp->max.y) {
#line 11
        if (bp->min.y < rp->max.y) {
#line 11
          tmp = 1;
        } else {
#line 11
          tmp = 0;
        }
      } else {
#line 11
        tmp = 0;
      }
    } else {
#line 11
      tmp = 0;
    }
  } else {
#line 11
    tmp = 0;
  }
#line 11
  if (tmp == 0) {
#line 13
    return (0);
  }
#line 15
  if (rp->min.x < bp->min.x) {
#line 16
    rp->min.x = bp->min.x;
  }
#line 17
  if (rp->min.y < bp->min.y) {
#line 18
    rp->min.y = bp->min.y;
  }
#line 19
  if (rp->max.x > bp->max.x) {
#line 20
    rp->max.x = bp->max.x;
  }
#line 21
  if (rp->max.y > bp->max.y) {
#line 22
    rp->max.y = bp->max.y;
  }
#line 23
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/cursor.c"
Cursor___0 boxcursor  =    {{-7, -7}, {(unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)248, (unsigned char)31,
               (unsigned char)248, (unsigned char)31, (unsigned char)248, (unsigned char)31,
               (unsigned char)248, (unsigned char)31, (unsigned char)248, (unsigned char)31,
               (unsigned char)248, (unsigned char)31, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255,
               (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255},
    {(unsigned char)0, (unsigned char)0, (unsigned char)127, (unsigned char)254, (unsigned char)127,
     (unsigned char)254, (unsigned char)127, (unsigned char)254, (unsigned char)112,
     (unsigned char)14, (unsigned char)112, (unsigned char)14, (unsigned char)112,
     (unsigned char)14, (unsigned char)112, (unsigned char)14, (unsigned char)112,
     (unsigned char)14, (unsigned char)112, (unsigned char)14, (unsigned char)112,
     (unsigned char)14, (unsigned char)112, (unsigned char)14, (unsigned char)127,
     (unsigned char)254, (unsigned char)127, (unsigned char)254, (unsigned char)127,
     (unsigned char)254, (unsigned char)0, (unsigned char)0}, 0};
#line 22 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/cursor.c"
Cursor___0 fatarrow  =    {{-1, -1}, {(unsigned char)255, (unsigned char)255, (unsigned char)128, (unsigned char)1,
               (unsigned char)128, (unsigned char)2, (unsigned char)128, (unsigned char)12,
               (unsigned char)128, (unsigned char)16, (unsigned char)128, (unsigned char)16,
               (unsigned char)128, (unsigned char)8, (unsigned char)128, (unsigned char)4,
               (unsigned char)128, (unsigned char)2, (unsigned char)128, (unsigned char)1,
               (unsigned char)128, (unsigned char)2, (unsigned char)140, (unsigned char)4,
               (unsigned char)146, (unsigned char)8, (unsigned char)145, (unsigned char)16,
               (unsigned char)160, (unsigned char)160, (unsigned char)192, (unsigned char)64},
    {(unsigned char)0, (unsigned char)0, (unsigned char)127, (unsigned char)254, (unsigned char)127,
     (unsigned char)252, (unsigned char)127, (unsigned char)240, (unsigned char)127,
     (unsigned char)224, (unsigned char)127, (unsigned char)224, (unsigned char)127,
     (unsigned char)240, (unsigned char)127, (unsigned char)248, (unsigned char)127,
     (unsigned char)252, (unsigned char)127, (unsigned char)254, (unsigned char)127,
     (unsigned char)252, (unsigned char)115, (unsigned char)248, (unsigned char)97,
     (unsigned char)240, (unsigned char)96, (unsigned char)224, (unsigned char)64,
     (unsigned char)64, (unsigned char)0, (unsigned char)0}, 0};
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/cursor.c"
Cursor___0 *cursor  =    & fatarrow;
#line 52 "./../include/frame.h"
Point _frdraw(Frame *f , Point pt ) ;
#line 66
void _frredraw(Frame *f , Point pt ) ;
#line 70
int _frstrlen(Frame *f , int nb ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frdraw.c"
void _frredraw(Frame *f , Point pt ) 
{ 
  Frbox *b ;
  int nb ;

  {
#line 12
  nb = 0;
#line 12
  b = f->box;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! (nb < (int )f->nbox)) {
#line 12
      goto while_break;
    }
    {
#line 13
    _frcklinewrap(f, & pt, b);
    }
#line 14
    if (b->nrune >= 0L) {
      {
#line 15
      string(f->b, pt, f->font, (char *)b->a.ptr, (Fcode )12);
      }
    }
#line 16
    pt.x = (int )((long )pt.x + b->wid);
#line 12
    nb ++;
#line 12
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frdraw.c"
Point _frdraw(Frame *f , Point pt ) 
{ 
  Frbox *b ;
  int nb ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 26
  b = f->box;
#line 26
  nb = 0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (nb < (int )f->nbox)) {
#line 26
      goto while_break;
    }
    {
#line 27
    _frcklinewrap0(f, & pt, b);
    }
#line 28
    if (pt.y == f->r.max.y) {
      {
#line 29
      tmp = _frstrlen(f, nb);
#line 29
      f->nchars = (ushort )((int )f->nchars - tmp);
#line 30
      _frdelbox(f, nb, (int )f->nbox - 1);
      }
#line 31
      goto while_break;
    }
#line 33
    if (b->nrune > 0L) {
      {
#line 34
      n = _frcanfit(f, pt, b);
      }
#line 35
      if (n == 0) {
        {
#line 36
        berror((char *)"draw: _frcanfit==0");
        }
      }
#line 37
      if ((long )n != b->nrune) {
        {
#line 38
        _frsplitbox(f, nb, n);
#line 39
        b = f->box + nb;
        }
      }
#line 41
      pt.x = (int )((long )pt.x + b->wid);
    } else
#line 43
    if ((int )b->a.b.bc == 10) {
#line 44
      pt.x = (int )f->left;
#line 44
      pt.y += (int )(f->font)->height;
    } else {
      {
#line 46
      tmp___0 = _frnewwid(f, pt, b);
#line 46
      pt.x += tmp___0;
      }
    }
#line 26
    nb ++;
#line 26
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (pt);
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frdraw.c"
int _frstrlen(Frame *f , int nb ) 
{ 
  int n ;
  long tmp ;

  {
#line 56
  n = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (nb < (int )f->nbox)) {
#line 56
      goto while_break;
    }
#line 57
    if ((f->box + nb)->nrune < 0L) {
#line 57
      tmp = 1L;
    } else {
#line 57
      tmp = (f->box + nb)->nrune;
    }
#line 57
    n = (int )((long )n + tmp);
#line 56
    nb ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (n);
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *notaddress ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
View *openinclude(View *v , Range r ) ;
#line 241
Range view_expand(View *v , Range r , char *s ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
static Bool view_literal(View **vp , Range *r , char *s ) ;
#line 9
static Bool view_gotofile(View **vp , Range *r , char *a ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
View *openlabel(char *label , Bool create ) 
{ 
  View *v ;
  Path contracted ;

  {
  {
#line 17
  pathcontract(contracted, label);
#line 19
  v = data_find(contracted);
  }
#line 19
  if (v) {
    {
#line 20
    tile_show(v->tile);
    }
#line 21
    return (v);
  } else {
    {
#line 22
    v = data_open(contracted, create);
    }
#line 22
    if (v) {
#line 23
      return (v);
    } else {
#line 25
      return ((View *)0);
    }
  }
}
}
#line 29 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
void view_look(View *v , char *arg ) 
{ 
  Bool found ;
  ulong p ;
  Range r ;
  ulong tmp ;
  ulong tmp___0 ;

  {
  {
#line 31
  found = (Bool )0;
#line 37
  tmp = text_length(v->t);
  }
#line 37
  if (! tmp) {
#line 38
    return;
  }
  {
#line 40
  tmp___0 = text_length(v->t);
#line 40
  p = (v->sel.p0 + 1UL) % tmp___0;
#line 41
  r = range(p, p);
  }
#line 43
  if (arg) {
    {
#line 44
    found = text_findliteralutf(v->t, & r, arg);
    }
  } else
#line 45
  if (v->sel.p1 - v->sel.p0) {
    {
#line 46
    found = text_look(v->t, & r, v->sel);
    }
  } else {
#line 48
    found = (Bool )0;
  }
#line 51
  if (found) {
    {
#line 52
    view_show(v, r);
#line 53
    view_select(v, r);
#line 54
    view_setlastselection(v);
    }
  }
#line 56
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
Bool view_goto(View **vp , Range *r , char *s ) 
{ 
  Bool tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 71
  tmp = view_gotofile(vp, r, s);
  }
#line 71
  if (tmp) {
#line 71
    tmp___1 = 1;
  } else {
    {
#line 71
    tmp___0 = view_literal(vp, r, s);
    }
#line 71
    if (tmp___0) {
#line 71
      tmp___1 = 1;
    } else {
#line 71
      tmp___1 = 0;
    }
  }
#line 71
  return ((Bool )tmp___1);
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
void b3(View *v , Range r ) 
{ 
  char *s ;
  View *oldv ;
  Range expanded ;
  Data *d ;
  View *found ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Tile *tmp___2 ;
  View *tmp___3 ;

  {
  {
#line 87
  expanded = view_expand(v, r, notaddress);
  }
#line 88
  if (! (expanded.p1 - expanded.p0)) {
#line 89
    return;
  }
  {
#line 90
  s = text_duputf(v->t, expanded);
#line 91
  d = view_data(v);
#line 92
  oldv = v;
#line 95
  tmp = data_sendgoto(d, expanded, s);
  }
#line 95
  if (tmp) {
#line 96
    goto cleanup;
  }
  {
#line 99
  tmp___1 = view_gotofile(& v, & expanded, s);
  }
#line 99
  if (tmp___1) {
#line 100
    r = expanded;
  } else {
    {
#line 101
    found = openinclude(v, r);
    }
#line 101
    if (found) {
#line 102
      v = found;
#line 103
      r = found->sel;
    } else {
      {
#line 104
      tmp___0 = view_literal(& v, & expanded, s);
      }
#line 104
      if (tmp___0) {
#line 105
        r = expanded;
      } else {
#line 107
        goto cleanup;
      }
    }
  }
  {
#line 110
  view_show(v, r);
#line 111
  view_select(v, r);
#line 112
  view_setlastselection(v);
#line 115
  tmp___2 = view_win(v);
#line 115
  tmp___3 = tile_tag(tmp___2);
  }
#line 115
  if ((unsigned long )oldv != (unsigned long )tmp___3) {
    {
#line 116
    view_warp(v, r);
    }
  }
  cleanup: 
  {
#line 119
  free((void *)s);
  }
#line 120
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
static Bool view_literal(View **vp , Range *r , char *s ) 
{ 
  View *v ;
  Text *t___0 ;
  Range tmp ;
  Bool tmp___0 ;

  {
#line 132
  v = *vp;
#line 133
  tmp = *r;
#line 135
  if (v) {
#line 135
    if (! v->scroll) {
#line 135
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 136
    v = view_body(v);
    }
#line 136
    if (v) {
#line 137
      tmp = v->sel;
    } else {
      {
#line 136
      v = view_body(last_selection);
      }
#line 136
      if (v) {
#line 137
        tmp = v->sel;
      } else {
#line 139
        return ((Bool )0);
      }
    }
  }
  {
#line 144
  t___0 = v->t;
#line 145
  tmp___0 = text_findliteralutf(t___0, & tmp, s);
  }
#line 145
  if (tmp___0) {
#line 146
    *vp = v;
#line 147
    *r = tmp;
#line 148
    return ((Bool )1);
  }
#line 150
  return ((Bool )0);
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/vsearch.c"
static Bool view_gotofile(View **vp , Range *r , char *a ) 
{ 
  Path s ;
  View *v ;
  View *v2 ;
  char *colon ;
  Path label ;
  Data *tmp ;
  Range oldr ;
  Bool tmp___0 ;
  size_t tmp___1 ;
  Bool tmp___2 ;

  {
  {
#line 164
  v = *vp;
#line 169
  strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)a);
#line 170
  colon = strchr((char const   *)(s), ':');
  }
#line 171
  if (colon) {
#line 172
    *colon = (char)0;
  }
  {
#line 176
  tmp___1 = strlen((char const   *)(s));
  }
#line 176
  if (tmp___1) {
    {
#line 178
    tmp = view_data(v);
#line 178
    data_addcontext(tmp, label, s);
#line 179
    v2 = openlabel(label, (Bool )0);
    }
#line 179
    if (v2) {
#line 180
      if (colon) {
        {
#line 181
        oldr = v2->sel;
#line 183
        tmp___0 = text_search(v2->t, r, colon + 1, v2->sel);
        }
#line 183
        if (! tmp___0) {
#line 184
          *r = oldr;
        }
      } else {
#line 187
        *r = v2->sel;
      }
#line 189
      *vp = v2;
#line 190
      return ((Bool )1);
    } else {
#line 192
      return ((Bool )0);
    }
  }
#line 197
  if (v) {
#line 197
    if (! v->scroll) {
#line 197
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 198
    v = view_body(v);
    }
#line 198
    if (! v) {
      {
#line 198
      v = view_body(last_selection);
      }
#line 198
      if (! v) {
#line 199
        return ((Bool )0);
      }
    }
  }
  {
#line 201
  *r = v->sel;
#line 202
  tmp___2 = text_search(v->t, r, colon + 1, v->sel);
  }
#line 202
  if (tmp___2) {
#line 203
    *vp = v;
#line 204
    return ((Bool )1);
  }
#line 206
  return ((Bool )0);
}
}
#line 212 "./../include/libg.h"
void circle(Bitmap *b , Point p , int r , int v , Fcode f ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/circle.c"
void circle(Bitmap *b , Point p , int r , int v , Fcode f ) 
{ 
  unsigned int d ;
  int x ;
  int y ;
  GC g ;

  {
#line 13
  x = p.x - r;
#line 14
  y = p.y - r;
#line 15
  if (b->flag & 32) {
#line 16
    x -= b->r.min.x;
#line 17
    y -= b->r.min.y;
  }
  {
#line 19
  d = (unsigned int )(2 * r);
#line 20
  g = _getfillgc(f, b, (unsigned long )v);
#line 21
  XDrawArc(_dpy, (Drawable )b->id, g, x, y, d, d, 0, 23040);
  }
#line 22
  return;
}
}
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *notinclude ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Range text_expand(Text *t___0 , Range r , char *s ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/include.c"
static char *pathfind(char const   *paths , char const   *file ) ;
#line 8
static Bool is_includebrackets(char left___0 , char right___0 ) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/include.c"
View *openinclude(View *v , Range r ) 
{ 
  Range expanded ;
  Path buf___3 ;
  Path pbuf ;
  int len ;
  Text *t___0 ;
  char *s ;
  Bool tmp ;
  char *tmp___0 ;
  View *tmp___1 ;

  {
  {
#line 25
  t___0 = view_text(v);
#line 27
  expanded = text_expand(t___0, r, notinclude);
#line 28
  len = (int )(expanded.p1 - expanded.p0);
  }
#line 29
  if (len > 12288) {
#line 30
    return ((View *)0);
  } else
#line 29
  if (len < 2) {
#line 30
    return ((View *)0);
  }
  {
#line 31
  len = text_copyutf(t___0, expanded, buf___3);
#line 33
  tmp = is_includebrackets(buf___3[0], buf___3[len - 1]);
  }
#line 33
  if (! tmp) {
#line 34
    return ((View *)0);
  }
  {
#line 36
  buf___3[len - 1] = (char)0;
#line 37
  tmp___0 = getenv("INCLUDES");
#line 37
  s = pathfind((char const   *)tmp___0, (char const   *)(buf___3 + 1));
  }
#line 38
  if (! s) {
    {
#line 39
    sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)"/usr/include/%s",
            buf___3 + 1);
#line 40
    s = pbuf;
    }
  }
  {
#line 42
  tmp___1 = openlabel(s, (Bool )0);
  }
#line 42
  return (tmp___1);
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/include.c"
static Bool is_includebrackets(char left___0 , char right___0 ) 
{ 
  int tmp ;

  {
#line 51
  if ((int )left___0 == 34) {
#line 51
    if ((int )right___0 == 34) {
#line 51
      tmp = 1;
    } else {
#line 51
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if ((int )left___0 == 60) {
#line 51
    if ((int )right___0 == 62) {
#line 51
      tmp = 1;
    } else {
#line 51
      tmp = 0;
    }
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return ((Bool )tmp);
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/include.c"
static char const   *nextstr(char const   *p , char const   *c , int *n ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 59
  if (! p) {
#line 60
    return ((char const   *)0);
  } else
#line 59
  if (! *p) {
#line 60
    return ((char const   *)0);
  }
  {
#line 62
  tmp = strcspn(p, c);
#line 62
  i = (int )tmp;
#line 62
  *n = i;
  }
#line 63
  if (*(p + i)) {
#line 64
    i ++;
  }
#line 65
  return (p + i);
}
}
#line 68 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/include.c"
static char *pathfind(char const   *paths , char const   *file ) 
{ 
  char const   *p ;
  char const   *ptmp ;
  int flen ;
  int plen ;
  size_t tmp ;
  int fd ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 75
  if (! paths) {
#line 76
    return ((char *)0);
  } else
#line 75
  if (! file) {
#line 76
    return ((char *)0);
  }
  {
#line 78
  tmp = strlen(file);
#line 78
  flen = (int )tmp;
#line 79
  p = paths;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    ptmp = nextstr(p, ":", & plen);
    }
#line 80
    if (! ((unsigned long )ptmp != (unsigned long )((char const   *)0))) {
#line 80
      goto while_break;
    }
    {
#line 82
    tmp___1 = malloc((size_t )(((plen + 1) + flen) + 1));
#line 82
    tmp___0 = (char *)tmp___1;
    }
#line 84
    if (tmp___0) {
      {
#line 85
      sprintf((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"%.*s/%s",
              plen, p, file);
#line 86
      fd = open((char const   *)tmp___0, 0);
      }
#line 86
      if (fd < 0) {
        {
#line 87
        free((void *)tmp___0);
        }
      } else {
        {
#line 89
        close(fd);
        }
#line 90
        return (tmp___0);
      }
    }
#line 93
    p = ptmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return ((char *)0);
}
}
#line 205 "./../include/libg.h"
Font___0 *mkfont(Subfont *subfont ) ;
#line 235
int scrpix(int *w , int *h ) ;
#line 242
unsigned long event(Event *e ) ;
#line 245
int ekbd(void) ;
#line 246
int ecanread(unsigned long keys ) ;
#line 247
int ecanmouse(void) ;
#line 248
int ecankbd(void) ;
#line 250
void eflush(unsigned long keys ) ;
#line 253
unsigned long rgbpix(Bitmap *b , RGB col ) ;
#line 254
void rdcolmap(Bitmap *b , RGB *map ) ;
#line 255
void wrcolmap(Bitmap *b , RGB *map ) ;
#line 258
int snarfswap(char *s , int n , char **t___0 ) ;
#line 261
int scrollfwdbut(void) ;
#line 276 "./../include/libg.h"
Bitmap screen  ;
#line 277 "./../include/libg.h"
Font___0 *font  ;
#line 277 "./../include/libg.h"
Font___0 *fixed  ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1564
extern Colormap XCreateColormap(Display * , Window  , Visual * , int  ) ;
#line 1851
extern int XScreenNumberOfScreen(Screen * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1869
extern XIOErrorHandler XSetIOErrorHandler(int (*)(Display * ) ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2559
extern int XFreeFontInfo(char ** , XFontStruct * , int  ) ;
#line 2975
extern int XQueryColors(Display * , Colormap  , XColor * , int  ) ;
#line 3400
extern int XStoreColors(Display * , Colormap  , XColor * , int  ) ;
#line 542 "/usr/include/X11/Xutil.h"
extern int XMatchVisualInfo(Display * , int  , int  , int  , XVisualInfo * ) ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
Display *_dpy  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
unsigned long _fgpixel  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
unsigned long _bgpixel  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
XColor _fgcolor  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/libgint.h"
XColor _bgcolor  ;
#line 522 "/usr/include/X11/Intrinsic.h"
extern Boolean XtCallAcceptFocus(Widget  , Time * ) ;
#line 692
extern XtTranslations XtParseTranslationTable(char const   * ) ;
#line 705
extern void XtAugmentTranslations(Widget  , XtTranslations  ) ;
#line 724
extern void XtAppAddActions(XtAppContext  , XtActionList  , Cardinal  ) ;
#line 984
extern XtIntervalId XtAppAddTimeOut(XtAppContext  , unsigned long  , void (*)(XtPointer  ,
                                                                              XtIntervalId * ) ,
                                    XtPointer  ) ;
#line 991
extern void XtRemoveTimeOut(XtIntervalId  ) ;
#line 1002
extern XtInputId XtAppAddInput(XtAppContext  , int  , XtPointer  , void (*)(XtPointer  ,
                                                                            int * ,
                                                                            XtInputId * ) ,
                               XtPointer  ) ;
#line 1010
extern void XtRemoveInput(XtInputId  ) ;
#line 1051
extern XtInputMask XtAppPending(XtAppContext  ) ;
#line 1110
extern void XtRealizeWidget(Widget  ) ;
#line 1190
extern Display *XtDisplay(Widget  ) ;
#line 1198
extern Screen *XtScreen(Widget  ) ;
#line 1206
extern Window XtWindow(Widget  ) ;
#line 1376
extern Widget XtCreateManagedWidget(char const   * , WidgetClass  , Widget  , ArgList  ,
                                    Cardinal  ) ;
#line 1474
extern Widget XtAppInitialize(XtAppContext * , char const   * , XrmOptionDescList  ,
                              Cardinal  , int * , String * , String * , ArgList  ,
                              Cardinal  ) ;
#line 1592
extern void XtSetValues(Widget  , ArgList  , Cardinal  ) ;
#line 1603
extern void XtGetValues(Widget  , ArgList  , Cardinal  ) ;
#line 189 "/usr/include/X11/Shell.h"
extern char const   XtShellStrings[] ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
Widget _toplevel  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int _ld2d[6]  = {      1,      2,      4,      8, 
        16,      24};
#line 43 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long _ld2dmask[6]  = {      1UL,      3UL,      15UL,      255UL, 
        65535UL,      16777215UL};
#line 44 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
Colormap _libg_cmap  ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int _cmap_installed  ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static XtAppContext app  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Widget widg  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int exposed  =    0;
#line 53 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Atom wm_take_focus  ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Mouse lastmouse  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Esrc esrc[10]  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int nsrc  ;
#line 78 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int einitcalled  =    0;
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int Smouse  =    -1;
#line 80 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int Skeyboard  =    -1;
#line 81 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int Stimer  =    -1;
#line 84
static Font___0 *initfont(char *name , XFontStruct *xf , char *backupname ) ;
#line 85
static void reshaped(int minx , int miny , int maxx , int maxy ) ;
#line 86
static void gotchar(int c ) ;
#line 87
static void gotmouse(Gwinmouse *gm ) ;
#line 88
static int log2(int n ) ;
#line 89
static void pixtocolor(Pixel p , XColor *pc ) ;
#line 90
static Subfont *XFontStructtoSubfont(XFontStruct *fp ) ;
#line 91
static Ebuf *ebread(Esrc *s ) ;
#line 92
static Ebuf *ebadd(Esrc *s ) ;
#line 93
static void focinit(Widget w ) ;
#line 94
static void wmproto(Widget w , XEvent *e , String *p , Cardinal *np ) ;
#line 95
static void waitevent(void) ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void (*onerr)(char * )  ;
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
String _fallbacks[3]  = {      (String )"*gwin.width: 800",      (String )"*gwin.height: 600",      (String )((void *)0)};
#line 106 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static char *shelltrans  =    (char *)"<ClientMessage> WM_PROTOCOLS : WMProtocolAction()";
#line 108 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static XtActionsRec wmpactions[1]  = {      {(String )"WMProtocolAction", & wmproto}};
#line 114 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static XrmOptionDescRec optable[3]  = {      {(char *)"-p9fn", (char *)"*p9font", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-p9font",
      (char *)"*p9font", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-p9fixed", (char *)"*p9fixed", (XrmOptionKind )3, (caddr_t )((void *)0)}};
#line 120 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int ioerr(Display *d ) 
{ 


  {
#line 123
  if (onerr) {
    {
#line 124
    (*onerr)((char *)"ioerr");
    }
  } else {
    {
#line 126
    exit(1);
    }
  }
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void xtbinit(void (*f)(char * ) , char *class___0 , int *pargc , char **argv , char **fallbacks ) 
{ 
  int n ;
  unsigned int depth ;
  XFontStruct *xf ;
  String fontname ;
  String fixedname ;
  Arg args___0[10] ;
  char *p ;
  int compose___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  Window tmp___5 ;

  {
#line 143
  if (! class___0) {
#line 143
    if (*(argv + 0)) {
      {
#line 144
      p = strrchr((char const   *)*(argv + 0), '/');
      }
#line 145
      if (p) {
#line 146
        if ((unsigned long )(p + 1) != (unsigned long )((void *)0)) {
          {
#line 146
          tmp = strlen((char const   *)(p + 1));
#line 146
          tmp___0 = XtMalloc((unsigned int )tmp + 1U);
#line 146
          tmp___1 = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)(p + 1));
#line 146
          class___0 = tmp___1;
          }
        } else {
#line 146
          class___0 = (char *)((void *)0);
        }
      } else
#line 148
      if ((unsigned long )*(argv + 0) != (unsigned long )((void *)0)) {
        {
#line 148
        tmp___2 = strlen((char const   *)*(argv + 0));
#line 148
        tmp___3 = XtMalloc((unsigned int )tmp___2 + 1U);
#line 148
        tmp___4 = strcpy((char */* __restrict  */)tmp___3, (char const   */* __restrict  */)*(argv + 0));
#line 148
        class___0 = tmp___4;
        }
      } else {
#line 148
        class___0 = (char *)((void *)0);
      }
#line 149
      if ((int )*(class___0 + 0) >= 97) {
#line 149
        if ((int )*(class___0 + 0) <= 122) {
#line 150
          *(class___0 + 0) = (char )((int )*(class___0 + 0) + -32);
        }
      }
    }
  }
#line 152
  onerr = f;
#line 153
  if (! fallbacks) {
#line 154
    fallbacks = _fallbacks;
  }
  {
#line 155
  n = 0;
#line 156
  args___0[n].name = (char *)(& XtShellStrings[417]);
#line 156
  args___0[n].value = (XtArgVal )1;
#line 156
  n ++;
#line 157
  _toplevel = XtAppInitialize(& app, (char const   *)class___0, optable, (Cardinal )(sizeof(optable) / sizeof(optable[0])),
                              pargc, argv, fallbacks, args___0, (Cardinal )n);
#line 161
  n = 0;
#line 162
  args___0[n].name = (String )"reshaped";
#line 162
  args___0[n].value = (XtArgVal )(& reshaped);
#line 162
  n ++;
#line 163
  args___0[n].name = (String )"gotchar";
#line 163
  args___0[n].value = (XtArgVal )(& gotchar);
#line 163
  n ++;
#line 164
  args___0[n].name = (String )"gotmouse";
#line 164
  args___0[n].value = (XtArgVal )(& gotmouse);
#line 164
  n ++;
#line 165
  widg = XtCreateManagedWidget("gwin", gwinWidgetClass, _toplevel, args___0, (Cardinal )n);
#line 167
  n = 0;
#line 168
  args___0[n].name = (char *)(& XtStrings[214]);
#line 168
  args___0[n].value = (XtArgVal )(& _fgpixel);
#line 168
  n ++;
#line 169
  args___0[n].name = (char *)(& XtStrings[52]);
#line 169
  args___0[n].value = (XtArgVal )(& _bgpixel);
#line 169
  n ++;
#line 170
  args___0[n].name = (char *)(& XtStrings[163]);
#line 170
  args___0[n].value = (XtArgVal )(& depth);
#line 170
  n ++;
#line 171
  args___0[n].name = (char *)(& XtStrings[199]);
#line 171
  args___0[n].value = (XtArgVal )(& xf);
#line 171
  n ++;
#line 172
  args___0[n].name = (String )"p9font";
#line 172
  args___0[n].value = (XtArgVal )(& fontname);
#line 172
  n ++;
#line 173
  args___0[n].name = (String )"p9fixed";
#line 173
  args___0[n].value = (XtArgVal )(& fixedname);
#line 173
  n ++;
#line 174
  args___0[n].name = (String )"composeMod";
#line 174
  args___0[n].value = (XtArgVal )(& compose___0);
#line 174
  n ++;
#line 175
  XtGetValues(widg, args___0, (Cardinal )n);
#line 176
  XSetIOErrorHandler(& ioerr);
#line 177
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))(& ioerr));
  }
#line 179
  if (compose___0 < 0) {
    {
#line 180
    n = 0;
#line 181
    args___0[n].name = (String )"composeMod";
#line 181
    args___0[n].value = (XtArgVal )0;
#line 181
    n ++;
#line 182
    XtSetValues(widg, args___0, (Cardinal )n);
    }
  } else
#line 179
  if (compose___0 > 5) {
    {
#line 180
    n = 0;
#line 181
    args___0[n].name = (String )"composeMod";
#line 181
    args___0[n].value = (XtArgVal )0;
#line 181
    n ++;
#line 182
    XtSetValues(widg, args___0, (Cardinal )n);
    }
  }
  {
#line 185
  _dpy = XtDisplay(widg);
#line 186
  screen.id = 0;
#line 187
  XtRealizeWidget(_toplevel);
#line 188
  pixtocolor(_fgpixel, & _fgcolor);
#line 189
  pixtocolor(_bgpixel, & _bgcolor);
#line 190
  tmp___5 = XtWindow(widg);
#line 190
  screen.id = (int )tmp___5;
#line 191
  screen.ldepth = log2((int )depth);
#line 192
  screen.flag = 4;
  }
#line 193
  if (_fgpixel != 0UL) {
#line 194
    screen.flag |= 2;
  }
#line 195
  if (depth == 1U) {
#line 196
    screen.flag |= 1;
  }
  {
#line 197
  font = initfont(fontname, xf, (char *)"variable");
#line 198
  fixed = initfont(fixedname, (XFontStruct *)0, (char *)"fixed");
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (! exposed)) {
#line 200
      goto while_break;
    }
    {
#line 201
    XFlush(_dpy);
#line 202
    XtAppProcessEvent(app, (XtInputMask )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  XFlush(_dpy);
#line 205
  focinit(_toplevel);
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Font___0 *initfont(char *name , XFontStruct *xf , char *backupname ) 
{ 
  Font___0 *f ;
  long tmp ;
  Subfont *tmp___0 ;
  Font___0 *tmp___1 ;
  Subfont *tmp___2 ;
  Font___0 *tmp___3 ;

  {
#line 218
  if (name) {
    {
#line 219
    f = rdfontfile(name, screen.ldepth);
    }
#line 220
    if (f) {
      {
#line 220
      tmp = charwidth(f, (Rune )' ');
      }
#line 220
      if (tmp != 0L) {
#line 221
        return (f);
      }
    }
  }
#line 223
  if (xf) {
    {
#line 224
    tmp___0 = XFontStructtoSubfont(xf);
#line 224
    tmp___1 = mkfont(tmp___0);
    }
#line 224
    return (tmp___1);
  }
  {
#line 225
  tmp___2 = getsubfont(backupname);
#line 225
  tmp___3 = mkfont(tmp___2);
  }
#line 225
  return (tmp___3);
}
}
#line 228 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void focinit(Widget w ) 
{ 
  XrmValue src ;
  XrmValue dst ;
  size_t tmp ;
  Window tmp___0 ;
  Display *tmp___1 ;
  XtTranslations tmp___2 ;

  {
  {
#line 234
  src.addr = (XPointer )"WM_TAKE_FOCUS";
#line 235
  tmp = strlen((char const   *)src.addr);
#line 235
  src.size = (unsigned int )(tmp + 1UL);
#line 236
  dst.addr = (XPointer )((XtPointer )(& wm_take_focus));
#line 237
  dst.size = (unsigned int )sizeof(Atom );
#line 238
  XtConvertAndStore(w, (char const   *)((char *)(& XtStrings[1797])), & src, (char const   *)((char *)(& XtStrings[1544])),
                    & dst);
#line 239
  tmp___0 = XtWindow(w);
#line 239
  tmp___1 = XtDisplay(w);
#line 239
  XSetWMProtocols(tmp___1, tmp___0, & wm_take_focus, 1);
#line 240
  XtAppAddActions(app, wmpactions, (Cardinal )(sizeof(wmpactions) / sizeof(wmpactions[0])));
#line 241
  tmp___2 = XtParseTranslationTable((char const   *)shelltrans);
#line 241
  XtAugmentTranslations(w, tmp___2);
  }
#line 243
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void wmproto(Widget w , XEvent *e , String *p , Cardinal *np ) 
{ 
  Time t___0 ;

  {
#line 251
  if (e->type == 33) {
#line 251
    if ((Atom )e->xclient.data.l[0] == wm_take_focus) {
      {
#line 253
      t___0 = (Time )e->xclient.data.l[1];
#line 254
      XtCallAcceptFocus(widg, & t___0);
      }
    }
  }
#line 256
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void reshaped(int minx , int miny , int maxx , int maxy ) 
{ 
  Ebuf *eb ;

  {
  {
#line 265
  screen.r = Rect(minx, miny, maxx, maxy);
#line 266
  screen.clipr = screen.r;
  }
#line 267
  if (screen.id) {
    {
#line 268
    exposed = 1;
#line 269
    ereshaped(screen.r);
    }
  }
#line 271
  if (einitcalled) {
    {
#line 276
    eb = ebadd(& esrc[Smouse]);
    }
#line 277
    if ((unsigned long )eb == (unsigned long )((Ebuf *)0)) {
      {
#line 278
      berror((char *)"eballoc can\'t malloc");
      }
    }
    {
#line 279
    memcpy((void */* __restrict  */)((void *)(eb->buf)), (void const   */* __restrict  */)((void *)(& lastmouse)),
           sizeof(lastmouse));
#line 280
    (esrc[Smouse].count) ++;
    }
  }
#line 282
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void gotchar(int c ) 
{ 
  Ebuf *eb ;

  {
#line 289
  if (! einitcalled) {
#line 290
    return;
  } else
#line 289
  if (Skeyboard == -1) {
#line 290
    return;
  }
  {
#line 291
  eb = ebadd(& esrc[Skeyboard]);
  }
#line 292
  if ((unsigned long )eb == (unsigned long )((Ebuf *)0)) {
    {
#line 293
    berror((char *)"eballoc can\'t malloc");
    }
  }
#line 294
  eb->buf[0] = (unsigned char )((unsigned short )(c & 65535));
#line 294
  eb->buf[1] = (unsigned char )((int )((unsigned short )(c & 65535)) >> 8);
#line 295
  (esrc[Skeyboard].count) ++;
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void gotmouse(Gwinmouse *gm ) 
{ 
  Ebuf *eb ;
  Mouse m ;

  {
#line 304
  if (! einitcalled) {
#line 305
    return;
  } else
#line 304
  if (Smouse == -1) {
#line 305
    return;
  }
  {
#line 306
  m.buttons = gm->buttons;
#line 307
  m.xy.x = gm->xy.x;
#line 308
  m.xy.y = gm->xy.y;
#line 309
  m.msec = gm->msec;
#line 310
  lastmouse = m;
#line 311
  eb = ebadd(& esrc[Smouse]);
  }
#line 312
  if ((unsigned long )eb == (unsigned long )((Ebuf *)0)) {
    {
#line 313
    berror((char *)"eballoc can\'t malloc");
    }
  }
  {
#line 314
  memcpy((void */* __restrict  */)((void *)(eb->buf)), (void const   */* __restrict  */)((void *)(& m)),
         sizeof(m));
#line 315
  (esrc[Smouse].count) ++;
  }
#line 316
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void gotinput(XtPointer cldata , int *pfd , XtInputId *id___0 ) 
{ 
  Ebuf *eb ;
  Ebuf *lasttail ;
  Ebuf *newe ;
  Esrc *es ;
  int n ;
  void *tmp ;

  {
#line 325
  if (! einitcalled) {
#line 326
    return;
  }
#line 327
  es = (Esrc *)cldata;
#line 328
  if (es->count >= 1024) {
#line 329
    return;
  }
  {
#line 330
  lasttail = es->tail;
#line 331
  eb = ebadd(es);
  }
#line 332
  if ((unsigned long )eb == (unsigned long )((Ebuf *)0)) {
#line 333
    return;
  }
#line 334
  if (es->size) {
    {
#line 335
    n = (int )read(*pfd, (char *)(eb->buf), es->size);
    }
#line 336
    if (n < 0) {
#line 337
      n = 0;
    }
#line 338
    if (n < es->size) {
      {
#line 339
      tmp = realloc((void *)eb, sizeof(Ebuf ) + (unsigned long )n);
#line 339
      newe = (Ebuf *)tmp;
#line 340
      newe->n = n;
      }
#line 341
      if ((unsigned long )es->head == (unsigned long )eb) {
#line 342
        es->head = newe;
      } else {
#line 344
        lasttail->next = newe;
      }
#line 345
      es->tail = newe;
    }
  }
#line 348
  (es->count) ++;
#line 349
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void gottimeout(XtPointer cldata , XtIntervalId *id___0 ) 
{ 


  {
#line 354
  if (! einitcalled) {
#line 355
    return;
  } else
#line 354
  if (Stimer == -1) {
#line 355
    return;
  }
  {
#line 361
  esrc[Stimer].head = (Ebuf *)1;
#line 362
  esrc[Stimer].count = 1;
#line 363
  XtAppAddTimeOut(app, (unsigned long )((long )cldata), & gottimeout, cldata);
  }
#line 364
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static int log2(int n ) 
{ 
  int i ;
  int v ;

  {
#line 371
  i = 0;
#line 371
  v = 1;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (i < 32)) {
#line 371
      goto while_break;
    }
#line 372
    if (n <= v) {
#line 373
      goto while_break;
    }
#line 371
    i ++;
#line 371
    v <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (i);
}
}
#line 377 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void pixtocolor(Pixel p , XColor *pc ) 
{ 
  XrmValue xvf ;
  XrmValue xvt ;
  Boolean tmp ;

  {
  {
#line 393
  xvf.size = (unsigned int )sizeof(Pixel );
#line 394
  xvf.addr = (XPointer )((XtPointer )(& p));
#line 395
  xvt.size = (unsigned int )sizeof(XColor );
#line 396
  xvt.addr = (XPointer )((XtPointer )pc);
#line 397
  tmp = XtConvertAndStore(_toplevel, (char const   *)((char *)(& XtStrings[1754])),
                          & xvf, (char const   *)((char *)(& XtStrings[1596])), & xvt);
  }
#line 397
  if (! tmp) {
#line 398
    pc->pixel = p;
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long rgbpix(Bitmap *b , RGB col ) 
{ 
  XColor c ;
  Colormap cmap ;
  Arg args___0[2] ;
  int n ;
  int depth ;
  int dr ;
  int dg ;
  int db ;
  RGB map[256] ;
  RGB *m ;
  unsigned long d ;
  unsigned long max ;
  unsigned long pixel ;
  int tmp ;

  {
#line 412
  if (! _cmap_installed) {
    {
#line 413
    n = 0;
#line 414
    args___0[n].name = (char *)(& XtStrings[154]);
#line 414
    args___0[n].value = (XtArgVal )(& cmap);
#line 414
    n ++;
#line 415
    XtGetValues(_toplevel, args___0, (Cardinal )n);
#line 416
    c.red = (unsigned short )(col.red >> 16);
#line 417
    c.green = (unsigned short )(col.green >> 16);
#line 418
    c.blue = (unsigned short )(col.blue >> 16);
#line 419
    c.flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 420
    tmp = XAllocColor(_dpy, cmap, & c);
    }
#line 420
    if (tmp) {
#line 421
      return (c.pixel);
    }
  }
  {
#line 423
  depth = _ld2d[screen.ldepth];
#line 424
  rdcolmap(& screen, map);
#line 425
  max = 0xffffffffffffffffUL;
#line 426
  n = 0;
#line 426
  m = map;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (n < 1 << depth)) {
#line 426
      goto while_break;
    }
#line 428
    dr = (int )(m->red - col.red);
#line 429
    dg = (int )(m->green - col.green);
#line 430
    db = (int )(m->blue - col.blue);
#line 431
    d = (unsigned long )((dr * dr + dg * dg) + db * db);
#line 432
    if (d < max) {
#line 434
      max = d;
#line 435
      pixel = (unsigned long )n;
    } else
#line 432
    if (max == 0xffffffffffffffffUL) {
#line 434
      max = d;
#line 435
      pixel = (unsigned long )n;
    }
#line 426
    n ++;
#line 426
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  return (pixel);
}
}
#line 441 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void rdcolmap(Bitmap *b , RGB *map ) 
{ 
  XColor cols[256] ;
  int i ;
  int n ;
  int depth ;
  Colormap cmap ;
  Arg args___0[2] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 449
  if (_cmap_installed) {
#line 450
    cmap = _libg_cmap;
  } else {
    {
#line 452
    i = 0;
#line 453
    args___0[i].name = (char *)(& XtStrings[154]);
#line 453
    args___0[i].value = (XtArgVal )(& cmap);
#line 453
    i ++;
#line 454
    XtGetValues(_toplevel, args___0, (Cardinal )i);
    }
  }
#line 457
  depth = _ld2d[screen.ldepth];
#line 458
  n = 1 << depth;
#line 459
  if (depth == 1) {
#line 460
    tmp___0 = (unsigned long )(~ 0);
#line 460
    (map + 0)->blue = tmp___0;
#line 460
    tmp = tmp___0;
#line 460
    (map + 0)->green = tmp;
#line 460
    (map + 0)->red = tmp;
#line 461
    tmp___2 = 0UL;
#line 461
    (map + 1)->blue = tmp___2;
#line 461
    tmp___1 = tmp___2;
#line 461
    (map + 1)->green = tmp___1;
#line 461
    (map + 1)->red = tmp___1;
  } else {
#line 464
    if (n > 256) {
      {
#line 465
      berror((char *)"rdcolmap bitmap too deep");
      }
#line 466
      return;
    }
#line 468
    i = 0;
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      if (! (i < n)) {
#line 468
        goto while_break;
      }
#line 469
      cols[i].pixel = (unsigned long )i;
#line 468
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 470
    XQueryColors(_dpy, cmap, cols, n);
#line 471
    i = 0;
    }
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! (i < n)) {
#line 471
        goto while_break___0;
      }
#line 472
      (map + i)->red = (unsigned long )(((int )cols[i].red << 16) | (int )cols[i].red);
#line 473
      (map + i)->green = (unsigned long )(((int )cols[i].green << 16) | (int )cols[i].green);
#line 474
      (map + i)->blue = (unsigned long )(((int )cols[i].blue << 16) | (int )cols[i].blue);
#line 471
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 477
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void wrcolmap(Bitmap *b , RGB *map ) 
{ 
  int i ;
  int n ;
  int depth ;
  Screen *scr ;
  XColor cols[256] ;
  Arg args___0[2] ;
  XVisualInfo vi ;
  Window w ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 489
  scr = XtScreen(_toplevel);
#line 490
  depth = _ld2d[screen.ldepth];
#line 491
  n = 1 << depth;
  }
#line 492
  if (n > 256) {
    {
#line 493
    berror((char *)"wrcolmap bitmap too deep");
    }
#line 494
    return;
  } else
#line 495
  if (depth > 1) {
#line 496
    i = 0;
    {
#line 496
    while (1) {
      while_continue: /* CIL Label */ ;
#line 496
      if (! (i < n)) {
#line 496
        goto while_break;
      }
#line 497
      cols[i].red = (unsigned short )((map + i)->red >> 16);
#line 498
      cols[i].green = (unsigned short )((map + i)->green >> 16);
#line 499
      cols[i].blue = (unsigned short )((map + i)->blue >> 16);
#line 500
      cols[i].pixel = (unsigned long )i;
#line 501
      cols[i].flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 496
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 503
    tmp = XScreenNumberOfScreen(scr);
#line 503
    tmp___0 = XMatchVisualInfo(_dpy, tmp, depth, 3, & vi);
    }
#line 503
    if (! tmp___0) {
      {
#line 505
      berror((char *)"wrcolmap can\'t get visual");
      }
#line 506
      return;
    }
    {
#line 508
    w = XtWindow(_toplevel);
#line 509
    _libg_cmap = XCreateColormap(_dpy, w, vi.visual, 1);
#line 510
    XStoreColors(_dpy, _libg_cmap, cols, n);
#line 512
    i = 0;
#line 513
    args___0[i].name = (char *)(& XtStrings[154]);
#line 513
    args___0[i].value = (XtArgVal )_libg_cmap;
#line 513
    i ++;
#line 514
    XtSetValues(_toplevel, args___0, (Cardinal )i);
#line 515
    _cmap_installed = 1;
    }
  }
#line 517
  return;
}
}
#line 519 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
Subfont *getsubfont(char *s ) 
{ 
  XFontStruct *fp ;
  Subfont *tmp ;

  {
#line 524
  if (! s) {
#line 525
    return ((Subfont *)0);
  }
  {
#line 526
  fp = XLoadQueryFont(_dpy, (char const   *)s);
  }
#line 527
  if (! fp) {
#line 528
    return ((Subfont *)0);
  }
  {
#line 529
  tmp = XFontStructtoSubfont(fp);
  }
#line 529
  return (tmp);
}
}
#line 532 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Subfont *XFontStructtoSubfont(XFontStruct *fp ) 
{ 
  XCharStruct *cp ;
  Subfont *f ;
  int min ;
  int max ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 540
  if (! fp) {
    {
#line 541
    berror((char *)"no font");
    }
  }
  {
#line 542
  tmp = malloc(sizeof(Subfont ));
#line 542
  f = (Subfont *)tmp;
  }
#line 543
  if (! f) {
    {
#line 544
    berror((char *)"XFontStructtoSubfont malloc");
    }
  }
#line 545
  min = (int )fp->min_byte1;
#line 546
  max = (int )fp->max_byte1;
#line 547
  f->minrow = min;
#line 548
  f->mincol = (int )fp->min_char_or_byte2;
#line 549
  f->width = (int )((fp->max_char_or_byte2 - fp->min_char_or_byte2) + 1U);
#line 550
  f->n = f->width;
#line 551
  f->minchar = 0;
#line 552
  f->maxchar = (int )fp->max_char_or_byte2;
#line 553
  if (min) {
#line 554
    f->maxchar |= max << 8;
#line 555
    f->n *= (max - min) + 1;
  } else
#line 553
  if (max) {
#line 554
    f->maxchar |= max << 8;
#line 555
    f->n *= (max - min) + 1;
  }
  {
#line 557
  f->id = (int )fp->fid;
#line 558
  f->height = (unsigned char )((int )fp->max_bounds.ascent + (int )fp->max_bounds.descent);
#line 559
  f->ascent = (char )fp->max_bounds.ascent;
#line 560
  tmp___0 = malloc((unsigned long )(f->n + 1) * sizeof(Fontchar ));
#line 560
  f->info = (Fontchar *)tmp___0;
  }
#line 561
  if (! f->info) {
    {
#line 562
    berror((char *)"getsubfont malloc");
    }
  }
  {
#line 563
  memset((void *)f->info, 0, (unsigned long )(f->n + 1) * sizeof(Fontchar ));
#line 564
  i = 0;
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < f->n)) {
#line 564
      goto while_break;
    }
#line 565
    if (fp->per_char) {
#line 566
      cp = fp->per_char + i;
    } else {
#line 568
      cp = & fp->max_bounds;
    }
#line 569
    (f->info + i)->left = (signed char )cp->lbearing;
#line 570
    (f->info + i)->cwidth = (short )((int )cp->rbearing - (int )cp->lbearing);
#line 571
    (f->info + i)->width = (unsigned char )cp->width;
#line 572
    (f->info + i)->top = (unsigned char)0;
#line 573
    (f->info + i)->bottom = f->height;
#line 564
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 575
  XFreeFontInfo((char **)0, fp, 0);
  }
#line 576
  return (f);
}
}
#line 579 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int scrollfwdbut(void) 
{ 
  Arg arg ;
  Boolean v ;
  int tmp ;

  {
  {
#line 586
  arg.name = (String )"scrollForwardR";
#line 586
  arg.value = (XtArgVal )(& v);
#line 587
  XtGetValues(widg, & arg, (Cardinal )1);
  }
#line 588
  if (v) {
#line 588
    tmp = 3;
  } else {
#line 588
    tmp = 1;
  }
#line 588
  return (tmp);
}
}
#line 591 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void einit(unsigned long keys ) 
{ 


  {
#line 597
  nsrc = 0;
#line 598
  if (keys & 1UL) {
#line 599
    Smouse = 0;
#line 600
    esrc[Smouse].inuse = 1;
#line 601
    esrc[Smouse].size = (int )sizeof(Mouse );
#line 602
    esrc[Smouse].count = 0;
#line 603
    nsrc = Smouse + 1;
  }
#line 605
  if (keys & 2UL) {
#line 606
    Skeyboard = 1;
#line 607
    esrc[Skeyboard].inuse = 1;
#line 608
    esrc[Skeyboard].size = 1;
#line 609
    esrc[Skeyboard].count = 0;
#line 610
    if (Skeyboard >= nsrc) {
#line 611
      nsrc = Skeyboard + 1;
    }
  }
#line 613
  einitcalled = 1;
#line 614
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long estart(unsigned long key , int fd , int n ) 
{ 
  int i ;

  {
#line 621
  if (fd < 0) {
    {
#line 622
    berror((char *)"bad fd to estart");
    }
  }
#line 623
  if (n <= 0) {
#line 624
    n = 8320;
  } else
#line 623
  if (n > 8320) {
#line 624
    n = 8320;
  }
#line 625
  i = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! (i < 10)) {
#line 625
      goto while_break;
    }
#line 626
    if ((key & (unsigned long )(~ (1 << i))) == 0UL) {
#line 626
      if (! esrc[i].inuse) {
#line 627
        if (nsrc <= i) {
#line 628
          nsrc = i + 1;
        }
        {
#line 629
        esrc[i].inuse = 1;
#line 630
        esrc[i].size = n;
#line 631
        esrc[i].count = 0;
#line 632
        esrc[i].id = XtAppAddInput(app, fd, (XtPointer )1L, & gotinput, (XtPointer )(& esrc[i]));
        }
#line 634
        return ((unsigned long )(1 << i));
      }
    }
#line 625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  return (0UL);
}
}
#line 639 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void rmsource(int s ) 
{ 
  Ebuf *tmp ;

  {
#line 645
  esrc[s].inuse = 0;
#line 646
  esrc[s].size = 0;
#line 647
  esrc[s].count = 0;
#line 648
  tmp = (Ebuf *)0;
#line 648
  esrc[s].tail = tmp;
#line 648
  esrc[s].head = tmp;
#line 649
  return;
}
}
#line 651 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void estop(unsigned long key ) 
{ 
  int s ;

  {
  {
#line 656
  s = log2((int )key);
  }
#line 657
  if (! esrc[s].inuse) {
    {
#line 658
    berror((char *)"key not in use");
    }
  }
  {
#line 660
  XtRemoveInput(esrc[s].id);
#line 661
  rmsource(s);
  }
#line 662
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void estoptimer(unsigned long key ) 
{ 
  int s ;

  {
  {
#line 669
  s = log2((int )key);
  }
#line 670
  if (! esrc[s].inuse) {
    {
#line 671
    berror((char *)"key not in use");
    }
  }
#line 673
  if (Stimer != s) {
    {
#line 674
    berror((char *)"this key is not the timer");
    }
  }
  {
#line 675
  XtRemoveTimeOut(esrc[s].id);
#line 676
  Stimer = -1;
#line 677
  rmsource(s);
  }
#line 678
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long etimer(unsigned long key , long n ) 
{ 
  int i ;
  XtIntervalId tmp ;

  {
#line 685
  if (Stimer != -1) {
    {
#line 686
    berror((char *)"timer started twice");
    }
  }
#line 687
  if (n <= 0L) {
#line 688
    n = 1000L;
  }
#line 689
  i = 0;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (i < 10)) {
#line 689
      goto while_break;
    }
#line 690
    if ((key & (unsigned long )(~ (1 << i))) == 0UL) {
#line 690
      if (! esrc[i].inuse) {
#line 691
        if (nsrc <= i) {
#line 692
          nsrc = i + 1;
        }
        {
#line 693
        esrc[i].inuse = 1;
#line 694
        esrc[i].size = 0;
#line 695
        esrc[i].count = 0;
#line 696
        esrc[i].head = (Ebuf *)0;
#line 698
        tmp = XtAppAddTimeOut(app, (unsigned long )n, & gottimeout, (XtPointer )n);
#line 698
        esrc[i].id = tmp;
#line 700
        Stimer = i;
        }
#line 701
        return ((unsigned long )(1 << i));
      }
    }
#line 689
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return (0UL);
}
}
#line 706 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long event(Event *e ) 
{ 
  unsigned long tmp ;

  {
  {
#line 709
  tmp = eread((unsigned long )(~ 0L), e);
  }
#line 709
  return (tmp);
}
}
#line 712 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
unsigned long eread(unsigned long keys , Event *e ) 
{ 
  Ebuf *eb ;
  int i ;
  XtInputMask tmp ;

  {
#line 718
  if (keys == 0UL) {
#line 719
    return (0UL);
  }
  {
#line 721
  tmp = XtAppPending(app);
  }
#line 721
  if (tmp & 1UL) {
    {
#line 722
    XtAppProcessEvent(app, (XtInputMask )1);
    }
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    i = 0;
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 725
      if (! (i < nsrc)) {
#line 725
        goto while_break___0;
      }
#line 726
      if (keys & (unsigned long )(1 << i)) {
#line 726
        if (esrc[i].head) {
#line 727
          if (i == Smouse) {
            {
#line 728
            e->mouse = emouse();
            }
          } else
#line 729
          if (i == Skeyboard) {
            {
#line 730
            e->kbdc = ekbd();
            }
          } else
#line 731
          if (i == Stimer) {
#line 732
            esrc[i].head = (Ebuf *)0;
#line 733
            esrc[i].count = 0;
          } else {
            {
#line 735
            eb = ebread(& esrc[i]);
#line 736
            e->n = eb->n;
            }
#line 737
            if (e->n > 0) {
              {
#line 738
              memcpy((void */* __restrict  */)((void *)(e->data)), (void const   */* __restrict  */)((void *)(eb->buf)),
                     (size_t )e->n);
              }
            }
            {
#line 739
            free((void *)eb);
            }
          }
#line 741
          return ((unsigned long )(1 << i));
        }
      }
#line 725
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 743
    waitevent();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 747 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void eflush(unsigned long keys ) 
{ 
  int i ;
  Ebuf *eb ;
  Ebuf *enext ;

  {
#line 753
  if (keys == 0UL) {
#line 754
    return;
  }
#line 756
  i = 0;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < nsrc)) {
#line 756
      goto while_break;
    }
#line 757
    if (keys & (unsigned long )(1 << i)) {
#line 758
      eb = esrc[i].head;
      {
#line 758
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 758
        if (! eb) {
#line 758
          goto while_break___0;
        }
        {
#line 759
        enext = eb->next;
#line 760
        free((void *)eb);
#line 758
        eb = enext;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 762
      esrc[i].count = 0;
#line 763
      esrc[i].head = (Ebuf *)0;
#line 764
      esrc[i].tail = (Ebuf *)0;
    }
#line 756
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  return;
}
}
#line 768 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
Mouse emouse(void) 
{ 
  Mouse m ;
  Ebuf *eb ;

  {
#line 774
  if (! esrc[Smouse].inuse) {
    {
#line 775
    berror((char *)"mouse events not selected");
    }
  }
  {
#line 776
  eb = ebread(& esrc[Smouse]);
#line 777
  memcpy((void */* __restrict  */)((void *)(& m)), (void const   */* __restrict  */)((void *)(eb->buf)),
         sizeof(Mouse ));
#line 778
  free((void *)eb);
  }
#line 779
  return (m);
}
}
#line 782 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int ekbd(void) 
{ 
  Ebuf *eb ;
  int c ;

  {
#line 788
  if (! esrc[Skeyboard].inuse) {
    {
#line 789
    berror((char *)"keyboard events not selected");
    }
  }
  {
#line 790
  eb = ebread(& esrc[Skeyboard]);
#line 791
  c = (int )eb->buf[0] | ((int )eb->buf[1] << 8);
#line 792
  free((void *)eb);
  }
#line 793
  return (c);
}
}
#line 796 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int ecanread(unsigned long keys ) 
{ 
  int i ;
  XtInputMask tmp ;

  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    i = 0;
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 802
      if (! (i < nsrc)) {
#line 802
        goto while_break___0;
      }
#line 803
      if (keys & (unsigned long )(1 << i)) {
#line 803
        if (esrc[i].head) {
#line 804
          return (1 << i);
        }
      }
#line 802
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 806
    tmp = XtAppPending(app);
    }
#line 806
    if (tmp) {
      {
#line 807
      waitevent();
      }
    } else {
#line 809
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 813 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int ecanmouse(void) 
{ 
  int tmp ;

  {
#line 816
  if (Smouse == -1) {
    {
#line 817
    berror((char *)"mouse events not selected");
    }
  }
  {
#line 818
  tmp = ecanread(1UL);
  }
#line 818
  return (tmp);
}
}
#line 821 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int ecankbd(void) 
{ 
  int tmp ;

  {
#line 824
  if (Skeyboard == -1) {
    {
#line 825
    berror((char *)"keyboard events not selected");
    }
  }
  {
#line 826
  tmp = ecanread(2UL);
  }
#line 826
  return (tmp);
}
}
#line 829 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Ebuf *ebread(Esrc *s ) 
{ 
  Ebuf *eb ;

  {
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! ((unsigned long )s->head == (unsigned long )((Ebuf *)0))) {
#line 834
      goto while_break;
    }
    {
#line 835
    waitevent();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  eb = s->head;
#line 838
  if ((unsigned long )s == (unsigned long )(& esrc[Smouse])) {
    {
#line 839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 839
      if (! eb->next) {
#line 839
        goto while_break___0;
      }
      {
#line 840
      s->head = eb->next;
#line 841
      (s->count) --;
#line 842
      free((void *)eb);
#line 843
      eb = s->head;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 847
  s->head = (s->head)->next;
#line 848
  if ((unsigned long )s->head == (unsigned long )((Ebuf *)0)) {
#line 849
    s->tail = (Ebuf *)0;
#line 850
    s->count = 0;
  } else {
#line 852
    (s->count) --;
  }
#line 853
  return (eb);
}
}
#line 856 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static Ebuf *ebadd(Esrc *s ) 
{ 
  Ebuf *eb ;
  int m ;
  void *tmp ;
  Ebuf *tmp___0 ;

  {
#line 862
  m = (int )sizeof(Ebuf );
#line 863
  if (s->size > 1) {
#line 864
    m += s->size - 1;
  }
  {
#line 865
  tmp = malloc((size_t )m);
#line 865
  eb = (Ebuf *)tmp;
  }
#line 866
  if (eb) {
#line 867
    eb->next = (struct Ebuf *)0;
#line 868
    eb->n = s->size;
#line 869
    if (s->tail) {
#line 870
      (s->tail)->next = eb;
#line 871
      s->tail = eb;
    } else {
#line 873
      tmp___0 = eb;
#line 873
      s->tail = tmp___0;
#line 873
      s->head = tmp___0;
    }
  }
#line 875
  return (eb);
}
}
#line 878 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void berror(char *s ) 
{ 


  {
#line 881
  if (onerr) {
    {
#line 882
    (*onerr)(s);
    }
  } else {
    {
#line 884
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libg error: %s:\n",
            s);
#line 885
    exit(1);
    }
  }
#line 887
  return;
}
}
#line 889 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void bflush(void) 
{ 
  XtInputMask tmp ;

  {
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 892
    tmp = XtAppPending(app);
    }
#line 892
    if (! (tmp & 1UL)) {
#line 892
      goto while_break;
    }
    {
#line 893
    waitevent();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 894
  return;
}
}
#line 896 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
static void waitevent(void) 
{ 
  XtInputMask mask ;

  {
  {
#line 901
  XFlush(_dpy);
#line 903
  mask = XtAppPending(app);
  }
#line 905
  if (mask & 1UL) {
    {
#line 906
    XtAppProcessEvent(app, (XtInputMask )1);
    }
  } else {
    {
#line 908
    XtAppProcessEvent(app, (XtInputMask )15);
    }
  }
#line 909
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int snarfswap(char *s , int n , char **t___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 914
  *t___0 = GwinSelectionSwap(widg, s);
  }
#line 915
  if (*t___0) {
    {
#line 916
    tmp = strlen((char const   *)*t___0);
    }
#line 916
    return ((int )tmp);
  }
#line 917
  return (0);
}
}
#line 920 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
char *select_get(void) 
{ 
  char *tmp ;

  {
  {
#line 923
  tmp = Gwinselect_get(widg);
  }
#line 923
  return (tmp);
}
}
#line 926 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
void select_put(char *s ) 
{ 


  {
  {
#line 929
  Gwinselect_put(widg, s);
  }
#line 930
  return;
}
}
#line 932 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/xtbinit.c"
int scrpix(int *w , int *h ) 
{ 
  Screen *tmp ;
  Screen *tmp___0 ;

  {
#line 934
  if (w) {
    {
#line 935
    tmp = XtScreen(_toplevel);
#line 935
    *w = tmp->width;
    }
  }
#line 936
  if (h) {
    {
#line 937
    tmp___0 = XtScreen(_toplevel);
#line 937
    *h = tmp___0->height;
    }
  }
#line 938
  return (1);
}
}
#line 215 "./../include/libg.h"
void polysegment(Bitmap *d , int n , Point *pp , int v , Fcode f ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 2364 "/usr/include/X11/Xlib.h"
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/polysegment.c"
void polysegment(Bitmap *d , int n , Point *pp , int v , Fcode f ) 
{ 
  XPoint *xp ;
  int i ;
  GC g ;
  void *tmp ;

  {
  {
#line 13
  tmp = calloc((size_t )n, sizeof(XPoint ));
#line 13
  xp = (XPoint *)tmp;
  }
#line 13
  if (! xp) {
    {
#line 14
    berror((char *)"polysegment: could not allocate XPoints");
    }
  }
#line 15
  i = 0;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (i < n)) {
#line 15
      goto while_break;
    }
#line 16
    if (d->flag & 32) {
#line 17
      (xp + i)->x = (short )(pp->x - d->r.min.x);
#line 18
      (xp + i)->y = (short )(pp->y - d->r.min.y);
    } else {
#line 20
      (xp + i)->x = (short )pp->x;
#line 21
      (xp + i)->y = (short )pp->y;
    }
#line 15
    i ++;
#line 15
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  g = _getfillgc(f, d, (unsigned long )v);
#line 24
  XDrawLines(_dpy, (Drawable )d->id, g, xp, n, 0);
#line 25
  free((void *)xp);
  }
#line 26
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *notfilename ;
#line 9
char *notcommand ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static void b2(View *v , Range r , Bool ischord ) ;
#line 10
static void dobutton(View *v , Mouse *orig ) ;
#line 11
static void doscroll(View *v , Mouse *m ) ;
#line 12
static void action(View *v , Mouse *m , Range r , ulong oldbuttons ) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
void domouse(View *v , Mouse *m ) 
{ 
  ulong oldbuttons ;
  Range r ;
  Range tmp ;

  {
#line 21
  if (m->xy.x < (v->r.min.x + 13) + 4) {
#line 22
    if (v->scroll) {
      {
#line 23
      doscroll(v, m);
      }
    } else {
      {
#line 25
      dobutton(v, m);
      }
    }
  } else {
    {
#line 27
    oldbuttons = (ulong )m->buttons;
#line 28
    tmp = vselect(v, m);
#line 28
    r = tmp;
#line 30
    action(v, m, r, oldbuttons);
    }
  }
#line 32
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static void dobutton(View *v , Mouse *orig ) 
{ 
  Mouse m ;
  Tile *tile ;
  Tile *tmp ;
  Point tmp___0 ;
  int tmp___1 ;

  {
  {
#line 41
  tmp = view_tile(v);
#line 41
  tile = tmp;
  }
#line 46
  if ((unsigned long )tile == (unsigned long )wily) {
#line 47
    return;
  }
  {
#line 50
  cursorswitch(& boxcursor);
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    m = emouse();
    }
#line 51
    if (! (m.buttons == orig->buttons)) {
#line 51
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  cursorswitch(cursor);
  }
#line 57
  if (m.buttons) {
#line 58
    return;
  }
  {
#line 60
  tmp___1 = distance(m.xy, orig->xy);
  }
#line 60
  if (tmp___1 < 25) {
    {
#line 61
    tile_grow(tile, orig->buttons);
#line 62
    tmp___0 = buttonpos(tile);
#line 62
    cursorset(tmp___0);
    }
  } else {
    {
#line 64
    tile_move(tile, m.xy);
    }
  }
#line 65
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static char *locals[6]  = {      (char *)"Look",      (char *)"Put",      (char *)"Get",      (char *)"Undo", 
        (char *)"Redo",      (char *)0};
#line 72 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static Bool islocal(char *s ) 
{ 
  char **ptr ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 76
  ptr = locals;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! *ptr) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp = strlen((char const   *)*ptr);
#line 77
    tmp___0 = strncmp((char const   *)s, (char const   *)*ptr, tmp);
    }
#line 77
    if (! tmp___0) {
#line 78
      return ((Bool )1);
    }
#line 76
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return ((Bool )0);
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static void b2(View *v , Range r , Bool ischord ) 
{ 
  char *cmd ;
  char *arg ;
  View *ls ;
  Range rarg ;
  Bool tmp ;
  Data *tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 88
  ls = last_selection;
#line 90
  r = view_expand(v, r, notcommand);
  }
#line 91
  if (! (r.p1 - r.p0)) {
#line 92
    return;
  }
  {
#line 94
  cmd = text_duputf(v->t, r);
  }
#line 96
  if (ischord) {
#line 96
    if (ls) {
#line 96
      if (ls->sel.p1 - ls->sel.p0 < 200UL) {
        {
#line 99
        rarg = view_expand(ls, ls->sel, notfilename);
#line 100
        arg = text_duputf(ls->t, rarg);
#line 103
        tmp = islocal(cmd);
        }
#line 103
        if (! tmp) {
#line 104
          v = ls;
        }
      } else {
#line 106
        arg = (char *)0;
      }
    } else {
#line 106
      arg = (char *)0;
    }
  } else {
#line 106
    arg = (char *)0;
  }
  {
#line 108
  tmp___0 = view_data(v);
#line 108
  tmp___1 = data_sendexec(tmp___0, cmd, arg);
  }
#line 108
  if (! tmp___1) {
    {
#line 109
    run(v, cmd, arg);
    }
  }
  {
#line 111
  free((void *)cmd);
  }
#line 112
  if (arg) {
    {
#line 113
    free((void *)arg);
    }
  }
#line 114
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static void action(View *v , Mouse *m , Range r , ulong oldbuttons ) 
{ 
  enum __anonenum_state_61 state ;

  {
#line 126
  if (oldbuttons & 1UL) {
#line 127
    state = (enum __anonenum_state_61 )3;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! m->buttons) {
#line 129
        goto while_break;
      }
#line 130
      if (m->buttons & 2) {
#line 131
        if ((unsigned int )state & 1U) {
          {
#line 132
          view_cut(v, v->sel);
#line 133
          state = (enum __anonenum_state_61 )2;
          }
        }
      } else
#line 135
      if (m->buttons & 4) {
#line 136
        if ((unsigned int )state & 2U) {
          {
#line 137
          view_paste(v);
#line 138
          state = (enum __anonenum_state_61 )1;
          }
        }
      }
      {
#line 141
      *m = emouse();
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 143
  if (oldbuttons & 2UL) {
#line 144
    if (m->buttons) {
#line 145
      if (m->buttons & 1) {
        {
#line 146
        b2(v, r, (Bool )1);
        }
      }
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 147
        if (! m->buttons) {
#line 147
          goto while_break___0;
        }
        {
#line 148
        *m = emouse();
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 150
      b2(v, r, (Bool )0);
      }
    }
  } else
#line 154
  if (m->buttons) {
    {
#line 155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 155
      if (! m->buttons) {
#line 155
        goto while_break___1;
      }
      {
#line 156
      *m = emouse();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 158
    b3(v, r);
    }
  }
#line 160
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/mouse.c"
static void doscroll(View *v , Mouse *m ) 
{ 
  ulong buttons ;
  ulong timer ;
  ulong type ;
  int delay ;
  Bool firstmouse ;
  Event e ;

  {
  {
#line 172
  delay = 5;
#line 179
  buttons = (ulong )m->buttons;
#line 181
  type = (ulong )1;
#line 182
  firstmouse = (Bool )1;
#line 183
  e.mouse = *m;
#line 184
  m = & e.mouse;
#line 187
  timer = etimer(0UL, 100L);
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (type == 1UL) {
#line 192
      if (firstmouse) {
        {
#line 193
        firstmouse = (Bool )0;
#line 194
        view_scroll(v, m);
        }
      }
    } else
#line 197
    if (delay) {
#line 198
      delay --;
    } else {
      {
#line 200
      view_scroll(v, m);
      }
    }
    {
#line 202
    type = eread(1UL | timer, & e);
    }
#line 188
    if (type == 1UL) {
#line 188
      if ((ulong )m->buttons != buttons) {
#line 188
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  estoptimer(timer);
  }
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! m->buttons) {
#line 208
      goto while_break___0;
    }
    {
#line 209
    eread(1UL, & e);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
samRangeset sel  ;
#line 118 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/sam.h"
Inst *startinst  ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
String___0 lastregexp  ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Inst program[1024]  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Inst *progp  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Inst *bstartinst  ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Ilist *tl  ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Ilist *nl  ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Ilist list[2][128]  ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
static samRangeset sempty  ;
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Node andstack[20]  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Node *andp  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int atorstack[20]  ;
#line 102 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int *atorp  ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int lastwasand  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int cursubid  ;
#line 105 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int subidstack[20]  ;
#line 106 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int *subidp  ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int backwards  ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int nbra  ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Rune *exprp  ;
#line 111 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int nclass  ;
#line 112 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int Nclass  ;
#line 113 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Rune **class  ;
#line 114 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int negateclass  ;
#line 116
void addinst(Ilist *l , Inst *inst , samRangeset *sep ) ;
#line 117
void newmatch(samRangeset *sp ) ;
#line 118
void bnewmatch(samRangeset *sp ) ;
#line 119
void pushand(Inst *f , Inst *l ) ;
#line 120
void pushator(int v ) ;
#line 121
Node *popand(int op ) ;
#line 122
int popator(void) ;
#line 123
void startlex(Rune *s ) ;
#line 124
int lex(void) ;
#line 125
void operator(int v ) ;
#line 126
void operand(int v ) ;
#line 127
void evaluntil(int pri ) ;
#line 128
void optimize(Inst *start ) ;
#line 129
void bldcclass(void) ;
#line 131 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void regerror(Err e ) 
{ 


  {
  {
#line 134
  Strzero(& lastregexp);
#line 135
  samerror(e);
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void regerror_c(Err e , int c ) 
{ 


  {
  {
#line 141
  Strzero(& lastregexp);
#line 142
  error_c(e, c);
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Inst *newinst(int v ) 
{ 
  Inst *tmp ;

  {
#line 148
  if ((unsigned long )progp >= (unsigned long )(& program[1024])) {
    {
#line 149
    regerror((Err )0);
    }
  }
#line 150
  progp->type = (long )v;
#line 151
  progp->l.lleft = (struct Inst *)0;
#line 152
  progp->r.rright = (struct Inst *)0;
#line 153
  tmp = progp;
#line 153
  progp ++;
#line 153
  return (tmp);
}
}
#line 156 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Inst *realcompile(Rune *s ) 
{ 
  int token ;

  {
  {
#line 161
  startlex(s);
#line 162
  atorp = atorstack;
#line 163
  andp = andstack;
#line 164
  subidp = subidstack;
#line 165
  cursubid = 0;
#line 166
  lastwasand = 0;
#line 168
  pushator(65535);
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    token = lex();
    }
#line 169
    if (! (token != 131191)) {
#line 169
      goto while_break;
    }
#line 170
    if ((token & 65536) == 65536) {
      {
#line 171
      operator(token);
      }
    } else {
      {
#line 173
      operand(token);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  evaluntil(65536);
#line 178
  operand(131191);
#line 179
  evaluntil(65536);
  }
#line 180
  if (nbra) {
    {
#line 181
    regerror((Err )1);
    }
  }
#line 182
  andp --;
#line 183
  return (andp->first);
}
}
#line 186 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void compile(String___0 *s ) 
{ 
  int i ;
  Inst *oprogp ;
  int tmp ;

  {
  {
#line 192
  tmp = Strcmp(s, & lastregexp);
  }
#line 192
  if (tmp == 0) {
#line 193
    return;
  }
#line 194
  i = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < nclass)) {
#line 194
      goto while_break;
    }
    {
#line 195
    free((void *)*(class + i));
#line 194
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  nclass = 0;
#line 197
  progp = program;
#line 198
  backwards = 0;
#line 199
  startinst = realcompile(s->s);
#line 200
  optimize(program);
#line 201
  oprogp = progp;
#line 202
  backwards = 1;
#line 203
  bstartinst = realcompile(s->s);
#line 204
  optimize(oprogp);
#line 205
  Strduplstr(& lastregexp, s);
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void operand(int v ) 
{ 
  Inst *i ;

  {
#line 212
  if (lastwasand) {
    {
#line 213
    operator(65540);
    }
  }
  {
#line 214
  i = newinst(v);
  }
#line 215
  if (v == 131076) {
#line 216
    if (negateclass) {
#line 217
      i->type = 131077L;
    }
#line 218
    i->r.class = nclass - 1;
  }
  {
#line 220
  pushand(i, i);
#line 221
  lastwasand = 1;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void operator(int v ) 
{ 


  {
#line 227
  if (v == 65537) {
#line 227
    nbra --;
#line 227
    if (nbra < 0) {
      {
#line 228
      regerror((Err )2);
      }
    }
  }
#line 229
  if (v == 65538) {
#line 234
    cursubid ++;
#line 235
    nbra ++;
#line 236
    if (lastwasand) {
      {
#line 237
      operator(65540);
      }
    }
  } else {
    {
#line 239
    evaluntil(v);
    }
  }
#line 240
  if (v != 65537) {
    {
#line 241
    pushator(v);
    }
  }
#line 242
  lastwasand = 0;
#line 243
  if (v == 65541) {
#line 244
    lastwasand = 1;
  } else
#line 243
  if (v == 65543) {
#line 244
    lastwasand = 1;
  } else
#line 243
  if (v == 65542) {
#line 244
    lastwasand = 1;
  } else
#line 243
  if (v == 65537) {
#line 244
    lastwasand = 1;
  }
#line 245
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void cant(char *s ) 
{ 
  char buf___3[100] ;

  {
  {
#line 252
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"regexp: can\'t happen: %s",
          s);
#line 253
  panic(buf___3);
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void pushand(Inst *f , Inst *l ) 
{ 


  {
#line 259
  if ((unsigned long )andp >= (unsigned long )(& andstack[20])) {
    {
#line 260
    cant((char *)"operand stack overflow");
    }
  }
#line 261
  andp->first = f;
#line 262
  andp->last = l;
#line 263
  andp ++;
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void pushator(int v ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 269
  if ((unsigned long )atorp >= (unsigned long )(& atorstack[20])) {
    {
#line 270
    cant((char *)"operator stack overflow");
    }
  }
#line 271
  tmp = atorp;
#line 271
  atorp ++;
#line 271
  *tmp = v;
#line 272
  if (cursubid >= 10) {
#line 273
    tmp___0 = subidp;
#line 273
    subidp ++;
#line 273
    *tmp___0 = -1;
  } else {
#line 275
    tmp___1 = subidp;
#line 275
    subidp ++;
#line 275
    *tmp___1 = cursubid;
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
Node *popand(int op ) 
{ 


  {
#line 281
  if ((unsigned long )andp <= (unsigned long )(& andstack[0])) {
#line 282
    if (op) {
      {
#line 283
      regerror_c((Err )3, op);
      }
    } else {
      {
#line 285
      regerror((Err )4);
      }
    }
  }
#line 286
  andp --;
#line 286
  return (andp);
}
}
#line 289 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int popator(void) 
{ 


  {
#line 292
  if ((unsigned long )atorp <= (unsigned long )(& atorstack[0])) {
    {
#line 293
    cant((char *)"operator stack underflow");
    }
  }
#line 294
  subidp --;
#line 295
  atorp --;
#line 295
  return (*atorp);
}
}
#line 298 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void evaluntil(int pri ) 
{ 
  Node *op1 ;
  Node *op2 ;
  Node *v ;
  Inst *inst1 ;
  Inst *inst2 ;
  int tmp ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (pri == 65537)) {
#line 304
      if (! (*(atorp + -1) >= pri)) {
#line 304
        goto while_break;
      }
    }
    {
#line 305
    tmp = popator();
    }
    {
#line 306
    if (tmp == 65538) {
#line 306
      goto case_65538;
    }
#line 319
    if (tmp == 65539) {
#line 319
      goto case_65539;
    }
#line 330
    if (tmp == 65540) {
#line 330
      goto case_65540;
    }
#line 338
    if (tmp == 65541) {
#line 338
      goto case_65541;
    }
#line 345
    if (tmp == 65542) {
#line 345
      goto case_65542;
    }
#line 352
    if (tmp == 65543) {
#line 352
      goto case_65543;
    }
#line 316
    goto switch_default;
    case_65538: /* CIL Label */ 
    {
#line 307
    op1 = popand('(');
#line 308
    inst2 = newinst(65537);
#line 309
    inst2->r.rsubid = *subidp;
#line 310
    (op1->last)->l.lnext = inst2;
#line 311
    inst1 = newinst(65538);
#line 312
    inst1->r.rsubid = *subidp;
#line 313
    inst1->l.lnext = op1->first;
#line 314
    pushand(inst1, inst2);
    }
#line 315
    return;
    switch_default: /* CIL Label */ 
    {
#line 317
    panic((char *)"unknown regexp operator");
    }
#line 318
    goto switch_break;
    case_65539: /* CIL Label */ 
    {
#line 320
    op2 = popand('|');
#line 321
    op1 = popand('|');
#line 322
    inst2 = newinst(131073);
#line 323
    (op2->last)->l.lnext = inst2;
#line 324
    (op1->last)->l.lnext = inst2;
#line 325
    inst1 = newinst(65539);
#line 326
    inst1->r.rright = op1->first;
#line 327
    inst1->l.lleft = op2->first;
#line 328
    pushand(inst1, inst2);
    }
#line 329
    goto switch_break;
    case_65540: /* CIL Label */ 
    {
#line 331
    op2 = popand(0);
#line 332
    op1 = popand(0);
    }
#line 333
    if (backwards) {
#line 333
      if ((op2->first)->type != 131191L) {
#line 334
        v = op1;
#line 334
        op1 = op2;
#line 334
        op2 = v;
      }
    }
    {
#line 335
    (op1->last)->l.lnext = op2->first;
#line 336
    pushand(op1->first, op2->last);
    }
#line 337
    goto switch_break;
    case_65541: /* CIL Label */ 
    {
#line 339
    op2 = popand('*');
#line 340
    inst1 = newinst(65539);
#line 341
    (op2->last)->l.lnext = inst1;
#line 342
    inst1->r.rright = op2->first;
#line 343
    pushand(inst1, inst1);
    }
#line 344
    goto switch_break;
    case_65542: /* CIL Label */ 
    {
#line 346
    op2 = popand('+');
#line 347
    inst1 = newinst(65539);
#line 348
    (op2->last)->l.lnext = inst1;
#line 349
    inst1->r.rright = op2->first;
#line 350
    pushand(op2->first, inst1);
    }
#line 351
    goto switch_break;
    case_65543: /* CIL Label */ 
    {
#line 353
    op2 = popand('?');
#line 354
    inst1 = newinst(65539);
#line 355
    inst2 = newinst(131073);
#line 356
    inst1->l.lleft = inst2;
#line 357
    inst1->r.rright = op2->first;
#line 358
    (op2->last)->l.lnext = inst2;
#line 359
    pushand(inst1, inst2);
    }
#line 360
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void optimize(Inst *start ) 
{ 
  Inst *inst ;
  Inst *target ;

  {
#line 371
  inst = start;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (inst->type != 131191L)) {
#line 371
      goto while_break;
    }
#line 372
    target = inst->l.lnext;
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 373
      if (! (target->type == 131073L)) {
#line 373
        goto while_break___0;
      }
#line 374
      target = target->l.lnext;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 375
    inst->l.lnext = target;
#line 371
    inst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void startlex(Rune *s ) 
{ 


  {
#line 407
  exprp = s;
#line 408
  nbra = 0;
#line 409
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int lex(void) 
{ 
  int c ;
  Rune *tmp ;
  Rune *tmp___0 ;

  {
#line 414
  tmp = exprp;
#line 414
  exprp ++;
#line 414
  c = (int )*tmp;
  {
#line 417
  if (c == 92) {
#line 417
    goto case_92;
  }
#line 422
  if (c == 0) {
#line 422
    goto case_0;
  }
#line 426
  if (c == 42) {
#line 426
    goto case_42;
  }
#line 429
  if (c == 63) {
#line 429
    goto case_63;
  }
#line 432
  if (c == 43) {
#line 432
    goto case_43;
  }
#line 435
  if (c == 124) {
#line 435
    goto case_124;
  }
#line 438
  if (c == 46) {
#line 438
    goto case_46;
  }
#line 441
  if (c == 40) {
#line 441
    goto case_40;
  }
#line 444
  if (c == 41) {
#line 444
    goto case_41;
  }
#line 447
  if (c == 94) {
#line 447
    goto case_94;
  }
#line 450
  if (c == 36) {
#line 450
    goto case_36;
  }
#line 453
  if (c == 91) {
#line 453
    goto case_91;
  }
#line 416
  goto switch_break;
  case_92: /* CIL Label */ 
#line 418
  if (*exprp) {
#line 419
    tmp___0 = exprp;
#line 419
    exprp ++;
#line 419
    c = (int )*tmp___0;
#line 419
    if (c == 110) {
#line 420
      c = '\n';
    }
  }
#line 421
  goto switch_break;
  case_0: /* CIL Label */ 
#line 423
  c = 131191;
#line 424
  exprp --;
#line 425
  goto switch_break;
  case_42: /* CIL Label */ 
#line 427
  c = 65541;
#line 428
  goto switch_break;
  case_63: /* CIL Label */ 
#line 430
  c = 65543;
#line 431
  goto switch_break;
  case_43: /* CIL Label */ 
#line 433
  c = 65542;
#line 434
  goto switch_break;
  case_124: /* CIL Label */ 
#line 436
  c = 65539;
#line 437
  goto switch_break;
  case_46: /* CIL Label */ 
#line 439
  c = 131072;
#line 440
  goto switch_break;
  case_40: /* CIL Label */ 
#line 442
  c = 65538;
#line 443
  goto switch_break;
  case_41: /* CIL Label */ 
#line 445
  c = 65537;
#line 446
  goto switch_break;
  case_94: /* CIL Label */ 
#line 448
  c = 131074;
#line 449
  goto switch_break;
  case_36: /* CIL Label */ 
#line 451
  c = 131075;
#line 452
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 454
  c = 131076;
#line 455
  bldcclass();
  }
#line 456
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 458
  return (c);
}
}
#line 461 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
long nextrec(void) 
{ 
  Rune *tmp ;
  Rune *tmp___0 ;

  {
#line 463
  if ((int )*(exprp + 0) == 0) {
    {
#line 464
    regerror((Err )5);
    }
  } else
#line 463
  if ((int )*(exprp + 0) == 92) {
#line 463
    if ((int )*(exprp + 1) == 0) {
      {
#line 464
      regerror((Err )5);
      }
    }
  }
#line 465
  if ((int )*(exprp + 0) == 92) {
#line 466
    exprp ++;
#line 467
    if ((int )*exprp == 110) {
#line 468
      exprp ++;
#line 469
      return ((long )'\n');
    }
#line 471
    tmp = exprp;
#line 471
    exprp ++;
#line 471
    return ((long )((int )*tmp | 65536));
  }
#line 473
  tmp___0 = exprp;
#line 473
  exprp ++;
#line 473
  return ((long )*tmp___0);
}
}
#line 476 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void bldcclass(void) 
{ 
  long c1 ;
  long c2 ;
  long n ;
  long na ;
  Rune *classp ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 482
  tmp = salloc(20);
#line 482
  classp = (Rune *)tmp;
#line 483
  n = 0L;
#line 484
  na = 10L;
  }
#line 486
  if ((int )*exprp == 94) {
#line 487
    tmp___0 = n;
#line 487
    n ++;
#line 487
    *(classp + tmp___0) = (Rune )'\n';
#line 488
    negateclass = 1;
#line 489
    exprp ++;
  } else {
#line 491
    negateclass = 0;
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 492
    c1 = nextrec();
    }
#line 492
    if (! (c1 != 93L)) {
#line 492
      goto while_break;
    }
#line 493
    if (c1 == 45L) {
      Error: 
      {
#line 495
      free((void *)classp);
#line 496
      regerror((Err )5);
      }
    }
#line 498
    if (n + 4L >= na) {
      {
#line 499
      na += 10L;
#line 500
      tmp___1 = srealloc((void *)classp, (int )(na * 2L));
#line 500
      classp = (Rune *)tmp___1;
      }
    }
#line 502
    if ((int )*exprp == 45) {
      {
#line 503
      exprp ++;
#line 504
      c2 = nextrec();
      }
#line 504
      if (c2 == 93L) {
#line 505
        goto Error;
      }
#line 506
      *(classp + n) = (Rune )65535;
#line 507
      *(classp + (n + 1L)) = (Rune )c1;
#line 508
      *(classp + (n + 2L)) = (Rune )c2;
#line 509
      n += 3L;
    } else {
#line 511
      tmp___2 = n;
#line 511
      n ++;
#line 511
      *(classp + tmp___2) = (Rune )c1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  *(classp + n) = (Rune )0;
#line 514
  if (nclass == Nclass) {
    {
#line 515
    Nclass += 10;
#line 516
    tmp___3 = srealloc((void *)class, (int )((unsigned long )Nclass * sizeof(Rune *)));
#line 516
    class = (Rune **)tmp___3;
    }
  }
#line 518
  tmp___4 = nclass;
#line 518
  nclass ++;
#line 518
  *(class + tmp___4) = classp;
#line 519
  return;
}
}
#line 521 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int classmatch(int classno , int c , int negate ) 
{ 
  Rune *w ;
  Rune *tmp ;

  {
#line 526
  w = *(class + classno);
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! *w) {
#line 527
      goto while_break;
    }
#line 528
    if ((int )*w == 65535) {
#line 529
      if ((int )*(w + 1) <= c) {
#line 529
        if (c <= (int )*(w + 2)) {
#line 530
          return (! negate);
        }
      }
#line 531
      w += 3;
    } else {
#line 532
      tmp = w;
#line 532
      w ++;
#line 532
      if ((int )*tmp == c) {
#line 533
        return (! negate);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return (negate);
}
}
#line 543 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void addinst(Ilist *l , Inst *inst , samRangeset *sep ) 
{ 
  Ilist *w ;

  {
#line 548
  w = l;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! w->inst) {
#line 548
      goto while_break;
    }
#line 549
    if ((unsigned long )w->inst == (unsigned long )inst) {
#line 550
      if (sep->w[0].p1 < w->se.w[0].p1) {
#line 551
        w->se = *sep;
      }
#line 552
      return;
    }
#line 548
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  w->inst = inst;
#line 556
  w->se = *sep;
#line 557
  (w + 1)->inst = (Inst *)0;
#line 558
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int execute(File *f , Posn startp , Posn eof ) 
{ 
  int flag ;
  Inst *inst ;
  Ilist *tlp ;
  Posn w ;
  int nnl ;
  int ntl ;
  int c ;
  int wrapped ;
  int startchar ;
  long tmp ;
  ulong tmp___0 ;
  ulong tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Rune c2 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 563
  flag = 0;
#line 566
  w = startp;
#line 567
  nnl = 0;
#line 569
  wrapped = 0;
#line 570
  if (startinst->type < 65536L) {
#line 570
    tmp = startinst->type;
  } else {
#line 570
    tmp = 0L;
  }
#line 570
  startchar = (int )tmp;
#line 572
  list[1][0].inst = (Inst *)0;
#line 572
  list[0][0].inst = list[1][0].inst;
#line 573
  sel.w[0].p1 = (Posn )-1;
#line 574
  (f->t)->pos = (ulong )startp;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
    doloop: 
#line 578
    if ((f->t)->pos < (f->t)->gap.p0) {
#line 578
      tmp___0 = (f->t)->pos;
#line 578
      ((f->t)->pos) ++;
#line 578
      c = (int )*((f->t)->text + tmp___0);
    } else {
#line 578
      if ((f->t)->pos < (f->t)->length) {
#line 578
        tmp___1 = (f->t)->pos;
#line 578
        ((f->t)->pos) ++;
#line 578
        tmp___2 = (int )*((f->t)->text + (tmp___1 + ((f->t)->gap.p1 - (f->t)->gap.p0)));
      } else {
#line 578
        tmp___2 = -1;
      }
#line 578
      c = tmp___2;
    }
#line 579
    if (w >= eof) {
#line 579
      goto _L___1;
    } else
#line 579
    if (c < 0) {
      _L___1: /* CIL Label */ 
#line 580
      tmp___3 = wrapped;
#line 580
      wrapped ++;
      {
#line 582
      if (tmp___3 == 2) {
#line 582
        goto case_2;
      }
#line 582
      if (tmp___3 == 0) {
#line 582
        goto case_2;
      }
#line 584
      if (tmp___3 == 1) {
#line 584
        goto case_1;
      }
#line 591
      goto switch_default;
      case_2: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 583
      goto switch_break;
      case_1: /* CIL Label */ 
#line 585
      if (sel.w[0].p1 >= 0L) {
#line 586
        goto Return;
      } else
#line 585
      if (eof != 2147483647L) {
#line 586
        goto Return;
      }
#line 587
      list[1][0].inst = (Inst *)0;
#line 587
      list[0][0].inst = list[1][0].inst;
#line 588
      (f->t)->pos = (ulong )((Posn )0);
#line 589
      w = (Posn )0;
#line 590
      goto doloop;
      switch_default: /* CIL Label */ 
#line 592
      goto Return;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 594
    if (wrapped) {
#line 594
      if (w >= startp) {
#line 594
        goto _L;
      } else {
#line 594
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 594
    if (sel.w[0].p1 > 0L) {
      _L: /* CIL Label */ 
#line 594
      if (nnl == 0) {
#line 595
        goto while_break;
      }
    }
#line 597
    if (startchar) {
#line 597
      if (nnl == 0) {
#line 597
        if (c != startchar) {
#line 598
          goto __Cont;
        }
      }
    }
#line 599
    tl = list[flag];
#line 600
    flag ^= 1;
#line 600
    nl = list[flag];
#line 601
    nl->inst = (Inst *)0;
#line 602
    ntl = nnl;
#line 603
    nnl = 0;
#line 604
    if (sel.w[0].p1 < 0L) {
#line 604
      if (! wrapped) {
#line 604
        goto _L___2;
      } else
#line 604
      if (w < startp) {
#line 604
        goto _L___2;
      } else
#line 604
      if (startp == eof) {
        _L___2: /* CIL Label */ 
#line 606
        ntl ++;
#line 606
        if (ntl >= 128) {
          Overflow: 
          {
#line 608
          samerror((Err )6);
          }
        }
        {
#line 609
        sempty.w[0].p1 = w;
#line 610
        addinst(tl, startinst, & sempty);
        }
      }
    }
#line 613
    tlp = tl;
    {
#line 613
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 613
      inst = tlp->inst;
#line 613
      if (! inst) {
#line 613
        goto while_break___0;
      }
      Switchstmt: 
      {
#line 624
      if (inst->type == 65538L) {
#line 624
        goto case_65538;
      }
#line 629
      if (inst->type == 65537L) {
#line 629
        goto case_65537;
      }
#line 634
      if (inst->type == 131072L) {
#line 634
        goto case_131072;
      }
#line 638
      if (inst->type == 131074L) {
#line 638
        goto case_131074;
      }
#line 650
      if (inst->type == 131075L) {
#line 650
        goto case_131075;
      }
#line 654
      if (inst->type == 131076L) {
#line 654
        goto case_131076;
      }
#line 658
      if (inst->type == 131077L) {
#line 658
        goto case_131077;
      }
#line 662
      if (inst->type == 65539L) {
#line 662
        goto case_65539;
      }
#line 670
      if (inst->type == 131191L) {
#line 670
        goto case_131191;
      }
#line 616
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
#line 617
      if (inst->type == (long )c) {
        Addinst: 
#line 619
        nnl ++;
#line 619
        if (nnl >= 128) {
#line 620
          goto Overflow;
        }
        {
#line 621
        addinst(nl, inst->l.lnext, & tlp->se);
        }
      }
#line 623
      goto switch_break___0;
      case_65538: /* CIL Label */ 
#line 625
      if (inst->r.rsubid >= 0) {
#line 626
        tlp->se.w[inst->r.rsubid].p1 = w;
      }
#line 627
      inst = inst->l.lnext;
#line 628
      goto Switchstmt;
      case_65537: /* CIL Label */ 
#line 630
      if (inst->r.rsubid >= 0) {
#line 631
        tlp->se.w[inst->r.rsubid].w2 = w;
      }
#line 632
      inst = inst->l.lnext;
#line 633
      goto Switchstmt;
      case_131072: /* CIL Label */ 
#line 635
      if (c != 10) {
#line 636
        goto Addinst;
      }
#line 637
      goto switch_break___0;
      case_131074: /* CIL Label */ 
#line 639
      if (w == 0L) {
        Step: 
#line 641
        inst = inst->l.lnext;
#line 642
        goto Switchstmt;
      }
      {
#line 646
      tmp___4 = Tchars(f->t, & c2, (ulong )(w - 1L), (ulong )w);
      }
#line 646
      if (tmp___4 == 1L) {
#line 646
        if ((int )c2 == 10) {
#line 647
          goto Step;
        }
      }
#line 649
      goto switch_break___0;
      case_131075: /* CIL Label */ 
#line 651
      if (c == 10) {
#line 652
        goto Step;
      }
#line 653
      goto switch_break___0;
      case_131076: /* CIL Label */ 
#line 655
      if (c >= 0) {
        {
#line 655
        tmp___5 = classmatch(inst->r.class, c, 0);
        }
#line 655
        if (tmp___5) {
#line 656
          goto Addinst;
        }
      }
#line 657
      goto switch_break___0;
      case_131077: /* CIL Label */ 
#line 659
      if (c >= 0) {
        {
#line 659
        tmp___6 = classmatch(inst->r.class, c, 1);
        }
#line 659
        if (tmp___6) {
#line 660
          goto Addinst;
        }
      }
#line 661
      goto switch_break___0;
      case_65539: /* CIL Label */ 
#line 664
      ntl ++;
#line 664
      if (ntl >= 128) {
#line 665
        goto Overflow;
      }
      {
#line 666
      addinst(tlp, inst->r.rright, & tlp->se);
#line 668
      inst = inst->l.lleft;
      }
#line 669
      goto Switchstmt;
      case_131191: /* CIL Label */ 
      {
#line 671
      tlp->se.w[0].w2 = w;
#line 672
      newmatch(& tlp->se);
      }
#line 673
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 613
      tlp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 576
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
  Return: 
#line 678
  return (sel.w[0].p1 >= 0L);
}
}
#line 681 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void newmatch(samRangeset *sp ) 
{ 
  int i ;

  {
#line 686
  if (sel.w[0].p1 < 0L) {
#line 686
    goto _L;
  } else
#line 686
  if (sp->w[0].p1 < sel.w[0].p1) {
#line 686
    goto _L;
  } else
#line 686
  if (sp->w[0].p1 == sel.w[0].p1) {
#line 686
    if (sp->w[0].w2 > sel.w[0].w2) {
      _L: /* CIL Label */ 
#line 688
      i = 0;
      {
#line 688
      while (1) {
        while_continue: /* CIL Label */ ;
#line 688
        if (! (i < 10)) {
#line 688
          goto while_break;
        }
#line 689
        sel.w[i] = sp->w[i];
#line 688
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 690
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
int bexecute(File *f , Posn startp ) 
{ 
  int flag ;
  Inst *inst ;
  Ilist *tlp ;
  Posn w ;
  int nnl ;
  int ntl ;
  int c ;
  int wrapped ;
  int startchar ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Rune c2 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 695
  flag = 0;
#line 698
  w = startp;
#line 699
  nnl = 0;
#line 701
  wrapped = 0;
#line 702
  if (bstartinst->type < 65536L) {
#line 702
    tmp = bstartinst->type;
  } else {
#line 702
    tmp = 0L;
  }
#line 702
  startchar = (int )tmp;
#line 704
  list[1][0].inst = (Inst *)0;
#line 704
  list[0][0].inst = list[1][0].inst;
#line 705
  sel.w[0].p1 = (Posn )-1;
#line 706
  (f->t)->pos = (ulong )startp;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
    doloop: 
#line 710
    if ((f->t)->pos > (f->t)->gap.p0) {
#line 710
      ((f->t)->pos) --;
#line 710
      c = (int )*((f->t)->text + ((f->t)->pos + ((f->t)->gap.p1 - (f->t)->gap.p0)));
    } else {
#line 710
      if ((f->t)->pos) {
#line 710
        ((f->t)->pos) --;
#line 710
        tmp___1 = (int )*((f->t)->text + (f->t)->pos);
      } else {
#line 710
        tmp___1 = -1;
      }
#line 710
      c = tmp___1;
    }
#line 710
    if (c == -1) {
#line 711
      tmp___0 = wrapped;
#line 711
      wrapped ++;
      {
#line 713
      if (tmp___0 == 2) {
#line 713
        goto case_2;
      }
#line 713
      if (tmp___0 == 0) {
#line 713
        goto case_2;
      }
#line 715
      if (tmp___0 == 1) {
#line 715
        goto case_1;
      }
#line 717
      if (tmp___0 == 3) {
#line 717
        goto case_3;
      }
#line 723
      goto switch_default;
      case_2: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 714
      goto switch_break;
      case_1: /* CIL Label */ 
#line 716
      if (sel.w[0].p1 >= 0L) {
        case_3: /* CIL Label */ 
#line 718
        goto Return;
      }
#line 719
      list[1][0].inst = (Inst *)0;
#line 719
      list[0][0].inst = list[1][0].inst;
#line 720
      (f->t)->pos = (ulong )f->nrunes;
#line 721
      w = f->nrunes;
#line 722
      goto doloop;
      switch_default: /* CIL Label */ 
#line 724
      goto Return;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 726
    if (wrapped) {
#line 726
      if (w <= startp) {
#line 726
        goto _L;
      } else {
#line 726
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 726
    if (sel.w[0].p1 > 0L) {
      _L: /* CIL Label */ 
#line 726
      if (nnl == 0) {
#line 727
        goto while_break;
      }
    }
#line 729
    if (startchar) {
#line 729
      if (nnl == 0) {
#line 729
        if (c != startchar) {
#line 730
          goto __Cont;
        }
      }
    }
#line 731
    tl = list[flag];
#line 732
    flag ^= 1;
#line 732
    nl = list[flag];
#line 733
    nl->inst = (Inst *)0;
#line 734
    ntl = nnl;
#line 735
    nnl = 0;
#line 736
    if (sel.w[0].p1 < 0L) {
#line 736
      if (! wrapped) {
#line 736
        goto _L___1;
      } else
#line 736
      if (w > startp) {
        _L___1: /* CIL Label */ 
#line 738
        ntl ++;
#line 738
        if (ntl >= 128) {
          Overflow: 
          {
#line 740
          samerror((Err )6);
          }
        }
        {
#line 742
        sempty.w[0].p1 = - w;
#line 743
        addinst(tl, bstartinst, & sempty);
        }
      }
    }
#line 746
    tlp = tl;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 746
      inst = tlp->inst;
#line 746
      if (! inst) {
#line 746
        goto while_break___0;
      }
      Switchstmt: 
      {
#line 757
      if (inst->type == 65538L) {
#line 757
        goto case_65538;
      }
#line 762
      if (inst->type == 65537L) {
#line 762
        goto case_65537;
      }
#line 767
      if (inst->type == 131072L) {
#line 767
        goto case_131072;
      }
#line 771
      if (inst->type == 131074L) {
#line 771
        goto case_131074;
      }
#line 778
      if (inst->type == 131075L) {
#line 778
        goto case_131075;
      }
#line 785
      if (inst->type == 131076L) {
#line 785
        goto case_131076;
      }
#line 789
      if (inst->type == 131077L) {
#line 789
        goto case_131077;
      }
#line 793
      if (inst->type == 65539L) {
#line 793
        goto case_65539;
      }
#line 801
      if (inst->type == 131191L) {
#line 801
        goto case_131191;
      }
#line 749
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
#line 750
      if (inst->type == (long )c) {
        Addinst: 
#line 752
        nnl ++;
#line 752
        if (nnl >= 128) {
#line 753
          goto Overflow;
        }
        {
#line 754
        addinst(nl, inst->l.lnext, & tlp->se);
        }
      }
#line 756
      goto switch_break___0;
      case_65538: /* CIL Label */ 
#line 758
      if (inst->r.rsubid >= 0) {
#line 759
        tlp->se.w[inst->r.rsubid].p1 = w;
      }
#line 760
      inst = inst->l.lnext;
#line 761
      goto Switchstmt;
      case_65537: /* CIL Label */ 
#line 763
      if (inst->r.rsubid >= 0) {
#line 764
        tlp->se.w[inst->r.rsubid].w2 = w;
      }
#line 765
      inst = inst->l.lnext;
#line 766
      goto Switchstmt;
      case_131072: /* CIL Label */ 
#line 768
      if (c != 10) {
#line 769
        goto Addinst;
      }
#line 770
      goto switch_break___0;
      case_131074: /* CIL Label */ 
#line 772
      if (c == 10) {
#line 772
        goto Step;
      } else
#line 772
      if (w == 0L) {
        Step: 
#line 774
        inst = inst->l.lnext;
#line 775
        goto Switchstmt;
      }
#line 777
      goto switch_break___0;
      case_131075: /* CIL Label */ 
#line 779
      if (w < f->nrunes - 1L) {
        {
#line 781
        tmp___2 = Tchars(f->t, & c2, (ulong )w, (ulong )(w + 1L));
        }
#line 781
        if (tmp___2 == 1L) {
#line 781
          if ((int )c2 == 10) {
#line 782
            goto Step;
          }
        }
      }
#line 784
      goto switch_break___0;
      case_131076: /* CIL Label */ 
#line 786
      if (c >= 0) {
        {
#line 786
        tmp___3 = classmatch(inst->r.class, c, 0);
        }
#line 786
        if (tmp___3) {
#line 787
          goto Addinst;
        }
      }
#line 788
      goto switch_break___0;
      case_131077: /* CIL Label */ 
#line 790
      if (c >= 0) {
        {
#line 790
        tmp___4 = classmatch(inst->r.class, c, 1);
        }
#line 790
        if (tmp___4) {
#line 791
          goto Addinst;
        }
      }
#line 792
      goto switch_break___0;
      case_65539: /* CIL Label */ 
#line 795
      ntl ++;
#line 795
      if (ntl >= 128) {
#line 796
        goto Overflow;
      }
      {
#line 797
      addinst(tlp, inst->r.rright, & tlp->se);
#line 799
      inst = inst->l.lleft;
      }
#line 800
      goto Switchstmt;
      case_131191: /* CIL Label */ 
      {
#line 802
      tlp->se.w[0].p1 = - tlp->se.w[0].p1;
#line 803
      tlp->se.w[0].w2 = w;
#line 804
      bnewmatch(& tlp->se);
      }
#line 805
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 746
      tlp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 708
    w --;
  }
  while_break: /* CIL Label */ ;
  }
  Return: 
#line 810
  return (sel.w[0].p1 >= 0L);
}
}
#line 813 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/regexp.c"
void bnewmatch(samRangeset *sp ) 
{ 
  int i ;

  {
#line 817
  if (sel.w[0].p1 < 0L) {
#line 817
    goto _L;
  } else
#line 817
  if (sp->w[0].p1 > sel.w[0].w2) {
#line 817
    goto _L;
  } else
#line 817
  if (sp->w[0].p1 == sel.w[0].w2) {
#line 817
    if (sp->w[0].w2 < sel.w[0].p1) {
      _L: /* CIL Label */ 
#line 818
      i = 0;
      {
#line 818
      while (1) {
        while_continue: /* CIL Label */ ;
#line 818
        if (! (i < 10)) {
#line 818
          goto while_break;
        }
#line 819
        sel.w[i].p1 = sp->w[i].w2;
#line 820
        sel.w[i].w2 = sp->w[i].p1;
#line 818
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 822
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
static ushort get2(uchar *p ) ;
#line 35
static ulong get4(uchar *p ) ;
#line 36
static void put2(uchar *p , ushort n ) ;
#line 37
static void put4(uchar *p , ulong n ) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
void msg_fill(Msg *m , Mtype t___0 , Id w , Range r , ushort flag , char *s ) 
{ 


  {
#line 41
  m->t = t___0;
#line 42
  m->w = w;
#line 43
  m->r = r;
#line 44
  m->flag = flag;
#line 45
  m->s = s;
#line 46
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
int msg_size(Msg *m ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 54
  if (! m) {
    {
#line 54
    __assert_fail("m", "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c",
                  54U, "msg_size");
    }
  }
#line 55
  if (m->s) {
    {
#line 55
    tmp = strlen((char const   *)m->s);
#line 55
    tmp___0 = tmp;
    }
  } else {
#line 55
    tmp___0 = (size_t )0;
  }
#line 55
  return ((int )(23UL + tmp___0));
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
void msg_flatten(Msg *m , uchar *buf___3 ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 68
  put2(buf___3, (ushort )65261);
#line 69
  put2(buf___3 + 2, (ushort )m->t);
#line 70
  tmp = msg_size(m);
#line 70
  put4(buf___3 + 4, (ulong )tmp);
#line 71
  put2(buf___3 + 8, (ushort )m->m);
#line 72
  put2(buf___3 + 10, (ushort )m->w);
#line 73
  put4(buf___3 + 12, m->r.p0);
#line 74
  put4(buf___3 + 16, m->r.p1);
#line 75
  put2(buf___3 + 20, m->flag);
  }
#line 76
  if (m->s) {
#line 76
    tmp___0 = (char const   *)m->s;
  } else {
#line 76
    tmp___0 = "";
  }
  {
#line 76
  strcpy((char */* __restrict  */)(buf___3 + 22), (char const   */* __restrict  */)tmp___0);
  }
#line 77
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
int msg_init(Msg *m , uchar *buf___3 ) 
{ 
  ulong len ;
  ushort tmp ;
  ushort tmp___0 ;
  ushort tmp___1 ;
  ushort tmp___2 ;

  {
  {
#line 96
  len = get4(buf___3 + 4);
#line 98
  tmp = get2(buf___3);
  }
#line 98
  if ((int )tmp != 65261) {
#line 99
    return (-1);
  } else
#line 98
  if (len < 22UL) {
#line 99
    return (-1);
  }
  {
#line 101
  tmp___0 = get2(buf___3 + 2);
#line 101
  m->t = (Mtype )tmp___0;
#line 102
  tmp___1 = get2(buf___3 + 8);
#line 102
  m->m = (Id )tmp___1;
#line 103
  tmp___2 = get2(buf___3 + 10);
#line 103
  m->w = (Id )tmp___2;
#line 104
  m->r.p0 = get4(buf___3 + 12);
#line 105
  m->r.p1 = get4(buf___3 + 16);
#line 106
  m->flag = get2(buf___3 + 20);
#line 107
  m->s = (char *)(buf___3 + 22);
#line 108
  *(buf___3 + (len - 1UL)) = (uchar )'\000';
  }
#line 115
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
ulong msg_bufsize(uchar *buf___3 ) 
{ 
  ulong tmp ;

  {
  {
#line 125
  tmp = get4(buf___3 + 4);
  }
#line 125
  return (tmp);
}
}
#line 128 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
void msg_print(Msg *m ) 
{ 
  char const   *tmp ;

  {
  {
#line 131
  printf((char const   */* __restrict  */)"(");
  }
  {
#line 133
  if ((unsigned int )m->t == 10U) {
#line 133
    goto case_10;
  }
#line 134
  if ((unsigned int )m->t == 11U) {
#line 134
    goto case_11;
  }
#line 135
  if ((unsigned int )m->t == 12U) {
#line 135
    goto case_12;
  }
#line 136
  if ((unsigned int )m->t == 13U) {
#line 136
    goto case_13;
  }
#line 137
  if ((unsigned int )m->t == 14U) {
#line 137
    goto case_14;
  }
#line 138
  if ((unsigned int )m->t == 15U) {
#line 138
    goto case_15;
  }
#line 139
  if ((unsigned int )m->t == 16U) {
#line 139
    goto case_16;
  }
#line 140
  if ((unsigned int )m->t == 17U) {
#line 140
    goto case_17;
  }
#line 141
  if ((unsigned int )m->t == 19U) {
#line 141
    goto case_19;
  }
#line 142
  if ((unsigned int )m->t == 18U) {
#line 142
    goto case_18;
  }
#line 143
  if ((unsigned int )m->t == 20U) {
#line 143
    goto case_20;
  }
#line 144
  if ((unsigned int )m->t == 21U) {
#line 144
    goto case_21;
  }
#line 145
  if ((unsigned int )m->t == 23U) {
#line 145
    goto case_23;
  }
#line 146
  if ((unsigned int )m->t == 22U) {
#line 146
    goto case_22;
  }
#line 147
  if ((unsigned int )m->t == 24U) {
#line 147
    goto case_24;
  }
#line 148
  if ((unsigned int )m->t == 25U) {
#line 148
    goto case_25;
  }
#line 149
  if ((unsigned int )m->t == 26U) {
#line 149
    goto case_26;
  }
#line 150
  if ((unsigned int )m->t == 27U) {
#line 150
    goto case_27;
  }
#line 151
  if ((unsigned int )m->t == 28U) {
#line 151
    goto case_28;
  }
#line 152
  if ((unsigned int )m->t == 29U) {
#line 152
    goto case_29;
  }
#line 153
  if ((unsigned int )m->t == 30U) {
#line 153
    goto case_30;
  }
#line 154
  if ((unsigned int )m->t == 31U) {
#line 154
    goto case_31;
  }
#line 155
  if ((unsigned int )m->t == 32U) {
#line 155
    goto case_32;
  }
#line 156
  if ((unsigned int )m->t == 33U) {
#line 156
    goto case_33;
  }
#line 157
  if ((unsigned int )m->t == 1U) {
#line 157
    goto case_1;
  }
#line 158
  if ((unsigned int )m->t == 8U) {
#line 158
    goto case_8;
  }
#line 159
  if ((unsigned int )m->t == 2U) {
#line 159
    goto case_2;
  }
#line 160
  if ((unsigned int )m->t == 4U) {
#line 160
    goto case_4;
  }
#line 161
  if ((unsigned int )m->t == 9U) {
#line 161
    goto case_9;
  }
#line 162
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"(WRerror");
  }
#line 133
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 134
  printf((char const   */* __restrict  */)"WMlist");
  }
#line 134
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 135
  printf((char const   */* __restrict  */)"WRlist");
  }
#line 135
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"WMnew");
  }
#line 136
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 137
  printf((char const   */* __restrict  */)"WRnew");
  }
#line 137
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 138
  printf((char const   */* __restrict  */)"WMattach");
  }
#line 138
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"WRattach");
  }
#line 139
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 140
  printf((char const   */* __restrict  */)"WMsetname");
  }
#line 140
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 141
  printf((char const   */* __restrict  */)"WMgetname");
  }
#line 141
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"WRsetname");
  }
#line 142
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 143
  printf((char const   */* __restrict  */)"WRgetname");
  }
#line 143
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 144
  printf((char const   */* __restrict  */)"WMsettools");
  }
#line 144
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"WMgettools");
  }
#line 145
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"WRsettools");
  }
#line 146
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 147
  printf((char const   */* __restrict  */)"WRgettools");
  }
#line 147
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"WMread");
  }
#line 148
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 149
  printf((char const   */* __restrict  */)"WRread");
  }
#line 149
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 150
  printf((char const   */* __restrict  */)"WMreplace");
  }
#line 150
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"WRreplace");
  }
#line 151
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 152
  printf((char const   */* __restrict  */)"WMexec");
  }
#line 152
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 153
  printf((char const   */* __restrict  */)"WRexec");
  }
#line 153
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"WMgoto");
  }
#line 154
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 155
  printf((char const   */* __restrict  */)"WRgoto");
  }
#line 155
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 156
  printf((char const   */* __restrict  */)"WMfencepost");
  }
#line 156
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"WEexec");
  }
#line 157
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 158
  printf((char const   */* __restrict  */)"WEreplace");
  }
#line 158
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 159
  printf((char const   */* __restrict  */)"WEgoto");
  }
#line 159
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"WEdestroy");
  }
#line 160
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 161
  printf((char const   */* __restrict  */)"WEfencepost");
  }
#line 161
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 162
  printf((char const   */* __restrict  */)"Unknown");
  }
#line 162
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 164
  printf((char const   */* __restrict  */)", %d", m->m);
#line 165
  printf((char const   */* __restrict  */)", %d", m->w);
#line 166
  printf((char const   */* __restrict  */)", %d", (int )m->flag);
#line 167
  printf((char const   */* __restrict  */)", (%lu,%lu)", m->r.p0, m->r.p1);
  }
#line 168
  if (m->s) {
#line 168
    tmp = (char const   *)m->s;
  } else {
#line 168
    tmp = "";
  }
  {
#line 168
  printf((char const   */* __restrict  */)", [%s]) ", tmp);
  }
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
static ushort get2(uchar *p ) 
{ 


  {
#line 174
  return ((ushort )(((int )*(p + 0) << 8) + (int )*(p + 1)));
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
static ulong get4(uchar *p ) 
{ 


  {
#line 180
  return ((ulong )(((((int )*(p + 0) << 24) + ((int )*(p + 1) << 16)) + ((int )*(p + 2) << 8)) + (int )*(p + 3)));
}
}
#line 183 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
static void put2(uchar *p , ushort n ) 
{ 


  {
#line 186
  *(p + 0) = (uchar )(((int )n >> 8) & 255);
#line 187
  *(p + 1) = (uchar )((int )n & 255);
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libmsg/msg.c"
static void put4(uchar *p , ulong n ) 
{ 


  {
#line 193
  *(p + 0) = (uchar )((n >> 24) & 255UL);
#line 194
  *(p + 1) = (uchar )((n >> 16) & 255UL);
#line 195
  *(p + 2) = (uchar )((n >> 8) & 255UL);
#line 196
  *(p + 3) = (uchar )(n & 255UL);
#line 197
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
int text_linenumber(Text *t___0 , ulong p ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/line.c"
int text_linenumber(Text *t___0 , ulong p ) 
{ 
  int c ;
  int newlines ;
  int tmp ;

  {
#line 17
  newlines = 1;
#line 19
  t___0->pos = p;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (t___0->pos > t___0->gap.p0) {
#line 20
      (t___0->pos) --;
#line 20
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 20
      if (t___0->pos) {
#line 20
        (t___0->pos) --;
#line 20
        tmp = (int )*(t___0->text + t___0->pos);
      } else {
#line 20
        tmp = -1;
      }
#line 20
      c = tmp;
    }
#line 20
    if (! (c != -1)) {
#line 20
      goto while_break;
    }
#line 21
    if (c == 10) {
#line 22
      newlines ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return (newlines);
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/line.c"
Bool text_findline(Text *t___0 , Range *r , ulong n ) 
{ 
  Bool foundstart ;
  int c ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;

  {
#line 33
  foundstart = (Bool )0;
#line 36
  if (n == 0UL) {
#line 37
    return ((Bool )0);
  } else
#line 38
  if (n == 1UL) {
#line 39
    foundstart = (Bool )1;
#line 40
    r->p0 = (ulong )0;
  }
#line 42
  n --;
#line 43
  t___0->pos = (ulong )0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (t___0->pos < t___0->gap.p0) {
#line 44
      tmp = t___0->pos;
#line 44
      (t___0->pos) ++;
#line 44
      c = (int )*(t___0->text + tmp);
    } else {
#line 44
      if (t___0->pos < t___0->length) {
#line 44
        tmp___0 = t___0->pos;
#line 44
        (t___0->pos) ++;
#line 44
        tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 44
        tmp___1 = -1;
      }
#line 44
      c = tmp___1;
    }
#line 44
    if (! (c != -1)) {
#line 44
      goto while_break;
    }
#line 45
    if (c == 10) {
#line 46
      if (foundstart) {
#line 47
        goto while_break;
      } else {
#line 48
        n --;
#line 48
        if (! n) {
#line 49
          r->p0 = t___0->pos;
#line 50
          foundstart = (Bool )1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  r->p1 = t___0->pos;
#line 55
  return (foundstart);
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/line.c"
Range text_lastline(Text *t___0 ) 
{ 
  int c ;
  int tmp ;
  Range tmp___0 ;

  {
#line 63
  t___0->pos = t___0->length;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (t___0->pos > t___0->gap.p0) {
#line 64
      (t___0->pos) --;
#line 64
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 64
      if (t___0->pos) {
#line 64
        (t___0->pos) --;
#line 64
        tmp = (int )*(t___0->text + t___0->pos);
      } else {
#line 64
        tmp = -1;
      }
#line 64
      c = tmp;
    }
#line 64
    if (c != -1) {
#line 64
      if (! (c != 10)) {
#line 64
        goto while_break;
      }
    } else {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  tmp___0 = range(t___0->pos + 1UL, t___0->length);
  }
#line 66
  return (tmp___0);
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/line.c"
ulong text_nl(Text *t___0 , ulong pos , int delta ) 
{ 
  int c ;
  ulong retval ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 84
  if (delta > 0) {
#line 85
    t___0->pos = pos;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (t___0->pos < t___0->gap.p0) {
#line 86
        tmp = t___0->pos;
#line 86
        (t___0->pos) ++;
#line 86
        c = (int )*(t___0->text + tmp);
      } else {
#line 86
        if (t___0->pos < t___0->length) {
#line 86
          tmp___0 = t___0->pos;
#line 86
          (t___0->pos) ++;
#line 86
          tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
        } else {
#line 86
          tmp___1 = -1;
        }
#line 86
        c = tmp___1;
      }
#line 86
      if (! (c != -1)) {
#line 86
        goto while_break;
      }
#line 87
      if (c == 10) {
#line 88
        delta --;
#line 88
        if (! delta) {
#line 89
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 91
    t___0->pos = pos;
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 92
      if (t___0->pos > t___0->gap.p0) {
#line 92
        (t___0->pos) --;
#line 92
        c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 92
        if (t___0->pos) {
#line 92
          (t___0->pos) --;
#line 92
          tmp___3 = (int )*(t___0->text + t___0->pos);
        } else {
#line 92
          tmp___3 = -1;
        }
#line 92
        c = tmp___3;
      }
#line 92
      if (! (c != -1)) {
#line 92
        goto while_break___0;
      }
#line 93
      if (c == 10) {
#line 94
        tmp___2 = delta;
#line 94
        delta ++;
#line 94
        if (! tmp___2) {
#line 95
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 97
  retval = t___0->pos;
#line 98
  if (! (retval == 0UL)) {
#line 98
    if (! (retval == t___0->length)) {
#line 99
      retval ++;
    }
  }
#line 100
  return (retval);
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/line.c"
ulong text_startOfLine(Text *t___0 , ulong p ) 
{ 
  int c ;
  int tmp ;
  ulong tmp___0 ;

  {
#line 108
  t___0->pos = p;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (t___0->pos > t___0->gap.p0) {
#line 110
      (t___0->pos) --;
#line 110
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 110
      if (t___0->pos) {
#line 110
        (t___0->pos) --;
#line 110
        tmp = (int )*(t___0->text + t___0->pos);
      } else {
#line 110
        tmp = -1;
      }
#line 110
      c = tmp;
    }
#line 109
    if (c != -1) {
#line 109
      if (! (c != 10)) {
#line 109
        goto while_break;
      }
    } else {
#line 109
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (t___0->pos) {
#line 112
    tmp___0 = t___0->pos + 1UL;
  } else {
#line 112
    tmp___0 = t___0->pos;
  }
#line 112
  return (tmp___0);
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tile.h"
Bool list_oksizes(Tile *list___0 ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Bool list_oksizes(Tile *list___0 ) 
{ 
  Tile *t___0 ;

  {
#line 15
  t___0 = list___0->down;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 15
      goto while_break;
    }
#line 15
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return ((Bool )1);
}
}
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
void list_unhide(Tile *list___0 ) 
{ 
  Tile *t___0 ;

  {
#line 25
  t___0 = list___0->down;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 25
      goto while_break;
    }
#line 26
    t___0->ishidden = (Bool )0;
#line 27
    if (t___0->max - t___0->min < t___0->base) {
#line 28
      t___0->max = t___0->min + t___0->base;
    }
#line 25
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
void list_slide(Tile *t___0 ) 
{ 
  int prev ;

  {
#line 35
  prev = t___0->cmin;
#line 37
  t___0 = t___0->down;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 37
      goto while_break;
    }
#line 37
    if (! t___0->ishidden) {
      {
#line 38
      moveto(t___0, prev);
#line 39
      prev = t___0->max;
      }
    }
#line 37
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Tile *biggest_visible(Tile *start , Tile *end ) 
{ 
  Tile *t___0 ;
  Tile *big ;

  {
#line 46
  big = (Tile *)0;
#line 48
  t___0 = start;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 48
      goto while_break;
    }
#line 48
    if (! t___0->ishidden) {
#line 49
      if (! big) {
#line 50
        big = t___0;
      } else
#line 49
      if (t___0->max - t___0->min > big->max - big->min) {
#line 50
        big = t___0;
      }
    }
#line 48
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (big);
}
}
#line 56 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Tile *last_visible_body(Tile *start , Tile *end ) 
{ 
  Tile *t___0 ;
  Tile *last ;

  {
#line 58
  last = (Tile *)0;
#line 59
  t___0 = start;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 59
      goto while_break;
    }
#line 59
    if (! t___0->ishidden) {
#line 60
      if (t___0->max - t___0->min > t___0->base) {
#line 61
        last = t___0;
      }
    }
#line 59
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (last);
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Tile *last_visible(Tile *start , Tile *end ) 
{ 
  Tile *t___0 ;
  Tile *last ;

  {
#line 69
  last = (Tile *)0;
#line 70
  t___0 = start;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 70
      goto while_break;
    }
#line 70
    if (! t___0->ishidden) {
#line 71
      last = t___0;
    }
#line 70
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (last);
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
int list_size(Tile *start , Tile *end ) 
{ 
  int size ;
  Tile *t___0 ;

  {
#line 79
  size = 0;
#line 81
  t___0 = start;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 81
      goto while_break;
    }
#line 81
    if (! t___0->ishidden) {
#line 82
      size += t___0->max - t___0->min;
    }
#line 81
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (size);
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
int list_basesize(Tile *start , Tile *end ) 
{ 
  int size ;
  Tile *t___0 ;

  {
#line 90
  size = 0;
#line 92
  t___0 = start;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 92
      goto while_break;
    }
#line 92
    if (! t___0->ishidden) {
#line 93
      size += t___0->base;
    }
#line 92
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (size);
}
}
#line 99 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Tile *list_find(Tile *parent , int n ) 
{ 
  Tile *t___0 ;

  {
#line 102
  t___0 = parent->down;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 102
      goto while_break;
    }
#line 102
    if (! t___0->ishidden) {
#line 103
      if (n < t___0->max) {
#line 103
        if (n >= t___0->min) {
#line 104
          goto while_break;
        }
      }
    }
#line 102
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (t___0);
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Tile *next_visible(Tile *t___0 ) 
{ 


  {
#line 112
  t___0 = t___0->right;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )t___0 != (unsigned long )((Tile *)0))) {
#line 112
      goto while_break;
    }
#line 112
    if (! t___0->ishidden) {
#line 113
      goto while_break;
    }
#line 112
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (t___0);
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/list.c"
Bool list_contains(Tile *start , Tile *end , Tile *want ) 
{ 
  Tile *t___0 ;

  {
#line 122
  t___0 = start;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )t___0 != (unsigned long )end)) {
#line 122
      goto while_break;
    }
#line 122
    if (! t___0->ishidden) {
#line 123
      if ((unsigned long )t___0 == (unsigned long )want) {
#line 124
        return ((Bool )1);
      }
    }
#line 122
    t___0 = t___0->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return ((Bool )0);
}
}
#line 53 "./../include/frame.h"
void _frgrowbox(Frame *f , int delta ) ;
#line 55
void _frmergebox(Frame *f , int bn ) ;
#line 67
void _fraddbox(Frame *f , int bn , int n ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _fraddbox(Frame *f , int bn , int n ) 
{ 
  int i ;

  {
#line 15
  if (bn > (int )f->nbox) {
    {
#line 16
    berror((char *)"_fraddbox");
    }
  }
#line 17
  if ((int )f->nbox + n > (int )f->nalloc) {
    {
#line 18
    _frgrowbox(f, n + 25);
    }
  }
#line 19
  i = (int )f->nbox;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    i --;
#line 19
    if (! (i >= bn)) {
#line 19
      goto while_break;
    }
#line 20
    *(f->box + (i + n)) = *(f->box + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  f->nbox = (ushort )((int )f->nbox + n);
#line 22
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frclosebox(Frame *f , int n0 , int n1 ) 
{ 
  int i ;

  {
#line 29
  if (n0 >= (int )f->nbox) {
    {
#line 30
    berror((char *)"_frclosebox");
    }
  } else
#line 29
  if (n1 >= (int )f->nbox) {
    {
#line 30
    berror((char *)"_frclosebox");
    }
  } else
#line 29
  if (n1 < n0) {
    {
#line 30
    berror((char *)"_frclosebox");
    }
  }
#line 31
  n1 ++;
#line 32
  i = n1;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < (int )f->nbox)) {
#line 32
      goto while_break;
    }
#line 33
    *(f->box + (i - (n1 - n0))) = *(f->box + i);
#line 32
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  f->nbox = (ushort )((int )f->nbox - (n1 - n0));
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frdelbox(Frame *f , int n0 , int n1 ) 
{ 


  {
#line 40
  if (n0 >= (int )f->nbox) {
    {
#line 41
    berror((char *)"_frdelbox");
    }
  } else
#line 40
  if (n1 >= (int )f->nbox) {
    {
#line 41
    berror((char *)"_frdelbox");
    }
  } else
#line 40
  if (n1 < n0) {
    {
#line 41
    berror((char *)"_frdelbox");
    }
  }
  {
#line 42
  _frfreebox(f, n0, n1);
#line 43
  _frclosebox(f, n0, n1);
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frfreebox(Frame *f , int n0 , int n1 ) 
{ 
  int i ;

  {
#line 51
  if (n1 < n0) {
#line 52
    return;
  }
#line 53
  if (n0 >= (int )f->nbox) {
    {
#line 54
    berror((char *)"_frfreebox");
    }
  } else
#line 53
  if (n1 >= (int )f->nbox) {
    {
#line 54
    berror((char *)"_frfreebox");
    }
  }
#line 55
  n1 ++;
#line 56
  i = n0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < n1)) {
#line 56
      goto while_break;
    }
#line 57
    if ((f->box + i)->nrune >= 0L) {
      {
#line 58
      free((void *)(f->box + i)->a.ptr);
      }
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frgrowbox(Frame *f , int delta ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 64
  f->nalloc = (ushort )((int )f->nalloc + delta);
#line 65
  if (f->box) {
    {
#line 65
    tmp = realloc((void *)f->box, (unsigned long )f->nalloc * sizeof(Frbox ));
#line 65
    f->box = (Frbox *)tmp;
    }
  } else {
    {
#line 65
    tmp___0 = malloc((unsigned long )f->nalloc * sizeof(Frbox ));
#line 65
    f->box = (Frbox *)tmp___0;
    }
  }
#line 66
  if ((unsigned long )f->box == (unsigned long )((Frbox *)0)) {
    {
#line 67
    berror((char *)"_frgrowbox");
    }
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
static void dupbox(Frame *f , int bn ) 
{ 
  uchar *p ;
  size_t tmp ;

  {
#line 76
  if ((f->box + bn)->nrune < 0L) {
    {
#line 77
    berror((char *)"dupbox");
    }
  }
  {
#line 78
  _fraddbox(f, bn, 1);
  }
#line 79
  if ((f->box + bn)->nrune >= 0L) {
    {
#line 80
    tmp = strlen((char const   *)((char *)(f->box + bn)->a.ptr));
#line 80
    p = _frallocstr((unsigned int )(tmp + 1UL));
#line 81
    strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)((char *)(f->box + bn)->a.ptr));
#line 82
    (f->box + (bn + 1))->a.ptr = p;
    }
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
static uchar *runeindex(uchar *p , int n ) 
{ 
  int i ;
  int w ;
  Rune rune ;

  {
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < n)) {
#line 93
      goto while_break;
    }
#line 94
    if ((int )*p < 128) {
#line 95
      w = 1;
    } else {
      {
#line 97
      w = chartorune(& rune, (char *)p);
      }
    }
#line 93
    i ++;
#line 93
    p += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (p);
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
static void truncatebox(Frame *f , Frbox *b , int n ) 
{ 
  uchar *tmp ;

  {
#line 107
  if (b->nrune < 0L) {
    {
#line 108
    berror((char *)"truncatebox");
    }
  } else
#line 107
  if (b->nrune < (long )n) {
    {
#line 108
    berror((char *)"truncatebox");
    }
  }
  {
#line 109
  b->nrune -= (long )n;
#line 110
  tmp = runeindex(b->a.ptr, (int )b->nrune);
#line 110
  *(tmp + 0) = (uchar )0;
#line 111
  b->wid = strwidth(f->font, (char *)b->a.ptr);
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
static void chopbox(Frame *f , Frbox *b , int n ) 
{ 
  uchar *tmp ;

  {
#line 118
  if (b->nrune < 0L) {
    {
#line 119
    berror((char *)"chopbox");
    }
  } else
#line 118
  if (b->nrune < (long )n) {
    {
#line 119
    berror((char *)"chopbox");
    }
  }
  {
#line 120
  tmp = runeindex(b->a.ptr, n);
#line 120
  strcpy((char */* __restrict  */)((char *)b->a.ptr), (char const   */* __restrict  */)((char *)tmp));
#line 121
  b->nrune -= (long )n;
#line 122
  b->wid = strwidth(f->font, (char *)b->a.ptr);
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frsplitbox(Frame *f , int bn , int n ) 
{ 


  {
  {
#line 128
  dupbox(f, bn);
#line 129
  truncatebox(f, f->box + bn, (int )((f->box + bn)->nrune - (long )n));
#line 130
  chopbox(f, f->box + (bn + 1), n);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
void _frmergebox(Frame *f , int bn ) 
{ 
  Frbox *b ;
  size_t tmp ;
  size_t tmp___0 ;
  uchar *tmp___1 ;

  {
  {
#line 138
  b = f->box + bn;
#line 139
  tmp = strlen((char const   *)((char *)(b + 0)->a.ptr));
#line 139
  tmp___0 = strlen((char const   *)((char *)(b + 1)->a.ptr));
#line 139
  _frinsure(f, bn, (unsigned int )((tmp + tmp___0) + 1UL));
#line 140
  tmp___1 = runeindex((b + 0)->a.ptr, (int )(b + 0)->nrune);
#line 140
  strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)((char *)(b + 1)->a.ptr));
#line 141
  (b + 0)->wid += (b + 1)->wid;
#line 142
  (b + 0)->nrune += (b + 1)->nrune;
#line 143
  _frdelbox(f, bn + 1, bn + 1);
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frbox.c"
int _frfindbox(Frame *f , int bn , ulong p , ulong q ) 
{ 
  Frbox *b ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 151
  b = f->box + bn;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (bn < (int )f->nbox) {
#line 151
      if (b->nrune < 0L) {
#line 151
        tmp___0 = 1L;
      } else {
#line 151
        tmp___0 = b->nrune;
      }
#line 151
      if (! (p + (ulong )tmp___0 <= q)) {
#line 151
        goto while_break;
      }
    } else {
#line 151
      goto while_break;
    }
#line 152
    if (b->nrune < 0L) {
#line 152
      tmp = 1L;
    } else {
#line 152
      tmp = b->nrune;
    }
#line 152
    p += (ulong )tmp;
#line 151
    bn ++;
#line 151
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if (p != q) {
    {
#line 154
    tmp___1 = bn;
#line 154
    bn ++;
#line 154
    _frsplitbox(f, tmp___1, (int )(q - p));
    }
  }
#line 155
  return (bn);
}
}
#line 221 "./../include/libg.h"
void rdbitmap(Bitmap *b , int miny , int maxy , unsigned char *data ) ;
#line 1468 "/usr/include/X11/Xlib.h"
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/rdbitmap.c"
void rdbitmap(Bitmap *b , int miny , int maxy , unsigned char *data ) 
{ 
  XImage *gim ;
  XImage *eim ;
  int x ;
  int y ;
  int w ;
  int h ;
  int pix ;
  int l ;
  int offset ;
  int px ;
  int inld ;
  int outld ;
  char *tdata ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 20
  w = b->r.max.x - b->r.min.x;
#line 21
  h = maxy - miny;
#line 22
  outld = b->ldepth;
#line 23
  if (b->ldepth == 0) {
#line 23
    inld = 0;
  } else {
#line 23
    inld = screen.ldepth;
  }
  {
#line 24
  gim = XGetImage(_dpy, (Drawable )b->id, 0, miny - b->r.min.y, (unsigned int )w,
                  (unsigned int )h, (unsigned long )(~ 0), 2);
#line 26
  px = 1 << (3 - outld);
  }
#line 28
  if (b->r.min.x >= 0) {
#line 29
    offset = b->r.min.x % px;
  } else {
#line 31
    offset = px - b->r.min.x % px;
  }
#line 32
  l = ((- b->r.min.x + px) - 1) / px;
#line 33
  if (b->r.max.x >= 0) {
#line 34
    l += ((b->r.max.x + px) - 1) / px;
  } else {
#line 36
    l -= b->r.max.x / px;
  }
#line 37
  l *= h;
#line 38
  if (l <= 0) {
#line 39
    return;
  }
  {
#line 40
  tmp = malloc((size_t )l);
#line 40
  tdata = (char *)tmp;
  }
#line 41
  if ((unsigned long )tdata == (unsigned long )((char *)0)) {
    {
#line 42
    berror((char *)"rdbitmap malloc");
    }
  }
  {
#line 43
  eim = XCreateImage(_dpy, (Visual *)0, (unsigned int )(1 << inld), 2, 0, tdata, (unsigned int )(w + offset),
                     (unsigned int )h, 8, 0);
#line 45
  eim->bitmap_pad = 8;
#line 46
  eim->bitmap_bit_order = 1;
#line 47
  eim->byte_order = 1;
#line 49
  y = 0;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (y < h)) {
#line 49
      goto while_break;
    }
#line 50
    x = 0;
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (x < w)) {
#line 50
        goto while_break___0;
      }
      {
#line 51
      tmp___0 = (*(gim->f.get_pixel))(gim, x, y);
#line 51
      pix = (int )tmp___0;
#line 52
      (*(eim->f.put_pixel))(eim, x + offset, y, (unsigned long )pix);
#line 50
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (inld == outld) {
    {
#line 56
    memcpy((void */* __restrict  */)((char *)data), (void const   */* __restrict  */)tdata,
           (size_t )l);
    }
  } else {
    {
#line 58
    _ldconvert(tdata, inld, (char *)data, outld, w, h);
    }
  }
  {
#line 60
  (*(gim->f.destroy_image))(gim);
#line 61
  (*(eim->f.destroy_image))(eim);
  }
#line 62
  return;
}
}
#line 200 "./../include/libg.h"
void copymasked(Bitmap *d , Point p , Bitmap *s , Bitmap *m , Rectangle r ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/copymasked.c"
void copymasked(Bitmap *d , Point p , Bitmap *s , Bitmap *m , Rectangle r ) 
{ 
  int sx ;
  int sy ;
  int dx ;
  int dy ;
  XGCValues gcv ;
  GC g ;

  {
#line 18
  if (r.max.x - r.min.x <= 0) {
#line 19
    return;
  } else
#line 18
  if (r.max.y - r.min.y <= 0) {
#line 19
    return;
  }
#line 20
  sx = r.min.x;
#line 21
  sy = r.min.y;
#line 22
  if (s->flag & 32) {
#line 23
    sx -= s->r.min.x;
#line 24
    sy -= s->r.min.y;
  }
#line 26
  dx = p.x;
#line 27
  dy = p.y;
#line 28
  if (d->flag & 32) {
#line 29
    dx -= d->r.min.x;
#line 30
    dy -= d->r.min.y;
  }
  {
#line 32
  gcv.fill_style = 2;
#line 33
  gcv.stipple = (Pixmap )m->id;
#line 34
  gcv.function = 0;
#line 35
  gcv.ts_x_origin = dx;
#line 36
  gcv.ts_y_origin = dy;
#line 37
  gcv.fill_style = 2;
#line 38
  g = _getgc(d, (unsigned long )((((1L | (1L << 11)) | (1L << 12)) | (1L << 13)) | (1L << 8)),
             & gcv);
#line 40
  XFillRectangle(_dpy, (Drawable )d->id, g, dx, dy, (unsigned int )(r.max.x - r.min.x),
                 (unsigned int )(r.max.y - r.min.y));
#line 42
  gcv.function = 7;
#line 43
  gcv.fill_style = 0;
#line 44
  g = _getgc(d, (unsigned long )(1L | (1L << 8)), & gcv);
#line 45
  XCopyArea(_dpy, (Drawable )s->id, (Drawable )d->id, g, sx, sy, (unsigned int )(r.max.x - r.min.x),
            (unsigned int )(r.max.y - r.min.y), dx, dy);
  }
#line 47
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/latin1.c"
struct latin latintab[207]  = 
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/latin1.c"
  {      {(unsigned short)161, {(unsigned char )'!', (unsigned char )'!'}}, 
        {(unsigned short)162, {(unsigned char )'c', (unsigned char )'$'}}, 
        {(unsigned short)163, {(unsigned char )'l', (unsigned char )'$'}}, 
        {(unsigned short)164, {(unsigned char )'g', (unsigned char )'$'}}, 
        {(unsigned short)165, {(unsigned char )'y', (unsigned char )'$'}}, 
        {(unsigned short)166, {(unsigned char )'|', (unsigned char )'|'}}, 
        {(unsigned short)167, {(unsigned char )'S', (unsigned char )'S'}}, 
        {(unsigned short)168, {(unsigned char )'\"', (unsigned char )'\"'}}, 
        {(unsigned short)169, {(unsigned char )'c', (unsigned char )'O'}}, 
        {(unsigned short)170, {(unsigned char )'s', (unsigned char )'a'}}, 
        {(unsigned short)171, {(unsigned char )'<', (unsigned char )'<'}}, 
        {(unsigned short)172, {(unsigned char )'n', (unsigned char )'o'}}, 
        {(unsigned short)173, {(unsigned char )'-', (unsigned char )'-'}}, 
        {(unsigned short)174, {(unsigned char )'r', (unsigned char )'O'}}, 
        {(unsigned short)175, {(unsigned char )'_', (unsigned char )'_'}}, 
        {(unsigned short)176, {(unsigned char )'d', (unsigned char )'e'}}, 
        {(unsigned short)177, {(unsigned char )'+', (unsigned char )'-'}}, 
        {(unsigned short)178, {(unsigned char )'s', (unsigned char )'2'}}, 
        {(unsigned short)179, {(unsigned char )'s', (unsigned char )'3'}}, 
        {(unsigned short)180, {(unsigned char )'\'', (unsigned char )'\''}}, 
        {(unsigned short)181, {(unsigned char )'m', (unsigned char )'i'}}, 
        {(unsigned short)182, {(unsigned char )'p', (unsigned char )'g'}}, 
        {(unsigned short)183, {(unsigned char )'.', (unsigned char )'.'}}, 
        {(unsigned short)184, {(unsigned char )',', (unsigned char )','}}, 
        {(unsigned short)185, {(unsigned char )'s', (unsigned char )'1'}}, 
        {(unsigned short)186, {(unsigned char )'s', (unsigned char )'o'}}, 
        {(unsigned short)187, {(unsigned char )'>', (unsigned char )'>'}}, 
        {(unsigned short)188, {(unsigned char )'1', (unsigned char )'4'}}, 
        {(unsigned short)189, {(unsigned char )'1', (unsigned char )'2'}}, 
        {(unsigned short)190, {(unsigned char )'3', (unsigned char )'4'}}, 
        {(unsigned short)191, {(unsigned char )'?', (unsigned char )'?'}}, 
        {(unsigned short)192, {(unsigned char )'`', (unsigned char )'A'}}, 
        {(unsigned short)193, {(unsigned char )'\'', (unsigned char )'A'}}, 
        {(unsigned short)194, {(unsigned char )'^', (unsigned char )'A'}}, 
        {(unsigned short)195, {(unsigned char )'~', (unsigned char )'A'}}, 
        {(unsigned short)196, {(unsigned char )'\"', (unsigned char )'A'}}, 
        {(unsigned short)197, {(unsigned char )'o', (unsigned char )'A'}}, 
        {(unsigned short)198, {(unsigned char )'A', (unsigned char )'E'}}, 
        {(unsigned short)199, {(unsigned char )',', (unsigned char )'C'}}, 
        {(unsigned short)200, {(unsigned char )'`', (unsigned char )'E'}}, 
        {(unsigned short)201, {(unsigned char )'\'', (unsigned char )'E'}}, 
        {(unsigned short)202, {(unsigned char )'^', (unsigned char )'E'}}, 
        {(unsigned short)203, {(unsigned char )'\"', (unsigned char )'E'}}, 
        {(unsigned short)204, {(unsigned char )'`', (unsigned char )'I'}}, 
        {(unsigned short)205, {(unsigned char )'\'', (unsigned char )'I'}}, 
        {(unsigned short)206, {(unsigned char )'^', (unsigned char )'I'}}, 
        {(unsigned short)207, {(unsigned char )'\"', (unsigned char )'I'}}, 
        {(unsigned short)208, {(unsigned char )'D', (unsigned char )'-'}}, 
        {(unsigned short)209, {(unsigned char )'~', (unsigned char )'N'}}, 
        {(unsigned short)210, {(unsigned char )'`', (unsigned char )'O'}}, 
        {(unsigned short)211, {(unsigned char )'\'', (unsigned char )'O'}}, 
        {(unsigned short)212, {(unsigned char )'^', (unsigned char )'O'}}, 
        {(unsigned short)213, {(unsigned char )'~', (unsigned char )'O'}}, 
        {(unsigned short)214, {(unsigned char )'\"', (unsigned char )'O'}}, 
        {(unsigned short)215, {(unsigned char )'m', (unsigned char )'u'}}, 
        {(unsigned short)216, {(unsigned char )'/', (unsigned char )'O'}}, 
        {(unsigned short)217, {(unsigned char )'`', (unsigned char )'U'}}, 
        {(unsigned short)218, {(unsigned char )'\'', (unsigned char )'U'}}, 
        {(unsigned short)219, {(unsigned char )'^', (unsigned char )'U'}}, 
        {(unsigned short)220, {(unsigned char )'\"', (unsigned char )'U'}}, 
        {(unsigned short)221, {(unsigned char )'\'', (unsigned char )'Y'}}, 
        {(unsigned short)222, {(unsigned char )'|', (unsigned char )'P'}}, 
        {(unsigned short)223, {(unsigned char )'s', (unsigned char )'s'}}, 
        {(unsigned short)224, {(unsigned char )'`', (unsigned char )'a'}}, 
        {(unsigned short)225, {(unsigned char )'\'', (unsigned char )'a'}}, 
        {(unsigned short)226, {(unsigned char )'^', (unsigned char )'a'}}, 
        {(unsigned short)227, {(unsigned char )'~', (unsigned char )'a'}}, 
        {(unsigned short)228, {(unsigned char )'\"', (unsigned char )'a'}}, 
        {(unsigned short)229, {(unsigned char )'o', (unsigned char )'a'}}, 
        {(unsigned short)230, {(unsigned char )'a', (unsigned char )'e'}}, 
        {(unsigned short)231, {(unsigned char )',', (unsigned char )'c'}}, 
        {(unsigned short)232, {(unsigned char )'`', (unsigned char )'e'}}, 
        {(unsigned short)233, {(unsigned char )'\'', (unsigned char )'e'}}, 
        {(unsigned short)234, {(unsigned char )'^', (unsigned char )'e'}}, 
        {(unsigned short)235, {(unsigned char )'\"', (unsigned char )'e'}}, 
        {(unsigned short)236, {(unsigned char )'`', (unsigned char )'i'}}, 
        {(unsigned short)237, {(unsigned char )'\'', (unsigned char )'i'}}, 
        {(unsigned short)238, {(unsigned char )'^', (unsigned char )'i'}}, 
        {(unsigned short)239, {(unsigned char )'\"', (unsigned char )'i'}}, 
        {(unsigned short)240, {(unsigned char )'d', (unsigned char )'-'}}, 
        {(unsigned short)241, {(unsigned char )'~', (unsigned char )'n'}}, 
        {(unsigned short)242, {(unsigned char )'`', (unsigned char )'o'}}, 
        {(unsigned short)243, {(unsigned char )'\'', (unsigned char )'o'}}, 
        {(unsigned short)244, {(unsigned char )'^', (unsigned char )'o'}}, 
        {(unsigned short)245, {(unsigned char )'~', (unsigned char )'o'}}, 
        {(unsigned short)246, {(unsigned char )'\"', (unsigned char )'o'}}, 
        {(unsigned short)247, {(unsigned char )'-', (unsigned char )':'}}, 
        {(unsigned short)248, {(unsigned char )'/', (unsigned char )'o'}}, 
        {(unsigned short)249, {(unsigned char )'`', (unsigned char )'u'}}, 
        {(unsigned short)250, {(unsigned char )'\'', (unsigned char )'u'}}, 
        {(unsigned short)251, {(unsigned char )'^', (unsigned char )'u'}}, 
        {(unsigned short)252, {(unsigned char )'\"', (unsigned char )'u'}}, 
        {(unsigned short)253, {(unsigned char )'\'', (unsigned char )'y'}}, 
        {(unsigned short)254, {(unsigned char )'|', (unsigned char )'p'}}, 
        {(unsigned short)255, {(unsigned char )'\"', (unsigned char )'y'}}, 
        {(unsigned short)9812, {(unsigned char )'w', (unsigned char )'k'}}, 
        {(unsigned short)9813, {(unsigned char )'w', (unsigned char )'q'}}, 
        {(unsigned short)9814, {(unsigned char )'w', (unsigned char )'r'}}, 
        {(unsigned short)9815, {(unsigned char )'w', (unsigned char )'b'}}, 
        {(unsigned short)9816, {(unsigned char )'w', (unsigned char )'n'}}, 
        {(unsigned short)9817, {(unsigned char )'w', (unsigned char )'p'}}, 
        {(unsigned short)9818, {(unsigned char )'b', (unsigned char )'k'}}, 
        {(unsigned short)9819, {(unsigned char )'b', (unsigned char )'q'}}, 
        {(unsigned short)9820, {(unsigned char )'b', (unsigned char )'r'}}, 
        {(unsigned short)9821, {(unsigned char )'b', (unsigned char )'b'}}, 
        {(unsigned short)9822, {(unsigned char )'b', (unsigned char )'n'}}, 
        {(unsigned short)9823, {(unsigned char )'b', (unsigned char )'p'}}, 
        {(unsigned short)945, {(unsigned char )'*', (unsigned char )'a'}}, 
        {(unsigned short)946, {(unsigned char )'*', (unsigned char )'b'}}, 
        {(unsigned short)947, {(unsigned char )'*', (unsigned char )'g'}}, 
        {(unsigned short)948, {(unsigned char )'*', (unsigned char )'d'}}, 
        {(unsigned short)949, {(unsigned char )'*', (unsigned char )'e'}}, 
        {(unsigned short)950, {(unsigned char )'*', (unsigned char )'z'}}, 
        {(unsigned short)951, {(unsigned char )'*', (unsigned char )'y'}}, 
        {(unsigned short)952, {(unsigned char )'*', (unsigned char )'h'}}, 
        {(unsigned short)953, {(unsigned char )'*', (unsigned char )'i'}}, 
        {(unsigned short)954, {(unsigned char )'*', (unsigned char )'k'}}, 
        {(unsigned short)955, {(unsigned char )'*', (unsigned char )'l'}}, 
        {(unsigned short)956, {(unsigned char )'*', (unsigned char )'m'}}, 
        {(unsigned short)957, {(unsigned char )'*', (unsigned char )'n'}}, 
        {(unsigned short)958, {(unsigned char )'*', (unsigned char )'c'}}, 
        {(unsigned short)959, {(unsigned char )'*', (unsigned char )'o'}}, 
        {(unsigned short)960, {(unsigned char )'*', (unsigned char )'p'}}, 
        {(unsigned short)961, {(unsigned char )'*', (unsigned char )'r'}}, 
        {(unsigned short)962, {(unsigned char )'t', (unsigned char )'s'}}, 
        {(unsigned short)963, {(unsigned char )'*', (unsigned char )'s'}}, 
        {(unsigned short)964, {(unsigned char )'*', (unsigned char )'t'}}, 
        {(unsigned short)965, {(unsigned char )'*', (unsigned char )'u'}}, 
        {(unsigned short)966, {(unsigned char )'*', (unsigned char )'f'}}, 
        {(unsigned short)967, {(unsigned char )'*', (unsigned char )'x'}}, 
        {(unsigned short)968, {(unsigned char )'*', (unsigned char )'q'}}, 
        {(unsigned short)969, {(unsigned char )'*', (unsigned char )'w'}}, 
        {(unsigned short)913, {(unsigned char )'*', (unsigned char )'A'}}, 
        {(unsigned short)914, {(unsigned char )'*', (unsigned char )'B'}}, 
        {(unsigned short)915, {(unsigned char )'*', (unsigned char )'G'}}, 
        {(unsigned short)916, {(unsigned char )'*', (unsigned char )'D'}}, 
        {(unsigned short)917, {(unsigned char )'*', (unsigned char )'E'}}, 
        {(unsigned short)918, {(unsigned char )'*', (unsigned char )'Z'}}, 
        {(unsigned short)919, {(unsigned char )'*', (unsigned char )'Y'}}, 
        {(unsigned short)920, {(unsigned char )'*', (unsigned char )'H'}}, 
        {(unsigned short)921, {(unsigned char )'*', (unsigned char )'I'}}, 
        {(unsigned short)922, {(unsigned char )'*', (unsigned char )'K'}}, 
        {(unsigned short)923, {(unsigned char )'*', (unsigned char )'L'}}, 
        {(unsigned short)924, {(unsigned char )'*', (unsigned char )'M'}}, 
        {(unsigned short)925, {(unsigned char )'*', (unsigned char )'N'}}, 
        {(unsigned short)926, {(unsigned char )'*', (unsigned char )'C'}}, 
        {(unsigned short)927, {(unsigned char )'*', (unsigned char )'O'}}, 
        {(unsigned short)928, {(unsigned char )'*', (unsigned char )'P'}}, 
        {(unsigned short)929, {(unsigned char )'*', (unsigned char )'R'}}, 
        {(unsigned short)931, {(unsigned char )'*', (unsigned char )'S'}}, 
        {(unsigned short)932, {(unsigned char )'*', (unsigned char )'T'}}, 
        {(unsigned short)933, {(unsigned char )'*', (unsigned char )'U'}}, 
        {(unsigned short)934, {(unsigned char )'*', (unsigned char )'F'}}, 
        {(unsigned short)935, {(unsigned char )'*', (unsigned char )'X'}}, 
        {(unsigned short)936, {(unsigned char )'*', (unsigned char )'Q'}}, 
        {(unsigned short)937, {(unsigned char )'*', (unsigned char )'W'}}, 
        {(unsigned short)8592, {(unsigned char )'<', (unsigned char )'-'}}, 
        {(unsigned short)8593, {(unsigned char )'u', (unsigned char )'a'}}, 
        {(unsigned short)8594, {(unsigned char )'-', (unsigned char )'>'}}, 
        {(unsigned short)8595, {(unsigned char )'d', (unsigned char )'a'}}, 
        {(unsigned short)8596, {(unsigned char )'a', (unsigned char )'b'}}, 
        {(unsigned short)8656, {(unsigned char )'V', (unsigned char )'='}}, 
        {(unsigned short)8658, {(unsigned char )'=', (unsigned char )'V'}}, 
        {(unsigned short)8704, {(unsigned char )'f', (unsigned char )'a'}}, 
        {(unsigned short)8707, {(unsigned char )'t', (unsigned char )'e'}}, 
        {(unsigned short)8706, {(unsigned char )'p', (unsigned char )'d'}}, 
        {(unsigned short)8709, {(unsigned char )'e', (unsigned char )'s'}}, 
        {(unsigned short)8710, {(unsigned char )'D', (unsigned char )'e'}}, 
        {(unsigned short)8711, {(unsigned char )'g', (unsigned char )'r'}}, 
        {(unsigned short)8712, {(unsigned char )'m', (unsigned char )'o'}}, 
        {(unsigned short)8713, {(unsigned char )'!', (unsigned char )'m'}}, 
        {(unsigned short)8717, {(unsigned char )'s', (unsigned char )'t'}}, 
        {(unsigned short)8727, {(unsigned char )'*', (unsigned char )'*'}}, 
        {(unsigned short)8729, {(unsigned char )'b', (unsigned char )'u'}}, 
        {(unsigned short)8730, {(unsigned char )'s', (unsigned char )'r'}}, 
        {(unsigned short)8733, {(unsigned char )'p', (unsigned char )'t'}}, 
        {(unsigned short)8734, {(unsigned char )'i', (unsigned char )'f'}}, 
        {(unsigned short)8736, {(unsigned char )'a', (unsigned char )'n'}}, 
        {(unsigned short)8743, {(unsigned char )'l', (unsigned char )'&'}}, 
        {(unsigned short)8744, {(unsigned char )'l', (unsigned char )'|'}}, 
        {(unsigned short)8745, {(unsigned char )'c', (unsigned char )'a'}}, 
        {(unsigned short)8746, {(unsigned char )'c', (unsigned char )'u'}}, 
        {(unsigned short)8747, {(unsigned char )'i', (unsigned char )'s'}}, 
        {(unsigned short)8756, {(unsigned char )'t', (unsigned char )'f'}}, 
        {(unsigned short)8771, {(unsigned char )'~', (unsigned char )'='}}, 
        {(unsigned short)8773, {(unsigned char )'c', (unsigned char )'g'}}, 
        {(unsigned short)8776, {(unsigned char )'~', (unsigned char )'~'}}, 
        {(unsigned short)8800, {(unsigned char )'!', (unsigned char )'='}}, 
        {(unsigned short)8801, {(unsigned char )'=', (unsigned char )'='}}, 
        {(unsigned short)8806, {(unsigned char )'<', (unsigned char )'='}}, 
        {(unsigned short)8807, {(unsigned char )'>', (unsigned char )'='}}, 
        {(unsigned short)8834, {(unsigned char )'s', (unsigned char )'b'}}, 
        {(unsigned short)8835, {(unsigned char )'s', (unsigned char )'p'}}, 
        {(unsigned short)8836, {(unsigned char )'!', (unsigned char )'b'}}, 
        {(unsigned short)8838, {(unsigned char )'i', (unsigned char )'b'}}, 
        {(unsigned short)8839, {(unsigned char )'i', (unsigned char )'p'}}, 
        {(unsigned short)8853, {(unsigned char )'O', (unsigned char )'+'}}, 
        {(unsigned short)8854, {(unsigned char )'O', (unsigned char )'-'}}, 
        {(unsigned short)8855, {(unsigned char )'O', (unsigned char )'x'}}, 
        {(unsigned short)8866, {(unsigned char )'t', (unsigned char )'u'}}, 
        {(unsigned short)8872, {(unsigned char )'T', (unsigned char )'u'}}, 
        {(unsigned short)8900, {(unsigned char )'l', (unsigned char )'z'}}, 
        {(unsigned short)8943, {(unsigned char )'e', (unsigned char )'l'}}, 
        {(unsigned short)9785, {(unsigned char )':', (unsigned char )'('}}, 
        {(unsigned short)9786, {(unsigned char )':', (unsigned char )')'}}, 
        {(unsigned short)9787, {(unsigned char )';', (unsigned char )')'}}, 
        {(unsigned short)0, {(unsigned char)0}}};
#line 217 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/latin1.c"
long latin1(unsigned char *k ) 
{ 
  struct latin *l ;

  {
#line 222
  l = latintab;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! l->l) {
#line 222
      goto while_break;
    }
#line 223
    if ((int )*(k + 0) == (int )l->c[0]) {
#line 223
      if ((int )*(k + 1) == (int )l->c[1]) {
#line 224
        return ((long )l->l);
      }
    }
#line 222
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (-1L);
}
}
#line 228 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/latin1.c"
long unicode(unsigned char *k ) 
{ 
  long i ;
  long c ;

  {
#line 233
  k ++;
#line 234
  c = 0L;
#line 235
  i = 0L;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! (i < 4L)) {
#line 235
      goto while_break;
    }
#line 236
    c <<= 4;
#line 237
    if (48 <= (int )*k) {
#line 237
      if ((int )*k <= 57) {
#line 238
        c += (long )((int )*k - 48);
      } else {
#line 237
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 239
    if (97 <= (int )*k) {
#line 239
      if ((int )*k <= 102) {
#line 240
        c += (long )((10 + (int )*k) - 97);
      } else {
#line 239
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 241
    if (65 <= (int )*k) {
#line 241
      if ((int )*k <= 70) {
#line 242
        c += (long )((10 + (int )*k) - 65);
      } else {
#line 244
        return (-1L);
      }
    } else {
#line 244
      return (-1L);
    }
#line 235
    i ++;
#line 235
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (c);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/dir.c"
static int mycmp(void const   *a , void const   *d ) 
{ 
  int tmp ;

  {
  {
#line 14
  tmp = strcmp((char const   *)*((char **)a), (char const   *)*((char **)d));
  }
#line 14
  return (tmp);
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/dir.c"
char **dirnames(DIR *dirp , char *path ) 
{ 
  struct stat statbuf ;
  struct dirent *direntp ;
  char *name ;
  char **list___0 ;
  int nfiles ;
  int maxnames ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Path buf___3 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 38
  maxnames = 10240;
#line 42
  rewinddir(dirp);
#line 44
  tmp = salloc((int )((unsigned long )maxnames * sizeof(char *)));
#line 44
  list___0 = (char **)tmp;
#line 47
  tmp___0 = chdir((char const   *)path);
  }
#line 47
  if (tmp___0) {
    {
#line 48
    diag(path, (char *)"couldn\'t chdir");
    }
#line 49
    return ((char **)0);
  }
#line 51
  nfiles = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    direntp = readdir(dirp);
    }
#line 52
    if (! direntp) {
#line 52
      goto while_break;
    }
#line 53
    name = direntp->d_name;
#line 54
    if ((int )*(name + 0) == 46) {
#line 54
      if (! show_dot_files) {
#line 55
        goto while_continue;
      } else
#line 54
      if ((int )*(name + 1) == 0) {
#line 55
        goto while_continue;
      }
    }
#line 57
    if (! (nfiles + 2 < maxnames)) {
      {
#line 58
      maxnames *= 2;
#line 59
      tmp___1 = srealloc((void *)list___0, (int )((unsigned long )maxnames * sizeof(char *)));
#line 59
      list___0 = (char **)tmp___1;
      }
    }
#line 62
    if ((int )direntp->d_type == 4) {
      {
#line 66
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%s/",
              name);
#line 67
      tmp___2 = nfiles;
#line 67
      nfiles ++;
#line 67
      *(list___0 + tmp___2) = strdup((char const   *)(buf___3));
      }
    } else {
      {
#line 62
      tmp___4 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& statbuf));
      }
#line 62
      if (tmp___4 >= 0) {
#line 62
        if ((statbuf.st_mode & 61440U) == 16384U) {
          {
#line 66
          sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%s/",
                  name);
#line 67
          tmp___2 = nfiles;
#line 67
          nfiles ++;
#line 67
          *(list___0 + tmp___2) = strdup((char const   *)(buf___3));
          }
        } else {
          {
#line 69
          tmp___3 = nfiles;
#line 69
          nfiles ++;
#line 69
          *(list___0 + tmp___3) = strdup((char const   *)name);
          }
        }
      } else {
        {
#line 69
        tmp___3 = nfiles;
#line 69
        nfiles ++;
#line 69
        *(list___0 + tmp___3) = strdup((char const   *)name);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  tmp___5 = chdir((char const   *)(wilydir));
  }
#line 73
  if (tmp___5) {
    {
#line 74
    diag(wilydir, (char *)"couldn\'t chdir back to wilydir [%s]", wilydir);
    }
  }
  {
#line 76
  closedir(dirp);
#line 78
  qsort((void *)list___0, (size_t )nfiles, sizeof(char *), & mycmp);
#line 80
  *(list___0 + nfiles) = (char *)0;
  }
#line 81
  return (list___0);
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/dir.c"
void dirnames_free(char **names ) 
{ 
  char **s ;

  {
#line 89
  if (! names) {
#line 90
    return;
  }
#line 91
  s = names;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! *s) {
#line 91
      goto while_break;
    }
    {
#line 92
    free((void *)*s);
#line 91
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  free((void *)names);
  }
#line 94
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/col.c"
Tile *tile_col(Tile *tile ) 
{ 


  {
#line 12
  if (tile) {
#line 12
    if ((unsigned int )tile->ori != 0U) {
#line 13
      tile = tile->up;
    }
  }
#line 14
  return (tile);
}
}
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/col.c"
void col_new(View *v , char *arg ) 
{ 
  int min ;
  int max ;
  Tile *col ;
  Text *tagt ;

  {
  {
#line 24
  findplace(wily, & min, & max);
#line 25
  tagt = text_alloc((Data *)0, (Bool )0);
#line 26
  text_replaceutf(tagt, nr, columntools);
#line 27
  col = tile_new((Ori )0, min, max, 50, wily, tagt, (Text *)0);
#line 28
  list_add(wily, col);
  }
#line 29
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/col.c"
static int col_delwins(Tile *tile ) 
{ 
  Tile *t___0 ;
  Tile *next ;
  int problem ;
  int tmp ;

  {
#line 37
  problem = 0;
#line 39
  t___0 = tile->down;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! t___0) {
#line 39
      goto while_break;
    }
    {
#line 40
    next = t___0->right;
#line 41
    tmp = win_del(t___0);
    }
#line 41
    if (tmp) {
#line 42
      problem = 1;
    }
#line 39
    t___0 = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return (problem);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/col.c"
void col_del(Tile *t___0 ) 
{ 
  int tmp ;

  {
#line 49
  if (t___0) {
    {
#line 49
    tmp = col_delwins(t___0);
    }
#line 49
    if (! tmp) {
      {
#line 50
      tile_del(t___0);
      }
    }
  }
#line 52
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/ldconvert.c"
void _ldconvert(char *in , int inld , char *out , int outld , int w , int h ) 
{ 
  int a ;
  int b ;
  int i ;
  int j ;
  int i1 ;
  int j1 ;
  int j2 ;
  int mask ;
  int ind ;
  int inl ;
  int outd ;
  int outl ;
  int hh ;
  int ww ;
  char *p ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 14
  i1 = 8 >> inld;
#line 15
  j1 = 8 >> outld;
#line 16
  ind = 1 << inld;
#line 17
  outd = 1 << outld;
#line 18
  inl = ((w << inld) + 7) / 8;
#line 19
  outl = ((w << outld) + 7) / 8;
#line 20
  b = 0;
#line 22
  if (ind > outd) {
#line 23
    mask = 256 - (256 >> outd);
#line 24
    hh = 0;
    {
#line 24
    while (1) {
      while_continue: /* CIL Label */ ;
#line 24
      if (! (hh < h)) {
#line 24
        goto while_break;
      }
#line 25
      p = in;
#line 25
      q = out;
#line 25
      ww = 0;
      {
#line 25
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 25
        if (! (ww < w)) {
#line 25
          goto while_break___0;
        }
#line 26
        j = j1;
        {
#line 26
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 26
          if (! (j > 0)) {
#line 26
            goto while_break___1;
          }
#line 27
          tmp = p;
#line 27
          p ++;
#line 27
          a = (int )*tmp;
#line 28
          i = i1;
          {
#line 28
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 28
            if (! (i > 0)) {
#line 28
              goto while_break___2;
            }
#line 29
            b |= a & mask;
#line 30
            a <<= ind;
#line 31
            b <<= outd;
#line 28
            i --;
#line 28
            j --;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 34
        tmp___0 = q;
#line 34
        q ++;
#line 34
        *tmp___0 = (char )(b >> 8);
#line 25
        ww ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 24
      hh ++;
#line 24
      in += inl;
#line 24
      out += outl;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 37
    j2 = 1 << (outld - inld);
#line 38
    mask = 256 - (256 >> ind);
#line 39
    hh = 0;
    {
#line 39
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 39
      if (! (hh < h)) {
#line 39
        goto while_break___3;
      }
#line 40
      p = in;
#line 40
      q = out;
#line 40
      ww = 0;
      {
#line 40
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 40
        if (! (ww < w)) {
#line 40
          goto while_break___4;
        }
#line 41
        tmp___1 = p;
#line 41
        p ++;
#line 41
        a = (int )*tmp___1;
#line 42
        i = i1;
        {
#line 42
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 42
          if (! (i > 0)) {
#line 42
            goto while_break___5;
          }
#line 43
          j = j1;
          {
#line 43
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 43
            if (! (j > 0)) {
#line 43
              goto while_break___6;
            }
#line 44
            b |= a & mask;
#line 45
            a <<= ind;
#line 46
            b <<= outd;
#line 43
            j --;
#line 43
            i --;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 48
          j = j2;
          {
#line 48
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 48
            if (! (j > 0)) {
#line 48
              goto while_break___7;
            }
#line 49
            b |= b << ind;
#line 48
            j --;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 50
          tmp___2 = q;
#line 50
          q ++;
#line 50
          *tmp___2 = (char )(b >> 8);
        }
        while_break___5: /* CIL Label */ ;
        }
#line 40
        ww ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 39
      hh ++;
#line 39
      in += inl;
#line 39
      out += outl;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 54
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
Scroll *scroll_alloc(Bitmap *b , Rectangle r ) ;
#line 244
Bool view_invariants(View *v ) ;
#line 255
void view_append(View *v , char *s , int n ) ;
#line 263
void viewlist_replace(View *v , Range r , Rstring s ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
static Rectangle nullrect  =    {{0, 0}, {0, 0}};
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_getdot(View *v , char *buf___3 , Bool isLine ) 
{ 
  int tmp ;

  {
#line 17
  if (isLine) {
    {
#line 18
    tmp = text_linenumber(v->t, v->sel.p0);
#line 18
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)" :%d,.",
            tmp);
    }
  } else {
    {
#line 21
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)" :#%lu,.",
            v->sel.p0);
    }
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Range view_expand(View *v , Range r , char *s ) 
{ 
  Range tmp ;

  {
#line 27
  if (r.p1 - r.p0) {
#line 28
    return (r);
  }
#line 29
  if (v->sel.p1 - v->sel.p0) {
#line 29
    if (v->sel.p0 <= r.p0) {
#line 29
      if (v->sel.p1 >= r.p1) {
#line 30
        return (v->sel);
      } else {
        {
#line 32
        tmp = text_expand(v->t, r, s);
        }
#line 32
        return (tmp);
      }
    } else {
      {
#line 32
      tmp = text_expand(v->t, r, s);
      }
#line 32
      return (tmp);
    }
  } else {
    {
#line 32
    tmp = text_expand(v->t, r, s);
    }
#line 32
    return (tmp);
  }
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
View *view_new(Font___0 *f , Bool istag , Text *text , Tile *tile ) 
{ 
  View *v ;
  void *tmp ;
  Bitmap *b ;
  ulong length ;
  ulong sel___0 ;
  Scroll *tmp___0 ;

  {
  {
#line 43
  tmp = salloc((int )sizeof(View ));
#line 43
  v = (View *)tmp;
#line 44
  b = (Bitmap *)0;
#line 48
  length = text_length(text);
#line 49
  v->r = nullrect;
#line 50
  frinit(& v->f, nullrect, f, b);
#line 51
  v->visible = range((ulong )0, (ulong )0);
  }
#line 52
  if (istag) {
#line 52
    sel___0 = length;
  } else {
#line 52
    sel___0 = (ulong )0;
  }
  {
#line 53
  v->sel = range(sel___0, sel___0);
#line 54
  v->anchor = length;
#line 55
  v->t = text;
#line 56
  v->next = (View *)0;
#line 57
  v->selecting = (Bool )0;
#line 58
  v->autoindent = autoindent_enabled;
#line 59
  text_addview(text, v);
#line 60
  v->tile = tile;
  }
#line 61
  if (istag) {
#line 61
    v->scroll = (Scroll *)0;
  } else {
    {
#line 61
    tmp___0 = scroll_alloc(b, nullrect);
#line 61
    v->scroll = tmp___0;
    }
  }
#line 63
  return (v);
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
int view_delete(View *v ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = text_rmview(v->t, v);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
#line 71
  if ((unsigned long )v == (unsigned long )last_selection) {
    {
#line 72
    view_setlastselection((View *)0);
    }
  }
  {
#line 73
  frclear(& v->f);
  }
#line 74
  if (v->scroll) {
    {
#line 75
    free((void *)v->scroll);
    }
  }
#line 76
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Bool view_invariants(View *v ) 
{ 
  Range r ;
  ulong length ;

  {
#line 85
  if (! v->f.b) {
#line 86
    return ((Bool )1);
  }
  {
#line 88
  length = text_length(v->t);
  }
#line 103
  if (! v->selecting) {
    {
#line 105
    r = rclip(v->sel, v->visible);
    }
  }
#line 109
  return ((Bool )1);
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Data *view_data(View *v ) 
{ 
  Data *tmp ;
  Data *tmp___0 ;

  {
#line 120
  if (v) {
    {
#line 120
    tmp = text_data(v->t);
#line 120
    tmp___0 = tmp;
    }
  } else {
#line 120
    tmp___0 = (Data *)0;
  }
#line 120
  return (tmp___0);
}
}
#line 124 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
View *view_body(View *v ) 
{ 
  View *tmp ;
  View *tmp___0 ;

  {
#line 126
  if (! v) {
#line 127
    return ((View *)0);
  }
#line 128
  if (v) {
#line 128
    if (v->scroll) {
#line 128
      tmp___0 = v;
    } else {
      {
#line 128
      tmp = tile_body(v->tile);
#line 128
      tmp___0 = tmp;
      }
    }
  } else {
    {
#line 128
    tmp = tile_body(v->tile);
#line 128
    tmp___0 = tmp;
    }
  }
#line 128
  return (tmp___0);
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Tile *view_win(View *v ) 
{ 
  Tile *tmp ;
  Tile *tmp___0 ;

  {
#line 134
  if (v) {
    {
#line 134
    tmp = tile_win(v->tile);
#line 134
    tmp___0 = tmp;
    }
  } else {
#line 134
    tmp___0 = (Tile *)0;
  }
#line 134
  return (tmp___0);
}
}
#line 138 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Tile *view_tile(View *v ) 
{ 
  Tile *tmp ;

  {
#line 140
  if (v) {
#line 140
    tmp = v->tile;
  } else {
#line 140
    tmp = (Tile *)0;
  }
#line 140
  return (tmp);
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Text *view_text(View *v ) 
{ 
  Text *tmp ;

  {
#line 145
  if (v) {
#line 145
    tmp = v->t;
  } else {
#line 145
    tmp = (Text *)0;
  }
#line 145
  return (tmp);
}
}
#line 148 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
Range view_getsel(View *v ) 
{ 


  {
#line 150
  return (v->sel);
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
int view_height(View *v ) 
{ 
  int tmp ;

  {
#line 155
  if (v) {
#line 155
    if (v->f.b) {
#line 155
      tmp = v->r.max.y - v->r.min.y;
    } else {
#line 155
      tmp = 0;
    }
  } else {
#line 155
    tmp = 0;
  }
#line 155
  return (tmp);
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_paste(View *v ) 
{ 
  Range tmp ;

  {
  {
#line 160
  undo_break(v->t);
#line 161
  tmp = paste(v->t, v->sel);
#line 161
  view_select(v, tmp);
#line 162
  view_show(v, v->sel);
  }
#line 163
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_cut(View *v , Range r ) 
{ 
  Rstring tmp ;
  Range tmp___0 ;

  {
#line 171
  if (r.p1 - r.p0) {
    {
#line 172
    snarf(v->t, r);
#line 173
    undo_break(v->t);
#line 174
    tmp = rstring((Rune *)0, (Rune *)0);
#line 174
    text_replace(v->t, r, tmp);
    }
  }
  {
#line 176
  tmp___0 = range(r.p0, r.p0);
#line 176
  view_show(v, tmp___0);
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_append(View *v , char *s , int n ) 
{ 
  Text *t___0 ;
  ulong len ;
  Range end ;

  {
  {
#line 185
  t___0 = v->t;
#line 186
  len = text_length(t___0);
#line 187
  end = range(len, len);
#line 188
  *(s + n) = (char)0;
#line 190
  text_replaceutf(v->t, end, s);
  }
#line 191
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_pipe(View *v , Bool *first , char *s , int n ) 
{ 
  ulong p0 ;
  Range r ;

  {
#line 199
  p0 = v->sel.p0;
#line 202
  if (*first) {
#line 203
    r = v->sel;
#line 204
    *first = (Bool )0;
  } else {
    {
#line 206
    r = range(v->sel.p1, v->sel.p1);
    }
  }
  {
#line 209
  *(s + n) = (char)0;
#line 210
  text_replaceutf(v->t, r, s);
#line 211
  r = range(p0, v->sel.p1);
#line 213
  view_select(v, r);
  }
#line 214
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_setfont(View *v , char *arg ) 
{ 
  Font___0 *tmp ;

  {
#line 223
  if ((unsigned long )v->f.font == (unsigned long )font) {
#line 223
    tmp = fixed;
  } else {
#line 223
    tmp = font;
  }
  {
#line 223
  frfont(& v->f, tmp);
  }
#line 224
  if ((unsigned long )v->f.b != (unsigned long )((Bitmap *)0)) {
    {
#line 225
    view_reshaped(v, v->r);
    }
  }
#line 226
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_border(View *v , Bool set ) 
{ 
  Rectangle r ;
  Tile *tmp ;
  Bool tmp___0 ;

  {
  {
#line 239
  r = v->r;
#line 240
  r.min.x += 17;
#line 242
  tmp = view_tile(v);
#line 242
  tmp___0 = tile_hidden(tmp);
  }
#line 242
  if (tmp___0) {
#line 243
    return;
  }
#line 244
  if (set) {
    {
#line 245
    border(& screen, r, 3, (Fcode )15);
    }
  } else {
    {
#line 247
    border(& screen, r, 3, (Fcode )0);
#line 248
    border(& screen, v->r, 1, (Fcode )15);
    }
  }
#line 250
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_setlastselection(View *v ) 
{ 


  {
#line 256
  if ((unsigned long )v == (unsigned long )last_selection) {
#line 257
    return;
  }
#line 259
  if (last_selection) {
    {
#line 260
    view_border(last_selection, (Bool )0);
    }
  }
#line 261
  if (v) {
    {
#line 262
    view_border(v, (Bool )1);
    }
  }
#line 263
  last_selection = v;
#line 264
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_select(View *v , Range r ) 
{ 


  {
  {
#line 273
  frselectp(& v->f, (Fcode )5);
#line 274
  v->sel = r;
#line 275
  r = rclip(v->sel, v->visible);
#line 276
  v->f.p0 = r.p0 - v->visible.p0;
#line 277
  v->f.p1 = r.p1 - v->visible.p0;
#line 278
  frselectp(& v->f, (Fcode )5);
  }
#line 281
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void view_warp(View *v , Range r ) 
{ 
  Point pt ;

  {
  {
#line 297
  pt = frptofchar(& v->f, r.p0 - v->visible.p0);
#line 298
  pt.y += (int )(v->f.font)->height / 2;
#line 299
  cursorset(pt);
  }
#line 300
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
static void view_replace(View *v , Range r , Rstring s ) 
{ 
  Range q ;
  Range tmp ;
  int len ;
  Bool visible ;
  Frame *f ;

  {
  {
#line 310
  tmp = intersect(r, v->visible);
#line 310
  q = tmp;
#line 312
  visible = (Bool )((unsigned long )v->f.b != (unsigned long )((Bitmap *)0));
  }
#line 322
  if (visible) {
#line 322
    if (q.p1 >= q.p0) {
#line 324
      f = & v->f;
#line 326
      q.p0 -= v->visible.p0;
#line 327
      q.p1 -= v->visible.p0;
#line 329
      if (q.p1 - q.p0) {
        {
#line 330
        frdelete(f, q.p0, q.p1);
        }
      }
#line 331
      if (s.r1 - s.r0) {
        {
#line 332
        frinsert(f, s.r0, s.r1, q.p0);
        }
      }
    }
  }
  {
#line 336
  len = (int )(s.r1 - s.r0);
#line 337
  v->visible.p0 = ladjust(v->visible.p0, r, len);
#line 338
  v->visible.p1 = radjust(v->visible.p1, r, len);
#line 339
  v->sel.p0 = radjust(v->sel.p0, r, len);
#line 340
  v->sel.p1 = radjust(v->sel.p1, r, len);
#line 341
  v->anchor = ladjust(v->anchor, r, len);
  }
#line 343
  if (visible) {
    {
#line 344
    fill(v);
    }
  }
#line 346
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
static void view_refresh(View *v ) 
{ 


  {
#line 352
  if ((unsigned long )v->f.b != (unsigned long )((Bitmap *)0)) {
    {
#line 353
    v->sel = range(v->visible.p0, v->visible.p0);
#line 354
    frdelete(& v->f, (ulong )0, (ulong )v->f.nchars);
#line 355
    fill(v);
    }
  }
#line 357
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void viewlist_refresh(View *v ) 
{ 


  {
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! v) {
#line 361
      goto while_break;
    }
    {
#line 362
    view_refresh(v);
#line 361
    v = v->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/view.c"
void viewlist_replace(View *v , Range r , Rstring s ) 
{ 


  {
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! v) {
#line 367
      goto while_break;
    }
    {
#line 368
    view_replace(v, r, s);
#line 367
    v = v->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipr.c"
int clipr(Bitmap *d , Rectangle r ) 
{ 
  int tmp ;

  {
  {
#line 9
  tmp = rectclip(& r, d->r);
  }
#line 9
  if (tmp == 0) {
#line 10
    return (0);
  }
#line 11
  d->clipr = r;
#line 12
  if (r.min.x != d->r.min.x) {
#line 16
    d->flag |= 64;
  } else
#line 12
  if (r.min.y != d->r.min.y) {
#line 16
    d->flag |= 64;
  } else
#line 12
  if (r.max.x != d->r.max.x) {
#line 16
    d->flag |= 64;
  } else
#line 12
  if (r.max.y != d->r.max.y) {
#line 16
    d->flag |= 64;
  } else {
#line 18
    d->flag &= -65;
  }
#line 19
  return (1);
}
}
#line 213 "./../include/libg.h"
void disc(Bitmap *b , Point p , int r , int v , Fcode f ) ;
#line 2471 "/usr/include/X11/Xlib.h"
extern int XFillArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/disc.c"
void disc(Bitmap *b , Point p , int r , int v , Fcode f ) 
{ 
  unsigned int d ;
  int x ;
  int y ;
  GC g ;

  {
#line 13
  x = p.x - r;
#line 14
  y = p.y - r;
#line 15
  if (b->flag & 32) {
#line 16
    x -= b->r.min.x;
#line 17
    y -= b->r.min.y;
  }
  {
#line 19
  d = (unsigned int )(2 * r);
#line 20
  g = _getfillgc(f, b, (unsigned long )v);
#line 21
  XFillArc(_dpy, (Drawable )b->id, g, x, y, d, d, 0, 23040);
  }
#line 22
  return;
}
}
#line 222 "./../include/libg.h"
void wrbitmapfile(int fd , Bitmap *b ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/wrbitmapfile.c"
void wrbitmapfile(int fd , Bitmap *b ) 
{ 
  char hdr[61] ;
  unsigned char *data ;
  long dy ;
  long px ;
  unsigned long l ;
  unsigned long t___0 ;
  unsigned long n ;
  long miny ;
  long maxy ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 17
  sprintf(hdr, "%11d %11d %11d %11d %11d ", b->ldepth, b->r.min.x, b->r.min.y, b->r.max.x,
          b->r.max.y);
#line 19
  tmp = (int )write(fd, hdr, 60);
  }
#line 19
  if (tmp != 60) {
    {
#line 20
    berror((char *)"wrbitmapfile write");
    }
  }
#line 22
  px = (long )(1 << (3 - b->ldepth));
#line 24
  if (b->r.min.x >= 0) {
#line 25
    l = (unsigned long )((((long )b->r.max.x + px) - 1L) / px - (long )b->r.min.x / px);
  } else {
#line 27
    t___0 = (unsigned long )(((long )(- b->r.min.x) + px) - 1L);
#line 28
    t___0 = (t___0 / (unsigned long )px) * (unsigned long )px;
#line 29
    l = (((t___0 + (unsigned long )b->r.max.x) + (unsigned long )px) - 1UL) / (unsigned long )px;
  }
  {
#line 31
  miny = (long )b->r.min.y;
#line 32
  maxy = (long )b->r.max.y;
#line 33
  tmp___0 = malloc((size_t )4096);
#line 33
  data = (unsigned char *)tmp___0;
  }
#line 34
  if ((unsigned long )data == (unsigned long )((unsigned char *)0)) {
    {
#line 35
    berror((char *)"wrbitmapfile malloc");
    }
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (maxy > miny)) {
#line 36
      goto while_break;
    }
#line 37
    dy = maxy - miny;
#line 38
    if ((unsigned long )dy * l > 4096UL) {
#line 39
      dy = (long )(4096UL / l);
    }
    {
#line 40
    rdbitmap(b, (int )miny, (int )(miny + dy), data);
#line 41
    n = (unsigned long )dy * l;
#line 42
    tmp___1 = (int )write(fd, data, n);
    }
#line 42
    if ((unsigned long )tmp___1 != n) {
      {
#line 43
      free((void *)data);
#line 44
      berror((char *)"wrbitmapfile write");
      }
    }
#line 46
    miny += dy;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  free((void *)data);
  }
#line 49
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static struct Abbrev *abbrev  =    (struct Abbrev *)0;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static int nabbrev  =    0;
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static int maxabbrev  =    0;
#line 19
static Bool foundmatch(char *dest , char *orig ) ;
#line 20
static Bool contract(char *dest , char *orig ) ;
#line 21
static void newenv(char *env , Stat *buf___3 ) ;
#line 22
static Abbrev *findstat(Stat *buf___3 ) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
void env_init(char **envp ) 
{ 
  char *env ;
  char *ptr ;
  Stat buf___3 ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    tmp___2 = envp;
#line 30
    envp ++;
#line 30
    env = *tmp___2;
#line 30
    if (! env) {
#line 30
      goto while_break;
    }
    {
#line 31
    ptr = strchr((char const   *)env, '=');
    }
#line 31
    if (! ptr) {
#line 32
      goto while_continue;
    }
    {
#line 33
    tmp = ptr;
#line 33
    ptr ++;
#line 33
    *tmp = (char)0;
#line 34
    tmp___0 = strlen((char const   *)ptr);
    }
#line 34
    if (tmp___0) {
      {
#line 34
      tmp___1 = stat((char const   */* __restrict  */)ptr, (struct stat */* __restrict  */)(& buf___3));
      }
#line 34
      if (! tmp___1) {
        {
#line 35
        newenv(env, & buf___3);
        }
      }
    }
#line 36
    ptr --;
#line 36
    *ptr = (char )'=';
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
void pathcontract(char *dest , char *orig ) 
{ 
  Bool tmp ;

  {
#line 43
  if ((int )*(orig + 0) == 47) {
    {
#line 43
    tmp = contract(dest, orig);
    }
#line 43
    if (! tmp) {
      {
#line 46
      strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)orig);
      }
    }
  } else {
    {
#line 46
    strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)orig);
    }
  }
#line 48
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static Bool foundmatch(char *dest , char *orig ) 
{ 
  Stat buf___3 ;
  Abbrev *ab ;
  int tmp ;

  {
  {
#line 59
  tmp = stat((char const   */* __restrict  */)orig, (struct stat */* __restrict  */)(& buf___3));
  }
#line 59
  if (tmp) {
#line 63
    return ((Bool )0);
  } else {
    {
#line 59
    ab = findstat(& buf___3);
    }
#line 59
    if (ab) {
      {
#line 60
      sprintf((char */* __restrict  */)dest, (char const   */* __restrict  */)"$%s",
              ab->env);
      }
#line 61
      return ((Bool )1);
    } else {
#line 63
      return ((Bool )0);
    }
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static Bool contract(char *dest , char *orig ) 
{ 
  char *lastslash ;
  Bool retval ;
  Bool tmp ;

  {
  {
#line 72
  tmp = foundmatch(dest, orig);
  }
#line 72
  if (tmp) {
#line 73
    return ((Bool )1);
  } else {
    {
#line 75
    lastslash = strrchr((char const   *)orig, '/');
    }
#line 76
    if (lastslash) {
      {
#line 77
      *lastslash = (char )'\000';
#line 78
      retval = contract(dest, orig);
#line 79
      *lastslash = (char )'/';
      }
#line 80
      if (retval) {
        {
#line 81
        strcat((char */* __restrict  */)dest, (char const   */* __restrict  */)lastslash);
        }
      }
#line 83
      return (retval);
    } else {
#line 85
      return ((Bool )0);
    }
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static void newenv(char *env , Stat *buf___3 ) 
{ 
  Abbrev *new___0 ;
  Abbrev *old ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 96
  old = findstat(buf___3);
  }
#line 96
  if (old) {
    {
#line 97
    tmp = strlen((char const   *)env);
#line 97
    tmp___0 = strlen((char const   *)(old->env));
    }
#line 97
    if (tmp < tmp___0) {
      {
#line 98
      strcpy((char */* __restrict  */)(old->env), (char const   */* __restrict  */)env);
      }
    }
#line 99
    return;
  }
#line 102
  if (nabbrev == maxabbrev) {
#line 103
    if (maxabbrev) {
#line 103
      maxabbrev *= 2;
    } else {
#line 103
      maxabbrev += 2;
    }
    {
#line 104
    tmp___1 = srealloc((void *)abbrev, (int )((unsigned long )maxabbrev * sizeof(*abbrev)));
#line 104
    abbrev = (struct Abbrev *)tmp___1;
    }
  }
  {
#line 106
  tmp___2 = nabbrev;
#line 106
  nabbrev ++;
#line 106
  new___0 = abbrev + tmp___2;
#line 107
  strcpy((char */* __restrict  */)(new___0->env), (char const   */* __restrict  */)env);
#line 108
  new___0->buf = *buf___3;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/env.c"
static Abbrev *findstat(Stat *buf___3 ) 
{ 
  Abbrev *ab ;
  int tmp ;

  {
#line 115
  ab = abbrev;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((unsigned long )ab < (unsigned long )(abbrev + nabbrev))) {
#line 115
      goto while_break;
    }
    {
#line 116
    tmp = statcmp(buf___3, & ab->buf);
    }
#line 116
    if (! tmp) {
#line 117
      return (ab);
    }
#line 115
    ab ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return ((Abbrev *)0);
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/mkfont.c"
Font___0 *mkfont(Subfont *subfont ) 
{ 
  Font___0 *font___0 ;
  Cachesubf *c ;
  char *cp ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 17
  tmp = (int )malloc(sizeof(Font___0 ));
#line 17
  font___0 = (Font___0 *)tmp;
  }
#line 18
  if ((unsigned long )font___0 == (unsigned long )((Font___0 *)0)) {
#line 19
    return ((Font___0 *)0);
  }
  {
#line 20
  memset((void *)font___0, 0, sizeof(Font___0 ));
#line 21
  cp = (char *)"<synthetic>";
#line 22
  tmp___0 = strlen((char const   *)cp);
#line 22
  tmp___1 = (int )malloc(tmp___0 + 1UL);
#line 22
  font___0->name = (char *)tmp___1;
  }
#line 23
  if ((unsigned long )font___0->name == (unsigned long )((char *)0)) {
    {
#line 24
    free(font___0);
    }
#line 25
    return ((Font___0 *)0);
  }
  {
#line 27
  strcpy((char */* __restrict  */)font___0->name, (char const   */* __restrict  */)cp);
#line 28
  font___0->nsubf = (unsigned short)1;
#line 29
  tmp___2 = (int )malloc((unsigned long )font___0->nsubf * sizeof(Cachesubf ));
#line 29
  font___0->subf = (Cachesubf *)tmp___2;
  }
#line 30
  if ((unsigned long )font___0->subf == (unsigned long )((Cachesubf *)0)) {
    {
#line 32
    free(font___0->name);
#line 33
    free(font___0);
    }
#line 34
    return ((Font___0 *)0);
  }
  {
#line 36
  memset((void *)font___0->subf, 0, (unsigned long )font___0->nsubf * sizeof(Cachesubf ));
#line 37
  font___0->height = subfont->height;
#line 38
  font___0->ascent = subfont->ascent;
#line 39
  font___0->ldepth = (char )screen.ldepth;
#line 40
  c = font___0->subf;
#line 41
  subfont->minchar = subfont->mincol;
#line 42
  c->min = (Rune )subfont->minchar;
#line 43
  c->max = (Rune )subfont->maxchar;
#line 44
  c->name = (char *)0;
#line 45
  (font___0->subf + 0)->f = subfont;
  }
#line 46
  return (font___0);
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
static Frame frame  ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
static Point bxscan(Frame *f , Rune *sp , Rune *ep , Point *ppt ) 
{ 
  int w ;
  int c ;
  int nb ;
  int delta ;
  int nl___0 ;
  int nr___0 ;
  int rw ;
  Frbox *b ;
  char *s ;
  char tmp[259] ;
  uchar *p ;
  long tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  Point tmp___3 ;

  {
#line 20
  frame.r = f->r;
#line 21
  frame.b = f->b;
#line 22
  frame.font = f->font;
#line 23
  frame.maxtab = f->maxtab;
#line 24
  frame.left = f->left;
#line 25
  frame.nbox = (ushort )0;
#line 26
  frame.nchars = (ushort )0;
#line 27
  delta = 25;
#line 28
  nl___0 = 0;
#line 29
  nb = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if ((unsigned long )sp < (unsigned long )ep) {
#line 29
      if (! (nl___0 <= (int )f->maxlines)) {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
#line 30
    if (nb == (int )frame.nalloc) {
      {
#line 31
      _frgrowbox(& frame, delta);
      }
#line 32
      if (delta < 10000) {
#line 33
        delta *= 2;
      }
    }
#line 35
    b = frame.box + nb;
#line 36
    c = (int )*sp;
#line 37
    if (c == 9) {
#line 37
      goto _L;
    } else
#line 37
    if (c == 10) {
      _L: /* CIL Label */ 
#line 38
      b->a.b.bc = (short )c;
#line 39
      b->wid = 5000L;
#line 40
      if (c == 10) {
#line 40
        b->a.b.minwid = (short)0;
      } else {
        {
#line 40
        tmp___0 = charwidth(frame.font, (Rune )' ');
#line 40
        b->a.b.minwid = (short )tmp___0;
        }
      }
#line 41
      b->nrune = -1L;
#line 42
      if (c == 10) {
#line 43
        nl___0 ++;
      }
#line 44
      frame.nchars = (ushort )((int )frame.nchars + 1);
#line 45
      sp ++;
    } else {
#line 47
      s = tmp;
#line 48
      nr___0 = 0;
#line 49
      w = 0;
      {
#line 50
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 50
        if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 50
          goto while_break___0;
        }
#line 51
        c = (int )*sp;
#line 52
        if (c == 9) {
#line 53
          goto while_break___0;
        } else
#line 52
        if (c == 10) {
#line 53
          goto while_break___0;
        }
        {
#line 54
        rw = runetochar(s, sp);
        }
#line 55
        if ((unsigned long )(s + rw) >= (unsigned long )(tmp + 256)) {
#line 56
          goto while_break___0;
        }
        {
#line 57
        tmp___1 = charwidth(frame.font, (Rune )c);
#line 57
        w = (int )((long )w + tmp___1);
#line 58
        sp ++;
#line 59
        s += rw;
#line 60
        nr___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 62
      tmp___2 = s;
#line 62
      s ++;
#line 62
      *tmp___2 = (char)0;
#line 63
      p = _frallocstr((unsigned int )(s - tmp));
#line 64
      b = frame.box + nb;
#line 65
      b->a.ptr = p;
#line 66
      memmove((void *)p, (void const   *)(tmp), (size_t )(s - tmp));
#line 67
      b->wid = (long )w;
#line 68
      b->nrune = (long )nr___0;
#line 69
      frame.nchars = (ushort )((int )frame.nchars + nr___0);
      }
    }
#line 29
    nb ++;
#line 29
    frame.nbox = (ushort )((int )frame.nbox + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  _frcklinewrap0(f, ppt, frame.box + 0);
#line 73
  tmp___3 = _frdraw(& frame, *ppt);
  }
#line 73
  return (tmp___3);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
static void chopframe(Frame *f , Point pt , ulong p , int bn ) 
{ 
  Frbox *b ;
  long tmp ;

  {
#line 82
  b = f->box + bn;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if ((unsigned long )b >= (unsigned long )(f->box + f->nbox)) {
      {
#line 84
      berror((char *)"endofframe");
      }
    }
    {
#line 85
    _frcklinewrap(f, & pt, b);
    }
#line 86
    if (pt.y >= f->r.max.y) {
#line 87
      goto while_break;
    }
#line 88
    if (b->nrune < 0L) {
#line 88
      tmp = 1L;
    } else {
#line 88
      tmp = b->nrune;
    }
    {
#line 88
    p += (ulong )tmp;
#line 89
    _fradvance(f, & pt, b);
#line 82
    b ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  f->nchars = (ushort )p;
#line 92
  f->nlines = f->maxlines;
#line 93
  if ((unsigned long )b < (unsigned long )(f->box + f->nbox)) {
    {
#line 94
    _frdelbox(f, (int )(b - f->box), (int )f->nbox - 1);
    }
  }
#line 95
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
static struct __anonstruct_pts_34 *pts  ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
static int nalloc  =    0;
#line 97 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frinsert.c"
void frinsert(Frame *f , Rune *sp , Rune *ep , ulong p0 ) 
{ 
  Point pt0 ;
  Point pt1 ;
  Point ppt0 ;
  Point ppt1 ;
  Point pt ;
  Frbox *b ;
  int n ;
  int n0 ;
  int nn0 ;
  int y ;
  Rectangle r ;
  int npts ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int q0 ;
  int q1 ;
  Point tmp___3 ;
  int tmp___4 ;

  {
#line 110
  if (p0 > (ulong )f->nchars) {
#line 111
    return;
  } else
#line 110
  if ((unsigned long )sp == (unsigned long )ep) {
#line 111
    return;
  } else
#line 110
  if ((unsigned long )f->b == (unsigned long )((Bitmap *)0)) {
#line 111
    return;
  }
  {
#line 112
  n0 = _frfindbox(f, 0, (ulong )0, p0);
#line 113
  nn0 = n0;
#line 114
  pt0 = _frptofcharnb(f, p0, n0);
#line 115
  ppt0 = pt0;
#line 116
  pt1 = bxscan(f, sp, ep, & ppt0);
#line 117
  ppt1 = pt1;
  }
#line 118
  if (n0 < (int )f->nbox) {
    {
#line 119
    b = f->box + n0;
#line 119
    _frcklinewrap(f, & pt0, b);
#line 120
    _frcklinewrap0(f, & ppt1, b);
    }
  }
#line 122
  f->modified = (ushort )1;
#line 128
  if (p0 == f->p0) {
#line 128
    if (p0 == f->p1) {
      {
#line 129
      frselectf(f, pt0, pt0, (Fcode )5);
      }
    } else {
      {
#line 131
      frselectp(f, (Fcode )5);
      }
    }
  } else {
    {
#line 131
    frselectp(f, (Fcode )5);
    }
  }
#line 139
  b = f->box + n0;
#line 139
  npts = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (pt1.x != pt0.x) {
#line 139
      if (pt1.y != f->r.max.y) {
#line 139
        if (! (n0 < (int )f->nbox)) {
#line 139
          goto while_break;
        }
      } else {
#line 139
        goto while_break;
      }
    } else {
#line 139
      goto while_break;
    }
    {
#line 141
    _frcklinewrap(f, & pt0, b);
#line 142
    _frcklinewrap0(f, & pt1, b);
    }
#line 143
    if (b->nrune > 0L) {
      {
#line 144
      n = _frcanfit(f, pt1, b);
      }
#line 145
      if (n == 0) {
        {
#line 146
        berror((char *)"_frcanfit==0");
        }
      }
#line 147
      if ((long )n != b->nrune) {
        {
#line 148
        _frsplitbox(f, n0, n);
#line 149
        b = f->box + n0;
        }
      }
    }
#line 152
    if (npts == nalloc) {
#line 153
      if (pts) {
        {
#line 153
        tmp = realloc((void *)pts, (unsigned long )(npts + 25) * sizeof(*(pts + 0)));
#line 153
        pts = (struct __anonstruct_pts_34 *)tmp;
        }
      } else {
        {
#line 153
        tmp___0 = malloc((unsigned long )(npts + 25) * sizeof(*(pts + 0)));
#line 153
        pts = (struct __anonstruct_pts_34 *)tmp___0;
        }
      }
#line 154
      nalloc += 25;
#line 155
      b = f->box + n0;
    }
#line 157
    (pts + npts)->pt0 = pt0;
#line 158
    (pts + npts)->pt1 = pt1;
#line 160
    if (pt1.y == f->r.max.y) {
#line 161
      goto while_break;
    }
    {
#line 162
    _fradvance(f, & pt0, b);
#line 163
    tmp___1 = _frnewwid(f, pt1, b);
#line 163
    pt1.x += tmp___1;
#line 139
    b ++;
#line 139
    n0 ++;
#line 139
    npts ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (pt1.y > f->r.max.y) {
    {
#line 166
    berror((char *)"frinsert pt1 too far");
    }
  }
#line 167
  if (pt1.y == f->r.max.y) {
#line 167
    if (n0 < (int )f->nbox) {
      {
#line 168
      tmp___2 = _frstrlen(f, n0);
#line 168
      f->nchars = (ushort )((int )f->nchars - tmp___2);
#line 169
      _frdelbox(f, n0, (int )f->nbox - 1);
      }
    }
  }
#line 171
  if (n0 == (int )f->nbox) {
#line 172
    f->nlines = (ushort )((pt1.y - f->r.min.y) / (int )(f->font)->height + (pt1.x > (int )f->left));
  } else
#line 173
  if (pt1.y != pt0.y) {
#line 176
    y = f->r.max.y;
#line 177
    q0 = pt0.y + (int )(f->font)->height;
#line 178
    q1 = pt1.y + (int )(f->font)->height;
#line 179
    f->nlines = (ushort )((int )f->nlines + (q1 - q0) / (int )(f->font)->height);
#line 180
    if ((int )f->nlines > (int )f->maxlines) {
      {
#line 181
      chopframe(f, ppt1, p0, nn0);
      }
    }
#line 182
    if (pt1.y < y) {
#line 183
      r = f->r;
#line 184
      r.min.y = q0;
#line 185
      r.max.y = y - (q1 - q0);
#line 186
      if (q1 < y) {
        {
#line 187
        tmp___3 = Pt(f->r.min.x, q1);
#line 187
        bitblt(f->b, tmp___3, f->b, r, (Fcode )12);
        }
      }
      {
#line 188
      r.min = pt0;
#line 189
      r.max.y = q0;
#line 190
      bitblt(f->b, pt1, f->b, r, (Fcode )12);
      }
    }
  }
#line 198
  if (pt1.y == f->r.max.y) {
#line 198
    y = pt1.y;
  } else {
#line 198
    y = 0;
  }
#line 198
  b = f->box + (n0 - 1);
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    npts --;
#line 198
    if (! (npts >= 0)) {
#line 198
      goto while_break___0;
    }
#line 199
    pt = (pts + npts)->pt1;
#line 200
    if (b->nrune > 0L) {
      {
#line 201
      r.min = (pts + npts)->pt0;
#line 202
      r.max = r.min;
#line 203
      r.max.x = (int )((long )r.max.x + b->wid);
#line 204
      r.max.y += (int )(f->font)->height;
#line 205
      bitblt(f->b, pt, f->b, r, (Fcode )12);
      }
#line 206
      if (pt.y < y) {
        {
#line 207
        r.min = pt;
#line 208
        r.max = pt;
#line 209
        r.min.x = (int )((long )r.min.x + b->wid);
#line 210
        r.max.x = f->r.max.x;
#line 211
        r.max.y += (int )(f->font)->height;
#line 212
        bitblt(f->b, r.min, f->b, r, (Fcode )0);
        }
      }
#line 214
      y = pt.y;
    } else {
#line 216
      r.min = pt;
#line 217
      r.max = pt;
#line 218
      r.max.x = (int )((long )r.max.x + b->wid);
#line 219
      r.max.y += (int )(f->font)->height;
#line 220
      if (r.max.x >= f->r.max.x) {
#line 221
        r.max.x = f->r.max.x;
      }
      {
#line 222
      bitblt(f->b, r.min, f->b, r, (Fcode )0);
      }
#line 223
      if (pt.x == (int )f->left) {
#line 223
        y = pt.y;
      } else {
#line 223
        y = 0;
      }
    }
#line 198
    b --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 226
  frselectf(f, ppt0, ppt1, (Fcode )0);
#line 227
  _frredraw(& frame, ppt0);
#line 228
  _fraddbox(f, nn0, (int )frame.nbox);
#line 229
  n = 0;
  }
  {
#line 229
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 229
    if (! (n < (int )frame.nbox)) {
#line 229
      goto while_break___1;
    }
#line 230
    *(f->box + (nn0 + n)) = *(frame.box + n);
#line 229
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 231
  if (nn0 > 0) {
#line 231
    if ((f->box + (nn0 - 1))->nrune >= 0L) {
#line 231
      if ((long )ppt0.x - (f->box + (nn0 - 1))->wid >= (long )((int )f->left)) {
#line 232
        nn0 --;
#line 233
        ppt0.x = (int )((long )ppt0.x - (f->box + nn0)->wid);
      }
    }
  }
#line 235
  n0 += (int )frame.nbox;
#line 236
  if (n0 < (int )f->nbox - 1) {
#line 236
    tmp___4 = n0 + 1;
  } else {
#line 236
    tmp___4 = n0;
  }
  {
#line 236
  _frclean(f, ppt0, nn0, tmp___4);
#line 237
  f->nchars = (ushort )((int )f->nchars + (int )frame.nchars);
  }
#line 238
  if (f->p0 >= p0) {
#line 239
    f->p0 += (ulong )frame.nchars;
  }
#line 240
  if (f->p0 > (ulong )f->nchars) {
#line 241
    f->p0 = (ulong )f->nchars;
  }
#line 242
  if (f->p1 >= p0) {
#line 243
    f->p1 += (ulong )frame.nchars;
  }
#line 244
  if (f->p1 > (ulong )f->nchars) {
#line 245
    f->p1 = (ulong )f->nchars;
  }
  {
#line 246
  frselectp(f, (Fcode )5);
  }
#line 247
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
int _frcanfit(Frame *f , Point pt , Frbox *b ) 
{ 
  int left___0 ;
  int w ;
  int nr___0 ;
  uchar *p ;
  Rune r ;
  long tmp ;

  {
#line 14
  left___0 = f->r.max.x - pt.x;
#line 15
  if (b->nrune < 0L) {
#line 16
    return ((int )b->a.b.minwid <= left___0);
  }
#line 17
  if ((long )left___0 >= b->wid) {
#line 18
    return ((int )b->nrune);
  }
#line 19
  nr___0 = 0;
#line 19
  p = b->a.ptr;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! *p) {
#line 19
      goto while_break;
    }
#line 20
    r = (Rune )*p;
#line 21
    if ((int )r < 128) {
#line 22
      w = 1;
    } else {
      {
#line 24
      w = chartorune(& r, (char *)p);
      }
    }
    {
#line 25
    tmp = charwidth(f->font, r);
#line 25
    left___0 = (int )((long )left___0 - tmp);
    }
#line 26
    if (left___0 < 0) {
#line 27
      return (nr___0);
    }
#line 19
    p += w;
#line 19
    nr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 29
  berror((char *)"_frcanfit can\'t");
  }
#line 30
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
void _frcklinewrap(Frame *f , Point *p , Frbox *b ) 
{ 
  long tmp ;

  {
#line 36
  if (b->nrune < 0L) {
#line 36
    tmp = (long )b->a.b.minwid;
  } else {
#line 36
    tmp = b->wid;
  }
#line 36
  if (tmp > (long )(f->r.max.x - p->x)) {
#line 37
    p->x = (int )f->left;
#line 38
    p->y += (int )(f->font)->height;
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
void _frcklinewrap0(Frame *f , Point *p , Frbox *b ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = _frcanfit(f, *p, b);
  }
#line 45
  if (tmp == 0) {
#line 46
    p->x = (int )f->left;
#line 47
    p->y += (int )(f->font)->height;
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
void _fradvance(Frame *f , Point *p , Frbox *b ) 
{ 


  {
#line 54
  if (b->nrune < 0L) {
#line 54
    if ((int )b->a.b.bc == 10) {
#line 55
      p->x = (int )f->left;
#line 56
      p->y += (int )(f->font)->height;
    } else {
#line 58
      p->x = (int )((long )p->x + b->wid);
    }
  } else {
#line 58
    p->x = (int )((long )p->x + b->wid);
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
int _frnewwid(Frame *f , Point pt , Frbox *b ) 
{ 
  int c ;
  int x ;

  {
#line 66
  c = f->r.max.x;
#line 67
  x = pt.x;
#line 68
  if (b->nrune >= 0L) {
#line 69
    return ((int )b->wid);
  }
#line 70
  if ((int )b->a.b.bc == 9) {
#line 71
    if (x + (int )b->a.b.minwid > c) {
#line 72
      pt.x = (int )f->left;
#line 72
      x = pt.x;
    }
#line 73
    x += (int )f->maxtab;
#line 74
    x -= (x - (int )f->left) % (int )f->maxtab;
#line 75
    if (x - pt.x < (int )b->a.b.minwid) {
#line 76
      x = pt.x + (int )b->a.b.minwid;
    } else
#line 75
    if (x > c) {
#line 76
      x = pt.x + (int )b->a.b.minwid;
    }
#line 77
    b->wid = (long )(x - pt.x);
  }
#line 79
  return ((int )b->wid);
}
}
#line 82 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frutil.c"
void _frclean(Frame *f , Point pt , int n0 , int n1 ) 
{ 
  Frbox *b ;
  int nb ;
  int c ;

  {
#line 88
  c = f->r.max.x;
#line 89
  nb = n0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (nb < n1 - 1)) {
#line 89
      goto while_break;
    }
    {
#line 90
    b = f->box + nb;
#line 91
    _frcklinewrap(f, & pt, b);
    }
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 92
      if ((b + 0)->nrune >= 0L) {
#line 92
        if (nb < n1 - 1) {
#line 92
          if ((b + 1)->nrune >= 0L) {
#line 92
            if (! (((long )pt.x + (b + 0)->wid) + (b + 1)->wid < (long )c)) {
#line 92
              goto while_break___0;
            }
          } else {
#line 92
            goto while_break___0;
          }
        } else {
#line 92
          goto while_break___0;
        }
      } else {
#line 92
        goto while_break___0;
      }
      {
#line 93
      _frmergebox(f, nb);
#line 94
      n1 --;
#line 95
      b = f->box + nb;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 97
    _fradvance(f, & pt, f->box + nb);
#line 89
    nb ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 99
    if (! (nb < (int )f->nbox)) {
#line 99
      goto while_break___1;
    }
    {
#line 100
    b = f->box + nb;
#line 101
    _frcklinewrap(f, & pt, b);
#line 102
    _fradvance(f, & pt, f->box + nb);
#line 99
    nb ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  f->lastlinefull = (ushort )0;
#line 105
  if (pt.y >= f->r.max.y) {
#line 106
    f->lastlinefull = (ushort )1;
  }
#line 107
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
static Bitmap *dkgrey_o  ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
static Bitmap *dkgrey_e  ;
#line 15
static Rectangle getthumb(Scroll *s , ulong extent , ulong max , ulong thumb ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
void scroll_init(void) 
{ 
  int x ;
  int y ;
  int dx ;
  int dy ;
  Rectangle tmp ;
  Point tmp___0 ;
  Rectangle tmp___1 ;
  Point tmp___2 ;

  {
  {
#line 21
  dx = 4;
#line 21
  dy = 2;
#line 23
  tmp = Rect(0, 0, dx, dy);
#line 23
  dkgrey_o = balloc(tmp, 0);
#line 24
  bitblt(dkgrey_o, dkgrey_o->r.min, dkgrey_o, dkgrey_o->r, (Fcode )15);
#line 25
  x = 0;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (x < dx)) {
#line 25
      goto while_break;
    }
#line 26
    y = (x % 4) / 2;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (y < dy)) {
#line 26
        goto while_break___0;
      }
      {
#line 27
      tmp___0 = Pt(x, y);
#line 27
      point(dkgrey_o, tmp___0, 0, (Fcode )0);
#line 26
      y += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 25
    x += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 29
  tmp___1 = Rect(0, 0, dx, dy);
#line 29
  dkgrey_e = balloc(tmp___1, 0);
#line 30
  bitblt(dkgrey_e, dkgrey_e->r.min, dkgrey_e, dkgrey_e->r, (Fcode )15);
#line 31
  x = 1;
  }
  {
#line 31
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 31
    if (! (x < dx)) {
#line 31
      goto while_break___1;
    }
#line 32
    y = (x % 4) / 2;
    {
#line 32
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 32
      if (! (y < dy)) {
#line 32
        goto while_break___2;
      }
      {
#line 33
      tmp___2 = Pt(x, y);
#line 33
      point(dkgrey_e, tmp___2, 0, (Fcode )0);
#line 32
      y += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 31
    x += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
void scroll_setrects(Scroll *s , Bitmap *b , Rectangle r ) 
{ 
  ulong tmp ;
  ulong tmp___0 ;

  {
#line 38
  if (! s) {
#line 39
    return;
  }
#line 40
  s->r = r;
#line 41
  s->b = b;
#line 42
  tmp___0 = (ulong )0;
#line 42
  s->max = tmp___0;
#line 42
  tmp = tmp___0;
#line 42
  s->extent = tmp;
#line 42
  s->thumb = tmp;
#line 43
  if (b) {
    {
#line 44
    bitblt(b, r.min, b, r, (Fcode )0);
#line 45
    border(b, r, 1, (Fcode )15);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
Scroll *scroll_alloc(Bitmap *b , Rectangle r ) 
{ 
  Scroll *s ;
  void *tmp ;

  {
  {
#line 54
  tmp = salloc((int )sizeof(Scroll ));
#line 54
  s = (Scroll *)tmp;
#line 55
  scroll_setrects(s, b, r);
  }
#line 56
  return (s);
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
void scroll_set(Scroll *s , ulong thumb , ulong extent , ulong max ) 
{ 
  Rectangle q ;
  Rectangle oldr ;
  Rectangle newr ;
  Rectangle above ;
  Rectangle below ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 63
  oldr = getthumb(s, s->extent, s->max, s->thumb);
#line 64
  below = s->r;
#line 64
  above = below;
#line 65
  above.max.y = oldr.min.y;
#line 66
  below.min.y = oldr.max.y;
#line 68
  newr = getthumb(s, extent, max, thumb);
#line 71
  q = newr;
#line 72
  tmp = rectclip(& q, above);
  }
#line 72
  if (tmp) {
    {
#line 73
    bitblt(s->b, q.min, s->b, q, (Fcode )0);
    }
  }
  {
#line 74
  q = newr;
#line 75
  tmp___0 = rectclip(& q, below);
  }
#line 75
  if (tmp___0) {
    {
#line 76
    bitblt(s->b, q.min, s->b, q, (Fcode )0);
    }
  }
  {
#line 78
  below = s->r;
#line 78
  above = below;
#line 79
  above.max.y = newr.min.y;
#line 80
  below.min.y = newr.max.y;
#line 83
  q = oldr;
#line 84
  tmp___1 = rectclip(& q, above);
  }
#line 84
  if (tmp___1) {
#line 85
    if (s->r.min.x % 2 == 0) {
      {
#line 86
      texture(s->b, q, dkgrey_e, (Fcode )12);
      }
    } else {
      {
#line 88
      texture(s->b, q, dkgrey_o, (Fcode )12);
      }
    }
  }
  {
#line 90
  q = oldr;
#line 91
  tmp___2 = rectclip(& q, below);
  }
#line 91
  if (tmp___2) {
#line 92
    if (s->r.min.x % 2 == 0) {
      {
#line 93
      texture(s->b, q, dkgrey_e, (Fcode )12);
      }
    } else {
      {
#line 95
      texture(s->b, q, dkgrey_o, (Fcode )12);
      }
    }
  }
#line 97
  s->thumb = thumb;
#line 98
  s->extent = extent;
#line 99
  s->max = max;
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
static ulong div_down(ulong p , ulong q ) 
{ 


  {
#line 104
  return (p / q);
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
static ulong div_up(ulong p , ulong q ) 
{ 


  {
#line 109
  return (((p + q) - 1UL) / q);
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/scroll.c"
static Rectangle getthumb(Scroll *s , ulong extent , ulong max , ulong thumb ) 
{ 
  Rectangle r ;
  ulong length ;
  ulong tmp ;
  ulong tmp___0 ;

  {
  {
#line 118
  r = inset(s->r, 1);
#line 121
  length = (ulong )(r.max.y - r.min.y);
  }
#line 122
  if (extent < max) {
    {
#line 123
    tmp = div_down(length * thumb, max);
#line 123
    r.min.y = (int )((ulong )r.min.y + tmp);
    }
#line 124
    if (thumb < max) {
      {
#line 125
      tmp___0 = div_up(length * extent, max);
#line 125
      r.max.y = (int )((ulong )r.min.y + tmp___0);
      }
    } else {
#line 127
      r.min.y = r.max.y;
    }
  }
#line 130
  return (r);
}
}
#line 211 "./../include/libg.h"
void arc(Bitmap *b , Point p0 , Point p1 , Point p2 , int v , Fcode f ) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/arc.c"
void arc(Bitmap *b , Point p0 , Point p1 , Point p2 , int v , Fcode f ) 
{ 
  unsigned int d ;
  int x ;
  int y ;
  int r ;
  int start ;
  int end ;
  int delta ;
  GC g ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 16
  p1.x -= p0.x;
#line 17
  p1.y -= p0.y;
#line 18
  p2.x -= p0.x;
#line 19
  p2.y -= p0.y;
#line 20
  tmp = sqrt((double )(p1.x * p1.x + p1.y * p1.y));
#line 20
  r = (int )tmp;
#line 21
  tmp___0 = atan2((double )(- p2.y), (double )p2.x);
#line 21
  start = (int )((double )11520 * (tmp___0 / 3.1415926535897932384626433832795028841971693993751));
#line 22
  tmp___1 = atan2((double )(- p1.y), (double )p1.x);
#line 22
  end = (int )((double )11520 * (tmp___1 / 3.1415926535897932384626433832795028841971693993751));
  }
#line 23
  if (start < 0) {
#line 24
    start += 23040;
  }
#line 25
  if (end < 0) {
#line 26
    end += 23040;
  }
#line 27
  delta = end - start;
#line 28
  if (delta < 0) {
#line 29
    delta += 23040;
  }
#line 30
  x = p0.x - r;
#line 31
  y = p0.y - r;
#line 32
  if (b->flag & 32) {
#line 33
    x -= b->r.min.x;
#line 34
    y -= b->r.min.y;
  }
  {
#line 36
  d = (unsigned int )(2 * r);
#line 37
  g = _getfillgc(f, b, (unsigned long )v);
#line 42
  XDrawArc(_dpy, (Drawable )b->id, g, x, y, d, d, start, delta);
  }
#line 43
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 57 "./../include/libc.h"
void fprint(int fd , char *z  , ...) ;
#line 60
int errstr(char *buf___3 ) ;
#line 61
char *getuser(void) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/misc.c"
void fprint(int fd , char *z  , ...) 
{ 
  va_list args___0 ;
  char buf___3[2048] ;
  size_t tmp ;

  {
  {
#line 19
  __builtin_va_start(args___0, z);
#line 20
  vsprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)z,
           args___0);
#line 21
  tmp = strlen((char const   *)(buf___3));
#line 21
  write(fd, (void const   *)(buf___3), tmp);
#line 22
  __builtin_va_end(args___0);
  }
#line 23
  return;
}
}
#line 54
extern int errno ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/misc.c"
int errstr(char *buf___3 ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = strerror(errno);
#line 56
  strncpy((char */* __restrict  */)buf___3, (char const   */* __restrict  */)tmp,
          (size_t )64);
  }
#line 57
  return (1);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/misc.c"
static char *user  =    (char *)0;
#line 60 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/misc.c"
char *getuser(void) 
{ 
  struct passwd *p ;
  __uid_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 67
  if (! user) {
    {
#line 68
    tmp = getuid();
#line 68
    p = getpwuid(tmp);
    }
#line 69
    if (p) {
#line 69
      if (p->pw_name) {
        {
#line 70
        tmp___0 = strlen((char const   *)p->pw_name);
#line 70
        tmp___1 = malloc(tmp___0 + 1UL);
#line 70
        user = (char *)tmp___1;
        }
#line 71
        if (user) {
          {
#line 72
          strcpy((char */* __restrict  */)user, (char const   */* __restrict  */)p->pw_name);
          }
        }
      }
    }
  }
#line 75
  if (! user) {
#line 76
    user = (char *)"unknown";
  }
#line 77
  return (user);
}
}
#line 9 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
char *notdoubleclick ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune l1[6]  = {      (Rune )'{',      (Rune )'[',      (Rune )'(',      (Rune )'<', 
        (Rune )171,      (Rune )0};
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune r1[6]  = {      (Rune )'}',      (Rune )']',      (Rune )')',      (Rune )'>', 
        (Rune )187,      (Rune )0};
#line 13 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune l2[2]  = {      (Rune )'\n',      (Rune )0};
#line 14 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune r2[2]  = {      (Rune )'\n',      (Rune )0};
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune l3[5]  = {      (Rune )'\'',      (Rune )'\"',      (Rune )'`',      (Rune )'>', 
        (Rune )0};
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune r3[5]  = {      (Rune )'\'',      (Rune )'\"',      (Rune )'`',      (Rune )'<', 
        (Rune )0};
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
Rune *left[4]  = {      l1,      l2,      l3,      (Rune *)0};
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
Rune *right[4]  = {      r1,      r2,      r3,      (Rune *)0};
#line 24 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Bool okchar(int c , char *stoplist ) 
{ 
  char *tmp ;

  {
#line 31
  if (c <= 32) {
#line 32
    return ((Bool )0);
  }
#line 33
  if (127 <= c) {
#line 33
    if (c <= 160) {
#line 34
      return ((Bool )0);
    }
  }
  {
#line 35
  tmp = utfrune(stoplist, (long )c);
  }
#line 35
  if (tmp) {
#line 36
    return ((Bool )0);
  }
#line 37
  return ((Bool )1);
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static int clickmatch(Text *t___0 , int cl , int cr , int dir ) 
{ 
  int c ;
  int nest ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 44
  nest = 1;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (dir > 0) {
#line 45
      if (t___0->pos < t___0->gap.p0) {
#line 45
        tmp = t___0->pos;
#line 45
        (t___0->pos) ++;
#line 45
        tmp___2 = (int )*(t___0->text + tmp);
      } else {
#line 45
        if (t___0->pos < t___0->length) {
#line 45
          tmp___0 = t___0->pos;
#line 45
          (t___0->pos) ++;
#line 45
          tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
        } else {
#line 45
          tmp___1 = -1;
        }
#line 45
        tmp___2 = tmp___1;
      }
#line 45
      c = tmp___2;
    } else {
#line 45
      if (t___0->pos > t___0->gap.p0) {
#line 45
        (t___0->pos) --;
#line 45
        tmp___4 = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 45
        if (t___0->pos) {
#line 45
          (t___0->pos) --;
#line 45
          tmp___3 = (int )*(t___0->text + t___0->pos);
        } else {
#line 45
          tmp___3 = -1;
        }
#line 45
        tmp___4 = tmp___3;
      }
#line 45
      c = tmp___4;
    }
#line 45
    if (! (c > 0)) {
#line 45
      goto while_break;
    }
#line 46
    if (cl == 10) {
#line 46
      if (c == 4) {
#line 47
        return (1);
      }
    }
#line 48
    if (c == cr) {
#line 49
      nest --;
#line 49
      if (nest == 0) {
#line 50
        return (1);
      }
    } else
#line 51
    if (c == cl) {
#line 52
      nest ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (cl == 10) {
#line 54
    if (nest == 1) {
#line 54
      tmp___5 = 1;
    } else {
#line 54
      tmp___5 = 0;
    }
  } else {
#line 54
    tmp___5 = 0;
  }
#line 54
  return (tmp___5);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
static Rune *strrune(Rune *s , Rune c ) 
{ 
  Rune c1 ;
  Rune *tmp ;
  Rune *tmp___0 ;

  {
#line 61
  if ((int )c == 0) {
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      tmp = s;
#line 62
      s ++;
#line 62
      if (! *tmp) {
#line 62
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 64
    return (s - 1);
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    tmp___0 = s;
#line 67
    s ++;
#line 67
    c1 = *tmp___0;
#line 67
    if (! c1) {
#line 67
      goto while_break___0;
    }
#line 68
    if ((int )c1 == (int )c) {
#line 69
      return (s - 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  return ((Rune *)0);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
Range text_expand(Text *t___0 , Range r , char *s ) 
{ 
  int c ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  Bool tmp___4 ;

  {
#line 80
  t___0->pos = r.p1;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (t___0->pos < t___0->gap.p0) {
#line 81
      tmp = t___0->pos;
#line 81
      (t___0->pos) ++;
#line 81
      c = (int )*(t___0->text + tmp);
    } else {
#line 81
      if (t___0->pos < t___0->length) {
#line 81
        tmp___0 = t___0->pos;
#line 81
        (t___0->pos) ++;
#line 81
        tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 81
        tmp___1 = -1;
      }
#line 81
      c = tmp___1;
    }
#line 81
    if (c != -1) {
      {
#line 81
      tmp___2 = okchar(c, s);
      }
#line 81
      if (! tmp___2) {
#line 81
        goto while_break;
      }
    } else {
#line 81
      goto while_break;
    }
#line 82
    (r.p1) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  t___0->pos = r.p0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (t___0->pos > t___0->gap.p0) {
#line 84
      (t___0->pos) --;
#line 84
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 84
      if (t___0->pos) {
#line 84
        (t___0->pos) --;
#line 84
        tmp___3 = (int )*(t___0->text + t___0->pos);
      } else {
#line 84
        tmp___3 = -1;
      }
#line 84
      c = tmp___3;
    }
#line 84
    if (c != -1) {
      {
#line 84
      tmp___4 = okchar(c, s);
      }
#line 84
      if (! tmp___4) {
#line 84
        goto while_break___0;
      }
    } else {
#line 84
      goto while_break___0;
    }
#line 85
    (r.p0) --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  return (r);
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
Range text_doubleclick(Text *t___0 , ulong p0 ) 
{ 
  int c ;
  int i ;
  Rune *r ;
  Rune *l ;
  Range dot ;
  ulong tmp ;
  ulong tmp___0 ;
  int tmp___1 ;
  Rune *tmp___2 ;
  int tmp___3 ;
  Rune *tmp___4 ;
  int tmp___5 ;
  ulong tmp___6 ;
  ulong tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  Rune *tmp___11 ;
  int tmp___12 ;
  Rune *tmp___13 ;
  ulong tmp___14 ;
  ulong tmp___15 ;
  int tmp___16 ;
  Bool tmp___17 ;
  int tmp___18 ;
  Bool tmp___19 ;

  {
#line 98
  if (p0 > t___0->length) {
#line 99
    return (dot);
  }
#line 100
  dot.p1 = p0;
#line 100
  dot.p0 = dot.p1;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! left[i]) {
#line 101
      goto while_break;
    }
#line 102
    l = left[i];
#line 103
    r = right[i];
#line 105
    if (p0 == 0UL) {
#line 106
      t___0->pos = p0;
#line 107
      c = '\n';
    } else {
#line 109
      t___0->pos = p0 - 1UL;
#line 110
      if (t___0->pos < t___0->gap.p0) {
#line 110
        tmp = t___0->pos;
#line 110
        (t___0->pos) ++;
#line 110
        c = (int )*(t___0->text + tmp);
      } else {
#line 110
        if (t___0->pos < t___0->length) {
#line 110
          tmp___0 = t___0->pos;
#line 110
          (t___0->pos) ++;
#line 110
          tmp___1 = (int )*(t___0->text + (tmp___0 + (t___0->gap.p1 - t___0->gap.p0)));
        } else {
#line 110
          tmp___1 = -1;
        }
#line 110
        c = tmp___1;
      }
    }
#line 112
    if (c != -1) {
      {
#line 112
      tmp___4 = strrune(l, (Rune )c);
      }
#line 112
      if (tmp___4) {
        {
#line 113
        tmp___2 = strrune(l, (Rune )c);
#line 113
        tmp___3 = clickmatch(t___0, c, (int )*(r + (tmp___2 - l)), 1);
        }
#line 113
        if (tmp___3) {
#line 114
          dot.p0 = p0;
#line 115
          dot.p1 = t___0->pos - (ulong )(c != 10);
        }
#line 117
        return (dot);
      }
    }
#line 120
    if (p0 == t___0->length) {
#line 121
      t___0->pos = p0;
#line 122
      c = '\n';
    } else {
#line 124
      t___0->pos = p0 + 1UL;
#line 125
      if (t___0->pos > t___0->gap.p0) {
#line 125
        (t___0->pos) --;
#line 125
        c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 125
        if (t___0->pos) {
#line 125
          (t___0->pos) --;
#line 125
          tmp___5 = (int )*(t___0->text + t___0->pos);
        } else {
#line 125
          tmp___5 = -1;
        }
#line 125
        c = tmp___5;
      }
    }
#line 127
    if (c != -1) {
      {
#line 127
      tmp___13 = strrune(r, (Rune )c);
      }
#line 127
      if (tmp___13) {
        {
#line 128
        tmp___11 = strrune(r, (Rune )c);
#line 128
        tmp___12 = clickmatch(t___0, c, (int )*(l + (tmp___11 - r)), -1);
        }
#line 128
        if (tmp___12) {
#line 129
          dot.p0 = t___0->pos;
#line 130
          if (c != 10) {
#line 132
            (dot.p0) ++;
          } else
#line 130
          if (t___0->pos != 0UL) {
#line 132
            (dot.p0) ++;
          } else {
#line 130
            t___0->pos = (ulong )0;
#line 130
            if (t___0->pos < t___0->gap.p0) {
#line 130
              tmp___6 = t___0->pos;
#line 130
              (t___0->pos) ++;
#line 130
              tmp___9 = (int )*(t___0->text + tmp___6);
            } else {
#line 130
              if (t___0->pos < t___0->length) {
#line 130
                tmp___7 = t___0->pos;
#line 130
                (t___0->pos) ++;
#line 130
                tmp___8 = (int )*(t___0->text + (tmp___7 + (t___0->gap.p1 - t___0->gap.p0)));
              } else {
#line 130
                tmp___8 = -1;
              }
#line 130
              tmp___9 = tmp___8;
            }
#line 130
            if (tmp___9 == 10) {
#line 132
              (dot.p0) ++;
            }
          }
#line 133
          if (p0 < t___0->length) {
#line 133
            if (c == 10) {
#line 133
              tmp___10 = 1;
            } else {
#line 133
              tmp___10 = 0;
            }
          } else {
#line 133
            tmp___10 = 0;
          }
#line 133
          dot.p1 = p0 + (ulong )tmp___10;
        }
#line 135
        return (dot);
      }
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  t___0->pos = p0;
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (t___0->pos < t___0->gap.p0) {
#line 140
      tmp___14 = t___0->pos;
#line 140
      (t___0->pos) ++;
#line 140
      c = (int )*(t___0->text + tmp___14);
    } else {
#line 140
      if (t___0->pos < t___0->length) {
#line 140
        tmp___15 = t___0->pos;
#line 140
        (t___0->pos) ++;
#line 140
        tmp___16 = (int )*(t___0->text + (tmp___15 + (t___0->gap.p1 - t___0->gap.p0)));
      } else {
#line 140
        tmp___16 = -1;
      }
#line 140
      c = tmp___16;
    }
#line 140
    if (c != -1) {
      {
#line 140
      tmp___17 = okchar(c, notdoubleclick);
      }
#line 140
      if (! tmp___17) {
#line 140
        goto while_break___0;
      }
    } else {
#line 140
      goto while_break___0;
    }
#line 141
    (dot.p1) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  t___0->pos = p0;
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 144
    if (t___0->pos > t___0->gap.p0) {
#line 144
      (t___0->pos) --;
#line 144
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 144
      if (t___0->pos) {
#line 144
        (t___0->pos) --;
#line 144
        tmp___18 = (int )*(t___0->text + t___0->pos);
      } else {
#line 144
        tmp___18 = -1;
      }
#line 144
      c = tmp___18;
    }
#line 144
    if (c != -1) {
      {
#line 144
      tmp___19 = okchar(c, notdoubleclick);
      }
#line 144
      if (! tmp___19) {
#line 144
        goto while_break___1;
      }
    } else {
#line 144
      goto while_break___1;
    }
#line 145
    (dot.p0) --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 146
  return (dot);
}
}
#line 152 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/click.c"
ulong text_startofword(Text *t___0 , ulong p0 ) 
{ 
  int c ;
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;

  {
#line 156
  t___0->pos = p0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (t___0->pos > t___0->gap.p0) {
#line 159
      (t___0->pos) --;
#line 159
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 159
      if (t___0->pos) {
#line 159
        (t___0->pos) --;
#line 159
        tmp = (int )*(t___0->text + t___0->pos);
      } else {
#line 159
        tmp = -1;
      }
#line 159
      c = tmp;
    }
#line 159
    if (c != -1) {
#line 159
      if (c != 10) {
        {
#line 159
        tmp___0 = okchar(c, notdoubleclick);
        }
#line 159
        if (tmp___0) {
#line 159
          goto while_break;
        }
      } else {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (c == 10) {
#line 161
    if (t___0->pos != p0 - 1UL) {
#line 162
      return (t___0->pos + 1UL);
    }
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (t___0->pos > t___0->gap.p0) {
#line 163
      (t___0->pos) --;
#line 163
      c = (int )*(t___0->text + (t___0->pos + (t___0->gap.p1 - t___0->gap.p0)));
    } else {
#line 163
      if (t___0->pos) {
#line 163
        (t___0->pos) --;
#line 163
        tmp___1 = (int )*(t___0->text + t___0->pos);
      } else {
#line 163
        tmp___1 = -1;
      }
#line 163
      c = tmp___1;
    }
#line 163
    if (c != -1) {
      {
#line 163
      tmp___2 = okchar(c, notdoubleclick);
      }
#line 163
      if (! tmp___2) {
#line 163
        goto while_break___0;
      }
    } else {
#line 163
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return (t___0->pos + (ulong )(c != -1));
}
}
#line 3221 "/usr/include/X11/Xlib.h"
extern int XSetFillStyle(Display * , GC  , int  ) ;
#line 3320
extern int XSetStipple(Display * , GC  , Pixmap  ) ;
#line 3332
extern int XSetTSOrigin(Display * , GC  , int  , int  ) ;
#line 3339
extern int XSetTile(Display * , GC  , Pixmap  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/texture.c"
void texture(Bitmap *d , Rectangle r , Bitmap *s , Fcode f ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  int bfunc ;
  GC g ;

  {
#line 12
  x = r.min.x;
#line 13
  y = r.min.y;
#line 14
  if (d->flag & 32) {
#line 15
    x -= d->r.min.x;
#line 16
    y -= d->r.min.y;
  }
  {
#line 18
  g = _getcopygc(f, d, s, & bfunc);
  }
#line 19
  if (d->flag & 32) {
    {
#line 20
    XSetTSOrigin(_dpy, g, - d->r.min.x, - d->r.min.y);
    }
  } else {
    {
#line 22
    XSetTSOrigin(_dpy, g, 0, 0);
    }
  }
#line 23
  w = r.max.x - r.min.x;
#line 24
  h = r.max.y - r.min.y;
#line 25
  if (bfunc == 2) {
    {
#line 27
    XFillRectangle(_dpy, (Drawable )d->id, g, x, y, (unsigned int )w, (unsigned int )h);
    }
  } else
#line 28
  if (bfunc == 0) {
    {
#line 29
    XSetTile(_dpy, g, (Drawable )s->id);
#line 30
    XSetFillStyle(_dpy, g, 1);
#line 31
    XFillRectangle(_dpy, (Drawable )d->id, g, x, y, (unsigned int )w, (unsigned int )h);
#line 32
    XSetFillStyle(_dpy, g, 0);
    }
  } else {
#line 34
    if (s->ldepth != 0) {
      {
#line 35
      berror((char *)"unsupported texture");
      }
    }
    {
#line 36
    XSetStipple(_dpy, g, (Drawable )s->id);
#line 37
    XSetFillStyle(_dpy, g, 3);
#line 38
    XFillRectangle(_dpy, (Drawable )d->id, g, x, y, (unsigned int )w, (unsigned int )h);
#line 39
    XSetFillStyle(_dpy, g, 0);
    }
  }
#line 41
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/proto.h"
void tag_modified(Text *t___0 , ulong p ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
static void setgap(Text *t___0 , ulong p , int n ) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
Bool text_invariants(Text *t___0 ) 
{ 


  {
#line 49
  return ((Bool )1);
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
int text_read(Text *t___0 , int fd , int len ) 
{ 
  int desired ;
  int nread ;
  char buf___3[10240] ;
  int offset ;
  void *tmp ;
  ssize_t tmp___0 ;
  ulong tmp___1 ;

  {
#line 66
  desired = (int )((unsigned long )len * sizeof(Rune ) + 512UL);
#line 67
  if (t___0->alloced < (ulong )desired) {
    {
#line 68
    t___0->alloced = (ulong )desired;
#line 69
    free((void *)t___0->text);
#line 70
    tmp = salloc((int )(t___0->alloced * sizeof(Rune )));
#line 70
    t___0->text = (Rune *)tmp;
    }
  }
#line 72
  t___0->length = (ulong )0;
#line 73
  t___0->pos = (ulong )0;
#line 74
  offset = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (len > 0)) {
#line 75
      goto while_break;
    }
#line 76
    if (len < 10240 - offset) {
#line 76
      desired = len;
    } else {
#line 76
      desired = 10240 - offset;
    }
    {
#line 77
    tmp___0 = read(fd, (void *)(buf___3 + offset), (size_t )desired);
#line 77
    nread = (int )tmp___0;
    }
#line 78
    if (nread <= 0) {
#line 79
      return (-1);
    }
    {
#line 80
    tmp___1 = utftotext(t___0->text + t___0->length, buf___3, (buf___3 + nread) + offset);
#line 80
    t___0->length += tmp___1;
#line 81
    len -= nread;
#line 88
    offset = utftotext_unconverted;
    }
#line 88
    if (offset) {
      {
#line 89
      memcpy((void */* __restrict  */)(buf___3), (void const   */* __restrict  */)((buf___3 + desired) - offset),
             (size_t )offset);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  t___0->gap = range(t___0->length, t___0->alloced);
#line 93
  undo_reset(t___0);
#line 94
  undo_start(t___0);
#line 95
  close(fd);
#line 96
  viewlist_refresh(t___0->v);
  }
#line 97
  return (0);
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
static int utfwrite(Rune *r0 , Rune *r1___0 , int fd ) 
{ 
  char buf___3[10243] ;
  Rune *p ;
  char *t___0 ;
  int nwrite ;
  int nwritten ;
  Rune *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 114
  p = r0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((unsigned long )p < (unsigned long )r1___0)) {
#line 115
      goto while_break;
    }
#line 116
    t___0 = buf___3;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if ((unsigned long )p < (unsigned long )r1___0) {
#line 117
        if (! ((unsigned long )t___0 < (unsigned long )(buf___3 + 10240))) {
#line 117
          goto while_break___0;
        }
      } else {
#line 117
        goto while_break___0;
      }
      {
#line 118
      tmp = p;
#line 118
      p ++;
#line 118
      tmp___0 = runetochar(t___0, tmp);
#line 118
      t___0 += tmp___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 120
    nwrite = (int )(t___0 - buf___3);
#line 121
    t___0 = buf___3;
    {
#line 121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 121
      if (! (nwrite > 0)) {
#line 121
        goto while_break___1;
      }
      {
#line 122
      tmp___1 = write(fd, (void const   *)t___0, (size_t )nwrite);
#line 122
      nwritten = (int )tmp___1;
      }
#line 123
      if (nwritten <= 0) {
#line 124
        return (-1);
      }
#line 121
      nwrite -= nwritten;
#line 121
      t___0 += nwritten;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
void gaptranslate(Range r , Range gap , Range *before , Range *after ) 
{ 
  Range NULLRANGE ;
  ulong tmp ;
  Range tmp___0 ;
  ulong tmp___1 ;
  Range tmp___2 ;

  {
#line 132
  NULLRANGE.p0 = (ulong )0;
#line 132
  NULLRANGE.p1 = (ulong )0;
#line 135
  if (r.p0 < gap.p0) {
#line 135
    if (r.p1 < gap.p0) {
#line 135
      tmp = r.p1;
    } else {
#line 135
      tmp = gap.p0;
    }
    {
#line 135
    tmp___0 = range(r.p0, tmp);
#line 135
    *before = tmp___0;
    }
  } else {
#line 135
    *before = NULLRANGE;
  }
#line 139
  if (r.p1 > gap.p0) {
#line 139
    if (gap.p1 > r.p0 + (gap.p1 - gap.p0)) {
#line 139
      tmp___1 = gap.p1;
    } else {
#line 139
      tmp___1 = r.p0 + (gap.p1 - gap.p0);
    }
    {
#line 139
    tmp___2 = range(tmp___1, r.p1 + (gap.p1 - gap.p0));
#line 139
    *after = tmp___2;
    }
  } else {
#line 139
    *after = NULLRANGE;
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
int text_write_range(Text *t___0 , Range r , int fd ) 
{ 
  Range b ;
  Range a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 149
  gaptranslate(r, t___0->gap, & b, & a);
#line 150
  tmp = utfwrite(t___0->text + b.p0, t___0->text + b.p1, fd);
  }
#line 150
  if (tmp) {
#line 150
    tmp___1 = 1;
  } else {
    {
#line 150
    tmp___0 = utfwrite(t___0->text + a.p0, t___0->text + a.p1, fd);
    }
#line 150
    if (tmp___0) {
#line 150
      tmp___1 = 1;
    } else {
#line 150
      tmp___1 = 0;
    }
  }
#line 150
  return (tmp___1);
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
void text_copy(Text *t___0 , Range r , Rune *buf___3 ) 
{ 
  Range b ;
  Range a ;
  ulong bsize ;

  {
  {
#line 164
  gaptranslate(r, t___0->gap, & b, & a);
#line 165
  bsize = b.p1 - b.p0;
#line 166
  memcpy((void */* __restrict  */)buf___3, (void const   */* __restrict  */)(t___0->text + b.p0),
         bsize * sizeof(Rune ));
#line 167
  buf___3 += bsize;
#line 168
  memcpy((void */* __restrict  */)buf___3, (void const   */* __restrict  */)(t___0->text + a.p0),
         (a.p1 - a.p0) * sizeof(Rune ));
  }
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
Text *text_alloc(Data *d , Bool isbody ) 
{ 
  Text *t___0 ;
  void *tmp ;
  Undo *tmp___0 ;
  Undo *tmp___1 ;

  {
  {
#line 176
  tmp = salloc((int )sizeof(Text ));
#line 176
  t___0 = (Text *)tmp;
#line 177
  t___0->alloced = (ulong )0;
#line 178
  t___0->text = (Rune *)0;
#line 179
  t___0->length = (ulong )0;
#line 180
  t___0->pos = (ulong )0;
#line 182
  t___0->gap = nr;
#line 183
  t___0->data = d;
#line 184
  t___0->isbody = isbody;
#line 185
  t___0->v = (View *)0;
#line 186
  tmp___1 = (Undo *)0;
#line 186
  t___0->mark = tmp___1;
#line 186
  tmp___0 = tmp___1;
#line 186
  t___0->undone = tmp___0;
#line 186
  t___0->did = tmp___0;
#line 187
  t___0->undoing = (enum __anonenum_undoing_61 )0;
#line 188
  t___0->needsbackup = (Bool )0;
  }
#line 189
  return (t___0);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
Range text_replace(Text *t___0 , Range r , Rstring s ) 
{ 
  ulong rlen ;
  ulong rslen ;
  int delta ;

  {
#line 198
  rlen = r.p1 - r.p0;
#line 199
  rslen = (ulong )(s.r1 - s.r0);
#line 200
  delta = (int )(rslen - rlen);
#line 206
  if (! (r.p1 - r.p0)) {
#line 206
    if (! (s.r1 - s.r0)) {
#line 207
      return (r);
    }
  }
  {
#line 209
  undo_record(t___0, r, s);
  }
#line 210
  if (t___0->gap.p0 != r.p0) {
    {
#line 211
    setgap(t___0, r.p0, delta);
    }
  } else
#line 210
  if (t___0->gap.p1 - t___0->gap.p0 < (ulong )delta) {
    {
#line 211
    setgap(t___0, r.p0, delta);
    }
  }
  {
#line 212
  memcpy((void */* __restrict  */)(t___0->text + t___0->gap.p0), (void const   */* __restrict  */)s.r0,
         rslen * sizeof(Rune ));
#line 213
  t___0->gap.p1 += rlen;
#line 214
  t___0->gap.p0 += rslen;
#line 215
  t___0->length += (ulong )delta;
#line 219
  viewlist_replace(t___0->v, r, s);
  }
#line 222
  if (t___0->data) {
#line 223
    if (! t___0->isbody) {
      {
#line 224
      tag_modified(t___0, r.p0);
      }
    } else {
      {
#line 226
      data_sendreplace(t___0->data, r, s);
      }
    }
  }
#line 229
  r.p1 = r.p0 + rslen;
#line 231
  return (r);
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
void text_free(Text *t___0 ) 
{ 


  {
  {
#line 239
  undo_free(t___0);
  }
#line 240
  if (t___0->text) {
    {
#line 241
    free((void *)t___0->text);
    }
  }
#line 242
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
static void movegap(Text *t___0 , ulong p ) 
{ 


  {
#line 251
  if (p < t___0->gap.p0) {
    {
#line 252
    memmove((void *)((t___0->text + p) + (t___0->gap.p1 - t___0->gap.p0)), (void const   *)(t___0->text + p),
            (t___0->gap.p0 - p) * sizeof(Rune ));
#line 255
    t___0->gap.p1 -= t___0->gap.p0 - p;
#line 256
    t___0->gap.p0 = p;
    }
  } else
#line 257
  if (p > t___0->gap.p0) {
    {
#line 258
    memmove((void *)(t___0->text + t___0->gap.p0), (void const   *)(t___0->text + t___0->gap.p1),
            (p - t___0->gap.p0) * sizeof(Rune ));
#line 261
    t___0->gap.p1 = p + (t___0->gap.p1 - t___0->gap.p0);
#line 262
    t___0->gap.p0 = p;
    }
  }
#line 265
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/text.c"
static void setgap(Text *t___0 , ulong p , int n ) 
{ 
  int extra ;
  void *tmp ;

  {
  {
#line 274
  movegap(t___0, p);
#line 277
  extra = (int )((ulong )n - (t___0->gap.p1 - t___0->gap.p0));
  }
#line 278
  if (extra <= 0) {
#line 279
    return;
  }
  {
#line 282
  extra += 512;
#line 283
  t___0->alloced += (ulong )extra;
#line 284
  tmp = srealloc((void *)t___0->text, (int )(t___0->alloced * sizeof(Rune )));
#line 284
  t___0->text = (Rune *)tmp;
#line 287
  memmove((void *)((t___0->text + t___0->gap.p1) + extra), (void const   *)(t___0->text + t___0->gap.p1),
          ((t___0->alloced - (ulong )extra) - t___0->gap.p1) * sizeof(Rune ));
#line 290
  t___0->gap.p1 += (ulong )extra;
  }
#line 292
  return;
}
}
#line 233 "./../include/libg.h"
int clipline(Rectangle r , Point *p0 , Point *p1 ) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
int _clipline(Rectangle r , Point *p0 , Point *p1 , Linedesc *l ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
static long lfloor(long x , long y ) 
{ 


  {
#line 24
  if (y <= 0L) {
#line 25
    if (y == 0L) {
#line 26
      return (x);
    }
#line 27
    y = - y;
#line 28
    x = - x;
  }
#line 30
  if (x < 0L) {
#line 31
    x = - x;
#line 32
    x += y - 1L;
#line 33
    return (- (x / y));
  }
#line 35
  return (x / y);
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
static long lceil(long x , long y ) 
{ 


  {
#line 41
  if (y <= 0L) {
#line 42
    if (y == 0L) {
#line 43
      return (x);
    }
#line 44
    y = - y;
#line 45
    x = - x;
  }
#line 47
  if (x < 0L) {
#line 48
    x = - x;
#line 49
    return (- (x / y));
  }
#line 51
  x += y - 1L;
#line 52
  return (x / y);
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
int _gminor(long x , Linedesc *l ) 
{ 
  long y ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 60
  y = (2L * (x - (long )l->x0)) * l->dminor + l->dmajor;
#line 61
  tmp = lfloor(y, 2L * l->dmajor);
#line 61
  y = tmp + (long )l->y0;
  }
#line 62
  if (l->slopeneg) {
#line 62
    tmp___0 = - y;
  } else {
#line 62
    tmp___0 = y;
  }
#line 62
  return ((int )tmp___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
int _gmajor(long y , Linedesc *l ) 
{ 
  long x ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if (l->slopeneg) {
#line 70
    tmp = - y;
  } else {
#line 70
    tmp = y;
  }
  {
#line 70
  x = (2L * (tmp - (long )l->y0)) * l->dmajor - l->dminor;
#line 71
  tmp___0 = lceil(x, 2L * l->dminor);
#line 71
  x = tmp___0 + (long )l->x0;
  }
#line 72
  if (l->dminor) {
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 73
      tmp___1 = _gminor(x - 1L, l);
      }
#line 73
      if (! ((long )tmp___1 == y)) {
#line 73
        goto while_break;
      }
#line 74
      x --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 75
  return ((int )x);
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
void gsetline(Point *pp0 , Point *pp1 , Linedesc *l ) 
{ 
  long dx ;
  long dy ;
  long t___0 ;
  int swapped ;
  Point p0 ;
  Point p1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 86
  swapped = 0;
#line 87
  p0 = *pp0;
#line 88
  p1 = *pp1;
#line 89
  l->xmajor = (char)1;
#line 90
  l->slopeneg = (char)0;
#line 91
  dx = (long )(p1.x - p0.x);
#line 92
  dy = (long )(p1.y - p0.y);
#line 93
  tmp = abs((int )dy);
#line 93
  tmp___0 = abs((int )dx);
  }
#line 93
  if (tmp > tmp___0) {
#line 94
    l->xmajor = (char)0;
#line 95
    t___0 = (long )p0.x;
#line 95
    p0.x = p0.y;
#line 95
    p0.y = (int )t___0;
#line 96
    t___0 = (long )p1.x;
#line 96
    p1.x = p1.y;
#line 96
    p1.y = (int )t___0;
#line 97
    t___0 = dx;
#line 97
    dx = dy;
#line 97
    dy = t___0;
  }
#line 99
  if (dx < 0L) {
#line 100
    swapped ++;
#line 101
    t___0 = (long )p0.x;
#line 101
    p0.x = p1.x;
#line 101
    p1.x = (int )t___0;
#line 102
    t___0 = (long )p0.y;
#line 102
    p0.y = p1.y;
#line 102
    p1.y = (int )t___0;
#line 103
    dx = - dx;
#line 104
    dy = - dy;
  }
#line 106
  if (dy < 0L) {
#line 107
    l->slopeneg = (char)1;
#line 108
    dy = - dy;
#line 109
    p0.y = - p0.y;
  }
#line 111
  l->dminor = dy;
#line 112
  l->dmajor = dx;
#line 113
  l->x0 = p0.x;
#line 114
  l->y0 = p0.y;
#line 115
  if (swapped) {
#line 115
    p1.x = p0.x + 1;
  } else {
#line 115
    (p1.x) --;
  }
  {
#line 116
  p1.y = _gminor((long )p1.x, l);
  }
#line 117
  if ((int )l->xmajor == 0) {
#line 118
    t___0 = (long )p0.x;
#line 118
    p0.x = p0.y;
#line 118
    p0.y = (int )t___0;
#line 119
    t___0 = (long )p1.x;
#line 119
    p1.x = p1.y;
#line 119
    p1.y = (int )t___0;
  }
#line 121
  if (pp0->x > pp1->x) {
#line 122
    *pp1 = *pp0;
#line 123
    *pp0 = p1;
  } else {
#line 125
    *pp1 = p1;
  }
#line 126
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
static int code(Point *p , Rectangle *r ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 138
  if (p->x < r->min.x) {
#line 138
    tmp___0 = 1;
  } else {
#line 138
    if (p->x >= r->max.x) {
#line 138
      tmp = 2;
    } else {
#line 138
      tmp = 0;
    }
#line 138
    tmp___0 = tmp;
  }
#line 138
  if (p->y < r->min.y) {
#line 138
    tmp___2 = 4;
  } else {
#line 138
    if (p->y >= r->max.y) {
#line 138
      tmp___1 = 8;
    } else {
#line 138
      tmp___1 = 0;
    }
#line 138
    tmp___2 = tmp___1;
  }
#line 138
  return (tmp___0 | tmp___2);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
int clipline(Rectangle r , Point *p0 , Point *p1 ) 
{ 
  Linedesc l ;
  int tmp ;

  {
  {
#line 147
  tmp = _clipline(r, p0, p1, & l);
  }
#line 147
  return (tmp);
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/clipline.c"
int _clipline(Rectangle r , Point *p0 , Point *p1 , Linedesc *l ) 
{ 
  int c0 ;
  int c1 ;
  int n ;
  long t___0 ;
  long ret ;
  Point temp ;
  int swapped ;
  int tmp ;
  int tmp___0 ;

  {
#line 158
  if (p0->x == p1->x) {
#line 158
    if (p0->y == p1->y) {
#line 159
      return (0);
    }
  }
  {
#line 160
  gsetline(p0, p1, l);
  }
#line 162
  if ((int )l->xmajor == 0) {
#line 163
    t___0 = (long )p0->x;
#line 163
    p0->x = p0->y;
#line 163
    p0->y = (int )t___0;
#line 164
    t___0 = (long )p1->x;
#line 164
    p1->x = p1->y;
#line 164
    p1->y = (int )t___0;
#line 165
    t___0 = (long )r.min.x;
#line 165
    r.min.x = r.min.y;
#line 165
    r.min.y = (int )t___0;
#line 166
    t___0 = (long )r.max.x;
#line 166
    r.max.x = r.max.y;
#line 166
    r.max.y = (int )t___0;
  }
  {
#line 168
  c0 = code(p0, & r);
#line 169
  c1 = code(p1, & r);
#line 170
  ret = 1L;
#line 171
  swapped = 0;
#line 172
  n = 0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (c0 | c1)) {
#line 173
      goto while_break;
    }
#line 174
    if (c0 & c1) {
#line 175
      ret = 0L;
#line 176
      goto Return;
    }
#line 178
    n ++;
#line 178
    if (n > 10) {
#line 179
      ret = 0L;
#line 180
      goto Return;
    }
#line 182
    if (c0 == 0) {
#line 183
      temp = *p0;
#line 184
      *p0 = *p1;
#line 185
      *p1 = temp;
#line 186
      t___0 = (long )c0;
#line 186
      c0 = c1;
#line 186
      c1 = (int )t___0;
#line 187
      swapped ^= 1;
    }
#line 189
    if (c0 == 0) {
#line 190
      goto while_break;
    }
#line 191
    if (c0 & 1) {
      {
#line 192
      p0->x = r.min.x;
#line 193
      p0->y = _gminor((long )p0->x, l);
      }
    } else
#line 194
    if (c0 & 2) {
      {
#line 195
      p0->x = r.max.x - 1;
#line 196
      p0->y = _gminor((long )p0->x, l);
      }
    } else
#line 197
    if (c0 & 4) {
#line 198
      p0->y = r.min.y;
#line 199
      if (l->slopeneg) {
        {
#line 200
        tmp = _gmajor((long )(p0->y - 1), l);
#line 200
        p0->x = tmp - 1;
        }
      } else {
        {
#line 202
        p0->x = _gmajor((long )p0->y, l);
        }
      }
    } else
#line 203
    if (c0 & 8) {
#line 204
      p0->y = r.max.y - 1;
#line 205
      if (l->slopeneg) {
        {
#line 206
        p0->x = _gmajor((long )p0->y, l);
        }
      } else {
        {
#line 208
        tmp___0 = _gmajor((long )(p0->y + 1), l);
#line 208
        p0->x = tmp___0 - 1;
        }
      }
    }
    {
#line 210
    c0 = code(p0, & r);
    }
  }
  while_break: /* CIL Label */ ;
  }
  Return: 
#line 214
  if ((int )l->xmajor == 0) {
#line 215
    t___0 = (long )p0->x;
#line 215
    p0->x = p0->y;
#line 215
    p0->y = (int )t___0;
#line 216
    t___0 = (long )p1->x;
#line 216
    p1->x = p1->y;
#line 216
    p1->y = (int )t___0;
  }
#line 218
  if (swapped) {
#line 219
    temp = *p0;
#line 220
    *p0 = *p1;
#line 221
    *p1 = temp;
  }
#line 223
  return ((int )ret);
}
}
#line 41 "./../include/frame.h"
void frselect(Frame *f , Mouse *m ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frselect.c"
void frselect(Frame *f , Mouse *m ) 
{ 
  ulong p0 ;
  ulong p1 ;
  ulong q ;
  Point mp ;
  Point pt0 ;
  Point pt1 ;
  Point qt ;
  int b ;

  {
#line 14
  b = m->buttons;
#line 15
  mp = m->xy;
  Again: 
  {
#line 18
  f->modified = (ushort )0;
#line 19
  frselectp(f, (Fcode )5);
#line 20
  p1 = frcharofpt(f, mp);
#line 20
  p0 = p1;
#line 21
  pt0 = frptofchar(f, p0);
#line 22
  pt1 = frptofchar(f, p1);
#line 23
  frselectf(f, pt0, pt1, (Fcode )5);
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (f->modified) {
#line 26
      goto Again;
    }
    {
#line 27
    q = frcharofpt(f, m->xy);
    }
#line 28
    if (p1 != q) {
#line 29
      if (p0 == p1) {
        {
#line 30
        frselectf(f, pt0, pt1, (Fcode )5);
        }
      }
      {
#line 31
      qt = frptofchar(f, q);
      }
#line 32
      if (p1 < q) {
        {
#line 33
        frselectf(f, pt1, qt, (Fcode )5);
        }
      } else {
        {
#line 35
        frselectf(f, qt, pt1, (Fcode )5);
        }
      }
#line 36
      p1 = q;
#line 37
      pt1 = qt;
#line 38
      if (p0 == p1) {
        {
#line 39
        frselectf(f, pt0, pt1, (Fcode )5);
        }
      }
    }
#line 41
    f->modified = (ushort )0;
#line 42
    if (p0 < p1) {
#line 43
      f->p0 = p0;
#line 43
      f->p1 = p1;
    } else {
#line 45
      f->p0 = p1;
#line 45
      f->p1 = p0;
    }
    {
#line 46
    frgetmouse();
    }
#line 24
    if (! (m->buttons == b)) {
#line 24
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frselect.c"
void frselectf(Frame *f , Point p0 , Point p1 , Fcode c ) 
{ 
  int n ;
  Point q0 ;
  Point q1 ;
  Rectangle tmp ;
  Rectangle tmp___0 ;
  Rectangle tmp___1 ;
  Point tmp___2 ;
  Rectangle tmp___3 ;
  Point tmp___4 ;

  {
#line 56
  if (p0.x == (int )f->left) {
#line 57
    p0.x = f->r.min.x;
  }
#line 58
  if (p1.x == (int )f->left) {
#line 59
    p1.x = f->r.min.x;
  }
#line 60
  q0 = p0;
#line 61
  q1 = p1;
#line 62
  q0.y += (int )(f->font)->height;
#line 63
  q1.y += (int )(f->font)->height;
#line 64
  n = (p1.y - p0.y) / (int )(f->font)->height;
#line 65
  if ((unsigned long )f->b == (unsigned long )((Bitmap *)0)) {
    {
#line 66
    berror((char *)"frselectf b==0");
    }
  }
#line 67
  if (p0.y == f->r.max.y) {
#line 68
    return;
  }
#line 69
  if (n == 0) {
#line 70
    if (p0.x == p1.x) {
#line 71
      if (p0.x == f->r.min.x) {
#line 72
        (q1.x) ++;
      } else {
#line 74
        (p0.x) --;
      }
    }
    {
#line 75
    tmp = Rpt(p0, q1);
#line 75
    bitblt(f->b, p0, f->b, tmp, c);
    }
  } else {
#line 77
    if (p0.x >= f->r.max.x) {
#line 78
      p0.x = f->r.max.x - 1;
    }
    {
#line 79
    tmp___0 = Rect(p0.x, p0.y, f->r.max.x, q0.y);
#line 79
    bitblt(f->b, p0, f->b, tmp___0, c);
    }
#line 80
    if (n > 1) {
      {
#line 81
      tmp___1 = Rect(f->r.min.x, q0.y, f->r.max.x, p1.y);
#line 81
      tmp___2 = Pt(f->r.min.x, q0.y);
#line 81
      bitblt(f->b, tmp___2, f->b, tmp___1, c);
      }
    }
    {
#line 83
    tmp___3 = Rect(f->r.min.x, p1.y, q1.x, q1.y);
#line 83
    tmp___4 = Pt(f->r.min.x, p1.y);
#line 83
    bitblt(f->b, tmp___4, f->b, tmp___3, c);
    }
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libframe/frselect.c"
void frselectp(Frame *f , Fcode c ) 
{ 
  Point pt0 ;
  Point pt1 ;
  Point tmp ;

  {
  {
#line 93
  pt0 = frptofchar(f, f->p0);
  }
#line 94
  if (f->p0 == f->p1) {
#line 94
    pt1 = pt0;
  } else {
    {
#line 94
    tmp = frptofchar(f, f->p1);
#line 94
    pt1 = tmp;
    }
  }
  {
#line 95
  frselectf(f, pt0, pt1, c);
  }
#line 96
  return;
}
}
#line 2446 "/usr/include/X11/Xlib.h"
extern int XDrawText16(Display * , Drawable  , GC  , int  , int  , XTextItem16 * ,
                       int  ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/string.c"
Point string(Bitmap *b , Point p , Font___0 *ft , char *s , Fcode f ) 
{ 
  int x ;
  int y ;
  int wid ;
  int i ;
  int j ;
  int n ;
  int nti ;
  int cf ;
  XChar2b cbuf[128] ;
  unsigned short fbuf[128] ;
  XTextItem16 ti[128] ;
  Rune r ;
  GC g ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 18
  x = p.x;
#line 19
  y = p.y;
#line 20
  if (b->flag & 32) {
#line 21
    x -= b->r.min.x;
#line 22
    y -= b->r.min.y;
  }
  {
#line 24
  y += (int )ft->ascent;
#line 25
  g = _getfillgc(f, b, (unsigned long )(~ 0));
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! *s) {
#line 27
      goto while_break;
    }
    {
#line 28
    n = cachechars(ft, & s, (void *)(cbuf), 128, & wid, fbuf);
    }
#line 29
    if (n <= 0) {
      {
#line 30
      tmp = chartorune(& r, s);
#line 30
      s += tmp;
      }
#line 31
      goto while_continue;
    }
#line 33
    nti = 0;
#line 34
    cf = (int )fbuf[0];
#line 35
    ti[0].chars = cbuf;
#line 36
    ti[0].delta = 0;
#line 37
    ti[0].font = (Font )((ft->subf + cf)->f)->id;
#line 38
    i = 1;
#line 38
    j = 1;
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      if (! (i < n)) {
#line 38
        goto while_break___0;
      }
#line 39
      if ((int )fbuf[i] != cf) {
#line 40
        cf = (int )fbuf[i];
#line 41
        tmp___0 = nti;
#line 41
        nti ++;
#line 41
        ti[tmp___0].nchars = j;
#line 42
        ti[nti].chars = & cbuf[i];
#line 43
        ti[nti].delta = 0;
#line 44
        ti[nti].font = (Font )((ft->subf + cf)->f)->id;
#line 45
        j = 0;
      }
#line 38
      i ++;
#line 38
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 48
    tmp___1 = nti;
#line 48
    nti ++;
#line 48
    ti[tmp___1].nchars = j;
#line 49
    XDrawText16(_dpy, (Drawable )b->id, g, x, y, ti, nti);
#line 50
    x += wid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (b->flag & 32) {
#line 52
    p.x = x + b->r.min.x;
  } else {
#line 52
    p.x = x;
  }
#line 53
  return (p);
}
}
#line 201 "./../include/libg.h"
int bitbltclip(void *vp ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/libXg/bitbltclip.c"
int bitbltclip(void *vp ) 
{ 
  int dx ;
  int dy ;
  int i ;
  struct bbcarg *bp ;
  int tmp ;

  {
#line 19
  bp = (struct bbcarg *)vp;
#line 20
  dx = bp->r.max.x - bp->r.min.x;
#line 21
  dy = bp->r.max.y - bp->r.min.y;
#line 22
  if (bp->p.x < (bp->dm)->clipr.min.x) {
#line 23
    i = (bp->dm)->clipr.min.x - bp->p.x;
#line 24
    bp->r.min.x += i;
#line 25
    bp->p.x += i;
#line 26
    dx -= i;
  }
#line 28
  if (bp->p.y < (bp->dm)->clipr.min.y) {
#line 29
    i = (bp->dm)->clipr.min.y - bp->p.y;
#line 30
    bp->r.min.y += i;
#line 31
    bp->p.y += i;
#line 32
    dy -= i;
  }
#line 34
  if (bp->p.x + dx > (bp->dm)->clipr.max.x) {
#line 35
    i = (bp->p.x + dx) - (bp->dm)->clipr.max.x;
#line 36
    bp->r.max.x -= i;
#line 37
    dx -= i;
  }
#line 39
  if (bp->p.y + dy > (bp->dm)->clipr.max.y) {
#line 40
    i = (bp->p.y + dy) - (bp->dm)->clipr.max.y;
#line 41
    bp->r.max.y -= i;
#line 42
    dy -= i;
  }
#line 44
  if (bp->r.min.x < (bp->sm)->clipr.min.x) {
#line 45
    i = (bp->sm)->clipr.min.x - bp->r.min.x;
#line 46
    bp->p.x += i;
#line 47
    bp->r.min.x += i;
#line 48
    dx -= i;
  }
#line 50
  if (bp->r.min.y < (bp->sm)->clipr.min.y) {
#line 51
    i = (bp->sm)->clipr.min.y - bp->r.min.y;
#line 52
    bp->p.y += i;
#line 53
    bp->r.min.y += i;
#line 54
    dy -= i;
  }
#line 56
  if (bp->r.max.x > (bp->sm)->clipr.max.x) {
#line 57
    i = bp->r.max.x - (bp->sm)->clipr.max.x;
#line 58
    bp->r.max.x -= i;
#line 59
    dx -= i;
  }
#line 61
  if (bp->r.max.y > (bp->sm)->clipr.max.y) {
#line 62
    i = bp->r.max.y - (bp->sm)->clipr.max.y;
#line 63
    bp->r.max.y -= i;
#line 64
    dy -= i;
  }
#line 66
  if (dx > 0) {
#line 66
    if (dy > 0) {
#line 66
      tmp = 1;
    } else {
#line 66
      tmp = 0;
    }
  } else {
#line 66
    tmp = 0;
  }
#line 66
  return (tmp);
}
}
#line 8 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
View *last_selection  ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.h"
Path wilydir  ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
Bool show_dot_files  =    (Bool )0;
#line 4 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
Bool autoindent_enabled  =    (Bool )1;
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *notfilename  =    (char *)"!\"#%&\'()*;<=>?@`[\\]^{|}";
#line 16 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *notinclude  =    (char *)"!#%&\'()*;=?@`[\\]^{|}";
#line 17 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *notdoubleclick  =    (char *)"!\"#$%&\'()*+,-./:;<=>?@`[\\]^{|}~";
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *notcommand  =    (char *)"!\"#%&\'()*;:=?@`[\\]^{}";
#line 19 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *notaddress  =    (char *)"!\"%&\'()+;<=>?@`[]{|}";
#line 21 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/global.c"
char *whitespace  =    (char *)" \t\v\n";
#line 15 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
static char *whitespace_regexp  =    (char *)"[ \t\n]+";
#line 16
static Range tag_findtool(Text *t___0 , char *s ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
static Bool wily_modifying_tag  =    (Bool )0;
#line 25 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
char *tag_gettools(Text *t___0 ) 
{ 
  Range r ;
  char *tmp ;
  Bool tmp___0 ;

  {
  {
#line 29
  r = nr;
#line 30
  tmp___0 = text_utfregexp(t___0, (char *)"\\|.*", & r, (Bool )1);
  }
#line 30
  if (tmp___0) {
    {
#line 31
    (r.p0) ++;
#line 32
    tmp = text_duputf(t___0, r);
    }
#line 32
    return (tmp);
  } else {
#line 34
    return ((char *)"");
  }
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_settools(Text *t___0 , char *s ) 
{ 
  Range r ;
  ulong len ;
  Bool tmp ;

  {
  {
#line 40
  r = nr;
#line 43
  tmp = text_utfregexp(t___0, (char *)"\\|.*", & r, (Bool )1);
  }
#line 43
  if (tmp) {
#line 44
    (r.p0) ++;
  } else {
    {
#line 46
    len = text_length(t___0);
#line 47
    r = range(len, len);
    }
  }
  {
#line 49
  text_replaceutf(t___0, r, s);
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_set(Text *t___0 , char *s ) 
{ 
  Range tmp ;

  {
  {
#line 56
  wily_modifying_tag = (Bool )1;
#line 57
  tmp = text_all(t___0);
#line 57
  text_replaceutf(t___0, tmp, s);
#line 58
  wily_modifying_tag = (Bool )0;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_setlabel(Text *t___0 , char *s ) 
{ 
  Range r ;
  Path buf___3 ;
  ulong l ;
  Bool tmp ;

  {
  {
#line 68
  wily_modifying_tag = (Bool )1;
#line 71
  r = range((ulong )0, (ulong )0);
#line 72
  tmp = text_utfregexp(t___0, whitespace_regexp, & r, (Bool )1);
  }
#line 72
  if (! tmp) {
    {
#line 73
    l = text_length(t___0);
#line 74
    r = range(l, l);
    }
  }
  {
#line 77
  r.p0 = (ulong )0;
#line 78
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%s ",
          s);
#line 79
  text_replaceutf(t___0, r, buf___3);
#line 80
  wily_modifying_tag = (Bool )0;
  }
#line 81
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_rmtool(Text *t___0 , char *s ) 
{ 
  Range r ;
  Rstring tmp ;
  int tmp___0 ;

  {
  {
#line 90
  wily_modifying_tag = (Bool )1;
#line 92
  r = tag_findtool(t___0, s);
  }
#line 93
  if (r.p1 - r.p0) {
    {
#line 94
    tmp = rstring((Rune *)0, (Rune *)0);
#line 94
    text_replace(t___0, r, tmp);
    }
  }
  {
#line 95
  tmp___0 = strcmp((char const   *)s, "Put");
  }
#line 95
  if (! tmp___0) {
    {
#line 96
    text_fillbutton(t___0, (Fcode )0);
    }
  }
#line 97
  wily_modifying_tag = (Bool )0;
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
static void place_tool(Text *t___0 , Range r , char *s ) 
{ 
  Path tmp ;

  {
  {
#line 105
  sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%s ",
          s);
#line 106
  text_replaceutf(t___0, r, tmp);
  }
#line 107
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_addrunning(Text *t___0 , char *cmd ) 
{ 
  Range r ;

  {
  {
#line 120
  r = tag_findtool(t___0, cmd);
#line 121
  r.p0 = r.p1;
#line 122
  place_tool(t___0, r, cmd);
  }
#line 123
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_addtool(Text *t___0 , char *s ) 
{ 
  Range r ;
  int tmp ;

  {
  {
#line 132
  wily_modifying_tag = (Bool )1;
#line 134
  r = tag_findtool(t___0, s);
  }
#line 135
  if (! (r.p1 - r.p0)) {
    {
#line 136
    place_tool(t___0, r, s);
    }
  }
  {
#line 137
  tmp = strcmp((char const   *)s, "Put");
  }
#line 137
  if (! tmp) {
    {
#line 138
    text_fillbutton(t___0, (Fcode )15);
    }
  }
#line 139
  wily_modifying_tag = (Bool )0;
#line 140
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
static Range tag_findtool(Text *t___0 , char *s ) 
{ 
  Range pos ;
  Range endpos ;
  ulong l ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 153
  pos = nr;
#line 153
  endpos = pos;
#line 154
  tmp = text_findliteralutf(t___0, & endpos, (char *)"|");
  }
#line 154
  if (tmp) {
#line 155
    endpos.p1 = endpos.p0;
  } else {
    {
#line 157
    l = text_length(t___0);
#line 158
    endpos = range(l, l);
    }
  }
  {
#line 161
  tmp___0 = text_findwordutf(t___0, & pos, s);
  }
#line 161
  if (tmp___0) {
#line 161
    if (pos.p0 < endpos.p0) {
#line 162
      return (pos);
    }
  }
#line 164
  return (endpos);
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/wily-0.13.41/wily/tag.c"
void tag_modified(Text *t___0 , ulong p ) 
{ 
  Range r ;
  Path buf___3 ;
  int n ;
  Bool tmp ;
  Data *tmp___0 ;

  {
#line 178
  if (wily_modifying_tag) {
#line 179
    return;
  }
  {
#line 182
  r = nr;
#line 183
  tmp = text_utfregexp(t___0, whitespace_regexp, & r, (Bool )1);
  }
#line 183
  if (tmp) {
#line 184
    if (p > r.p0) {
#line 185
      return;
    }
#line 186
    r.p1 = r.p0;
#line 187
    r.p0 = (ulong )0;
  } else {
    {
#line 189
    r = text_all(t___0);
    }
  }
  {
#line 192
  n = text_copyutf(t___0, r, buf___3);
#line 193
  buf___3[n] = (char)0;
#line 194
  tmp___0 = text_data(t___0);
#line 194
  data_setlabel(tmp___0, buf___3);
  }
#line 195
  return;
}
}
