/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 52 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
enum __anonenum_arg_type_27 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 52 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
typedef enum __anonenum_arg_type_27 arg_type;
#line 94 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
union __anonunion_a_29 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 94 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
struct __anonstruct_argument_28 {
   arg_type type ;
   union __anonunion_a_29 a ;
};
#line 94 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
typedef struct __anonstruct_argument_28 argument;
#line 141 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
struct __anonstruct_arguments_30 {
   size_t count ;
   argument *arg ;
};
#line 141 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
typedef struct __anonstruct_arguments_30 arguments;
#line 46 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.h"
struct __anonstruct_char_directive_31 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 46 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.h"
typedef struct __anonstruct_char_directive_31 char_directive;
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.h"
struct __anonstruct_char_directives_32 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.h"
typedef struct __anonstruct_char_directives_32 char_directives;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 136 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef long ptrdiff_t;
#line 34 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_24 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_23 {
   int __count ;
   union __anonunion___value_24 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_23 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 48 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 680 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 135 "/usr/include/stdint.h"
typedef long intmax_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 54 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 48 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 60 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 62
struct hash_table;
#line 64 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 48 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 54 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 196 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 36 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt_int.h"
enum __anonenum___ordering_3 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 36 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __anonenum___ordering_3 __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 102 "getdate.y"
typedef long long_time_t;
#line 116 "getdate.y"
struct __anonstruct_textint_27 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 116 "getdate.y"
typedef struct __anonstruct_textint_27 textint;
#line 124 "getdate.y"
struct __anonstruct_table_28 {
   char const   *name ;
   int type ;
   int value ;
};
#line 124 "getdate.y"
typedef struct __anonstruct_table_28 table;
#line 137 "getdate.y"
struct __anonstruct_relative_time_31 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 137 "getdate.y"
typedef struct __anonstruct_relative_time_31 relative_time;
#line 159 "getdate.y"
struct __anonstruct_parser_control_32 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 159 "getdate.y"
typedef struct __anonstruct_parser_control_32 parser_control;
#line 204
union YYSTYPE;
#line 294 "getdate.y"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 294 "getdate.y"
typedef union YYSTYPE YYSTYPE;
#line 442 "getdate.c"
typedef unsigned char yytype_uint8;
#line 449 "getdate.c"
typedef signed char yytype_int8;
#line 463 "getdate.c"
typedef short yytype_int16;
#line 594 "getdate.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 50 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 42 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 79 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 153
struct argp;
#line 154
struct argp_state;
#line 155
struct argp_child;
#line 227 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 295 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 320 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 195 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct group {
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   struct argp  const  *argp ;
   char *short_end ;
   unsigned int args_processed ;
   struct group *parent ;
   unsigned int parent_index ;
   void *input ;
   void **child_inputs ;
   void *hook ;
};
#line 242 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct parser {
   struct argp  const  *argp ;
   char *short_opts ;
   struct rpl_option *long_opts ;
   struct _getopt_data opt_data ;
   struct group *groups ;
   struct group *egroup ;
   void **child_inputs ;
   int try_getopt ;
   struct argp_state state ;
   void *storage ;
};
#line 277 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct parser_convert_state {
   struct parser *parser ;
   char *short_end ;
   struct rpl_option *long_end ;
   void **child_inputs_end ;
};
#line 418 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct parser_sizes {
   size_t short_len ;
   size_t long_len ;
   size_t num_groups ;
   size_t num_child_inputs ;
};
#line 492 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct __anonstruct_32 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct __anonstruct_34 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
struct __anonstruct_36 {
   char c ;
   struct rpl_option x ;
};
#line 93 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
struct argp_fmtstream {
   FILE *stream ;
   size_t lmargin ;
   size_t rmargin ;
   ssize_t wmargin ;
   size_t point_offs ;
   ssize_t point_col ;
   char *buf ;
   char *p ;
   char *end ;
};
#line 110 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
typedef struct argp_fmtstream *argp_fmtstream_t;
#line 79 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct uparams {
   int dup_args ;
   int dup_args_note ;
   int short_opt_col ;
   int long_opt_col ;
   int doc_opt_col ;
   int opt_doc_col ;
   int header_col ;
   int usage_indent ;
   int rmargin ;
   int valid ;
};
#line 113 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct uparam_name {
   char const   *name ;
   int is_bool ;
   size_t uparams_offs ;
};
#line 352
struct hol_cluster;
#line 354 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct hol_entry {
   struct argp_option  const  *opt ;
   unsigned int num ;
   char *short_options ;
   int group ;
   struct hol_cluster *cluster ;
   struct argp  const  *argp ;
   unsigned int ord ;
};
#line 385 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct hol_cluster {
   char const   *header ;
   int index ;
   int group ;
   struct hol_cluster *parent ;
   struct argp  const  *argp ;
   int depth ;
   struct hol_cluster *next ;
};
#line 415 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct hol {
   struct hol_entry *entries ;
   unsigned int num_entries ;
   char *short_options ;
   struct hol_cluster *clusters ;
};
#line 979 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct hol_help_state {
   struct hol_entry *prev_entry ;
   int sep_groups ;
   int suppressed_dup_arg ;
};
#line 996 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
struct pentry_state {
   struct hol_entry  const  *entry ;
   argp_fmtstream_t stream ;
   struct hol_help_state *hhstate ;
   int first ;
   struct argp_state  const  *state ;
};
#line 869 "/usr/include/stdio.h"
struct obstack;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/bits/types.h"
typedef int __daddr_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/sys/mtio.h"
struct mtop {
   short mt_op ;
   int mt_count ;
};
#line 82 "/usr/include/sys/mtio.h"
struct mtget {
   long mt_type ;
   long mt_resid ;
   long mt_dsreg ;
   long mt_gstat ;
   long mt_erreg ;
   __daddr_t mt_fileno ;
   __daddr_t mt_blkno ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group___0 {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
union __anonunion_id_56 {
   uid_t u ;
   gid_t g ;
};
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
struct userid {
   union __anonunion_id_56 id ;
   char *name ;
   struct userid *next ;
};
#line 111 "/home/wslee/gnu_benchmarks/cpio-2.11/src/cpiohdr.h"
struct cpio_file_stat {
   unsigned short c_magic ;
   ino_t c_ino ;
   mode_t c_mode ;
   uid_t c_uid ;
   gid_t c_gid ;
   size_t c_nlink ;
   time_t c_mtime ;
   off_t c_filesize ;
   long c_dev_maj ;
   long c_dev_min ;
   long c_rdev_maj ;
   long c_rdev_min ;
   size_t c_namesize ;
   unsigned long c_chksum ;
   char *c_name ;
   char *c_tar_linkname ;
};
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.h"
struct __anonstruct_dynamic_string_56 {
   int ds_length ;
   char *ds_string ;
};
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.h"
typedef struct __anonstruct_dynamic_string_56 dynamic_string;
#line 687 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
struct inode_val {
   ino_t inode ;
   unsigned long major_num ;
   unsigned long minor_num ;
   char *file_name ;
};
#line 1130
enum __anonenum_state_57 {
    begin = 0,
    in_zeros = 1,
    not_in_zeros = 2
} ;
#line 1411 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
struct delayed_set_stat {
   struct delayed_set_stat *next ;
   struct cpio_file_stat stat ;
   mode_t invert_permissions ;
};
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
enum archive_format {
    arf_unknown = 0,
    arf_binary = 1,
    arf_oldascii = 2,
    arf_newascii = 3,
    arf_crcascii = 4,
    arf_tar = 5,
    arf_ustar = 6,
    arf_hpoldascii = 7,
    arf_hpbinary = 8
} ;
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tarhdr.h"
struct tar_header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char typeflag ;
   char linkname[100] ;
   char magic[6] ;
   char version[2] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
   char prefix[155] ;
};
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tarhdr.h"
union tar_record {
   struct tar_header header ;
   char buffer[512] ;
};
#line 240 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
struct warn_tab {
   char *name ;
   int flag ;
};
#line 20 "/home/wslee/gnu_benchmarks/cpio-2.11/src/defer.h"
struct deferment {
   struct deferment *next ;
   struct cpio_file_stat header ;
};
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/cpiohdr.h"
struct old_cpio_header {
   unsigned short c_magic ;
   unsigned short c_dev ;
   unsigned short c_ino ;
   unsigned short c_mode ;
   unsigned short c_uid ;
   unsigned short c_gid ;
   unsigned short c_nlink ;
   unsigned short c_rdev ;
   unsigned short c_mtimes[2] ;
   unsigned short c_namesize ;
   unsigned short c_filesizes[2] ;
} __attribute__((__packed__)) ;
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/src/cpiohdr.h"
struct old_ascii_header {
   char c_magic[6] ;
   char c_dev[6] ;
   char c_ino[6] ;
   char c_mode[6] ;
   char c_uid[6] ;
   char c_gid[6] ;
   char c_nlink[6] ;
   char c_rdev[6] ;
   char c_mtime[11] ;
   char c_namesize[6] ;
   char c_filesize[11] ;
} __attribute__((__packed__)) ;
#line 91 "/home/wslee/gnu_benchmarks/cpio-2.11/src/cpiohdr.h"
struct new_ascii_header {
   char c_magic[6] ;
   char c_ino[8] ;
   char c_mode[8] ;
   char c_uid[8] ;
   char c_gid[8] ;
   char c_nlink[8] ;
   char c_mtime[8] ;
   char c_filesize[8] ;
   char c_dev_maj[8] ;
   char c_dev_min[8] ;
   char c_rdev_maj[8] ;
   char c_rdev_min[8] ;
   char c_namesize[8] ;
   char c_chksum[8] ;
} __attribute__((__packed__)) ;
#line 945 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
union __anonunion_magic_57 {
   char str[6] ;
   unsigned short num ;
   struct old_cpio_header old_header ;
};
#line 25 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 181 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 56 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 34
  tmp = strndup(string, n);
#line 34
  s = tmp;
  }
#line 35
  if (! s) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (s);
}
}
#line 58 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 59
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 60
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 61
void *xrealloc(void *p , size_t n ) ;
#line 62
void *x2realloc(void *p , size_t *pn ) ;
#line 63
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 64
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 197 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 200
  n = *pn;
#line 202
  if (! p) {
#line 204
    if (! n) {
#line 212
      n = 64UL / s;
#line 213
      n += (size_t )(! n);
    }
  } else {
#line 222
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 223
      xalloc_die();
      }
    }
#line 224
    n += (n + 1UL) / 2UL;
  }
  {
#line 227
  *pn = n;
#line 228
  tmp = xrealloc(p, n * s);
  }
#line 228
  return (tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                            size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 47
  tmp = malloc(n);
#line 47
  p = tmp;
  }
#line 48
  if (! p) {
#line 48
    if (n != 0UL) {
      {
#line 49
      xalloc_die();
      }
    }
  }
#line 50
  return (p);
}
}
#line 56 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 59
  p = realloc(p, n);
  }
#line 60
  if (! p) {
#line 60
    if (n != 0UL) {
      {
#line 61
      xalloc_die();
      }
    }
  }
#line 62
  return (p);
}
}
#line 71 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 74
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 74
  return (tmp);
}
}
#line 81
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 81 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 84
  tmp = xmalloc(s);
#line 84
  tmp___0 = (void *)memset(tmp, 0, s);
  }
#line 84
  return (tmp___0);
}
}
#line 90
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 90 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 98
  p = calloc(n, s);
  }
#line 98
  if (! p) {
    {
#line 100
    xalloc_die();
    }
  }
#line 101
  return (p);
}
}
#line 108
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 108 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  tmp = xmalloc(s);
#line 111
  tmp___0 = (void *)memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                           s);
  }
#line 111
  return (tmp___0);
}
}
#line 116
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 116 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 119
  tmp = strlen(string);
#line 119
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 119
  return ((char *)tmp___0);
}
}
#line 19 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xgetcwd.h"
char *xgetcwd(void) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 683 "./unistd.h"
char *rpl_getcwd(char *buf , size_t size ) ;
#line 36 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 39
  tmp = rpl_getcwd((char *)((void *)0), (size_t )0);
#line 39
  cwd = tmp;
  }
#line 40
  if (! cwd) {
    {
#line 40
    tmp___0 = __errno_location();
    }
#line 40
    if (*tmp___0 == 12) {
      {
#line 41
      xalloc_die();
      }
    }
  }
#line 42
  return (cwd);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 20 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/exitfail.h"
int volatile   exit_failure ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 36
  tmp = gettext("memory exhausted");
#line 36
  error((int )exit_failure, 0, "%s", tmp);
#line 42
  abort();
  }
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 333
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                          char const   * __restrict  __fmt 
                                                                                                          , ...) ;
#line 339
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 699
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 36 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.h"
char const   version_etc_copyright[47] ;
#line 54
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 60
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 65
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 71
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 78
void emit_bug_reporting_address(void) ;
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 69
  if (command_name) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 72
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 86
  tmp = gettext("(C)");
#line 86
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2010);
#line 88
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 88
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 99
  if (n_authors == 0UL) {
#line 99
    goto case_0;
  }
#line 102
  if (n_authors == 1UL) {
#line 102
    goto case_1;
  }
#line 106
  if (n_authors == 2UL) {
#line 106
    goto case_2;
  }
#line 110
  if (n_authors == 3UL) {
#line 110
    goto case_3;
  }
#line 115
  if (n_authors == 4UL) {
#line 115
    goto case_4;
  }
#line 122
  if (n_authors == 5UL) {
#line 122
    goto case_5;
  }
#line 129
  if (n_authors == 6UL) {
#line 129
    goto case_6;
  }
#line 137
  if (n_authors == 7UL) {
#line 137
    goto case_7;
  }
#line 145
  if (n_authors == 8UL) {
#line 145
    goto case_8;
  }
#line 154
  if (n_authors == 9UL) {
#line 154
    goto case_9;
  }
#line 163
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 101
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 104
  tmp___1 = gettext("Written by %s.\n");
#line 104
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 105
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 108
  tmp___2 = gettext("Written by %s and %s.\n");
#line 108
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 109
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 112
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 112
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 114
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 119
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 119
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 121
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 126
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 126
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 128
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 133
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 133
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 136
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 141
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 141
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 144
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 149
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 149
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 153
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 158
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 158
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 169
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 169
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 188
  n_authors = (size_t )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! *(authors + n_authors)) {
#line 188
      goto while_break;
    }
#line 188
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 191
  return;
}
}
#line 197 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 205
  n_authors = (size_t )0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (n_authors < 10UL) {
      {
#line 205
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 205
      tmp = tmp___0;
#line 205
      authtab[n_authors] = tmp;
      }
#line 205
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 205
        goto while_break;
      }
    } else {
#line 205
      goto while_break;
    }
#line 205
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 212
  return;
}
}
#line 228
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 228 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 235
  __builtin_va_start(authors, version);
#line 236
  version_etc_va(stream, command_name, package, version, authors);
#line 237
  __builtin_va_end(authors);
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 247
  tmp = gettext("\nReport bugs to: %s\n");
#line 247
  printf((char const   */* __restrict  */)tmp, "bug-cpio@gnu.org");
#line 255
  tmp___0 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
#line 255
  printf((char const   */* __restrict  */)tmp___0, "GNU cpio", "cpio");
#line 258
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 258
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 260
  return;
}
}
#line 28 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 28 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 153 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 177 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 54 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 0xffffffffffffffffUL;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 81
  return (tmp___1);
}
}
#line 85 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1479 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___32 ;
  size_t __attribute__((__pure__))  tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t __attribute__((__pure__))  tmp___37 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int arg___0 ;
  unsigned int arg___1 ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  long arg___6 ;
  unsigned long arg___7 ;
  long long arg___8 ;
  unsigned long long arg___9 ;
  double arg___10 ;
  long double arg___11 ;
  int arg___12 ;
  wint_t arg___13 ;
  char const   *arg___14 ;
  wchar_t const   *arg___15 ;
  void *arg___16 ;
  size_t bigger_need ;
  size_t tmp___38 ;
  size_t __attribute__((__pure__))  tmp___39 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  int *tmp___43 ;
  size_t n___2 ;
  size_t tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t __attribute__((__pure__))  tmp___46 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___5 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;

  {
  {
#line 1486
  tmp = printf_parse(format, & d, & a);
  }
#line 1486
  if (tmp < 0) {
#line 1488
    return ((char *)((void *)0));
  }
  {
#line 1495
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1495
  if (tmp___1 < 0) {
    {
#line 1497
    free((void *)d.dir);
    }
#line 1497
    if (a.arg) {
      {
#line 1497
      free((void *)a.arg);
      }
    }
    {
#line 1498
    tmp___0 = __errno_location();
#line 1498
    *tmp___0 = 22;
    }
#line 1499
    return ((char *)((void *)0));
  }
  {
#line 1516
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1516
  buf_neededlength = (size_t )tmp___2;
  }
#line 1519
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1521
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1521
    buf = (char *)tmp___3;
#line 1522
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1527
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1527
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1527
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1527
    buf_memsize = tmp___4;
#line 1528
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1529
      goto out_of_memory_1;
    }
    {
#line 1530
    tmp___5 = malloc(buf_memsize);
#line 1530
    buf = (char *)tmp___5;
    }
#line 1531
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1532
      goto out_of_memory_1;
    }
#line 1533
    buf_malloced = buf;
  }
#line 1536
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1538
    result = resultbuf;
#line 1539
    allocated = *lengthp;
  } else {
#line 1543
    result = (char *)((void *)0);
#line 1544
    allocated = (size_t )0;
  }
#line 1546
  length = (size_t )0;
#line 1576
  cp = format;
#line 1576
  i = (size_t )0;
#line 1576
  dp = d.dir + 0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1578
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1580
      n = (size_t )(dp->dir_start - cp);
#line 1581
      tmp___6 = xsum(length, n);
#line 1581
      augmented_length = (size_t )tmp___6;
      }
#line 1583
      if (augmented_length > allocated) {
#line 1583
        if (allocated > 0UL) {
#line 1583
          if (allocated <= 9223372036854775807UL) {
#line 1583
            tmp___7 = allocated * 2UL;
          } else {
#line 1583
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1583
          allocated = tmp___7;
        } else {
#line 1583
          allocated = (size_t )12;
        }
#line 1583
        if (augmented_length > allocated) {
#line 1583
          allocated = augmented_length;
        }
#line 1583
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1583
          memory_size = allocated * sizeof(char );
        } else {
#line 1583
          memory_size = 0xffffffffffffffffUL;
        }
#line 1583
        if (memory_size == 0xffffffffffffffffUL) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else
#line 1583
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1583
          tmp___9 = realloc((void *)result, memory_size);
#line 1583
          memory = (char *)tmp___9;
          }
        }
#line 1583
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1583
          if (length > 0UL) {
            {
#line 1583
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1583
        result = memory;
      }
#line 1587
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1589
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1590
        length = augmented_length;
        }
      } else {
        {
#line 1594
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1595
          tmp___10 = length;
#line 1595
          length ++;
#line 1595
          tmp___11 = cp;
#line 1595
          cp ++;
#line 1595
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1594
          n --;
#line 1594
          if (! (n > 0UL)) {
#line 1594
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1599
    if (i == d.count) {
#line 1600
      goto while_break;
    }
#line 1603
    if ((int )dp->conversion == 37) {
#line 1607
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1608
        abort();
        }
      }
      {
#line 1609
      tmp___12 = xsum(length, (size_t )1);
#line 1609
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1610
      if (augmented_length___0 > allocated) {
#line 1610
        if (allocated > 0UL) {
#line 1610
          if (allocated <= 9223372036854775807UL) {
#line 1610
            tmp___13 = allocated * 2UL;
          } else {
#line 1610
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1610
          allocated = tmp___13;
        } else {
#line 1610
          allocated = (size_t )12;
        }
#line 1610
        if (augmented_length___0 > allocated) {
#line 1610
          allocated = augmented_length___0;
        }
#line 1610
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1610
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1610
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1610
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1610
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1610
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1610
          memory___0 = (char *)tmp___15;
          }
        }
#line 1610
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1610
          if (length > 0UL) {
            {
#line 1610
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1610
        result = memory___0;
      }
#line 1611
      *(result + length) = (char )'%';
#line 1612
      length = augmented_length___0;
    } else {
#line 1616
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1617
        abort();
        }
      }
#line 1619
      if ((int )dp->conversion == 110) {
        {
#line 1623
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1623
          goto case_18;
        }
#line 1626
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1626
          goto case_19;
        }
#line 1629
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1629
          goto case_20;
        }
#line 1632
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1632
          goto case_21;
        }
#line 1636
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1636
          goto case_22;
        }
#line 1640
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1624
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1625
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1627
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1628
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1630
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1631
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1633
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1634
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1637
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1638
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1641
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4304
        type = (a.arg + dp->arg_index)->type;
#line 4305
        flags = dp->flags;
#line 4701
        fbp = buf;
#line 4702
        tmp___16 = fbp;
#line 4702
        fbp ++;
#line 4702
        *tmp___16 = (char )'%';
#line 4708
        if (flags & 1) {
#line 4709
          tmp___17 = fbp;
#line 4709
          fbp ++;
#line 4709
          *tmp___17 = (char )'\'';
        }
#line 4711
        if (flags & 2) {
#line 4712
          tmp___18 = fbp;
#line 4712
          fbp ++;
#line 4712
          *tmp___18 = (char )'-';
        }
#line 4713
        if (flags & 4) {
#line 4714
          tmp___19 = fbp;
#line 4714
          fbp ++;
#line 4714
          *tmp___19 = (char )'+';
        }
#line 4715
        if (flags & 8) {
#line 4716
          tmp___20 = fbp;
#line 4716
          fbp ++;
#line 4716
          *tmp___20 = (char )' ';
        }
#line 4717
        if (flags & 16) {
#line 4718
          tmp___21 = fbp;
#line 4718
          fbp ++;
#line 4718
          *tmp___21 = (char )'#';
        }
#line 4721
        if (flags & 32) {
#line 4722
          tmp___22 = fbp;
#line 4722
          fbp ++;
#line 4722
          *tmp___22 = (char )'0';
        }
#line 4723
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4725
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4728
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4730
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   n___0 * sizeof(char ));
#line 4731
            fbp += n___0;
            }
          } else {
#line 4735
            mp = dp->width_start;
            {
#line 4736
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4737
              tmp___23 = fbp;
#line 4737
              fbp ++;
#line 4737
              tmp___24 = mp;
#line 4737
              mp ++;
#line 4737
              *tmp___23 = (char )((unsigned char )*tmp___24);
#line 4736
              n___0 --;
#line 4736
              if (! (n___0 > 0UL)) {
#line 4736
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4744
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4746
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4749
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4751
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   n___1 * sizeof(char ));
#line 4752
            fbp += n___1;
            }
          } else {
#line 4756
            mp___0 = dp->precision_start;
            {
#line 4757
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4758
              tmp___25 = fbp;
#line 4758
              fbp ++;
#line 4758
              tmp___26 = mp___0;
#line 4758
              mp___0 ++;
#line 4758
              *tmp___25 = (char )((unsigned char )*tmp___26);
#line 4757
              n___1 --;
#line 4757
              if (! (n___1 > 0UL)) {
#line 4757
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4768
        if ((unsigned int )type == 10U) {
#line 4768
          goto case_10;
        }
#line 4768
        if ((unsigned int )type == 9U) {
#line 4768
          goto case_10;
        }
#line 4785
        if ((unsigned int )type == 16U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 14U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 8U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 7U) {
#line 4785
          goto case_16;
        }
#line 4789
        if ((unsigned int )type == 12U) {
#line 4789
          goto case_12;
        }
#line 4792
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4775
        tmp___27 = fbp;
#line 4775
        fbp ++;
#line 4775
        *tmp___27 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4787
        tmp___28 = fbp;
#line 4787
        fbp ++;
#line 4787
        *tmp___28 = (char )'l';
#line 4788
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4790
        tmp___29 = fbp;
#line 4790
        fbp ++;
#line 4790
        *tmp___29 = (char )'L';
#line 4791
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4793
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4800
        *fbp = dp->conversion;
#line 4830
        *(fbp + 1) = (char )'\000';
#line 4837
        prefix_count = 0U;
#line 4838
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4840
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4841
            abort();
            }
          }
#line 4842
          tmp___30 = prefix_count;
#line 4842
          prefix_count ++;
#line 4842
          prefixes[tmp___30] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4844
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4846
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4847
            abort();
            }
          }
#line 4848
          tmp___31 = prefix_count;
#line 4848
          prefix_count ++;
#line 4848
          prefixes[tmp___31] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4860
        tmp___37 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4860
        if (tmp___37 > (size_t __attribute__((__pure__))  )allocated) {
#line 4860
          if (allocated > 0UL) {
#line 4860
            if (allocated <= 9223372036854775807UL) {
#line 4860
              tmp___32 = allocated * 2UL;
            } else {
#line 4860
              tmp___32 = 0xffffffffffffffffUL;
            }
#line 4860
            allocated = tmp___32;
          } else {
#line 4860
            allocated = (size_t )12;
          }
          {
#line 4860
          tmp___34 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4860
          if (tmp___34 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4860
            tmp___33 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4860
            allocated = (size_t )tmp___33;
            }
          }
#line 4860
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4860
            memory_size___1 = allocated * sizeof(char );
          } else {
#line 4860
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 4860
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4860
            goto out_of_memory;
          }
#line 4860
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4860
            tmp___35 = malloc(memory_size___1);
#line 4860
            memory___1 = (char *)tmp___35;
            }
          } else
#line 4860
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4860
            tmp___35 = malloc(memory_size___1);
#line 4860
            memory___1 = (char *)tmp___35;
            }
          } else {
            {
#line 4860
            tmp___36 = realloc((void *)result, memory_size___1);
#line 4860
            memory___1 = (char *)tmp___36;
            }
          }
#line 4860
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4860
            goto out_of_memory;
          }
#line 4860
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4860
            if (length > 0UL) {
              {
#line 4860
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4860
          result = memory___1;
        }
#line 4865
        *(result + length) = (char )'\000';
        {
#line 4868
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4870
          count = -1;
#line 4873
          retcount = 0;
#line 4874
          maxlen = allocated - length;
#line 4877
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4878
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
#line 4879
          maxlen *= sizeof(char ) / sizeof(char );
          {
#line 4923
          if ((unsigned int )type == 1U) {
#line 4923
            goto case_1;
          }
#line 4929
          if ((unsigned int )type == 2U) {
#line 4929
            goto case_2___0;
          }
#line 4935
          if ((unsigned int )type == 3U) {
#line 4935
            goto case_3;
          }
#line 4941
          if ((unsigned int )type == 4U) {
#line 4941
            goto case_4;
          }
#line 4947
          if ((unsigned int )type == 5U) {
#line 4947
            goto case_5;
          }
#line 4953
          if ((unsigned int )type == 6U) {
#line 4953
            goto case_6;
          }
#line 4959
          if ((unsigned int )type == 7U) {
#line 4959
            goto case_7___0;
          }
#line 4965
          if ((unsigned int )type == 8U) {
#line 4965
            goto case_8___0;
          }
#line 4972
          if ((unsigned int )type == 9U) {
#line 4972
            goto case_9___0;
          }
#line 4978
          if ((unsigned int )type == 10U) {
#line 4978
            goto case_10___0;
          }
#line 4985
          if ((unsigned int )type == 11U) {
#line 4985
            goto case_11;
          }
#line 4991
          if ((unsigned int )type == 12U) {
#line 4991
            goto case_12___0;
          }
#line 4997
          if ((unsigned int )type == 13U) {
#line 4997
            goto case_13;
          }
#line 5004
          if ((unsigned int )type == 14U) {
#line 5004
            goto case_14___0;
          }
#line 5011
          if ((unsigned int )type == 15U) {
#line 5011
            goto case_15;
          }
#line 5018
          if ((unsigned int )type == 16U) {
#line 5018
            goto case_16___0;
          }
#line 5025
          if ((unsigned int )type == 17U) {
#line 5025
            goto case_17;
          }
#line 5031
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4925
          arg___0 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4926
          if (prefix_count == 0U) {
#line 4926
            goto case_0;
          }
#line 4926
          if (prefix_count == 1U) {
#line 4926
            goto case_1___0;
          }
#line 4926
          if (prefix_count == 2U) {
#line 4926
            goto case_2;
          }
#line 4926
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4926
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___0,
                                    & count);
          }
#line 4926
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4926
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___0, & count);
          }
#line 4926
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4926
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___0, & count);
          }
#line 4926
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4926
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4928
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4931
          arg___1 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4932
          if (prefix_count == 0U) {
#line 4932
            goto case_0___0;
          }
#line 4932
          if (prefix_count == 1U) {
#line 4932
            goto case_1___1;
          }
#line 4932
          if (prefix_count == 2U) {
#line 4932
            goto case_2___1;
          }
#line 4932
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4932
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___1,
                                    & count);
          }
#line 4932
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4932
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___1, & count);
          }
#line 4932
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4932
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___1, & count);
          }
#line 4932
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4932
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4934
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4937
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4938
          if (prefix_count == 0U) {
#line 4938
            goto case_0___1;
          }
#line 4938
          if (prefix_count == 1U) {
#line 4938
            goto case_1___2;
          }
#line 4938
          if (prefix_count == 2U) {
#line 4938
            goto case_2___2;
          }
#line 4938
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4938
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___2,
                                    & count);
          }
#line 4938
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4938
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___2, & count);
          }
#line 4938
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4938
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___2, & count);
          }
#line 4938
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4938
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4940
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4943
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4944
          if (prefix_count == 0U) {
#line 4944
            goto case_0___2;
          }
#line 4944
          if (prefix_count == 1U) {
#line 4944
            goto case_1___3;
          }
#line 4944
          if (prefix_count == 2U) {
#line 4944
            goto case_2___3;
          }
#line 4944
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4944
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___3,
                                    & count);
          }
#line 4944
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4944
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___3, & count);
          }
#line 4944
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4944
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___3, & count);
          }
#line 4944
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4944
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4946
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4949
          arg___4 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4950
          if (prefix_count == 0U) {
#line 4950
            goto case_0___3;
          }
#line 4950
          if (prefix_count == 1U) {
#line 4950
            goto case_1___4;
          }
#line 4950
          if (prefix_count == 2U) {
#line 4950
            goto case_2___4;
          }
#line 4950
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4950
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___4,
                                    & count);
          }
#line 4950
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4950
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___4, & count);
          }
#line 4950
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4950
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___4, & count);
          }
#line 4950
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4950
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 4952
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 4955
          arg___5 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 4956
          if (prefix_count == 0U) {
#line 4956
            goto case_0___4;
          }
#line 4956
          if (prefix_count == 1U) {
#line 4956
            goto case_1___5;
          }
#line 4956
          if (prefix_count == 2U) {
#line 4956
            goto case_2___5;
          }
#line 4956
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 4956
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___5,
                                    & count);
          }
#line 4956
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 4956
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___5, & count);
          }
#line 4956
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 4956
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___5, & count);
          }
#line 4956
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 4956
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 4958
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 4961
          arg___6 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 4962
          if (prefix_count == 0U) {
#line 4962
            goto case_0___5;
          }
#line 4962
          if (prefix_count == 1U) {
#line 4962
            goto case_1___6;
          }
#line 4962
          if (prefix_count == 2U) {
#line 4962
            goto case_2___6;
          }
#line 4962
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 4962
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___6,
                                    & count);
          }
#line 4962
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 4962
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___6, & count);
          }
#line 4962
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 4962
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___6, & count);
          }
#line 4962
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 4962
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 4964
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 4967
          arg___7 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 4968
          if (prefix_count == 0U) {
#line 4968
            goto case_0___6;
          }
#line 4968
          if (prefix_count == 1U) {
#line 4968
            goto case_1___7;
          }
#line 4968
          if (prefix_count == 2U) {
#line 4968
            goto case_2___7;
          }
#line 4968
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 4968
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___7,
                                    & count);
          }
#line 4968
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 4968
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___7, & count);
          }
#line 4968
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 4968
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___7, & count);
          }
#line 4968
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 4968
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 4970
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 4974
          arg___8 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 4975
          if (prefix_count == 0U) {
#line 4975
            goto case_0___7;
          }
#line 4975
          if (prefix_count == 1U) {
#line 4975
            goto case_1___8;
          }
#line 4975
          if (prefix_count == 2U) {
#line 4975
            goto case_2___8;
          }
#line 4975
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 4975
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___8,
                                    & count);
          }
#line 4975
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 4975
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___8, & count);
          }
#line 4975
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 4975
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___8, & count);
          }
#line 4975
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 4975
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 4977
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 4980
          arg___9 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 4981
          if (prefix_count == 0U) {
#line 4981
            goto case_0___8;
          }
#line 4981
          if (prefix_count == 1U) {
#line 4981
            goto case_1___9;
          }
#line 4981
          if (prefix_count == 2U) {
#line 4981
            goto case_2___9;
          }
#line 4981
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 4981
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___9,
                                    & count);
          }
#line 4981
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 4981
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___9, & count);
          }
#line 4981
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 4981
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___9, & count);
          }
#line 4981
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 4981
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 4983
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 4987
          arg___10 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 4988
          if (prefix_count == 0U) {
#line 4988
            goto case_0___9;
          }
#line 4988
          if (prefix_count == 1U) {
#line 4988
            goto case_1___10;
          }
#line 4988
          if (prefix_count == 2U) {
#line 4988
            goto case_2___10;
          }
#line 4988
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 4988
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___10,
                                    & count);
          }
#line 4988
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 4988
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___10, & count);
          }
#line 4988
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 4988
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___10, & count);
          }
#line 4988
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 4988
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 4990
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 4993
          arg___11 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 4994
          if (prefix_count == 0U) {
#line 4994
            goto case_0___10;
          }
#line 4994
          if (prefix_count == 1U) {
#line 4994
            goto case_1___11;
          }
#line 4994
          if (prefix_count == 2U) {
#line 4994
            goto case_2___11;
          }
#line 4994
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 4994
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___11,
                                    & count);
          }
#line 4994
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 4994
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___11, & count);
          }
#line 4994
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 4994
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___11, & count);
          }
#line 4994
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 4994
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 4996
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 4999
          arg___12 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5000
          if (prefix_count == 0U) {
#line 5000
            goto case_0___11;
          }
#line 5000
          if (prefix_count == 1U) {
#line 5000
            goto case_1___12;
          }
#line 5000
          if (prefix_count == 2U) {
#line 5000
            goto case_2___12;
          }
#line 5000
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5000
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___12,
                                    & count);
          }
#line 5000
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5000
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___12, & count);
          }
#line 5000
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5000
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___12, & count);
          }
#line 5000
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5000
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5002
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5006
          arg___13 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5007
          if (prefix_count == 0U) {
#line 5007
            goto case_0___12;
          }
#line 5007
          if (prefix_count == 1U) {
#line 5007
            goto case_1___13;
          }
#line 5007
          if (prefix_count == 2U) {
#line 5007
            goto case_2___13;
          }
#line 5007
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5007
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___13,
                                    & count);
          }
#line 5007
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5007
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___13, & count);
          }
#line 5007
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5007
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___13, & count);
          }
#line 5007
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5007
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5009
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5013
          arg___14 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5014
          if (prefix_count == 0U) {
#line 5014
            goto case_0___13;
          }
#line 5014
          if (prefix_count == 1U) {
#line 5014
            goto case_1___14;
          }
#line 5014
          if (prefix_count == 2U) {
#line 5014
            goto case_2___14;
          }
#line 5014
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5014
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___14,
                                    & count);
          }
#line 5014
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5014
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___14, & count);
          }
#line 5014
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5014
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___14, & count);
          }
#line 5014
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5014
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5016
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5020
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5021
          if (prefix_count == 0U) {
#line 5021
            goto case_0___14;
          }
#line 5021
          if (prefix_count == 1U) {
#line 5021
            goto case_1___15;
          }
#line 5021
          if (prefix_count == 2U) {
#line 5021
            goto case_2___15;
          }
#line 5021
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5021
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___15,
                                    & count);
          }
#line 5021
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5021
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___15, & count);
          }
#line 5021
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5021
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___15, & count);
          }
#line 5021
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5021
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5023
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5027
          arg___16 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5028
          if (prefix_count == 0U) {
#line 5028
            goto case_0___15;
          }
#line 5028
          if (prefix_count == 1U) {
#line 5028
            goto case_1___16;
          }
#line 5028
          if (prefix_count == 2U) {
#line 5028
            goto case_2___16;
          }
#line 5028
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5028
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, arg___16,
                                    & count);
          }
#line 5028
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5028
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    arg___16, & count);
          }
#line 5028
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5028
          retcount = (int )snprintf((char */* __restrict  */)(result + length), maxlen,
                                    (char const   */* __restrict  */)buf, prefixes[0],
                                    prefixes[1], arg___16, & count);
          }
#line 5028
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5028
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5030
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5032
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5040
          if (count >= 0) {
#line 5044
            if ((size_t )count < maxlen) {
#line 5044
              if ((int )*((result + length) + count) != 0) {
                {
#line 5046
                abort();
                }
              }
            }
#line 5048
            if (retcount > count) {
#line 5049
              count = retcount;
            }
          } else
#line 5055
          if ((int )*(fbp + 1) != 0) {
#line 5059
            *(fbp + 1) = (char )'\000';
#line 5060
            goto __Cont;
          } else
#line 5065
          if (retcount < 0) {
#line 5072
            if (allocated <= 9223372036854775807UL) {
#line 5072
              tmp___38 = allocated * 2UL;
            } else {
#line 5072
              tmp___38 = 0xffffffffffffffffUL;
            }
            {
#line 5072
            tmp___39 = xsum(tmp___38, (size_t )12);
#line 5072
            bigger_need = (size_t )tmp___39;
            }
#line 5074
            if (bigger_need > allocated) {
#line 5074
              if (allocated > 0UL) {
#line 5074
                if (allocated <= 9223372036854775807UL) {
#line 5074
                  tmp___40 = allocated * 2UL;
                } else {
#line 5074
                  tmp___40 = 0xffffffffffffffffUL;
                }
#line 5074
                allocated = tmp___40;
              } else {
#line 5074
                allocated = (size_t )12;
              }
#line 5074
              if (bigger_need > allocated) {
#line 5074
                allocated = bigger_need;
              }
#line 5074
              if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5074
                memory_size___2 = allocated * sizeof(char );
              } else {
#line 5074
                memory_size___2 = 0xffffffffffffffffUL;
              }
#line 5074
              if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5074
                goto out_of_memory;
              }
#line 5074
              if ((unsigned long )result == (unsigned long )resultbuf) {
                {
#line 5074
                tmp___41 = malloc(memory_size___2);
#line 5074
                memory___2 = (char *)tmp___41;
                }
              } else
#line 5074
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 5074
                tmp___41 = malloc(memory_size___2);
#line 5074
                memory___2 = (char *)tmp___41;
                }
              } else {
                {
#line 5074
                tmp___42 = realloc((void *)result, memory_size___2);
#line 5074
                memory___2 = (char *)tmp___42;
                }
              }
#line 5074
              if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5074
                goto out_of_memory;
              }
#line 5074
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5074
                if (length > 0UL) {
                  {
#line 5074
                  memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                         length);
                  }
                }
              }
#line 5074
              result = memory___2;
            }
#line 5075
            goto __Cont;
          } else {
#line 5078
            count = retcount;
          }
#line 5084
          if (count < 0) {
#line 5086
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5086
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5087
                free((void *)result);
                }
              }
            }
#line 5088
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5089
              free((void *)buf_malloced);
              }
            }
            {
#line 5090
            free((void *)d.dir);
            }
#line 5090
            if (a.arg) {
              {
#line 5090
              free((void *)a.arg);
              }
            }
            {
#line 5091
            tmp___43 = __errno_location();
#line 5091
            *tmp___43 = 22;
            }
#line 5092
            return ((char *)((void *)0));
          }
#line 5101
          if ((size_t )((unsigned int )count + 1U) >= maxlen) {
#line 5106
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5107
              goto overflow;
            } else {
#line 5119
              if (allocated <= 9223372036854775807UL) {
#line 5119
                tmp___44 = allocated * 2UL;
              } else {
#line 5119
                tmp___44 = 0xffffffffffffffffUL;
              }
              {
#line 5119
              tmp___45 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5119
              tmp___46 = xmax((size_t )tmp___45, tmp___44);
#line 5119
              n___2 = (size_t )tmp___46;
              }
#line 5126
              if (n___2 > allocated) {
#line 5126
                if (allocated > 0UL) {
#line 5126
                  if (allocated <= 9223372036854775807UL) {
#line 5126
                    tmp___47 = allocated * 2UL;
                  } else {
#line 5126
                    tmp___47 = 0xffffffffffffffffUL;
                  }
#line 5126
                  allocated = tmp___47;
                } else {
#line 5126
                  allocated = (size_t )12;
                }
#line 5126
                if (n___2 > allocated) {
#line 5126
                  allocated = n___2;
                }
#line 5126
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5126
                  memory_size___3 = allocated * sizeof(char );
                } else {
#line 5126
                  memory_size___3 = 0xffffffffffffffffUL;
                }
#line 5126
                if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5126
                  goto out_of_memory;
                }
#line 5126
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5126
                  tmp___48 = malloc(memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___48;
                  }
                } else
#line 5126
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5126
                  tmp___48 = malloc(memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___48;
                  }
                } else {
                  {
#line 5126
                  tmp___49 = realloc((void *)result, memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___49;
                  }
                }
#line 5126
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5126
                  goto out_of_memory;
                }
#line 5126
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5126
                  if (length > 0UL) {
                    {
#line 5126
                    memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5126
                result = memory___3;
              }
#line 5127
              goto __Cont;
            }
          }
#line 5424
          length += (size_t )count;
#line 5425
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1576
    cp = dp->dir_end;
#line 1576
    i ++;
#line 1576
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5432
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5432
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5432
    if (allocated > 0UL) {
#line 5432
      if (allocated <= 9223372036854775807UL) {
#line 5432
        tmp___50 = allocated * 2UL;
      } else {
#line 5432
        tmp___50 = 0xffffffffffffffffUL;
      }
#line 5432
      allocated = tmp___50;
    } else {
#line 5432
      allocated = (size_t )12;
    }
    {
#line 5432
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5432
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5432
      tmp___51 = xsum(length, (size_t )1);
#line 5432
      allocated = (size_t )tmp___51;
      }
    }
#line 5432
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5432
      memory_size___4 = allocated * sizeof(char );
    } else {
#line 5432
      memory_size___4 = 0xffffffffffffffffUL;
    }
#line 5432
    if (memory_size___4 == 0xffffffffffffffffUL) {
#line 5432
      goto out_of_memory;
    }
#line 5432
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5432
      tmp___53 = malloc(memory_size___4);
#line 5432
      memory___4 = (char *)tmp___53;
      }
    } else
#line 5432
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5432
      tmp___53 = malloc(memory_size___4);
#line 5432
      memory___4 = (char *)tmp___53;
      }
    } else {
      {
#line 5432
      tmp___54 = realloc((void *)result, memory_size___4);
#line 5432
      memory___4 = (char *)tmp___54;
      }
    }
#line 5432
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5432
      goto out_of_memory;
    }
#line 5432
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5432
      if (length > 0UL) {
        {
#line 5432
        memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5432
    result = memory___4;
  }
#line 5433
  *(result + length) = (char )'\000';
#line 5435
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5435
    if (length + 1UL < allocated) {
      {
#line 5440
      tmp___56 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5440
      memory___5 = (char *)tmp___56;
      }
#line 5441
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5442
        result = memory___5;
      }
    }
  }
#line 5445
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5446
    free((void *)buf_malloced);
    }
  }
  {
#line 5447
  free((void *)d.dir);
  }
#line 5447
  if (a.arg) {
    {
#line 5447
    free((void *)a.arg);
    }
  }
#line 5448
  *lengthp = length;
#line 5453
  return (result);
  overflow: 
#line 5457
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5457
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5458
      free((void *)result);
      }
    }
  }
#line 5459
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5460
    free((void *)buf_malloced);
    }
  }
  {
#line 5461
  free((void *)d.dir);
  }
#line 5461
  if (a.arg) {
    {
#line 5461
    free((void *)a.arg);
    }
  }
  {
#line 5462
  tmp___57 = __errno_location();
#line 5462
  *tmp___57 = 75;
  }
#line 5463
  return ((char *)((void *)0));
  out_of_memory: 
#line 5467
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5467
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5468
      free((void *)result);
      }
    }
  }
#line 5469
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5470
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
  {
#line 5472
  free((void *)d.dir);
  }
#line 5472
  if (a.arg) {
    {
#line 5472
    free((void *)a.arg);
    }
  }
  {
#line 5473
  tmp___58 = __errno_location();
#line 5473
  *tmp___58 = 12;
  }
#line 5474
  return ((char *)((void *)0));
}
}
#line 4 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.h"
int fdutimens(char const   *file , int fd , struct timespec  const  *timespec ) ;
#line 5
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 6
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 7
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 364
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) utimensat)(int __fd ,
                                                                                      char const   *__path ,
                                                                                      struct timespec  const  *__times ,
                                                                                      int __flags ) ;
#line 372
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
#line 156
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
#line 529 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/stat-time.h"
__inline static struct timespec get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 109
  return ((struct timespec )st->st_atim);
}
}
#line 133 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/stat-time.h"
__inline static struct timespec get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 137
  return ((struct timespec )st->st_mtim);
}
}
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/timespec.h"
void gettime(struct timespec *ts ) ;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
static int utimensat_works_really  ;
#line 76 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
static int lutimensat_works_really  ;
#line 86 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ 
  int result ;
  int utime_omit_count ;
  int *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 89
  result = 0;
#line 90
  utime_omit_count = 0;
#line 91
  if (! timespec) {
    {
#line 91
    __assert_fail("timespec", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c",
                  91U, "validate_timespec");
    }
  }
#line 92
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 92
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 92
      if ((timespec + 0)->tv_nsec < 0L) {
        {
#line 99
        tmp = __errno_location();
#line 99
        *tmp = 22;
        }
#line 100
        return (-1);
      } else
#line 92
      if (1000000000L <= (timespec + 0)->tv_nsec) {
        {
#line 99
        tmp = __errno_location();
#line 99
        *tmp = 22;
        }
#line 100
        return (-1);
      } else {
#line 92
        goto _L___0;
      }
    } else {
#line 92
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 92
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 92
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 92
      if ((timespec + 1)->tv_nsec < 0L) {
        {
#line 99
        tmp = __errno_location();
#line 99
        *tmp = 22;
        }
#line 100
        return (-1);
      } else
#line 92
      if (1000000000L <= (timespec + 1)->tv_nsec) {
        {
#line 99
        tmp = __errno_location();
#line 99
        *tmp = 22;
        }
#line 100
        return (-1);
      }
    }
  }
#line 106
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 106
    goto _L___1;
  } else
#line 106
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: /* CIL Label */ 
#line 109
    (timespec + 0)->tv_sec = (__time_t )0;
#line 110
    result = 1;
#line 111
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 112
      utime_omit_count ++;
    }
  }
#line 114
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 114
    goto _L___2;
  } else
#line 114
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: /* CIL Label */ 
#line 117
    (timespec + 1)->tv_sec = (__time_t )0;
#line 118
    result = 1;
#line 119
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 120
      utime_omit_count ++;
    }
  }
#line 122
  return (result + (utime_omit_count == 1));
}
}
#line 131 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ 
  struct timespec *timespec ;

  {
#line 134
  timespec = *ts;
#line 135
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 135
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 137
      return ((_Bool)1);
    }
  }
#line 138
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 138
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 141
      *ts = (struct timespec *)((void *)0);
#line 142
      return ((_Bool)0);
    }
  }
#line 145
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
#line 146
    *(timespec + 0) = get_stat_atime(statbuf);
    }
  } else
#line 147
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
#line 148
    gettime(timespec + 0);
    }
  }
#line 150
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
#line 151
    *(timespec + 1) = get_stat_mtime(statbuf);
    }
  } else
#line 152
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
#line 153
    gettime(timespec + 1);
    }
  }
#line 155
  return ((_Bool)0);
}
}
#line 168 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
int fdutimens(char const   *file , int fd , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int tmp___1 ;
  int result ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;
  struct timeval timeval[2] ;
  struct timeval  const  *t ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;

  {
#line 172
  if (timespec) {
#line 172
    tmp = adjusted_timespec;
  } else {
#line 172
    tmp = (struct timespec *)((void *)0);
  }
#line 172
  ts = tmp;
#line 173
  adjustment_needed = 0;
#line 176
  if (ts) {
    {
#line 178
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 179
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 180
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 182
  if (adjustment_needed < 0) {
#line 183
    return (-1);
  }
#line 188
  if (! file) {
#line 190
    if (fd < 0) {
      {
#line 192
      tmp___0 = __errno_location();
#line 192
      *tmp___0 = 9;
      }
#line 193
      return (-1);
    }
    {
#line 195
    tmp___1 = dup2(fd, fd);
    }
#line 195
    if (tmp___1 != fd) {
#line 196
      return (-1);
    }
  }
#line 222
  if (0 <= utimensat_works_really) {
#line 234
    if (adjustment_needed == 2) {
#line 236
      if (fd < 0) {
        {
#line 236
        tmp___2 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 236
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 236
        tmp___3 = fstat(fd, & st);
#line 236
        tmp___4 = tmp___3;
        }
      }
#line 236
      if (tmp___4) {
#line 237
        return (-1);
      }
#line 238
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 239
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
        }
      } else
#line 240
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 241
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
        }
      }
#line 243
      adjustment_needed ++;
    }
#line 247
    if (fd < 0) {
      {
#line 249
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
      }
#line 258
      if (0 < result) {
        {
#line 259
        tmp___5 = __errno_location();
#line 259
        *tmp___5 = 38;
        }
      }
#line 261
      if (result == 0) {
#line 263
        utimensat_works_really = 1;
#line 264
        return (result);
      } else {
        {
#line 261
        tmp___6 = __errno_location();
        }
#line 261
        if (*tmp___6 != 38) {
#line 263
          utimensat_works_really = 1;
#line 264
          return (result);
        }
      }
    }
#line 269
    if (0 <= fd) {
      {
#line 271
      result = futimens(fd, (struct timespec  const  *)ts);
      }
#line 274
      if (0 < result) {
        {
#line 275
        tmp___7 = __errno_location();
#line 275
        *tmp___7 = 38;
        }
      }
#line 277
      if (result == 0) {
#line 279
        utimensat_works_really = 1;
#line 280
        return (result);
      } else {
        {
#line 277
        tmp___8 = __errno_location();
        }
#line 277
        if (*tmp___8 != 38) {
#line 279
          utimensat_works_really = 1;
#line 280
          return (result);
        }
      }
    }
  }
#line 285
  utimensat_works_really = -1;
#line 286
  lutimensat_works_really = -1;
#line 293
  if (adjustment_needed) {
#line 293
    goto _L;
  } else
#line 293
  if (0) {
    _L: /* CIL Label */ 
#line 295
    if (adjustment_needed != 3) {
#line 295
      if (fd < 0) {
        {
#line 295
        tmp___9 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 295
        tmp___11 = tmp___9;
        }
      } else {
        {
#line 295
        tmp___10 = fstat(fd, & st);
#line 295
        tmp___11 = tmp___10;
        }
      }
#line 295
      if (tmp___11) {
#line 297
        return (-1);
      }
    }
#line 298
    if (ts) {
      {
#line 298
      tmp___12 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 298
      if (tmp___12) {
#line 299
        return (0);
      }
    }
  }
#line 306
  if (ts) {
#line 308
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 309
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 310
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 311
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 312
    t = (struct timeval  const  *)(timeval);
  } else {
#line 315
    t = (struct timeval  const  *)((void *)0);
  }
#line 317
  if (fd < 0) {
    {
#line 320
    tmp___13 = futimesat(-100, file, (struct timeval  const  *)t);
    }
#line 320
    return (tmp___13);
  } else {
    {
#line 336
    tmp___14 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    }
#line 336
    if (tmp___14 == 0) {
#line 337
      return (0);
    }
  }
#line 345
  if (! file) {
#line 351
    return (-1);
  }
  {
#line 355
  tmp___15 = utimes(file, (struct timeval  const  *)t);
  }
#line 355
  return (tmp___15);
}
}
#line 385 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 388
  tmp = fdutimens(file, fd, timespec);
  }
#line 388
  return (tmp);
}
}
#line 393 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 396
  tmp = fdutimens(file, -1, timespec);
  }
#line 396
  return (tmp);
}
}
#line 403 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 407
  if (timespec) {
#line 407
    tmp = adjusted_timespec;
  } else {
#line 407
    tmp = (struct timespec *)((void *)0);
  }
#line 407
  ts = tmp;
#line 408
  adjustment_needed = 0;
#line 411
  if (ts) {
    {
#line 413
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 414
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 415
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 417
  if (adjustment_needed < 0) {
#line 418
    return (-1);
  }
#line 426
  if (0 <= lutimensat_works_really) {
#line 438
    if (adjustment_needed == 2) {
      {
#line 440
      tmp___0 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 440
      if (tmp___0) {
#line 441
        return (-1);
      }
#line 442
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 443
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
        }
      } else
#line 444
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 445
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
        }
      }
#line 447
      adjustment_needed ++;
    }
    {
#line 450
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
    }
#line 459
    if (0 < result) {
      {
#line 460
      tmp___1 = __errno_location();
#line 460
      *tmp___1 = 38;
      }
    }
#line 462
    if (result == 0) {
#line 464
      utimensat_works_really = 1;
#line 465
      lutimensat_works_really = 1;
#line 466
      return (result);
    } else {
      {
#line 462
      tmp___2 = __errno_location();
      }
#line 462
      if (*tmp___2 != 38) {
#line 464
        utimensat_works_really = 1;
#line 465
        lutimensat_works_really = 1;
#line 466
        return (result);
      }
    }
  }
#line 469
  lutimensat_works_really = -1;
#line 476
  if (adjustment_needed) {
#line 476
    goto _L;
  } else
#line 476
  if (0) {
    _L: /* CIL Label */ 
#line 478
    if (adjustment_needed != 3) {
      {
#line 478
      tmp___3 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 478
      if (tmp___3) {
#line 479
        return (-1);
      }
    }
#line 480
    if (ts) {
      {
#line 480
      tmp___4 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 480
      if (tmp___4) {
#line 481
        return (0);
      }
    }
  }
#line 509
  if (! adjustment_needed) {
    {
#line 509
    tmp___5 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
    }
#line 509
    if (tmp___5) {
#line 510
      return (-1);
    }
  }
#line 511
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
#line 512
    tmp___6 = fdutimens(file, -1, (struct timespec  const  *)ts);
    }
#line 512
    return (tmp___6);
  }
  {
#line 513
  tmp___7 = __errno_location();
#line 513
  *tmp___7 = 38;
  }
#line 514
  return (-1);
}
}
#line 46 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 35
  *p = (char)0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    p --;
#line 51
    *p = (char )(48UL + i % 10UL);
#line 50
    i /= 10UL;
#line 50
    if (! (i != 0UL)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (p);
}
}
#line 47 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 35
  *p = (char)0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    p --;
#line 51
    *p = (char )(48U + i % 10U);
#line 50
    i /= 10U;
#line 50
    if (! (i != 0U)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (p);
}
}
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 32
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 32
  end = (char const   *)tmp;
  }
#line 33
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 34
    return ((size_t )((end - string) + 1L));
  } else {
#line 36
    return (maxlen);
  }
}
}
#line 70 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname.h"
size_t base_len(char const   *name ) ;
#line 72
char *last_component(char const   *name ) ;
#line 74
_Bool strip_trailing_slashes(char *file ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 35
  tmp = last_component((char const   *)file);
#line 35
  base = tmp;
  }
#line 41
  if (! *base) {
#line 42
    base = file;
  }
  {
#line 43
  tmp___0 = base_len((char const   *)base);
#line 43
  base_lim = base + tmp___0;
#line 44
  had_slash = (_Bool )((int )*base_lim != 0);
#line 45
  *base_lim = (char )'\000';
  }
#line 46
  return (had_slash);
}
}
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/savedir.h"
char *savedir(char const   *dir ) ;
#line 27
char *fdsavedir(int fd ) ;
#line 142 "/usr/include/dirent.h"
extern DIR *fdopendir(int __fd ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 52 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/savedir.c"
static char *savedirstream(DIR *dirp ) 
{ 
  char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 56
  allocated = (size_t )512;
#line 57
  used = (size_t )0;
#line 60
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 61
    return ((char *)((void *)0));
  }
  {
#line 63
  tmp = xmalloc(allocated);
#line 63
  name_space = (char *)tmp;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp___0 = __errno_location();
#line 70
    *tmp___0 = 0;
#line 71
    tmp___1 = readdir(dirp);
#line 71
    dp = (struct dirent  const  *)tmp___1;
    }
#line 72
    if (! dp) {
#line 73
      goto while_break;
    }
#line 77
    entry = (char const   *)(dp->d_name);
#line 78
    if ((int const   )*(entry + 0) != 46) {
#line 78
      tmp___5 = 0;
    } else {
#line 78
      if ((int const   )*(entry + 1) != 46) {
#line 78
        tmp___4 = 1;
      } else {
#line 78
        tmp___4 = 2;
      }
#line 78
      tmp___5 = tmp___4;
    }
#line 78
    if ((int const   )*(entry + tmp___5) != 0) {
      {
#line 80
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 80
      entry_size = tmp___2 + 1UL;
      }
#line 81
      if (used + entry_size < used) {
        {
#line 82
        xalloc_die();
        }
      }
#line 83
      if (allocated <= used + entry_size) {
        {
#line 85
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 87
          if (2UL * allocated < allocated) {
            {
#line 88
            xalloc_die();
            }
          }
#line 89
          allocated *= 2UL;
#line 85
          if (! (allocated <= used + entry_size)) {
#line 85
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 93
        tmp___3 = xrealloc((void *)name_space, allocated);
#line 93
        name_space = (char *)tmp___3;
        }
      }
      {
#line 95
      memcpy((void */* __restrict  */)(name_space + used), (void const   */* __restrict  */)entry,
             entry_size);
#line 96
      used += entry_size;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  *(name_space + used) = (char )'\000';
#line 100
  tmp___6 = __errno_location();
#line 100
  save_errno = *tmp___6;
#line 101
  tmp___8 = closedir(dirp);
  }
#line 101
  if (tmp___8 != 0) {
    {
#line 102
    tmp___7 = __errno_location();
#line 102
    save_errno = *tmp___7;
    }
  }
#line 103
  if (save_errno != 0) {
    {
#line 105
    free((void *)name_space);
#line 106
    tmp___9 = __errno_location();
#line 106
    *tmp___9 = save_errno;
    }
#line 107
    return ((char *)((void *)0));
  }
#line 109
  return (name_space);
}
}
#line 117 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/savedir.c"
char *savedir(char const   *dir ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
  {
#line 120
  tmp = opendir_safer(dir);
#line 120
  tmp___0 = savedirstream(tmp);
  }
#line 120
  return (tmp___0);
}
}
#line 128 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/savedir.c"
char *fdsavedir(int fd ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
  {
#line 131
  tmp = fdopendir(fd);
#line 131
  tmp___0 = savedirstream(tmp);
  }
#line 131
  return (tmp___0);
}
}
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 33
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 34
void free_cwd(struct saved_cwd *cwd ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 35 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.h"
int chdir_long(char *dir ) ;
#line 23 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/unistd-safer.h"
int fd_safer(int fd ) ;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 78
  cwd->name = (char *)((void *)0);
#line 80
  cwd->desc = open(".", 0);
#line 82
  cwd->desc = fd_safer(cwd->desc);
  }
#line 83
  if (cwd->desc < 0) {
    {
#line 85
    cwd->name = xgetcwd();
    }
#line 86
    if (cwd->name) {
#line 86
      tmp = 0;
    } else {
#line 86
      tmp = -1;
    }
#line 86
    return (tmp);
  }
#line 89
  return (0);
}
}
#line 96 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 99
  if (0 <= (int )cwd->desc) {
    {
#line 100
    tmp = fchdir((int )cwd->desc);
    }
#line 100
    return (tmp);
  } else {
    {
#line 102
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 102
    return (tmp___0);
  }
}
}
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 108
  if (cwd->desc >= 0) {
    {
#line 109
    close(cwd->desc);
    }
  }
  {
#line 110
  free((void *)cwd->name);
  }
#line 111
  return;
}
}
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/safe-write.h"
size_t safe_write(int fd , void const   *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/safe-read.c"
size_t safe_write(int fd , void const   *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    tmp = write(fd, buf, count);
#line 68
    result = tmp;
    }
#line 70
    if (0L <= result) {
#line 71
      return ((size_t )result);
    } else {
      {
#line 72
      tmp___1 = __errno_location();
      }
#line 72
      if (*tmp___1 == 4) {
#line 73
        goto __Cont;
      } else {
        {
#line 74
        tmp___0 = __errno_location();
        }
#line 74
        if (*tmp___0 == 22) {
#line 74
          if (2147475456UL < count) {
#line 75
            count = (size_t )2147475456;
          } else {
#line 77
            return ((size_t )result);
          }
        } else {
#line 77
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    tmp = (ssize_t )read(fd, buf, count);
#line 68
    result = tmp;
    }
#line 70
    if (0L <= result) {
#line 71
      return ((size_t )result);
    } else {
      {
#line 72
      tmp___1 = __errno_location();
      }
#line 72
      if (*tmp___1 == 4) {
#line 73
        goto __Cont;
      } else {
        {
#line 74
        tmp___0 = __errno_location();
        }
#line 74
        if (*tmp___0 == 22) {
#line 74
          if (2147475456UL < count) {
#line 75
            count = (size_t )2147475456;
          } else {
#line 77
            return ((size_t )result);
          }
        } else {
#line 77
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 236 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg___0 ) ;
#line 324
char *quotearg(char const   *arg___0 ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg___0 , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg___0 , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg___0 ) ;
#line 363
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 122 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 123
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 123 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 126
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 126
    tmp = -1;
  } else {
#line 126
    tmp = -2;
  }
#line 126
  if ((size_t )tmp / s < n) {
    {
#line 127
    xalloc_die();
    }
  }
  {
#line 128
  tmp___0 = xmalloc(n * s);
  }
#line 128
  return (tmp___0);
}
}
#line 234
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 235
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 235 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 238
  if (sizeof(char ) == 1UL) {
    {
#line 238
    tmp = xmalloc(n);
#line 238
    tmp___1 = tmp;
    }
  } else {
    {
#line 238
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 238
    tmp___1 = tmp___0;
    }
  }
#line 238
  return ((char *)tmp___1);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 68 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 68 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 82 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 82
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 95 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 100 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  e = *tmp;
  }
#line 104
  if (o) {
#line 104
    tmp___0 = o;
  } else {
#line 104
    tmp___0 = & default_quoting_options;
  }
  {
#line 104
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 104
  p = (struct quoting_options *)tmp___1;
#line 106
  tmp___2 = __errno_location();
#line 106
  *tmp___2 = e;
  }
#line 107
  return (p);
}
}
#line 111 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 114
  if (o) {
#line 114
    tmp = o;
  } else {
#line 114
    tmp = & default_quoting_options;
  }
#line 114
  return (tmp->style);
}
}
#line 119 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 122
  if (o) {
#line 122
    tmp = o;
  } else {
#line 122
    tmp = & default_quoting_options;
  }
#line 122
  tmp->style = s;
#line 123
  return;
}
}
#line 130 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 133
  uc = (unsigned char )c;
#line 134
  if (o) {
#line 134
    tmp = o;
  } else {
#line 134
    tmp = & default_quoting_options;
  }
#line 134
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 136
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 137
  r = (int )((*p >> shift) & 1U);
#line 138
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 139
  return (r);
}
}
#line 146 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 150
  if (! o) {
#line 151
    o = & default_quoting_options;
  }
#line 152
  r = o->flags;
#line 153
  o->flags = i;
#line 154
  return (r);
}
}
#line 157 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 161
  if (! o) {
#line 162
    o = & default_quoting_options;
  }
#line 163
  o->style = (enum quoting_style )8;
#line 164
  if (! left_quote) {
    {
#line 165
    abort();
    }
  } else
#line 164
  if (! right_quote) {
    {
#line 165
    abort();
    }
  }
#line 166
  o->left_quote = left_quote;
#line 167
  o->right_quote = right_quote;
#line 168
  return;
}
}
#line 171 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 175
  o.style = style;
#line 176
  o.flags = 0;
#line 177
  memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
  }
#line 178
  return (o);
}
}
#line 183 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 186
  tmp = gettext(msgid);
#line 186
  translation = (char const   *)tmp;
  }
#line 187
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 187
    if ((unsigned int )s == 7U) {
#line 188
      translation = "\"";
    }
  }
#line 189
  return (translation);
}
}
#line 205 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg___0 ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 214
  len = (size_t )0;
#line 215
  quote_string = (char const   *)0;
#line 216
  quote_string_len = (size_t )0;
#line 217
  backslash_escapes = (_Bool)0;
#line 218
  tmp = __ctype_get_mb_cur_max();
#line 218
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 219
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 232
  if ((unsigned int )quoting_style == 4U) {
#line 232
    goto case_4;
  }
#line 236
  if ((unsigned int )quoting_style == 3U) {
#line 236
    goto case_3;
  }
#line 244
  if ((unsigned int )quoting_style == 5U) {
#line 244
    goto case_5;
  }
#line 251
  if ((unsigned int )quoting_style == 8U) {
#line 251
    goto case_8;
  }
#line 251
  if ((unsigned int )quoting_style == 7U) {
#line 251
    goto case_8;
  }
#line 251
  if ((unsigned int )quoting_style == 6U) {
#line 251
    goto case_8;
  }
#line 286
  if ((unsigned int )quoting_style == 1U) {
#line 286
    goto case_1;
  }
#line 290
  if ((unsigned int )quoting_style == 2U) {
#line 290
    goto case_2;
  }
#line 297
  if ((unsigned int )quoting_style == 0U) {
#line 297
    goto case_0;
  }
#line 301
  goto switch_default;
  case_4: /* CIL Label */ 
#line 233
  quoting_style = (enum quoting_style )3;
#line 234
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 237
  if (! elide_outer_quotes) {
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (len < buffersize) {
#line 238
        *(buffer + len) = (char )'\"';
      }
#line 238
      len ++;
#line 238
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 239
  backslash_escapes = (_Bool)1;
#line 240
  quote_string = "\"";
#line 241
  quote_string_len = (size_t )1;
#line 242
  goto switch_break;
  case_5: /* CIL Label */ 
#line 245
  backslash_escapes = (_Bool)1;
#line 246
  elide_outer_quotes = (_Bool)0;
#line 247
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 253
  if ((unsigned int )quoting_style != 8U) {
    {
#line 274
    left_quote = gettext_quote("`", quoting_style);
#line 275
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 277
  if (! elide_outer_quotes) {
#line 278
    quote_string = left_quote;
    {
#line 278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 278
      if (! *quote_string) {
#line 278
        goto while_break___0;
      }
      {
#line 279
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 279
        if (len < buffersize) {
#line 279
          *(buffer + len) = (char )*quote_string;
        }
#line 279
        len ++;
#line 279
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 278
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 280
  backslash_escapes = (_Bool)1;
#line 281
  quote_string = right_quote;
#line 282
  quote_string_len = strlen(quote_string);
  }
#line 284
  goto switch_break;
  case_1: /* CIL Label */ 
#line 287
  quoting_style = (enum quoting_style )2;
#line 288
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 291
  if (! elide_outer_quotes) {
    {
#line 292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 292
      if (len < buffersize) {
#line 292
        *(buffer + len) = (char )'\'';
      }
#line 292
      len ++;
#line 292
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 293
  quote_string = "\'";
#line 294
  quote_string_len = (size_t )1;
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
#line 298
  elide_outer_quotes = (_Bool)0;
#line 299
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 302
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 305
  i = (size_t )0;
  {
#line 305
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 305
    if (argsize == 0xffffffffffffffffUL) {
#line 305
      tmp___6 = (int const   )*(arg___0 + i) == 0;
    } else {
#line 305
      tmp___6 = i == argsize;
    }
#line 305
    if (tmp___6) {
#line 305
      goto while_break___3;
    }
#line 309
    is_right_quote = (_Bool)0;
#line 311
    if (backslash_escapes) {
#line 311
      if (quote_string_len) {
#line 311
        if (i + quote_string_len <= argsize) {
          {
#line 311
          tmp___0 = memcmp((void const   *)(arg___0 + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 311
          if (tmp___0 == 0) {
#line 316
            if (elide_outer_quotes) {
#line 317
              goto force_outer_quoting_style;
            }
#line 318
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 321
    c = (unsigned char )*(arg___0 + i);
    {
#line 324
    if ((int )c == 0) {
#line 324
      goto case_0___0;
    }
#line 350
    if ((int )c == 63) {
#line 350
      goto case_63;
    }
#line 388
    if ((int )c == 7) {
#line 388
      goto case_7___0;
    }
#line 389
    if ((int )c == 8) {
#line 389
      goto case_8___0;
    }
#line 390
    if ((int )c == 12) {
#line 390
      goto case_12;
    }
#line 391
    if ((int )c == 10) {
#line 391
      goto case_10;
    }
#line 392
    if ((int )c == 13) {
#line 392
      goto case_13;
    }
#line 393
    if ((int )c == 9) {
#line 393
      goto case_9;
    }
#line 394
    if ((int )c == 11) {
#line 394
      goto case_11;
    }
#line 395
    if ((int )c == 92) {
#line 395
      goto case_92;
    }
#line 414
    if ((int )c == 125) {
#line 414
      goto case_125;
    }
#line 414
    if ((int )c == 123) {
#line 414
      goto case_125;
    }
#line 418
    if ((int )c == 126) {
#line 418
      goto case_126;
    }
#line 418
    if ((int )c == 35) {
#line 418
      goto case_126;
    }
#line 430
    if ((int )c == 124) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 96) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 94) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 91) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 62) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 61) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 60) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 59) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 42) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 41) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 40) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 38) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 36) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 34) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 33) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 32) {
#line 430
      goto case_124;
    }
#line 440
    if ((int )c == 39) {
#line 440
      goto case_39___0;
    }
#line 462
    if ((int )c == 122) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 121) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 120) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 119) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 118) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 117) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 116) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 115) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 114) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 113) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 112) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 111) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 110) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 109) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 108) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 107) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 106) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 105) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 104) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 103) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 102) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 101) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 100) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 99) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 98) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 97) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 95) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 93) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 90) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 89) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 88) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 87) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 86) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 85) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 84) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 83) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 82) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 81) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 80) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 79) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 78) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 77) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 76) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 75) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 74) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 73) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 72) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 71) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 70) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 69) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 68) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 67) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 66) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 65) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 58) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 57) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 56) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 55) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 54) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 53) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 52) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 51) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 50) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 49) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 48) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 47) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 46) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 45) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 44) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 43) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 37) {
#line 462
      goto case_122;
    }
#line 475
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 325
    if (backslash_escapes) {
#line 327
      if (elide_outer_quotes) {
#line 328
        goto force_outer_quoting_style;
      }
      {
#line 329
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 329
        if (len < buffersize) {
#line 329
          *(buffer + len) = (char )'\\';
        }
#line 329
        len ++;
#line 329
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 335
      if (i + 1UL < argsize) {
#line 335
        if (48 <= (int )*(arg___0 + (i + 1UL))) {
#line 335
          if ((int const   )*(arg___0 + (i + 1UL)) <= 57) {
            {
#line 337
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 337
              if (len < buffersize) {
#line 337
                *(buffer + len) = (char )'0';
              }
#line 337
              len ++;
#line 337
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 338
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 338
              if (len < buffersize) {
#line 338
                *(buffer + len) = (char )'0';
              }
#line 338
              len ++;
#line 338
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 340
      c = (unsigned char )'0';
    } else
#line 346
    if (flags & 1) {
#line 347
      goto __Cont;
    }
#line 348
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 353
    if ((unsigned int )quoting_style == 2U) {
#line 353
      goto case_2___0;
    }
#line 358
    if ((unsigned int )quoting_style == 3U) {
#line 358
      goto case_3___0;
    }
#line 383
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 354
    if (elide_outer_quotes) {
#line 355
      goto force_outer_quoting_style;
    }
#line 356
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 359
    if (flags & 4) {
#line 359
      if (i + 2UL < argsize) {
#line 359
        if ((int const   )*(arg___0 + (i + 1UL)) == 63) {
          {
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 62) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 61) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 60) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 47) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 45) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 41) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 40) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 39) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2UL)) == 33) {
#line 365
            goto case_62;
          }
#line 378
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 368
          if (elide_outer_quotes) {
#line 369
            goto force_outer_quoting_style;
          }
#line 370
          c = (unsigned char )*(arg___0 + (i + 2UL));
#line 371
          i += 2UL;
          {
#line 372
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'?';
            }
#line 372
            len ++;
#line 372
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 373
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 373
            if (len < buffersize) {
#line 373
              *(buffer + len) = (char )'\"';
            }
#line 373
            len ++;
#line 373
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 374
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 374
            if (len < buffersize) {
#line 374
              *(buffer + len) = (char )'\"';
            }
#line 374
            len ++;
#line 374
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 375
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 375
            if (len < buffersize) {
#line 375
              *(buffer + len) = (char )'?';
            }
#line 375
            len ++;
#line 375
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 376
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 379
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 381
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 384
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 386
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 388
    esc = (unsigned char )'a';
#line 388
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 389
    esc = (unsigned char )'b';
#line 389
    goto c_escape;
    case_12: /* CIL Label */ 
#line 390
    esc = (unsigned char )'f';
#line 390
    goto c_escape;
    case_10: /* CIL Label */ 
#line 391
    esc = (unsigned char )'n';
#line 391
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 392
    esc = (unsigned char )'r';
#line 392
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 393
    esc = (unsigned char )'t';
#line 393
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 394
    esc = (unsigned char )'v';
#line 394
    goto c_escape;
    case_92: /* CIL Label */ 
#line 395
    esc = c;
#line 398
    if (backslash_escapes) {
#line 398
      if (elide_outer_quotes) {
#line 398
        if (quote_string_len) {
#line 399
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 402
    if ((unsigned int )quoting_style == 2U) {
#line 402
      if (elide_outer_quotes) {
#line 404
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 407
    if (backslash_escapes) {
#line 409
      c = esc;
#line 410
      goto store_escape;
    }
#line 412
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 415
    if (argsize == 0xffffffffffffffffUL) {
#line 415
      tmp___1 = (int const   )*(arg___0 + 1) == 0;
    } else {
#line 415
      tmp___1 = argsize == 1UL;
    }
#line 415
    if (! tmp___1) {
#line 416
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 419
    if (i != 0UL) {
#line 420
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 435
    if ((unsigned int )quoting_style == 2U) {
#line 435
      if (elide_outer_quotes) {
#line 437
        goto force_outer_quoting_style;
      }
    }
#line 438
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 441
    if ((unsigned int )quoting_style == 2U) {
#line 443
      if (elide_outer_quotes) {
#line 444
        goto force_outer_quoting_style;
      }
      {
#line 445
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 445
        if (len < buffersize) {
#line 445
          *(buffer + len) = (char )'\'';
        }
#line 445
        len ++;
#line 445
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 446
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 446
        if (len < buffersize) {
#line 446
          *(buffer + len) = (char )'\\';
        }
#line 446
        len ++;
#line 446
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 447
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 447
        if (len < buffersize) {
#line 447
          *(buffer + len) = (char )'\'';
        }
#line 447
        len ++;
#line 447
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 449
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 473
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 487
    if (unibyte_locale) {
      {
#line 489
      m = (size_t )1;
#line 490
      tmp___2 = __ctype_b_loc();
#line 490
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 495
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 497
      m = (size_t )0;
#line 498
      printable = (_Bool)1;
      }
#line 499
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 500
        argsize = strlen(arg___0);
        }
      }
      {
#line 502
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 505
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg___0 + (i + m)),
                          argsize - (i + m), & mbstate);
#line 505
        bytes = tmp___3;
        }
#line 507
        if (bytes == 0UL) {
#line 508
          goto while_break___14;
        } else
#line 509
        if (bytes == 0xffffffffffffffffUL) {
#line 511
          printable = (_Bool)0;
#line 512
          goto while_break___14;
        } else
#line 514
        if (bytes == 0xfffffffffffffffeUL) {
#line 516
          printable = (_Bool)0;
          {
#line 517
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 517
            if (i + m < argsize) {
#line 517
              if (! *(arg___0 + (i + m))) {
#line 517
                goto while_break___15;
              }
            } else {
#line 517
              goto while_break___15;
            }
#line 518
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 519
          goto while_break___14;
        } else {
#line 527
          if (elide_outer_quotes) {
#line 527
            if ((unsigned int )quoting_style == 2U) {
#line 531
              j = (size_t )1;
              {
#line 531
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 531
                if (! (j < bytes)) {
#line 531
                  goto while_break___16;
                }
                {
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 124) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 96) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 94) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 92) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 91) {
#line 535
                  goto case_124___0;
                }
#line 538
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 536
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 539
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 531
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 543
          tmp___4 = iswprint((wint_t )w);
          }
#line 543
          if (! tmp___4) {
#line 544
            printable = (_Bool)0;
          }
#line 545
          m += bytes;
        }
        {
#line 502
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 502
        if (tmp___5) {
#line 502
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 551
    if (1UL < m) {
#line 551
      goto _L___0;
    } else
#line 551
    if (backslash_escapes) {
#line 551
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 555
        ilim = i + m;
        {
#line 557
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 559
          if (backslash_escapes) {
#line 559
            if (! printable) {
#line 561
              if (elide_outer_quotes) {
#line 562
                goto force_outer_quoting_style;
              }
              {
#line 563
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 563
                if (len < buffersize) {
#line 563
                  *(buffer + len) = (char )'\\';
                }
#line 563
                len ++;
#line 563
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 564
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 564
                if (len < buffersize) {
#line 564
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 564
                len ++;
#line 564
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 565
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 565
                if (len < buffersize) {
#line 565
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 565
                len ++;
#line 565
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 566
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 559
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 568
          if (is_right_quote) {
            {
#line 570
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 570
              if (len < buffersize) {
#line 570
                *(buffer + len) = (char )'\\';
              }
#line 570
              len ++;
#line 570
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 571
            is_right_quote = (_Bool)0;
          }
#line 573
          if (ilim <= i + 1UL) {
#line 574
            goto while_break___17;
          }
          {
#line 575
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 575
            if (len < buffersize) {
#line 575
              *(buffer + len) = (char )c;
            }
#line 575
            len ++;
#line 575
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 576
          i ++;
#line 576
          c = (unsigned char )*(arg___0 + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 579
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 584
    if (backslash_escapes) {
#line 584
      goto _L___3;
    } else
#line 584
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 584
      if (quote_these_too) {
#line 584
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 584
          goto _L___2;
        }
      } else {
#line 584
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 584
    if (! is_right_quote) {
#line 588
      goto store_c;
    }
    store_escape: 
#line 591
    if (elide_outer_quotes) {
#line 592
      goto force_outer_quoting_style;
    }
    {
#line 593
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 593
      if (len < buffersize) {
#line 593
        *(buffer + len) = (char )'\\';
      }
#line 593
      len ++;
#line 593
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 596
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 596
      if (len < buffersize) {
#line 596
        *(buffer + len) = (char )c;
      }
#line 596
      len ++;
#line 596
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 305
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 599
  if (len == 0UL) {
#line 599
    if ((unsigned int )quoting_style == 2U) {
#line 599
      if (elide_outer_quotes) {
#line 601
        goto force_outer_quoting_style;
      }
    }
  }
#line 603
  if (quote_string) {
#line 603
    if (! elide_outer_quotes) {
      {
#line 604
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 604
        if (! *quote_string) {
#line 604
          goto while_break___25;
        }
        {
#line 605
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 605
          if (len < buffersize) {
#line 605
            *(buffer + len) = (char )*quote_string;
          }
#line 605
          len ++;
#line 605
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 604
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 607
  if (len < buffersize) {
#line 608
    *(buffer + len) = (char )'\000';
  }
#line 609
  return (len);
  force_outer_quoting_style: 
  {
#line 614
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg___0, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 614
  return (tmp___7);
}
}
#line 629 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 634
  if (o) {
#line 634
    tmp = o;
  } else {
#line 634
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 634
  p = tmp;
#line 635
  tmp___0 = __errno_location();
#line 635
  e = *tmp___0;
#line 636
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg___0, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 636
  r = tmp___1;
#line 639
  tmp___2 = __errno_location();
#line 639
  *tmp___2 = e;
  }
#line 640
  return (r);
}
}
#line 644 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 648
  tmp = quotearg_alloc_mem(arg___0, argsize, (size_t *)((void *)0), o);
  }
#line 648
  return (tmp);
}
}
#line 657 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 661
  if (o) {
#line 661
    tmp = o;
  } else {
#line 661
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 661
  p = tmp;
#line 662
  tmp___0 = __errno_location();
#line 662
  e = *tmp___0;
  }
#line 664
  if (size) {
#line 664
    tmp___1 = 0;
  } else {
#line 664
    tmp___1 = 1;
  }
  {
#line 664
  flags = (int )(p->flags | (int const   )tmp___1);
#line 665
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg___0, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 665
  bufsize = tmp___2 + 1UL;
#line 669
  tmp___3 = xcharalloc(bufsize);
#line 669
  buf = tmp___3;
#line 670
  quotearg_buffer_restyled(buf, bufsize, arg___0, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 673
  tmp___4 = __errno_location();
#line 673
  *tmp___4 = e;
  }
#line 674
  if (size) {
#line 675
    *size = bufsize - 1UL;
  }
#line 676
  return (buf);
}
}
#line 688 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static char slot0[256]  ;
#line 689 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static unsigned int nslots  =    1U;
#line 690 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 691 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 693 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 696
  sv = slotvec;
#line 698
  i = 1U;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < nslots)) {
#line 698
      goto while_break;
    }
    {
#line 699
    free((void *)(sv + i)->val);
#line 698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 702
    free((void *)(sv + 0)->val);
#line 703
    slotvec0.size = sizeof(slot0);
#line 704
    slotvec0.val = slot0;
    }
  }
#line 706
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 708
    free((void *)sv);
#line 709
    slotvec = & slotvec0;
    }
  }
#line 711
  nslots = 1U;
#line 712
  return;
}
}
#line 722 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg___0 , size_t argsize , struct quoting_options  const  *options___0 ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 726
  tmp = __errno_location();
#line 726
  e = *tmp;
#line 728
  n0 = (unsigned int )n;
#line 729
  sv = slotvec;
  }
#line 731
  if (n < 0) {
    {
#line 732
    abort();
    }
  }
#line 734
  if (nslots <= n0) {
#line 741
    n1 = (size_t )(n0 + 1U);
#line 742
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 744
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 744
      tmp___0 = -1;
    } else {
#line 744
      tmp___0 = -2;
    }
#line 744
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 745
      xalloc_die();
      }
    }
#line 747
    if (preallocated) {
#line 747
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 747
      tmp___1 = sv;
    }
    {
#line 747
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 747
    sv = (struct slotvec *)tmp___2;
#line 747
    slotvec = sv;
    }
#line 748
    if (preallocated) {
#line 749
      *sv = slotvec0;
    }
    {
#line 750
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 751
    nslots = (unsigned int )n1;
    }
  }
  {
#line 755
  size = (sv + n)->size;
#line 756
  val = (sv + n)->val;
#line 758
  flags = (int )(options___0->flags | 1);
#line 759
  tmp___3 = quotearg_buffer_restyled(val, size, arg___0, argsize, (enum quoting_style )options___0->style,
                                     flags, (unsigned int const   *)(options___0->quote_these_too),
                                     (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
#line 759
  qsize = tmp___3;
  }
#line 765
  if (size <= qsize) {
#line 767
    size = qsize + 1UL;
#line 767
    (sv + n)->size = size;
#line 768
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 769
      free((void *)val);
      }
    }
    {
#line 770
    val = xcharalloc(size);
#line 770
    (sv + n)->val = val;
#line 771
    quotearg_buffer_restyled(val, size, arg___0, argsize, (enum quoting_style )options___0->style,
                             flags, (unsigned int const   *)(options___0->quote_these_too),
                             (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
    }
  }
  {
#line 777
  tmp___4 = __errno_location();
#line 777
  *tmp___4 = e;
  }
#line 778
  return (val);
}
}
#line 782 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n(int n , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 785
  tmp = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 785
  return (tmp);
}
}
#line 788 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 791
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 791
  return (tmp);
}
}
#line 794 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 797
  tmp = quotearg_n(0, arg___0);
  }
#line 797
  return (tmp);
}
}
#line 800 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 803
  tmp = quotearg_n_mem(0, arg___0, argsize);
  }
#line 803
  return (tmp);
}
}
#line 806 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 809
  tmp = quoting_options_from_style(s);
#line 809
  o = tmp;
#line 810
  tmp___0 = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 810
  return (tmp___0);
}
}
#line 813 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 817
  tmp = quoting_options_from_style(s);
#line 817
  o = tmp;
#line 818
  tmp___0 = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o));
  }
#line 818
  return (tmp___0);
}
}
#line 821 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 824
  tmp = quotearg_n_style(0, s, arg___0);
  }
#line 824
  return (tmp);
}
}
#line 827 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 830
  tmp = quotearg_n_style_mem(0, s, arg___0, argsize);
  }
#line 830
  return (tmp);
}
}
#line 833 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch ) 
{ 
  struct quoting_options options___0 ;
  char *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 837
  options___0 = default_quoting_options;
#line 838
  set_char_quoting(& options___0, ch, 1);
#line 839
  tmp = quotearg_n_options(0, arg___0, argsize, (struct quoting_options  const  *)(& options___0));
  }
#line 839
  return (tmp);
}
}
#line 842 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_char(char const   *arg___0 , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 845
  tmp = quotearg_char_mem(arg___0, (size_t )-1, ch);
  }
#line 845
  return (tmp);
}
}
#line 848 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_colon(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 851
  tmp = quotearg_char(arg___0, (char )':');
  }
#line 851
  return (tmp);
}
}
#line 854 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 857
  tmp = quotearg_char_mem(arg___0, argsize, (char )':');
  }
#line 857
  return (tmp);
}
}
#line 860 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 864
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg___0, (size_t )-1);
  }
#line 864
  return (tmp);
}
}
#line 868 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 873
  o = default_quoting_options;
#line 874
  set_custom_quoting(& o, left_quote, right_quote);
#line 875
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o));
  }
#line 875
  return (tmp);
}
}
#line 878 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 882
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg___0);
  }
#line 882
  return (tmp);
}
}
#line 885 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 889
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg___0, argsize);
  }
#line 889
  return (tmp);
}
}
#line 22 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 23
char const   *quote(char const   *name ) ;
#line 30 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 33
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 33
  return ((char const   *)tmp);
}
}
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 41
  tmp = quote_n(0, name);
  }
#line 41
  return (tmp);
}
}
#line 34 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/progname.h"
char const   *program_name ;
#line 39
void set_program_name(char const   *argv0 ) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 35 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 40 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 53
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 56
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 58
    abort();
    }
  }
  {
#line 61
  tmp = strrchr(argv0, '/');
#line 61
  slash = (char const   *)tmp;
  }
#line 62
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 62
    base = slash + 1;
  } else {
#line 62
    base = argv0;
  }
#line 63
  if (base - argv0 >= 7L) {
    {
#line 63
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 63
    if (tmp___1 == 0) {
      {
#line 65
      argv0 = base;
#line 66
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 66
      if (tmp___0 == 0) {
#line 68
        argv0 = base + 3;
#line 72
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 86
  program_name = argv0;
#line 92
  program_invocation_name = (char *)argv0;
#line 94
  return;
}
}
#line 82 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  int __cil_tmp64 ;
  void *__cil_tmp65 ;

  {
  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )1;
#line 94
  tmp = malloc(d_allocated * sizeof(char_directive ));
#line 94
  d->dir = (char_directive *)tmp;
  }
#line 95
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 97
    goto out_of_memory_1;
  }
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )0;
#line 101
  a->arg = (argument *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*cp != 0)) {
#line 135
      goto while_break;
    }
#line 137
    tmp___0 = cp;
#line 137
    cp ++;
#line 137
    c = (char )*tmp___0;
#line 138
    if ((int )c == 37) {
#line 140
      arg_index = ~ ((size_t )0);
#line 141
      dp = d->dir + d->count;
#line 144
      dp->dir_start = cp - 1;
#line 145
      dp->flags = 0;
#line 146
      dp->width_start = (char const   *)((void *)0);
#line 147
      dp->width_end = (char const   *)((void *)0);
#line 148
      dp->width_arg_index = ~ ((size_t )0);
#line 149
      dp->precision_start = (char const   *)((void *)0);
#line 150
      dp->precision_end = (char const   *)((void *)0);
#line 151
      dp->precision_arg_index = ~ ((size_t )0);
#line 152
      dp->arg_index = ~ ((size_t )0);
#line 155
      if ((int const   )*cp >= 48) {
#line 155
        if ((int const   )*cp <= 57) {
#line 159
          np = cp;
          {
#line 159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 159
            if ((int const   )*np >= 48) {
#line 159
              if (! ((int const   )*np <= 57)) {
#line 159
                goto while_break___0;
              }
            } else {
#line 159
              goto while_break___0;
            }
#line 159
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 161
          if ((int const   )*np == 36) {
#line 163
            n = (size_t )0;
#line 165
            np = cp;
            {
#line 165
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 165
              if ((int const   )*np >= 48) {
#line 165
                if (! ((int const   )*np <= 57)) {
#line 165
                  goto while_break___1;
                }
              } else {
#line 165
                goto while_break___1;
              }
#line 166
              if (n <= 1844674407370955161UL) {
#line 166
                tmp___1 = n * 10UL;
              } else {
#line 166
                tmp___1 = 0xffffffffffffffffUL;
              }
              {
#line 166
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 166
              n = (size_t )tmp___2;
#line 165
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 167
            if (n == 0UL) {
#line 169
              goto error;
            }
#line 170
            if (n == 0xffffffffffffffffUL) {
#line 172
              goto error;
            }
#line 173
            arg_index = n - 1UL;
#line 174
            cp = np + 1;
          }
        }
      }
      {
#line 179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 181
        if ((int const   )*cp == 39) {
#line 183
          dp->flags |= 1;
#line 184
          cp ++;
        } else
#line 186
        if ((int const   )*cp == 45) {
#line 188
          dp->flags |= 2;
#line 189
          cp ++;
        } else
#line 191
        if ((int const   )*cp == 43) {
#line 193
          dp->flags |= 4;
#line 194
          cp ++;
        } else
#line 196
        if ((int const   )*cp == 32) {
#line 198
          dp->flags |= 8;
#line 199
          cp ++;
        } else
#line 201
        if ((int const   )*cp == 35) {
#line 203
          dp->flags |= 16;
#line 204
          cp ++;
        } else
#line 206
        if ((int const   )*cp == 48) {
#line 208
          dp->flags |= 32;
#line 209
          cp ++;
        } else {
#line 212
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      if ((int const   )*cp == 42) {
#line 218
        dp->width_start = cp;
#line 219
        cp ++;
#line 220
        dp->width_end = cp;
#line 221
        if (max_width_length < 1UL) {
#line 222
          max_width_length = (size_t )1;
        }
#line 225
        if ((int const   )*cp >= 48) {
#line 225
          if ((int const   )*cp <= 57) {
#line 229
            np___0 = cp;
            {
#line 229
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 229
              if ((int const   )*np___0 >= 48) {
#line 229
                if (! ((int const   )*np___0 <= 57)) {
#line 229
                  goto while_break___3;
                }
              } else {
#line 229
                goto while_break___3;
              }
#line 229
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 231
            if ((int const   )*np___0 == 36) {
#line 233
              n___0 = (size_t )0;
#line 235
              np___0 = cp;
              {
#line 235
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 235
                if ((int const   )*np___0 >= 48) {
#line 235
                  if (! ((int const   )*np___0 <= 57)) {
#line 235
                    goto while_break___4;
                  }
                } else {
#line 235
                  goto while_break___4;
                }
#line 236
                if (n___0 <= 1844674407370955161UL) {
#line 236
                  tmp___3 = n___0 * 10UL;
                } else {
#line 236
                  tmp___3 = 0xffffffffffffffffUL;
                }
                {
#line 236
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 236
                n___0 = (size_t )tmp___4;
#line 235
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 237
              if (n___0 == 0UL) {
#line 239
                goto error;
              }
#line 240
              if (n___0 == 0xffffffffffffffffUL) {
#line 242
                goto error;
              }
#line 243
              dp->width_arg_index = n___0 - 1UL;
#line 244
              cp = np___0 + 1;
            }
          }
        }
#line 247
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 249
          tmp___5 = arg_posn;
#line 249
          arg_posn ++;
#line 249
          dp->width_arg_index = tmp___5;
#line 250
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 252
            goto error;
          }
        }
#line 254
        n___1 = dp->width_arg_index;
#line 254
        if (n___1 >= a_allocated) {
#line 254
          if (a_allocated <= 9223372036854775807UL) {
#line 254
            a_allocated *= 2UL;
          } else {
#line 254
            a_allocated = 0xffffffffffffffffUL;
          }
#line 254
          if (a_allocated <= n___1) {
            {
#line 254
            tmp___6 = xsum(n___1, (size_t )1);
#line 254
            a_allocated = (size_t )tmp___6;
            }
          }
#line 254
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 254
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 254
            memory_size = 0xffffffffffffffffUL;
          }
#line 254
          if (memory_size == 0xffffffffffffffffUL) {
#line 254
            goto out_of_memory;
          }
#line 254
          if (a->arg) {
            {
#line 254
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 254
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 254
            tmp___8 = malloc(memory_size);
#line 254
            tmp___9 = tmp___8;
            }
          }
#line 254
          memory = (argument *)tmp___9;
#line 254
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 254
            goto out_of_memory;
          }
#line 254
          a->arg = memory;
        }
        {
#line 254
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 254
          if (! (a->count <= n___1)) {
#line 254
            goto while_break___5;
          }
#line 254
          tmp___10 = a->count;
#line 254
          (a->count) ++;
#line 254
          (a->arg + tmp___10)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 254
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 254
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 254
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 254
          goto error;
        }
      } else
#line 256
      if ((int const   )*cp >= 48) {
#line 256
        if ((int const   )*cp <= 57) {
#line 260
          dp->width_start = cp;
          {
#line 261
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 261
            if ((int const   )*cp >= 48) {
#line 261
              if (! ((int const   )*cp <= 57)) {
#line 261
                goto while_break___6;
              }
            } else {
#line 261
              goto while_break___6;
            }
#line 261
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 263
          dp->width_end = cp;
#line 264
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 265
          if (max_width_length < width_length) {
#line 266
            max_width_length = width_length;
          }
        }
      }
#line 270
      if ((int const   )*cp == 46) {
#line 272
        cp ++;
#line 273
        if ((int const   )*cp == 42) {
#line 275
          dp->precision_start = cp - 1;
#line 276
          cp ++;
#line 277
          dp->precision_end = cp;
#line 278
          if (max_precision_length < 2UL) {
#line 279
            max_precision_length = (size_t )2;
          }
#line 282
          if ((int const   )*cp >= 48) {
#line 282
            if ((int const   )*cp <= 57) {
#line 286
              np___1 = cp;
              {
#line 286
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 286
                if ((int const   )*np___1 >= 48) {
#line 286
                  if (! ((int const   )*np___1 <= 57)) {
#line 286
                    goto while_break___7;
                  }
                } else {
#line 286
                  goto while_break___7;
                }
#line 286
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 288
              if ((int const   )*np___1 == 36) {
#line 290
                n___2 = (size_t )0;
#line 292
                np___1 = cp;
                {
#line 292
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 292
                  if ((int const   )*np___1 >= 48) {
#line 292
                    if (! ((int const   )*np___1 <= 57)) {
#line 292
                      goto while_break___8;
                    }
                  } else {
#line 292
                    goto while_break___8;
                  }
#line 293
                  if (n___2 <= 1844674407370955161UL) {
#line 293
                    tmp___11 = n___2 * 10UL;
                  } else {
#line 293
                    tmp___11 = 0xffffffffffffffffUL;
                  }
                  {
#line 293
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 293
                  n___2 = (size_t )tmp___12;
#line 292
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 294
                if (n___2 == 0UL) {
#line 296
                  goto error;
                }
#line 297
                if (n___2 == 0xffffffffffffffffUL) {
#line 300
                  goto error;
                }
#line 301
                dp->precision_arg_index = n___2 - 1UL;
#line 302
                cp = np___1 + 1;
              }
            }
          }
#line 305
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 307
            tmp___13 = arg_posn;
#line 307
            arg_posn ++;
#line 307
            dp->precision_arg_index = tmp___13;
#line 308
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 310
              goto error;
            }
          }
#line 312
          n___3 = dp->precision_arg_index;
#line 312
          if (n___3 >= a_allocated) {
#line 312
            if (a_allocated <= 9223372036854775807UL) {
#line 312
              a_allocated *= 2UL;
            } else {
#line 312
              a_allocated = 0xffffffffffffffffUL;
            }
#line 312
            if (a_allocated <= n___3) {
              {
#line 312
              tmp___14 = xsum(n___3, (size_t )1);
#line 312
              a_allocated = (size_t )tmp___14;
              }
            }
#line 312
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 312
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 312
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 312
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 312
              goto out_of_memory;
            }
#line 312
            if (a->arg) {
              {
#line 312
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 312
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 312
              tmp___16 = malloc(memory_size___0);
#line 312
              tmp___17 = tmp___16;
              }
            }
#line 312
            memory___0 = (argument *)tmp___17;
#line 312
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 312
              goto out_of_memory;
            }
#line 312
            a->arg = memory___0;
          }
          {
#line 312
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 312
            if (! (a->count <= n___3)) {
#line 312
              goto while_break___9;
            }
#line 312
            tmp___18 = a->count;
#line 312
            (a->count) ++;
#line 312
            (a->arg + tmp___18)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 312
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 312
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 312
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 312
            goto error;
          }
        } else {
#line 318
          dp->precision_start = cp - 1;
          {
#line 319
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 319
            if ((int const   )*cp >= 48) {
#line 319
              if (! ((int const   )*cp <= 57)) {
#line 319
                goto while_break___10;
              }
            } else {
#line 319
              goto while_break___10;
            }
#line 319
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 321
          dp->precision_end = cp;
#line 322
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 323
          if (max_precision_length < precision_length) {
#line 324
            max_precision_length = precision_length;
          }
        }
      }
#line 333
      flags = 0;
      {
#line 335
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 337
        if ((int const   )*cp == 104) {
#line 339
          flags |= 1 << (flags & 1);
#line 340
          cp ++;
        } else
#line 342
        if ((int const   )*cp == 76) {
#line 344
          flags |= 4;
#line 345
          cp ++;
        } else
#line 347
        if ((int const   )*cp == 108) {
#line 349
          flags += 8;
#line 350
          cp ++;
        } else
#line 352
        if ((int const   )*cp == 106) {
#line 354
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 357
            flags += 16;
          } else
#line 359
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 362
            flags += 8;
          }
#line 364
          cp ++;
        } else
#line 366
        if ((int const   )*cp == 122) {
#line 366
          goto _L;
        } else
#line 366
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 371
          if (sizeof(size_t ) > sizeof(long )) {
#line 374
            flags += 16;
          } else
#line 376
          if (sizeof(size_t ) > sizeof(int )) {
#line 379
            flags += 8;
          }
#line 381
          cp ++;
        } else
#line 383
        if ((int const   )*cp == 116) {
#line 385
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 388
            flags += 16;
          } else
#line 390
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 393
            flags += 8;
          }
#line 395
          cp ++;
        } else {
#line 436
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 440
      tmp___19 = cp;
#line 440
      cp ++;
#line 440
      c = (char )*tmp___19;
      {
#line 443
      if ((int )c == 105) {
#line 443
        goto case_105;
      }
#line 443
      if ((int )c == 100) {
#line 443
        goto case_105;
      }
#line 461
      if ((int )c == 88) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 120) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 117) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 111) {
#line 461
        goto case_88;
      }
#line 480
      if ((int )c == 65) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 97) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 71) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 103) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 69) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 101) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 70) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 102) {
#line 480
        goto case_65;
      }
#line 486
      if ((int )c == 99) {
#line 486
        goto case_99;
      }
#line 497
      if ((int )c == 67) {
#line 497
        goto case_67;
      }
#line 502
      if ((int )c == 115) {
#line 502
        goto case_115;
      }
#line 513
      if ((int )c == 83) {
#line 513
        goto case_83;
      }
#line 518
      if ((int )c == 112) {
#line 518
        goto case_112;
      }
#line 521
      if ((int )c == 110) {
#line 521
        goto case_110;
      }
#line 550
      if ((int )c == 37) {
#line 550
        goto case_37;
      }
#line 553
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 446
      if (flags >= 16) {
#line 447
        type = (arg_type )9;
      } else
#line 446
      if (flags & 4) {
#line 447
        type = (arg_type )9;
      } else
#line 452
      if (flags >= 8) {
#line 453
        type = (arg_type )7;
      } else
#line 454
      if (flags & 2) {
#line 455
        type = (arg_type )1;
      } else
#line 456
      if (flags & 1) {
#line 457
        type = (arg_type )3;
      } else {
#line 459
        type = (arg_type )5;
      }
#line 460
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 464
      if (flags >= 16) {
#line 465
        type = (arg_type )10;
      } else
#line 464
      if (flags & 4) {
#line 465
        type = (arg_type )10;
      } else
#line 470
      if (flags >= 8) {
#line 471
        type = (arg_type )8;
      } else
#line 472
      if (flags & 2) {
#line 473
        type = (arg_type )2;
      } else
#line 474
      if (flags & 1) {
#line 475
        type = (arg_type )4;
      } else {
#line 477
        type = (arg_type )6;
      }
#line 478
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 481
      if (flags >= 16) {
#line 482
        type = (arg_type )12;
      } else
#line 481
      if (flags & 4) {
#line 482
        type = (arg_type )12;
      } else {
#line 484
        type = (arg_type )11;
      }
#line 485
      goto switch_break;
      case_99: /* CIL Label */ 
#line 487
      if (flags >= 8) {
#line 489
        type = (arg_type )14;
      } else {
#line 494
        type = (arg_type )13;
      }
#line 495
      goto switch_break;
      case_67: /* CIL Label */ 
#line 498
      type = (arg_type )14;
#line 499
      c = (char )'c';
#line 500
      goto switch_break;
      case_115: /* CIL Label */ 
#line 503
      if (flags >= 8) {
#line 505
        type = (arg_type )16;
      } else {
#line 510
        type = (arg_type )15;
      }
#line 511
      goto switch_break;
      case_83: /* CIL Label */ 
#line 514
      type = (arg_type )16;
#line 515
      c = (char )'s';
#line 516
      goto switch_break;
      case_112: /* CIL Label */ 
#line 519
      type = (arg_type )17;
#line 520
      goto switch_break;
      case_110: /* CIL Label */ 
#line 524
      if (flags >= 16) {
#line 525
        type = (arg_type )22;
      } else
#line 524
      if (flags & 4) {
#line 525
        type = (arg_type )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (arg_type )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (arg_type )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (arg_type )19;
      } else {
#line 537
        type = (arg_type )20;
      }
#line 538
      goto switch_break;
      case_37: /* CIL Label */ 
#line 551
      type = (arg_type )0;
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 555
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 564
          tmp___20 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = tmp___20;
#line 565
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          if (a_allocated <= 9223372036854775807UL) {
#line 569
            a_allocated *= 2UL;
          } else {
#line 569
            a_allocated = 0xffffffffffffffffUL;
          }
#line 569
          if (a_allocated <= n___4) {
            {
#line 569
            tmp___21 = xsum(n___4, (size_t )1);
#line 569
            a_allocated = (size_t )tmp___21;
            }
          }
#line 569
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 569
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 569
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 569
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 569
            goto out_of_memory;
          }
#line 569
          if (a->arg) {
            {
#line 569
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 569
            tmp___24 = tmp___22;
            }
          } else {
            {
#line 569
            tmp___23 = malloc(memory_size___1);
#line 569
            tmp___24 = tmp___23;
            }
          }
#line 569
          memory___1 = (argument *)tmp___24;
#line 569
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          a->arg = memory___1;
        }
        {
#line 569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 569
          if (! (a->count <= n___4)) {
#line 569
            goto while_break___12;
          }
#line 569
          tmp___25 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + tmp___25)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        if (d_allocated <= 9223372036854775807UL) {
#line 581
          d_allocated *= 2UL;
        } else {
#line 581
          d_allocated = 0xffffffffffffffffUL;
        }
#line 582
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 582
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 582
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 583
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 585
          goto out_of_memory;
        }
        {
#line 586
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 586
        memory___2 = (char_directive *)tmp___26;
        }
#line 587
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 589
          goto out_of_memory;
        }
#line 590
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  (d->dir + d->count)->dir_start = cp;
#line 603
  d->max_width_length = max_width_length;
#line 604
  d->max_precision_length = max_precision_length;
#line 605
  return (0);
  error: 
#line 608
  if (a->arg) {
    {
#line 609
    free((void *)a->arg);
    }
  }
#line 610
  if (d->dir) {
    {
#line 611
    free((void *)d->dir);
    }
  }
  {
#line 612
  tmp___27 = __errno_location();
#line 612
  *tmp___27 = 22;
  }
#line 613
  return (-1);
  out_of_memory: 
#line 616
  if (a->arg) {
    {
#line 617
    free((void *)a->arg);
    }
  }
#line 618
  if (d->dir) {
    {
#line 619
    free((void *)d->dir);
    }
  }
  out_of_memory_1: 
  {
#line 621
  tmp___28 = __errno_location();
#line 621
  *tmp___28 = 12;
  }
#line 622
  return (-1);
}
}
#line 115 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 44
  i = (size_t )0;
#line 44
  ap = a->arg + 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < a->count)) {
#line 44
      goto while_break;
    }
    {
#line 47
    if ((unsigned int )ap->type == 1U) {
#line 47
      goto case_1;
    }
#line 50
    if ((unsigned int )ap->type == 2U) {
#line 50
      goto case_2;
    }
#line 53
    if ((unsigned int )ap->type == 3U) {
#line 53
      goto case_3;
    }
#line 56
    if ((unsigned int )ap->type == 4U) {
#line 56
      goto case_4;
    }
#line 59
    if ((unsigned int )ap->type == 5U) {
#line 59
      goto case_5;
    }
#line 62
    if ((unsigned int )ap->type == 6U) {
#line 62
      goto case_6;
    }
#line 65
    if ((unsigned int )ap->type == 7U) {
#line 65
      goto case_7;
    }
#line 68
    if ((unsigned int )ap->type == 8U) {
#line 68
      goto case_8;
    }
#line 72
    if ((unsigned int )ap->type == 9U) {
#line 72
      goto case_9;
    }
#line 75
    if ((unsigned int )ap->type == 10U) {
#line 75
      goto case_10;
    }
#line 79
    if ((unsigned int )ap->type == 11U) {
#line 79
      goto case_11;
    }
#line 82
    if ((unsigned int )ap->type == 12U) {
#line 82
      goto case_12;
    }
#line 85
    if ((unsigned int )ap->type == 13U) {
#line 85
      goto case_13;
    }
#line 89
    if ((unsigned int )ap->type == 14U) {
#line 89
      goto case_14;
    }
#line 99
    if ((unsigned int )ap->type == 15U) {
#line 99
      goto case_15;
    }
#line 108
    if ((unsigned int )ap->type == 16U) {
#line 108
      goto case_16;
    }
#line 126
    if ((unsigned int )ap->type == 17U) {
#line 126
      goto case_17;
    }
#line 129
    if ((unsigned int )ap->type == 18U) {
#line 129
      goto case_18;
    }
#line 132
    if ((unsigned int )ap->type == 19U) {
#line 132
      goto case_19;
    }
#line 135
    if ((unsigned int )ap->type == 20U) {
#line 135
      goto case_20;
    }
#line 138
    if ((unsigned int )ap->type == 21U) {
#line 138
      goto case_21;
    }
#line 142
    if ((unsigned int )ap->type == 22U) {
#line 142
      goto case_22;
    }
#line 185
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 48
    tmp = __builtin_va_arg(args, int );
#line 48
    ap->a.a_schar = tmp;
    }
#line 49
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 51
    tmp___0 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_uchar = tmp___0;
    }
#line 52
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 54
    tmp___1 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_short = tmp___1;
    }
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    tmp___2 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_ushort = tmp___2;
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    tmp___3 = __builtin_va_arg(args, int );
#line 60
    ap->a.a_int = tmp___3;
    }
#line 61
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 63
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 63
    ap->a.a_uint = tmp___4;
    }
#line 64
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 66
    tmp___5 = __builtin_va_arg(args, long );
#line 66
    ap->a.a_longint = tmp___5;
    }
#line 67
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 69
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 69
    ap->a.a_ulongint = tmp___6;
    }
#line 70
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 73
    tmp___7 = __builtin_va_arg(args, long long );
#line 73
    ap->a.a_longlongint = tmp___7;
    }
#line 74
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 76
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 76
    ap->a.a_ulonglongint = tmp___8;
    }
#line 77
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 80
    tmp___9 = __builtin_va_arg(args, double );
#line 80
    ap->a.a_double = tmp___9;
    }
#line 81
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 83
    tmp___10 = __builtin_va_arg(args, long double );
#line 83
    ap->a.a_longdouble = tmp___10;
    }
#line 84
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 86
    tmp___11 = __builtin_va_arg(args, int );
#line 86
    ap->a.a_char = tmp___11;
    }
#line 87
    goto switch_break;
    case_14: /* CIL Label */ 
#line 93
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 93
      tmp___13 = __builtin_va_arg(args, int );
#line 93
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 93
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 93
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 97
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 100
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 100
    ap->a.a_string = tmp___16;
    }
#line 104
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 105
      ap->a.a_string = "(NULL)";
    }
#line 106
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 109
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 109
    ap->a.a_wide_string = tmp___17;
    }
#line 113
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 122
      ap->a.a_wide_string = wide_null_string;
    }
#line 124
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 127
    tmp___18 = __builtin_va_arg(args, void *);
#line 127
    ap->a.a_pointer = tmp___18;
    }
#line 128
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 130
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 130
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 131
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 133
    tmp___20 = __builtin_va_arg(args, short *);
#line 133
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 134
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 136
    tmp___21 = __builtin_va_arg(args, int *);
#line 136
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 137
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 139
    tmp___22 = __builtin_va_arg(args, long *);
#line 139
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 140
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 143
    tmp___23 = __builtin_va_arg(args, long long *);
#line 143
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 144
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 187
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 44
    i ++;
#line 44
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  tmp___1 = pipe(fd);
  }
#line 36
  if (tmp___1 == 0) {
#line 39
    i = 0;
    {
#line 39
    while (1) {
      while_continue: /* CIL Label */ ;
#line 39
      if (! (i < 2)) {
#line 39
        goto while_break;
      }
      {
#line 41
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 42
      if (*(fd + i) < 0) {
        {
#line 44
        tmp = __errno_location();
#line 44
        e = *tmp;
#line 45
        close(*(fd + (1 - i)));
#line 46
        tmp___0 = __errno_location();
#line 46
        *tmp___0 = e;
        }
#line 47
        return (-1);
      }
#line 39
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 51
    return (0);
  }
#line 57
  return (-1);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dirfd)(DIR *__dirp ) ;
#line 22 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/unistd-safer.h"
int dup_safer(int fd ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 35
  tmp = opendir(name);
#line 35
  dp = tmp;
  }
#line 37
  if (dp) {
    {
#line 39
    tmp___0 = dirfd(dp);
#line 39
    fd = tmp___0;
    }
#line 41
    if (0 <= fd) {
#line 41
      if (fd <= 2) {
        {
#line 54
        tmp___1 = dup_safer(fd);
#line 54
        f = tmp___1;
#line 55
        newdp = fdopendir(f);
#line 56
        tmp___2 = __errno_location();
#line 56
        e = *tmp___2;
        }
#line 57
        if (! newdp) {
          {
#line 58
          close(f);
          }
        }
        {
#line 63
        closedir(dp);
#line 64
        tmp___3 = __errno_location();
#line 64
        *tmp___3 = e;
#line 65
        dp = newdp;
        }
      }
    }
  }
#line 69
  return (dp);
}
}
#line 29 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 61 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-proc.c"
static int proc_status  =    0;
#line 58 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file ) 
{ 
  int proc_self_fd ;
  int tmp ;
  struct stat proc_self_fd_dotdot_st ;
  struct stat proc_self_st ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + (sizeof("..") - 1UL)) + 1UL] ;
  int tmp___2 ;
  int tmp___3 ;
  size_t bufsize ;
  size_t tmp___4 ;
  char *result ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 64
  if (! *file) {
#line 66
    *(buf + 0) = (char )'\000';
#line 67
    return ((char *)buf);
  }
#line 70
  if (! proc_status) {
    {
#line 80
    tmp = open("/proc/self/fd", 0);
#line 80
    proc_self_fd = tmp;
    }
#line 81
    if (proc_self_fd < 0) {
#line 82
      proc_status = -1;
    } else {
      {
#line 88
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
              proc_self_fd, "..");
#line 89
      tmp___2 = stat((char const   */* __restrict  */)(dotdot_buf), (struct stat */* __restrict  */)(& proc_self_fd_dotdot_st));
      }
#line 89
      if (tmp___2 == 0) {
        {
#line 89
        tmp___3 = stat((char const   */* __restrict  */)"/proc/self", (struct stat */* __restrict  */)(& proc_self_st));
        }
#line 89
        if (tmp___3 == 0) {
#line 89
          if (proc_self_fd_dotdot_st.st_ino == proc_self_st.st_ino) {
#line 89
            if (proc_self_fd_dotdot_st.st_dev == proc_self_st.st_dev) {
#line 89
              proc_status = 1;
            } else {
#line 89
              proc_status = -1;
            }
          } else {
#line 89
            proc_status = -1;
          }
        } else {
#line 89
          proc_status = -1;
        }
      } else {
#line 89
        proc_status = -1;
      }
      {
#line 94
      close(proc_self_fd);
      }
    }
  }
#line 98
  if (proc_status < 0) {
#line 99
    return ((char *)((void *)0));
  } else {
    {
#line 102
    tmp___4 = strlen(file);
#line 102
    bufsize = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + tmp___4) + 1UL;
    }
#line 103
    if (bufsize < 512UL) {
#line 103
      tmp___6 = buf;
    } else {
      {
#line 103
      tmp___5 = xmalloc(bufsize);
#line 103
      tmp___6 = (char *)tmp___5;
      }
    }
    {
#line 103
    result = (char *)tmp___6;
#line 104
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
            fd, file);
    }
#line 105
    return (result);
  }
}
}
#line 56 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat.h"
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 57
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-die.c"
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 35
  tmp = gettext("unable to record current working directory");
#line 35
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 42
  abort();
  }
}
}
#line 50
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 53
  tmp = gettext("failed to return to initial working directory");
#line 53
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 57
  abort();
  }
}
}
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 35
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      p --;
#line 51
      *p = (char )(48L + i % 10L);
#line 50
      i /= 10L;
#line 50
      if (! (i != 0L)) {
#line 50
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 55
  return (p);
}
}
#line 66 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 62 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.c"
static void *mmalloca_results[257]  ;
#line 66 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 72
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 74
  if (nplus >= n) {
    {
#line 76
    tmp = malloc(nplus);
#line 76
    p = (char *)tmp;
    }
#line 78
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 82
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 85
      *((int *)p + -1) = 336984906;
#line 88
      slot = (unsigned long )p % 257UL;
#line 89
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 90
      mmalloca_results[slot] = (void *)p;
#line 92
      return ((void *)p);
    }
  }
#line 96
  return ((void *)0);
}
}
#line 107 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 111
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 117
    if (*((int *)p + -1) == 336984906) {
#line 121
      slot = (unsigned long )p % 257UL;
#line 122
      chain = & mmalloca_results[slot];
      {
#line 123
      while (1) {
        while_continue: /* CIL Label */ ;
#line 123
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 123
          goto while_break;
        }
#line 125
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 128
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 129
          *chain = ((struct header *)p_begin)->next;
#line 130
          free((void *)p_begin);
          }
#line 131
          return;
        }
#line 133
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 138
  return;
}
}
#line 35 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/localcharset.h"
char const   *locale_charset(void) ;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int __attribute__((__gnu_inline__))  getc_unlocked(FILE *__fp ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 117 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 120 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___0 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 125
  cp = (char const   *)charset_aliases;
#line 126
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 130
    base = "charset.alias";
#line 135
    tmp = getenv("CHARSETALIASDIR");
#line 135
    dir = (char const   *)tmp;
    }
#line 136
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 137
      dir = "/usr/local/lib";
    } else
#line 136
    if ((int const   )*(dir + 0) == 0) {
#line 137
      dir = "/usr/local/lib";
    }
    {
#line 141
    tmp___0 = strlen(dir);
#line 141
    dir_len___0 = tmp___0;
#line 142
    tmp___1 = strlen(base);
#line 142
    base_len___0 = tmp___1;
    }
#line 143
    if (dir_len___0 > 0UL) {
#line 143
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 143
        tmp___2 = 1;
      } else {
#line 143
        tmp___2 = 0;
      }
    } else {
#line 143
      tmp___2 = 0;
    }
    {
#line 143
    add_slash = tmp___2;
#line 144
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 144
    file_name___0 = (char *)tmp___3;
    }
#line 145
    if ((unsigned long )file_name___0 != (unsigned long )((void *)0)) {
      {
#line 147
      memcpy((void */* __restrict  */)file_name___0, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 148
      if (add_slash) {
#line 149
        *(file_name___0 + dir_len___0) = (char )'/';
      }
      {
#line 150
      memcpy((void */* __restrict  */)((file_name___0 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 154
    if ((unsigned long )file_name___0 == (unsigned long )((void *)0)) {
#line 156
      cp = "";
    } else {
      {
#line 168
      fd = open((char const   *)file_name___0, 131072);
      }
#line 170
      if (fd < 0) {
#line 172
        cp = "";
      } else {
        {
#line 177
        fp = fdopen(fd, "r");
        }
#line 178
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 181
          close(fd);
#line 182
          cp = "";
          }
        } else {
#line 187
          res_ptr = (char *)((void *)0);
#line 188
          res_size = (size_t )0;
          {
#line 190
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 198
            c = (int )getc_unlocked(fp);
            }
#line 199
            if (c == -1) {
#line 200
              goto while_break;
            }
#line 201
            if (c == 10) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 32) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 9) {
#line 202
              goto __Cont;
            }
#line 203
            if (c == 35) {
              {
#line 206
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 207
                c = (int )getc_unlocked(fp);
                }
#line 206
                if (c == -1) {
#line 206
                  goto while_break___0;
                } else
#line 206
                if (c == 10) {
#line 206
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 209
              if (c == -1) {
#line 210
                goto while_break;
              }
#line 211
              goto __Cont;
            }
            {
#line 213
            ungetc(c, fp);
#line 214
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 214
            if (tmp___4 < 2) {
#line 215
              goto while_break;
            }
            {
#line 216
            l1 = strlen((char const   *)(buf1));
#line 217
            l2 = strlen((char const   *)(buf2));
#line 218
            old_res_ptr = res_ptr;
            }
#line 219
            if (res_size == 0UL) {
              {
#line 221
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 222
              tmp___5 = malloc(res_size + 1UL);
#line 222
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 226
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 227
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 227
              res_ptr = (char *)tmp___6;
              }
            }
#line 229
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 232
              res_size = (size_t )0;
#line 233
              if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
                {
#line 234
                free((void *)old_res_ptr);
                }
              }
#line 235
              goto while_break;
            }
            {
#line 237
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 238
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 240
          fclose(fp);
          }
#line 241
          if (res_size == 0UL) {
#line 242
            cp = "";
          } else {
#line 245
            *(res_ptr + res_size) = (char )'\000';
#line 246
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 251
      free((void *)file_name___0);
      }
    }
#line 345
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 348
  return (cp);
}
}
#line 360 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 371
  tmp = nl_langinfo(14);
#line 371
  codeset = (char const   *)tmp;
  }
#line 529
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 531
    codeset = "";
  }
  {
#line 534
  aliases = get_charset_aliases();
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! ((int const   )*aliases != 0)) {
#line 534
      goto while_break;
    }
    {
#line 537
    tmp___3 = strcmp(codeset, aliases);
    }
#line 537
    if (tmp___3 == 0) {
      {
#line 540
      tmp___2 = strlen(aliases);
#line 540
      codeset = (aliases + tmp___2) + 1;
      }
#line 541
      goto while_break;
    } else
#line 537
    if ((int const   )*(aliases + 0) == 42) {
#line 537
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 540
        tmp___2 = strlen(aliases);
#line 540
        codeset = (aliases + tmp___2) + 1;
        }
#line 541
        goto while_break;
      }
    }
    {
#line 534
    tmp___0 = strlen(aliases);
#line 534
    aliases += tmp___0 + 1UL;
#line 534
    tmp___1 = strlen(aliases);
#line 534
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  if ((int const   )*(codeset + 0) == 0) {
#line 548
    codeset = "ASCII";
  }
#line 550
  return (codeset);
}
}
#line 45 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 35
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      p --;
#line 51
      *p = (char )(48L + i % 10L);
#line 50
      i /= 10L;
#line 50
      if (! (i != 0L)) {
#line 50
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 55
  return (p);
}
}
#line 67 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 68
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 69
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 70
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 71
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 72
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 73
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 76
void *hash_get_first(Hash_table const   *table ) ;
#line 77
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 78
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 79
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 82
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 83
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 84
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 87
void hash_clear(Hash_table *table ) ;
#line 88
void hash_free(Hash_table *table ) ;
#line 91
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 92
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 93
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 78 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 81
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 132 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 151 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 154
  return ((size_t )table->n_buckets);
}
}
#line 159 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 162
  return ((size_t )table->n_buckets_used);
}
}
#line 167 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 170
  return ((size_t )table->n_entries);
}
}
#line 175 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 179
  max_bucket_length = (size_t )0;
#line 181
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 181
      goto while_break;
    }
#line 183
    if (bucket->data) {
#line 185
      cursor = bucket;
#line 186
      bucket_length = (size_t )1;
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 188
        cursor = (struct hash_entry  const  *)cursor->next;
#line 188
        if (! cursor) {
#line 188
          goto while_break___0;
        }
#line 189
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 191
      if (bucket_length > max_bucket_length) {
#line 192
        max_bucket_length = bucket_length;
      }
    }
#line 181
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (max_bucket_length);
}
}
#line 202 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 206
  n_buckets_used = (size_t )0;
#line 207
  n_entries = (size_t )0;
#line 209
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 209
      goto while_break;
    }
#line 211
    if (bucket->data) {
#line 213
      cursor = bucket;
#line 216
      n_buckets_used ++;
#line 217
      n_entries ++;
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 220
        cursor = (struct hash_entry  const  *)cursor->next;
#line 220
        if (! cursor) {
#line 220
          goto while_break___0;
        }
#line 221
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 209
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 225
    if (n_entries == (size_t )table->n_entries) {
#line 226
      return ((_Bool)1);
    }
  }
#line 228
  return ((_Bool)0);
}
}
#line 231 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 234
  tmp = hash_get_n_entries(table);
#line 234
  n_entries = tmp;
#line 235
  tmp___0 = hash_get_n_buckets(table);
#line 235
  n_buckets = tmp___0;
#line 236
  tmp___1 = hash_get_n_buckets_used(table);
#line 236
  n_buckets_used = tmp___1;
#line 237
  tmp___2 = hash_get_max_bucket_length(table);
#line 237
  max_bucket_length = tmp___2;
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 240
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 241
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 244
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 246
  return;
}
}
#line 251 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 254
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 254
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 258
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 259
    abort();
    }
  }
#line 261
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 262
    return ((void *)0);
  }
#line 264
  cursor = bucket;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! cursor) {
#line 264
      goto while_break;
    }
#line 265
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 266
      return ((void *)cursor->data);
    } else {
      {
#line 265
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 265
      if (tmp___0) {
#line 266
        return ((void *)cursor->data);
      }
    }
#line 264
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return ((void *)0);
}
}
#line 282 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 287
  if (table->n_entries == 0UL) {
#line 288
    return ((void *)0);
  }
#line 290
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 292
      abort();
      }
    } else
#line 293
    if (bucket->data) {
#line 294
      return ((void *)bucket->data);
    }
#line 290
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 301 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 304
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 304
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 308
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 309
    abort();
    }
  }
#line 312
  cursor = bucket;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! cursor) {
#line 312
      goto while_break;
    }
#line 313
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 313
      if (cursor->next) {
#line 314
        return ((cursor->next)->data);
      }
    }
#line 312
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    bucket ++;
#line 317
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 317
      goto while_break___0;
    }
#line 318
    if (bucket->data) {
#line 319
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  return ((void *)0);
}
}
#line 329 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 333
  counter = (size_t )0;
#line 337
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 337
      goto while_break;
    }
#line 339
    if (bucket->data) {
#line 341
      cursor = bucket;
      {
#line 341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 341
        if (! cursor) {
#line 341
          goto while_break___0;
        }
#line 343
        if (counter >= buffer_size) {
#line 344
          return (counter);
        }
#line 345
        tmp = counter;
#line 345
        counter ++;
#line 345
        *(buffer + tmp) = (void *)cursor->data;
#line 341
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 337
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (counter);
}
}
#line 361 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 365
  counter = (size_t )0;
#line 369
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 369
      goto while_break;
    }
#line 371
    if (bucket->data) {
#line 373
      cursor = bucket;
      {
#line 373
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 373
        if (! cursor) {
#line 373
          goto while_break___0;
        }
        {
#line 375
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 375
        if (! tmp) {
#line 376
          return (counter);
        }
#line 377
        counter ++;
#line 373
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 369
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return (counter);
}
}
#line 421 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 424
  value = (size_t )0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    ch = (unsigned char )*string;
#line 427
    if (! ch) {
#line 427
      goto while_break;
    }
#line 428
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 427
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return (value);
}
}
#line 437 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 440
  divisor = (size_t )3;
#line 441
  square = divisor * divisor;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (square < candidate) {
#line 443
      if (! (candidate % divisor)) {
#line 443
        goto while_break;
      }
    } else {
#line 443
      goto while_break;
    }
#line 445
    divisor ++;
#line 446
    square += 4UL * divisor;
#line 447
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if (candidate % divisor) {
#line 450
    tmp = 1;
  } else {
#line 450
    tmp = 0;
  }
#line 450
  return ((_Bool )tmp);
}
}
#line 456 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 460
  if (candidate < 10UL) {
#line 461
    candidate = (size_t )10;
  }
#line 464
  candidate |= 1UL;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (0xffffffffffffffffUL != candidate) {
      {
#line 466
      tmp = is_prime(candidate);
      }
#line 466
      if (tmp) {
#line 466
        goto while_break;
      }
    } else {
#line 466
      goto while_break;
    }
#line 467
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  return (candidate);
}
}
#line 472 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 475
  *tuning = (Hash_tuning )default_tuning;
#line 476
  return;
}
}
#line 479 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 487
  tmp = rotr_sz((size_t )data, 3);
#line 487
  val = tmp;
  }
#line 488
  return (val % n);
}
}
#line 492 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 495
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 505 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 508
  tuning = table->tuning;
#line 510
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 511
    return ((_Bool)1);
  }
#line 518
  epsilon = 0.1f;
#line 520
  if (epsilon < (float )tuning->growth_threshold) {
#line 520
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 520
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 520
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 520
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 520
            if (tuning->shrink_factor <= (float const   )1) {
#line 520
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 527
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 529
  table->tuning = & default_tuning;
#line 530
  return ((_Bool)0);
}
}
#line 537 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 540
  if (! tuning->is_n_buckets) {
#line 542
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 543
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 544
      return ((size_t )0);
    }
#line 545
    candidate = (size_t )new_candidate;
  }
  {
#line 547
  candidate = next_prime(candidate);
  }
#line 548
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 548
    tmp = -1;
  } else {
#line 548
    tmp = -2;
  }
#line 548
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 549
    return ((size_t )0);
  }
#line 550
  return (candidate);
}
}
#line 587 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 594
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 595
    hasher = & raw_hasher;
  }
#line 596
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 597
    comparator = & raw_comparator;
  }
  {
#line 599
  tmp = malloc(sizeof(*table));
#line 599
  table = (Hash_table *)tmp;
  }
#line 600
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 601
    return ((Hash_table *)((void *)0));
  }
#line 603
  if (! tuning) {
#line 604
    tuning = & default_tuning;
  }
  {
#line 605
  table->tuning = tuning;
#line 606
  tmp___0 = check_tuning(table);
  }
#line 606
  if (! tmp___0) {
#line 613
    goto fail;
  }
  {
#line 616
  table->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 617
  if (! table->n_buckets) {
#line 618
    goto fail;
  }
  {
#line 620
  tmp___1 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 620
  table->bucket = (struct hash_entry *)tmp___1;
  }
#line 621
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 622
    goto fail;
  }
#line 623
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 624
  table->n_buckets_used = (size_t )0;
#line 625
  table->n_entries = (size_t )0;
#line 627
  table->hasher = hasher;
#line 628
  table->comparator = comparator;
#line 629
  table->data_freer = data_freer;
#line 631
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 635
  return (table);
  fail: 
  {
#line 638
  free((void *)table);
  }
#line 639
  return ((Hash_table *)((void *)0));
}
}
#line 646 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 651
  bucket = table->bucket;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 651
      goto while_break;
    }
#line 653
    if (bucket->data) {
#line 659
      cursor = bucket->next;
      {
#line 659
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 659
        if (! cursor) {
#line 659
          goto while_break___0;
        }
#line 661
        if (table->data_freer) {
          {
#line 662
          (*(table->data_freer))(cursor->data);
          }
        }
#line 663
        cursor->data = (void *)0;
#line 665
        next = cursor->next;
#line 668
        cursor->next = table->free_entry_list;
#line 669
        table->free_entry_list = cursor;
#line 659
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 673
      if (table->data_freer) {
        {
#line 674
        (*(table->data_freer))(bucket->data);
        }
      }
#line 675
      bucket->data = (void *)0;
#line 676
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 651
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  table->n_buckets_used = (size_t )0;
#line 681
  table->n_entries = (size_t )0;
#line 682
  return;
}
}
#line 689 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 697
  if (table->data_freer) {
#line 697
    if (table->n_entries) {
#line 699
      bucket = table->bucket;
      {
#line 699
      while (1) {
        while_continue: /* CIL Label */ ;
#line 699
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 699
          goto while_break;
        }
#line 701
        if (bucket->data) {
#line 703
          cursor = bucket;
          {
#line 703
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 703
            if (! cursor) {
#line 703
              goto while_break___0;
            }
            {
#line 704
            (*(table->data_freer))(cursor->data);
#line 703
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 699
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 716
  bucket = table->bucket;
  {
#line 716
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 716
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 716
      goto while_break___1;
    }
#line 718
    cursor = bucket->next;
    {
#line 718
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 718
      if (! cursor) {
#line 718
        goto while_break___2;
      }
      {
#line 720
      next = cursor->next;
#line 721
      free((void *)cursor);
#line 718
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 716
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 726
  cursor = table->free_entry_list;
  {
#line 726
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 726
    if (! cursor) {
#line 726
      goto while_break___3;
    }
    {
#line 728
    next = cursor->next;
#line 729
    free((void *)cursor);
#line 726
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 735
  free((void *)table->bucket);
#line 736
  free((void *)table);
  }
#line 737
  return;
}
}
#line 744 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 749
  if (table->free_entry_list) {
#line 751
    new = table->free_entry_list;
#line 752
    table->free_entry_list = new->next;
  } else {
    {
#line 759
    tmp = malloc(sizeof(*new));
#line 759
    new = (struct hash_entry *)tmp;
    }
  }
#line 763
  return (new);
}
}
#line 769 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 772
  entry->data = (void *)0;
#line 773
  entry->next = table->free_entry_list;
#line 774
  table->free_entry_list = entry;
#line 775
  return;
}
}
#line 783 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 787
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 787
  bucket = table->bucket + tmp;
  }
#line 791
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 792
    abort();
    }
  }
#line 794
  *bucket_head = bucket;
#line 797
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 798
    return ((void *)0);
  }
#line 801
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 801
    goto _L;
  } else {
    {
#line 801
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 801
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 803
      data = bucket->data;
#line 805
      if (delete) {
#line 807
        if (bucket->next) {
          {
#line 809
          next = bucket->next;
#line 813
          *bucket = *next;
#line 814
          free_entry(table, next);
          }
        } else {
#line 818
          bucket->data = (void *)0;
        }
      }
#line 822
      return (data);
    }
  }
#line 826
  cursor = bucket;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! cursor->next) {
#line 826
      goto while_break;
    }
#line 828
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 828
      goto _L___0;
    } else {
      {
#line 828
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 828
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 831
        data___0 = (cursor->next)->data;
#line 833
        if (delete) {
          {
#line 835
          next___0 = cursor->next;
#line 839
          cursor->next = next___0->next;
#line 840
          free_entry(table, next___0);
          }
        }
#line 843
        return (data___0);
      }
    }
#line 826
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 848
  return ((void *)0);
}
}
#line 857 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  size_t tmp___0 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___1 ;

  {
#line 863
  bucket = src->bucket;
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 863
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 863
      goto while_break;
    }
#line 864
    if (bucket->data) {
#line 875
      cursor = bucket->next;
      {
#line 875
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 875
        if (! cursor) {
#line 875
          goto while_break___0;
        }
        {
#line 877
        data = cursor->data;
#line 878
        tmp = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 878
        new_bucket = dst->bucket + tmp;
        }
#line 880
        if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
          {
#line 881
          abort();
          }
        }
#line 883
        next = cursor->next;
#line 885
        if (new_bucket->data) {
#line 889
          cursor->next = new_bucket->next;
#line 890
          new_bucket->next = cursor;
        } else {
          {
#line 896
          new_bucket->data = data;
#line 897
          (dst->n_buckets_used) ++;
#line 898
          free_entry(dst, cursor);
          }
        }
#line 875
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 904
      data = bucket->data;
#line 905
      bucket->next = (struct hash_entry *)((void *)0);
#line 906
      if (safe) {
#line 907
        goto __Cont;
      }
      {
#line 908
      tmp___0 = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 908
      new_bucket = dst->bucket + tmp___0;
      }
#line 910
      if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
        {
#line 911
        abort();
        }
      }
#line 913
      if (new_bucket->data) {
        {
#line 917
        tmp___1 = allocate_entry(dst);
#line 917
        new_entry = tmp___1;
        }
#line 919
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 920
          return ((_Bool)0);
        }
#line 922
        new_entry->data = data;
#line 923
        new_entry->next = new_bucket->next;
#line 924
        new_bucket->next = new_entry;
      } else {
#line 929
        new_bucket->data = data;
#line 930
        (dst->n_buckets_used) ++;
      }
#line 932
      bucket->data = (void *)0;
#line 933
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 863
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  return ((_Bool)1);
}
}
#line 946 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  void *__cil_tmp11 ;

  {
  {
#line 951
  tmp = compute_bucket_size(candidate, table->tuning);
#line 951
  new_size = tmp;
  }
#line 953
  if (! new_size) {
#line 954
    return ((_Bool)0);
  }
#line 955
  if (new_size == table->n_buckets) {
#line 956
    return ((_Bool)1);
  }
  {
#line 957
  new_table = & storage;
#line 958
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 958
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 959
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 960
    return ((_Bool)0);
  }
  {
#line 961
  new_table->n_buckets = new_size;
#line 962
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 963
  new_table->n_buckets_used = (size_t )0;
#line 964
  new_table->n_entries = (size_t )0;
#line 965
  new_table->tuning = table->tuning;
#line 966
  new_table->hasher = table->hasher;
#line 967
  new_table->comparator = table->comparator;
#line 968
  new_table->data_freer = table->data_freer;
#line 988
  new_table->free_entry_list = table->free_entry_list;
#line 990
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 990
  if (tmp___1) {
    {
#line 993
    free((void *)table->bucket);
#line 994
    table->bucket = new_table->bucket;
#line 995
    table->bucket_limit = new_table->bucket_limit;
#line 996
    table->n_buckets = new_table->n_buckets;
#line 997
    table->n_buckets_used = new_table->n_buckets_used;
#line 998
    table->free_entry_list = new_table->free_entry_list;
    }
#line 1000
    return ((_Bool)1);
  }
  {
#line 1016
  table->free_entry_list = new_table->free_entry_list;
#line 1017
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1017
  if (tmp___2) {
    {
#line 1017
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1017
    if (! tmp___3) {
      {
#line 1019
      abort();
      }
    }
  } else {
    {
#line 1019
    abort();
    }
  }
  {
#line 1021
  free((void *)new_table->bucket);
  }
#line 1022
  return ((_Bool)0);
}
}
#line 1031 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1038
  if (! entry) {
    {
#line 1039
    abort();
    }
  }
  {
#line 1042
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1042
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1043
    return (data);
  }
#line 1050
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1055
    check_tuning(table);
    }
#line 1056
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1059
      tuning = table->tuning;
#line 1060
      if (tuning->is_n_buckets) {
#line 1060
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1060
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1060
      candidate = (float )tmp;
#line 1066
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1067
        return ((void *)0);
      }
      {
#line 1070
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1070
      if (! tmp___0) {
#line 1071
        return ((void *)0);
      }
      {
#line 1074
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1074
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1075
        abort();
        }
      }
    }
  }
#line 1081
  if (bucket->data) {
    {
#line 1083
    tmp___2 = allocate_entry(table);
#line 1083
    new_entry = tmp___2;
    }
#line 1085
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1086
      return ((void *)0);
    }
#line 1090
    new_entry->data = (void *)entry;
#line 1091
    new_entry->next = bucket->next;
#line 1092
    bucket->next = new_entry;
#line 1093
    (table->n_entries) ++;
#line 1094
    return ((void *)entry);
  }
#line 1099
  bucket->data = (void *)entry;
#line 1100
  (table->n_entries) ++;
#line 1101
  (table->n_buckets_used) ++;
#line 1103
  return ((void *)entry);
}
}
#line 1110 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1116
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1117
  if (! data) {
#line 1118
    return ((void *)0);
  }
#line 1120
  (table->n_entries) --;
#line 1121
  if (! bucket->data) {
#line 1123
    (table->n_buckets_used) --;
#line 1128
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1133
      check_tuning(table);
      }
#line 1134
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1137
        tuning = table->tuning;
#line 1138
        if (tuning->is_n_buckets) {
#line 1138
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1138
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1138
        candidate = (size_t )tmp;
#line 1144
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1144
        if (! tmp___0) {
#line 1152
          cursor = table->free_entry_list;
          {
#line 1154
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1154
            if (! cursor) {
#line 1154
              goto while_break;
            }
            {
#line 1156
            next = cursor->next;
#line 1157
            free((void *)cursor);
#line 1158
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1160
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1167
  return (data);
}
}
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 30 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;
  void *__cil_tmp4 ;

  {
  {
#line 38
  tmp = clock_gettime(0, ts);
  }
#line 38
  if (tmp == 0) {
#line 39
    return;
  }
  {
#line 44
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 45
  ts->tv_sec = tv.tv_sec;
#line 46
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
#line 50
  return;
}
}
#line 243 "./getopt.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options___0 ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 247
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options___0 ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 117
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
#line 123
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 128
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 41 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt1.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options___0 ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 41 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const   *options___0 ,
                                                         struct rpl_option  const  *long_options ,
                                                         int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 0, 0);
  }
#line 45
  return (tmp);
}
}
#line 49 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 0, d,
                           0);
  }
#line 54
  return (tmp);
}
}
#line 63
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options___0 ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const   *options___0 ,
                                                              struct rpl_option  const  *long_options ,
                                                              int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 1, 0);
  }
#line 68
  return (tmp);
}
}
#line 72 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 1, d,
                           0);
  }
#line 77
  return (tmp);
}
}
#line 149 "./getopt.h"
char *rpl_optarg  ;
#line 163
int rpl_optind ;
#line 168
int rpl_opterr ;
#line 172
int rpl_optopt ;
#line 239
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int rpl_optind  =    1;
#line 93 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int rpl_opterr  =    1;
#line 99 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int rpl_optopt  =    '?';
#line 103 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
static struct _getopt_data getopt_data  ;
#line 149 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 152
  bottom = d->__first_nonopt;
#line 153
  middle = d->__last_nonopt;
#line 154
  top = d->rpl_optind;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (top > middle) {
#line 184
      if (! (middle > bottom)) {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
#line 186
    if (top - middle > middle - bottom) {
#line 189
      len = middle - bottom;
#line 193
      i = 0;
      {
#line 193
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 193
        if (! (i < len)) {
#line 193
          goto while_break___0;
        }
#line 195
        tem = *(argv + (bottom + i));
#line 196
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 197
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 193
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 201
      top -= len;
    } else {
#line 206
      len___0 = top - middle;
#line 210
      i___0 = 0;
      {
#line 210
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 210
        if (! (i___0 < len___0)) {
#line 210
          goto while_break___1;
        }
#line 212
        tem = *(argv + (bottom + i___0));
#line 213
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 214
        *(argv + (middle + i___0)) = tem;
#line 210
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 218
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 225
  d->__last_nonopt = d->rpl_optind;
#line 226
  return;
}
}
#line 230 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 239
  tmp = d->rpl_optind;
#line 239
  d->__last_nonopt = tmp;
#line 239
  d->__first_nonopt = tmp;
#line 241
  d->__nextchar = (char *)((void *)0);
#line 243
  if (posixly_correct) {
#line 243
    tmp___1 = 1;
  } else {
    {
#line 243
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 243
    if (tmp___0) {
#line 243
      tmp___1 = 1;
    } else {
#line 243
      tmp___1 = 0;
    }
  }
#line 243
  d->__posixly_correct = tmp___1;
#line 247
  if ((int const   )*(optstring + 0) == 45) {
#line 249
    d->__ordering = (enum __anonenum___ordering_3 )2;
#line 250
    optstring ++;
  } else
#line 252
  if ((int const   )*(optstring + 0) == 43) {
#line 254
    d->__ordering = (enum __anonenum___ordering_3 )0;
#line 255
    optstring ++;
  } else
#line 257
  if (d->__posixly_correct) {
#line 258
    d->__ordering = (enum __anonenum___ordering_3 )0;
  } else {
#line 260
    d->__ordering = (enum __anonenum___ordering_3 )1;
  }
#line 292
  return (optstring);
}
}
#line 351 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char c ;
  char *tmp___18 ;
  char *temp ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 356
  print_errors = d->rpl_opterr;
#line 357
  if ((int const   )*(optstring + 0) == 58) {
#line 358
    print_errors = 0;
  }
#line 360
  if (argc < 1) {
#line 361
    return (-1);
  }
#line 363
  d->rpl_optarg = (char *)((void *)0);
#line 365
  if (d->rpl_optind == 0) {
#line 365
    goto _L;
  } else
#line 365
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 367
    if (d->rpl_optind == 0) {
#line 368
      d->rpl_optind = 1;
    }
    {
#line 369
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 371
    d->__initialized = 1;
    }
  }
#line 386
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 386
    goto _L___3;
  } else
#line 386
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 392
    if (d->__last_nonopt > d->rpl_optind) {
#line 393
      d->__last_nonopt = d->rpl_optind;
    }
#line 394
    if (d->__first_nonopt > d->rpl_optind) {
#line 395
      d->__first_nonopt = d->rpl_optind;
    }
#line 397
    if ((unsigned int )d->__ordering == 1U) {
#line 402
      if (d->__first_nonopt != d->__last_nonopt) {
#line 402
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 404
          exchange(argv, d);
          }
        } else {
#line 402
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 405
      if (d->__last_nonopt != d->rpl_optind) {
#line 406
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 411
      while (1) {
        while_continue: /* CIL Label */ ;
#line 411
        if (d->rpl_optind < argc) {
#line 411
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 411
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 411
              goto while_break;
            }
          }
        } else {
#line 411
          goto while_break;
        }
#line 412
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 413
      d->__last_nonopt = d->rpl_optind;
    }
#line 421
    if (d->rpl_optind != argc) {
      {
#line 421
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 421
      if (! tmp) {
#line 423
        (d->rpl_optind) ++;
#line 425
        if (d->__first_nonopt != d->__last_nonopt) {
#line 425
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 427
            exchange(argv, d);
            }
          } else {
#line 425
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 428
        if (d->__first_nonopt == d->__last_nonopt) {
#line 429
          d->__first_nonopt = d->rpl_optind;
        }
#line 430
        d->__last_nonopt = argc;
#line 432
        d->rpl_optind = argc;
      }
    }
#line 438
    if (d->rpl_optind == argc) {
#line 442
      if (d->__first_nonopt != d->__last_nonopt) {
#line 443
        d->rpl_optind = d->__first_nonopt;
      }
#line 444
      return (-1);
    }
#line 450
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 450
      goto _L___2;
    } else
#line 450
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 452
      if ((unsigned int )d->__ordering == 0U) {
#line 453
        return (-1);
      }
#line 454
      tmp___0 = d->rpl_optind;
#line 454
      (d->rpl_optind) ++;
#line 454
      d->rpl_optarg = *(argv + tmp___0);
#line 455
      return (1);
    }
#line 461
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 461
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 461
        tmp___1 = 1;
      } else {
#line 461
        tmp___1 = 0;
      }
    } else {
#line 461
      tmp___1 = 0;
    }
#line 461
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 480
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 480
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 480
      goto _L___6;
    } else
#line 480
    if (long_only) {
#line 480
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 480
        goto _L___6;
      } else {
        {
#line 480
        tmp___17 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 480
        if (! tmp___17) {
          _L___6: /* CIL Label */ 
#line 487
          pfound = (struct rpl_option  const  *)((void *)0);
#line 488
          exact = 0;
#line 489
          ambig = 0;
#line 490
          indfound = -1;
#line 493
          nameend = d->__nextchar;
          {
#line 493
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 493
            if (*nameend) {
#line 493
              if (! ((int )*nameend != 61)) {
#line 493
                goto while_break___0;
              }
            } else {
#line 493
              goto while_break___0;
            }
#line 493
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 498
          p = longopts;
#line 498
          option_index = 0;
          {
#line 498
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 498
            if (! p->name) {
#line 498
              goto while_break___1;
            }
            {
#line 499
            tmp___3 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )(nameend - d->__nextchar));
            }
#line 499
            if (! tmp___3) {
              {
#line 501
              tmp___2 = strlen((char const   *)p->name);
              }
#line 501
              if ((unsigned int )(nameend - d->__nextchar) == (unsigned int )tmp___2) {
#line 505
                pfound = p;
#line 506
                indfound = option_index;
#line 507
                exact = 1;
#line 508
                goto while_break___1;
              } else
#line 510
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 513
                pfound = p;
#line 514
                indfound = option_index;
              } else
#line 516
              if (long_only) {
#line 521
                ambig = 1;
              } else
#line 516
              if (pfound->has_arg != p->has_arg) {
#line 521
                ambig = 1;
              } else
#line 516
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 521
                ambig = 1;
              } else
#line 516
              if (pfound->val != p->val) {
#line 521
                ambig = 1;
              }
            }
#line 498
            p ++;
#line 498
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 524
          if (ambig) {
#line 524
            if (! exact) {
#line 526
              if (print_errors) {
                {
#line 547
                tmp___4 = gettext("%s: option \'%s\' is ambiguous\n");
#line 547
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                        *(argv + 0), *(argv + d->rpl_optind));
                }
              }
              {
#line 551
              tmp___5 = strlen((char const   *)d->__nextchar);
#line 551
              d->__nextchar += tmp___5;
#line 552
              (d->rpl_optind) ++;
#line 553
              d->rpl_optopt = 0;
              }
#line 554
              return ('?');
            }
          }
#line 557
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 559
            option_index = indfound;
#line 560
            (d->rpl_optind) ++;
#line 561
            if (*nameend) {
#line 565
              if (pfound->has_arg) {
#line 566
                d->rpl_optarg = nameend + 1;
              } else {
#line 569
                if (print_errors) {
#line 576
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 584
                    tmp___6 = gettext("%s: option \'--%s\' doesn\'t allow an argument\n");
#line 584
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 598
                    tmp___7 = gettext("%s: option \'%c%s\' doesn\'t allow an argument\n");
#line 598
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                    }
                  }
                }
                {
#line 624
                tmp___8 = strlen((char const   *)d->__nextchar);
#line 624
                d->__nextchar += tmp___8;
#line 626
                d->rpl_optopt = (int )pfound->val;
                }
#line 627
                return ('?');
              }
            } else
#line 630
            if (pfound->has_arg == 1) {
#line 632
              if (d->rpl_optind < argc) {
#line 633
                tmp___9 = d->rpl_optind;
#line 633
                (d->rpl_optind) ++;
#line 633
                d->rpl_optarg = *(argv + tmp___9);
              } else {
#line 636
                if (print_errors) {
                  {
#line 659
                  tmp___10 = gettext("%s: option \'%s\' requires an argument\n");
#line 659
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                          *(argv + 0), *(argv + (d->rpl_optind - 1)));
                  }
                }
                {
#line 664
                tmp___11 = strlen((char const   *)d->__nextchar);
#line 664
                d->__nextchar += tmp___11;
#line 665
                d->rpl_optopt = (int )pfound->val;
                }
#line 666
                if ((int const   )*(optstring + 0) == 58) {
#line 666
                  tmp___12 = ':';
                } else {
#line 666
                  tmp___12 = '?';
                }
#line 666
                return (tmp___12);
              }
            }
            {
#line 669
            tmp___13 = strlen((char const   *)d->__nextchar);
#line 669
            d->__nextchar += tmp___13;
            }
#line 670
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 671
              *longind = option_index;
            }
#line 672
            if (pfound->flag) {
#line 674
              *(pfound->flag) = (int )pfound->val;
#line 675
              return (0);
            }
#line 677
            return ((int )pfound->val);
          }
#line 684
          if (! long_only) {
#line 684
            goto _L___4;
          } else
#line 684
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 684
            goto _L___4;
          } else {
            {
#line 684
            tmp___16 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 684
            if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 687
              if (print_errors) {
#line 694
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 701
                  tmp___14 = gettext("%s: unrecognized option \'--%s\'\n");
#line 701
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 712
                  tmp___15 = gettext("%s: unrecognized option \'%c%s\'\n");
#line 712
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                  }
                }
              }
#line 734
              d->__nextchar = (char *)"";
#line 735
              (d->rpl_optind) ++;
#line 736
              d->rpl_optopt = 0;
#line 737
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 744
  tmp___18 = d->__nextchar;
#line 744
  (d->__nextchar) ++;
#line 744
  c = *tmp___18;
#line 745
  tmp___19 = strchr(optstring, (int )c);
#line 745
  temp = tmp___19;
  }
#line 748
  if ((int )*(d->__nextchar) == 0) {
#line 749
    (d->rpl_optind) ++;
  }
#line 751
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 751
    goto _L___7;
  } else
#line 751
  if ((int )c == 58) {
    _L___7: /* CIL Label */ 
#line 753
    if (print_errors) {
      {
#line 764
      tmp___20 = gettext("%s: invalid option -- \'%c\'\n");
#line 764
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
              *(argv + 0), (int )c);
      }
    }
#line 784
    d->rpl_optopt = (int )c;
#line 785
    return ('?');
  }
#line 788
  if ((int )*(temp + 0) == 87) {
#line 788
    if ((int )*(temp + 1) == 59) {
#line 792
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 793
      exact___0 = 0;
#line 794
      ambig___0 = 0;
#line 795
      indfound___0 = 0;
#line 799
      if ((int )*(d->__nextchar) != 0) {
#line 801
        d->rpl_optarg = d->__nextchar;
#line 804
        (d->rpl_optind) ++;
      } else
#line 806
      if (d->rpl_optind == argc) {
#line 808
        if (print_errors) {
          {
#line 830
          tmp___21 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 830
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
                  *(argv + 0), (int )c);
          }
        }
#line 835
        d->rpl_optopt = (int )c;
#line 836
        if ((int const   )*(optstring + 0) == 58) {
#line 837
          c = (char )':';
        } else {
#line 839
          c = (char )'?';
        }
#line 840
        return ((int )c);
      } else {
#line 845
        tmp___22 = d->rpl_optind;
#line 845
        (d->rpl_optind) ++;
#line 845
        d->rpl_optarg = *(argv + tmp___22);
      }
#line 850
      nameend___0 = d->rpl_optarg;
#line 850
      d->__nextchar = nameend___0;
      {
#line 850
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 850
        if (*nameend___0) {
#line 850
          if (! ((int )*nameend___0 != 61)) {
#line 850
            goto while_break___2;
          }
        } else {
#line 850
          goto while_break___2;
        }
#line 850
        nameend___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 856
      p___0 = longopts;
#line 856
      option_index___0 = 0;
      {
#line 856
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 856
        if (! p___0->name) {
#line 856
          goto while_break___3;
        }
        {
#line 857
        tmp___24 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 857
        if (! tmp___24) {
          {
#line 859
          tmp___23 = strlen((char const   *)p___0->name);
          }
#line 859
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___23) {
#line 862
            pfound___0 = p___0;
#line 863
            indfound___0 = option_index___0;
#line 864
            exact___0 = 1;
#line 865
            goto while_break___3;
          } else
#line 867
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 870
            pfound___0 = p___0;
#line 871
            indfound___0 = option_index___0;
          } else {
#line 875
            ambig___0 = 1;
          }
        }
#line 856
        p___0 ++;
#line 856
        option_index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 877
      if (ambig___0) {
#line 877
        if (! exact___0) {
#line 879
          if (print_errors) {
            {
#line 900
            tmp___25 = gettext("%s: option \'-W %s\' is ambiguous\n");
#line 900
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
                    *(argv + 0), *(argv + d->rpl_optind));
            }
          }
          {
#line 904
          tmp___26 = strlen((char const   *)d->__nextchar);
#line 904
          d->__nextchar += tmp___26;
#line 905
          (d->rpl_optind) ++;
          }
#line 906
          return ('?');
        }
      }
#line 908
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 910
        option_index___0 = indfound___0;
#line 911
        if (*nameend___0) {
#line 915
          if (pfound___0->has_arg) {
#line 916
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 919
            if (print_errors) {
              {
#line 942
              tmp___27 = gettext("%s: option \'-W %s\' doesn\'t allow an argument\n");
#line 942
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___27,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 948
            tmp___28 = strlen((char const   *)d->__nextchar);
#line 948
            d->__nextchar += tmp___28;
            }
#line 949
            return ('?');
          }
        } else
#line 952
        if (pfound___0->has_arg == 1) {
#line 954
          if (d->rpl_optind < argc) {
#line 955
            tmp___29 = d->rpl_optind;
#line 955
            (d->rpl_optind) ++;
#line 955
            d->rpl_optarg = *(argv + tmp___29);
          } else {
#line 958
            if (print_errors) {
              {
#line 981
              tmp___30 = gettext("%s: option \'%s\' requires an argument\n");
#line 981
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
                      *(argv + 0), *(argv + (d->rpl_optind - 1)));
              }
            }
            {
#line 986
            tmp___31 = strlen((char const   *)d->__nextchar);
#line 986
            d->__nextchar += tmp___31;
            }
#line 987
            if ((int const   )*(optstring + 0) == 58) {
#line 987
              tmp___32 = ':';
            } else {
#line 987
              tmp___32 = '?';
            }
#line 987
            return (tmp___32);
          }
        }
        {
#line 990
        tmp___33 = strlen((char const   *)d->__nextchar);
#line 990
        d->__nextchar += tmp___33;
        }
#line 991
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 992
          *longind = option_index___0;
        }
#line 993
        if (pfound___0->flag) {
#line 995
          *(pfound___0->flag) = (int )pfound___0->val;
#line 996
          return (0);
        }
#line 998
        return ((int )pfound___0->val);
      }
#line 1000
      d->__nextchar = (char *)((void *)0);
#line 1001
      return ('W');
    }
  }
#line 1003
  if ((int )*(temp + 1) == 58) {
#line 1005
    if ((int )*(temp + 2) == 58) {
#line 1008
      if ((int )*(d->__nextchar) != 0) {
#line 1010
        d->rpl_optarg = d->__nextchar;
#line 1011
        (d->rpl_optind) ++;
      } else {
#line 1014
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1015
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1020
      if ((int )*(d->__nextchar) != 0) {
#line 1022
        d->rpl_optarg = d->__nextchar;
#line 1025
        (d->rpl_optind) ++;
      } else
#line 1027
      if (d->rpl_optind == argc) {
#line 1029
        if (print_errors) {
          {
#line 1051
          tmp___34 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 1051
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___34,
                  *(argv + 0), (int )c);
          }
        }
#line 1056
        d->rpl_optopt = (int )c;
#line 1057
        if ((int const   )*(optstring + 0) == 58) {
#line 1058
          c = (char )':';
        } else {
#line 1060
          c = (char )'?';
        }
      } else {
#line 1065
        tmp___35 = d->rpl_optind;
#line 1065
        (d->rpl_optind) ++;
#line 1065
        d->rpl_optarg = *(argv + tmp___35);
      }
#line 1066
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1069
  return ((int )c);
}
}
#line 1073 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1080
  getopt_data.rpl_optind = rpl_optind;
#line 1081
  getopt_data.rpl_opterr = rpl_opterr;
#line 1083
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1087
  rpl_optind = getopt_data.rpl_optind;
#line 1088
  rpl_optarg = getopt_data.rpl_optarg;
#line 1089
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1091
  return (result);
}
}
#line 1102
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 1102 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getopt.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char * const  *argv ,
                                                    char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1105
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  }
#line 1105
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 237
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getdate.h"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 126 "./c-ctype.h"
_Bool c_isalpha(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 766
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 205 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 206
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 207
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 212 "getdate.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 215
  if (pc->dates_seen) {
#line 215
    if (! pc->year.digits) {
#line 215
      if (! pc->rels_seen) {
#line 215
        if (pc->times_seen) {
#line 217
          pc->year = text_int;
        } else
#line 215
        if (2UL < text_int.digits) {
#line 217
          pc->year = text_int;
        } else {
#line 215
          goto _L___1;
        }
      } else {
#line 215
        goto _L___1;
      }
    } else {
#line 215
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 220
  if (4UL < text_int.digits) {
#line 222
    (pc->dates_seen) ++;
#line 223
    pc->day = text_int.value % 100L;
#line 224
    pc->month = (text_int.value / 100L) % 100L;
#line 225
    pc->year.value = text_int.value / 10000L;
#line 226
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 230
    (pc->times_seen) ++;
#line 231
    if (text_int.digits <= 2UL) {
#line 233
      pc->hour = text_int.value;
#line 234
      pc->minutes = 0L;
    } else {
#line 238
      pc->hour = text_int.value / 100L;
#line 239
      pc->minutes = text_int.value % 100L;
    }
#line 241
    pc->seconds.tv_sec = (__time_t )0;
#line 242
    pc->seconds.tv_nsec = 0L;
#line 243
    pc->meridian = 2;
  }
#line 246
  return;
}
}
#line 249 "getdate.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 252
  pc->rel.ns += (long )factor * rel.ns;
#line 253
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
#line 254
  pc->rel.minutes += (long )factor * rel.minutes;
#line 255
  pc->rel.hour += (long )factor * rel.hour;
#line 256
  pc->rel.day += (long )factor * rel.day;
#line 257
  pc->rel.month += (long )factor * rel.month;
#line 258
  pc->rel.year += (long )factor * rel.year;
#line 259
  pc->rels_seen = (_Bool)1;
#line 260
  return;
}
}
#line 263 "getdate.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 267
  pc->hour = hour;
#line 268
  pc->minutes = minutes;
#line 269
  pc->seconds.tv_sec = sec;
#line 270
  pc->seconds.tv_nsec = nsec;
#line 271
  return;
}
}
#line 667 "getdate.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 667 "getdate.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 788 "getdate.c"
static yytype_uint8 const   yyr1[83]  = 
#line 788
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47};
#line 802 "getdate.c"
static yytype_uint8 const   yyr2[83]  = 
#line 802
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 818 "getdate.c"
static yytype_uint8 const   yydefact[100]  = 
#line 818
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )74,      (yytype_uint8 const   )76,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )45,      (yytype_uint8 const   )48,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )62,      (yytype_uint8 const   )51,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )41,      (yytype_uint8 const   )63,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )28,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )43,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )26,      (yytype_uint8 const   )79,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )66,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )34,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )79,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19};
#line 833 "getdate.c"
static yytype_int8 const   yydefgoto[21]  = 
#line 833
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33, 
        (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37, 
        (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )40,      (yytype_int8 const   )41,      (yytype_int8 const   )81, 
        (yytype_int8 const   )92};
#line 843 "getdate.c"
static yytype_int8 const   yypact[100]  = 
#line 843
  {      (yytype_int8 const   )-17,      (yytype_int8 const   )56,      (yytype_int8 const   )15,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )26,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-82,      (yytype_int8 const   )68,      (yytype_int8 const   )10, 
        (yytype_int8 const   )50,      (yytype_int8 const   )9,      (yytype_int8 const   )59,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )72,      (yytype_int8 const   )73,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )80,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )65,      (yytype_int8 const   )61,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )17,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )60,      (yytype_int8 const   )44, 
        (yytype_int8 const   )67,      (yytype_int8 const   )69,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-7,      (yytype_int8 const   )62,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )75,      (yytype_int8 const   )-82,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82};
#line 858 "getdate.c"
static yytype_int8 const   yypgoto[21]  = 
#line 858
  {      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-6,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-81, 
        (yytype_int8 const   )-3};
#line 870 "getdate.c"
static yytype_uint8 const   yytable[99]  = 
#line 870
  {      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )1,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )94,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )91,      (yytype_uint8 const   )6,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )73,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )42,      (yytype_uint8 const   )52,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )89,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )74,      (yytype_uint8 const   )97,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )95,      (yytype_uint8 const   )79,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )80};
#line 884 "getdate.c"
static yytype_int8 const   yycheck[99]  = 
#line 884
  {      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )23,      (yytype_int8 const   )12, 
        (yytype_int8 const   )15,      (yytype_int8 const   )90,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )19,      (yytype_int8 const   )4,      (yytype_int8 const   )19,      (yytype_int8 const   )0, 
        (yytype_int8 const   )97,      (yytype_int8 const   )24,      (yytype_int8 const   )20,      (yytype_int8 const   )24, 
        (yytype_int8 const   )22,      (yytype_int8 const   )26,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )24,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )12,      (yytype_int8 const   )19, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )15,      (yytype_int8 const   )25, 
        (yytype_int8 const   )4,      (yytype_int8 const   )27,      (yytype_int8 const   )19,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )3, 
        (yytype_int8 const   )19,      (yytype_int8 const   )91,      (yytype_int8 const   )25,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )20, 
        (yytype_int8 const   )95,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )24};
#line 900 "getdate.c"
static yytype_uint8 const   yystos[100]  = 
#line 900
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )25,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )39,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )46,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )26,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )19,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46};
#line 1405 "getdate.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 
  char *__cil_tmp5 ;

  {
#line 1419
  if (! yymsg) {
#line 1420
    yymsg = "Deleting";
  }
  {
#line 1426
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1427
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1429
  return;
}
}
#line 1442
int yyparse(parser_control *pc ) ;
#line 1470 "getdate.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
#line 1494
  yytoken = 0;
#line 1512
  yyss = yyssa;
#line 1517
  yyvs = yyvsa;
#line 1524
  yystacksize = 20UL;
#line 1533
  yylen = 0;
#line 1537
  yystate = 0;
#line 1538
  yyerrstatus = 0;
#line 1539
  yynerrs = 0;
#line 1540
  yychar = -2;
#line 1547
  yyssp = yyss;
#line 1548
  yyvsp = yyvs;
#line 1550
  goto yysetstate;
  yynewstate: 
#line 1558
  yyssp ++;
  yysetstate: 
#line 1561
  *yyssp = (yytype_int16 )yystate;
#line 1563
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1566
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1595
    if (20UL <= yystacksize) {
#line 1596
      goto yyexhaustedlab;
    }
#line 1597
    yystacksize *= 2UL;
#line 1598
    if (20UL < yystacksize) {
#line 1599
      yystacksize = 20UL;
    }
    {
#line 1602
    yyss1 = yyss;
#line 1603
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1603
    yyptr = (union yyalloc *)tmp;
    }
#line 1605
    if (! yyptr) {
#line 1606
      goto yyexhaustedlab;
    }
    {
#line 1607
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1607
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1607
      yyss = & yyptr->yyss;
#line 1607
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1607
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1607
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1608
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1608
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1608
      yyvs = & yyptr->yyvs;
#line 1608
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1608
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1608
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1611
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1612
      free((void *)yyss1);
      }
    }
#line 1617
    yyssp = (yyss + yysize) - 1;
#line 1618
    yyvsp = (yyvs + yysize) - 1;
#line 1624
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1625
      goto yyabortlab;
    }
  }
#line 1630
  goto yybackup;
  yybackup: 
#line 1641
  yyn = (int )yypact[yystate];
#line 1642
  if (yyn == -82) {
#line 1643
    goto yydefault;
  }
#line 1648
  if (yychar == -2) {
    {
#line 1651
    yychar = yylex(& yylval, pc);
    }
  }
#line 1654
  if (yychar <= 0) {
#line 1656
    yytoken = 0;
#line 1656
    yychar = yytoken;
  } else
#line 1661
  if ((unsigned int )yychar <= 277U) {
#line 1661
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1661
    yytoken = 2;
  }
#line 1667
  yyn += yytoken;
#line 1668
  if (yyn < 0) {
#line 1669
    goto yydefault;
  } else
#line 1668
  if (98 < yyn) {
#line 1669
    goto yydefault;
  } else
#line 1668
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1669
    goto yydefault;
  }
#line 1670
  yyn = (int )yytable[yyn];
#line 1671
  if (yyn <= 0) {
#line 1673
    if (yyn == 0) {
#line 1674
      goto yyerrlab;
    } else
#line 1673
    if (yyn == -1) {
#line 1674
      goto yyerrlab;
    }
#line 1675
    yyn = - yyn;
#line 1676
    goto yyreduce;
  }
#line 1679
  if (yyn == 12) {
#line 1680
    goto yyacceptlab;
  }
#line 1684
  if (yyerrstatus) {
#line 1685
    yyerrstatus --;
  }
#line 1691
  if (yychar != 0) {
#line 1692
    yychar = -2;
  }
#line 1694
  yystate = yyn;
#line 1695
  yyvsp ++;
#line 1695
  *yyvsp = yylval;
#line 1697
  goto yynewstate;
  yydefault: 
#line 1704
  yyn = (int )yydefact[yystate];
#line 1705
  if (yyn == 0) {
#line 1706
    goto yyerrlab;
  }
#line 1707
  goto yyreduce;
  yyreduce: 
#line 1715
  yylen = (int )yyr2[yyn];
#line 1725
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1731
  if (yyn == 4) {
#line 1731
    goto case_4;
  }
#line 323
  if (yyn == 7) {
#line 323 "getdate.y"
    goto case_7;
  }
#line 333
  if (yyn == 8) {
#line 333
    goto case_8;
  }
#line 335
  if (yyn == 9) {
#line 335
    goto case_9;
  }
#line 337
  if (yyn == 10) {
#line 337
    goto case_10;
  }
#line 339
  if (yyn == 11) {
#line 339
    goto case_11;
  }
#line 341
  if (yyn == 15) {
#line 341
    goto case_15;
  }
#line 352
  if (yyn == 16) {
#line 352
    goto case_16;
  }
#line 357
  if (yyn == 17) {
#line 357
    goto case_17;
  }
#line 364
  if (yyn == 18) {
#line 364
    goto case_18;
  }
#line 369
  if (yyn == 19) {
#line 369
    goto case_19;
  }
#line 376
  if (yyn == 20) {
#line 376
    goto case_20;
  }
#line 384
  if (yyn == 21) {
#line 384
    goto case_21;
  }
#line 389
  if (yyn == 22) {
#line 389
    goto case_22;
  }
#line 394
  if (yyn == 23) {
#line 394
    goto case_23;
  }
#line 397
  if (yyn == 24) {
#line 397
    goto case_24;
  }
#line 399
  if (yyn == 25) {
#line 399
    goto case_25;
  }
#line 401
  if (yyn == 26) {
#line 401
    goto case_26;
  }
#line 403
  if (yyn == 27) {
#line 403
    goto case_27;
  }
#line 411
  if (yyn == 28) {
#line 411
    goto case_28;
  }
#line 416
  if (yyn == 29) {
#line 416
    goto case_29;
  }
#line 421
  if (yyn == 30) {
#line 421
    goto case_30;
  }
#line 426
  if (yyn == 31) {
#line 426
    goto case_31;
  }
#line 434
  if (yyn == 32) {
#line 434
    goto case_32;
  }
#line 454
  if (yyn == 33) {
#line 454
    goto case_33;
  }
#line 461
  if (yyn == 34) {
#line 461
    goto case_34;
  }
#line 469
  if (yyn == 35) {
#line 469
    goto case_35;
  }
#line 477
  if (yyn == 36) {
#line 477
    goto case_36;
  }
#line 482
  if (yyn == 37) {
#line 482
    goto case_37;
  }
#line 488
  if (yyn == 38) {
#line 488
    goto case_38;
  }
#line 493
  if (yyn == 39) {
#line 493
    goto case_39;
  }
#line 499
  if (yyn == 40) {
#line 499
    goto case_40;
  }
#line 504
  if (yyn == 41) {
#line 504
    goto case_41;
  }
#line 506
  if (yyn == 42) {
#line 506
    goto case_42;
  }
#line 508
  if (yyn == 43) {
#line 508
    goto case_43;
  }
#line 513
  if (yyn == 44) {
#line 513
    goto case_44;
  }
#line 515
  if (yyn == 45) {
#line 515
    goto case_45;
  }
#line 517
  if (yyn == 46) {
#line 517
    goto case_46;
  }
#line 519
  if (yyn == 47) {
#line 519
    goto case_47;
  }
#line 521
  if (yyn == 48) {
#line 521
    goto case_48;
  }
#line 523
  if (yyn == 49) {
#line 523
    goto case_49;
  }
#line 525
  if (yyn == 50) {
#line 525
    goto case_50;
  }
#line 527
  if (yyn == 51) {
#line 527
    goto case_51;
  }
#line 529
  if (yyn == 52) {
#line 529
    goto case_52;
  }
#line 531
  if (yyn == 53) {
#line 531
    goto case_53;
  }
#line 533
  if (yyn == 54) {
#line 533
    goto case_54;
  }
#line 535
  if (yyn == 55) {
#line 535
    goto case_55;
  }
#line 537
  if (yyn == 56) {
#line 537
    goto case_56;
  }
#line 539
  if (yyn == 57) {
#line 539
    goto case_57;
  }
#line 541
  if (yyn == 58) {
#line 541
    goto case_58;
  }
#line 543
  if (yyn == 59) {
#line 543
    goto case_59;
  }
#line 545
  if (yyn == 60) {
#line 545
    goto case_60;
  }
#line 547
  if (yyn == 61) {
#line 547
    goto case_61;
  }
#line 549
  if (yyn == 62) {
#line 549
    goto case_62;
  }
#line 551
  if (yyn == 64) {
#line 551
    goto case_64;
  }
#line 557
  if (yyn == 65) {
#line 557
    goto case_65;
  }
#line 559
  if (yyn == 66) {
#line 559
    goto case_66;
  }
#line 561
  if (yyn == 67) {
#line 561
    goto case_67;
  }
#line 563
  if (yyn == 68) {
#line 563
    goto case_68;
  }
#line 565
  if (yyn == 69) {
#line 565
    goto case_69;
  }
#line 567
  if (yyn == 70) {
#line 567
    goto case_70;
  }
#line 572
  if (yyn == 74) {
#line 572
    goto case_74;
  }
#line 580
  if (yyn == 76) {
#line 580
    goto case_76;
  }
#line 586
  if (yyn == 77) {
#line 586
    goto case_77;
  }
#line 591
  if (yyn == 78) {
#line 591
    goto case_78;
  }
#line 601
  if (yyn == 79) {
#line 601
    goto case_79;
  }
#line 606
  if (yyn == 80) {
#line 606
    goto case_80;
  }
#line 608
  if (yyn == 81) {
#line 608
    goto case_81;
  }
#line 613
  if (yyn == 82) {
#line 613
    goto case_82;
  }
#line 2177 "getdate.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 318 "getdate.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 319
  pc->timespec_seen = (_Bool)1;
#line 321
  goto switch_break;
  case_7: /* CIL Label */ 
#line 330
  (pc->times_seen) ++;
#line 331
  goto switch_break;
  case_8: /* CIL Label */ 
#line 332
  (pc->local_zones_seen) ++;
#line 333
  goto switch_break;
  case_9: /* CIL Label */ 
#line 334
  (pc->zones_seen) ++;
#line 335
  goto switch_break;
  case_10: /* CIL Label */ 
#line 336
  (pc->dates_seen) ++;
#line 337
  goto switch_break;
  case_11: /* CIL Label */ 
#line 338
  (pc->days_seen) ++;
#line 339
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 347
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 348
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 350
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 352
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 353
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 355
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 357
  set_hhmmss(pc, (yyvsp + -4)->textintval.value, (yyvsp + -2)->textintval.value, (time_t )0,
             0L);
#line 358
  pc->meridian = 2;
#line 359
  (pc->zones_seen) ++;
#line 360
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 362
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 364
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 365
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 367
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 369
  set_hhmmss(pc, (yyvsp + -6)->textintval.value, (yyvsp + -4)->textintval.value, (yyvsp + -2)->timespec.tv_sec,
             (yyvsp + -2)->timespec.tv_nsec);
#line 370
  pc->meridian = 2;
#line 371
  (pc->zones_seen) ++;
#line 372
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 374
  goto switch_break;
  case_20: /* CIL Label */ 
#line 379
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 380
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 382
  goto switch_break;
  case_21: /* CIL Label */ 
#line 384
  pc->local_isdst = 1;
#line 385
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 387
  goto switch_break;
  case_22: /* CIL Label */ 
#line 391
  pc->time_zone = (yyvsp + 0)->intval;
#line 392
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 393
  pc->time_zone = (yyvsp + -1)->intval;
#line 394
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 395
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 396
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 396
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  }
#line 397
  goto switch_break;
  case_25: /* CIL Label */ 
#line 398
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 399
  goto switch_break;
  case_26: /* CIL Label */ 
#line 400
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 401
  goto switch_break;
  case_27: /* CIL Label */ 
#line 406
  pc->day_ordinal = 0L;
#line 407
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 409
  goto switch_break;
  case_28: /* CIL Label */ 
#line 411
  pc->day_ordinal = 0L;
#line 412
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 414
  goto switch_break;
  case_29: /* CIL Label */ 
#line 416
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 417
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 419
  goto switch_break;
  case_30: /* CIL Label */ 
#line 421
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 422
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 424
  goto switch_break;
  case_31: /* CIL Label */ 
#line 429
  pc->month = (yyvsp + -2)->textintval.value;
#line 430
  pc->day = (yyvsp + 0)->textintval.value;
#line 432
  goto switch_break;
  case_32: /* CIL Label */ 
#line 439
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 441
    pc->year = (yyvsp + -4)->textintval;
#line 442
    pc->month = (yyvsp + -2)->textintval.value;
#line 443
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 447
    pc->month = (yyvsp + -4)->textintval.value;
#line 448
    pc->day = (yyvsp + -2)->textintval.value;
#line 449
    pc->year = (yyvsp + 0)->textintval;
  }
#line 452
  goto switch_break;
  case_33: /* CIL Label */ 
#line 455
  pc->year = (yyvsp + -2)->textintval;
#line 456
  pc->month = - (yyvsp + -1)->textintval.value;
#line 457
  pc->day = - (yyvsp + 0)->textintval.value;
#line 459
  goto switch_break;
  case_34: /* CIL Label */ 
#line 462
  pc->day = (yyvsp + -2)->textintval.value;
#line 463
  pc->month = (yyvsp + -1)->intval;
#line 464
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 465
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 467
  goto switch_break;
  case_35: /* CIL Label */ 
#line 470
  pc->month = (yyvsp + -2)->intval;
#line 471
  pc->day = - (yyvsp + -1)->textintval.value;
#line 472
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 473
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 475
  goto switch_break;
  case_36: /* CIL Label */ 
#line 477
  pc->month = (yyvsp + -1)->intval;
#line 478
  pc->day = (yyvsp + 0)->textintval.value;
#line 480
  goto switch_break;
  case_37: /* CIL Label */ 
#line 482
  pc->month = (yyvsp + -3)->intval;
#line 483
  pc->day = (yyvsp + -2)->textintval.value;
#line 484
  pc->year = (yyvsp + 0)->textintval;
#line 486
  goto switch_break;
  case_38: /* CIL Label */ 
#line 488
  pc->day = (yyvsp + -1)->textintval.value;
#line 489
  pc->month = (yyvsp + 0)->intval;
#line 491
  goto switch_break;
  case_39: /* CIL Label */ 
#line 493
  pc->day = (yyvsp + -2)->textintval.value;
#line 494
  pc->month = (yyvsp + -1)->intval;
#line 495
  pc->year = (yyvsp + 0)->textintval;
#line 497
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 501
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
  }
#line 502
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 503
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 504
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 505
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 506
  goto switch_break;
  case_43: /* CIL Label */ 
#line 510
  __constr_expr_0.year = 0L;
#line 510
  __constr_expr_0.month = 0L;
#line 510
  __constr_expr_0.day = 0L;
#line 510
  __constr_expr_0.hour = 0L;
#line 510
  __constr_expr_0.minutes = 0L;
#line 510
  __constr_expr_0.seconds = (long_time_t )0;
#line 510
  __constr_expr_0.ns = 0L;
#line 510
  yyval.rel = __constr_expr_0;
#line 510
  yyval.rel.year = (yyvsp + -1)->intval;
#line 511
  goto switch_break;
  case_44: /* CIL Label */ 
#line 512
  __constr_expr_1.year = 0L;
#line 512
  __constr_expr_1.month = 0L;
#line 512
  __constr_expr_1.day = 0L;
#line 512
  __constr_expr_1.hour = 0L;
#line 512
  __constr_expr_1.minutes = 0L;
#line 512
  __constr_expr_1.seconds = (long_time_t )0;
#line 512
  __constr_expr_1.ns = 0L;
#line 512
  yyval.rel = __constr_expr_1;
#line 512
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 513
  goto switch_break;
  case_45: /* CIL Label */ 
#line 514
  __constr_expr_2.year = 0L;
#line 514
  __constr_expr_2.month = 0L;
#line 514
  __constr_expr_2.day = 0L;
#line 514
  __constr_expr_2.hour = 0L;
#line 514
  __constr_expr_2.minutes = 0L;
#line 514
  __constr_expr_2.seconds = (long_time_t )0;
#line 514
  __constr_expr_2.ns = 0L;
#line 514
  yyval.rel = __constr_expr_2;
#line 514
  yyval.rel.year = 1L;
#line 515
  goto switch_break;
  case_46: /* CIL Label */ 
#line 516
  __constr_expr_3.year = 0L;
#line 516
  __constr_expr_3.month = 0L;
#line 516
  __constr_expr_3.day = 0L;
#line 516
  __constr_expr_3.hour = 0L;
#line 516
  __constr_expr_3.minutes = 0L;
#line 516
  __constr_expr_3.seconds = (long_time_t )0;
#line 516
  __constr_expr_3.ns = 0L;
#line 516
  yyval.rel = __constr_expr_3;
#line 516
  yyval.rel.month = (yyvsp + -1)->intval;
#line 517
  goto switch_break;
  case_47: /* CIL Label */ 
#line 518
  __constr_expr_4.year = 0L;
#line 518
  __constr_expr_4.month = 0L;
#line 518
  __constr_expr_4.day = 0L;
#line 518
  __constr_expr_4.hour = 0L;
#line 518
  __constr_expr_4.minutes = 0L;
#line 518
  __constr_expr_4.seconds = (long_time_t )0;
#line 518
  __constr_expr_4.ns = 0L;
#line 518
  yyval.rel = __constr_expr_4;
#line 518
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 519
  goto switch_break;
  case_48: /* CIL Label */ 
#line 520
  __constr_expr_5.year = 0L;
#line 520
  __constr_expr_5.month = 0L;
#line 520
  __constr_expr_5.day = 0L;
#line 520
  __constr_expr_5.hour = 0L;
#line 520
  __constr_expr_5.minutes = 0L;
#line 520
  __constr_expr_5.seconds = (long_time_t )0;
#line 520
  __constr_expr_5.ns = 0L;
#line 520
  yyval.rel = __constr_expr_5;
#line 520
  yyval.rel.month = 1L;
#line 521
  goto switch_break;
  case_49: /* CIL Label */ 
#line 522
  __constr_expr_6.year = 0L;
#line 522
  __constr_expr_6.month = 0L;
#line 522
  __constr_expr_6.day = 0L;
#line 522
  __constr_expr_6.hour = 0L;
#line 522
  __constr_expr_6.minutes = 0L;
#line 522
  __constr_expr_6.seconds = (long_time_t )0;
#line 522
  __constr_expr_6.ns = 0L;
#line 522
  yyval.rel = __constr_expr_6;
#line 522
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 523
  goto switch_break;
  case_50: /* CIL Label */ 
#line 524
  __constr_expr_7.year = 0L;
#line 524
  __constr_expr_7.month = 0L;
#line 524
  __constr_expr_7.day = 0L;
#line 524
  __constr_expr_7.hour = 0L;
#line 524
  __constr_expr_7.minutes = 0L;
#line 524
  __constr_expr_7.seconds = (long_time_t )0;
#line 524
  __constr_expr_7.ns = 0L;
#line 524
  yyval.rel = __constr_expr_7;
#line 524
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 525
  goto switch_break;
  case_51: /* CIL Label */ 
#line 526
  __constr_expr_8.year = 0L;
#line 526
  __constr_expr_8.month = 0L;
#line 526
  __constr_expr_8.day = 0L;
#line 526
  __constr_expr_8.hour = 0L;
#line 526
  __constr_expr_8.minutes = 0L;
#line 526
  __constr_expr_8.seconds = (long_time_t )0;
#line 526
  __constr_expr_8.ns = 0L;
#line 526
  yyval.rel = __constr_expr_8;
#line 526
  yyval.rel.day = (yyvsp + 0)->intval;
#line 527
  goto switch_break;
  case_52: /* CIL Label */ 
#line 528
  __constr_expr_9.year = 0L;
#line 528
  __constr_expr_9.month = 0L;
#line 528
  __constr_expr_9.day = 0L;
#line 528
  __constr_expr_9.hour = 0L;
#line 528
  __constr_expr_9.minutes = 0L;
#line 528
  __constr_expr_9.seconds = (long_time_t )0;
#line 528
  __constr_expr_9.ns = 0L;
#line 528
  yyval.rel = __constr_expr_9;
#line 528
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 529
  goto switch_break;
  case_53: /* CIL Label */ 
#line 530
  __constr_expr_10.year = 0L;
#line 530
  __constr_expr_10.month = 0L;
#line 530
  __constr_expr_10.day = 0L;
#line 530
  __constr_expr_10.hour = 0L;
#line 530
  __constr_expr_10.minutes = 0L;
#line 530
  __constr_expr_10.seconds = (long_time_t )0;
#line 530
  __constr_expr_10.ns = 0L;
#line 530
  yyval.rel = __constr_expr_10;
#line 530
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 531
  goto switch_break;
  case_54: /* CIL Label */ 
#line 532
  __constr_expr_11.year = 0L;
#line 532
  __constr_expr_11.month = 0L;
#line 532
  __constr_expr_11.day = 0L;
#line 532
  __constr_expr_11.hour = 0L;
#line 532
  __constr_expr_11.minutes = 0L;
#line 532
  __constr_expr_11.seconds = (long_time_t )0;
#line 532
  __constr_expr_11.ns = 0L;
#line 532
  yyval.rel = __constr_expr_11;
#line 532
  yyval.rel.hour = 1L;
#line 533
  goto switch_break;
  case_55: /* CIL Label */ 
#line 534
  __constr_expr_12.year = 0L;
#line 534
  __constr_expr_12.month = 0L;
#line 534
  __constr_expr_12.day = 0L;
#line 534
  __constr_expr_12.hour = 0L;
#line 534
  __constr_expr_12.minutes = 0L;
#line 534
  __constr_expr_12.seconds = (long_time_t )0;
#line 534
  __constr_expr_12.ns = 0L;
#line 534
  yyval.rel = __constr_expr_12;
#line 534
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 535
  goto switch_break;
  case_56: /* CIL Label */ 
#line 536
  __constr_expr_13.year = 0L;
#line 536
  __constr_expr_13.month = 0L;
#line 536
  __constr_expr_13.day = 0L;
#line 536
  __constr_expr_13.hour = 0L;
#line 536
  __constr_expr_13.minutes = 0L;
#line 536
  __constr_expr_13.seconds = (long_time_t )0;
#line 536
  __constr_expr_13.ns = 0L;
#line 536
  yyval.rel = __constr_expr_13;
#line 536
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 537
  goto switch_break;
  case_57: /* CIL Label */ 
#line 538
  __constr_expr_14.year = 0L;
#line 538
  __constr_expr_14.month = 0L;
#line 538
  __constr_expr_14.day = 0L;
#line 538
  __constr_expr_14.hour = 0L;
#line 538
  __constr_expr_14.minutes = 0L;
#line 538
  __constr_expr_14.seconds = (long_time_t )0;
#line 538
  __constr_expr_14.ns = 0L;
#line 538
  yyval.rel = __constr_expr_14;
#line 538
  yyval.rel.minutes = 1L;
#line 539
  goto switch_break;
  case_58: /* CIL Label */ 
#line 540
  __constr_expr_15.year = 0L;
#line 540
  __constr_expr_15.month = 0L;
#line 540
  __constr_expr_15.day = 0L;
#line 540
  __constr_expr_15.hour = 0L;
#line 540
  __constr_expr_15.minutes = 0L;
#line 540
  __constr_expr_15.seconds = (long_time_t )0;
#line 540
  __constr_expr_15.ns = 0L;
#line 540
  yyval.rel = __constr_expr_15;
#line 540
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 541
  goto switch_break;
  case_59: /* CIL Label */ 
#line 542
  __constr_expr_16.year = 0L;
#line 542
  __constr_expr_16.month = 0L;
#line 542
  __constr_expr_16.day = 0L;
#line 542
  __constr_expr_16.hour = 0L;
#line 542
  __constr_expr_16.minutes = 0L;
#line 542
  __constr_expr_16.seconds = (long_time_t )0;
#line 542
  __constr_expr_16.ns = 0L;
#line 542
  yyval.rel = __constr_expr_16;
#line 542
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 543
  goto switch_break;
  case_60: /* CIL Label */ 
#line 544
  __constr_expr_17.year = 0L;
#line 544
  __constr_expr_17.month = 0L;
#line 544
  __constr_expr_17.day = 0L;
#line 544
  __constr_expr_17.hour = 0L;
#line 544
  __constr_expr_17.minutes = 0L;
#line 544
  __constr_expr_17.seconds = (long_time_t )0;
#line 544
  __constr_expr_17.ns = 0L;
#line 544
  yyval.rel = __constr_expr_17;
#line 544
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 544
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 545
  goto switch_break;
  case_61: /* CIL Label */ 
#line 546
  __constr_expr_18.year = 0L;
#line 546
  __constr_expr_18.month = 0L;
#line 546
  __constr_expr_18.day = 0L;
#line 546
  __constr_expr_18.hour = 0L;
#line 546
  __constr_expr_18.minutes = 0L;
#line 546
  __constr_expr_18.seconds = (long_time_t )0;
#line 546
  __constr_expr_18.ns = 0L;
#line 546
  yyval.rel = __constr_expr_18;
#line 546
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 546
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 547
  goto switch_break;
  case_62: /* CIL Label */ 
#line 548
  __constr_expr_19.year = 0L;
#line 548
  __constr_expr_19.month = 0L;
#line 548
  __constr_expr_19.day = 0L;
#line 548
  __constr_expr_19.hour = 0L;
#line 548
  __constr_expr_19.minutes = 0L;
#line 548
  __constr_expr_19.seconds = (long_time_t )0;
#line 548
  __constr_expr_19.ns = 0L;
#line 548
  yyval.rel = __constr_expr_19;
#line 548
  yyval.rel.seconds = (long_time_t )1;
#line 549
  goto switch_break;
  case_64: /* CIL Label */ 
#line 554
  __constr_expr_20.year = 0L;
#line 554
  __constr_expr_20.month = 0L;
#line 554
  __constr_expr_20.day = 0L;
#line 554
  __constr_expr_20.hour = 0L;
#line 554
  __constr_expr_20.minutes = 0L;
#line 554
  __constr_expr_20.seconds = (long_time_t )0;
#line 554
  __constr_expr_20.ns = 0L;
#line 554
  yyval.rel = __constr_expr_20;
#line 554
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 555
  goto switch_break;
  case_65: /* CIL Label */ 
#line 556
  __constr_expr_21.year = 0L;
#line 556
  __constr_expr_21.month = 0L;
#line 556
  __constr_expr_21.day = 0L;
#line 556
  __constr_expr_21.hour = 0L;
#line 556
  __constr_expr_21.minutes = 0L;
#line 556
  __constr_expr_21.seconds = (long_time_t )0;
#line 556
  __constr_expr_21.ns = 0L;
#line 556
  yyval.rel = __constr_expr_21;
#line 556
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 557
  goto switch_break;
  case_66: /* CIL Label */ 
#line 558
  __constr_expr_22.year = 0L;
#line 558
  __constr_expr_22.month = 0L;
#line 558
  __constr_expr_22.day = 0L;
#line 558
  __constr_expr_22.hour = 0L;
#line 558
  __constr_expr_22.minutes = 0L;
#line 558
  __constr_expr_22.seconds = (long_time_t )0;
#line 558
  __constr_expr_22.ns = 0L;
#line 558
  yyval.rel = __constr_expr_22;
#line 558
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 559
  goto switch_break;
  case_67: /* CIL Label */ 
#line 560
  __constr_expr_23.year = 0L;
#line 560
  __constr_expr_23.month = 0L;
#line 560
  __constr_expr_23.day = 0L;
#line 560
  __constr_expr_23.hour = 0L;
#line 560
  __constr_expr_23.minutes = 0L;
#line 560
  __constr_expr_23.seconds = (long_time_t )0;
#line 560
  __constr_expr_23.ns = 0L;
#line 560
  yyval.rel = __constr_expr_23;
#line 560
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 561
  goto switch_break;
  case_68: /* CIL Label */ 
#line 562
  __constr_expr_24.year = 0L;
#line 562
  __constr_expr_24.month = 0L;
#line 562
  __constr_expr_24.day = 0L;
#line 562
  __constr_expr_24.hour = 0L;
#line 562
  __constr_expr_24.minutes = 0L;
#line 562
  __constr_expr_24.seconds = (long_time_t )0;
#line 562
  __constr_expr_24.ns = 0L;
#line 562
  yyval.rel = __constr_expr_24;
#line 562
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 563
  goto switch_break;
  case_69: /* CIL Label */ 
#line 564
  __constr_expr_25.year = 0L;
#line 564
  __constr_expr_25.month = 0L;
#line 564
  __constr_expr_25.day = 0L;
#line 564
  __constr_expr_25.hour = 0L;
#line 564
  __constr_expr_25.minutes = 0L;
#line 564
  __constr_expr_25.seconds = (long_time_t )0;
#line 564
  __constr_expr_25.ns = 0L;
#line 564
  yyval.rel = __constr_expr_25;
#line 564
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 565
  goto switch_break;
  case_70: /* CIL Label */ 
#line 569
  __constr_expr_26.year = 0L;
#line 569
  __constr_expr_26.month = 0L;
#line 569
  __constr_expr_26.day = 0L;
#line 569
  __constr_expr_26.hour = 0L;
#line 569
  __constr_expr_26.minutes = 0L;
#line 569
  __constr_expr_26.seconds = (long_time_t )0;
#line 569
  __constr_expr_26.ns = 0L;
#line 569
  yyval.rel = __constr_expr_26;
#line 569
  yyval.rel.day = (yyvsp + 0)->intval;
#line 570
  goto switch_break;
  case_74: /* CIL Label */ 
#line 577
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 577
  yyval.timespec.tv_nsec = 0L;
#line 578
  goto switch_break;
  case_76: /* CIL Label */ 
#line 583
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 583
  yyval.timespec.tv_nsec = 0L;
#line 584
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 588
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 589
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 596
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 597
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 599
  goto switch_break;
  case_79: /* CIL Label */ 
#line 603
  yyval.intval = -1L;
#line 604
  goto switch_break;
  case_80: /* CIL Label */ 
#line 605
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 606
  goto switch_break;
  case_81: /* CIL Label */ 
#line 610
  yyval.intval = 2L;
#line 611
  goto switch_break;
  case_82: /* CIL Label */ 
#line 612
  yyval.intval = (yyvsp + 0)->intval;
#line 613
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2177 "getdate.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2181
  yyvsp -= yylen;
#line 2181
  yyssp -= yylen;
#line 2182
  yylen = 0;
#line 2185
  yyvsp ++;
#line 2185
  *yyvsp = yyval;
#line 2192
  yyn = (int )yyr1[yyn];
#line 2194
  yystate = (int )((int const   )yypgoto[yyn - 27] + (int const   )*yyssp);
#line 2195
  if (0 <= yystate) {
#line 2195
    if (yystate <= 98) {
#line 2195
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2196
        yystate = (int )yytable[yystate];
      } else {
#line 2198
        yystate = (int )yydefgoto[yyn - 27];
      }
    } else {
#line 2198
      yystate = (int )yydefgoto[yyn - 27];
    }
  } else {
#line 2198
    yystate = (int )yydefgoto[yyn - 27];
  }
#line 2200
  goto yynewstate;
  yyerrlab: 
#line 2208
  if (! yyerrstatus) {
    {
#line 2210
    yynerrs ++;
#line 2212
    yyerror((parser_control const   *)pc, "syntax error");
    }
  }
#line 2250
  if (yyerrstatus == 3) {
#line 2255
    if (yychar <= 0) {
#line 2258
      if (yychar == 0) {
#line 2259
        goto yyabortlab;
      }
    } else {
      {
#line 2263
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2265
      yychar = -2;
      }
    }
  }
#line 2271
  goto yyerrlab1;
#line 2287
  yyvsp -= yylen;
#line 2287
  yyssp -= yylen;
#line 2288
  yylen = 0;
#line 2290
  yystate = (int )*yyssp;
#line 2291
  goto yyerrlab1;
  yyerrlab1: 
#line 2298
  yyerrstatus = 3;
  {
#line 2300
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2302
    yyn = (int )yypact[yystate];
#line 2303
    if (yyn != -82) {
#line 2305
      yyn ++;
#line 2306
      if (0 <= yyn) {
#line 2306
        if (yyn <= 98) {
#line 2306
          if ((int const   )yycheck[yyn] == 1) {
#line 2308
            yyn = (int )yytable[yyn];
#line 2309
            if (0 < yyn) {
#line 2310
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2315
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2316
      goto yyabortlab;
    }
    {
#line 2319
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2321
    yyvsp --;
#line 2321
    yyssp --;
#line 2322
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2326
  if (yyn == 12) {
#line 2327
    goto yyacceptlab;
  }
#line 2329
  yyvsp ++;
#line 2329
  *yyvsp = yylval;
#line 2335
  yystate = yyn;
#line 2336
  goto yynewstate;
  yyacceptlab: 
#line 2343
  yyresult = 0;
#line 2344
  goto yyreturn;
  yyabortlab: 
#line 2350
  yyresult = 1;
#line 2351
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2358
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2359
  yyresult = 2;
  }
  yyreturn: 
#line 2364
  if (yychar != 0) {
#line 2364
    if (yychar != -2) {
      {
#line 2365
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
      }
    }
  }
#line 2369
  yyvsp -= yylen;
#line 2369
  yyssp -= yylen;
  {
#line 2371
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2371
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2371
      goto while_break___2;
    }
    {
#line 2373
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2375
    yyvsp --;
#line 2375
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2378
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2379
    free((void *)yyss);
    }
  }
#line 2386
  return (yyresult);
}
}
#line 617 "getdate.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 626 "getdate.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 631 "getdate.y"
static table const   month_and_day_table[25]  = 
#line 631
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 660 "getdate.y"
static table const   time_units_table[11]  = 
#line 660
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 676 "getdate.y"
static table const   relative_time_table[20]  = 
#line 676
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 704 "getdate.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 717 "getdate.y"
static table const   time_zone_table[48]  = 
#line 717
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 770 "getdate.y"
static table const   military_table[26]  = 
#line 770
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 273, 420}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 809 "getdate.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 816
  if (s.digits <= 2UL) {
#line 816
    if (mm < 0L) {
#line 817
      s.value *= 100L;
    }
  }
#line 819
  if (mm < 0L) {
#line 820
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 822
    if (s.negative) {
#line 822
      tmp = - mm;
    } else {
#line 822
      tmp = mm;
    }
#line 822
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 827
  tmp___0 = abs((int )n_minutes);
  }
#line 827
  if (1440 < tmp___0) {
#line 828
    (pc->zones_seen) ++;
  }
#line 830
  return (n_minutes);
}
}
#line 833 "getdate.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 841
  if (meridian == 0) {
#line 841
    goto case_0;
  }
#line 843
  if (meridian == 1) {
#line 843
    goto case_1;
  }
#line 838
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 840
  if (0L <= hours) {
#line 840
    if (hours < 24L) {
#line 840
      tmp = hours;
    } else {
#line 840
      tmp = -1L;
    }
  } else {
#line 840
    tmp = -1L;
  }
#line 840
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 842
  if (0L < hours) {
#line 842
    if (hours < 12L) {
#line 842
      tmp___1 = hours;
    } else {
#line 842
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 842
    if (hours == 12L) {
#line 842
      tmp___0 = 0;
    } else {
#line 842
      tmp___0 = -1;
    }
#line 842
    tmp___1 = (long )tmp___0;
  }
#line 842
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 844
  if (0L < hours) {
#line 844
    if (hours < 12L) {
#line 844
      tmp___3 = hours + 12L;
    } else {
#line 844
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 844
    if (hours == 12L) {
#line 844
      tmp___2 = 12;
    } else {
#line 844
      tmp___2 = -1;
    }
#line 844
    tmp___3 = (long )tmp___2;
  }
#line 844
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 848 "getdate.y"
static long to_year(textint textyear ) 
{ 
  long year ;
  int tmp ;

  {
#line 851
  year = textyear.value;
#line 853
  if (year < 0L) {
#line 854
    year = - year;
  } else
#line 858
  if (textyear.digits == 2UL) {
#line 859
    if (year < 69L) {
#line 859
      tmp = 2000;
    } else {
#line 859
      tmp = 1900;
    }
#line 859
    year += (long )tmp;
  }
#line 861
  return (year);
}
}
#line 864 "getdate.y"
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 869
  tp = universal_time_zone_table;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! tp->name) {
#line 869
      goto while_break;
    }
    {
#line 870
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 870
    if (tmp == 0) {
#line 871
      return (tp);
    }
#line 869
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 875
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 875
    if (! tp->name) {
#line 875
      goto while_break___0;
    }
    {
#line 876
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 876
    if (tmp___0 == 0) {
#line 877
      return (tp);
    }
#line 875
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 879
  tp = time_zone_table;
  {
#line 879
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 879
    if (! tp->name) {
#line 879
      goto while_break___1;
    }
    {
#line 880
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 880
    if (tmp___1 == 0) {
#line 881
      return (tp);
    }
#line 879
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 883
  return ((table const   *)((void *)0));
}
}
#line 913 "getdate.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;

  {
#line 924
  p = word;
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! *p) {
#line 924
      goto while_break;
    }
    {
#line 926
    ch = (unsigned char )*p;
#line 927
    tmp = c_toupper((int )ch);
#line 927
    *p = (char )tmp;
#line 924
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  tp = meridian_table;
  {
#line 930
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 930
    if (! tp->name) {
#line 930
      goto while_break___0;
    }
    {
#line 931
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 931
    if (tmp___0 == 0) {
#line 932
      return (tp);
    }
#line 930
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 935
  wordlen = strlen((char const   *)word);
  }
#line 936
  if (wordlen == 3UL) {
#line 936
    tmp___1 = 1;
  } else
#line 936
  if (wordlen == 4UL) {
#line 936
    if ((int )*(word + 3) == 46) {
#line 936
      tmp___1 = 1;
    } else {
#line 936
      tmp___1 = 0;
    }
  } else {
#line 936
    tmp___1 = 0;
  }
#line 936
  abbrev = (_Bool )tmp___1;
#line 938
  tp = month_and_day_table;
  {
#line 938
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 938
    if (! tp->name) {
#line 938
      goto while_break___1;
    }
#line 939
    if (abbrev) {
      {
#line 939
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 939
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 939
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 939
      tmp___4 = tmp___3;
      }
    }
#line 939
    if (tmp___4 == 0) {
#line 940
      return (tp);
    }
#line 938
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 942
  tp = lookup_zone(pc, (char const   *)word);
  }
#line 942
  if (tp) {
#line 943
    return (tp);
  }
  {
#line 945
  tmp___5 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
  }
#line 945
  if (tmp___5 == 0) {
#line 946
    return (dst_table);
  }
#line 948
  tp = time_units_table;
  {
#line 948
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 948
    if (! tp->name) {
#line 948
      goto while_break___2;
    }
    {
#line 949
    tmp___6 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 949
    if (tmp___6 == 0) {
#line 950
      return (tp);
    }
#line 948
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 953
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 955
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 956
    tp = time_units_table;
    {
#line 956
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 956
      if (! tp->name) {
#line 956
        goto while_break___3;
      }
      {
#line 957
      tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 957
      if (tmp___7 == 0) {
#line 958
        return (tp);
      }
#line 956
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 959
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 962
  tp = relative_time_table;
  {
#line 962
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 962
    if (! tp->name) {
#line 962
      goto while_break___4;
    }
    {
#line 963
    tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 963
    if (tmp___8 == 0) {
#line 964
      return (tp);
    }
#line 962
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 967
  if (wordlen == 1UL) {
#line 968
    tp = military_table;
    {
#line 968
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 968
      if (! tp->name) {
#line 968
        goto while_break___5;
      }
#line 969
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 970
        return (tp);
      }
#line 968
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 973
  period_found = (_Bool)0;
#line 973
  q = word;
#line 973
  p = q;
  {
#line 973
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 973
    tmp___9 = *q;
#line 973
    *p = tmp___9;
#line 973
    if (! tmp___9) {
#line 973
      goto while_break___6;
    }
#line 974
    if ((int )*q == 46) {
#line 975
      period_found = (_Bool)1;
    } else {
#line 977
      p ++;
    }
#line 973
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 978
  if (period_found) {
    {
#line 978
    tp = lookup_zone(pc, (char const   *)word);
    }
#line 978
    if (tp) {
#line 979
      return (tp);
    }
  }
#line 981
  return ((table const   *)((void *)0));
}
}
#line 984 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  void *__cil_tmp27 ;

  {
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 992
      c = (unsigned char )*(pc->input);
#line 992
      tmp = c_isspace((int )c);
      }
#line 992
      if (! tmp) {
#line 992
        goto while_break___0;
      }
#line 993
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 995
    if ((unsigned int )c - 48U <= 9U) {
#line 995
      goto _L___2;
    } else
#line 995
    if ((int )c == 45) {
#line 995
      goto _L___2;
    } else
#line 995
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1000
      if ((int )c == 45) {
#line 1000
        goto _L;
      } else
#line 1000
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1002
        if ((int )c == 45) {
#line 1002
          sign = -1;
        } else {
#line 1002
          sign = 1;
        }
        {
#line 1003
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1003
          (pc->input) ++;
#line 1003
          c = (unsigned char )*(pc->input);
#line 1003
          tmp___0 = c_isspace((int )c);
          }
#line 1003
          if (! tmp___0) {
#line 1003
            goto while_break___1;
          }
#line 1004
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1005
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1007
          goto __Cont;
        }
      } else {
#line 1010
        sign = 0;
      }
#line 1011
      p = pc->input;
#line 1012
      value = 0UL;
      {
#line 1012
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1014
        value1 = value + (unsigned long )((int )c - 48);
#line 1015
        if (value1 < value) {
#line 1016
          return ('?');
        }
#line 1017
        value = value1;
#line 1018
        p ++;
#line 1018
        c = (unsigned char )*p;
#line 1019
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1020
          goto while_break___2;
        }
#line 1021
        if (1844674407370955161UL < value) {
#line 1022
          return ('?');
        }
#line 1012
        value *= 10UL;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1024
      if ((int )c == 46) {
#line 1024
        goto _L___1;
      } else
#line 1024
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1024
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1032
          if (sign < 0) {
#line 1034
            s = (time_t )(- value);
#line 1035
            if (0L < s) {
#line 1036
              return ('?');
            }
#line 1037
            value1___0 = (unsigned long )(- s);
          } else {
#line 1041
            s = (time_t )value;
#line 1042
            if (s < 0L) {
#line 1043
              return ('?');
            }
#line 1044
            value1___0 = (unsigned long )s;
          }
#line 1046
          if (value != value1___0) {
#line 1047
            return ('?');
          }
#line 1050
          p ++;
#line 1051
          tmp___1 = p;
#line 1051
          p ++;
#line 1051
          ns = (int )((int const   )*tmp___1 - 48);
#line 1052
          digits = 2;
          {
#line 1052
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1052
            if (! (digits <= 9)) {
#line 1052
              goto while_break___3;
            }
#line 1054
            ns *= 10;
#line 1055
            if ((unsigned int )*p - 48U <= 9U) {
#line 1056
              tmp___2 = p;
#line 1056
              p ++;
#line 1056
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1052
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1060
          if (sign < 0) {
            {
#line 1061
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1061
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1061
                goto while_break___4;
              }
#line 1062
              if ((int const   )*p != 48) {
#line 1064
                ns ++;
#line 1065
                goto while_break___4;
              }
#line 1061
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1067
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1067
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1067
              goto while_break___5;
            }
#line 1068
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1073
          if (sign < 0) {
#line 1073
            if (ns) {
#line 1075
              s --;
#line 1076
              if (! (s < 0L)) {
#line 1077
                return ('?');
              }
#line 1078
              ns = 1000000000 - ns;
            }
          }
#line 1081
          lvalp->timespec.tv_sec = s;
#line 1082
          lvalp->timespec.tv_nsec = (long )ns;
#line 1083
          pc->input = p;
#line 1084
          if (sign) {
#line 1084
            tmp___3 = 276;
          } else {
#line 1084
            tmp___3 = 277;
          }
#line 1084
          return (tmp___3);
        } else {
#line 1024
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1088
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1089
        if (sign < 0) {
#line 1091
          lvalp->textintval.value = (long )(- value);
#line 1092
          if (0L < lvalp->textintval.value) {
#line 1093
            return ('?');
          }
        } else {
#line 1097
          lvalp->textintval.value = (long )value;
#line 1098
          if (lvalp->textintval.value < 0L) {
#line 1099
            return ('?');
          }
        }
#line 1101
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1102
        pc->input = p;
#line 1103
        if (sign) {
#line 1103
          tmp___4 = 274;
        } else {
#line 1103
          tmp___4 = 275;
        }
#line 1103
        return (tmp___4);
      }
    }
    {
#line 1107
    tmp___7 = c_isalpha((int )c);
    }
#line 1107
    if (tmp___7) {
#line 1110
      p___0 = buff;
      {
#line 1113
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1115
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1116
          tmp___5 = p___0;
#line 1116
          p___0 ++;
#line 1116
          *tmp___5 = (char )c;
        }
        {
#line 1117
        (pc->input) ++;
#line 1117
        c = (unsigned char )*(pc->input);
#line 1113
        tmp___6 = c_isalpha((int )c);
        }
#line 1113
        if (! tmp___6) {
#line 1113
          if (! ((int )c == 46)) {
#line 1113
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1121
      *p___0 = (char )'\000';
#line 1122
      tp = lookup_word((parser_control const   *)pc, buff);
      }
#line 1123
      if (! tp) {
#line 1124
        return ('?');
      }
#line 1125
      lvalp->intval = (long )tp->value;
#line 1126
      return ((int )tp->type);
    }
#line 1129
    if ((int )c != 40) {
#line 1130
      tmp___8 = pc->input;
#line 1130
      (pc->input) ++;
#line 1130
      return ((int )*tmp___8);
    }
#line 1131
    count = (size_t )0;
    {
#line 1132
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1134
      tmp___9 = pc->input;
#line 1134
      (pc->input) ++;
#line 1134
      c = (unsigned char )*tmp___9;
#line 1135
      if ((int )c == 0) {
#line 1136
        return ((int )c);
      }
#line 1137
      if ((int )c == 40) {
#line 1138
        count ++;
      } else
#line 1139
      if ((int )c == 41) {
#line 1140
        count --;
      }
#line 1132
      if (! (count != 0UL)) {
#line 1132
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1147 "getdate.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1151
  return (0);
}
}
#line 1158 "getdate.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1161
  if (t == -1L) {
    {
#line 1166
    tmp = localtime((time_t const   *)(& t));
#line 1166
    tm1 = (struct tm  const  *)tmp;
    }
#line 1167
    if (! tm1) {
#line 1168
      return ((_Bool)0);
    }
  }
#line 1171
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1185 "getdate.y"
static char *get_tz(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 1188
  tmp = getenv("TZ");
#line 1188
  tz = tmp;
  }
#line 1189
  if (tz) {
    {
#line 1191
    tmp___0 = strlen((char const   *)tz);
#line 1191
    tzsize = tmp___0 + 1UL;
    }
#line 1192
    if (tzsize <= 100UL) {
      {
#line 1192
      tmp___1 = (void *)memcpy((void */* __restrict  */)tzbuf, (void const   */* __restrict  */)tz,
                               tzsize);
#line 1192
      tz = (char *)tmp___1;
      }
    } else {
      {
#line 1192
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1192
      tz = (char *)tmp___2;
      }
    }
  }
#line 1196
  return (tz);
}
}
#line 1203 "getdate.y"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  relative_time __constr_expr_27 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___10 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int year ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
#line 1214
  tz_was_altered = (_Bool)0;
#line 1215
  tz0 = (char *)((void *)0);
#line 1217
  ok = (_Bool)1;
#line 1219
  if (! now) {
    {
#line 1221
    gettime(& gettime_buffer);
#line 1222
    now = (struct timespec  const  *)(& gettime_buffer);
    }
  }
  {
#line 1225
  Start = (time_t )now->tv_sec;
#line 1226
  Start_ns = (long )now->tv_nsec;
#line 1228
  tmp___0 = localtime(& now->tv_sec);
#line 1228
  tmp = (struct tm  const  *)tmp___0;
  }
#line 1229
  if (! tmp) {
#line 1230
    return ((_Bool)0);
  }
  {
#line 1232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1232
    c = (unsigned char )*p;
#line 1232
    tmp___1 = c_isspace((int )c);
    }
#line 1232
    if (! tmp___1) {
#line 1232
      goto while_break;
    }
#line 1233
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1235
  tmp___5 = strncmp(p, "TZ=\"", (size_t )4);
  }
#line 1235
  if (tmp___5 == 0) {
#line 1237
    tzbase = p + 4;
#line 1238
    tzsize = (size_t )1;
#line 1241
    s = tzbase;
    {
#line 1241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1241
      if (! *s) {
#line 1241
        goto while_break___0;
      }
#line 1242
      if ((int const   )*s == 92) {
#line 1244
        s ++;
#line 1245
        if (! ((int const   )*s == 92)) {
#line 1245
          if (! ((int const   )*s == 34)) {
#line 1246
            goto while_break___0;
          }
        }
      } else
#line 1248
      if ((int const   )*s == 34) {
        {
#line 1253
        large_tz = (_Bool )(100UL < tzsize);
#line 1256
        free((void *)tz0);
#line 1257
        tz0 = get_tz((char *)(tz0buf));
        }
#line 1258
        if (large_tz) {
          {
#line 1258
          tmp___2 = xmalloc(tzsize);
#line 1258
          tz1 = (char *)tmp___2;
          }
        } else {
#line 1258
          tz1 = tz1buf;
        }
#line 1258
        z = tz1;
#line 1259
        s = tzbase;
        {
#line 1259
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1259
          if (! ((int const   )*s != 34)) {
#line 1259
            goto while_break___1;
          }
#line 1260
          tmp___3 = z;
#line 1260
          z ++;
#line 1260
          s += (int const   )*s == 92;
#line 1260
          *tmp___3 = (char )*s;
#line 1259
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1261
        *z = (char )'\000';
#line 1262
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1262
        setenv_ok = (_Bool )(tmp___4 == 0);
        }
#line 1263
        if (large_tz) {
          {
#line 1264
          free((void *)tz1);
          }
        }
#line 1265
        if (! setenv_ok) {
#line 1266
          goto fail;
        }
#line 1267
        tz_was_altered = (_Bool)1;
#line 1268
        p = s + 1;
      }
#line 1241
      s ++;
#line 1241
      tzsize ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1275
  if ((int const   )*p == 0) {
#line 1276
    p = "0";
  }
#line 1278
  pc.input = p;
#line 1279
  pc.year.value = (long )tmp->tm_year;
#line 1280
  pc.year.value += 1900L;
#line 1281
  pc.year.digits = (size_t )0;
#line 1282
  pc.month = (long )(tmp->tm_mon + 1);
#line 1283
  pc.day = (long )tmp->tm_mday;
#line 1284
  pc.hour = (long )tmp->tm_hour;
#line 1285
  pc.minutes = (long )tmp->tm_min;
#line 1286
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1287
  pc.seconds.tv_nsec = Start_ns;
#line 1288
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1290
  pc.meridian = 2;
#line 1291
  __constr_expr_27.year = 0L;
#line 1291
  __constr_expr_27.month = 0L;
#line 1291
  __constr_expr_27.day = 0L;
#line 1291
  __constr_expr_27.hour = 0L;
#line 1291
  __constr_expr_27.minutes = 0L;
#line 1291
  __constr_expr_27.seconds = (long_time_t )0;
#line 1291
  __constr_expr_27.ns = 0L;
#line 1291
  pc.rel = __constr_expr_27;
#line 1292
  pc.timespec_seen = (_Bool)0;
#line 1293
  pc.rels_seen = (_Bool)0;
#line 1294
  pc.dates_seen = (size_t )0;
#line 1295
  pc.days_seen = (size_t )0;
#line 1296
  pc.times_seen = (size_t )0;
#line 1297
  pc.local_zones_seen = (size_t )0;
#line 1298
  pc.dsts_seen = (size_t )0;
#line 1299
  pc.zones_seen = (size_t )0;
#line 1302
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1303
  pc.local_time_zone_table[0].type = 269;
#line 1304
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1305
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1311
  quarter = 1;
  {
#line 1311
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1311
    if (! (quarter <= 3)) {
#line 1311
      goto while_break___2;
    }
    {
#line 1313
    probe = Start + (time_t )(quarter * 7776000);
#line 1314
    tmp___6 = localtime((time_t const   *)(& probe));
#line 1314
    probe_tm = (struct tm  const  *)tmp___6;
    }
#line 1315
    if (probe_tm) {
#line 1315
      if (probe_tm->tm_zone) {
#line 1315
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1319
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1320
          pc.local_time_zone_table[1].type = 269;
#line 1321
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1322
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1324
          goto while_break___2;
        }
      }
    }
#line 1311
    quarter ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1348
  if (pc.local_time_zone_table[0].name) {
#line 1348
    if (pc.local_time_zone_table[1].name) {
      {
#line 1348
      tmp___7 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
      }
#line 1348
      if (! tmp___7) {
#line 1355
        pc.local_time_zone_table[0].value = -1;
#line 1356
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1359
  tmp___8 = yyparse(& pc);
  }
#line 1359
  if (tmp___8 != 0) {
#line 1360
    goto fail;
  }
#line 1362
  if (pc.timespec_seen) {
#line 1363
    *result = pc.seconds;
  } else {
#line 1366
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1368
      goto fail;
    }
    {
#line 1370
    tmp___9 = to_year(pc.year);
#line 1370
    tm.tm_year = (int )(tmp___9 - 1900L);
#line 1371
    tm.tm_mon = (int )(pc.month - 1L);
#line 1372
    tm.tm_mday = (int )pc.day;
    }
#line 1373
    if (pc.times_seen) {
#line 1373
      goto _L;
    } else
#line 1373
    if (pc.rels_seen) {
#line 1373
      if (! pc.dates_seen) {
#line 1373
        if (! pc.days_seen) {
          _L: /* CIL Label */ 
          {
#line 1375
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
#line 1376
          if (tm.tm_hour < 0) {
#line 1377
            goto fail;
          }
#line 1378
          tm.tm_min = (int )pc.minutes;
#line 1379
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1383
          tm.tm_sec = 0;
#line 1383
          tm.tm_min = tm.tm_sec;
#line 1383
          tm.tm_hour = tm.tm_min;
#line 1384
          pc.seconds.tv_nsec = 0L;
        }
      } else {
#line 1383
        tm.tm_sec = 0;
#line 1383
        tm.tm_min = tm.tm_sec;
#line 1383
        tm.tm_hour = tm.tm_min;
#line 1384
        pc.seconds.tv_nsec = 0L;
      }
    } else {
#line 1383
      tm.tm_sec = 0;
#line 1383
      tm.tm_min = tm.tm_sec;
#line 1383
      tm.tm_hour = tm.tm_min;
#line 1384
      pc.seconds.tv_nsec = 0L;
    }
#line 1388
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1389
      tm.tm_isdst = -1;
    }
#line 1393
    if (pc.local_zones_seen) {
#line 1394
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 1396
    tm0 = tm;
#line 1398
    Start = mktime(& tm);
#line 1400
    tmp___13 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
    }
#line 1400
    if (! tmp___13) {
#line 1402
      if (! pc.zones_seen) {
#line 1403
        goto fail;
      } else {
#line 1416
        time_zone = pc.time_zone;
#line 1417
        if (time_zone < 0L) {
#line 1417
          tmp___10 = - time_zone;
        } else {
#line 1417
          tmp___10 = time_zone;
        }
#line 1417
        abs_time_zone = tmp___10;
#line 1418
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1419
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1422
        if (! tz_was_altered) {
          {
#line 1423
          tz0 = get_tz((char *)(tz0buf));
          }
        }
        {
#line 1424
        sprintf((char */* __restrict  */)(tz1buf___0), (char const   */* __restrict  */)"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1426
        tmp___11 = setenv("TZ", (char const   *)(tz1buf___0), 1);
        }
#line 1426
        if (tmp___11 != 0) {
#line 1427
          goto fail;
        }
        {
#line 1428
        tz_was_altered = (_Bool)1;
#line 1429
        tm = tm0;
#line 1430
        Start = mktime(& tm);
#line 1431
        tmp___12 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
        }
#line 1431
        if (! tmp___12) {
#line 1432
          goto fail;
        }
      }
    }
#line 1436
    if (pc.days_seen) {
#line 1436
      if (! pc.dates_seen) {
#line 1438
        if (0L < pc.day_ordinal) {
#line 1438
          if (tm.tm_wday != pc.day_number) {
#line 1438
            tmp___14 = 1;
          } else {
#line 1438
            tmp___14 = 0;
          }
        } else {
#line 1438
          tmp___14 = 0;
        }
        {
#line 1438
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___14)));
#line 1442
        tm.tm_isdst = -1;
#line 1443
        Start = mktime(& tm);
        }
#line 1444
        if (Start == -1L) {
#line 1445
          goto fail;
        }
      }
    }
#line 1449
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1451
      year = (int )((long )tm.tm_year + pc.rel.year);
#line 1452
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1453
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1454
      if ((((year < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1457
        goto fail;
      }
      {
#line 1458
      tm.tm_year = year;
#line 1459
      tm.tm_mon = month;
#line 1460
      tm.tm_mday = day;
#line 1461
      tm.tm_hour = tm0.tm_hour;
#line 1462
      tm.tm_min = tm0.tm_min;
#line 1463
      tm.tm_sec = tm0.tm_sec;
#line 1464
      tm.tm_isdst = tm0.tm_isdst;
#line 1465
      Start = mktime(& tm);
      }
#line 1466
      if (Start == -1L) {
#line 1467
        goto fail;
      }
    }
#line 1472
    if (pc.zones_seen) {
#line 1474
      delta = pc.time_zone * 60L;
#line 1477
      delta -= tm.tm_gmtoff;
#line 1485
      t1 = Start - delta;
#line 1486
      if ((Start < t1) != (delta < 0L)) {
#line 1487
        goto fail;
      }
#line 1488
      Start = t1;
    }
#line 1499
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1500
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1501
    t0 = Start;
#line 1502
    d1 = 3600L * pc.rel.hour;
#line 1503
    t1___0 = t0 + d1;
#line 1504
    d2 = 60L * pc.rel.minutes;
#line 1505
    t2 = t1___0 + d2;
#line 1506
    d3 = pc.rel.seconds;
#line 1507
    t3 = t2 + d3;
#line 1508
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1509
    t4 = t3 + d4;
#line 1510
    t5 = t4;
#line 1512
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1519
      goto fail;
    }
#line 1521
    result->tv_sec = t5;
#line 1522
    result->tv_nsec = normalized_ns;
  }
#line 1526
  goto done;
  fail: 
#line 1529
  ok = (_Bool)0;
  done: 
#line 1531
  if (tz_was_altered) {
#line 1532
    if (tz0) {
      {
#line 1532
      tmp___15 = setenv("TZ", (char const   *)tz0, 1);
#line 1532
      tmp___17 = tmp___15;
      }
    } else {
      {
#line 1532
      tmp___16 = unsetenv("TZ");
#line 1532
      tmp___17 = tmp___16;
      }
    }
#line 1532
    ok = (_Bool )((int )ok & (tmp___17 == 0));
  }
#line 1533
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    {
#line 1534
    free((void *)tz0);
    }
  }
#line 1535
  return (ok);
}
}
#line 507 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 238 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd ,
                                                                                      char const   * __restrict  __file ,
                                                                                      struct stat * __restrict  __buf ,
                                                                                      int __flag ) ;
#line 97 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 209 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) rewinddir)(DIR *__dirp ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) memmove)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
#line 108 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/getcwd.c"
char *rpl_getcwd(char *buf , size_t size ) 
{ 
  int fd ;
  _Bool fd_needs_closing ;
  DIR *dirstream ;
  dev_t rootdev ;
  dev_t thisdev ;
  ino_t rootino ;
  ino_t thisino ;
  char *dir ;
  register char *dirp ;
  struct stat st ;
  size_t allocated ;
  size_t used ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct dirent *d ;
  dev_t dotdev ;
  ino_t dotino ;
  _Bool mount_point ;
  int parent_status ;
  size_t dirroom ;
  size_t namlen ;
  _Bool use_d_ino ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  _Bool match ;
  int tmp___11 ;
  int entry_status ;
  int *tmp___12 ;
  char *tmp___13 ;
  size_t oldsize ;
  size_t tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  int save ;
  int *tmp___20 ;
  int *tmp___21 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  {
#line 124
  fd = -100;
#line 125
  fd_needs_closing = (_Bool)0;
#line 132
  dirstream = (DIR *)((void *)0);
#line 138
  allocated = size;
#line 154
  dir = (char *)getcwd(buf, size);
  }
#line 155
  if (dir) {
#line 156
    return (dir);
  } else {
    {
#line 155
    tmp = __errno_location();
    }
#line 155
    if (*tmp != 34) {
      {
#line 155
      tmp___0 = __errno_location();
      }
#line 155
      if (*tmp___0 != 36) {
        {
#line 155
        tmp___1 = __errno_location();
        }
#line 155
        if (*tmp___1 != 2) {
#line 156
          return (dir);
        }
      }
    }
  }
#line 159
  if (size == 0UL) {
#line 161
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 163
      tmp___2 = __errno_location();
#line 163
      *tmp___2 = 22;
      }
#line 164
      return ((char *)((void *)0));
    }
#line 167
    allocated = (size_t )4096;
  }
#line 170
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 172
    tmp___3 = malloc(allocated);
#line 172
    dir = (char *)tmp___3;
    }
#line 173
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 174
      return ((char *)((void *)0));
    }
  } else {
#line 177
    dir = buf;
  }
  {
#line 179
  dirp = dir + allocated;
#line 180
  dirp --;
#line 180
  *dirp = (char )'\000';
#line 182
  tmp___4 = lstat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st));
  }
#line 182
  if (tmp___4 < 0) {
#line 183
    goto lose;
  }
  {
#line 184
  thisdev = st.st_dev;
#line 185
  thisino = st.st_ino;
#line 187
  tmp___5 = lstat((char const   */* __restrict  */)"/", (struct stat */* __restrict  */)(& st));
  }
#line 187
  if (tmp___5 < 0) {
#line 188
    goto lose;
  }
#line 189
  rootdev = st.st_dev;
#line 190
  rootino = st.st_ino;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (thisdev == rootdev) {
#line 192
      if (thisino == rootino) {
#line 192
        goto while_break;
      }
    }
    {
#line 201
    use_d_ino = (_Bool)1;
#line 205
    fd = openat(fd, "..", 0);
    }
#line 206
    if (fd < 0) {
#line 207
      goto lose;
    }
    {
#line 208
    fd_needs_closing = (_Bool)1;
#line 209
    parent_status = fstat(fd, & st);
    }
#line 216
    if (parent_status != 0) {
#line 217
      goto lose;
    }
#line 219
    if (dirstream) {
      {
#line 219
      tmp___6 = closedir(dirstream);
      }
#line 219
      if (tmp___6 != 0) {
#line 221
        dirstream = (DIR *)((void *)0);
#line 222
        goto lose;
      }
    }
    {
#line 226
    dotdev = st.st_dev;
#line 227
    dotino = st.st_ino;
#line 228
    mount_point = (_Bool )(dotdev != thisdev);
#line 232
    dirstream = fdopendir(fd);
    }
#line 233
    if ((unsigned long )dirstream == (unsigned long )((void *)0)) {
#line 234
      goto lose;
    }
    {
#line 236
    fd = dirfd(dirstream);
#line 237
    fd_needs_closing = (_Bool)0;
    }
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 248
      tmp___7 = __errno_location();
#line 248
      *tmp___7 = 0;
#line 249
      d = readdir(dirstream);
      }
#line 258
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        {
#line 258
        tmp___8 = __errno_location();
        }
#line 258
        if (*tmp___8 == 0) {
#line 258
          if (use_d_ino) {
            {
#line 260
            use_d_ino = (_Bool)0;
#line 261
            rewinddir(dirstream);
#line 262
            d = readdir(dirstream);
            }
          }
        }
      }
#line 265
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        {
#line 267
        tmp___10 = __errno_location();
        }
#line 267
        if (*tmp___10 == 0) {
          {
#line 270
          tmp___9 = __errno_location();
#line 270
          *tmp___9 = 2;
          }
        }
#line 271
        goto lose;
      }
#line 273
      if ((int )d->d_name[0] == 46) {
#line 273
        if ((int )d->d_name[1] == 0) {
#line 276
          goto __Cont;
        } else
#line 273
        if ((int )d->d_name[1] == 46) {
#line 273
          if ((int )d->d_name[2] == 0) {
#line 276
            goto __Cont;
          }
        }
      }
#line 278
      if (use_d_ino) {
#line 280
        if (d->d_ino == thisino) {
#line 280
          tmp___11 = 1;
        } else
#line 280
        if (mount_point) {
#line 280
          tmp___11 = 1;
        } else {
#line 280
          tmp___11 = 0;
        }
#line 280
        match = (_Bool )tmp___11;
#line 281
        if (! match) {
#line 282
          goto __Cont;
        }
      }
      {
#line 288
      entry_status = fstatat(fd, (char const   */* __restrict  */)(d->d_name), (struct stat */* __restrict  */)(& st),
                             256);
      }
#line 332
      if (entry_status == 0) {
#line 332
        if ((st.st_mode & 61440U) == 16384U) {
#line 332
          if (st.st_dev == thisdev) {
#line 332
            if (st.st_ino == thisino) {
#line 334
              goto while_break___0;
            }
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 338
    dirroom = (size_t )(dirp - dir);
#line 339
    namlen = strlen((char const   *)(d->d_name));
    }
#line 341
    if (dirroom <= namlen) {
#line 343
      if (size != 0UL) {
        {
#line 345
        tmp___12 = __errno_location();
#line 345
        *tmp___12 = 34;
        }
#line 346
        goto lose;
      } else {
#line 351
        oldsize = allocated;
#line 353
        if (allocated < namlen) {
#line 353
          tmp___14 = namlen;
        } else {
#line 353
          tmp___14 = allocated;
        }
#line 353
        allocated += tmp___14;
#line 354
        if (allocated < oldsize) {
#line 356
          goto memory_exhausted;
        } else {
          {
#line 354
          tmp___15 = realloc((void *)dir, allocated);
#line 354
          tmp___13 = (char *)tmp___15;
          }
#line 354
          if (! tmp___13) {
#line 356
            goto memory_exhausted;
          }
        }
        {
#line 360
        tmp___16 = (void *)memcpy((void */* __restrict  */)((tmp___13 + allocated) - (oldsize - dirroom)),
                                  (void const   */* __restrict  */)(tmp___13 + dirroom),
                                  oldsize - dirroom);
#line 360
        dirp = (char *)tmp___16;
#line 363
        dir = tmp___13;
        }
      }
    }
    {
#line 366
    dirp -= namlen;
#line 367
    memcpy((void */* __restrict  */)dirp, (void const   */* __restrict  */)(d->d_name),
           namlen);
#line 368
    dirp --;
#line 368
    *dirp = (char )'/';
#line 370
    thisdev = dotdev;
#line 371
    thisino = dotino;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  if (dirstream) {
    {
#line 374
    tmp___17 = closedir(dirstream);
    }
#line 374
    if (tmp___17 != 0) {
#line 376
      dirstream = (DIR *)((void *)0);
#line 377
      goto lose;
    }
  }
#line 380
  if ((unsigned long )dirp == (unsigned long )(dir + (allocated - 1UL))) {
#line 381
    dirp --;
#line 381
    *dirp = (char )'/';
  }
  {
#line 388
  used = (size_t )((dir + allocated) - dirp);
#line 389
  memmove((void *)dir, (void const   *)dirp, used);
  }
#line 391
  if (size == 0UL) {
    {
#line 393
    tmp___18 = realloc((void *)dir, used);
#line 393
    buf = (char *)tmp___18;
    }
  }
#line 395
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 398
    buf = dir;
  }
#line 400
  return (buf);
  memory_exhausted: 
  {
#line 403
  tmp___19 = __errno_location();
#line 403
  *tmp___19 = 12;
  }
  lose: 
  {
#line 406
  tmp___20 = __errno_location();
#line 406
  save = *tmp___20;
  }
#line 407
  if (dirstream) {
    {
#line 408
    closedir(dirstream);
    }
  }
#line 410
  if (fd_needs_closing) {
    {
#line 411
    close(fd);
    }
  }
#line 416
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 417
    free((void *)dir);
    }
  }
  {
#line 418
  tmp___21 = __errno_location();
#line 418
  *tmp___21 = save;
  }
#line 420
  return ((char *)((void *)0));
}
}
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/full-write.h"
size_t full_write(int fd , void const   *buf , size_t count ) ;
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/full-write.c"
size_t full_write(int fd , void const   *buf , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 62
  total = (size_t )0;
#line 63
  ptr = (char const   *)buf;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (count > 0UL)) {
#line 65
      goto while_break;
    }
    {
#line 67
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 67
    n_rw = tmp;
    }
#line 68
    if (n_rw == 0xffffffffffffffffUL) {
#line 69
      goto while_break;
    }
#line 70
    if (n_rw == 0UL) {
      {
#line 72
      tmp___0 = __errno_location();
#line 72
      *tmp___0 = 28;
      }
#line 73
      goto while_break;
    }
#line 75
    total += n_rw;
#line 76
    ptr += n_rw;
#line 77
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (total);
}
}
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 41
  if (0 <= fd) {
#line 41
    if (fd <= 2) {
      {
#line 43
      tmp = dup_safer(fd);
#line 43
      f = tmp;
#line 44
      tmp___0 = __errno_location();
#line 44
      e = *tmp___0;
#line 45
      close(fd);
#line 46
      tmp___1 = __errno_location();
#line 46
      *tmp___1 = e;
#line 47
      fd = f;
      }
    }
  }
#line 50
  return (fd);
}
}
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 286 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 217 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 167 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg___0 ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 171
  result = -1;
#line 172
  __builtin_va_start(arg___0, action);
  }
  {
#line 202
  if (action == 1030) {
#line 202
    goto case_1030;
  }
#line 283
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 204
  tmp___0 = __builtin_va_arg(arg___0, int );
#line 204
  target = tmp___0;
  }
#line 218
  if (0 <= have_dupfd_cloexec) {
    {
#line 220
    result = fcntl(fd, action, target);
    }
#line 221
    if (0 <= result) {
#line 223
      have_dupfd_cloexec = 1;
    } else {
      {
#line 221
      tmp___1 = __errno_location();
      }
#line 221
      if (*tmp___1 != 22) {
#line 223
        have_dupfd_cloexec = 1;
      } else {
        {
#line 231
        result = rpl_fcntl(fd, 0, target);
        }
#line 232
        if (result < 0) {
#line 233
          goto switch_break;
        }
#line 234
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 238
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 239
  if (0 <= result) {
#line 239
    if (have_dupfd_cloexec == -1) {
      {
#line 241
      tmp___2 = fcntl(result, 1);
#line 241
      flags = tmp___2;
      }
#line 242
      if (flags < 0) {
#line 242
        goto _L;
      } else {
        {
#line 242
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 242
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 244
          tmp___3 = __errno_location();
#line 244
          saved_errno = *tmp___3;
#line 245
          close(result);
#line 246
          tmp___4 = __errno_location();
#line 246
          *tmp___4 = saved_errno;
#line 247
          result = -1;
          }
        }
      }
    }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 286
  tmp___7 = __builtin_va_arg(arg___0, void *);
#line 286
  p = tmp___7;
#line 287
  result = fcntl(fd, action, p);
  }
#line 291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 294
  __builtin_va_end(arg___0);
  }
#line 295
  return (result);
}
}
#line 27 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 35
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 35
  return (tmp);
}
}
#line 66 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname.h"
char *dir_name(char const   *file ) ;
#line 69
char *mdir_name(char const   *file ) ;
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 36
  tmp = mdir_name(file);
#line 36
  result = tmp;
  }
#line 37
  if (! result) {
    {
#line 38
    xalloc_die();
    }
  }
#line 39
  return (result);
}
}
#line 71 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname.h"
size_t dir_len(char const   *file ) ;
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 36
  prefix_length = (size_t )0;
#line 40
  if (prefix_length != 0UL) {
#line 40
    tmp___0 = 0;
  } else {
#line 40
    if ((int const   )*(file + 0) == 47) {
#line 40
      tmp = 1;
    } else {
#line 40
      tmp = 0;
    }
#line 40
    tmp___0 = tmp;
  }
  {
#line 40
  prefix_length += (size_t )tmp___0;
#line 50
  tmp___1 = last_component(file);
#line 50
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (prefix_length < length)) {
#line 50
      goto while_break;
    }
#line 52
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 53
      goto while_break;
    }
#line 50
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (length);
}
}
#line 72 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 75
  tmp = dir_len(file);
#line 75
  length = tmp;
  }
#line 76
  if (length == 0UL) {
#line 76
    tmp___0 = 1;
  } else {
#line 76
    tmp___0 = 0;
  }
  {
#line 76
  append_dot = (_Bool )tmp___0;
#line 80
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 80
  dir = (char *)tmp___1;
  }
#line 81
  if (! dir) {
#line 82
    return ((char *)((void *)0));
  }
  {
#line 83
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 84
  if (append_dot) {
#line 85
    tmp___2 = length;
#line 85
    length ++;
#line 85
    *(dir + tmp___2) = (char )'.';
  }
#line 86
  *(dir + length) = (char )'\000';
#line 87
  return (dir);
}
}
#line 30 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 31
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 32
void close_stdout(void) ;
#line 598 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 4 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/close-stream.h"
int close_stream(FILE *stream ) ;
#line 38 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.c"
static char const   *file_name  ;
#line 42 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 45
  file_name = file;
#line 46
  return;
}
}
#line 48 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.c"
static _Bool ignore_EPIPE  ;
#line 79 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 82
  ignore_EPIPE = ignore;
#line 83
  return;
}
}
#line 108 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error___0 ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 111
  tmp___3 = close_stream(stdout);
  }
#line 111
  if (tmp___3 != 0) {
#line 111
    if (ignore_EPIPE) {
      {
#line 111
      tmp___4 = __errno_location();
      }
#line 111
      if (! (*tmp___4 == 32)) {
#line 111
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 114
      tmp = gettext("write error");
#line 114
      write_error___0 = (char const   *)tmp;
      }
#line 115
      if (file_name) {
        {
#line 116
        tmp___0 = quotearg_colon(file_name);
#line 116
        tmp___1 = __errno_location();
#line 116
        error(0, *tmp___1, "%s: %s", tmp___0, write_error___0);
        }
      } else {
        {
#line 119
        tmp___2 = __errno_location();
#line 119
        error(0, *tmp___2, "%s", write_error___0);
        }
      }
      {
#line 121
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 124
  tmp___5 = close_stream(stderr);
  }
#line 124
  if (tmp___5 != 0) {
    {
#line 125
    _exit((int )exit_failure);
    }
  }
#line 126
  return;
}
}
#line 810 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 76 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t __fpending(FILE *__fp ) ;
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 60
  tmp = __fpending(stream);
#line 60
  some_pending = (_Bool )(tmp != 0UL);
#line 61
  tmp___0 = (int )ferror_unlocked(stream);
#line 61
  prev_fail = (_Bool )(tmp___0 != 0);
#line 62
  tmp___1 = fclose(stream);
#line 62
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 72
  if (prev_fail) {
#line 72
    goto _L___0;
  } else
#line 72
  if (fclose_fail) {
#line 72
    if (some_pending) {
#line 72
      goto _L___0;
    } else {
      {
#line 72
      tmp___3 = __errno_location();
      }
#line 72
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 74
        if (! fclose_fail) {
          {
#line 75
          tmp___2 = __errno_location();
#line 75
          *tmp___2 = 0;
          }
        }
#line 76
        return (-1);
      }
    }
  }
#line 79
  return (0);
}
}
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 119 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memrchr)(void const   *__s ,
                                                                                      int __c ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 286
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 47 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 50
  cdb->fd = -100;
#line 51
  return;
}
}
#line 53 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = fchdir((int )cdb->fd);
  }
#line 56
  return (tmp);
}
}
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 62
  if (0 <= (int )cdb->fd) {
    {
#line 64
    tmp = close((int )cdb->fd);
#line 64
    close_fail = (_Bool )tmp;
    }
#line 65
    if (! (! close_fail)) {
      {
#line 65
      __assert_fail("! close_fail", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                    65U, "cdb_free");
      }
    }
  }
#line 67
  return;
}
}
#line 73 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 76
  tmp = openat(cdb->fd, dir, 67840);
#line 76
  new_fd = tmp;
  }
#line 78
  if (new_fd < 0) {
#line 79
    return (-1);
  }
  {
#line 81
  cdb_free((struct cd_buf  const  *)cdb);
#line 82
  cdb->fd = new_fd;
  }
#line 84
  return (0);
}
}
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
__inline static char *find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 91
  tmp = strspn(s, "/");
#line 91
  n_slash = tmp;
  }
#line 92
  return ((char *)s + n_slash);
}
}
#line 110 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 113
  tmp = chdir((char const   *)dir);
#line 113
  e = tmp;
  }
#line 114
  if (e == 0) {
#line 115
    return (e);
  } else {
    {
#line 114
    tmp___0 = __errno_location();
    }
#line 114
    if (*tmp___0 != 36) {
#line 115
      return (e);
    }
  }
  {
#line 118
  tmp___1 = strlen((char const   *)dir);
#line 118
  len = tmp___1;
#line 119
  dir_end = dir + len;
#line 123
  cdb_init(& cdb);
  }
#line 127
  if (! (0UL < len)) {
    {
#line 127
    __assert_fail("0 < len", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                  127U, "chdir_long");
    }
  }
#line 128
  if (! (4096UL <= len)) {
    {
#line 128
    __assert_fail("4096 <= len", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                  128U, "chdir_long");
    }
  }
  {
#line 131
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 138
  if (n_leading_slash == 2UL) {
    {
#line 143
    tmp___2 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 143
    slash = (char *)tmp___2;
    }
#line 144
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 146
      tmp___3 = __errno_location();
#line 146
      *tmp___3 = 36;
      }
#line 147
      return (-1);
    }
    {
#line 149
    *slash = (char )'\000';
#line 150
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 151
    *slash = (char )'/';
    }
#line 152
    if (err != 0) {
#line 153
      goto Fail;
    }
    {
#line 154
    dir = find_non_slash((char const   *)(slash + 1));
    }
  } else
#line 156
  if (n_leading_slash) {
    {
#line 158
    tmp___4 = cdb_advance_fd(& cdb, "/");
    }
#line 158
    if (tmp___4 != 0) {
#line 159
      goto Fail;
    }
#line 160
    dir += n_leading_slash;
  }
#line 163
  if (! ((int )*dir != 47)) {
    {
#line 163
    __assert_fail("*dir != \'/\'", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                  163U, "chdir_long");
    }
  }
#line 164
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 164
    __assert_fail("dir <= dir_end", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                  164U, "chdir_long");
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (4096L <= dir_end - dir)) {
#line 166
      goto while_break;
    }
    {
#line 172
    tmp___5 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 172
    slash___0 = (char *)tmp___5;
    }
#line 173
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 175
      tmp___6 = __errno_location();
#line 175
      *tmp___6 = 36;
      }
#line 176
      return (-1);
    }
#line 179
    *slash___0 = (char )'\000';
#line 180
    if (! (slash___0 - dir < 4096L)) {
      {
#line 180
      __assert_fail("slash - dir < 4096", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/chdir-long.c",
                    180U, "chdir_long");
      }
    }
    {
#line 181
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 182
    *slash___0 = (char )'/';
    }
#line 183
    if (err___0 != 0) {
#line 184
      goto Fail;
    }
    {
#line 186
    dir = find_non_slash((char const   *)(slash___0 + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 191
    tmp___7 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 191
    if (tmp___7 != 0) {
#line 192
      goto Fail;
    }
  }
  {
#line 195
  tmp___8 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 195
  if (tmp___8 != 0) {
#line 196
    goto Fail;
  }
  {
#line 198
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 199
  return (0);
  Fail: 
  {
#line 203
  tmp___9 = __errno_location();
#line 203
  saved_errno = *tmp___9;
#line 204
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 205
  tmp___10 = __errno_location();
#line 205
  *tmp___10 = saved_errno;
  }
#line 206
  return (-1);
}
}
#line 123 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 138
int c_tolower(int c ) ;
#line 29 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 65 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/dirname.h"
char *base_name(char const   *name ) ;
#line 29 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 32
  tmp = last_component(name);
#line 32
  base = (char const   *)tmp;
  }
#line 37
  if (! *base) {
    {
#line 38
    tmp___0 = base_len(name);
#line 38
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 38
    return (tmp___1);
  }
  {
#line 41
  length = base_len(base);
  }
#line 42
  if ((int const   )*(base + length) == 47) {
#line 43
    length ++;
  }
  {
#line 59
  tmp___3 = xstrndup(base, length);
  }
#line 59
  return (tmp___3);
}
}
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 34
  base = name + 0;
#line 36
  saw_slash = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((int const   )*base == 47)) {
#line 38
      goto while_break;
    }
#line 39
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  p = base;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! *p) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int const   )*p == 47) {
#line 44
      saw_slash = (_Bool)1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base = p;
#line 48
      saw_slash = (_Bool)0;
    }
#line 41
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  return ((char *)base);
}
}
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 63
  prefix_len = (size_t )0;
#line 65
  len = strlen(name);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (1UL < len) {
#line 65
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 65
        goto while_break;
      }
    } else {
#line 65
      goto while_break;
    }
#line 66
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 65
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (len);
}
}
#line 73 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 27 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
  }
#line 36
  return (result);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 417 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 418
extern int __overflow(_IO_FILE * , int  ) ;
#line 460
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 461
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 348
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap ) ;
#line 354
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vprintf)(char const   * __restrict  __fmt , __gnuc_va_list __ap ) ;
#line 520
__inline extern int __attribute__((__gnu_inline__))  getchar(void) ;
#line 533
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) ;
#line 543
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) ;
#line 562
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) ;
#line 576
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) ;
#line 584
__inline extern int __attribute__((__gnu_inline__))  putc_unlocked(int __c , FILE *__stream ) ;
#line 585
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) ;
#line 638
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 651
__inline extern __ssize_t __attribute__((__gnu_inline__))  getline(char ** __restrict  __lineptr ,
                                                                   size_t * __restrict  __n ,
                                                                   FILE * __restrict  __stream ) ;
#line 809
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 36 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vprintf)(char const   * __restrict  __fmt , __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = (int )vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 39
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 44 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar(void) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = _IO_getc(stdin);
  }
#line 47
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 53 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 56
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 56
  if (tmp___3) {
    {
#line 56
    tmp___0 = __uflow(__fp);
#line 56
    tmp___2 = tmp___0;
    }
  } else {
#line 56
    tmp___1 = __fp->_IO_read_ptr;
#line 56
    (__fp->_IO_read_ptr) ++;
#line 56
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 56
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 63 "/usr/include/bits/stdio.h"
extern int __attribute__((__gnu_inline__))  getc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 66
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 66
  if (tmp___3) {
    {
#line 66
    tmp___0 = __uflow(__fp);
#line 66
    tmp___2 = tmp___0;
    }
  } else {
#line 66
    tmp___1 = __fp->_IO_read_ptr;
#line 66
    (__fp->_IO_read_ptr) ++;
#line 66
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 66
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 70 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 73
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 73
  if (tmp___3) {
    {
#line 73
    tmp___0 = __uflow(stdin);
#line 73
    tmp___2 = tmp___0;
    }
  } else {
#line 73
    tmp___1 = stdin->_IO_read_ptr;
#line 73
    (stdin->_IO_read_ptr) ++;
#line 73
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 73
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 79 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = _IO_putc(__c, stdout);
  }
#line 82
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 88 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 91
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 91
  if (tmp___4) {
    {
#line 91
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 91
    tmp___3 = tmp___0;
    }
  } else {
#line 91
    tmp___1 = __stream->_IO_write_ptr;
#line 91
    (__stream->_IO_write_ptr) ++;
#line 91
    tmp___2 = (char )__c;
#line 91
    *tmp___1 = tmp___2;
#line 91
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 91
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 105 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 108
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 108
  if (tmp___4) {
    {
#line 108
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 108
    tmp___3 = tmp___0;
    }
  } else {
#line 108
    tmp___1 = stdout->_IO_write_ptr;
#line 108
    (stdout->_IO_write_ptr) ++;
#line 108
    tmp___2 = (char )__c;
#line 108
    *tmp___1 = tmp___2;
#line 108
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 108
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 115 "/usr/include/bits/stdio.h"
__inline extern __ssize_t __attribute__((__gnu_inline__))  getline(char ** __restrict  __lineptr ,
                                                                   size_t * __restrict  __n ,
                                                                   FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 118
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 118
  return ((__ssize_t __attribute__((__gnu_inline__))  )tmp);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 125 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) 
{ 


  {
#line 128
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 16) != 0));
}
}
#line 132
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 132 "/usr/include/bits/stdio.h"
extern int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 135
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 32) != 0));
}
}
#line 31 "/usr/include/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(unsigned long long __dev ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(unsigned long long __dev ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) unsigned long long __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                                                                  unsigned int __minor ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(unsigned long long __dev ) ;
#line 42 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(unsigned long long __dev ) 
{ 


  {
#line 45
  return ((unsigned int __attribute__((__gnu_inline__))  )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 48
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(unsigned long long __dev ) ;
#line 48 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(unsigned long long __dev ) 
{ 


  {
#line 51
  return ((unsigned int __attribute__((__gnu_inline__))  )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) unsigned long long __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                                                                  unsigned int __minor ) ;
#line 54 "/usr/include/sys/sysmacros.h"
__inline extern unsigned long long __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                                    unsigned int __minor ) 
{ 


  {
#line 57
  return ((unsigned long long __attribute__((__gnu_inline__))  )(((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32)));
}
}
#line 83 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  tolower(int __c ) ;
#line 119
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  toupper(int __c ) ;
#line 190
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline extern int __attribute__((__gnu_inline__))  tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
#line 193
      tmp = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 193
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 193
    tmp___0 = (__int32_t const   )__c;
  }
#line 193
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 196
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline extern int __attribute__((__gnu_inline__))  toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
#line 199
      tmp = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 199
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 199
    tmp___0 = (__int32_t const   )__c;
  }
#line 199
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 517 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) ;
#line 611 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
void argp_usage(struct argp_state  const  *__state ) 
{ 


  {
  {
#line 614
  argp_state_help((struct argp_state  const  */* __restrict  */)__state, (FILE */* __restrict  */)stderr,
                  262U);
  }
#line 615
  return;
}
}
#line 617
 __attribute__((__nothrow__)) int _option_is_short(struct argp_option  const  *__opt ) ;
#line 617 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
int _option_is_short(struct argp_option  const  *__opt ) 
{ 
  int __key ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 620
  if (__opt->flags & 8) {
#line 621
    return (0);
  } else {
#line 624
    __key = (int )__opt->key;
#line 625
    if (__key > 0) {
#line 625
      if (__key <= 255) {
        {
#line 625
        tmp = __ctype_b_loc();
        }
#line 625
        if ((int const   )*(*tmp + __key) & 16384) {
#line 625
          tmp___0 = 1;
        } else {
#line 625
          tmp___0 = 0;
        }
      } else {
#line 625
        tmp___0 = 0;
      }
    } else {
#line 625
      tmp___0 = 0;
    }
#line 625
    return (tmp___0);
  }
}
}
#line 629
 __attribute__((__nothrow__)) int _option_is_end(struct argp_option  const  *__opt ) ;
#line 629 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
int _option_is_end(struct argp_option  const  *__opt ) 
{ 
  int tmp ;

  {
#line 632
  if (! __opt->key) {
#line 632
    if (! __opt->name) {
#line 632
      if (! __opt->doc) {
#line 632
        if (! __opt->group) {
#line 632
          tmp = 1;
        } else {
#line 632
          tmp = 0;
        }
      } else {
#line 632
        tmp = 0;
      }
    } else {
#line 632
      tmp = 0;
    }
  } else {
#line 632
    tmp = 0;
  }
#line 632
  return (tmp);
}
}
#line 453 "./argp.h"
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ) ;
#line 36 "./argp-version-etc.h"
void argp_version_setup(char const   *name , char const   * const  *authors ) ;
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-version-etc.c"
static char const   *program_canonical_name  ;
#line 25 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-version-etc.c"
static char const   * const  *program_authors___0  ;
#line 27 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-version-etc.c"
static void version_etc_hook(FILE *stream , struct argp_state *state ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 30
  version_etc_ar(stream, program_canonical_name, "GNU cpio", "2.11", program_authors___0);
  }
#line 32
  return;
}
}
#line 34 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-version-etc.c"
void argp_version_setup(char const   *name , char const   * const  *authors ) 
{ 


  {
#line 37
  argp_program_version_hook = (void (*)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ))(& version_etc_hook);
#line 38
  program_canonical_name = name;
#line 39
  program_authors___0 = authors;
#line 40
  return;
}
}
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-pvh.c"
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state )  =    (void (*)(FILE * __restrict  stream ,
             struct argp_state * __restrict  state ))((void *)0);
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-pv.c"
char const   *argp_program_version  ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 417 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) ;
#line 533
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) ;
#line 570
 __attribute__((__nothrow__)) void *_argp_input(struct argp  const  * __restrict  argp___0 ,
                                                struct argp_state  const  * __restrict  state ) ;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static int volatile   _argp_hang  ;
#line 81 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static struct argp_option  const  argp_default_options[5]  = {      {"help", '?', (char const   *)0, 0, "give this help list", -1}, 
        {"usage", -3, (char const   *)0, 0, "give a short usage message", 0}, 
        {"program-name", -2, "NAME", 2, "set the program name", 0}, 
        {"HANG", -4, "SECS", 3, "hang for SECS seconds (default 3600)", 0}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 91 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t argp_default_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int volatile   tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 96
  if (key == 63) {
#line 96
    goto case_63;
  }
#line 99
  if (key == -3) {
#line 99
    goto case_neg_3;
  }
#line 104
  if (key == -2) {
#line 104
    goto case_neg_2;
  }
#line 126
  if (key == -4) {
#line 126
    goto case_neg_4;
  }
#line 132
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 97
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  634U);
  }
#line 98
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 100
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  513U);
  }
#line 102
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 106
  program_invocation_name = arg___0;
#line 113
  state->name = last_component((char const   *)arg___0);
#line 116
  program_invocation_short_name = state->name;
  }
#line 119
  if ((state->flags & 3U) == 1U) {
#line 122
    *(state->argv + 0) = arg___0;
  }
#line 124
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 127
  if (arg___0) {
#line 127
    tmp = (char const   *)arg___0;
  } else {
#line 127
    tmp = "3600";
  }
  {
#line 127
  tmp___0 = atoi(tmp);
#line 127
  _argp_hang = (int volatile   )tmp___0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    tmp___1 = _argp_hang;
#line 128
    _argp_hang -= (int volatile   )1;
#line 128
    if (! (tmp___1 > (int volatile   )0)) {
#line 128
      goto while_break;
    }
    {
#line 129
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 133
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 138 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static struct argp  const  argp_default_argp  =    {argp_default_options, & argp_default_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 142 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static struct argp_option  const  argp_version_options[2]  = {      {"version", 'V', (char const   *)0, 0, "print program version", -1}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 148 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t argp_version_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 153
  if (key == 86) {
#line 153
    goto case_86;
  }
#line 164
  goto switch_default;
  case_86: /* CIL Label */ 
#line 154
  if (argp_program_version_hook) {
    {
#line 155
    (*argp_program_version_hook)((FILE */* __restrict  */)state->out_stream, (struct argp_state */* __restrict  */)state);
    }
  } else
#line 156
  if (argp_program_version) {
    {
#line 157
    fprintf((FILE */* __restrict  */)state->out_stream, (char const   */* __restrict  */)"%s\n",
            argp_program_version);
    }
  } else {
    {
#line 159
    tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "(PROGRAM ERROR) No version known!?");
#line 159
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp);
    }
  }
#line 161
  if (! (state->flags & 32U)) {
    {
#line 162
    exit(0);
    }
  }
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 165
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 170 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static struct argp  const  argp_version_argp  =    {argp_version_options, & argp_version_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 176 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static int find_long_option(struct rpl_option *long_options , char const   *name ) 
{ 
  struct rpl_option *l ;
  int tmp ;

  {
#line 179
  l = long_options;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )l->name != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
#line 181
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      {
#line 181
      tmp = strcmp(l->name, name);
      }
#line 181
      if (tmp == 0) {
#line 182
        return ((int )(l - long_options));
      } else {
#line 184
        l ++;
      }
    } else {
#line 184
      l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 186
    return ((int )(l - long_options));
  } else {
#line 188
    return (-1);
  }
}
}
#line 224 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t group_parse(struct group *group , struct argp_state *state , int key ,
                           char *arg___0 ) 
{ 
  error_t err ;

  {
#line 227
  if (group->parser) {
    {
#line 230
    state->hook = group->hook;
#line 231
    state->input = group->input;
#line 232
    state->child_inputs = group->child_inputs;
#line 233
    state->arg_num = group->args_processed;
#line 234
    err = (*(group->parser))(key, arg___0, state);
#line 235
    group->hook = state->hook;
    }
#line 236
    return (err);
  } else {
#line 239
    return (7);
  }
}
}
#line 289 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static struct group *convert_options(struct argp  const  *argp___0 , struct group *parent ,
                                     unsigned int parent_index , struct group *group ,
                                     struct parser_convert_state *cvt ) 
{ 
  struct argp_option  const  *real ;
  struct argp_child  const  *children ;
  struct argp_option  const  *opt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int num_children ;
  struct group *tmp___7 ;
  unsigned int index___0 ;
  unsigned int tmp___8 ;
  struct argp_child  const  *tmp___9 ;

  {
#line 295
  real = (struct argp_option  const  *)argp___0->options;
#line 296
  children = (struct argp_child  const  *)argp___0->children;
#line 298
  if (real) {
#line 298
    goto _L;
  } else
#line 298
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 302
    if (real) {
#line 303
      opt = real;
      {
#line 303
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 303
        tmp___6 = _option_is_end(opt);
        }
#line 303
        if (tmp___6) {
#line 303
          goto while_break;
        }
#line 305
        if (! (opt->flags & 4)) {
#line 307
          real = opt;
        }
#line 309
        if (! (real->flags & 8)) {
          {
#line 312
          tmp___2 = _option_is_short(opt);
          }
#line 312
          if (tmp___2) {
#line 315
            tmp = cvt->short_end;
#line 315
            (cvt->short_end) ++;
#line 315
            *tmp = (char )opt->key;
#line 316
            if (real->arg) {
#line 318
              tmp___0 = cvt->short_end;
#line 318
              (cvt->short_end) ++;
#line 318
              *tmp___0 = (char )':';
#line 319
              if (real->flags & 1) {
#line 320
                tmp___1 = cvt->short_end;
#line 320
                (cvt->short_end) ++;
#line 320
                *tmp___1 = (char )':';
              }
            }
#line 322
            *(cvt->short_end) = (char )'\000';
          }
#line 325
          if (opt->name) {
            {
#line 325
            tmp___5 = find_long_option((cvt->parser)->long_opts, (char const   *)opt->name);
            }
#line 325
            if (tmp___5 < 0) {
#line 329
              (cvt->long_end)->name = (char const   *)opt->name;
#line 330
              if (real->arg) {
#line 330
                if (real->flags & 1) {
#line 330
                  tmp___3 = 2;
                } else {
#line 330
                  tmp___3 = 1;
                }
#line 330
                (cvt->long_end)->has_arg = tmp___3;
              } else {
#line 330
                (cvt->long_end)->has_arg = 0;
              }
#line 336
              (cvt->long_end)->flag = (int *)0;
#line 343
              if (opt->key) {
#line 343
                tmp___4 = opt->key;
              } else {
#line 343
                tmp___4 = real->key;
              }
#line 343
              (cvt->long_end)->val = (int )((long )(tmp___4 & (int const   )((1 << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)) - 1)) + (((group - (cvt->parser)->groups) + 1L) << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)));
#line 348
              (cvt->long_end) ++;
#line 348
              (cvt->long_end)->name = (char const   *)((void *)0);
            }
          }
        }
#line 303
        opt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 353
    group->parser = (error_t (*)(int key , char *arg , struct argp_state *state ))argp___0->parser;
#line 354
    group->argp = argp___0;
#line 355
    group->short_end = cvt->short_end;
#line 356
    group->args_processed = 0U;
#line 357
    group->parent = parent;
#line 358
    group->parent_index = parent_index;
#line 359
    group->input = (void *)0;
#line 360
    group->hook = (void *)0;
#line 361
    group->child_inputs = (void **)0;
#line 363
    if (children) {
#line 367
      num_children = 0U;
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        if (! (children + num_children)->argp) {
#line 368
          goto while_break___0;
        }
#line 369
        num_children ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 370
      group->child_inputs = cvt->child_inputs_end;
#line 371
      cvt->child_inputs_end += num_children;
    }
#line 374
    tmp___7 = group;
#line 374
    group ++;
#line 374
    parent = tmp___7;
  } else {
#line 377
    parent = (struct group *)0;
  }
#line 379
  if (children) {
#line 381
    index___0 = 0U;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      if (! children->argp) {
#line 382
        goto while_break___1;
      }
      {
#line 383
      tmp___8 = index___0;
#line 383
      index___0 ++;
#line 383
      tmp___9 = children;
#line 383
      children ++;
#line 383
      group = convert_options((struct argp  const  *)tmp___9->argp, parent, tmp___8,
                              group, cvt);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 387
  return (group);
}
}
#line 391 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static void parser_convert(struct parser *parser , struct argp  const  *argp___0 ,
                           int flags ) 
{ 
  struct parser_convert_state cvt ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;

  {
#line 396
  cvt.parser = parser;
#line 397
  cvt.short_end = parser->short_opts;
#line 398
  cvt.long_end = parser->long_opts;
#line 399
  cvt.child_inputs_end = parser->child_inputs;
#line 401
  if (flags & 8) {
#line 402
    tmp = cvt.short_end;
#line 402
    (cvt.short_end) ++;
#line 402
    *tmp = (char )'-';
  } else
#line 403
  if (flags & 4) {
#line 404
    tmp___0 = cvt.short_end;
#line 404
    (cvt.short_end) ++;
#line 404
    *tmp___0 = (char )'+';
  }
#line 405
  *(cvt.short_end) = (char )'\000';
#line 407
  (cvt.long_end)->name = (char const   *)((void *)0);
#line 409
  parser->argp = argp___0;
#line 411
  if (argp___0) {
    {
#line 412
    parser->egroup = convert_options(argp___0, (struct group *)0, 0U, parser->groups,
                                     & cvt);
    }
  } else {
#line 414
    parser->egroup = parser->groups;
  }
#line 415
  return;
}
}
#line 430 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static void calc_sizes(struct argp  const  *argp___0 , struct parser_sizes *szs ) 
{ 
  struct argp_child  const  *child ;
  struct argp_option  const  *opt ;
  int num_opts ;
  struct argp_option  const  *tmp ;
  int tmp___0 ;
  struct argp_child  const  *tmp___1 ;

  {
#line 433
  child = (struct argp_child  const  *)argp___0->children;
#line 434
  opt = (struct argp_option  const  *)argp___0->options;
#line 436
  if (opt) {
#line 436
    goto _L;
  } else
#line 436
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 438
    (szs->num_groups) ++;
#line 439
    if (opt) {
#line 441
      num_opts = 0;
      {
#line 442
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 442
        tmp = opt;
#line 442
        opt ++;
#line 442
        tmp___0 = _option_is_end(tmp);
        }
#line 442
        if (tmp___0) {
#line 442
          goto while_break;
        }
#line 443
        num_opts ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 444
      szs->short_len += (size_t )(num_opts * 3);
#line 445
      szs->long_len += (size_t )num_opts;
    }
  }
#line 449
  if (child) {
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if (! child->argp) {
#line 450
        goto while_break___0;
      }
      {
#line 452
      tmp___1 = child;
#line 452
      child ++;
#line 452
      calc_sizes((struct argp  const  *)tmp___1->argp, szs);
#line 453
      (szs->num_child_inputs) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 455
  return;
}
}
#line 458 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t parser_init(struct parser *parser , struct argp  const  *argp___0 ,
                           int argc , char **argv , int flags , void *input ) 
{ 
  error_t err ;
  struct group *group ;
  struct parser_sizes szs ;
  struct _getopt_data opt_data ;
  char *storage ;
  size_t glen ;
  size_t gsum ;
  size_t clen ;
  size_t csum ;
  size_t llen ;
  size_t lsum ;
  size_t slen ;
  size_t ssum ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 462
  err = 0;
#line 465
  opt_data.rpl_optind = 1;
#line 465
  opt_data.rpl_opterr = 1;
#line 465
  opt_data.rpl_optopt = 0;
#line 465
  opt_data.rpl_optarg = (char *)0;
#line 465
  opt_data.__initialized = 0;
#line 465
  opt_data.__nextchar = (char *)0;
#line 465
  opt_data.__ordering = 0U;
#line 465
  opt_data.__posixly_correct = 0;
#line 465
  opt_data.__first_nonopt = 0;
#line 465
  opt_data.__last_nonopt = 0;
#line 472
  if (flags & 4) {
#line 472
    szs.short_len = (size_t )0;
  } else {
#line 472
    szs.short_len = (size_t )1;
  }
#line 473
  szs.long_len = (size_t )0;
#line 474
  szs.num_groups = (size_t )0;
#line 475
  szs.num_child_inputs = (size_t )0;
#line 477
  if (argp___0) {
    {
#line 478
    calc_sizes(argp___0, & szs);
    }
  }
  {
#line 481
  glen = (szs.num_groups + 1UL) * sizeof(struct group );
#line 482
  clen = szs.num_child_inputs * sizeof(void *);
#line 483
  llen = (szs.long_len + 1UL) * sizeof(struct rpl_option );
#line 484
  slen = szs.short_len + 1UL;
#line 491
  gsum = glen;
#line 492
  csum = ((((gsum + clen) + (unsigned long )(& ((struct __anonstruct_32 *)0)->x)) - 1UL) / (unsigned long )(& ((struct __anonstruct_34 *)0)->x)) * (unsigned long )(& ((struct __anonstruct_36 *)0)->x);
#line 493
  lsum = csum + llen;
#line 494
  ssum = lsum + slen;
#line 496
  parser->storage = malloc(ssum);
  }
#line 497
  if (! parser->storage) {
#line 498
    return (12);
  }
  {
#line 500
  storage = (char *)parser->storage;
#line 501
  parser->groups = (struct group *)parser->storage;
#line 502
  parser->child_inputs = (void **)(storage + gsum);
#line 503
  parser->long_opts = (struct rpl_option *)(storage + csum);
#line 504
  parser->short_opts = storage + lsum;
#line 505
  parser->opt_data = opt_data;
#line 507
  memset((void *)parser->child_inputs, 0, clen);
#line 508
  parser_convert(parser, argp___0, flags);
#line 510
  memset((void *)(& parser->state), 0, sizeof(struct argp_state ));
#line 511
  parser->state.root_argp = parser->argp;
#line 512
  parser->state.argc = argc;
#line 513
  parser->state.argv = argv;
#line 514
  parser->state.flags = (unsigned int )flags;
#line 515
  parser->state.err_stream = stderr;
#line 516
  parser->state.out_stream = stdout;
#line 517
  parser->state.next = 0;
#line 518
  parser->state.pstate = (void *)parser;
#line 520
  parser->try_getopt = 1;
  }
#line 524
  if ((unsigned long )parser->groups < (unsigned long )parser->egroup) {
#line 525
    (parser->groups)->input = input;
  }
#line 526
  group = parser->groups;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 526
      if (! (! err)) {
#line 526
        if (! (err == 7)) {
#line 526
          goto while_break;
        }
      }
    } else {
#line 526
      goto while_break;
    }
#line 530
    if (group->parent) {
#line 532
      group->input = *((group->parent)->child_inputs + group->parent_index);
    }
#line 534
    if (! group->parser) {
#line 534
      if ((group->argp)->children) {
#line 534
        if (((group->argp)->children)->argp) {
#line 539
          *(group->child_inputs + 0) = group->input;
        }
      }
    }
    {
#line 541
    err = group_parse(group, & parser->state, 16777219, (char *)0);
#line 526
    group ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  if (err == 7) {
#line 544
    err = 0;
  }
#line 546
  if (err) {
#line 547
    return (err);
  }
#line 549
  if (parser->state.flags & 2U) {
#line 551
    parser->opt_data.rpl_opterr = 0;
#line 552
    if (parser->state.flags & 1U) {
#line 555
      (parser->state.argv) --;
#line 555
      (parser->state.argc) ++;
    }
  } else {
#line 558
    parser->opt_data.rpl_opterr = 1;
  }
#line 560
  if ((unsigned long )parser->state.argv == (unsigned long )argv) {
#line 560
    if (*(argv + 0)) {
      {
#line 562
      parser->state.name = last_component((char const   *)*(argv + 0));
      }
    } else {
#line 564
      parser->state.name = program_invocation_short_name;
    }
  } else {
#line 564
    parser->state.name = program_invocation_short_name;
  }
#line 566
  return (0);
}
}
#line 570 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t parser_finalize(struct parser *parser , error_t err , int arg_ebadkey ,
                               int *end_index ) 
{ 
  struct group *group ;
  char *tmp ;
  char *__cil_tmp7 ;

  {
#line 576
  if (err == 7) {
#line 576
    if (arg_ebadkey) {
#line 578
      err = 0;
    }
  }
#line 580
  if (! err) {
#line 582
    if (parser->state.next == parser->state.argc) {
#line 586
      group = parser->groups;
      {
#line 586
      while (1) {
        while_continue: /* CIL Label */ ;
#line 586
        if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 586
          if (! (! err)) {
#line 586
            if (! (err == 7)) {
#line 586
              goto while_break;
            }
          }
        } else {
#line 586
          goto while_break;
        }
#line 589
        if (group->args_processed == 0U) {
          {
#line 590
          err = group_parse(group, & parser->state, 16777218, (char *)0);
          }
        }
#line 586
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 591
      group = parser->egroup - 1;
      {
#line 591
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 591
        if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 591
          if (! (! err)) {
#line 591
            if (! (err == 7)) {
#line 591
              goto while_break___0;
            }
          }
        } else {
#line 591
          goto while_break___0;
        }
        {
#line 594
        err = group_parse(group, & parser->state, 16777217, (char *)0);
#line 591
        group --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 596
      if (err == 7) {
#line 597
        err = 0;
      }
#line 600
      if (end_index) {
#line 601
        *end_index = parser->state.next;
      }
    } else
#line 603
    if (end_index) {
#line 605
      *end_index = parser->state.next;
    } else {
#line 609
      if (! (parser->state.flags & 2U)) {
#line 609
        if (parser->state.err_stream) {
          {
#line 611
          tmp = dgettext((char const   *)(parser->argp)->argp_domain, "%s: Too many arguments\n");
#line 611
          fprintf((FILE */* __restrict  */)parser->state.err_stream, (char const   */* __restrict  */)tmp,
                  parser->state.name);
          }
        }
      }
#line 615
      err = 7;
    }
  }
#line 622
  if (err) {
#line 625
    if (err == 7) {
      {
#line 628
      argp_state_help((struct argp_state  const  */* __restrict  */)(& parser->state),
                      (FILE */* __restrict  */)parser->state.err_stream, 260U);
      }
    }
#line 632
    group = parser->groups;
    {
#line 632
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 632
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 632
        goto while_break___1;
      }
      {
#line 633
      group_parse(group, & parser->state, 16777221, (char *)0);
#line 632
      group ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 641
    group = parser->egroup - 1;
    {
#line 641
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 641
      if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 641
        if (! (! err)) {
#line 641
          if (! (err == 7)) {
#line 641
            goto while_break___2;
          }
        }
      } else {
#line 641
        goto while_break___2;
      }
      {
#line 644
      err = group_parse(group, & parser->state, 16777220, (char *)0);
#line 641
      group --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 645
    if (err == 7) {
#line 646
      err = 0;
    }
  }
#line 650
  group = parser->egroup - 1;
  {
#line 650
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 650
    if (! ((unsigned long )group >= (unsigned long )parser->groups)) {
#line 650
      goto while_break___3;
    }
    {
#line 651
    group_parse(group, & parser->state, 16777223, (char *)0);
#line 650
    group --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 653
  if (err == 7) {
#line 654
    err = 22;
  }
  {
#line 656
  free(parser->storage);
  }
#line 658
  return (err);
}
}
#line 666 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t parser_parse_arg(struct parser *parser , char *val ) 
{ 
  int index___0 ;
  error_t err ;
  struct group *group ;
  int key ;

  {
#line 671
  (parser->state.next) --;
#line 671
  index___0 = parser->state.next;
#line 672
  err = 7;
#line 674
  key = 0;
#line 677
  group = parser->groups;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 677
      if (! (err == 7)) {
#line 677
        goto while_break;
      }
    } else {
#line 677
      goto while_break;
    }
    {
#line 681
    (parser->state.next) ++;
#line 682
    key = 0;
#line 683
    err = group_parse(group, & parser->state, key, val);
    }
#line 685
    if (err == 7) {
      {
#line 688
      (parser->state.next) --;
#line 689
      key = 16777222;
#line 690
      err = group_parse(group, & parser->state, key, (char *)0);
      }
    }
#line 677
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  if (! err) {
#line 696
    if (key == 16777222) {
#line 700
      parser->state.next = parser->state.argc;
    }
#line 702
    if (parser->state.next > index___0) {
#line 706
      group --;
#line 706
      group->args_processed += (unsigned int )(parser->state.next - index___0);
    } else {
#line 709
      parser->try_getopt = 1;
    }
  }
#line 712
  return (err);
}
}
#line 755
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) ;
#line 755 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static char const   bad_key_err[53]  = 
#line 755
  {      (char const   )'(',      (char const   )'P',      (char const   )'R',      (char const   )'O', 
        (char const   )'G',      (char const   )'R',      (char const   )'A',      (char const   )'M', 
        (char const   )' ',      (char const   )'E',      (char const   )'R',      (char const   )'R', 
        (char const   )'O',      (char const   )'R',      (char const   )')',      (char const   )' ', 
        (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'h',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'g',      (char const   )'n',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'d',      (char const   )'!',      (char const   )'?', 
        (char const   )'\000'};
#line 717 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) 
{ 
  int group_key ;
  error_t err ;
  struct group *group ;
  char *short_index ;
  char *tmp ;
  char *tmp___0 ;
  struct rpl_option *long_opt ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 722
  group_key = opt >> (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL);
#line 723
  err = 7;
#line 725
  if (group_key == 0) {
    {
#line 731
    tmp = strchr((char const   *)parser->short_opts, opt);
#line 731
    short_index = tmp;
    }
#line 733
    if (short_index) {
#line 734
      group = parser->groups;
      {
#line 734
      while (1) {
        while_continue: /* CIL Label */ ;
#line 734
        if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 734
          goto while_break;
        }
#line 735
        if ((unsigned long )group->short_end > (unsigned long )short_index) {
          {
#line 737
          err = group_parse(group, & parser->state, opt, parser->opt_data.rpl_optarg);
          }
#line 739
          goto while_break;
        }
#line 734
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 745
    err = group_parse(parser->groups + (group_key - 1), & parser->state, (opt << 8) >> 8,
                      parser->opt_data.rpl_optarg);
    }
  }
#line 750
  if (err == 7) {
#line 757
    if (group_key == 0) {
      {
#line 758
      tmp___0 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
#line 758
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"-%c: %s", opt, tmp___0);
      }
    } else {
#line 762
      long_opt = parser->long_opts;
      {
#line 763
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 763
        if (long_opt->val != opt) {
#line 763
          if (! long_opt->name) {
#line 763
            goto while_break___0;
          }
        } else {
#line 763
          goto while_break___0;
        }
#line 764
        long_opt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 765
      tmp___1 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
      }
#line 765
      if (long_opt->name) {
#line 765
        tmp___2 = long_opt->name;
      } else {
#line 765
        tmp___2 = "???";
      }
      {
#line 765
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"--%s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 771
  return (err);
}
}
#line 778 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
static error_t parser_parse_next(struct parser *parser , int *arg_ebadkey ) 
{ 
  int opt ;
  error_t err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 782
  err = 0;
#line 784
  if (parser->state.quoted) {
#line 784
    if (parser->state.next < parser->state.quoted) {
#line 789
      parser->state.quoted = 0;
    }
  }
#line 791
  if (parser->try_getopt) {
#line 791
    if (! parser->state.quoted) {
#line 795
      parser->opt_data.rpl_optind = parser->state.next;
#line 797
      parser->opt_data.rpl_optopt = -1;
#line 798
      if (parser->state.flags & 64U) {
        {
#line 799
        opt = _getopt_long_only_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                                  (struct rpl_option  const  *)parser->long_opts,
                                  (int *)0, & parser->opt_data);
        }
      } else {
        {
#line 803
        opt = _getopt_long_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                             (struct rpl_option  const  *)parser->long_opts, (int *)0,
                             & parser->opt_data);
        }
      }
#line 807
      parser->state.next = parser->opt_data.rpl_optind;
#line 809
      if (opt == -1) {
#line 813
        parser->try_getopt = 0;
#line 814
        if (parser->state.next > 1) {
          {
#line 814
          tmp = strcmp((char const   *)*(parser->state.argv + (parser->state.next - 1)),
                       "--");
          }
#line 814
          if (tmp == 0) {
#line 821
            parser->state.quoted = parser->state.next;
          }
        }
      } else
#line 823
      if (opt == 63) {
#line 823
        if (parser->opt_data.rpl_optopt != -1) {
#line 828
          *arg_ebadkey = 0;
#line 829
          return (7);
        }
      }
    } else {
#line 833
      opt = -1;
    }
  } else {
#line 833
    opt = -1;
  }
#line 835
  if (opt == -1) {
#line 838
    if (parser->state.next >= parser->state.argc) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else
#line 838
    if (parser->state.flags & 4U) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else {
#line 848
      opt = 1;
#line 849
      tmp___0 = parser->state.next;
#line 849
      (parser->state.next) ++;
#line 849
      parser->opt_data.rpl_optarg = *(parser->state.argv + tmp___0);
    }
  }
#line 853
  if (opt == 1) {
    {
#line 855
    err = parser_parse_arg(parser, parser->opt_data.rpl_optarg);
    }
  } else {
    {
#line 857
    err = parser_parse_opt(parser, opt, parser->opt_data.rpl_optarg);
    }
  }
#line 859
  if (err == 7) {
#line 860
    if (opt == -1) {
#line 860
      tmp___1 = 1;
    } else
#line 860
    if (opt == 1) {
#line 860
      tmp___1 = 1;
    } else {
#line 860
      tmp___1 = 0;
    }
#line 860
    *arg_ebadkey = tmp___1;
  }
#line 862
  return (err);
}
}
#line 870 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) 
{ 
  error_t err ;
  struct parser parser ;
  int arg_ebadkey ;
  struct argp_child *child ;
  void *tmp ;
  struct argp *top_argp ;
  void *tmp___0 ;
  struct argp_child *tmp___1 ;
  struct argp_child *tmp___2 ;
  struct argp_child *tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 879
  arg_ebadkey = 0;
#line 882
  if (! (flags & 1U)) {
#line 885
    if (! program_invocation_name) {
#line 886
      program_invocation_name = *(argv + 0);
    }
#line 889
    if (! program_invocation_short_name) {
      {
#line 890
      program_invocation_short_name = last_component((char const   *)*(argv + 0));
      }
    }
  }
#line 895
  if (! (flags & 16U)) {
    {
#line 898
    tmp = __builtin_alloca(4UL * sizeof(struct argp_child ));
#line 898
    child = (struct argp_child *)tmp;
#line 899
    tmp___0 = __builtin_alloca(sizeof(struct argp ));
#line 899
    top_argp = (struct argp *)tmp___0;
#line 903
    memset((void *)top_argp, 0, sizeof(*top_argp));
#line 904
    top_argp->children = (struct argp_child  const  *)child;
#line 906
    memset((void *)child, 0, 4UL * sizeof(struct argp_child ));
    }
#line 908
    if (argp___0) {
#line 909
      tmp___1 = child;
#line 909
      child ++;
#line 909
      tmp___1->argp = (struct argp  const  *)argp___0;
    }
#line 910
    tmp___2 = child;
#line 910
    child ++;
#line 910
    tmp___2->argp = & argp_default_argp;
#line 911
    if (argp_program_version) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    } else
#line 911
    if (argp_program_version_hook) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    }
#line 913
    child->argp = (struct argp  const  *)0;
#line 915
    argp___0 = (struct argp  const  */* __restrict  */)top_argp;
  }
  {
#line 919
  err = parser_init(& parser, (struct argp  const  *)argp___0, argc, (char **)argv,
                    (int )flags, (void *)input);
  }
#line 921
  if (! err) {
    {
#line 924
    while (1) {
      while_continue: /* CIL Label */ ;
#line 924
      if (! (! err)) {
#line 924
        goto while_break;
      }
      {
#line 925
      err = parser_parse_next(& parser, & arg_ebadkey);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 926
    err = parser_finalize(& parser, err, arg_ebadkey, (int *)end_index);
    }
  }
#line 929
  return (err);
}
}
#line 937
 __attribute__((__nothrow__)) void *_argp_input(struct argp  const  * __restrict  argp___0 ,
                                                struct argp_state  const  * __restrict  state ) ;
#line 937 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-parse.c"
void *_argp_input(struct argp  const  * __restrict  argp___0 , struct argp_state  const  * __restrict  state ) 
{ 
  struct group *group ;
  struct parser *parser ;

  {
#line 940
  if (state) {
#line 943
    parser = (struct parser *)state->pstate;
#line 945
    group = parser->groups;
    {
#line 945
    while (1) {
      while_continue: /* CIL Label */ ;
#line 945
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 945
        goto while_break;
      }
#line 946
      if ((unsigned long )group->argp == (unsigned long )argp___0) {
#line 947
        return (group->input);
      }
#line 945
      group ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 950
  return ((void *)0);
}
}
#line 756 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 274 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchrnul)(char const   *__s ,
                                                                                        int __c )  __attribute__((__pure__)) ;
#line 389
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) mempcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 436
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strerror_r)(int __errnum ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 886 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 893
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 462 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp.h"
char const   *argp_program_bug_address ;
#line 467
error_t argp_err_exit_status ;
#line 500
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) ;
#line 548
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) ;
#line 122 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) ;
#line 129
void argp_fmtstream_free(argp_fmtstream_t fs ) ;
#line 134
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) ;
#line 140
int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) ;
#line 143
int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) ;
#line 147
size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str , size_t __len ) ;
#line 161
size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) ;
#line 173
size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) ;
#line 179
size_t argp_fmtstream_point(argp_fmtstream_t __fs ) ;
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct uparams uparams  = 
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
     {0, 1, 2, 6, 2, 29, 1, 12, 79, 0};
#line 121 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct uparam_name  const  uparam_names[10]  = 
#line 121
  {      {"dup-args", 1, (unsigned long )(& ((struct uparams *)0)->dup_args)}, 
        {"dup-args-note", 1, (unsigned long )(& ((struct uparams *)0)->dup_args_note)}, 
        {"short-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->short_opt_col)}, 
        {"long-opt-col", 0, (unsigned long )(& ((struct uparams *)0)->long_opt_col)}, 
        {"doc-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->doc_opt_col)}, 
        {"opt-doc-col", 0, (unsigned long )(& ((struct uparams *)0)->opt_doc_col)}, 
        {"header-col", 0, (unsigned long )(& ((struct uparams *)0)->header_col)}, 
        {"usage-indent", 0, (unsigned long )(& ((struct uparams *)0)->usage_indent)}, 
        {"rmargin",
      0, (unsigned long )(& ((struct uparams *)0)->rmargin)}, 
        {(char const   *)0, 0, 0UL}};
#line 135 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void validate_uparams(struct argp_state  const  *state , struct uparams *upptr ) 
{ 
  struct uparam_name  const  *up ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 140
  up = uparam_names;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! up->name) {
#line 140
      goto while_break;
    }
#line 142
    if (up->is_bool) {
#line 144
      goto __Cont;
    } else
#line 142
    if (up->uparams_offs == (size_t const   )((unsigned long )(& ((struct uparams *)0)->rmargin))) {
#line 144
      goto __Cont;
    }
#line 145
    if (*((int *)((char *)upptr + up->uparams_offs)) >= upptr->rmargin) {
      {
#line 147
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "ARGP_HELP_FMT: %s value is less than or equal to %s");
#line 147
      argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp,
                   "rmargin", up->name);
      }
#line 152
      return;
    }
    __Cont: /* CIL Label */ 
#line 140
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  uparams = *upptr;
#line 156
  uparams.valid = 1;
#line 157
  return;
}
}
#line 160 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void fill_in_uparams(struct argp_state  const  *state ) 
{ 
  char const   *var ;
  char *tmp ;
  struct uparams new_params ;
  unsigned short const   **tmp___0 ;
  size_t var_len ;
  struct uparam_name  const  *un ;
  int unspec ;
  int val ;
  char const   *arg___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 163
  tmp = getenv("ARGP_HELP_FMT");
#line 163
  var = (char const   *)tmp;
#line 164
  new_params = uparams;
  }
#line 168
  if (var) {
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! *var) {
#line 171
        goto while_break;
      }
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 173
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 173
          tmp___0 = __ctype_b_loc();
          }
#line 173
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*var)) & 8192)) {
#line 173
            goto while_break___1;
          }
#line 173
          var ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 173
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 175
      tmp___13 = __ctype_b_loc();
      }
#line 175
      if ((int const   )*(*tmp___13 + (int )((unsigned char )*var)) & 1024) {
#line 179
        unspec = 0;
#line 179
        val = 0;
#line 180
        arg___0 = var;
        {
#line 182
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 182
          tmp___1 = __ctype_b_loc();
          }
#line 182
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*arg___0)) & 8)) {
#line 182
            if (! ((int const   )*arg___0 == 45)) {
#line 182
              if (! ((int const   )*arg___0 == 95)) {
#line 182
                goto while_break___2;
              }
            }
          }
#line 183
          arg___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 184
        var_len = (size_t )(arg___0 - var);
        {
#line 186
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 186
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 186
            tmp___2 = __ctype_b_loc();
            }
#line 186
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 186
              goto while_break___4;
            }
#line 186
            arg___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 186
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 188
        if ((int const   )*arg___0 == 0) {
#line 189
          unspec = 1;
        } else
#line 188
        if ((int const   )*arg___0 == 44) {
#line 189
          unspec = 1;
        } else
#line 190
        if ((int const   )*arg___0 == 61) {
#line 192
          arg___0 ++;
          {
#line 193
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 193
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 193
              tmp___3 = __ctype_b_loc();
              }
#line 193
              if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 193
                goto while_break___6;
              }
#line 193
              arg___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 193
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 196
        if (unspec) {
#line 198
          if ((int const   )*(var + 0) == 110) {
#line 198
            if ((int const   )*(var + 1) == 111) {
#line 198
              if ((int const   )*(var + 2) == 45) {
#line 200
                val = 0;
#line 201
                var += 3;
#line 202
                var_len -= 3UL;
              } else {
#line 205
                val = 1;
              }
            } else {
#line 205
              val = 1;
            }
          } else {
#line 205
            val = 1;
          }
        } else {
          {
#line 207
          tmp___6 = __ctype_b_loc();
          }
#line 207
          if ((int const   )*(*tmp___6 + (int )((unsigned char )*arg___0)) & 2048) {
            {
#line 209
            val = atoi(arg___0);
            }
            {
#line 210
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 210
              tmp___4 = __ctype_b_loc();
              }
#line 210
              if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*arg___0)) & 2048)) {
#line 210
                goto while_break___7;
              }
#line 211
              arg___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 212
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 212
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 212
                tmp___5 = __ctype_b_loc();
                }
#line 212
                if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 212
                  goto while_break___9;
                }
#line 212
                arg___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 212
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
#line 215
        un = uparam_names;
        {
#line 215
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 215
          if (! un->name) {
#line 215
            goto while_break___10;
          }
          {
#line 216
          tmp___9 = strlen((char const   *)un->name);
          }
#line 216
          if (tmp___9 == var_len) {
            {
#line 216
            tmp___10 = strncmp(var, (char const   *)un->name, var_len);
            }
#line 216
            if (tmp___10 == 0) {
#line 219
              if (unspec) {
#line 219
                if (! un->is_bool) {
                  {
#line 220
                  tmp___7 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                     "%.*s: ARGP_HELP_FMT parameter requires a value");
#line 220
                  argp_failure((struct argp_state  const  */* __restrict  */)state,
                               0, 0, (char const   */* __restrict  */)tmp___7, (int )var_len,
                               var);
                  }
                } else {
#line 219
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 225
              if (val < 0) {
                {
#line 226
                tmp___8 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                   "%.*s: ARGP_HELP_FMT parameter must be positive");
#line 226
                argp_failure((struct argp_state  const  */* __restrict  */)state,
                             0, 0, (char const   */* __restrict  */)tmp___8, (int )var_len,
                             var);
                }
              } else {
#line 232
                *((int *)((char *)(& new_params) + un->uparams_offs)) = val;
              }
#line 233
              goto while_break___10;
            }
          }
#line 215
          un ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 235
        if (! un->name) {
          {
#line 236
          tmp___11 = dgettext((char const   *)(state->root_argp)->argp_domain, "%.*s: Unknown ARGP_HELP_FMT parameter");
#line 236
          argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0,
                       (char const   */* __restrict  */)tmp___11, (int )var_len, var);
          }
        }
#line 241
        var = arg___0;
#line 242
        if ((int const   )*var == 44) {
#line 243
          var ++;
        }
      } else
#line 245
      if (*var) {
        {
#line 247
        tmp___12 = dgettext((char const   *)(state->root_argp)->argp_domain, "Garbage in ARGP_HELP_FMT: %s");
#line 247
        argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp___12,
                     var);
        }
#line 250
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 253
    validate_uparams(state, & new_params);
    }
  }
#line 255
  return;
}
}
#line 341 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int find_char(char ch , char *beg , char *end ) 
{ 


  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 344
      goto while_break;
    }
#line 345
    if ((int )*beg == (int )ch) {
#line 346
      return (1);
    } else {
#line 348
      beg ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (0);
}
}
#line 433 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct hol *make_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  char *so ;
  struct argp_option  const  *o ;
  struct argp_option  const  *opts ;
  struct hol_entry *entry ;
  unsigned int num_short_options ;
  struct hol *hol ;
  void *tmp ;
  int cur_group ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 438
  opts = (struct argp_option  const  *)argp___0->options;
#line 440
  num_short_options = 0U;
#line 441
  tmp = malloc(sizeof(struct hol ));
#line 441
  hol = (struct hol *)tmp;
  }
#line 443
  if (! hol) {
    {
#line 443
    __assert_fail("hol", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c", 443U,
                  "make_hol");
    }
  }
#line 445
  hol->num_entries = 0U;
#line 446
  hol->clusters = (struct hol_cluster *)0;
#line 448
  if (opts) {
#line 450
    cur_group = 0;
#line 453
    if (! (! (opts->flags & 4))) {
      {
#line 453
      __assert_fail("! ((opts)->flags & 0x4)", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c",
                    453U, "make_hol");
      }
    }
#line 456
    o = opts;
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 456
      tmp___1 = _option_is_end(o);
      }
#line 456
      if (tmp___1) {
#line 456
        goto while_break;
      }
#line 458
      if (! (o->flags & 4)) {
#line 459
        (hol->num_entries) ++;
      }
      {
#line 460
      tmp___0 = _option_is_short(o);
      }
#line 460
      if (tmp___0) {
#line 461
        num_short_options ++;
      }
#line 456
      o ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 464
    tmp___2 = malloc(sizeof(struct hol_entry ) * (unsigned long )hol->num_entries);
#line 464
    hol->entries = (struct hol_entry *)tmp___2;
#line 465
    tmp___3 = malloc((size_t )(num_short_options + 1U));
#line 465
    hol->short_options = (char *)tmp___3;
    }
#line 467
    if (hol->entries) {
#line 467
      if (! hol->short_options) {
        {
#line 467
        __assert_fail("hol->entries && hol->short_options", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c",
                      467U, "make_hol");
        }
      }
    } else {
      {
#line 467
      __assert_fail("hol->entries && hol->short_options", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c",
                    467U, "make_hol");
      }
    }
#line 472
    so = hol->short_options;
#line 473
    o = opts;
#line 473
    entry = hol->entries;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 473
      tmp___9 = _option_is_end(o);
      }
#line 473
      if (tmp___9) {
#line 473
        goto while_break___0;
      }
#line 475
      entry->opt = o;
#line 476
      entry->num = 0U;
#line 477
      entry->short_options = so;
#line 478
      if (o->group) {
#line 478
        cur_group = (int )o->group;
      } else {
#line 478
        if (! o->name) {
#line 478
          if (! o->key) {
#line 478
            tmp___4 = cur_group + 1;
          } else {
#line 478
            tmp___4 = cur_group;
          }
        } else {
#line 478
          tmp___4 = cur_group;
        }
#line 478
        cur_group = tmp___4;
      }
#line 478
      entry->group = cur_group;
#line 484
      entry->cluster = cluster;
#line 485
      entry->argp = argp___0;
      {
#line 487
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 489
        (entry->num) ++;
#line 490
        tmp___6 = _option_is_short(o);
        }
#line 490
        if (tmp___6) {
          {
#line 490
          tmp___7 = find_char((char )o->key, hol->short_options, so);
          }
#line 490
          if (! tmp___7) {
#line 492
            tmp___5 = so;
#line 492
            so ++;
#line 492
            *tmp___5 = (char )o->key;
          }
        }
        {
#line 493
        o ++;
#line 487
        tmp___8 = _option_is_end(o);
        }
#line 487
        if (tmp___8) {
#line 487
          goto while_break___1;
        } else
#line 487
        if (! (o->flags & 4)) {
#line 487
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 473
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 497
    *so = (char )'\000';
  }
#line 500
  return (hol);
}
}
#line 506 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct hol_cluster *hol_add_cluster(struct hol *hol , int group , char const   *header ,
                                           int index___0 , struct hol_cluster *parent ,
                                           struct argp  const  *argp___0 ) 
{ 
  struct hol_cluster *cl ;
  void *tmp ;

  {
  {
#line 510
  tmp = malloc(sizeof(struct hol_cluster ));
#line 510
  cl = (struct hol_cluster *)tmp;
  }
#line 511
  if (cl) {
#line 513
    cl->group = group;
#line 514
    cl->header = header;
#line 516
    cl->index = index___0;
#line 517
    cl->parent = parent;
#line 518
    cl->argp = argp___0;
#line 519
    if (parent) {
#line 519
      cl->depth = parent->depth + 1;
    } else {
#line 519
      cl->depth = 0;
    }
#line 521
    cl->next = hol->clusters;
#line 522
    hol->clusters = cl;
  }
#line 524
  return (cl);
}
}
#line 528 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_free(struct hol *hol ) 
{ 
  struct hol_cluster *cl ;
  struct hol_cluster *next ;

  {
#line 531
  cl = hol->clusters;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! cl) {
#line 533
      goto while_break;
    }
    {
#line 535
    next = cl->next;
#line 536
    free((void *)cl);
#line 537
    cl = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (hol->num_entries > 0U) {
    {
#line 542
    free((void *)hol->entries);
#line 543
    free((void *)hol->short_options);
    }
  }
  {
#line 546
  free((void *)hol);
  }
#line 547
  return;
}
}
#line 549 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int hol_entry_short_iterate(struct hol_entry  const  *entry , int (*func)(struct argp_option  const  *opt ,
                                                                                 struct argp_option  const  *real ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) ,
                                   char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;
  char *so ;
  int tmp ;

  {
#line 557
  val = 0;
#line 558
  real = (struct argp_option  const  *)entry->opt;
#line 559
  so = (char *)entry->short_options;
#line 561
  opt = real;
#line 561
  nopts = (unsigned int )entry->num;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (nopts > 0U) {
#line 561
      if (! (! val)) {
#line 561
        goto while_break;
      }
    } else {
#line 561
      goto while_break;
    }
    {
#line 562
    tmp = _option_is_short(opt);
    }
#line 562
    if (tmp) {
#line 562
      if ((int )*so == (int )opt->key) {
#line 564
        if (! (opt->flags & 4)) {
#line 565
          real = opt;
        }
#line 566
        if (! (opt->flags & 2)) {
          {
#line 567
          val = (*func)(opt, real, domain, cookie);
          }
        }
#line 568
        so ++;
      }
    }
#line 561
    opt ++;
#line 561
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (val);
}
}
#line 574 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
__inline static int ( __attribute__((__always_inline__)) hol_entry_long_iterate)(struct hol_entry  const  *entry ,
                                                                                 int (*func)(struct argp_option  const  *opt ,
                                                                                             struct argp_option  const  *real ,
                                                                                             char const   *domain ,
                                                                                             void *cookie ) ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;

  {
#line 583
  val = 0;
#line 584
  real = (struct argp_option  const  *)entry->opt;
#line 586
  opt = real;
#line 586
  nopts = (unsigned int )entry->num;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (nopts > 0U) {
#line 586
      if (! (! val)) {
#line 586
        goto while_break;
      }
    } else {
#line 586
      goto while_break;
    }
#line 587
    if (opt->name) {
#line 589
      if (! (opt->flags & 4)) {
#line 590
        real = opt;
      }
#line 591
      if (! (opt->flags & 2)) {
        {
#line 592
        val = (*func)(opt, real, domain, cookie);
        }
      }
    }
#line 586
    opt ++;
#line 586
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return (val);
}
}
#line 599 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int until_short(struct argp_option  const  *opt , struct argp_option  const  *real ,
                       char const   *domain , void *cookie ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 603
  tmp___1 = _option_is_short(opt);
  }
#line 603
  if (tmp___1) {
#line 603
    tmp___0 = opt->key;
  } else {
#line 603
    tmp___0 = (int const   )0;
  }
#line 603
  return ((int )tmp___0);
}
}
#line 607 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static char hol_entry_first_short(struct hol_entry  const  *entry ) 
{ 
  int tmp ;

  {
  {
#line 610
  tmp = hol_entry_short_iterate(entry, & until_short, (char const   *)(entry->argp)->argp_domain,
                                (void *)0);
  }
#line 610
  return ((char )tmp);
}
}
#line 615 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static char const   *hol_entry_first_long(struct hol_entry  const  *entry ) 
{ 
  struct argp_option  const  *opt ;
  unsigned int num ;

  {
#line 620
  opt = (struct argp_option  const  *)entry->opt;
#line 620
  num = (unsigned int )entry->num;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (num > 0U)) {
#line 620
      goto while_break;
    }
#line 621
    if (opt->name) {
#line 621
      if (! (opt->flags & 2)) {
#line 622
        return ((char const   *)opt->name);
      }
    }
#line 620
    opt ++;
#line 620
    num --;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  return ((char const   *)0);
}
}
#line 628 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct hol_entry *hol_find_entry(struct hol *hol , char const   *name ) 
{ 
  struct hol_entry *entry ;
  unsigned int num_entries ;
  struct argp_option  const  *opt ;
  unsigned int num_opts ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 631
  entry = hol->entries;
#line 632
  num_entries = hol->num_entries;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    tmp___1 = num_entries;
#line 634
    num_entries --;
#line 634
    if (! (tmp___1 > 0U)) {
#line 634
      goto while_break;
    }
#line 636
    opt = entry->opt;
#line 637
    num_opts = entry->num;
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      tmp___0 = num_opts;
#line 639
      num_opts --;
#line 639
      if (! (tmp___0 > 0U)) {
#line 639
        goto while_break___0;
      }
#line 640
      if (opt->name) {
#line 640
        if (! (opt->flags & 2)) {
          {
#line 640
          tmp = strcmp((char const   *)opt->name, name);
          }
#line 640
          if (tmp == 0) {
#line 641
            return (entry);
          } else {
#line 643
            opt ++;
          }
        } else {
#line 643
          opt ++;
        }
      } else {
#line 643
        opt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return ((struct hol_entry *)0);
}
}
#line 653 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_set_group(struct hol *hol , char const   *name , int group ) 
{ 
  struct hol_entry *entry ;
  struct hol_entry *tmp ;

  {
  {
#line 656
  tmp = hol_find_entry(hol, name);
#line 656
  entry = tmp;
  }
#line 657
  if (entry) {
#line 658
    entry->group = group;
  }
#line 659
  return;
}
}
#line 663 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int group_cmp(int group1 , int group2 , int eq ) 
{ 


  {
#line 666
  if (group1 == group2) {
#line 667
    return (eq);
  } else
#line 668
  if (group1 < 0) {
#line 668
    if (group2 < 0) {
#line 669
      return (group1 - group2);
    } else {
#line 668
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 668
  if (group1 >= 0) {
#line 668
    if (group2 >= 0) {
#line 669
      return (group1 - group2);
    } else {
#line 671
      return (group2 - group1);
    }
  } else {
#line 671
    return (group2 - group1);
  }
}
}
#line 676 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int hol_cluster_cmp(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 
  int tmp ;

  {
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (cl1->depth > cl2->depth)) {
#line 683
      goto while_break;
    }
#line 684
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (cl2->depth > cl1->depth)) {
#line 685
      goto while_break___0;
    }
#line 686
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 690
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )cl1->parent != (unsigned long )cl2->parent)) {
#line 690
      goto while_break___1;
    }
#line 691
    cl1 = (struct hol_cluster  const  *)cl1->parent;
#line 691
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 693
  tmp = group_cmp((int )cl1->group, (int )cl2->group, (int )(cl2->index - cl1->index));
  }
#line 693
  return (tmp);
}
}
#line 698 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct hol_cluster *hol_cluster_base(struct hol_cluster *cl ) 
{ 


  {
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! cl->parent) {
#line 701
      goto while_break;
    }
#line 702
    cl = cl->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return (cl);
}
}
#line 707 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int hol_cluster_is_child(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 


  {
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (cl1) {
#line 711
      if (! ((unsigned long )cl1 != (unsigned long )cl2)) {
#line 711
        goto while_break;
      }
    } else {
#line 711
      goto while_break;
    }
#line 712
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  return ((unsigned long )cl1 == (unsigned long )cl2);
}
}
#line 719 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int canon_doc_option(char const   **name ) 
{ 
  int non_opt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 724
  if (! *name) {
#line 725
    non_opt = 1;
  } else {
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 729
      tmp = __ctype_b_loc();
      }
#line 729
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(*name))) & 8192)) {
#line 729
        goto while_break;
      }
#line 730
      (*name) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 732
    non_opt = (int const   )*(*name) != 45;
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 734
      if (*(*name)) {
        {
#line 734
        tmp___0 = __ctype_b_loc();
        }
#line 734
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*name))) & 8) {
#line 734
          goto while_break___0;
        }
      } else {
#line 734
        goto while_break___0;
      }
#line 735
      (*name) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 737
  return (non_opt);
}
}
#line 744 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int hol_entry_cmp(struct hol_entry  const  *entry1 , struct hol_entry  const  *entry2 ) 
{ 
  int group1 ;
  int group2 ;
  int rc ;
  struct hol_cluster *tmp ;
  int tmp___0 ;
  struct hol_cluster *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int short1 ;
  char tmp___5 ;
  int short2 ;
  char tmp___6 ;
  int doc1 ;
  int doc2 ;
  char const   *long1 ;
  char const   *tmp___7 ;
  char const   *long2 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char first1 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned char first2 ;
  int tmp___13 ;
  int tmp___14 ;
  int lower_cmp ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 750
  group1 = (int )entry1->group;
#line 750
  group2 = (int )entry2->group;
#line 753
  if ((unsigned long )entry1->cluster != (unsigned long )entry2->cluster) {
#line 757
    if (! entry1->cluster) {
      {
#line 762
      tmp = hol_cluster_base((struct hol_cluster *)entry2->cluster);
#line 762
      tmp___0 = group_cmp(group1, tmp->group, -1);
      }
#line 762
      return (tmp___0);
    } else
#line 763
    if (! entry2->cluster) {
      {
#line 765
      tmp___1 = hol_cluster_base((struct hol_cluster *)entry1->cluster);
#line 765
      tmp___2 = group_cmp(tmp___1->group, group2, 1);
      }
#line 765
      return (tmp___2);
    } else {
      {
#line 768
      rc = hol_cluster_cmp((struct hol_cluster  const  *)entry1->cluster, (struct hol_cluster  const  *)entry2->cluster);
      }
#line 768
      if (rc) {
#line 768
        tmp___4 = rc;
      } else {
#line 768
        if (entry1->ord < entry2->ord) {
#line 768
          tmp___3 = -1;
        } else {
#line 768
          tmp___3 = 1;
        }
#line 768
        tmp___4 = tmp___3;
      }
#line 768
      return (tmp___4);
    }
  } else
#line 771
  if (group1 == group2) {
    {
#line 775
    tmp___5 = hol_entry_first_short(entry1);
#line 775
    short1 = (int )tmp___5;
#line 776
    tmp___6 = hol_entry_first_short(entry2);
#line 776
    short2 = (int )tmp___6;
#line 777
    doc1 = (int )((entry1->opt)->flags & 8);
#line 778
    doc2 = (int )((entry2->opt)->flags & 8);
#line 779
    tmp___7 = hol_entry_first_long(entry1);
#line 779
    long1 = tmp___7;
#line 780
    tmp___8 = hol_entry_first_long(entry2);
#line 780
    long2 = tmp___8;
    }
#line 782
    if (doc1) {
      {
#line 783
      doc1 = canon_doc_option(& long1);
      }
    }
#line 784
    if (doc2) {
      {
#line 785
      doc2 = canon_doc_option(& long2);
      }
    }
#line 787
    if (doc1 != doc2) {
#line 790
      return (doc1 - doc2);
    } else
#line 791
    if (! short1) {
#line 791
      if (! short2) {
#line 791
        if (long1) {
#line 791
          if (long2) {
            {
#line 793
            rc = strcasecmp(long1, long2);
            }
#line 793
            if (rc) {
#line 793
              tmp___10 = rc;
            } else {
#line 793
              if (entry1->ord < entry2->ord) {
#line 793
                tmp___9 = -1;
              } else {
#line 793
                tmp___9 = 1;
              }
#line 793
              tmp___10 = tmp___9;
            }
#line 793
            return (tmp___10);
          } else {
#line 791
            goto _L___1;
          }
        } else {
#line 791
          goto _L___1;
        }
      } else {
#line 791
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 802
      if (short1) {
#line 802
        tmp___12 = short1;
      } else {
#line 802
        if (long1) {
#line 802
          tmp___11 = (int const   )*long1;
        } else {
#line 802
          tmp___11 = (int const   )0;
        }
#line 802
        tmp___12 = (int )tmp___11;
      }
#line 802
      first1 = (unsigned char )tmp___12;
#line 803
      if (short2) {
#line 803
        tmp___14 = short2;
      } else {
#line 803
        if (long2) {
#line 803
          tmp___13 = (int const   )*long2;
        } else {
#line 803
          tmp___13 = (int const   )0;
        }
#line 803
        tmp___14 = (int )tmp___13;
      }
      {
#line 803
      first2 = (unsigned char )tmp___14;
#line 806
      tmp___15 = (int )tolower((int )first1);
#line 806
      tmp___16 = (int )tolower((int )first2);
#line 806
      lower_cmp = tmp___15 - tmp___16;
      }
#line 809
      if (lower_cmp) {
#line 809
        tmp___19 = lower_cmp;
      } else {
#line 809
        rc = (int )first2 - (int )first1;
#line 809
        if (rc) {
#line 809
          tmp___18 = rc;
        } else {
#line 809
          if (entry1->ord < entry2->ord) {
#line 809
            tmp___17 = -1;
          } else {
#line 809
            tmp___17 = 1;
          }
#line 809
          tmp___18 = tmp___17;
        }
#line 809
        tmp___19 = tmp___18;
      }
#line 809
      return (tmp___19);
    }
  } else {
#line 817
    if (entry1->ord < entry2->ord) {
#line 817
      tmp___20 = -1;
    } else {
#line 817
      tmp___20 = 1;
    }
    {
#line 817
    tmp___21 = group_cmp(group1, group2, tmp___20);
    }
#line 817
    return (tmp___21);
  }
}
}
#line 821 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int hol_entry_qcmp(void const   *entry1_v , void const   *entry2_v ) 
{ 
  int tmp ;

  {
  {
#line 824
  tmp = hol_entry_cmp((struct hol_entry  const  *)entry1_v, (struct hol_entry  const  *)entry2_v);
  }
#line 824
  return (tmp);
}
}
#line 830 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_sort(struct hol *hol ) 
{ 
  unsigned int i ;
  struct hol_entry *e ;

  {
#line 833
  if (hol->num_entries > 0U) {
#line 837
    i = 0U;
#line 837
    e = hol->entries;
    {
#line 837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 837
      if (! (i < hol->num_entries)) {
#line 837
        goto while_break;
      }
#line 838
      e->ord = i;
#line 837
      i ++;
#line 837
      e ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 839
    qsort((void *)hol->entries, (size_t )hol->num_entries, sizeof(struct hol_entry ),
          & hol_entry_qcmp);
    }
  }
#line 842
  return;
}
}
#line 846 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_append(struct hol *hol , struct hol *more ) 
{ 
  struct hol_cluster **cl_end ;
  unsigned int left ;
  char *so ;
  char *more_so ;
  struct hol_entry *e ;
  unsigned int num_entries ;
  struct hol_entry *entries ;
  void *tmp ;
  unsigned int hol_so_len ;
  size_t tmp___0 ;
  char *short_options ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int opts_left ;
  struct argp_option  const  *opt ;
  int ch ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 849
  cl_end = & hol->clusters;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! *cl_end) {
#line 852
      goto while_break;
    }
#line 853
    cl_end = & (*cl_end)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  *cl_end = more->clusters;
#line 855
  more->clusters = (struct hol_cluster *)0;
#line 858
  if (more->num_entries > 0U) {
#line 860
    if (hol->num_entries == 0U) {
#line 862
      hol->num_entries = more->num_entries;
#line 863
      hol->entries = more->entries;
#line 864
      hol->short_options = more->short_options;
#line 865
      more->num_entries = 0U;
    } else {
      {
#line 874
      num_entries = hol->num_entries + more->num_entries;
#line 875
      tmp = malloc((unsigned long )num_entries * sizeof(struct hol_entry ));
#line 875
      entries = (struct hol_entry *)tmp;
#line 877
      tmp___0 = strlen((char const   *)hol->short_options);
#line 877
      hol_so_len = (unsigned int )tmp___0;
#line 878
      tmp___1 = strlen((char const   *)more->short_options);
#line 878
      tmp___2 = malloc(((size_t )hol_so_len + tmp___1) + 1UL);
#line 878
      short_options = (char *)tmp___2;
      }
#line 881
      if (entries) {
#line 881
        if (! short_options) {
          {
#line 881
          __assert_fail("entries && short_options", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c",
                        881U, "hol_append");
          }
        }
      } else {
        {
#line 881
        __assert_fail("entries && short_options", "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c",
                      881U, "hol_append");
        }
      }
      {
#line 885
      tmp___3 = (void *)mempcpy((void */* __restrict  */)entries, (void const   */* __restrict  */)hol->entries,
                                (unsigned long )hol->num_entries * sizeof(struct hol_entry ));
#line 885
      mempcpy((void */* __restrict  */)tmp___3, (void const   */* __restrict  */)more->entries,
              (unsigned long )more->num_entries * sizeof(struct hol_entry ));
#line 890
      mempcpy((void */* __restrict  */)short_options, (void const   */* __restrict  */)hol->short_options,
              (size_t )hol_so_len);
#line 893
      e = entries;
#line 893
      left = hol->num_entries;
      }
      {
#line 893
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 893
        if (! (left > 0U)) {
#line 893
          goto while_break___0;
        }
#line 894
        e->short_options += short_options - hol->short_options;
#line 893
        e ++;
#line 893
        left --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 898
      so = short_options + hol_so_len;
#line 899
      more_so = more->short_options;
#line 900
      left = more->num_entries;
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! (left > 0U)) {
#line 900
          goto while_break___1;
        }
#line 905
        e->short_options = so;
#line 907
        opts_left = (int )e->num;
#line 907
        opt = e->opt;
        {
#line 907
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 907
          if (! opts_left) {
#line 907
            goto while_break___2;
          }
          {
#line 909
          ch = (int )*more_so;
#line 910
          tmp___6 = _option_is_short(opt);
          }
#line 910
          if (tmp___6) {
#line 910
            if (ch == (int )opt->key) {
              {
#line 913
              tmp___5 = find_char((char )ch, short_options, short_options + hol_so_len);
              }
#line 913
              if (! tmp___5) {
#line 917
                tmp___4 = so;
#line 917
                so ++;
#line 917
                *tmp___4 = (char )ch;
              }
#line 918
              more_so ++;
            }
          }
#line 907
          opt ++;
#line 907
          opts_left --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 900
        e ++;
#line 900
        left --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 923
      *so = (char )'\000';
#line 925
      free((void *)hol->entries);
#line 926
      free((void *)hol->short_options);
#line 928
      hol->entries = entries;
#line 929
      hol->num_entries = num_entries;
#line 930
      hol->short_options = short_options;
      }
    }
  }
  {
#line 934
  hol_free(more);
  }
#line 935
  return;
}
}
#line 938 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void indent_to(argp_fmtstream_t stream , unsigned int col ) 
{ 
  int needed ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 941
  tmp = argp_fmtstream_point(stream);
#line 941
  needed = (int )((size_t )col - tmp);
  }
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    tmp___0 = needed;
#line 942
    needed --;
#line 942
    if (! (tmp___0 > 0)) {
#line 942
      goto while_break;
    }
    {
#line 943
    argp_fmtstream_putc(stream, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return;
}
}
#line 948 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void space(argp_fmtstream_t stream , size_t ensure ) 
{ 
  size_t tmp ;

  {
  {
#line 951
  tmp = argp_fmtstream_point(stream);
  }
#line 951
  if (tmp + ensure >= stream->rmargin) {
    {
#line 953
    argp_fmtstream_putc(stream, '\n');
    }
  } else {
    {
#line 955
    argp_fmtstream_putc(stream, ' ');
    }
  }
#line 956
  return;
}
}
#line 961 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void arg(struct argp_option  const  *real , char const   *req_fmt , char const   *opt_fmt ,
                char const   *domain , argp_fmtstream_t stream ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 965
  if (real->arg) {
#line 967
    if (real->flags & 1) {
      {
#line 968
      tmp = dgettext(domain, (char const   *)real->arg);
#line 968
      argp_fmtstream_printf(stream, opt_fmt, tmp);
      }
    } else {
      {
#line 971
      tmp___0 = dgettext(domain, (char const   *)real->arg);
#line 971
      argp_fmtstream_printf(stream, req_fmt, tmp___0);
      }
    }
  }
#line 974
  return;
}
}
#line 1010 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static char const   *filter_doc(char const   *doc___0 , int key , struct argp  const  *argp___0 ,
                                struct argp_state  const  *state ) 
{ 
  void *input ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1014
  if (argp___0->help_filter) {
    {
#line 1017
    tmp = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
#line 1017
    input = tmp;
#line 1018
    tmp___0 = (*(argp___0->help_filter))(key, doc___0, input);
    }
#line 1018
    return ((char const   *)tmp___0);
  } else {
#line 1022
    return (doc___0);
  }
}
}
#line 1030 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void print_header(char const   *str , struct argp  const  *argp___0 , struct pentry_state *pest ) 
{ 
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  char const   *tmp___0 ;

  {
  {
#line 1034
  tmp = dgettext((char const   *)argp___0->argp_domain, str);
#line 1034
  tstr = (char const   *)tmp;
#line 1035
  tmp___0 = filter_doc(tstr, 33554435, argp___0, pest->state);
#line 1035
  fstr = tmp___0;
  }
#line 1037
  if (fstr) {
#line 1039
    if (*fstr) {
#line 1041
      if ((pest->hhstate)->prev_entry) {
        {
#line 1043
        argp_fmtstream_putc(pest->stream, '\n');
        }
      }
      {
#line 1044
      indent_to(pest->stream, (unsigned int )uparams.header_col);
#line 1045
      argp_fmtstream_set_lmargin(pest->stream, (size_t )uparams.header_col);
#line 1046
      argp_fmtstream_set_wmargin(pest->stream, (size_t )uparams.header_col);
#line 1047
      argp_fmtstream_puts(pest->stream, fstr);
#line 1048
      argp_fmtstream_set_lmargin(pest->stream, (size_t )0);
#line 1049
      argp_fmtstream_putc(pest->stream, '\n');
      }
    }
#line 1052
    (pest->hhstate)->sep_groups = 1;
  }
#line 1055
  if ((unsigned long )fstr != (unsigned long )tstr) {
    {
#line 1056
    free((void *)((char *)fstr));
    }
  }
#line 1057
  return;
}
}
#line 1063 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void comma(unsigned int col , struct pentry_state *pest ) 
{ 
  struct hol_entry  const  *pe ;
  struct hol_cluster  const  *cl ;
  int old_wm ;
  int tmp ;
  char *__cil_tmp7 ;

  {
#line 1066
  if (pest->first) {
#line 1068
    pe = (struct hol_entry  const  *)(pest->hhstate)->prev_entry;
#line 1069
    cl = (struct hol_cluster  const  *)(pest->entry)->cluster;
#line 1071
    if ((pest->hhstate)->sep_groups) {
#line 1071
      if (pe) {
#line 1071
        if ((pest->entry)->group != pe->group) {
          {
#line 1072
          argp_fmtstream_putc(pest->stream, '\n');
          }
        }
      }
    }
#line 1074
    if (cl) {
#line 1074
      if (cl->header) {
#line 1074
        if (*(cl->header)) {
#line 1074
          if (! pe) {
            {
#line 1083
            old_wm = (int )(pest->stream)->wmargin;
#line 1084
            print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                         pest);
#line 1085
            argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
            }
          } else
#line 1074
          if ((unsigned long )pe->cluster != (unsigned long )cl) {
            {
#line 1074
            tmp = hol_cluster_is_child((struct hol_cluster  const  *)pe->cluster,
                                       cl);
            }
#line 1074
            if (! tmp) {
              {
#line 1083
              old_wm = (int )(pest->stream)->wmargin;
#line 1084
              print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                           pest);
#line 1085
              argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
              }
            }
          }
        }
      }
    }
#line 1088
    pest->first = 0;
  } else {
    {
#line 1091
    argp_fmtstream_puts(pest->stream, ", ");
    }
  }
  {
#line 1093
  indent_to(pest->stream, col);
  }
#line 1094
  return;
}
}
#line 1097 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_entry_help(struct hol_entry *entry , struct argp_state  const  *state ,
                           argp_fmtstream_t stream , struct hol_help_state *hhstate ) 
{ 
  unsigned int num ;
  struct argp_option  const  *real ;
  struct argp_option  const  *opt ;
  char *so ;
  int have_long_opt ;
  int old_lm ;
  size_t tmp ;
  int old_wm ;
  struct pentry_state pest ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int first_long_opt ;
  int tmp___3 ;
  char const   *tstr ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *fstr ;
  char const   *tmp___6 ;
  unsigned int col ;
  size_t tmp___7 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 1102
  real = entry->opt;
#line 1103
  so = entry->short_options;
#line 1104
  have_long_opt = 0;
#line 1106
  tmp = argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1106
  old_lm = (int )tmp;
#line 1107
  old_wm = (int )stream->wmargin;
#line 1112
  pest.entry = (struct hol_entry  const  *)entry;
#line 1113
  pest.stream = stream;
#line 1114
  pest.hhstate = hhstate;
#line 1115
  pest.first = 1;
#line 1116
  pest.state = state;
  }
#line 1118
  if (! (real->flags & 8)) {
#line 1119
    opt = real;
#line 1119
    num = entry->num;
    {
#line 1119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1119
      if (! (num > 0U)) {
#line 1119
        goto while_break;
      }
#line 1120
      if (opt->name) {
#line 1120
        if (! (opt->flags & 2)) {
#line 1122
          have_long_opt = 1;
#line 1123
          goto while_break;
        }
      }
#line 1119
      opt ++;
#line 1119
      num --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1127
  argp_fmtstream_set_wmargin(stream, (size_t )uparams.short_opt_col);
#line 1128
  opt = real;
#line 1128
  num = entry->num;
  }
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! (num > 0U)) {
#line 1128
      goto while_break___0;
    }
    {
#line 1129
    tmp___0 = _option_is_short(opt);
    }
#line 1129
    if (tmp___0) {
#line 1129
      if (opt->key == (int const   )*so) {
#line 1132
        if (! (opt->flags & 2)) {
          {
#line 1134
          comma((unsigned int )uparams.short_opt_col, & pest);
#line 1135
          argp_fmtstream_putc(stream, '-');
#line 1136
          argp_fmtstream_putc(stream, (int )*so);
          }
#line 1137
          if (! have_long_opt) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1137
          if (uparams.dup_args) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1139
          if (real->arg) {
#line 1140
            hhstate->suppressed_dup_arg = 1;
          }
        }
#line 1142
        so ++;
      }
    }
#line 1128
    opt ++;
#line 1128
    num --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1146
  if (real->flags & 8) {
    {
#line 1149
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.doc_opt_col);
#line 1150
    opt = real;
#line 1150
    num = entry->num;
    }
    {
#line 1150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1150
      if (! (num > 0U)) {
#line 1150
        goto while_break___1;
      }
#line 1151
      if (opt->name) {
#line 1151
        if (*(opt->name)) {
#line 1151
          if (! (opt->flags & 2)) {
            {
#line 1153
            comma((unsigned int )uparams.doc_opt_col, & pest);
            }
#line 1157
            if (opt->flags & 32) {
#line 1157
              tmp___2 = opt->name;
            } else {
              {
#line 1157
              tmp___1 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                 (char const   *)opt->name);
#line 1157
              tmp___2 = (char const   */* const  */)tmp___1;
              }
            }
            {
#line 1157
            argp_fmtstream_puts(stream, (char const   *)tmp___2);
            }
          }
        }
      }
#line 1150
      opt ++;
#line 1150
      num --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1167
    first_long_opt = 1;
#line 1169
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.long_opt_col);
#line 1170
    opt = real;
#line 1170
    num = entry->num;
    }
    {
#line 1170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1170
      if (! (num > 0U)) {
#line 1170
        goto while_break___2;
      }
#line 1171
      if (opt->name) {
#line 1171
        if (! (opt->flags & 2)) {
          {
#line 1173
          comma((unsigned int )uparams.long_opt_col, & pest);
#line 1174
          argp_fmtstream_printf(stream, "--%s", opt->name);
          }
#line 1175
          if (first_long_opt) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1175
          if (uparams.dup_args) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1178
          if (real->arg) {
#line 1179
            hhstate->suppressed_dup_arg = 1;
          }
        }
      }
#line 1170
      opt ++;
#line 1170
      num --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1184
  argp_fmtstream_set_lmargin(stream, (size_t )0);
  }
#line 1186
  if (pest.first) {
    {
#line 1189
    tmp___3 = _option_is_short(real);
    }
#line 1189
    if (tmp___3) {
#line 1194
      goto cleanup;
    } else
#line 1189
    if (! real->name) {
      {
#line 1191
      print_header((char const   *)real->doc, entry->argp, & pest);
      }
    } else {
#line 1194
      goto cleanup;
    }
  } else {
#line 1198
    if (real->doc) {
      {
#line 1198
      tmp___4 = dgettext((char const   *)(state->root_argp)->argp_domain, (char const   *)real->doc);
#line 1198
      tmp___5 = tmp___4;
      }
    } else {
#line 1198
      tmp___5 = (char *)0;
    }
    {
#line 1198
    tstr = (char const   *)tmp___5;
#line 1200
    tmp___6 = filter_doc(tstr, (int )real->key, entry->argp, state);
#line 1200
    fstr = tmp___6;
    }
#line 1201
    if (fstr) {
#line 1201
      if (*fstr) {
        {
#line 1203
        tmp___7 = argp_fmtstream_point(stream);
#line 1203
        col = (unsigned int )tmp___7;
#line 1205
        argp_fmtstream_set_lmargin(stream, (size_t )uparams.opt_doc_col);
#line 1206
        argp_fmtstream_set_wmargin(stream, (size_t )uparams.opt_doc_col);
        }
#line 1208
        if (col > (unsigned int )(uparams.opt_doc_col + 3)) {
          {
#line 1209
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1210
        if (col >= (unsigned int )uparams.opt_doc_col) {
          {
#line 1211
          argp_fmtstream_puts(stream, "   ");
          }
        } else {
          {
#line 1213
          indent_to(stream, (unsigned int )uparams.opt_doc_col);
          }
        }
        {
#line 1215
        argp_fmtstream_puts(stream, fstr);
        }
      }
    }
#line 1217
    if (fstr) {
#line 1217
      if ((unsigned long )fstr != (unsigned long )tstr) {
        {
#line 1218
        free((void *)((char *)fstr));
        }
      }
    }
    {
#line 1221
    argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1222
    argp_fmtstream_putc(stream, '\n');
    }
  }
#line 1225
  hhstate->prev_entry = entry;
  cleanup: 
  {
#line 1228
  argp_fmtstream_set_lmargin(stream, (size_t )old_lm);
#line 1229
  argp_fmtstream_set_wmargin(stream, (size_t )old_wm);
  }
#line 1230
  return;
}
}
#line 1233 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_help(struct hol *hol , struct argp_state  const  *state , argp_fmtstream_t stream ) 
{ 
  unsigned int num ;
  struct hol_entry *entry ;
  struct hol_help_state hhstate ;
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  struct argp  const  *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1239
  hhstate.prev_entry = (struct hol_entry *)0;
#line 1239
  hhstate.sep_groups = 0;
#line 1239
  hhstate.suppressed_dup_arg = 0;
#line 1241
  entry = hol->entries;
#line 1241
  num = hol->num_entries;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (num > 0U)) {
#line 1241
      goto while_break;
    }
    {
#line 1242
    hol_entry_help(entry, state, stream, & hhstate);
#line 1241
    entry ++;
#line 1241
    num --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if (hhstate.suppressed_dup_arg) {
#line 1244
    if (uparams.dup_args_note) {
      {
#line 1246
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 1246
      tstr = (char const   *)tmp;
      }
#line 1249
      if (state) {
#line 1249
        tmp___0 = state->root_argp;
      } else {
#line 1249
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1249
      tmp___1 = filter_doc(tstr, 33554437, (struct argp  const  *)tmp___0, state);
#line 1249
      fstr = tmp___1;
      }
#line 1251
      if (fstr) {
#line 1251
        if (*fstr) {
          {
#line 1253
          argp_fmtstream_putc(stream, '\n');
#line 1254
          argp_fmtstream_puts(stream, fstr);
#line 1255
          argp_fmtstream_putc(stream, '\n');
          }
        }
      }
#line 1257
      if (fstr) {
#line 1257
        if ((unsigned long )fstr != (unsigned long )tstr) {
          {
#line 1258
          free((void *)((char *)fstr));
          }
        }
      }
    }
  }
#line 1260
  return;
}
}
#line 1266 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int add_argless_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                 char const   *domain , void *cookie ) 
{ 
  char **snao_end ;
  char *tmp ;

  {
#line 1271
  snao_end = (char **)cookie;
#line 1272
  if (! opt->arg) {
#line 1272
    if (! real->arg) {
#line 1272
      if (! ((opt->flags | real->flags) & 16)) {
#line 1274
        tmp = *snao_end;
#line 1274
        (*snao_end) ++;
#line 1274
        *tmp = (char )opt->key;
      }
    }
  }
#line 1275
  return (0);
}
}
#line 1280 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int usage_argful_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                  char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1285
  stream = (argp_fmtstream_t )cookie;
#line 1286
  arg___0 = (char const   *)opt->arg;
#line 1287
  flags = (int )(opt->flags | real->flags);
#line 1289
  if (! arg___0) {
#line 1290
    arg___0 = (char const   *)real->arg;
  }
#line 1292
  if (arg___0) {
#line 1292
    if (! (flags & 16)) {
      {
#line 1294
      tmp = dgettext(domain, arg___0);
#line 1294
      arg___0 = (char const   *)tmp;
      }
#line 1296
      if (flags & 1) {
        {
#line 1297
        argp_fmtstream_printf(stream, " [-%c[%s]]", opt->key, arg___0);
        }
      } else {
        {
#line 1302
        tmp___0 = strlen(arg___0);
#line 1302
        space(stream, 6UL + tmp___0);
#line 1303
        argp_fmtstream_printf(stream, "[-%c %s]", opt->key, arg___0);
        }
      }
    }
  }
#line 1307
  return (0);
}
}
#line 1312 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int usage_long_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                          char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1317
  stream = (argp_fmtstream_t )cookie;
#line 1318
  arg___0 = (char const   *)opt->arg;
#line 1319
  flags = (int )(opt->flags | real->flags);
#line 1321
  if (! arg___0) {
#line 1322
    arg___0 = (char const   *)real->arg;
  }
#line 1324
  if (! (flags & 16)) {
#line 1324
    if (! (opt->flags & 8)) {
#line 1326
      if (arg___0) {
        {
#line 1328
        tmp = dgettext(domain, arg___0);
#line 1328
        arg___0 = (char const   *)tmp;
        }
#line 1329
        if (flags & 1) {
          {
#line 1330
          argp_fmtstream_printf(stream, " [--%s[=%s]]", opt->name, arg___0);
          }
        } else {
          {
#line 1332
          argp_fmtstream_printf(stream, " [--%s=%s]", opt->name, arg___0);
          }
        }
      } else {
        {
#line 1335
        argp_fmtstream_printf(stream, " [--%s]", opt->name);
        }
      }
    }
  }
#line 1338
  return (0);
}
}
#line 1342 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void hol_usage(struct hol *hol , argp_fmtstream_t stream ) 
{ 
  unsigned int nentries ;
  struct hol_entry *entry ;
  char *short_no_arg_opts ;
  size_t tmp ;
  void *tmp___0 ;
  char *snao_end ;
  char *tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 1345
  if (hol->num_entries > 0U) {
    {
#line 1349
    tmp = strlen((char const   *)hol->short_options);
#line 1349
    tmp___0 = __builtin_alloca(tmp + 1UL);
#line 1349
    short_no_arg_opts = (char *)tmp___0;
#line 1350
    snao_end = short_no_arg_opts;
#line 1353
    entry = hol->entries;
#line 1353
    nentries = hol->num_entries;
    }
    {
#line 1353
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1353
      if (! (nentries > 0U)) {
#line 1353
        goto while_break;
      }
      {
#line 1356
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & add_argless_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)(& snao_end));
#line 1353
      entry ++;
#line 1353
      nentries --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1358
    if ((unsigned long )snao_end > (unsigned long )short_no_arg_opts) {
      {
#line 1360
      tmp___1 = snao_end;
#line 1360
      snao_end ++;
#line 1360
      *tmp___1 = (char)0;
#line 1361
      argp_fmtstream_printf(stream, " [-%s]", short_no_arg_opts);
      }
    }
#line 1365
    entry = hol->entries;
#line 1365
    nentries = hol->num_entries;
    {
#line 1365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1365
      if (! (nentries > 0U)) {
#line 1365
        goto while_break___0;
      }
      {
#line 1368
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & usage_argful_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1365
      entry ++;
#line 1365
      nentries --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1372
    entry = hol->entries;
#line 1372
    nentries = hol->num_entries;
    {
#line 1372
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1372
      if (! (nentries > 0U)) {
#line 1372
        goto while_break___1;
      }
      {
#line 1375
      hol_entry_long_iterate((struct hol_entry  const  *)entry, & usage_long_opt,
                             (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1372
      entry ++;
#line 1372
      nentries --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1378
  return;
}
}
#line 1382 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static struct hol *argp_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  struct argp_child  const  *child ;
  struct hol *hol ;
  struct hol *tmp ;
  struct hol_cluster *child_cluster ;
  struct hol_cluster *tmp___0 ;
  struct hol_cluster *tmp___1 ;
  struct hol *tmp___2 ;

  {
  {
#line 1385
  child = (struct argp_child  const  *)argp___0->children;
#line 1386
  tmp = make_hol(argp___0, cluster);
#line 1386
  hol = tmp;
  }
#line 1387
  if (child) {
    {
#line 1388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1388
      if (! child->argp) {
#line 1388
        goto while_break;
      }
#line 1390
      if (child->group) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else
#line 1390
      if (child->header) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else {
#line 1390
        tmp___1 = cluster;
      }
      {
#line 1390
      child_cluster = tmp___1;
#line 1397
      tmp___2 = argp_hol((struct argp  const  *)child->argp, child_cluster);
#line 1397
      hol_append(hol, tmp___2);
#line 1398
      child ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1400
  return (hol);
}
}
#line 1405 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static size_t argp_args_levels(struct argp  const  *argp___0 ) 
{ 
  size_t levels ;
  struct argp_child  const  *child ;
  char *tmp ;
  struct argp_child  const  *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1408
  levels = (size_t )0;
#line 1409
  child = (struct argp_child  const  *)argp___0->children;
#line 1411
  if (argp___0->args_doc) {
    {
#line 1411
    tmp = strchr((char const   *)argp___0->args_doc, '\n');
    }
#line 1411
    if (tmp) {
#line 1412
      levels ++;
    }
  }
#line 1414
  if (child) {
    {
#line 1415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1415
      if (! child->argp) {
#line 1415
        goto while_break;
      }
      {
#line 1416
      tmp___0 = child;
#line 1416
      child ++;
#line 1416
      tmp___1 = argp_args_levels((struct argp  const  *)tmp___0->argp);
#line 1416
      levels += tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1418
  return (levels);
}
}
#line 1426 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int argp_args_usage(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                           char **levels , int advance , argp_fmtstream_t stream ) 
{ 
  char *our_level ;
  int multiple ;
  struct argp_child  const  *child ;
  char const   *tdoc ;
  char *tmp ;
  char const   *nl ;
  char const   *fdoc ;
  char const   *tmp___0 ;
  char const   *cp ;
  char *tmp___1 ;
  int i ;
  char *tmp___2 ;
  struct argp_child  const  *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1430
  our_level = *levels;
#line 1431
  multiple = 0;
#line 1432
  child = (struct argp_child  const  *)argp___0->children;
#line 1433
  tmp = dgettext((char const   *)argp___0->argp_domain, (char const   *)argp___0->args_doc);
#line 1433
  tdoc = (char const   *)tmp;
#line 1433
  nl = (char const   *)0;
#line 1434
  tmp___0 = filter_doc(tdoc, 33554438, argp___0, state);
#line 1434
  fdoc = tmp___0;
  }
#line 1436
  if (fdoc) {
    {
#line 1438
    cp = fdoc;
#line 1439
    tmp___1 = strchrnul(cp, '\n');
#line 1439
    nl = (char const   *)tmp___1;
    }
#line 1440
    if ((int const   )*nl != 0) {
#line 1445
      multiple = 1;
#line 1446
      i = 0;
      {
#line 1446
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1446
        if (! (i < (int )*our_level)) {
#line 1446
          goto while_break;
        }
        {
#line 1447
        cp = nl + 1;
#line 1447
        tmp___2 = strchrnul(cp, '\n');
#line 1447
        nl = (char const   *)tmp___2;
#line 1446
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1448
      (*levels) ++;
    }
    {
#line 1453
    space(stream, (size_t )((nl + 1) - cp));
#line 1455
    argp_fmtstream_write(stream, cp, (size_t )(nl - cp));
    }
  }
#line 1457
  if (fdoc) {
#line 1457
    if ((unsigned long )fdoc != (unsigned long )tdoc) {
      {
#line 1458
      free((void *)((char *)fdoc));
      }
    }
  }
#line 1460
  if (child) {
    {
#line 1461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1461
      if (! child->argp) {
#line 1461
        goto while_break___0;
      }
      {
#line 1462
      tmp___3 = child;
#line 1462
      child ++;
#line 1462
      tmp___4 = argp_args_usage((struct argp  const  *)tmp___3->argp, state, levels,
                                advance, stream);
      }
#line 1462
      if (tmp___4) {
#line 1462
        tmp___5 = 0;
      } else {
#line 1462
        tmp___5 = 1;
      }
#line 1462
      advance = tmp___5;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1464
  if (advance) {
#line 1464
    if (multiple) {
#line 1467
      if (*nl) {
#line 1470
        *our_level = (char )((int )*our_level + 1);
#line 1471
        advance = 0;
      } else
#line 1473
      if ((int )*our_level > 0) {
#line 1475
        *our_level = (char)0;
      }
    }
  }
#line 1478
  return (! advance);
}
}
#line 1488 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static int argp_doc(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                    int post , int pre_blank , int first_only , argp_fmtstream_t stream ) 
{ 
  char const   *text ;
  char const   *inp_text ;
  size_t inp_text_len ;
  char const   *trans_text ;
  void *input ;
  int anything ;
  struct argp_child  const  *child ;
  char *vt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  struct argp_child  const  *tmp___8 ;
  int tmp___9 ;

  {
#line 1495
  inp_text_len = (size_t )0;
#line 1497
  input = (void *)0;
#line 1498
  anything = 0;
#line 1499
  child = (struct argp_child  const  *)argp___0->children;
#line 1501
  if (argp___0->doc) {
    {
#line 1503
    tmp = strchr((char const   *)argp___0->doc, '\v');
#line 1503
    vt = tmp;
    }
#line 1504
    if (vt) {
#line 1506
      if (post) {
#line 1507
        inp_text = (char const   *)(vt + 1);
      } else {
        {
#line 1510
        inp_text_len = (size_t )(vt - (char *)argp___0->doc);
#line 1511
        tmp___0 = strndup((char const   *)argp___0->doc, inp_text_len);
#line 1511
        inp_text = (char const   *)tmp___0;
        }
      }
    } else
#line 1515
    if (post) {
#line 1515
      inp_text = (char const   *)0;
    } else {
#line 1515
      inp_text = (char const   *)argp___0->doc;
    }
#line 1516
    if (inp_text) {
      {
#line 1516
      tmp___1 = dgettext((char const   *)argp___0->argp_domain, inp_text);
#line 1516
      trans_text = (char const   *)tmp___1;
      }
    } else {
#line 1516
      trans_text = (char const   *)((void *)0);
    }
  } else {
#line 1519
    inp_text = (char const   *)0;
#line 1519
    trans_text = inp_text;
  }
#line 1521
  if (argp___0->help_filter) {
    {
#line 1524
    input = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
    }
#line 1525
    if (post) {
#line 1525
      tmp___2 = 33554434;
    } else {
#line 1525
      tmp___2 = 33554433;
    }
    {
#line 1525
    tmp___3 = (*(argp___0->help_filter))(tmp___2, trans_text, input);
#line 1525
    text = (char const   *)tmp___3;
    }
  } else {
#line 1532
    text = trans_text;
  }
#line 1534
  if (text) {
#line 1536
    if (pre_blank) {
      {
#line 1537
      argp_fmtstream_putc(stream, '\n');
      }
    }
    {
#line 1539
    argp_fmtstream_puts(stream, text);
#line 1541
    tmp___4 = argp_fmtstream_point(stream);
    }
#line 1541
    if (tmp___4 > stream->lmargin) {
      {
#line 1542
      argp_fmtstream_putc(stream, '\n');
      }
    }
#line 1544
    anything = 1;
  }
#line 1547
  if (text) {
#line 1547
    if ((unsigned long )text != (unsigned long )trans_text) {
      {
#line 1548
      free((void *)((char *)text));
      }
    }
  }
#line 1550
  if (inp_text) {
#line 1550
    if (inp_text_len) {
      {
#line 1551
      free((void *)((char *)inp_text));
      }
    }
  }
#line 1553
  if (post) {
#line 1553
    if (argp___0->help_filter) {
      {
#line 1556
      tmp___5 = (*(argp___0->help_filter))(33554436, (char const   *)0, input);
#line 1556
      text = (char const   *)tmp___5;
      }
#line 1557
      if (text) {
#line 1559
        if (anything) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1559
        if (pre_blank) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        }
        {
#line 1561
        argp_fmtstream_puts(stream, text);
#line 1562
        free((void *)((char *)text));
#line 1563
        tmp___6 = argp_fmtstream_point(stream);
        }
#line 1563
        if (tmp___6 > stream->lmargin) {
          {
#line 1565
          argp_fmtstream_putc(stream, '\n');
          }
        }
#line 1566
        anything = 1;
      }
    }
  }
#line 1570
  if (child) {
    {
#line 1571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1571
      if (child->argp) {
#line 1571
        if (first_only) {
#line 1571
          if (anything) {
#line 1571
            goto while_break;
          }
        }
      } else {
#line 1571
        goto while_break;
      }
#line 1572
      if (anything) {
#line 1572
        tmp___7 = 1;
      } else
#line 1572
      if (pre_blank) {
#line 1572
        tmp___7 = 1;
      } else {
#line 1572
        tmp___7 = 0;
      }
      {
#line 1572
      tmp___8 = child;
#line 1572
      child ++;
#line 1572
      tmp___9 = argp_doc((struct argp  const  *)tmp___8->argp, state, post, tmp___7,
                         first_only, stream);
#line 1572
      anything |= tmp___9;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1577
  return (anything);
}
}
#line 1584 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
static void _help(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                  FILE *stream , unsigned int flags , char *name ) 
{ 
  int anything ;
  struct hol *hol ;
  argp_fmtstream_t fs ;
  int first_pattern ;
  int more_patterns ;
  size_t num_pattern_levels ;
  size_t tmp ;
  char *pattern_levels ;
  void *tmp___0 ;
  int old_lm ;
  int old_wm ;
  size_t tmp___1 ;
  char *levels ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1588
  anything = 0;
#line 1589
  hol = (struct hol *)0;
#line 1592
  if (! stream) {
#line 1593
    return;
  }
  {
#line 1596
  flockfile(stream);
  }
#line 1599
  if (! uparams.valid) {
    {
#line 1600
    fill_in_uparams(state);
    }
  }
  {
#line 1602
  fs = argp_make_fmtstream(stream, (size_t )0, (size_t )uparams.rmargin, (ssize_t )0);
  }
#line 1603
  if (! fs) {
    {
#line 1606
    funlockfile(stream);
    }
#line 1608
    return;
  }
#line 1611
  if (flags & 11U) {
    {
#line 1613
    hol = argp_hol(argp___0, (struct hol_cluster *)0);
#line 1616
    hol_set_group(hol, "help", -1);
#line 1617
    hol_set_group(hol, "version", -1);
#line 1619
    hol_sort(hol);
    }
  }
#line 1622
  if (flags & 3U) {
    {
#line 1625
    first_pattern = 1;
#line 1626
    tmp = argp_args_levels(argp___0);
#line 1626
    num_pattern_levels = tmp;
#line 1627
    tmp___0 = __builtin_alloca(num_pattern_levels);
#line 1627
    pattern_levels = (char *)tmp___0;
#line 1629
    memset((void *)pattern_levels, 0, num_pattern_levels);
    }
    {
#line 1631
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1634
      tmp___1 = argp_fmtstream_set_wmargin(fs, (size_t )uparams.usage_indent);
#line 1634
      old_wm = (int )tmp___1;
#line 1635
      levels = pattern_levels;
      }
#line 1637
      if (first_pattern) {
        {
#line 1638
        tmp___2 = dgettext((char const   *)argp___0->argp_domain, "Usage:");
#line 1638
        argp_fmtstream_printf(fs, "%s %s", tmp___2, name);
        }
      } else {
        {
#line 1642
        tmp___3 = dgettext((char const   *)argp___0->argp_domain, "  or: ");
#line 1642
        argp_fmtstream_printf(fs, "%s %s", tmp___3, name);
        }
      }
      {
#line 1648
      tmp___4 = argp_fmtstream_set_lmargin(fs, (size_t )uparams.usage_indent);
#line 1648
      old_lm = (int )tmp___4;
      }
#line 1650
      if (flags & 2U) {
#line 1653
        if (hol->num_entries > 0U) {
          {
#line 1654
          tmp___5 = dgettext((char const   *)argp___0->argp_domain, " [OPTION...]");
#line 1654
          argp_fmtstream_puts(fs, (char const   *)tmp___5);
          }
        }
      } else {
        {
#line 1660
        hol_usage(hol, fs);
#line 1661
        flags |= 2U;
        }
      }
      {
#line 1664
      more_patterns = argp_args_usage(argp___0, state, & levels, 1, fs);
#line 1666
      argp_fmtstream_set_wmargin(fs, (size_t )old_wm);
#line 1667
      argp_fmtstream_set_lmargin(fs, (size_t )old_lm);
#line 1669
      argp_fmtstream_putc(fs, '\n');
#line 1670
      anything = 1;
#line 1672
      first_pattern = 0;
      }
#line 1631
      if (! more_patterns) {
#line 1631
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1677
  if (flags & 16U) {
    {
#line 1678
    tmp___6 = argp_doc(argp___0, state, 0, 0, 1, fs);
#line 1678
    anything |= tmp___6;
    }
  }
#line 1680
  if (flags & 4U) {
    {
#line 1682
    tmp___7 = dgettext((char const   *)argp___0->argp_domain, "Try `%s --help\' or `%s --usage\' for more information.\n");
#line 1682
    argp_fmtstream_printf(fs, (char const   *)tmp___7, name, name);
#line 1685
    anything = 1;
    }
  }
#line 1688
  if (flags & 8U) {
#line 1692
    if (hol->num_entries > 0U) {
#line 1694
      if (anything) {
        {
#line 1695
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1696
      hol_help(hol, state, fs);
#line 1697
      anything = 1;
      }
    }
  }
#line 1701
  if (flags & 32U) {
    {
#line 1703
    tmp___8 = argp_doc(argp___0, state, 1, anything, 0, fs);
#line 1703
    anything |= tmp___8;
    }
  }
#line 1705
  if (flags & 64U) {
#line 1705
    if (argp_program_bug_address) {
#line 1707
      if (anything) {
        {
#line 1708
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1709
      tmp___9 = dgettext((char const   *)argp___0->argp_domain, "Report bugs to %s.\n");
#line 1709
      argp_fmtstream_printf(fs, (char const   *)tmp___9, argp_program_bug_address);
#line 1712
      anything = 1;
      }
    }
  }
  {
#line 1716
  funlockfile(stream);
  }
#line 1719
  if (hol) {
    {
#line 1720
    hol_free(hol);
    }
  }
  {
#line 1722
  argp_fmtstream_free(fs);
  }
#line 1723
  return;
}
}
#line 1727 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) 
{ 
  struct argp_state state ;
  void *__cil_tmp6 ;

  {
  {
#line 1731
  memset((void *)(& state), 0, sizeof(state));
#line 1732
  state.root_argp = (struct argp  const  *)argp___0;
#line 1733
  _help((struct argp  const  *)argp___0, (struct argp_state  const  *)(& state), (FILE *)stream,
        flags, (char *)name);
  }
#line 1734
  return;
}
}
#line 1759 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) 
{ 
  char *tmp ;
  struct argp  const  *tmp___0 ;

  {
#line 1762
  if (! state) {
#line 1762
    goto _L___0;
  } else
#line 1762
  if (! (state->flags & 2U)) {
    _L___0: /* CIL Label */ 
#line 1762
    if (stream) {
#line 1764
      if (state) {
#line 1764
        if (state->flags & 64U) {
#line 1765
          flags |= 128U;
        }
      }
#line 1767
      if (state) {
#line 1767
        tmp = state->name;
      } else {
#line 1767
        tmp = (char */* const  */)program_invocation_short_name;
      }
#line 1767
      if (state) {
#line 1767
        tmp___0 = state->root_argp;
      } else {
#line 1767
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1767
      _help((struct argp  const  *)tmp___0, (struct argp_state  const  *)state, (FILE *)stream,
            flags, (char *)tmp);
      }
#line 1770
      if (! state) {
#line 1770
        goto _L;
      } else
#line 1770
      if (! (state->flags & 32U)) {
        _L: /* CIL Label */ 
#line 1772
        if (flags & 256U) {
          {
#line 1773
          exit(argp_err_exit_status);
          }
        }
#line 1774
        if (flags & 512U) {
          {
#line 1775
          exit(0);
          }
        }
      }
    }
  }
#line 1778
  return;
}
}
#line 1786 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
#line 1789
  if (! state) {
#line 1789
    goto _L;
  } else
#line 1789
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1791
    if (state) {
#line 1791
      tmp = state->err_stream;
    } else {
#line 1791
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1791
    stream = (FILE *)tmp;
#line 1793
    if (stream) {
      {
#line 1798
      flockfile(stream);
#line 1801
      __builtin_va_start(ap, fmt);
      }
#line 1820
      if (state) {
#line 1820
        tmp___0 = state->name;
      } else {
#line 1820
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1820
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 1823
      fputc_unlocked(':', stream);
#line 1824
      fputc_unlocked(' ', stream);
#line 1826
      vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1828
      fputc_unlocked('\n', stream);
#line 1831
      argp_state_help(state, (FILE */* __restrict  */)stream, 260U);
#line 1833
      __builtin_va_end(ap);
#line 1836
      funlockfile(stream);
      }
    }
  }
#line 1840
  return;
}
}
#line 1853 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-help.c"
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  va_list ap ;
  char buf[200] ;
  char const   *s ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1857
  if (! state) {
#line 1857
    goto _L;
  } else
#line 1857
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1859
    if (state) {
#line 1859
      tmp = state->err_stream;
    } else {
#line 1859
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1859
    stream = (FILE *)tmp;
#line 1861
    if (stream) {
      {
#line 1864
      flockfile(stream);
      }
#line 1873
      if (state) {
#line 1873
        tmp___0 = state->name;
      } else {
#line 1873
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1873
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
      }
#line 1877
      if (fmt) {
        {
#line 1881
        __builtin_va_start(ap, fmt);
#line 1897
        fputc_unlocked(':', stream);
#line 1898
        fputc_unlocked(' ', stream);
#line 1900
        vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1903
        __builtin_va_end(ap);
        }
      }
#line 1906
      if (errnum) {
        {
#line 1917
        s = (char const   *)((void *)0);
#line 1918
        fputc_unlocked(':', stream);
#line 1919
        fputc_unlocked(' ', stream);
#line 1921
        tmp___1 = strerror_r(errnum, buf, sizeof(buf));
#line 1921
        s = (char const   *)tmp___1;
        }
#line 1927
        if (! s) {
          {
#line 1927
          tmp___3 = strerror(errnum);
#line 1927
          s = (char const   *)tmp___3;
          }
#line 1927
          if (! s) {
            {
#line 1928
            tmp___2 = dgettext((char const   *)(state->root_argp)->argp_domain, "Unknown system error");
#line 1928
            s = (char const   *)tmp___2;
            }
          }
        }
        {
#line 1931
        fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stream);
        }
      }
      {
#line 1940
      fputc_unlocked('\n', stream);
#line 1943
      funlockfile(stream);
      }
#line 1946
      if (status) {
#line 1946
        if (! state) {
          {
#line 1947
          exit(status);
          }
        } else
#line 1946
        if (! (state->flags & 32U)) {
          {
#line 1947
          exit(status);
          }
        }
      }
    }
  }
#line 1950
  return;
}
}
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#line 356 "/usr/include/stdio.h"
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 367
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
#line 376
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) __asprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt 
                                                , ...) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) asprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt 
                                              , ...) ;
#line 394
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) vdprintf)(int __fd , char const   * __restrict  __fmt , __gnuc_va_list __ap ) ;
#line 397
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) dprintf)(int __fd , char const   * __restrict  __fmt  , ...) ;
#line 604
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fgets)(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 622
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fgets_unlocked)(char * __restrict  __s , int __n ,
                                                    FILE * __restrict  __stream ) ;
#line 682
__inline extern size_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fread)(void * __restrict  __ptr , size_t __size ,
                                           size_t __n , FILE * __restrict  __stream ) ;
#line 710
__inline extern size_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr , size_t __size ,
                                                    size_t __n , FILE * __restrict  __stream ) ;
#line 872
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt 
                                    , ...) ;
#line 875
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
#line 31 "/usr/include/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 31 "/usr/include/bits/stdio2.h"
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                          char const   * __restrict  __fmt 
                                                                                                          , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp = __builtin_object_size((void *)__s, 1);
#line 34
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
  }
#line 34
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 43
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 43 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 47
  tmp = __builtin_object_size((void *)__s, 1);
#line 47
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
  }
#line 47
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 61
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) ;
#line 61 "/usr/include/bits/stdio2.h"
extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 65
  tmp = __builtin_object_size((void *)__s, 1);
#line 65
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
  }
#line 65
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 74
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
#line 74 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 78
  tmp = __builtin_object_size((void *)__s, 1);
#line 78
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
  }
#line 78
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 86
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 88
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 89
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 91
extern int __vprintf_chk(int __flag , char const   * __restrict  __format , __gnuc_va_list __ap ) ;
#line 95 "/usr/include/bits/stdio2.h"
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                          char const   * __restrict  __fmt 
                                                                                                          , ...) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
  }
#line 98
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 102 "/usr/include/bits/stdio2.h"
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
  {
#line 105
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
  }
#line 105
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 114 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) vprintf)(char const   * __restrict  __fmt , __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 120
  tmp = __vprintf_chk(1, __fmt, __ap);
  }
#line 120
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 124 "/usr/include/bits/stdio2.h"
extern int __attribute__((__gnu_inline__))  ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 128
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 133
extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__)) __asprintf_chk)(char ** __restrict  __ptr ,
                                                                                                                          int __flag ,
                                                                                                                          char const   * __restrict  __fmt 
                                                                                                                          , ...) ;
#line 136
extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__)) __vasprintf_chk)(char ** __restrict  __ptr ,
                                                                                                                           int __flag ,
                                                                                                                           char const   * __restrict  __fmt ,
                                                                                                                           __gnuc_va_list __arg ) ;
#line 139
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 141
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( /* format attribute */  __obstack_printf_chk)(struct obstack * __restrict  __obstack ,
                                                                                         int __flag ,
                                                                                         char const   * __restrict  __format 
                                                                                         , ...) ;
#line 148
extern  __attribute__((__nothrow__)) int ( /* format attribute */  __obstack_vprintf_chk)(struct obstack * __restrict  __obstack ,
                                                                                          int __flag ,
                                                                                          char const   * __restrict  __format ,
                                                                                          __gnuc_va_list __args ) ;
#line 155
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) asprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt 
                                              , ...) ;
#line 155 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) asprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt 
                                              , ...) 
{ 
  int tmp ;

  {
  {
#line 158
  tmp = __asprintf_chk(__ptr, 1, __fmt, __builtin_va_arg_pack());
  }
#line 158
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 170 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) dprintf)(int __fd , char const   * __restrict  __fmt  , ...) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
  }
#line 173
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 177
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt 
                                    , ...) ;
#line 177 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt 
                                    , ...) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = __obstack_printf_chk(__obstack, 1, __fmt, __builtin_va_arg_pack());
  }
#line 181
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 195
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 195 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 199
  tmp = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 199
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 202 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) vdprintf)(int __fd , char const   * __restrict  __fmt , __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 205
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 205
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 208
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
#line 208 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__artificial__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
  {
#line 212
  tmp = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 212
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 233
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 235
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 238
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 244 "/usr/include/bits/stdio2.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fgets)(char * __restrict  __s , int __n , FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 247
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
#line 247
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 250
    tmp = __builtin_object_size((void *)__s, 1);
#line 250
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
    }
#line 250
    return ((char __attribute__((__gnu_inline__))  *)tmp___0);
    {
#line 252
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
#line 252
    if ((size_t )__n > tmp___3) {
      {
#line 253
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 253
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
      }
#line 253
      return ((char __attribute__((__gnu_inline__))  *)tmp___2);
    }
  }
  {
#line 255
  tmp___5 = __fgets_alias(__s, __n, __stream);
  }
#line 255
  return ((char __attribute__((__gnu_inline__))  *)tmp___5);
}
}
#line 258
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 261
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 265
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 273 "/usr/include/bits/stdio2.h"
__inline extern size_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fread)(void * __restrict  __ptr , size_t __size ,
                                           size_t __n , FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 277
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  }
#line 277
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 282
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 282
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
    }
#line 282
    return ((size_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 284
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    }
#line 284
    if (__size * __n > tmp___3) {
      {
#line 285
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 285
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      }
#line 285
      return ((size_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 287
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 287
  return ((size_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 291
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char * __restrict  __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE * __restrict  __stream ) ;
#line 293
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict  __s ,
                                                                               int __n ,
                                                                               FILE * __restrict  __stream )  __asm__("fgets_unlocked")  ;
#line 296
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict  __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))) ;
#line 302 "/usr/include/bits/stdio2.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fgets_unlocked)(char * __restrict  __s , int __n ,
                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 305
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
#line 305
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 308
    tmp = __builtin_object_size((void *)__s, 1);
#line 308
    tmp___0 = __fgets_unlocked_chk(__s, tmp, __n, __stream);
    }
#line 308
    return ((char __attribute__((__gnu_inline__))  *)tmp___0);
    {
#line 310
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
#line 310
    if ((size_t )__n > tmp___3) {
      {
#line 311
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 311
      tmp___2 = __fgets_unlocked_chk_warn(__s, tmp___1, __n, __stream);
      }
#line 311
      return ((char __attribute__((__gnu_inline__))  *)tmp___2);
    }
  }
  {
#line 313
  tmp___5 = __fgets_unlocked_alias(__s, __n, __stream);
  }
#line 313
  return ((char __attribute__((__gnu_inline__))  *)tmp___5);
}
}
#line 319
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 322
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 326
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 334 "/usr/include/bits/stdio2.h"
__inline extern size_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr , size_t __size ,
                                                    size_t __n , FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 338
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  }
#line 338
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 343
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 343
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
    }
#line 343
    return ((size_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 346
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    }
#line 346
    if (__size * __n > tmp___3) {
      {
#line 347
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 347
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      }
#line 347
      return ((size_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 372
  tmp___5 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 372
  return ((size_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 130 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) ;
#line 135
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 138
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) bcopy)(void const   * __restrict  __src , void * __restrict  __dest ,
                                           size_t __len ) ;
#line 457
__inline extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 569
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 577
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __n ) ;
#line 48 "/usr/include/bits/string3.h"
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                            size_t __len ) ;
#line 48 "/usr/include/bits/string3.h"
extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2), __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  {
#line 52
  tmp = __builtin_object_size((void *)__dest, 0);
#line 52
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
  }
#line 52
  return ((void __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 55
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) memmove)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
#line 55 "/usr/include/bits/string3.h"
extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2), __artificial__,
__always_inline__)) memmove)(void * __restrict  __dest , void const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  {
#line 59
  tmp = __builtin_object_size((void *)__dest, 0);
#line 59
  tmp___0 = __builtin___memmove_chk((void *)__dest, (void const   *)__src, __len,
                                    tmp);
  }
#line 59
  return ((void __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 63
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) mempcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
#line 63 "/usr/include/bits/string3.h"
extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2), __artificial__,
__always_inline__)) mempcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  {
#line 67
  tmp = __builtin_object_size((void *)__dest, 0);
#line 67
  tmp___0 = __builtin___mempcpy_chk((void *)__dest, (void const   *)__src, __len,
                                    tmp);
  }
#line 67
  return ((void __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 77 "/usr/include/bits/string3.h"
extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1), __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = __builtin_object_size(__dest, 0);
#line 86
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
  }
#line 86
  return ((void __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 90
__inline extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) bcopy)(void const   * __restrict  __src , void * __restrict  __dest ,
                                           size_t __len ) ;
#line 90 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) bcopy)(void const   * __restrict  __src , void * __restrict  __dest ,
                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
  {
#line 94
  tmp = __builtin_object_size((void *)__dest, 0);
#line 94
  __builtin___memmove_chk((void *)__dest, (void const   *)__src, __len, tmp);
  }
#line 95
  return;
}
}
#line 97
__inline extern  __attribute__((__nothrow__)) void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 97 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
  {
#line 100
  tmp = __builtin_object_size(__dest, 0);
#line 100
  __builtin___memset_chk(__dest, '\000', __len, tmp);
  }
#line 101
  return;
}
}
#line 104
extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 104 "/usr/include/bits/string3.h"
extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2), __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  {
#line 107
  tmp = __builtin_object_size((void *)__dest, 1);
#line 107
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
  }
#line 107
  return ((char __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 111
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 111 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  {
#line 114
  tmp = __builtin_object_size((void *)__dest, 1);
#line 114
  tmp___0 = __builtin___stpcpy_chk((char *)__dest, (char const   *)__src, tmp);
  }
#line 114
  return ((char __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 119
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) ;
#line 119 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  {
#line 123
  tmp = __builtin_object_size((void *)__dest, 1);
#line 123
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
  }
#line 123
  return ((char __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 127
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 129
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n )  __asm__("stpncpy")  ;
#line 133
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __n ) ;
#line 133 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 136
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
#line 136
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
#line 138
    tmp = __builtin_object_size((void *)__dest, 1);
#line 138
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
    }
#line 138
    return ((char __attribute__((__gnu_inline__))  *)tmp___0);
  }
  {
#line 139
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
  }
#line 139
  return ((char __attribute__((__gnu_inline__))  *)tmp___3);
}
}
#line 143
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 143 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  {
#line 146
  tmp = __builtin_object_size((void *)__dest, 1);
#line 146
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
  }
#line 146
  return ((char __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) ;
#line 150 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2),
__artificial__, __always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  {
#line 154
  tmp = __builtin_object_size((void *)__dest, 1);
#line 154
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
  }
#line 154
  return ((char __attribute__((__gnu_inline__))  *)tmp___0);
}
}
#line 373 "/usr/include/unistd.h"
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes ,
                                           __off_t __offset ) ;
#line 401
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes ,
                                             __off64_t __offset ) ;
#line 520
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__,
__deprecated__))  *( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 618
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 706
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 790
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2), __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
#line 825
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
#line 873
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 913
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
#line 24 "/usr/include/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 26
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 28
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 34 "/usr/include/bits/unistd.h"
extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 37
  tmp___4 = __builtin_object_size(__buf, 0);
  }
#line 37
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 40
    tmp = __builtin_object_size(__buf, 0);
#line 40
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    }
#line 40
    return ((ssize_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 42
    tmp___3 = __builtin_object_size(__buf, 0);
    }
#line 42
    if (__nbytes > tmp___3) {
      {
#line 43
      tmp___1 = __builtin_object_size(__buf, 0);
#line 43
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      }
#line 43
      return ((ssize_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 45
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  }
#line 45
  return ((ssize_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 49
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) ;
#line 51
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize ) ;
#line 53
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset )  __asm__("pread")  ;
#line 56
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset )  __asm__("pread64")  ;
#line 59
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize )  __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"))) ;
#line 64
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize )  __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"))) ;
#line 72 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes ,
                                           __off_t __offset ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 75
  tmp___4 = __builtin_object_size(__buf, 0);
  }
#line 75
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 78
    tmp = __builtin_object_size(__buf, 0);
#line 78
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
    }
#line 78
    return ((ssize_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 80
    tmp___3 = __builtin_object_size(__buf, 0);
    }
#line 80
    if (__nbytes > tmp___3) {
      {
#line 81
      tmp___1 = __builtin_object_size(__buf, 0);
#line 81
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      }
#line 81
      return ((ssize_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 84
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
#line 84
  return ((ssize_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 105 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes ,
                                             __off64_t __offset ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 108
  tmp___4 = __builtin_object_size(__buf, 0);
  }
#line 108
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 111
    tmp = __builtin_object_size(__buf, 0);
#line 111
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
    }
#line 111
    return ((ssize_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 113
    tmp___3 = __builtin_object_size(__buf, 0);
    }
#line 113
    if (__nbytes > tmp___3) {
      {
#line 114
      tmp___1 = __builtin_object_size(__buf, 0);
#line 114
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      }
#line 114
      return ((ssize_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 118
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
#line 118
  return ((ssize_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 124
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                   size_t __len , size_t __buflen ) ;
#line 128
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_alias)(char const   * __restrict  __path , char * __restrict  __buf ,
                                     size_t __len )  __asm__("readlink")  ;
#line 132
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk_warn)(char const   * __restrict  __path , char * __restrict  __buf ,
                                        size_t __len , size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
#line 139 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 143
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 143
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 146
    tmp = __builtin_object_size((void *)__buf, 1);
#line 146
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
    }
#line 146
    return ((ssize_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 148
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 148
    if (__len > tmp___3) {
      {
#line 149
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 149
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
      }
#line 149
      return ((ssize_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 151
  tmp___5 = __readlink_alias(__path, __buf, __len);
  }
#line 151
  return ((ssize_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 156
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                     char * __restrict  __buf , size_t __len , size_t __buflen ) ;
#line 160
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                       char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 165
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                          char * __restrict  __buf , size_t __len ,
                                          size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
#line 173 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 177
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 177
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 180
    tmp = __builtin_object_size((void *)__buf, 1);
#line 180
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
    }
#line 180
    return ((ssize_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 182
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 182
    if (__len > tmp___3) {
      {
#line 183
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 183
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
      }
#line 183
      return ((ssize_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 186
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 186
  return ((ssize_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 190
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk)(char *__buf ,
                                                                                                   size_t __size ,
                                                                                                   size_t __buflen ) ;
#line 192
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_alias)(char *__buf ,
                                                                                                     size_t __size )  __asm__("getcwd")  ;
#line 194
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk_warn)(char *__buf ,
                                                                                                        size_t __size ,
                                                                                                        size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 200
extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 200 "/usr/include/bits/unistd.h"
extern char __attribute__((__gnu_inline__))  *( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 203
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 203
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 206
    tmp = __builtin_object_size((void *)__buf, 1);
#line 206
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    }
#line 206
    return ((char __attribute__((__gnu_inline__))  *)tmp___0);
    {
#line 208
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 208
    if (__size > tmp___3) {
      {
#line 209
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 209
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      }
#line 209
      return ((char __attribute__((__gnu_inline__))  *)tmp___2);
    }
  }
  {
#line 211
  tmp___5 = __getcwd_alias(__buf, __size);
  }
#line 211
  return ((char __attribute__((__gnu_inline__))  *)tmp___5);
}
}
#line 215
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 217
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char __attribute__((__gnu_inline__,
__deprecated__))  *( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 221 "/usr/include/bits/unistd.h"
__inline extern char __attribute__((__gnu_inline__, __deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 224
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  }
#line 224
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
#line 225
    tmp = __builtin_object_size((void *)__buf, 1);
#line 225
    tmp___0 = __getwd_chk(__buf, tmp);
    }
#line 225
    return ((char __attribute__((__gnu_inline__, __deprecated__))  *)tmp___0);
  }
  {
#line 226
  tmp___2 = __getwd_warn(__buf);
  }
#line 226
  return ((char __attribute__((__gnu_inline__, __deprecated__))  *)tmp___2);
}
}
#line 230
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 232
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len )  __asm__("confstr")  ;
#line 234
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 240 "/usr/include/bits/unistd.h"
__inline extern size_t __attribute__((__gnu_inline__))  ( __attribute__((__artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 243
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 243
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 246
    tmp = __builtin_object_size((void *)__buf, 1);
#line 246
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    }
#line 246
    return ((size_t __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 248
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 248
    if (tmp___3 < __len) {
      {
#line 249
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 249
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      }
#line 249
      return ((size_t __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 251
  tmp___5 = __confstr_alias(__name, __buf, __len);
  }
#line 251
  return ((size_t __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 255
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk)(int __size ,
                                                                                                    __gid_t *__list ,
                                                                                                    size_t __listlen ) ;
#line 257
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_alias)(int __size ,
                                                                                                      __gid_t *__list )  __asm__("getgroups")  ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk_warn)(int __size ,
                                                                                                         __gid_t *__list ,
                                                                                                         size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 265 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 268
  tmp___4 = __builtin_object_size((void *)__list, 1);
  }
#line 268
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 271
    tmp = __builtin_object_size((void *)__list, 1);
#line 271
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    }
#line 271
    return ((int __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 273
    tmp___3 = __builtin_object_size((void *)__list, 1);
    }
#line 273
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      {
#line 274
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 274
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      }
#line 274
      return ((int __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 276
  tmp___5 = __getgroups_alias(__size, __list);
  }
#line 276
  return ((int __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk)(int __fd ,
                                                                                            char *__buf ,
                                                                                            size_t __buflen ,
                                                                                            size_t __nreal ) ;
#line 282
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_alias)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen )  __asm__("ttyname_r")  ;
#line 285
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk_warn)(int __fd ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen ,
                                                                                                 size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2), __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
#line 291 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(2), __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 294
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 294
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 297
    tmp = __builtin_object_size((void *)__buf, 1);
#line 297
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    }
#line 297
    return ((int __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 299
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 299
    if (__buflen > tmp___3) {
      {
#line 300
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 300
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      }
#line 300
      return ((int __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 302
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 302
  return ((int __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 307
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 309
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 311
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 317 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 320
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 320
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 323
    tmp = __builtin_object_size((void *)__buf, 1);
#line 323
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    }
#line 323
    return ((int __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 325
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 325
    if (__buflen > tmp___3) {
      {
#line 326
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 326
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      }
#line 326
      return ((int __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 328
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  }
#line 328
  return ((int __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 334
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk)(char *__buf ,
                                                                                              size_t __buflen ,
                                                                                              size_t __nreal ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_alias)(char *__buf ,
                                                                                                size_t __buflen )  __asm__("gethostname")  ;
#line 338
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk_warn)(char *__buf ,
                                                                                                   size_t __buflen ,
                                                                                                   size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 344 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1),
__artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 347
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 347
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 350
    tmp = __builtin_object_size((void *)__buf, 1);
#line 350
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    }
#line 350
    return ((int __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 352
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 352
    if (__buflen > tmp___3) {
      {
#line 353
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 353
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      }
#line 353
      return ((int __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 355
  tmp___5 = __gethostname_alias(__buf, __buflen);
  }
#line 355
  return ((int __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 361
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 363
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 366
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk_warn)(char *__buf , size_t __buflen , size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
#line 373 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 376
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
#line 376
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
#line 379
    tmp = __builtin_object_size((void *)__buf, 1);
#line 379
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    }
#line 379
    return ((int __attribute__((__gnu_inline__))  )tmp___0);
    {
#line 381
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
#line 381
    if (__buflen > tmp___3) {
      {
#line 382
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 382
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      }
#line 382
      return ((int __attribute__((__gnu_inline__))  )tmp___2);
    }
  }
  {
#line 384
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  }
#line 384
  return ((int __attribute__((__gnu_inline__))  )tmp___5);
}
}
#line 184 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
void _argp_fmtstream_update(argp_fmtstream_t fs ) ;
#line 186
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) ;
#line 259 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str , size_t __len ) 
{ 
  int tmp ;

  {
#line 263
  if ((unsigned long )(__fs->p + __len) <= (unsigned long )__fs->end) {
    {
#line 265
    memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
           __len);
#line 266
    __fs->p += __len;
    }
#line 267
    return (__len);
  } else {
    {
#line 263
    tmp = _argp_fmtstream_ensure(__fs, __len);
    }
#line 263
    if (tmp) {
      {
#line 265
      memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
             __len);
#line 266
      __fs->p += __len;
      }
#line 267
      return (__len);
    } else {
#line 270
      return ((size_t )0);
    }
  }
}
}
#line 273 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) 
{ 
  size_t __len ;
  size_t tmp ;
  size_t __wrote ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 276
  tmp = strlen(__str);
#line 276
  __len = tmp;
  }
#line 277
  if (__len) {
    {
#line 279
    tmp___0 = argp_fmtstream_write(__fs, __str, __len);
#line 279
    __wrote = tmp___0;
    }
#line 280
    if (__wrote == __len) {
#line 280
      tmp___1 = 0;
    } else {
#line 280
      tmp___1 = -1;
    }
#line 280
    return (tmp___1);
  } else {
#line 283
    return (0);
  }
}
}
#line 286 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) 
{ 
  char *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 289
  if ((unsigned long )__fs->p < (unsigned long )__fs->end) {
#line 290
    tmp = __fs->p;
#line 290
    (__fs->p) ++;
#line 290
    tmp___0 = (char )__ch;
#line 290
    *tmp = tmp___0;
#line 290
    return ((int )tmp___0);
  } else {
    {
#line 289
    tmp___1 = _argp_fmtstream_ensure(__fs, (size_t )1);
    }
#line 289
    if (tmp___1) {
#line 290
      tmp = __fs->p;
#line 290
      (__fs->p) ++;
#line 290
      tmp___0 = (char )__ch;
#line 290
      *tmp = tmp___0;
#line 290
      return ((int )tmp___0);
    } else {
#line 292
      return (-1);
    }
  }
}
}
#line 296 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) 
{ 
  size_t __old ;

  {
#line 300
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 301
    _argp_fmtstream_update(__fs);
    }
  }
#line 302
  __old = __fs->lmargin;
#line 303
  __fs->lmargin = __lmargin;
#line 304
  return (__old);
}
}
#line 308 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_rmargin(argp_fmtstream_t __fs , size_t __rmargin ) 
{ 
  size_t __old ;

  {
#line 312
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 313
    _argp_fmtstream_update(__fs);
    }
  }
#line 314
  __old = __fs->rmargin;
#line 315
  __fs->rmargin = __rmargin;
#line 316
  return (__old);
}
}
#line 320 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) 
{ 
  size_t __old ;

  {
#line 324
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 325
    _argp_fmtstream_update(__fs);
    }
  }
#line 326
  __old = (size_t )__fs->wmargin;
#line 327
  __fs->wmargin = (ssize_t )__wmargin;
#line 328
  return (__old);
}
}
#line 332 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.h"
size_t argp_fmtstream_point(argp_fmtstream_t __fs ) 
{ 
  ssize_t tmp ;

  {
#line 335
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 336
    _argp_fmtstream_update(__fs);
    }
  }
#line 337
  if (__fs->point_col >= 0L) {
#line 337
    tmp = __fs->point_col;
  } else {
#line 337
    tmp = (ssize_t )0;
  }
#line 337
  return ((size_t )tmp);
}
}
#line 712 "/usr/include/stdio.h"
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.c"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) 
{ 
  argp_fmtstream_t fs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 65
  tmp = malloc(sizeof(struct argp_fmtstream ));
#line 65
  fs = (struct argp_fmtstream *)tmp;
  }
#line 66
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 68
    fs->stream = stream;
#line 70
    fs->lmargin = lmargin;
#line 71
    fs->rmargin = rmargin;
#line 72
    fs->wmargin = wmargin;
#line 73
    fs->point_col = (ssize_t )0;
#line 74
    fs->point_offs = (size_t )0;
#line 76
    tmp___0 = malloc((size_t )200);
#line 76
    fs->buf = (char *)tmp___0;
    }
#line 77
    if (! fs->buf) {
      {
#line 79
      free((void *)fs);
#line 80
      fs = (argp_fmtstream_t )0;
      }
    } else {
#line 84
      fs->p = fs->buf;
#line 85
      fs->end = fs->buf + 200;
    }
  }
#line 89
  return (fs);
}
}
#line 99 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.c"
void argp_fmtstream_free(argp_fmtstream_t fs ) 
{ 


  {
  {
#line 102
  _argp_fmtstream_update(fs);
  }
#line 103
  if ((unsigned long )fs->p > (unsigned long )fs->buf) {
    {
#line 108
    fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                    (FILE */* __restrict  */)fs->stream);
    }
  }
  {
#line 111
  free((void *)fs->buf);
#line 112
  free((void *)fs);
  }
#line 113
  return;
}
}
#line 123 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.c"
void _argp_fmtstream_update(argp_fmtstream_t fs ) 
{ 
  char *buf ;
  char *nl ;
  size_t len ;
  size_t r ;
  size_t pad ;
  size_t i ;
  void *tmp ;
  char *p ;
  char *nextline ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t mv ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 130
  buf = fs->buf + fs->point_offs;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )buf < (unsigned long )fs->p)) {
#line 131
      goto while_break;
    }
#line 135
    if (fs->point_col == 0L) {
#line 135
      if (fs->lmargin != 0UL) {
#line 138
        pad = fs->lmargin;
#line 139
        if ((unsigned long )(fs->p + pad) < (unsigned long )fs->end) {
          {
#line 143
          memmove((void *)(buf + pad), (void const   *)buf, (size_t )(fs->p - buf));
#line 144
          fs->p += pad;
#line 145
          memset((void *)buf, ' ', pad);
#line 146
          buf += pad;
          }
        } else {
#line 152
          i = (size_t )0;
          {
#line 152
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 152
            if (! (i < pad)) {
#line 152
              goto while_break___0;
            }
            {
#line 159
            fputc_unlocked(' ', fs->stream);
#line 152
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 162
        fs->point_col = (ssize_t )pad;
      }
    }
    {
#line 165
    len = (size_t )(fs->p - buf);
#line 166
    tmp = memchr((void const   *)buf, '\n', len);
#line 166
    nl = (char *)tmp;
    }
#line 168
    if (fs->point_col < 0L) {
#line 169
      fs->point_col = (ssize_t )0;
    }
#line 171
    if (! nl) {
#line 175
      if ((size_t )fs->point_col + len < fs->rmargin) {
#line 180
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 181
        goto while_break;
      } else {
#line 186
        nl = fs->p;
      }
    } else
#line 188
    if (fs->point_col + (nl - buf) < (ssize_t )fs->rmargin) {
#line 192
      fs->point_col = (ssize_t )0;
#line 193
      buf = nl + 1;
#line 194
      goto while_continue;
    }
#line 198
    r = fs->rmargin - 1UL;
#line 200
    if (fs->wmargin < 0L) {
#line 204
      if ((unsigned long )nl < (unsigned long )fs->p) {
        {
#line 206
        memmove((void *)(buf + (r - (size_t )fs->point_col)), (void const   *)nl,
                (size_t )(fs->p - nl));
#line 207
        fs->p -= (buf + (r - (size_t )fs->point_col)) - nl;
#line 209
        fs->point_col = (ssize_t )0;
#line 210
        buf += r + 1UL;
        }
      } else {
#line 217
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 218
        fs->p -= (size_t )fs->point_col - r;
#line 219
        goto while_break;
      }
    } else {
#line 231
      p = buf + ((r + 1UL) - (size_t )fs->point_col);
      {
#line 232
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 232
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 232
          tmp___0 = __ctype_b_loc();
          }
#line 232
          if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 1) {
#line 232
            goto while_break___1;
          }
        } else {
#line 232
          goto while_break___1;
        }
#line 233
        p --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 234
      nextline = p + 1;
#line 236
      if ((unsigned long )nextline > (unsigned long )buf) {
#line 239
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 240
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 241
            p --;
#line 240
            if ((unsigned long )p >= (unsigned long )buf) {
              {
#line 240
              tmp___1 = __ctype_b_loc();
              }
#line 240
              if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 1)) {
#line 240
                goto while_break___2;
              }
            } else {
#line 240
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 243
        nl = p + 1;
      } else {
#line 249
        p = buf + ((r + 1UL) - (size_t )fs->point_col);
#line 251
        if ((unsigned long )p < (unsigned long )nl) {
          {
#line 252
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 253
            p ++;
#line 252
            if ((unsigned long )p < (unsigned long )nl) {
              {
#line 252
              tmp___2 = __ctype_b_loc();
              }
#line 252
              if ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 1) {
#line 252
                goto while_break___3;
              }
            } else {
#line 252
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 255
        if ((unsigned long )p == (unsigned long )nl) {
#line 258
          fs->point_col = (ssize_t )0;
#line 259
          buf = nl + 1;
#line 260
          goto while_continue;
        }
#line 263
        nl = p;
        {
#line 265
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 266
          p ++;
#line 265
          tmp___3 = __ctype_b_loc();
          }
#line 265
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 1)) {
#line 265
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 269
        nextline = p;
      }
#line 277
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 277
        tmp___6 = fs->end - nl < fs->wmargin + 1L;
      } else {
#line 277
        tmp___6 = nextline - (nl + 1) < fs->wmargin;
      }
#line 277
      if (tmp___6) {
#line 277
        if ((unsigned long )fs->p > (unsigned long )nextline) {
#line 283
          if (fs->end - fs->p > fs->wmargin + 1L) {
            {
#line 286
            mv = (size_t )(fs->p - nextline);
#line 287
            memmove((void *)((nl + 1) + fs->wmargin), (void const   *)nextline, mv);
#line 288
            nextline = (nl + 1) + fs->wmargin;
#line 289
            len = (size_t )((nextline + mv) - buf);
#line 290
            tmp___4 = nl;
#line 290
            nl ++;
#line 290
            *tmp___4 = (char )'\n';
            }
          } else {
#line 299
            if ((unsigned long )nl > (unsigned long )fs->buf) {
              {
#line 300
              fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1,
                              (size_t )(nl - fs->buf), (FILE */* __restrict  */)fs->stream);
              }
            }
            {
#line 301
            fputc_unlocked('\n', fs->stream);
#line 304
            len += (size_t )(buf - fs->buf);
#line 305
            buf = fs->buf;
#line 305
            nl = buf;
            }
          }
        } else {
#line 311
          tmp___5 = nl;
#line 311
          nl ++;
#line 311
          *tmp___5 = (char )'\n';
        }
      } else {
#line 311
        tmp___5 = nl;
#line 311
        nl ++;
#line 311
        *tmp___5 = (char )'\n';
      }
#line 313
      if (nextline - nl >= fs->wmargin) {
#line 313
        goto _L;
      } else
#line 313
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 313
        if (fs->end - nextline >= fs->wmargin) {
          _L: /* CIL Label */ 
#line 316
          i___0 = 0;
          {
#line 316
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 316
            if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 316
              goto while_break___5;
            }
#line 317
            tmp___7 = nl;
#line 317
            nl ++;
#line 317
            *tmp___7 = (char )' ';
#line 316
            i___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 313
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 319
        i___0 = 0;
        {
#line 319
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 319
          if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 319
            goto while_break___6;
          }
          {
#line 325
          fputc_unlocked(' ', fs->stream);
#line 319
          i___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 329
      if ((unsigned long )nl < (unsigned long )nextline) {
        {
#line 330
        memmove((void *)nl, (void const   *)nextline, (size_t )((buf + len) - nextline));
        }
      }
#line 331
      len -= (size_t )(nextline - buf);
#line 334
      buf = nl;
#line 337
      fs->p = nl + len;
#line 342
      if (fs->wmargin) {
#line 342
        fs->point_col = fs->wmargin;
      } else {
#line 342
        fs->point_col = (ssize_t )-1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  fs->point_offs = (size_t )(fs->p - fs->buf);
#line 348
  return;
}
}
#line 352 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.c"
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) 
{ 
  ssize_t wrote ;
  size_t tmp ;
  size_t old_size ;
  size_t new_size ;
  char *new_buf ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 355
  if ((size_t )(fs->end - fs->p) < amount) {
    {
#line 360
    _argp_fmtstream_update(fs);
#line 366
    tmp = fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                          (FILE */* __restrict  */)fs->stream);
#line 366
    wrote = (ssize_t )tmp;
    }
#line 368
    if (wrote == fs->p - fs->buf) {
#line 370
      fs->p = fs->buf;
#line 371
      fs->point_offs = (size_t )0;
    } else {
      {
#line 375
      fs->p -= wrote;
#line 376
      fs->point_offs -= (size_t )wrote;
#line 377
      memmove((void *)fs->buf, (void const   *)(fs->buf + wrote), (size_t )(fs->p - fs->buf));
      }
#line 378
      return (0);
    }
#line 381
    if ((size_t )(fs->end - fs->buf) < amount) {
#line 384
      old_size = (size_t )(fs->end - fs->buf);
#line 385
      new_size = old_size + amount;
#line 388
      if (new_size < old_size) {
        {
#line 390
        tmp___0 = __errno_location();
#line 390
        *tmp___0 = 12;
        }
#line 391
        return (0);
      } else {
        {
#line 388
        tmp___1 = realloc((void *)fs->buf, new_size);
#line 388
        new_buf = (char *)tmp___1;
        }
#line 388
        if (! new_buf) {
          {
#line 390
          tmp___0 = __errno_location();
#line 390
          *tmp___0 = 12;
          }
#line 391
          return (0);
        }
      }
#line 394
      fs->buf = new_buf;
#line 395
      fs->end = new_buf + new_size;
#line 396
      fs->p = fs->buf;
    }
  }
#line 400
  return (1);
}
}
#line 403 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-fmtstream.c"
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) 
{ 
  int out ;
  size_t avail ;
  size_t size_guess ;
  va_list args ;
  int tmp ;

  {
#line 408
  size_guess = (size_t )150;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 414
    tmp = _argp_fmtstream_ensure(fs, size_guess);
    }
#line 414
    if (! tmp) {
#line 415
      return ((ssize_t )-1);
    }
    {
#line 417
    __builtin_va_start(args, fmt);
#line 418
    avail = (size_t )(fs->end - fs->p);
#line 419
    out = (int )vsnprintf((char */* __restrict  */)fs->p, avail, (char const   */* __restrict  */)fmt,
                          args);
#line 420
    __builtin_va_end(args);
    }
#line 421
    if ((size_t )out >= avail) {
#line 422
      size_guess = (size_t )(out + 1);
    }
#line 410
    if (! ((size_t )out >= avail)) {
#line 410
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  fs->p += out;
#line 428
  return ((ssize_t )out);
}
}
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-eexst.c"
error_t argp_err_exit_status  =    64;
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argp-ba.c"
char const   *argp_program_bug_address  ;
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.h"
ptrdiff_t argmatch(char const   *arg___0 , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 54
void (*argmatch_die)(void) ;
#line 58
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 70
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 81
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg___0 , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 96
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 62 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 65
  exit((int )exit_failure);
  }
}
}
#line 70 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 84 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
ptrdiff_t argmatch(char const   *arg___0 , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 90
  matchind = (ptrdiff_t )-1;
#line 91
  ambiguous = (_Bool)0;
#line 93
  arglen = strlen(arg___0);
#line 96
  i = (size_t )0;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *(arglist + i)) {
#line 96
      goto while_break;
    }
    {
#line 98
    tmp___1 = strncmp((char const   *)*(arglist + i), arg___0, arglen);
    }
#line 98
    if (! tmp___1) {
      {
#line 100
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 100
      if (tmp___0 == arglen) {
#line 102
        return ((ptrdiff_t )i);
      } else
#line 103
      if (matchind == -1L) {
#line 105
        matchind = (ptrdiff_t )i;
      } else
#line 109
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 115
        ambiguous = (_Bool)1;
      } else {
        {
#line 109
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 109
        if (tmp) {
#line 115
          ambiguous = (_Bool)1;
        }
      }
    }
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (ambiguous) {
#line 121
    return ((ptrdiff_t )-2);
  } else {
#line 123
    return (matchind);
  }
}
}
#line 131 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 134
  if (problem == -1L) {
    {
#line 134
    tmp = gettext("invalid argument %s for %s");
#line 134
    tmp___1 = tmp;
    }
  } else {
    {
#line 134
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 134
    tmp___1 = tmp___0;
    }
  }
  {
#line 134
  format = (char const   *)tmp___1;
#line 138
  tmp___2 = quote_n(1, context);
#line 138
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 138
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 140
  return;
}
}
#line 146 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 151
  last_val = (char const   *)((void *)0);
#line 155
  tmp = gettext("Valid arguments are:");
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 156
  i = (size_t )0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! *(arglist + i)) {
#line 156
      goto while_break;
    }
#line 157
    if (i == 0UL) {
      {
#line 160
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
              *(arglist + i));
#line 161
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 157
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 157
      if (tmp___0) {
        {
#line 160
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
                *(arglist + i));
#line 161
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 165
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", `%s\'",
                *(arglist + i));
        }
      }
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  fputc_unlocked('\n', stderr);
  }
#line 168
  return;
}
}
#line 176 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg___0 , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 182
  tmp = argmatch(arg___0, arglist, vallist, valsize);
#line 182
  res = tmp;
  }
#line 183
  if (res >= 0L) {
#line 185
    return (res);
  }
  {
#line 188
  argmatch_invalid(context, arg___0, res);
#line 189
  argmatch_valid(arglist, vallist, valsize);
#line 190
  (*exit_fn)();
  }
#line 192
  return ((ptrdiff_t )-1);
}
}
#line 197 "/home/wslee/gnu_benchmarks/cpio-2.11/gnu/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 204
  i = (size_t )0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! *(arglist + i)) {
#line 204
      goto while_break;
    }
    {
#line 205
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 205
    if (! tmp) {
#line 206
      return ((char const   *)*(arglist + i));
    }
#line 204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return ((char const   *)((void *)0));
}
}
#line 526 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 151 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 20 "./rmt.h"
char *rmt_command ;
#line 21 "./rmt.h"
char *rmt_dev_name__  ;
#line 23
int rmt_open__(char const   *file_name___0 , int open_mode , int bias , char const   *remote_shell ) ;
#line 24
int rmt_close__(int handle ) ;
#line 25
size_t rmt_read__(int handle , char *buffer , size_t length ) ;
#line 26
size_t rmt_write__(int handle , char *buffer , size_t length ) ;
#line 27
off_t rmt_lseek__(int handle , off_t offset , int whence ) ;
#line 28
int rmt_ioctl__(int handle , int operation , char *argument ) ;
#line 30 "./rmt.h"
_Bool force_local_option  ;
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static int from_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 91 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static int to_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 93 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
char *rmt_command  =    (char *)"/usr/local/libexec/rmt";
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static void _rmt_shutdown(int handle , int errno_value ) 
{ 
  int *tmp ;

  {
  {
#line 108
  close(from_remote[handle][0]);
#line 109
  close(to_remote[handle][1]);
#line 110
  from_remote[handle][0] = -1;
#line 111
  to_remote[handle][1] = -1;
#line 112
  tmp = __errno_location();
#line 112
  *tmp = errno_value;
  }
#line 113
  return;
}
}
#line 118 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static int do_command(int handle , char const   *buffer ) 
{ 
  size_t length ;
  size_t tmp ;
  void (*pipe_handler)() ;
  __sighandler_t tmp___0 ;
  ssize_t written ;
  size_t tmp___1 ;

  {
  {
#line 123
  tmp = strlen(buffer);
#line 123
  length = tmp;
#line 124
  tmp___0 = signal(13, (void (*)(int  ))1);
#line 124
  pipe_handler = (void (*)())tmp___0;
#line 125
  tmp___1 = full_write(to_remote[handle][1], (void const   *)buffer, length);
#line 125
  written = (ssize_t )tmp___1;
#line 126
  signal(13, (void (*)(int  ))pipe_handler);
  }
#line 128
  if ((size_t )written == length) {
#line 129
    return (0);
  }
  {
#line 133
  _rmt_shutdown(handle, 5);
  }
#line 134
  return (-1);
}
}
#line 137 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static char *get_status_string(int handle , char *command_buffer ) 
{ 
  char *cursor ;
  int counter ;
  size_t tmp ;
  char character ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 145
  counter = 0;
#line 145
  cursor = command_buffer;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (counter < 64)) {
#line 145
      goto while_break;
    }
    {
#line 149
    tmp = safe_read(from_remote[handle][0], (void *)cursor, (size_t )1);
    }
#line 149
    if (tmp != 1UL) {
      {
#line 151
      _rmt_shutdown(handle, 5);
      }
#line 152
      return ((char *)0);
    }
#line 154
    if ((int )*cursor == 10) {
#line 156
      *cursor = (char )'\000';
#line 157
      goto while_break;
    }
#line 145
    counter ++;
#line 145
    cursor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (counter == 64) {
    {
#line 163
    _rmt_shutdown(handle, 5);
    }
#line 164
    return ((char *)0);
  }
#line 169
  cursor = command_buffer;
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    if (! *cursor) {
#line 169
      goto while_break___0;
    }
#line 170
    if ((int )*cursor != 32) {
#line 171
      goto while_break___0;
    }
#line 169
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if ((int )*cursor == 69) {
#line 173
    goto _L;
  } else
#line 173
  if ((int )*cursor == 70) {
    _L: /* CIL Label */ 
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 183
      tmp___0 = safe_read(from_remote[handle][0], (void *)(& character), (size_t )1);
      }
#line 183
      if (! (tmp___0 == 1UL)) {
#line 183
        goto while_break___1;
      }
#line 184
      if ((int )character == 10) {
#line 185
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 188
    tmp___1 = __errno_location();
#line 188
    *tmp___1 = atoi((char const   *)(cursor + 1));
    }
#line 190
    if ((int )*cursor == 70) {
      {
#line 191
      tmp___2 = __errno_location();
#line 191
      _rmt_shutdown(handle, *tmp___2);
      }
    }
#line 193
    return ((char *)0);
  }
#line 198
  if ((int )*cursor != 65) {
    {
#line 200
    _rmt_shutdown(handle, 5);
    }
#line 201
    return ((char *)0);
  }
#line 206
  return (cursor + 1);
}
}
#line 211 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static long get_status(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  long result ;
  long tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp8 ;

  {
  {
#line 215
  tmp = get_status_string(handle, command_buffer);
#line 215
  status = (char const   *)tmp;
  }
#line 216
  if (status) {
    {
#line 218
    tmp___0 = atol(status);
#line 218
    result = tmp___0;
    }
#line 219
    if (0L <= result) {
#line 220
      return (result);
    }
    {
#line 221
    tmp___1 = __errno_location();
#line 221
    *tmp___1 = 5;
    }
  }
#line 223
  return (-1L);
}
}
#line 226 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static off_t get_status_off(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  off_t count ;
  int negative ;
  int tmp___0 ;
  int digit ;
  char const   *tmp___1 ;
  off_t c10 ;
  off_t nc ;
  off_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp14 ;

  {
  {
#line 230
  tmp = get_status_string(handle, command_buffer);
#line 230
  status = (char const   *)tmp;
  }
#line 232
  if (! status) {
#line 233
    return ((off_t )-1);
  } else {
#line 240
    count = (off_t )0;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! ((int const   )*status == 32)) {
#line 243
        if (! ((int const   )*status == 9)) {
#line 243
          goto while_break;
        }
      }
#line 244
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 243
      status ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 246
    negative = (int const   )*status == 45;
#line 247
    if (negative) {
#line 247
      tmp___0 = 1;
    } else
#line 247
    if ((int const   )*status == 43) {
#line 247
      tmp___0 = 1;
    } else {
#line 247
      tmp___0 = 0;
    }
#line 247
    status += tmp___0;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      tmp___1 = status;
#line 251
      status ++;
#line 251
      digit = (int )((int const   )*tmp___1 - 48);
#line 252
      if (9U < (unsigned int )digit) {
#line 253
        goto while_break___0;
      } else {
#line 256
        c10 = 10L * count;
#line 257
        if (negative) {
#line 257
          tmp___2 = c10 - (off_t )digit;
        } else {
#line 257
          tmp___2 = c10 + (off_t )digit;
        }
#line 257
        nc = tmp___2;
#line 258
        if (c10 / 10L != count) {
#line 259
          return ((off_t )-1);
        } else {
#line 258
          if (negative) {
#line 258
            tmp___3 = c10 < nc;
          } else {
#line 258
            tmp___3 = nc < c10;
          }
#line 258
          if (tmp___3) {
#line 259
            return ((off_t )-1);
          }
        }
#line 260
        count = nc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    return (count);
  }
}
}
#line 318 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
static void encode_oflag(char *buf , int oflag ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 321
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%d ", oflag);
  }
  {
#line 325
  if ((oflag & 3) == 0) {
#line 325
    goto case_0;
  }
#line 326
  if ((oflag & 3) == 2) {
#line 326
    goto case_2;
  }
#line 327
  if ((oflag & 3) == 1) {
#line 327
    goto case_1;
  }
#line 328
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 325
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_RDONLY");
  }
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 326
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_RDWR");
  }
#line 326
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 327
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_WRONLY");
  }
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 328
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 332
  if (oflag & 1024) {
    {
#line 332
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_APPEND");
    }
  }
#line 334
  if (oflag & 64) {
    {
#line 334
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_CREAT");
    }
  }
#line 336
  if (oflag & 4096) {
    {
#line 336
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_DSYNC");
    }
  }
#line 338
  if (oflag & 128) {
    {
#line 338
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_EXCL");
    }
  }
#line 343
  if (oflag & 256) {
    {
#line 343
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_NOCTTY");
    }
  }
#line 345
  if (oflag & 2048) {
    {
#line 345
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_NONBLOCK");
    }
  }
#line 347
  if (oflag & 4096) {
    {
#line 347
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_RSYNC");
    }
  }
#line 350
  if (oflag & 4096) {
    {
#line 350
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_SYNC");
    }
  }
#line 352
  if (oflag & 512) {
    {
#line 352
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_TRUNC");
    }
  }
#line 353
  return;
}
}
#line 360 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
int rmt_open__(char const   *file_name___0 , int open_mode , int bias , char const   *remote_shell ) 
{ 
  int remote_pipe_number ;
  char *file_name_copy ;
  char *remote_host ;
  char *remote_file ;
  char *remote_user ;
  int *tmp ;
  char *cursor ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct hostent *tmp___2 ;
  char const   *remote_shell_basename ;
  pid_t status ;
  int *tmp___3 ;
  char *tmp___4 ;
  int e ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int e___0 ;
  int *tmp___9 ;
  int *tmp___10 ;
  __uid_t tmp___11 ;
  __gid_t tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  size_t remote_file_len ;
  size_t tmp___15 ;
  char *command_buffer ;
  void *tmp___16 ;
  int e___1 ;
  int *tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 372
  remote_pipe_number = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (remote_pipe_number < 4)) {
#line 372
      goto while_break;
    }
#line 375
    if (from_remote[remote_pipe_number][0] == -1) {
#line 375
      if (to_remote[remote_pipe_number][1] == -1) {
#line 377
        goto while_break;
      }
    }
#line 372
    remote_pipe_number ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (remote_pipe_number == 4) {
    {
#line 381
    tmp = __errno_location();
#line 381
    *tmp = 24;
    }
#line 382
    return (-1);
  }
  {
#line 390
  file_name_copy = xstrdup(file_name___0);
#line 391
  remote_host = file_name_copy;
#line 392
  remote_user = (char *)0;
#line 393
  remote_file = (char *)0;
#line 395
  cursor = file_name_copy;
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (! *cursor) {
#line 395
      goto while_break___0;
    }
    {
#line 401
    if ((int )*cursor == 10) {
#line 401
      goto case_10;
    }
#line 408
    if ((int )*cursor == 64) {
#line 408
      goto case_64;
    }
#line 417
    if ((int )*cursor == 58) {
#line 417
      goto case_58;
    }
#line 398
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 399
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 404
    free((void *)file_name_copy);
#line 405
    tmp___0 = __errno_location();
#line 405
    *tmp___0 = 2;
    }
#line 406
    return (-1);
    case_64: /* CIL Label */ 
#line 409
    if (! remote_user) {
#line 411
      remote_user = remote_host;
#line 412
      *cursor = (char )'\000';
#line 413
      remote_host = cursor + 1;
    }
#line 415
    goto switch_break;
    case_58: /* CIL Label */ 
#line 418
    if (! remote_file) {
#line 420
      *cursor = (char )'\000';
#line 421
      remote_file = cursor + 1;
    }
#line 423
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 395
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 428
  tmp___2 = gethostbyname((char const   *)remote_host);
  }
#line 428
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 429
    tmp___1 = gettext("Cannot connect to %s: resolve failed");
#line 429
    error(128, 0, (char const   *)tmp___1, remote_host);
    }
  }
#line 432
  if (remote_user) {
#line 432
    if ((int )*remote_user == 0) {
#line 433
      remote_user = (char *)0;
    }
  }
#line 457
  if (! remote_shell) {
    {
#line 462
    free((void *)file_name_copy);
#line 463
    tmp___3 = __errno_location();
#line 463
    *tmp___3 = 5;
    }
#line 464
    return (-1);
  }
  {
#line 467
  tmp___4 = last_component(remote_shell);
#line 467
  remote_shell_basename = (char const   *)tmp___4;
#line 471
  tmp___7 = pipe((int *)(to_remote[remote_pipe_number]));
  }
#line 471
  if (tmp___7 == -1) {
#line 471
    goto _L;
  } else {
    {
#line 471
    tmp___8 = pipe((int *)(from_remote[remote_pipe_number]));
    }
#line 471
    if (tmp___8 == -1) {
      _L: /* CIL Label */ 
      {
#line 474
      tmp___5 = __errno_location();
#line 474
      e = *tmp___5;
#line 475
      free((void *)file_name_copy);
#line 476
      tmp___6 = __errno_location();
#line 476
      *tmp___6 = e;
      }
#line 477
      return (-1);
    }
  }
  {
#line 480
  status = fork();
  }
#line 481
  if (status == -1) {
    {
#line 483
    tmp___9 = __errno_location();
#line 483
    e___0 = *tmp___9;
#line 484
    free((void *)file_name_copy);
#line 485
    tmp___10 = __errno_location();
#line 485
    *tmp___10 = e___0;
    }
#line 486
    return (-1);
  }
#line 489
  if (status == 0) {
    {
#line 493
    close(0);
#line 494
    dup(to_remote[remote_pipe_number][0]);
#line 495
    close(to_remote[remote_pipe_number][0]);
#line 496
    close(to_remote[remote_pipe_number][1]);
#line 498
    close(1);
#line 499
    dup(from_remote[remote_pipe_number][1]);
#line 500
    close(from_remote[remote_pipe_number][0]);
#line 501
    close(from_remote[remote_pipe_number][1]);
    }
    {
#line 503
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 503
      tmp___11 = getuid();
#line 503
      setuid(tmp___11);
#line 503
      tmp___12 = getgid();
#line 503
      setgid(tmp___12);
      }
#line 503
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 505
    if (remote_user) {
      {
#line 506
      execl(remote_shell, remote_shell_basename, remote_host, "-l", remote_user, rmt_command,
            (char *)0);
      }
    } else {
      {
#line 509
      execl(remote_shell, remote_shell_basename, remote_host, rmt_command, (char *)0);
      }
    }
    {
#line 515
    tmp___13 = gettext("Cannot execute remote shell");
#line 515
    tmp___14 = __errno_location();
#line 515
    error(128, *tmp___14, (char const   *)tmp___13);
    }
  }
  {
#line 520
  close(from_remote[remote_pipe_number][1]);
#line 521
  close(to_remote[remote_pipe_number][0]);
#line 528
  tmp___15 = strlen((char const   *)remote_file);
#line 528
  remote_file_len = tmp___15;
#line 529
  tmp___16 = xmalloc(remote_file_len + 1000UL);
#line 529
  command_buffer = (char *)tmp___16;
#line 530
  sprintf((char */* __restrict  */)command_buffer, (char const   */* __restrict  */)"O%s\n",
          remote_file);
#line 531
  encode_oflag((command_buffer + remote_file_len) + 2, open_mode);
#line 532
  strcat((char */* __restrict  */)command_buffer, (char const   */* __restrict  */)"\n");
#line 533
  tmp___18 = do_command(remote_pipe_number, (char const   *)command_buffer);
  }
#line 533
  if (tmp___18 == -1) {
#line 533
    goto _L___0;
  } else {
    {
#line 533
    tmp___19 = get_status(remote_pipe_number);
    }
#line 533
    if (tmp___19 == -1L) {
      _L___0: /* CIL Label */ 
      {
#line 536
      tmp___17 = __errno_location();
#line 536
      e___1 = *tmp___17;
#line 537
      free((void *)command_buffer);
#line 538
      free((void *)file_name_copy);
#line 539
      _rmt_shutdown(remote_pipe_number, e___1);
      }
#line 540
      return (-1);
    }
  }
  {
#line 542
  free((void *)command_buffer);
#line 545
  free((void *)file_name_copy);
  }
#line 546
  return (remote_pipe_number + bias);
}
}
#line 551 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
int rmt_close__(int handle ) 
{ 
  long status ;
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 556
  tmp = do_command(handle, "C\n");
  }
#line 556
  if (tmp == -1) {
#line 557
    return (-1);
  }
  {
#line 559
  status = get_status(handle);
#line 560
  tmp___0 = __errno_location();
#line 560
  _rmt_shutdown(handle, *tmp___0);
  }
#line 561
  return ((int )status);
}
}
#line 566 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
size_t rmt_read__(int handle , char *buffer , size_t length ) 
{ 
  char command_buffer[64] ;
  size_t status ;
  size_t rlen ;
  size_t counter ;
  int tmp ;
  long tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 574
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"R%lu\n",
          length);
#line 575
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 575
  if (tmp == -1) {
#line 578
    return ((size_t )-1);
  } else {
    {
#line 575
    tmp___0 = get_status(handle);
#line 575
    status = (size_t )tmp___0;
    }
#line 575
    if (status == 0xffffffffffffffffUL) {
#line 578
      return ((size_t )-1);
    } else
#line 575
    if (status > length) {
#line 578
      return ((size_t )-1);
    }
  }
#line 580
  counter = (size_t )0;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (counter < status)) {
#line 580
      goto while_break;
    }
    {
#line 582
    rlen = safe_read(from_remote[handle][0], (void *)buffer, status - counter);
    }
#line 583
    if (rlen == 0xffffffffffffffffUL) {
      {
#line 585
      _rmt_shutdown(handle, 5);
      }
#line 586
      return ((size_t )-1);
    } else
#line 583
    if (rlen == 0UL) {
      {
#line 585
      _rmt_shutdown(handle, 5);
      }
#line 586
      return ((size_t )-1);
    }
#line 580
    counter += rlen;
#line 580
    buffer += rlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return (status);
}
}
#line 595 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
size_t rmt_write__(int handle , char *buffer , size_t length ) 
{ 
  char command_buffer[64] ;
  void (*pipe_handler)() ;
  size_t written ;
  int tmp ;
  __sighandler_t tmp___0 ;
  long r ;
  long tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 602
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"W%lu\n",
          length);
#line 603
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 603
  if (tmp == -1) {
#line 604
    return ((size_t )0);
  }
  {
#line 606
  tmp___0 = signal(13, (void (*)(int  ))1);
#line 606
  pipe_handler = (void (*)())tmp___0;
#line 607
  written = full_write(to_remote[handle][1], (void const   *)buffer, length);
#line 608
  signal(13, (void (*)(int  ))pipe_handler);
  }
#line 609
  if (written == length) {
    {
#line 611
    tmp___1 = get_status(handle);
#line 611
    r = tmp___1;
    }
#line 612
    if (r < 0L) {
#line 613
      return ((size_t )0);
    }
#line 614
    if ((size_t )r == length) {
#line 615
      return (length);
    }
#line 616
    written = (size_t )r;
  }
  {
#line 621
  _rmt_shutdown(handle, 5);
  }
#line 622
  return (written);
}
}
#line 627 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
off_t rmt_lseek__(int handle , off_t offset , int whence ) 
{ 
  char command_buffer[64] ;
  char operand_buffer[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp ;
  char *p ;
  int tmp___0 ;
  off_t tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 632
  if (offset < 0L) {
#line 632
    tmp = - ((uintmax_t )offset);
  } else {
#line 632
    tmp = (uintmax_t )offset;
  }
#line 632
  u = tmp;
#line 633
  p = operand_buffer + sizeof(operand_buffer);
#line 635
  p --;
#line 635
  *p = (char)0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    p --;
#line 637
    *p = (char )(48 + (int )(u % 10UL));
#line 636
    u /= 10UL;
#line 636
    if (! (u != 0UL)) {
#line 636
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  if (offset < 0L) {
#line 640
    p --;
#line 640
    *p = (char )'-';
  }
  {
#line 644
  if (whence == 0) {
#line 644
    goto case_0;
  }
#line 645
  if (whence == 1) {
#line 645
    goto case_1;
  }
#line 646
  if (whence == 2) {
#line 646
    goto case_2;
  }
#line 647
  goto switch_default;
  case_0: /* CIL Label */ 
#line 644
  whence = 0;
#line 644
  goto switch_break;
  case_1: /* CIL Label */ 
#line 645
  whence = 1;
#line 645
  goto switch_break;
  case_2: /* CIL Label */ 
#line 646
  whence = 2;
#line 646
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 647
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 650
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"L%s\n%d\n",
          p, whence);
#line 652
  tmp___0 = do_command(handle, (char const   *)(command_buffer));
  }
#line 652
  if (tmp___0 == -1) {
#line 653
    return ((off_t )-1);
  }
  {
#line 655
  tmp___1 = get_status_off(handle);
  }
#line 655
  return (tmp___1);
}
}
#line 660 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/rtapelib.c"
int rmt_ioctl__(int handle , int operation , char *argument ) 
{ 
  int *tmp ;
  char command_buffer[64] ;
  char operand_buffer[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp___0 ;
  char *p ;
  int tmp___1 ;
  long tmp___2 ;
  ssize_t status ;
  size_t counter ;
  int tmp___3 ;
  int *tmp___4 ;
  char copy ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 670
  if (operation == (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16))) {
#line 670
    goto case_exp;
  }
#line 698
  if (operation == (int )((unsigned long )(((2U << 30) | (unsigned int )(109 << 8)) | 2U) | (sizeof(struct mtget ) << 16))) {
#line 698
    goto case_exp___0;
  }
#line 665
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 666
  tmp = __errno_location();
#line 666
  *tmp = 95;
  }
#line 667
  return (-1);
  case_exp: /* CIL Label */ 
#line 674
  if (((struct mtop *)argument)->mt_count < 0) {
#line 674
    tmp___0 = - ((uintmax_t )((struct mtop *)argument)->mt_count);
  } else {
#line 674
    tmp___0 = (uintmax_t )((struct mtop *)argument)->mt_count;
  }
#line 674
  u = tmp___0;
#line 677
  p = operand_buffer + sizeof(operand_buffer);
#line 679
  p --;
#line 679
  *p = (char)0;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    p --;
#line 681
    *p = (char )(48 + (int )(u % 10UL));
#line 680
    u /= 10UL;
#line 680
    if (! (u != 0UL)) {
#line 680
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  if (((struct mtop *)argument)->mt_count < 0) {
#line 684
    p --;
#line 684
    *p = (char )'-';
  }
  {
#line 688
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"I%d\n%s\n",
          (int )((struct mtop *)argument)->mt_op, p);
#line 690
  tmp___1 = do_command(handle, (char const   *)(command_buffer));
  }
#line 690
  if (tmp___1 == -1) {
#line 691
    return (-1);
  }
  {
#line 693
  tmp___2 = get_status(handle);
  }
#line 693
  return ((int )tmp___2);
  case_exp___0: /* CIL Label */ 
  {
#line 709
  tmp___3 = do_command(handle, "S");
  }
#line 709
  if (tmp___3 == -1) {
#line 711
    return (-1);
  } else {
    {
#line 709
    status = get_status(handle);
    }
#line 709
    if (status == -1L) {
#line 711
      return (-1);
    }
  }
#line 713
  if ((unsigned long )status > sizeof(struct mtop )) {
    {
#line 715
    tmp___4 = __errno_location();
#line 715
    *tmp___4 = 75;
    }
#line 716
    return (-1);
  }
  {
#line 719
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 719
    if (! (status > 0L)) {
#line 719
      goto while_break___0;
    }
    {
#line 721
    counter = safe_read(from_remote[handle][0], (void *)argument, (size_t )status);
    }
#line 722
    if (counter == 0xffffffffffffffffUL) {
      {
#line 724
      _rmt_shutdown(handle, 5);
      }
#line 725
      return (-1);
    } else
#line 722
    if (counter == 0UL) {
      {
#line 724
      _rmt_shutdown(handle, 5);
      }
#line 725
      return (-1);
    }
#line 719
    status = (ssize_t )((size_t )status - counter);
#line 719
    argument += counter;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 734
  if (((struct mtget *)argument)->mt_type < 256L) {
#line 735
    return (0);
  }
#line 737
  counter = (size_t )0;
  {
#line 737
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 737
    if (! (counter < (size_t )status)) {
#line 737
      goto while_break___1;
    }
#line 739
    copy = *(argument + counter);
#line 741
    *(argument + counter) = *(argument + (counter + 1UL));
#line 742
    *(argument + (counter + 1UL)) = copy;
#line 737
    counter += 2UL;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 745
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 109 "./paxlib.h"
_Bool hash_string_insert(Hash_table **table , char const   *string ) ;
#line 110
_Bool hash_string_lookup(Hash_table const   *table , char const   *string ) ;
#line 112
_Bool removed_prefixes_p(void) ;
#line 113
char *safer_name_suffix(char const   *file_name___0 , _Bool link_target , _Bool absolute_names ) ;
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static size_t hash_string_hasher(void const   *name , size_t n_buckets ) 
{ 
  size_t tmp ;

  {
  {
#line 29
  tmp = hash_string((char const   *)name, n_buckets);
  }
#line 29
  return (tmp);
}
}
#line 33 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static _Bool hash_string_compare(void const   *name1 , void const   *name2 ) 
{ 
  int tmp ;

  {
  {
#line 36
  tmp = strcmp((char const   *)name1, (char const   *)name2);
  }
#line 36
  return ((_Bool )(tmp == 0));
}
}
#line 43 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static _Bool hash_string_insert_prefix(Hash_table **table , char const   *string ,
                                       size_t len , char const   **return_prefix ) 
{ 
  Hash_table *t ;
  char *s ;
  char *e ;
  void *tmp ;
  Hash_table *tmp___0 ;
  void *tmp___1 ;

  {
#line 47
  t = *table;
#line 51
  if (len) {
    {
#line 53
    tmp = xmalloc(len + 1UL);
#line 53
    s = (char *)tmp;
#line 54
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string, len);
#line 55
    *(s + len) = (char)0;
    }
  } else {
    {
#line 58
    s = xstrdup(string);
    }
  }
#line 60
  if (t) {
#line 60
    goto _L;
  } else {
    {
#line 60
    t = hash_initialize((size_t )0, (Hash_tuning const   *)0, & hash_string_hasher,
                        & hash_string_compare, (void (*)(void * ))0);
#line 60
    tmp___0 = t;
#line 60
    *table = tmp___0;
    }
#line 60
    if (tmp___0) {
      _L: /* CIL Label */ 
      {
#line 60
      tmp___1 = hash_insert(t, (void const   *)s);
#line 60
      e = (char *)tmp___1;
      }
#line 60
      if (! e) {
        {
#line 64
        xalloc_die();
        }
      }
    } else {
      {
#line 64
      xalloc_die();
      }
    }
  }
#line 66
  if ((unsigned long )e == (unsigned long )s) {
#line 68
    if (return_prefix) {
#line 69
      *return_prefix = (char const   *)s;
    }
#line 70
    return ((_Bool)1);
  } else {
    {
#line 74
    free((void *)s);
    }
#line 75
    return ((_Bool)0);
  }
}
}
#line 81 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
_Bool hash_string_insert(Hash_table **table , char const   *string ) 
{ 
  _Bool tmp ;

  {
  {
#line 84
  tmp = hash_string_insert_prefix(table, string, (size_t )0, (char const   **)((void *)0));
  }
#line 84
  return (tmp);
}
}
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
_Bool hash_string_lookup(Hash_table const   *table , char const   *string ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 91
  if (table) {
    {
#line 91
    tmp = hash_lookup(table, (void const   *)string);
    }
#line 91
    if (tmp) {
#line 91
      tmp___0 = 1;
    } else {
#line 91
      tmp___0 = 0;
    }
  } else {
#line 91
    tmp___0 = 0;
  }
#line 91
  return ((_Bool )tmp___0);
}
}
#line 95 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static Hash_table *prefix_table[2]  ;
#line 101 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
_Bool removed_prefixes_p(void) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 104
  if (prefix_table[0]) {
    {
#line 104
    tmp = hash_get_n_entries((Hash_table const   *)prefix_table[0]);
    }
#line 104
    if (tmp != 0UL) {
#line 104
      tmp___1 = 1;
    } else {
#line 104
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 104
  if (prefix_table[1]) {
    {
#line 104
    tmp___0 = hash_get_n_entries((Hash_table const   *)prefix_table[1]);
    }
#line 104
    if (tmp___0 != 0UL) {
#line 104
      tmp___1 = 1;
    } else {
#line 104
      tmp___1 = 0;
    }
  } else {
#line 104
    tmp___1 = 0;
  }
#line 104
  return ((_Bool )tmp___1);
}
}
#line 153 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static char const   * const  diagnostic[2]  = {      (char const   */* const  */)"Removing leading `%s\' from member names",      (char const   */* const  */)"Removing leading `%s\' from hard link targets"};
#line 167 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
static char const   * const  diagnostic___0[2]  = {      (char const   */* const  */)"Substituting `.\' for empty member name",      (char const   */* const  */)"Substituting `.\' for empty hard link target"};
#line 114 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/names.c"
char *safer_name_suffix(char const   *file_name___0 , _Bool link_target , _Bool absolute_names ) 
{ 
  char const   *p ;
  size_t prefix_len ;
  char c ;
  char const   *tmp ;
  char const   *prefix ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 120
  if (absolute_names) {
#line 121
    p = file_name___0;
  } else {
#line 127
    prefix_len = (size_t )0;
#line 129
    p = file_name___0 + prefix_len;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! *p) {
#line 129
        goto while_break;
      }
#line 131
      if ((int const   )*(p + 0) == 46) {
#line 131
        if ((int const   )*(p + 1) == 46) {
#line 131
          if ((int const   )*(p + 2) == 47) {
#line 132
            prefix_len = (size_t )((p + 2) - file_name___0);
          } else
#line 131
          if (! *(p + 2)) {
#line 132
            prefix_len = (size_t )((p + 2) - file_name___0);
          }
        }
      }
      {
#line 134
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 136
        tmp = p;
#line 136
        p ++;
#line 136
        c = (char )*tmp;
#line 137
        if ((int )c == 47) {
#line 138
          goto while_break___0;
        }
#line 134
        if (! *p) {
#line 134
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    p = file_name___0 + prefix_len;
    {
#line 143
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 143
      if (! ((int const   )*p == 47)) {
#line 143
        goto while_break___1;
      }
#line 144
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 143
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 145
    prefix_len = (size_t )(p - file_name___0);
#line 147
    if (prefix_len) {
      {
#line 150
      tmp___1 = hash_string_insert_prefix(& prefix_table[link_target], file_name___0,
                                          prefix_len, & prefix);
      }
#line 150
      if (tmp___1) {
        {
#line 158
        tmp___0 = gettext((char const   *)diagnostic[link_target]);
#line 158
        error(0, 0, (char const   *)tmp___0, prefix);
        }
      }
    }
  }
#line 163
  if (! *p) {
#line 165
    if ((unsigned long )p == (unsigned long )file_name___0) {
      {
#line 172
      tmp___2 = gettext((char const   *)diagnostic___0[link_target]);
#line 172
      error(0, 0, "%s", tmp___2);
      }
    }
#line 175
    p = ".";
  }
#line 178
  return ((char *)p);
}
}
#line 53 "./paxlib.h"
int exit_status ;
#line 102
void pax_exit(void) ;
#line 22 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/exit.c"
int exit_status  =    0;
#line 24 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/exit.c"
void pax_exit(void) 
{ 


  {
  {
#line 27
  exit(exit_status);
  }
}
}
#line 62 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 55 "./paxlib.h"
void pax_decode_mode(mode_t mode , char *string ) ;
#line 56
void call_arg_error(char const   *call , char const   *name ) ;
#line 57
 __attribute__((__noreturn__)) void call_arg_fatal(char const   *call , char const   *name ) ;
#line 58
void call_arg_warn(char const   *call , char const   *name ) ;
#line 59
void chmod_error_details(char const   *name , mode_t mode ) ;
#line 60
void chown_error_details(char const   *name , uid_t uid , gid_t gid ) ;
#line 64
 __attribute__((__noreturn__)) void chdir_fatal(char const   *name ) ;
#line 67
void close_error(char const   *name ) ;
#line 68
void close_warn(char const   *name ) ;
#line 69
 __attribute__((__noreturn__)) void exec_fatal(char const   *name ) ;
#line 70
void link_error(char const   *target , char const   *source ) ;
#line 71
void mkdir_error(char const   *name ) ;
#line 72
void mkfifo_error(char const   *name ) ;
#line 73
void mknod_error(char const   *name ) ;
#line 74
void open_error(char const   *name ) ;
#line 75
 __attribute__((__noreturn__)) void open_fatal(char const   *name ) ;
#line 76
void open_warn(char const   *name ) ;
#line 77
void read_error(char const   *name ) ;
#line 78
void read_error_details(char const   *name , off_t offset , size_t size ) ;
#line 79
 __attribute__((__noreturn__)) void read_fatal(char const   *name ) ;
#line 80
 __attribute__((__noreturn__)) void read_fatal_details(char const   *name , off_t offset ,
                                                       size_t size ) ;
#line 81
void read_warn_details(char const   *name , off_t offset , size_t size ) ;
#line 82
void readlink_error(char const   *name ) ;
#line 83
void readlink_warn(char const   *name ) ;
#line 84
void rmdir_error(char const   *name ) ;
#line 85
void savedir_error(char const   *name ) ;
#line 86
void savedir_warn(char const   *name ) ;
#line 87
void seek_error(char const   *name ) ;
#line 88
void seek_error_details(char const   *name , off_t offset ) ;
#line 89
void seek_warn(char const   *name ) ;
#line 90
void seek_warn_details(char const   *name , off_t offset ) ;
#line 91
void stat_fatal(char const   *name ) ;
#line 92
void stat_error(char const   *name ) ;
#line 93
void stat_warn(char const   *name ) ;
#line 94
void symlink_error(char const   *contents , char const   *name ) ;
#line 95
void truncate_error(char const   *name ) ;
#line 96
void truncate_warn(char const   *name ) ;
#line 97
void unlink_error(char const   *name ) ;
#line 98
void utime_error(char const   *name ) ;
#line 99
void waitpid_error(char const   *name ) ;
#line 100
void write_error(char const   *name ) ;
#line 103
 __attribute__((__noreturn__)) void fatal_exit(void) ;
#line 27 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void pax_decode_mode(mode_t mode , char *string ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 30
  tmp = string;
#line 30
  string ++;
#line 30
  if (mode & 256U) {
#line 30
    *tmp = (char )'r';
  } else {
#line 30
    *tmp = (char )'-';
  }
#line 31
  tmp___0 = string;
#line 31
  string ++;
#line 31
  if (mode & 128U) {
#line 31
    *tmp___0 = (char )'w';
  } else {
#line 31
    *tmp___0 = (char )'-';
  }
#line 32
  tmp___1 = string;
#line 32
  string ++;
#line 32
  if (mode & 2048U) {
#line 32
    if (mode & 64U) {
#line 32
      tmp___2 = 's';
    } else {
#line 32
      tmp___2 = 'S';
    }
#line 32
    *tmp___1 = (char )tmp___2;
  } else {
#line 32
    if (mode & 64U) {
#line 32
      tmp___3 = 'x';
    } else {
#line 32
      tmp___3 = '-';
    }
#line 32
    *tmp___1 = (char )tmp___3;
  }
#line 35
  tmp___4 = string;
#line 35
  string ++;
#line 35
  if (mode & (unsigned int )(256 >> 3)) {
#line 35
    *tmp___4 = (char )'r';
  } else {
#line 35
    *tmp___4 = (char )'-';
  }
#line 36
  tmp___5 = string;
#line 36
  string ++;
#line 36
  if (mode & (unsigned int )(128 >> 3)) {
#line 36
    *tmp___5 = (char )'w';
  } else {
#line 36
    *tmp___5 = (char )'-';
  }
#line 37
  tmp___6 = string;
#line 37
  string ++;
#line 37
  if (mode & 1024U) {
#line 37
    if (mode & (unsigned int )(64 >> 3)) {
#line 37
      tmp___7 = 's';
    } else {
#line 37
      tmp___7 = 'S';
    }
#line 37
    *tmp___6 = (char )tmp___7;
  } else {
#line 37
    if (mode & (unsigned int )(64 >> 3)) {
#line 37
      tmp___8 = 'x';
    } else {
#line 37
      tmp___8 = '-';
    }
#line 37
    *tmp___6 = (char )tmp___8;
  }
#line 40
  tmp___9 = string;
#line 40
  string ++;
#line 40
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 40
    *tmp___9 = (char )'r';
  } else {
#line 40
    *tmp___9 = (char )'-';
  }
#line 41
  tmp___10 = string;
#line 41
  string ++;
#line 41
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 41
    *tmp___10 = (char )'w';
  } else {
#line 41
    *tmp___10 = (char )'-';
  }
#line 42
  tmp___11 = string;
#line 42
  string ++;
#line 42
  if (mode & 512U) {
#line 42
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 42
      tmp___12 = 't';
    } else {
#line 42
      tmp___12 = 'T';
    }
#line 42
    *tmp___11 = (char )tmp___12;
  } else {
#line 42
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 42
      tmp___13 = 'x';
    } else {
#line 42
      tmp___13 = '-';
    }
#line 42
    *tmp___11 = (char )tmp___13;
  }
#line 45
  *string = (char )'\000';
#line 46
  return;
}
}
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void call_arg_error(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 53
  tmp = __errno_location();
#line 53
  e = *tmp;
#line 58
  tmp___0 = quotearg_colon(name);
#line 58
  tmp___1 = gettext("%s: Cannot %s");
#line 58
  error(0, e, (char const   *)tmp___1, tmp___0, call);
#line 58
  exit_status = 2;
  }
#line 59
  return;
}
}
#line 63
 __attribute__((__noreturn__)) void call_arg_fatal(char const   *call , char const   *name ) ;
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void call_arg_fatal(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 66
  tmp = __errno_location();
#line 66
  e = *tmp;
#line 71
  tmp___0 = quotearg_colon(name);
#line 71
  tmp___1 = gettext("%s: Cannot %s");
#line 71
  error(0, e, (char const   *)tmp___1, tmp___0, call);
#line 71
  fatal_exit();
  }
}
}
#line 76 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void call_arg_warn(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 79
  tmp = __errno_location();
#line 79
  e = *tmp;
#line 84
  tmp___0 = quotearg_colon(name);
#line 84
  tmp___1 = gettext("%s: Warning: Cannot %s");
#line 84
  error(0, e, (char const   *)tmp___1, tmp___0, call);
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void chmod_error_details(char const   *name , mode_t mode ) 
{ 
  int e ;
  int *tmp ;
  char buf[10] ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 90
  tmp = __errno_location();
#line 90
  e = *tmp;
#line 92
  pax_decode_mode(mode, buf);
#line 93
  tmp___0 = quotearg_colon(name);
#line 93
  tmp___1 = gettext("%s: Cannot change mode to %s");
#line 93
  error(0, e, (char const   *)tmp___1, tmp___0, buf);
#line 93
  exit_status = 2;
  }
#line 95
  return;
}
}
#line 97 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void chown_error_details(char const   *name , uid_t uid , gid_t gid ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 100
  tmp = __errno_location();
#line 100
  e = *tmp;
#line 101
  tmp___0 = quotearg_colon(name);
#line 101
  tmp___1 = gettext("%s: Cannot change ownership to uid %lu, gid %lu");
#line 101
  error(0, e, (char const   *)tmp___1, tmp___0, (unsigned long )uid, (unsigned long )gid);
#line 101
  exit_status = 2;
  }
#line 103
  return;
}
}
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void close_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 108
  call_arg_error("close", name);
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void close_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 114
  call_arg_warn("close", name);
  }
#line 115
  return;
}
}
#line 117
 __attribute__((__noreturn__)) void exec_fatal(char const   *name ) ;
#line 117 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void exec_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 120
  call_arg_fatal("exec", name);
  }
}
}
#line 123 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void link_error(char const   *target , char const   *source ) 
{ 
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 126
  tmp = __errno_location();
#line 126
  e = *tmp;
#line 127
  tmp___0 = quote_n(1, target);
#line 127
  tmp___1 = quotearg_colon(source);
#line 127
  tmp___2 = gettext("%s: Cannot hard link to %s");
#line 127
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 127
  exit_status = 2;
  }
#line 129
  return;
}
}
#line 131 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void mkdir_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 134
  call_arg_error("mkdir", name);
  }
#line 135
  return;
}
}
#line 137 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void mkfifo_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 140
  call_arg_error("mkfifo", name);
  }
#line 141
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void mknod_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 146
  call_arg_error("mknod", name);
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void open_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 152
  call_arg_error("open", name);
  }
#line 153
  return;
}
}
#line 155
 __attribute__((__noreturn__)) void open_fatal(char const   *name ) ;
#line 155 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void open_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 158
  call_arg_fatal("open", name);
  }
}
}
#line 161 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void open_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 164
  call_arg_warn("open", name);
  }
#line 165
  return;
}
}
#line 167 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void read_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 170
  call_arg_error("read", name);
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void read_error_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 177
  tmp = __errno_location();
#line 177
  e = *tmp;
#line 178
  tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 178
  tmp___1 = quotearg_colon(name);
#line 178
  tmp___2 = ngettext("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes",
                     size);
#line 178
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
#line 178
  exit_status = 2;
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void read_warn_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 190
  tmp = __errno_location();
#line 190
  e = *tmp;
#line 191
  tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 191
  tmp___1 = quotearg_colon(name);
#line 191
  tmp___2 = ngettext("%s: Warning: Read error at byte %s, while reading %lu byte",
                     "%s: Warning: Read error at byte %s, while reading %lu bytes",
                     size);
#line 191
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
  }
#line 197
  return;
}
}
#line 199
 __attribute__((__noreturn__)) void read_fatal(char const   *name ) ;
#line 199 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void read_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 202
  call_arg_fatal("read", name);
  }
}
}
#line 205
 __attribute__((__noreturn__)) void read_fatal_details(char const   *name , off_t offset ,
                                                       size_t size ) ;
#line 205 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void read_fatal_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 209
  tmp = __errno_location();
#line 209
  e = *tmp;
#line 210
  tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 210
  tmp___1 = quotearg_colon(name);
#line 210
  tmp___2 = ngettext("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes",
                     size);
#line 210
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
#line 210
  fatal_exit();
  }
}
}
#line 218 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void readlink_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 221
  call_arg_error("readlink", name);
  }
#line 222
  return;
}
}
#line 224 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void readlink_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 227
  call_arg_warn("readlink", name);
  }
#line 228
  return;
}
}
#line 230 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void rmdir_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 233
  call_arg_error("rmdir", name);
  }
#line 234
  return;
}
}
#line 236 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void savedir_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 239
  call_arg_error("savedir", name);
  }
#line 240
  return;
}
}
#line 242 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void savedir_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 245
  call_arg_warn("savedir", name);
  }
#line 246
  return;
}
}
#line 248 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void seek_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 251
  call_arg_error("seek", name);
  }
#line 252
  return;
}
}
#line 254 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void seek_error_details(char const   *name , off_t offset ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 258
  tmp = __errno_location();
#line 258
  e = *tmp;
#line 259
  tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 259
  tmp___1 = quotearg_colon(name);
#line 259
  tmp___2 = gettext("%s: Cannot seek to %s");
#line 259
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 259
  exit_status = 2;
  }
#line 262
  return;
}
}
#line 264 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void seek_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 267
  call_arg_warn("seek", name);
  }
#line 268
  return;
}
}
#line 270 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void seek_warn_details(char const   *name , off_t offset ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 274
  tmp = __errno_location();
#line 274
  e = *tmp;
#line 275
  tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 275
  tmp___1 = quotearg_colon(name);
#line 275
  tmp___2 = gettext("%s: Warning: Cannot seek to %s");
#line 275
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
  }
#line 278
  return;
}
}
#line 280 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void symlink_error(char const   *contents , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 283
  tmp = __errno_location();
#line 283
  e = *tmp;
#line 284
  tmp___0 = quote_n(1, contents);
#line 284
  tmp___1 = quotearg_colon(name);
#line 284
  tmp___2 = gettext("%s: Cannot create symlink to %s");
#line 284
  error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 284
  exit_status = 2;
  }
#line 286
  return;
}
}
#line 288 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void stat_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 291
  call_arg_fatal("stat", name);
  }
}
}
#line 294 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void stat_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 297
  call_arg_error("stat", name);
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void stat_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 303
  call_arg_warn("stat", name);
  }
#line 304
  return;
}
}
#line 306 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void truncate_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 309
  call_arg_error("truncate", name);
  }
#line 310
  return;
}
}
#line 312 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void truncate_warn(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 315
  call_arg_warn("truncate", name);
  }
#line 316
  return;
}
}
#line 318 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void unlink_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 321
  call_arg_error("unlink", name);
  }
#line 322
  return;
}
}
#line 324 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void utime_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 327
  call_arg_error("utime", name);
  }
#line 328
  return;
}
}
#line 330 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void waitpid_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 333
  call_arg_error("waitpid", name);
  }
#line 334
  return;
}
}
#line 336 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void write_error(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 339
  call_arg_error("write", name);
  }
#line 340
  return;
}
}
#line 342 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void write_error_details(char const   *name , size_t status , size_t size ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 345
  if (status == 0UL) {
    {
#line 346
    write_error(name);
    }
  } else {
    {
#line 348
    tmp = ngettext("%s: Wrote only %lu of %lu byte", "%s: Wrote only %lu of %lu bytes",
                   size);
#line 348
    error(0, 0, (char const   *)tmp, name, status, size);
#line 348
    exit_status = 2;
    }
  }
#line 353
  return;
}
}
#line 355 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void write_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 358
  call_arg_fatal("write", name);
  }
}
}
#line 361
 __attribute__((__noreturn__)) void chdir_fatal(char const   *name ) ;
#line 361 "/home/wslee/gnu_benchmarks/cpio-2.11/lib/error.c"
void chdir_fatal(char const   *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 364
  call_arg_fatal("chdir", name);
  }
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 103 "/usr/include/grp.h"
extern struct group___0 *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group___0 *getgrnam(char const   *__name ) ;
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/src/userspec.c"
static int isnumber_p(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! *str) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp = __ctype_b_loc();
    }
#line 54
    if (! ((int const   )*(*tmp + (int )*str) & 2048)) {
#line 55
      return (0);
    }
#line 53
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (1);
}
}
#line 75
char const   *parse_user_spec(char const   *spec_arg , uid_t *uid , gid_t *gid , char **username_arg ,
                              char **groupname_arg ) ;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/src/userspec.c"
static char const   *tired  =    "virtual memory exhausted";
#line 71 "/home/wslee/gnu_benchmarks/cpio-2.11/src/userspec.c"
char const   *parse_user_spec(char const   *spec_arg , uid_t *uid , gid_t *gid , char **username_arg ,
                              char **groupname_arg ) 
{ 
  char const   *error_msg ;
  char *spec ;
  struct passwd *pwd ;
  struct group___0 *grp ;
  char *g ;
  char *u ;
  char *separator ;
  char *groupname ;
  char *tmp ;
  int _len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int use_login_group ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char uint_buf[21] ;
  int _len___0 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int _len___1 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int _len___2 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 83
  error_msg = (char const   *)((void *)0);
#line 84
  tmp = (char *)((void *)0);
#line 84
  *groupname_arg = tmp;
#line 84
  *username_arg = tmp;
#line 85
  groupname = (char *)((void *)0);
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp___0 = strlen(spec_arg);
#line 87
    _len = (int )tmp___0;
#line 87
    tmp___1 = __builtin_alloca((unsigned long )(_len + 1));
#line 87
    spec = (char *)tmp___1;
#line 87
    strcpy((char */* __restrict  */)spec, (char const   */* __restrict  */)spec_arg);
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  separator = strchr((char const   *)spec, ':');
  }
#line 91
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
    {
#line 92
    separator = strchr((char const   *)spec, '.');
    }
  }
#line 95
  if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 96
    *separator = (char )'\000';
  }
#line 100
  if ((int )*spec == 0) {
#line 100
    u = (char *)((void *)0);
  } else {
#line 100
    u = spec;
  }
#line 102
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 102
    g = (char *)((void *)0);
  } else
#line 102
  if ((int )*(separator + 1) == 0) {
#line 102
    g = (char *)((void *)0);
  } else {
#line 102
    g = separator + 1;
  }
#line 106
  if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 106
    if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 107
      return ("can not omit both user and group");
    }
  }
#line 109
  if ((unsigned long )u != (unsigned long )((void *)0)) {
    {
#line 111
    pwd = getpwnam((char const   *)u);
    }
#line 112
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
      {
#line 115
      tmp___6 = isnumber_p((char const   *)u);
      }
#line 115
      if (tmp___6) {
#line 120
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 120
          if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 120
            tmp___3 = 1;
          } else {
#line 120
            tmp___3 = 0;
          }
        } else {
#line 120
          tmp___3 = 0;
        }
#line 120
        use_login_group = tmp___3;
#line 121
        if (use_login_group) {
          {
#line 122
          tmp___4 = gettext("cannot get the login group of a numeric UID");
#line 122
          error_msg = (char const   *)tmp___4;
          }
        } else {
          {
#line 124
          tmp___5 = atoi((char const   *)u);
#line 124
          *uid = (uid_t )tmp___5;
          }
        }
      } else {
        {
#line 116
        tmp___2 = gettext("invalid user");
#line 116
        error_msg = (char const   *)tmp___2;
        }
      }
    } else {
#line 129
      *uid = pwd->pw_uid;
#line 130
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 130
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          {
#line 134
          *gid = pwd->pw_gid;
#line 135
          grp = getgrgid(pwd->pw_gid);
          }
#line 136
          if ((unsigned long )grp == (unsigned long )((void *)0)) {
            {
#line 142
            sprintf((char */* __restrict  */)(uint_buf), (char const   */* __restrict  */)"%u",
                    pwd->pw_gid);
            }
            {
#line 143
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 143
              tmp___7 = strlen((char const   *)(uint_buf));
#line 143
              _len___0 = (int )tmp___7;
#line 143
              tmp___8 = __builtin_alloca((unsigned long )(_len___0 + 1));
#line 143
              groupname = (char *)tmp___8;
#line 143
              strcpy((char */* __restrict  */)groupname, (char const   */* __restrict  */)(uint_buf));
              }
#line 143
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 147
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 147
              tmp___9 = strlen((char const   *)grp->gr_name);
#line 147
              _len___1 = (int )tmp___9;
#line 147
              tmp___10 = __builtin_alloca((unsigned long )(_len___1 + 1));
#line 147
              groupname = (char *)tmp___10;
#line 147
              strcpy((char */* __restrict  */)groupname, (char const   */* __restrict  */)grp->gr_name);
              }
#line 147
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 155
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 155
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
      {
#line 158
      grp = getgrnam((char const   *)g);
      }
#line 159
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
        {
#line 161
        tmp___13 = isnumber_p((char const   *)g);
        }
#line 161
        if (tmp___13) {
          {
#line 164
          tmp___12 = atoi((char const   *)g);
#line 164
          *gid = (gid_t )tmp___12;
          }
        } else {
          {
#line 162
          tmp___11 = gettext("invalid group");
#line 162
          error_msg = (char const   *)tmp___11;
          }
        }
      } else {
#line 167
        *gid = grp->gr_gid;
      }
#line 170
      if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
        {
#line 171
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 171
          tmp___14 = strlen((char const   *)g);
#line 171
          _len___2 = (int )tmp___14;
#line 171
          tmp___15 = __builtin_alloca((unsigned long )(_len___2 + 1));
#line 171
          groupname = (char *)tmp___15;
#line 171
          strcpy((char */* __restrict  */)groupname, (char const   */* __restrict  */)g);
          }
#line 171
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 174
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 176
    if ((unsigned long )u != (unsigned long )((void *)0)) {
      {
#line 178
      *username_arg = strdup((char const   *)u);
      }
#line 179
      if ((unsigned long )*username_arg == (unsigned long )((void *)0)) {
#line 180
        error_msg = tired;
      }
    }
#line 183
    if ((unsigned long )groupname != (unsigned long )((void *)0)) {
#line 183
      if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
        {
#line 185
        *groupname_arg = strdup((char const   *)groupname);
        }
#line 186
        if ((unsigned long )*groupname_arg == (unsigned long )((void *)0)) {
#line 188
          if ((unsigned long )*username_arg != (unsigned long )((void *)0)) {
            {
#line 190
            free((void *)*username_arg);
#line 191
            *username_arg = (char *)((void *)0);
            }
          }
#line 193
          error_msg = tired;
        }
      }
    }
  }
#line 198
  return (error_msg);
}
}
#line 321 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 58 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
mode_t newdir_umask ;
#line 142
int make_path(char *argpath , uid_t owner , gid_t group , char const   *verbose_fmt_string ) ;
#line 215
void delay_set_stat(char const   *file_name___0 , struct stat *st , mode_t invert_permissions ) ;
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/src/makepath.c"
int make_path(char *argpath , uid_t owner , gid_t group , char const   *verbose_fmt_string ) 
{ 
  char *dirpath ;
  struct stat stats ;
  int retval ;
  mode_t tmpmode ;
  mode_t invert_permissions ;
  int we_are_root ;
  __uid_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *slash ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 58
  retval = 0;
#line 61
  tmp = getuid();
#line 61
  we_are_root = tmp == 0U;
#line 62
  tmp___0 = strlen((char const   *)argpath);
#line 62
  tmp___1 = __builtin_alloca(tmp___0 + 1UL);
#line 62
  dirpath = (char *)tmp___1;
#line 64
  strcpy((char */* __restrict  */)dirpath, (char const   */* __restrict  */)argpath);
#line 66
  tmp___16 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& stats));
  }
#line 66
  if (tmp___16) {
#line 68
    tmpmode = (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) & ~ newdir_umask;
#line 69
    if (we_are_root) {
#line 69
      invert_permissions = (mode_t )0;
    } else {
#line 69
      invert_permissions = 192U & ~ tmpmode;
    }
#line 71
    slash = dirpath;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! ((int )*slash == 47)) {
#line 72
        goto while_break;
      }
#line 73
      slash ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 74
      slash = strchr((char const   *)slash, '/');
      }
#line 74
      if (! slash) {
#line 74
        goto while_break___0;
      }
      {
#line 80
      *slash = (char )'\000';
#line 81
      tmp___7 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& stats));
      }
#line 81
      if (tmp___7) {
        {
#line 94
        tmp___5 = mkdir((char const   *)dirpath, tmpmode ^ invert_permissions);
        }
#line 94
        if (tmp___5) {
          {
#line 96
          tmp___2 = gettext("cannot make directory `%s\'");
#line 96
          tmp___3 = __errno_location();
#line 96
          error(0, *tmp___3, (char const   *)tmp___2, dirpath);
          }
#line 97
          return (1);
        } else {
#line 101
          if ((unsigned long )verbose_fmt_string != (unsigned long )((void *)0)) {
            {
#line 102
            error(0, 0, verbose_fmt_string, dirpath);
            }
          }
          {
#line 104
          tmp___4 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& stats));
          }
#line 104
          if (tmp___4) {
            {
#line 105
            stat_error((char const   *)dirpath);
            }
          } else {
#line 108
            if (owner != 4294967295U) {
#line 109
              stats.st_uid = owner;
            }
#line 110
            if (group != 4294967295U) {
#line 111
              stats.st_gid = group;
            }
            {
#line 113
            delay_set_stat((char const   *)dirpath, & stats, invert_permissions);
            }
          }
        }
      } else
#line 129
      if (! ((stats.st_mode & 61440U) == 16384U)) {
        {
#line 131
        tmp___6 = gettext("`%s\' exists but is not a directory");
#line 131
        error(0, 0, (char const   *)tmp___6, dirpath);
        }
#line 132
        return (1);
      }
#line 135
      tmp___8 = slash;
#line 135
      slash ++;
#line 135
      *tmp___8 = (char )'/';
      {
#line 139
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 139
        if (! ((int )*slash == 47)) {
#line 139
          goto while_break___1;
        }
#line 140
        slash ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 146
    tmp___14 = mkdir((char const   *)dirpath, tmpmode ^ invert_permissions);
    }
#line 146
    if (tmp___14) {
      {
#line 151
      tmp___11 = __errno_location();
      }
#line 151
      if (*tmp___11 != 17) {
        {
#line 155
        tmp___9 = gettext("cannot make directory `%s\'");
#line 155
        tmp___10 = __errno_location();
#line 155
        error(0, *tmp___10, (char const   *)tmp___9, dirpath);
        }
#line 156
        return (1);
      } else {
        {
#line 151
        tmp___12 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& stats));
        }
#line 151
        if (tmp___12 != 0) {
          {
#line 155
          tmp___9 = gettext("cannot make directory `%s\'");
#line 155
          tmp___10 = __errno_location();
#line 155
          error(0, *tmp___10, (char const   *)tmp___9, dirpath);
          }
#line 156
          return (1);
        } else
#line 151
        if (! ((stats.st_mode & 61440U) == 16384U)) {
          {
#line 155
          tmp___9 = gettext("cannot make directory `%s\'");
#line 155
          tmp___10 = __errno_location();
#line 155
          error(0, *tmp___10, (char const   *)tmp___9, dirpath);
          }
#line 156
          return (1);
        }
      }
    } else {
      {
#line 159
      tmp___13 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& stats));
      }
#line 159
      if (tmp___13) {
        {
#line 160
        stat_error((char const   *)dirpath);
        }
      } else {
#line 163
        if (owner != 4294967295U) {
#line 164
          stats.st_uid = owner;
        }
#line 165
        if (group != 4294967295U) {
#line 166
          stats.st_gid = group;
        }
        {
#line 168
        delay_set_stat((char const   *)dirpath, & stats, invert_permissions);
        }
      }
    }
#line 171
    if ((unsigned long )verbose_fmt_string != (unsigned long )((void *)0)) {
      {
#line 172
      error(0, 0, verbose_fmt_string, dirpath);
      }
    }
  } else
#line 179
  if (! ((stats.st_mode & 61440U) == 16384U)) {
    {
#line 181
    tmp___15 = gettext("`%s\' exists but is not a directory");
#line 181
    error(0, 0, (char const   *)tmp___15, dirpath);
    }
#line 182
    return (1);
  }
#line 187
  return (retval);
}
}
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 49 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
static struct userid *user_alist  ;
#line 52 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
static struct userid *nouser_alist  ;
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
char *getuser(uid_t uid ) 
{ 
  register struct userid *tail ;
  struct passwd *pwent ;
  char usernum_string[20] ;
  void *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 64
  tail = user_alist;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! tail) {
#line 64
      goto while_break;
    }
#line 65
    if (tail->id.u == uid) {
#line 66
      return (tail->name);
    }
#line 64
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  pwent = getpwuid(uid);
#line 69
  tmp = xmalloc(sizeof(struct userid ));
#line 69
  tail = (struct userid *)tmp;
#line 70
  tail->id.u = uid;
  }
#line 71
  if ((unsigned long )pwent == (unsigned long )((struct passwd *)0)) {
    {
#line 73
    sprintf((char */* __restrict  */)(usernum_string), (char const   */* __restrict  */)"%u",
            uid);
#line 74
    tail->name = xstrdup((char const   *)(usernum_string));
    }
  } else {
    {
#line 77
    tail->name = xstrdup((char const   *)pwent->pw_name);
    }
  }
#line 80
  tail->next = user_alist;
#line 81
  user_alist = tail;
#line 82
  return (tail->name);
}
}
#line 90 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
uid_t *getuidbyname(char *user ) 
{ 
  register struct userid *tail ;
  struct passwd *pwent ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 96
  tail = user_alist;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! tail) {
#line 96
      goto while_break;
    }
#line 98
    if ((int )*(tail->name) == (int )*user) {
      {
#line 98
      tmp = strcmp((char const   *)tail->name, (char const   *)user);
      }
#line 98
      if (! tmp) {
#line 99
        return (& tail->id.u);
      }
    }
#line 96
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  tail = nouser_alist;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! tail) {
#line 101
      goto while_break___0;
    }
#line 103
    if ((int )*(tail->name) == (int )*user) {
      {
#line 103
      tmp___0 = strcmp((char const   *)tail->name, (char const   *)user);
      }
#line 103
      if (! tmp___0) {
#line 104
        return ((uid_t *)0);
      }
    }
#line 101
    tail = tail->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 106
  pwent = getpwnam((char const   *)user);
#line 108
  tmp___1 = xmalloc(sizeof(struct userid ));
#line 108
  tail = (struct userid *)tmp___1;
#line 109
  tail->name = xstrdup((char const   *)user);
  }
#line 112
  if (pwent) {
#line 114
    tail->id.u = pwent->pw_uid;
#line 115
    tail->next = user_alist;
#line 116
    user_alist = tail;
#line 117
    return (& tail->id.u);
  }
#line 120
  tail->next = nouser_alist;
#line 121
  nouser_alist = tail;
#line 122
  return ((uid_t *)0);
}
}
#line 126 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
static struct userid *group_alist  ;
#line 127 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
static struct userid *nogroup_alist  ;
#line 132 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
char *getgroup(gid_t gid ) 
{ 
  register struct userid *tail ;
  struct group___0 *grent ;
  char groupnum_string[20] ;
  void *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 139
  tail = group_alist;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! tail) {
#line 139
      goto while_break;
    }
#line 140
    if (tail->id.g == gid) {
#line 141
      return (tail->name);
    }
#line 139
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  grent = getgrgid(gid);
#line 144
  tmp = xmalloc(sizeof(struct userid ));
#line 144
  tail = (struct userid *)tmp;
#line 145
  tail->id.g = gid;
  }
#line 146
  if ((unsigned long )grent == (unsigned long )((struct group___0 *)0)) {
    {
#line 148
    sprintf((char */* __restrict  */)(groupnum_string), (char const   */* __restrict  */)"%u",
            gid);
#line 149
    tail->name = xstrdup((char const   *)(groupnum_string));
    }
  } else {
    {
#line 152
    tail->name = xstrdup((char const   *)grent->gr_name);
    }
  }
#line 155
  tail->next = group_alist;
#line 156
  group_alist = tail;
#line 157
  return (tail->name);
}
}
#line 165 "/home/wslee/gnu_benchmarks/cpio-2.11/src/idcache.c"
gid_t *getgidbyname(char *group ) 
{ 
  register struct userid *tail ;
  struct group___0 *grent ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 171
  tail = group_alist;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! tail) {
#line 171
      goto while_break;
    }
#line 173
    if ((int )*(tail->name) == (int )*group) {
      {
#line 173
      tmp = strcmp((char const   *)tail->name, (char const   *)group);
      }
#line 173
      if (! tmp) {
#line 174
        return (& tail->id.g);
      }
    }
#line 171
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  tail = nogroup_alist;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! tail) {
#line 176
      goto while_break___0;
    }
#line 178
    if ((int )*(tail->name) == (int )*group) {
      {
#line 178
      tmp___0 = strcmp((char const   *)tail->name, (char const   *)group);
      }
#line 178
      if (! tmp___0) {
#line 179
        return ((gid_t *)0);
      }
    }
#line 176
    tail = tail->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 181
  grent = getgrnam((char const   *)group);
#line 183
  tmp___1 = xmalloc(sizeof(struct userid ));
#line 183
  tail = (struct userid *)tmp___1;
#line 184
  tail->name = xstrdup((char const   *)group);
  }
#line 187
  if (grent) {
#line 189
    tail->id.g = grent->gr_gid;
#line 190
    tail->next = group_alist;
#line 191
    group_alist = tail;
#line 192
    return (& tail->id.g);
  }
#line 195
  tail->next = nogroup_alist;
#line 196
  nogroup_alist = tail;
#line 197
  return ((gid_t *)0);
}
}
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/src/filemode.c"
static char ftypelet(long bits ) 
{ 


  {
#line 109
  if ((bits & 61440L) == 24576L) {
#line 110
    return ((char )'b');
  }
#line 112
  if ((bits & 61440L) == 8192L) {
#line 113
    return ((char )'c');
  }
#line 114
  if ((bits & 61440L) == 16384L) {
#line 115
    return ((char )'d');
  }
#line 116
  if ((bits & 61440L) == 32768L) {
#line 117
    return ((char )'-');
  }
#line 119
  if ((bits & 61440L) == 4096L) {
#line 120
    return ((char )'p');
  }
#line 123
  if ((bits & 61440L) == 40960L) {
#line 124
    return ((char )'l');
  }
#line 127
  if ((bits & 61440L) == 49152L) {
#line 128
    return ((char )'s');
  }
#line 138
  return ((char )'?');
}
}
#line 144 "/home/wslee/gnu_benchmarks/cpio-2.11/src/filemode.c"
static void rwx(unsigned short bits , char *chars ) 
{ 


  {
#line 147
  if ((int )bits & 256) {
#line 147
    *(chars + 0) = (char )'r';
  } else {
#line 147
    *(chars + 0) = (char )'-';
  }
#line 148
  if ((int )bits & 128) {
#line 148
    *(chars + 1) = (char )'w';
  } else {
#line 148
    *(chars + 1) = (char )'-';
  }
#line 149
  if ((int )bits & 64) {
#line 149
    *(chars + 2) = (char )'x';
  } else {
#line 149
    *(chars + 2) = (char )'-';
  }
#line 150
  return;
}
}
#line 155 "/home/wslee/gnu_benchmarks/cpio-2.11/src/filemode.c"
static void setst(unsigned short bits , char *chars ) 
{ 


  {
#line 159
  if ((int )bits & 2048) {
#line 161
    if ((int )*(chars + 3) != 120) {
#line 163
      *(chars + 3) = (char )'S';
    } else {
#line 165
      *(chars + 3) = (char )'s';
    }
  }
#line 169
  if ((int )bits & 1024) {
#line 171
    if ((int )*(chars + 6) != 120) {
#line 173
      *(chars + 6) = (char )'S';
    } else {
#line 175
      *(chars + 6) = (char )'s';
    }
  }
#line 179
  if ((int )bits & 512) {
#line 181
    if ((int )*(chars + 9) != 120) {
#line 183
      *(chars + 9) = (char )'T';
    } else {
#line 185
      *(chars + 9) = (char )'t';
    }
  }
#line 188
  return;
}
}
#line 193 "/home/wslee/gnu_benchmarks/cpio-2.11/src/filemode.c"
void mode_string(unsigned short mode , char *str ) 
{ 


  {
  {
#line 196
  *(str + 0) = ftypelet((long )mode);
#line 197
  rwx((unsigned short )((int )mode & 448), str + 1);
#line 198
  rwx((unsigned short )(((int )mode & 56) << 3), str + 4);
#line 199
  rwx((unsigned short )(((int )mode & 7) << 6), str + 7);
#line 200
  setst(mode, str);
  }
#line 201
  return;
}
}
#line 239 "/home/wslee/gnu_benchmarks/cpio-2.11/src/filemode.c"
void filemodestring(struct stat *statp , char *str ) 
{ 


  {
  {
#line 242
  mode_string((unsigned short )statp->st_mode, str);
  }
#line 243
  return;
}
}
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 297
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 469
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 474
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 229 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 47 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.h"
void ds_init(dynamic_string *string , int size ) ;
#line 50
char *ds_fgets(FILE *f , dynamic_string *s ) ;
#line 32 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int io_block_size ;
#line 33
int create_dir_flag ;
#line 41
int retain_time_flag ;
#line 42
int crc_i_flag ;
#line 43
int append_flag ;
#line 46
int swapping_bytes ;
#line 47
int swapping_halfwords ;
#line 48
int set_owner_flag ;
#line 49
uid_t set_owner ;
#line 50
int set_group_flag ;
#line 51
gid_t set_group ;
#line 52
int no_chown_flag ;
#line 53
int sparse_flag ;
#line 55
int only_verify_crc_flag ;
#line 57
unsigned int warn_option ;
#line 66
_Bool to_stdout_option ;
#line 68
int last_header_start ;
#line 72
char *new_media_message ;
#line 73
char *new_media_message_with_number ;
#line 74
char *new_media_message_after_number ;
#line 76
char *archive_name ;
#line 77
char *rsh_command_option ;
#line 78
unsigned long crc ;
#line 79
int delayed_seek_count ;
#line 84
char *input_buffer ;
#line 84
char *output_buffer ;
#line 85
char *in_buff ;
#line 85
char *out_buff ;
#line 86
size_t input_buffer_size ;
#line 87
size_t input_size ;
#line 87
size_t output_size ;
#line 88
off_t input_bytes ;
#line 88
off_t output_bytes ;
#line 94
char input_is_special ;
#line 95
char output_is_special ;
#line 98
int (*xstat)() ;
#line 99
void (*copy_function)() ;
#line 110
void swab_array(char *ptr , int count ) ;
#line 111
void process_copy_in(void) ;
#line 158
void tape_empty_output_buffer(int out_des ) ;
#line 159
void disk_empty_output_buffer(int out_des ) ;
#line 160
void swahw_array(char *ptr , int count ) ;
#line 161
void tape_buffered_write(char *in_buf , int out_des , off_t num_bytes ) ;
#line 162
void tape_buffered_read(char *in_buf , int in_des , off_t num_bytes ) ;
#line 163
int tape_buffered_peek(char *peek_buf , int in_des , int num_bytes ) ;
#line 164
void tape_toss_input(int in_des , off_t num_bytes ) ;
#line 165
void copy_files_tape_to_disk(int in_des , int out_des , off_t num_bytes ) ;
#line 166
void copy_files_disk_to_tape(int in_des , int out_des , off_t num_bytes , char *filename ) ;
#line 167
void copy_files_disk_to_disk(int in_des , int out_des , off_t num_bytes , char *filename ) ;
#line 168
void warn_if_file_changed(char *file_name___0 , off_t old_file_size , time_t old_file_mtime ) ;
#line 170
void create_all_directories(char *name ) ;
#line 171
void prepare_append(int out_file_des ) ;
#line 172
char *find_inode_file(ino_t node_num , unsigned long major_num , unsigned long minor_num ) ;
#line 174
void add_inode(ino_t node_num , char *file_name___0 , unsigned long major_num , unsigned long minor_num ) ;
#line 176
int open_archive(char *file ) ;
#line 177
void tape_offline(int tape_des ) ;
#line 178
void get_next_reel(int tape_des ) ;
#line 179
void set_new_media_message(char *message ) ;
#line 183
void write_nuls_to_file(off_t num_bytes , int out_des , void (*writer)(char *in_buf ,
                                                                       int out_des ,
                                                                       off_t num_bytes ) ) ;
#line 195
void set_perms(int fd , struct cpio_file_stat *header ) ;
#line 196
void set_file_times(int fd , char const   *name , unsigned long atime , unsigned long mtime ) ;
#line 198
void stat_to_cpio(struct cpio_file_stat *hdr , struct stat *st ) ;
#line 199
void cpio_to_stat(struct stat *st , struct cpio_file_stat *hdr ) ;
#line 200
void cpio_safer_name_suffix(char *name , _Bool link_target , _Bool absolute_names ,
                            _Bool strip_leading_dots ) ;
#line 202
int cpio_create_dir(struct cpio_file_stat *file_hdr , int existing_dir ) ;
#line 213
void delay_cpio_set_stat(struct cpio_file_stat *file_stat , mode_t invert_permissions ) ;
#line 217
int repair_delayed_set_stat(struct cpio_file_stat *file_hdr ) ;
#line 218
void apply_delayed_set_stat(void) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 54 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void tape_empty_output_buffer(int out_des ) 
{ 
  int bytes_written ;
  size_t tmp ;
  size_t tmp___0 ;
  int rest_bytes_written ;
  int rest_output_size ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 74
  if (out_des >= 1 << 30) {
    {
#line 74
    tmp = rmt_write__(out_des - (1 << 30), output_buffer, output_size);
#line 74
    bytes_written = (int )tmp;
    }
  } else {
    {
#line 74
    tmp___0 = full_write(out_des, (void const   *)output_buffer, output_size);
#line 74
    bytes_written = (int )tmp___0;
    }
  }
#line 75
  if ((size_t )bytes_written != output_size) {
#line 80
    if (output_is_special) {
#line 80
      if (bytes_written >= 0) {
#line 80
        goto _L___0;
      } else
#line 80
      if (bytes_written < 0) {
        {
#line 80
        tmp___7 = __errno_location();
        }
#line 80
        if (*tmp___7 == 28) {
#line 80
          goto _L___0;
        } else {
          {
#line 80
          tmp___8 = __errno_location();
          }
#line 80
          if (*tmp___8 == 5) {
#line 80
            goto _L___0;
          } else {
            {
#line 80
            tmp___9 = __errno_location();
            }
#line 80
            if (*tmp___9 == 6) {
              _L___0: /* CIL Label */ 
              {
#line 85
              get_next_reel(out_des);
              }
#line 86
              if (bytes_written > 0) {
#line 87
                rest_output_size = (int )(output_size - (size_t )bytes_written);
              } else {
#line 89
                rest_output_size = (int )output_size;
              }
#line 90
              if (out_des >= 1 << 30) {
                {
#line 90
                tmp___1 = rmt_write__(out_des - (1 << 30), output_buffer, (size_t )rest_output_size);
#line 90
                rest_bytes_written = (int )tmp___1;
                }
              } else {
                {
#line 90
                tmp___2 = full_write(out_des, (void const   *)output_buffer, (size_t )rest_output_size);
#line 90
                rest_bytes_written = (int )tmp___2;
                }
              }
#line 92
              if (rest_bytes_written != rest_output_size) {
                {
#line 93
                tmp___3 = gettext("write error");
#line 93
                tmp___4 = __errno_location();
#line 93
                error(1, *tmp___4, (char const   *)tmp___3);
                }
              }
            } else {
              {
#line 96
              tmp___5 = gettext("write error");
#line 96
              tmp___6 = __errno_location();
#line 96
              error(1, *tmp___6, (char const   *)tmp___5);
              }
            }
          }
        }
      } else {
        {
#line 96
        tmp___5 = gettext("write error");
#line 96
        tmp___6 = __errno_location();
#line 96
        error(1, *tmp___6, (char const   *)tmp___5);
        }
      }
    } else {
      {
#line 96
      tmp___5 = gettext("write error");
#line 96
      tmp___6 = __errno_location();
#line 96
      error(1, *tmp___6, (char const   *)tmp___5);
      }
    }
  }
#line 98
  output_bytes = (off_t )((size_t )output_bytes + output_size);
#line 99
  out_buff = output_buffer;
#line 100
  output_size = (size_t )0;
#line 101
  return;
}
}
#line 103
static int sparse_write(int fildes , char *buf , unsigned int nbyte ) ;
#line 115 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void disk_empty_output_buffer(int out_des ) 
{ 
  int bytes_written ;
  int complete_words ;
  int complete_halfwords ;
  ssize_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 120
  if (swapping_halfwords) {
#line 120
    goto _L;
  } else
#line 120
  if (swapping_bytes) {
    _L: /* CIL Label */ 
#line 122
    if (swapping_halfwords) {
      {
#line 125
      complete_words = (int )(output_size / 4UL);
#line 126
      swahw_array(output_buffer, complete_words);
      }
#line 127
      if (swapping_bytes) {
        {
#line 128
        swab_array(output_buffer, 2 * complete_words);
        }
      }
    } else {
      {
#line 133
      complete_halfwords = (int )(output_size / 2UL);
#line 134
      swab_array(output_buffer, complete_halfwords);
      }
    }
  }
#line 138
  if (sparse_flag) {
    {
#line 139
    bytes_written = sparse_write(out_des, output_buffer, (unsigned int )output_size);
    }
  } else {
    {
#line 141
    tmp = write(out_des, (void const   *)output_buffer, output_size);
#line 141
    bytes_written = (int )tmp;
    }
  }
#line 143
  if ((size_t )bytes_written != output_size) {
    {
#line 145
    tmp___0 = gettext("write error");
#line 145
    tmp___1 = __errno_location();
#line 145
    error(1, *tmp___1, (char const   *)tmp___0);
    }
  }
#line 147
  output_bytes = (off_t )((size_t )output_bytes + output_size);
#line 148
  out_buff = output_buffer;
#line 149
  output_size = (size_t )0;
#line 150
  return;
}
}
#line 156 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void swahw_array(char *ptr , int count ) 
{ 
  char tmp ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (count > 0)) {
#line 161
      goto while_break;
    }
#line 163
    tmp = *ptr;
#line 164
    *ptr = *(ptr + 2);
#line 165
    *(ptr + 2) = tmp;
#line 166
    ptr ++;
#line 167
    tmp = *ptr;
#line 168
    *ptr = *(ptr + 2);
#line 169
    *(ptr + 2) = tmp;
#line 170
    ptr += 3;
#line 161
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 183 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static void tape_fill_input_buffer(int in_des , int num_bytes ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 198
  in_buff = input_buffer;
#line 199
  if (num_bytes < io_block_size) {
#line 199
    num_bytes = num_bytes;
  } else {
#line 199
    num_bytes = io_block_size;
  }
#line 200
  if (in_des >= 1 << 30) {
    {
#line 200
    tmp = rmt_read__(in_des - (1 << 30), input_buffer, (size_t )num_bytes);
#line 200
    input_size = tmp;
    }
  } else {
    {
#line 200
    tmp___0 = safe_read(in_des, (void *)input_buffer, (size_t )num_bytes);
#line 200
    input_size = tmp___0;
    }
  }
#line 201
  if (input_size == 0UL) {
#line 201
    if (input_is_special) {
      {
#line 203
      get_next_reel(in_des);
      }
#line 204
      if (in_des >= 1 << 30) {
        {
#line 204
        tmp___1 = rmt_read__(in_des - (1 << 30), input_buffer, (size_t )num_bytes);
#line 204
        input_size = tmp___1;
        }
      } else {
        {
#line 204
        tmp___2 = safe_read(in_des, (void *)input_buffer, (size_t )num_bytes);
#line 204
        input_size = tmp___2;
        }
      }
    }
  }
#line 206
  if (input_size < 0UL) {
    {
#line 207
    tmp___3 = gettext("read error");
#line 207
    tmp___4 = __errno_location();
#line 207
    error(1, *tmp___4, (char const   *)tmp___3);
    }
  }
#line 208
  if (input_size == 0UL) {
    {
#line 210
    tmp___5 = gettext("premature end of file");
#line 210
    error(0, 0, (char const   *)tmp___5);
#line 211
    exit(1);
    }
  }
#line 213
  input_bytes = (off_t )((size_t )input_bytes + input_size);
#line 214
  return;
}
}
#line 221 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static int disk_fill_input_buffer(int in_des , off_t num_bytes ) 
{ 
  ssize_t tmp ;

  {
#line 224
  in_buff = input_buffer;
#line 225
  if (num_bytes < 512L) {
#line 225
    num_bytes = num_bytes;
  } else {
#line 225
    num_bytes = (off_t )512;
  }
  {
#line 226
  tmp = (ssize_t )read(in_des, (void *)input_buffer, (size_t )num_bytes);
#line 226
  input_size = (size_t )tmp;
  }
#line 227
  if (input_size < 0UL) {
#line 229
    input_size = (size_t )0;
#line 230
    return (-1);
  } else
#line 232
  if (input_size == 0UL) {
#line 233
    return (1);
  }
#line 234
  input_bytes = (off_t )((size_t )input_bytes + input_size);
#line 235
  return (0);
}
}
#line 241 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void tape_buffered_write(char *in_buf , int out_des , off_t num_bytes ) 
{ 
  off_t bytes_left ;
  off_t space_left ;

  {
#line 244
  bytes_left = num_bytes;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (bytes_left > 0L)) {
#line 247
      goto while_break;
    }
#line 249
    space_left = (off_t )((size_t )io_block_size - output_size);
#line 250
    if (space_left == 0L) {
      {
#line 251
      tape_empty_output_buffer(out_des);
      }
    } else {
#line 254
      if (bytes_left < space_left) {
#line 255
        space_left = bytes_left;
      }
      {
#line 256
      memcpy((void */* __restrict  */)out_buff, (void const   */* __restrict  */)in_buf,
             (size_t )((unsigned int )space_left));
#line 257
      out_buff += space_left;
#line 258
      output_size += (size_t )space_left;
#line 259
      in_buf += space_left;
#line 260
      bytes_left -= space_left;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 268 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void disk_buffered_write(char *in_buf , int out_des , off_t num_bytes ) 
{ 
  off_t bytes_left ;
  off_t space_left ;

  {
#line 271
  bytes_left = num_bytes;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (bytes_left > 0L)) {
#line 274
      goto while_break;
    }
#line 276
    space_left = (off_t )(512UL - output_size);
#line 277
    if (space_left == 0L) {
      {
#line 278
      disk_empty_output_buffer(out_des);
      }
    } else {
#line 281
      if (bytes_left < space_left) {
#line 282
        space_left = bytes_left;
      }
      {
#line 283
      memcpy((void */* __restrict  */)out_buff, (void const   */* __restrict  */)in_buf,
             (size_t )((unsigned int )space_left));
#line 284
      out_buff += space_left;
#line 285
      output_size += (size_t )space_left;
#line 286
      in_buf += space_left;
#line 287
      bytes_left -= space_left;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 296 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void tape_buffered_read(char *in_buf , int in_des , off_t num_bytes ) 
{ 
  off_t bytes_left ;
  off_t space_left ;

  {
#line 299
  bytes_left = num_bytes;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! (bytes_left > 0L)) {
#line 302
      goto while_break;
    }
#line 304
    if (input_size == 0UL) {
      {
#line 305
      tape_fill_input_buffer(in_des, io_block_size);
      }
    }
#line 306
    if ((size_t )bytes_left < input_size) {
#line 307
      space_left = bytes_left;
    } else {
#line 309
      space_left = (off_t )input_size;
    }
    {
#line 310
    memcpy((void */* __restrict  */)in_buf, (void const   */* __restrict  */)in_buff,
           (size_t )((unsigned int )space_left));
#line 311
    in_buff += space_left;
#line 312
    in_buf += space_left;
#line 313
    input_size -= (size_t )space_left;
#line 314
    bytes_left -= space_left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 326 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int tape_buffered_peek(char *peek_buf , int in_des , int num_bytes ) 
{ 
  long tmp_input_size ;
  long got_bytes ;
  char *append_buf ;
  int half ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp14 ;

  {
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (input_size < (size_t )num_bytes)) {
#line 346
      goto while_break;
    }
#line 348
    append_buf = in_buff + input_size;
#line 349
    if ((size_t )(append_buf - input_buffer) >= input_buffer_size) {
      {
#line 359
      half = (int )(input_buffer_size / 2UL);
#line 360
      memmove((void *)input_buffer, (void const   *)(input_buffer + half), (size_t )half);
#line 361
      in_buff -= half;
#line 362
      append_buf -= half;
      }
    }
#line 364
    if (in_des >= 1 << 30) {
      {
#line 364
      tmp = rmt_read__(in_des - (1 << 30), append_buf, (size_t )io_block_size);
#line 364
      tmp_input_size = (long )tmp;
      }
    } else {
      {
#line 364
      tmp___0 = safe_read(in_des, (void *)append_buf, (size_t )io_block_size);
#line 364
      tmp_input_size = (long )tmp___0;
      }
    }
#line 365
    if (tmp_input_size == 0L) {
#line 367
      if (input_is_special) {
        {
#line 369
        get_next_reel(in_des);
        }
#line 370
        if (in_des >= 1 << 30) {
          {
#line 370
          tmp___1 = rmt_read__(in_des - (1 << 30), append_buf, (size_t )io_block_size);
#line 370
          tmp_input_size = (long )tmp___1;
          }
        } else {
          {
#line 370
          tmp___2 = safe_read(in_des, (void *)append_buf, (size_t )io_block_size);
#line 370
          tmp_input_size = (long )tmp___2;
          }
        }
      } else {
#line 373
        goto while_break;
      }
    }
#line 375
    if (tmp_input_size < 0L) {
      {
#line 376
      tmp___3 = gettext("read error");
#line 376
      tmp___4 = __errno_location();
#line 376
      error(1, *tmp___4, (char const   *)tmp___3);
      }
    }
#line 377
    input_bytes += tmp_input_size;
#line 378
    input_size += (size_t )tmp_input_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if ((size_t )num_bytes <= input_size) {
#line 381
    got_bytes = (long )num_bytes;
  } else {
#line 383
    got_bytes = (long )input_size;
  }
  {
#line 384
  memcpy((void */* __restrict  */)peek_buf, (void const   */* __restrict  */)in_buff,
         (size_t )((unsigned int )got_bytes));
  }
#line 385
  return ((int )got_bytes);
}
}
#line 390 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void tape_toss_input(int in_des , off_t num_bytes ) 
{ 
  off_t bytes_left ;
  off_t space_left ;
  int k ;

  {
#line 393
  bytes_left = num_bytes;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (bytes_left > 0L)) {
#line 396
      goto while_break;
    }
#line 398
    if (input_size == 0UL) {
      {
#line 399
      tape_fill_input_buffer(in_des, io_block_size);
      }
    }
#line 400
    if ((size_t )bytes_left < input_size) {
#line 401
      space_left = bytes_left;
    } else {
#line 403
      space_left = (off_t )input_size;
    }
#line 405
    if (crc_i_flag) {
#line 405
      if (only_verify_crc_flag) {
#line 408
        k = 0;
        {
#line 408
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 408
          if (! ((off_t )k < space_left)) {
#line 408
            goto while_break___0;
          }
#line 409
          crc += (unsigned long )((int )*(in_buff + k) & 255);
#line 408
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 412
    in_buff += space_left;
#line 413
    input_size -= (size_t )space_left;
#line 414
    bytes_left -= space_left;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 425 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static char zeros_512[512]  ;
#line 418 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void write_nuls_to_file(off_t num_bytes , int out_des , void (*writer)(char *in_buf ,
                                                                       int out_des ,
                                                                       off_t num_bytes ) ) 
{ 
  off_t blocks ;
  off_t extra_bytes ;
  off_t i ;

  {
#line 427
  blocks = (off_t )((unsigned long )num_bytes / sizeof(zeros_512));
#line 428
  extra_bytes = (off_t )((unsigned long )num_bytes % sizeof(zeros_512));
#line 429
  i = (off_t )0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < blocks)) {
#line 429
      goto while_break;
    }
    {
#line 430
    (*writer)(zeros_512, out_des, (off_t )sizeof(zeros_512));
#line 429
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if (extra_bytes) {
    {
#line 432
    (*writer)(zeros_512, out_des, extra_bytes);
    }
  }
#line 433
  return;
}
}
#line 443 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void copy_files_tape_to_disk(int in_des , int out_des , off_t num_bytes ) 
{ 
  off_t size ;
  off_t k ;

  {
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (num_bytes > 0L)) {
#line 449
      goto while_break;
    }
#line 451
    if (input_size == 0UL) {
      {
#line 452
      tape_fill_input_buffer(in_des, io_block_size);
      }
    }
#line 453
    if (input_size < (size_t )num_bytes) {
#line 453
      size = (off_t )input_size;
    } else {
#line 453
      size = num_bytes;
    }
#line 454
    if (crc_i_flag) {
#line 456
      k = (off_t )0;
      {
#line 456
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 456
        if (! (k < size)) {
#line 456
          goto while_break___0;
        }
#line 457
        crc += (unsigned long )((int )*(in_buff + k) & 255);
#line 456
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 459
    disk_buffered_write(in_buff, out_des, size);
#line 460
    num_bytes -= size;
#line 461
    input_size -= (size_t )size;
#line 462
    in_buff += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 473 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void copy_files_disk_to_tape(int in_des , int out_des , off_t num_bytes , char *filename ) 
{ 
  off_t size ;
  off_t k ;
  int rc ;
  off_t original_num_bytes ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  off_t tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 482
  original_num_bytes = num_bytes;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (num_bytes > 0L)) {
#line 484
      goto while_break;
    }
#line 486
    if (input_size == 0UL) {
#line 487
      if (num_bytes < 512L) {
#line 487
        tmp___2 = num_bytes;
      } else {
#line 487
        tmp___2 = (off_t )512;
      }
      {
#line 487
      rc = disk_fill_input_buffer(in_des, tmp___2);
      }
#line 487
      if (rc) {
#line 491
        if (rc > 0) {
          {
#line 494
          tmp = umaxtostr((uintmax_t )num_bytes, buf);
#line 494
          tmp___0 = ngettext("File %s shrunk by %s byte, padding with zeros", "File %s shrunk by %s bytes, padding with zeros",
                             (unsigned long )num_bytes);
#line 494
          error(0, 0, (char const   *)tmp___0, filename, tmp);
          }
        } else {
          {
#line 501
          tmp___1 = gettext("Read error at byte %lld in file %s, padding with zeros");
#line 501
          error(0, 0, (char const   *)tmp___1, original_num_bytes - num_bytes, filename);
          }
        }
        {
#line 503
        write_nuls_to_file(num_bytes, out_des, & tape_buffered_write);
        }
#line 504
        goto while_break;
      }
    }
#line 506
    if (input_size < (size_t )num_bytes) {
#line 506
      size = (off_t )input_size;
    } else {
#line 506
      size = num_bytes;
    }
#line 507
    if (crc_i_flag) {
#line 509
      k = (off_t )0;
      {
#line 509
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 509
        if (! (k < size)) {
#line 509
          goto while_break___0;
        }
#line 510
        crc += (unsigned long )((int )*(in_buff + k) & 255);
#line 509
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 512
    tape_buffered_write(in_buff, out_des, size);
#line 513
    num_bytes -= size;
#line 514
    input_size -= (size_t )size;
#line 515
    in_buff += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 526 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void copy_files_disk_to_disk(int in_des , int out_des , off_t num_bytes , char *filename ) 
{ 
  off_t size ;
  off_t k ;
  off_t original_num_bytes ;
  int rc ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 535
  original_num_bytes = num_bytes;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (num_bytes > 0L)) {
#line 536
      goto while_break;
    }
#line 538
    if (input_size == 0UL) {
      {
#line 539
      rc = disk_fill_input_buffer(in_des, num_bytes);
      }
#line 539
      if (rc) {
#line 541
        if (rc > 0) {
          {
#line 544
          tmp = umaxtostr((uintmax_t )num_bytes, buf);
#line 544
          tmp___0 = ngettext("File %s shrunk by %s byte, padding with zeros", "File %s shrunk by %s bytes, padding with zeros",
                             (unsigned long )num_bytes);
#line 544
          error(0, 0, (char const   *)tmp___0, filename, tmp);
          }
        } else {
          {
#line 551
          tmp___1 = gettext("Read error at byte %lld in file %s, padding with zeros");
#line 551
          error(0, 0, (char const   *)tmp___1, original_num_bytes - num_bytes, filename);
          }
        }
        {
#line 553
        write_nuls_to_file(num_bytes, out_des, & disk_buffered_write);
        }
#line 554
        goto while_break;
      }
    }
#line 556
    if (input_size < (size_t )num_bytes) {
#line 556
      size = (off_t )input_size;
    } else {
#line 556
      size = num_bytes;
    }
#line 557
    if (crc_i_flag) {
#line 559
      k = (off_t )0;
      {
#line 559
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 559
        if (! (k < size)) {
#line 559
          goto while_break___0;
        }
#line 560
        crc += (unsigned long )((int )*(in_buff + k) & 255);
#line 559
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 562
    disk_buffered_write(in_buff, out_des, size);
#line 563
    num_bytes -= size;
#line 564
    input_size -= (size_t )size;
#line 565
    in_buff += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  return;
}
}
#line 571 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void warn_if_file_changed(char *file_name___0 , off_t old_file_size , time_t old_file_mtime ) 
{ 
  struct stat new_file_stat ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 576
  tmp = (*xstat)(file_name___0, & new_file_stat);
  }
#line 576
  if (tmp < 0) {
    {
#line 578
    stat_error((char const   *)file_name___0);
    }
#line 579
    return;
  }
#line 584
  if (new_file_stat.st_size > old_file_size) {
    {
#line 585
    tmp___0 = ngettext("File %s grew, %lu new byte not copied", "File %s grew, %lu new bytes not copied",
                       (unsigned long )(new_file_stat.st_size - old_file_size));
#line 585
    error(0, 0, (char const   *)tmp___0, file_name___0, (uintmax_t )(new_file_stat.st_size - old_file_size));
    }
  } else
#line 591
  if (new_file_stat.st_mtim.tv_sec != old_file_mtime) {
    {
#line 592
    tmp___1 = gettext("File %s was modified while being copied");
#line 592
    error(0, 0, (char const   *)tmp___1, file_name___0);
    }
  }
#line 593
  return;
}
}
#line 598 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void create_all_directories(char *name ) 
{ 
  char *dir ;
  int mode ;
  char *tmp ;
  char const   *fmt ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 607
  dir = dir_name((char const   *)name);
#line 608
  mode = 448;
  }
#line 619
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 620
    tmp = gettext("virtual memory exhausted");
#line 620
    error(2, 0, (char const   *)tmp);
    }
  }
#line 622
  if ((int )*(dir + 0) != 46) {
#line 622
    goto _L;
  } else
#line 622
  if ((int )*(dir + 1) != 0) {
    _L: /* CIL Label */ 
#line 625
    if (warn_option & 2U) {
      {
#line 626
      tmp___0 = gettext("Creating intermediate directory `%s\'");
#line 626
      fmt = (char const   *)tmp___0;
      }
    } else {
#line 628
      fmt = (char const   *)((void *)0);
    }
    {
#line 629
    make_path(dir, (uid_t )-1, (gid_t )-1, fmt);
    }
  }
  {
#line 632
  free((void *)dir);
  }
#line 633
  return;
}
}
#line 649 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void prepare_append(int out_file_des ) 
{ 
  int start_of_header ;
  int start_of_block ;
  int useful_bytes_in_block ;
  char *tmp_buf ;
  char *tmp ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  __off_t tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 657
  start_of_header = last_header_start;
#line 659
  useful_bytes_in_block = start_of_header % io_block_size;
#line 660
  start_of_block = start_of_header - useful_bytes_in_block;
#line 662
  tmp___1 = lseek(out_file_des, (__off_t )start_of_block, 0);
  }
#line 662
  if (tmp___1 < 0L) {
    {
#line 663
    tmp = gettext("cannot seek on output");
#line 663
    tmp___0 = __errno_location();
#line 663
    error(1, *tmp___0, (char const   *)tmp);
    }
  }
#line 664
  if (useful_bytes_in_block > 0) {
    {
#line 666
    tmp___2 = xmalloc((size_t )useful_bytes_in_block);
#line 666
    tmp_buf = (char *)tmp___2;
#line 667
    read(out_file_des, (void *)tmp_buf, (size_t )useful_bytes_in_block);
#line 668
    tmp___5 = lseek(out_file_des, (__off_t )start_of_block, 0);
    }
#line 668
    if (tmp___5 < 0L) {
      {
#line 669
      tmp___3 = gettext("cannot seek on output");
#line 669
      tmp___4 = __errno_location();
#line 669
      error(1, *tmp___4, (char const   *)tmp___3);
      }
    }
    {
#line 671
    tape_buffered_write(tmp_buf, out_file_des, (off_t )useful_bytes_in_block);
#line 672
    free((void *)tmp_buf);
    }
  }
#line 678
  input_size = (size_t )0;
#line 679
  input_bytes = (off_t )0;
#line 680
  in_buff = input_buffer;
#line 681
  return;
}
}
#line 696 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static Hash_table *hash_table  =    (Hash_table *)((void *)0);
#line 698 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static size_t inode_val_hasher(void const   *val , size_t n_buckets ) 
{ 
  struct inode_val  const  *ival ;

  {
#line 701
  ival = (struct inode_val  const  *)val;
#line 702
  return ((size_t )(ival->inode % (unsigned long const   )n_buckets));
}
}
#line 705 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static _Bool inode_val_compare(void const   *val1 , void const   *val2 ) 
{ 
  struct inode_val  const  *ival1 ;
  struct inode_val  const  *ival2 ;
  int tmp ;

  {
#line 708
  ival1 = (struct inode_val  const  *)val1;
#line 709
  ival2 = (struct inode_val  const  *)val2;
#line 710
  if (ival1->inode == ival2->inode) {
#line 710
    if (ival1->major_num == ival2->major_num) {
#line 710
      if (ival1->minor_num == ival2->minor_num) {
#line 710
        tmp = 1;
      } else {
#line 710
        tmp = 0;
      }
    } else {
#line 710
      tmp = 0;
    }
  } else {
#line 710
    tmp = 0;
  }
#line 710
  return ((_Bool )tmp);
}
}
#line 715 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
char *find_inode_file(ino_t node_num , unsigned long major_num , unsigned long minor_num ) 
{ 
  struct inode_val sample ;
  struct inode_val *ival ;
  void *tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;

  {
#line 722
  if (! hash_table) {
#line 723
    return ((char *)((void *)0));
  }
  {
#line 725
  sample.inode = node_num;
#line 726
  sample.major_num = major_num;
#line 727
  sample.minor_num = minor_num;
#line 728
  tmp = hash_lookup((Hash_table const   *)hash_table, (void const   *)(& sample));
#line 728
  ival = (struct inode_val *)tmp;
  }
#line 729
  if (ival) {
#line 729
    tmp___0 = ival->file_name;
  } else {
#line 729
    tmp___0 = (char *)((void *)0);
  }
#line 729
  return (tmp___0);
}
}
#line 734 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void add_inode(ino_t node_num , char *file_name___0 , unsigned long major_num , unsigned long minor_num ) 
{ 
  struct inode_val *temp ;
  struct inode_val *e ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 742
  tmp = xmalloc(sizeof(struct inode_val ));
#line 742
  temp = (struct inode_val *)tmp;
#line 743
  temp->inode = node_num;
#line 744
  temp->major_num = major_num;
#line 745
  temp->minor_num = minor_num;
#line 746
  temp->file_name = xstrdup((char const   *)file_name___0);
  }
#line 748
  if (hash_table) {
#line 748
    goto _L;
  } else {
    {
#line 748
    hash_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & inode_val_hasher,
                                 & inode_val_compare, (void (*)(void * ))0);
    }
#line 748
    if (hash_table) {
      _L: /* CIL Label */ 
      {
#line 748
      tmp___0 = hash_insert(hash_table, (void const   *)temp);
#line 748
      e = (struct inode_val *)tmp___0;
      }
#line 748
      if (! e) {
        {
#line 752
        xalloc_die();
        }
      }
    } else {
      {
#line 752
      xalloc_die();
      }
    }
  }
#line 754
  return;
}
}
#line 761 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int open_archive(char *file ) 
{ 
  int fd ;
  void (*copy_in)() ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;

  {
#line 767
  copy_in = & process_copy_in;
#line 769
  if ((unsigned long )copy_function == (unsigned long )copy_in) {
#line 770
    if (! force_local_option) {
      {
#line 770
      rmt_dev_name__ = strchr((char const   *)file, ':');
      }
#line 770
      if (rmt_dev_name__) {
#line 770
        if ((unsigned long )rmt_dev_name__ > (unsigned long )file) {
          {
#line 770
          tmp___2 = memchr((void const   *)file, '/', (size_t )(rmt_dev_name__ - file));
          }
#line 770
          if (tmp___2) {
            {
#line 770
            tmp___1 = open((char const   *)file, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 770
            fd = tmp___1;
            }
          } else {
            {
#line 770
            tmp___0 = rmt_open__((char const   *)file, 0, 1 << 30, (char const   *)rsh_command_option);
#line 770
            fd = tmp___0;
            }
          }
        } else {
          {
#line 770
          tmp___1 = open((char const   *)file, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 770
          fd = tmp___1;
          }
        }
      } else {
        {
#line 770
        tmp___1 = open((char const   *)file, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 770
        fd = tmp___1;
        }
      }
    } else {
      {
#line 770
      tmp___1 = open((char const   *)file, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 770
      fd = tmp___1;
      }
    }
  } else
#line 773
  if (! append_flag) {
#line 774
    if (! force_local_option) {
      {
#line 774
      rmt_dev_name__ = strchr((char const   *)file, ':');
      }
#line 774
      if (rmt_dev_name__) {
#line 774
        if ((unsigned long )rmt_dev_name__ > (unsigned long )file) {
          {
#line 774
          tmp___6 = memchr((void const   *)file, '/', (size_t )(rmt_dev_name__ - file));
          }
#line 774
          if (tmp___6) {
            {
#line 774
            tmp___5 = open((char const   *)file, 577, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 774
            fd = tmp___5;
            }
          } else {
            {
#line 774
            tmp___4 = rmt_open__((char const   *)file, 577, 1 << 30, (char const   *)rsh_command_option);
#line 774
            fd = tmp___4;
            }
          }
        } else {
          {
#line 774
          tmp___5 = open((char const   *)file, 577, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 774
          fd = tmp___5;
          }
        }
      } else {
        {
#line 774
        tmp___5 = open((char const   *)file, 577, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 774
        fd = tmp___5;
        }
      }
    } else {
      {
#line 774
      tmp___5 = open((char const   *)file, 577, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 774
      fd = tmp___5;
      }
    }
  } else
#line 777
  if (! force_local_option) {
    {
#line 777
    rmt_dev_name__ = strchr((char const   *)file, ':');
    }
#line 777
    if (rmt_dev_name__) {
#line 777
      if ((unsigned long )rmt_dev_name__ > (unsigned long )file) {
        {
#line 777
        tmp___10 = memchr((void const   *)file, '/', (size_t )(rmt_dev_name__ - file));
        }
#line 777
        if (tmp___10) {
          {
#line 777
          tmp___9 = open((char const   *)file, 2, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 777
          fd = tmp___9;
          }
        } else {
          {
#line 777
          tmp___8 = rmt_open__((char const   *)file, 2, 1 << 30, (char const   *)rsh_command_option);
#line 777
          fd = tmp___8;
          }
        }
      } else {
        {
#line 777
        tmp___9 = open((char const   *)file, 2, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 777
        fd = tmp___9;
        }
      }
    } else {
      {
#line 777
      tmp___9 = open((char const   *)file, 2, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 777
      fd = tmp___9;
      }
    }
  } else {
    {
#line 777
    tmp___9 = open((char const   *)file, 2, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 777
    fd = tmp___9;
    }
  }
#line 780
  return (fd);
}
}
#line 786 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void tape_offline(int tape_des ) 
{ 
  struct mtop control ;
  void *__cil_tmp3 ;

  {
#line 792
  control.mt_op = (short)7;
#line 793
  control.mt_count = 1;
#line 794
  if (tape_des >= 1 << 30) {
    {
#line 794
    rmt_ioctl__(tape_des - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                (char *)(& control));
    }
  } else {
    {
#line 794
    ioctl(tape_des, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
          (char *)(& control));
    }
  }
#line 796
  return;
}
}
#line 810 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static int reel_number  =    1;
#line 807 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void get_next_reel(int tape_des ) 
{ 
  FILE *tty_in ;
  FILE *tty_out ;
  int old_tape_des ;
  char *next_archive_name ;
  dynamic_string new_name___0 ;
  char *str_res ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int c ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 818
  ds_init(& new_name___0, 128);
#line 821
  tty_in = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
  }
#line 822
  if ((unsigned long )tty_in == (unsigned long )((void *)0)) {
    {
#line 823
    tmp = __errno_location();
#line 823
    error(2, *tmp, "/dev/tty");
    }
  }
  {
#line 824
  tty_out = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w");
  }
#line 825
  if ((unsigned long )tty_out == (unsigned long )((void *)0)) {
    {
#line 826
    tmp___0 = __errno_location();
#line 826
    error(2, *tmp___0, "/dev/tty");
    }
  }
  {
#line 828
  old_tape_des = tape_des;
#line 829
  tape_offline(tape_des);
  }
#line 830
  if (tape_des >= 1 << 30) {
    {
#line 830
    rmt_close__(tape_des - (1 << 30));
    }
  } else {
    {
#line 830
    close(tape_des);
    }
  }
#line 834
  reel_number ++;
#line 835
  if (new_media_message) {
    {
#line 836
    fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)"%s",
            new_media_message);
    }
  } else
#line 837
  if (new_media_message_with_number) {
    {
#line 838
    fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)"%s%d%s",
            new_media_message_with_number, reel_number, new_media_message_after_number);
    }
  } else
#line 840
  if (archive_name) {
    {
#line 841
    tmp___1 = gettext("Found end of tape.  Load next tape and press RETURN. ");
#line 841
    fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)tmp___1);
    }
  } else {
    {
#line 843
    tmp___2 = gettext("Found end of tape.  To continue, type device/file name when ready.\n");
#line 843
    fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)tmp___2);
    }
  }
  {
#line 845
  fflush_unlocked(tty_out);
  }
#line 847
  if (archive_name) {
    {
#line 851
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 852
      c = (int )getc_unlocked(tty_in);
      }
#line 851
      if (c != -1) {
#line 851
        if (! (c != 10)) {
#line 851
          goto while_break;
        }
      } else {
#line 851
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 855
    tape_des = open_archive(archive_name);
    }
#line 856
    if (tape_des == -1) {
      {
#line 857
      open_error((char const   *)archive_name);
      }
    }
  } else {
    {
#line 861
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 863
      if (tape_des < 0) {
        {
#line 865
        tmp___3 = gettext("To continue, type device/file name when ready.\n");
#line 865
        fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)tmp___3);
#line 867
        fflush_unlocked(tty_out);
        }
      }
      {
#line 870
      str_res = ds_fgets(tty_in, & new_name___0);
      }
#line 871
      if ((unsigned long )str_res == (unsigned long )((void *)0)) {
        {
#line 872
        exit(1);
        }
      } else
#line 871
      if ((int )*(str_res + 0) == 0) {
        {
#line 872
        exit(1);
        }
      }
      {
#line 873
      next_archive_name = str_res;
#line 875
      tape_des = open_archive(next_archive_name);
      }
#line 876
      if (tape_des == -1) {
        {
#line 877
        open_error((char const   *)next_archive_name);
        }
      }
#line 861
      if (! (tape_des < 0)) {
#line 861
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 890
  if (tape_des != old_tape_des) {
    {
#line 891
    tmp___4 = gettext("internal error: tape descriptor changed from %d to %d");
#line 891
    error(1, 0, (char const   *)tmp___4, old_tape_des, tape_des);
    }
  }
  {
#line 894
  free((void *)new_name___0.ds_string);
#line 895
  fclose(tty_in);
#line 896
  fclose(tty_out);
  }
#line 897
  return;
}
}
#line 905 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void set_new_media_message(char *message ) 
{ 
  char *p ;
  int prev_was_percent ;
  int length ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 911
  p = message;
#line 912
  prev_was_percent = 0;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! ((int )*p != 0)) {
#line 913
      goto while_break;
    }
#line 915
    if ((int )*p == 100) {
#line 915
      if (prev_was_percent) {
#line 916
        goto while_break;
      }
    }
#line 917
    prev_was_percent = (int )*p == 37;
#line 918
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  if ((int )*p == 0) {
    {
#line 922
    new_media_message = xstrdup((char const   *)message);
    }
  } else {
    {
#line 926
    length = (int )((p - message) - 1L);
#line 928
    tmp = xmalloc((size_t )(length + 1));
#line 928
    new_media_message_with_number = (char *)tmp;
#line 929
    strncpy((char */* __restrict  */)new_media_message_with_number, (char const   */* __restrict  */)message,
            (size_t )length);
#line 930
    *(new_media_message_with_number + length) = (char )'\000';
#line 931
    tmp___0 = strlen((char const   *)(p + 1));
#line 931
    length = (int )tmp___0;
#line 932
    tmp___1 = xmalloc((size_t )(length + 1));
#line 932
    new_media_message_after_number = (char *)tmp___1;
#line 933
    strcpy((char */* __restrict  */)new_media_message_after_number, (char const   */* __restrict  */)(p + 1));
    }
  }
#line 935
  return;
}
}
#line 1102 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static int buf_all_zeros(char *buf , int bufsize ) 
{ 
  int i ;
  char *tmp ;

  {
#line 1106
  i = 0;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    if (! (i < bufsize)) {
#line 1106
      goto while_break;
    }
#line 1108
    tmp = buf;
#line 1108
    buf ++;
#line 1108
    if ((int )*tmp != 0) {
#line 1109
      return (0);
    }
#line 1106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  return (1);
}
}
#line 1114 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int delayed_seek_count  =    0;
#line 1119 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static int sparse_write(int fildes , char *buf , unsigned int nbyte ) 
{ 
  int complete_block_count ;
  int leftover_bytes_count ;
  int seek_count ;
  int write_count ;
  char *cur_write_start ;
  int lseek_rc ;
  int write_rc ;
  int i ;
  enum __anonenum_state_57 state ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 1132
  complete_block_count = (int )(nbyte / 512U);
#line 1133
  leftover_bytes_count = (int )(nbyte % 512U);
#line 1135
  if (delayed_seek_count != 0) {
#line 1136
    state = (enum __anonenum_state_57 )1;
  } else {
#line 1138
    state = (enum __anonenum_state_57 )0;
  }
#line 1140
  seek_count = delayed_seek_count;
#line 1142
  i = 0;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! (i < complete_block_count)) {
#line 1142
      goto while_break;
    }
    {
#line 1146
    if ((unsigned int )state == 0U) {
#line 1146
      goto case_0;
    }
#line 1161
    if ((unsigned int )state == 1U) {
#line 1161
      goto case_1;
    }
#line 1176
    if ((unsigned int )state == 2U) {
#line 1176
      goto case_2;
    }
#line 1144
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1147
    tmp = buf_all_zeros(buf, 512);
    }
#line 1147
    if (tmp) {
#line 1149
      seek_count = 512;
#line 1150
      state = (enum __anonenum_state_57 )1;
    } else {
#line 1154
      cur_write_start = buf;
#line 1155
      write_count = 512;
#line 1156
      state = (enum __anonenum_state_57 )2;
    }
#line 1158
    buf += 512;
#line 1159
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1162
    tmp___0 = buf_all_zeros(buf, 512);
    }
#line 1162
    if (tmp___0) {
#line 1164
      seek_count += 512;
    } else {
      {
#line 1168
      lseek(fildes, (__off_t )seek_count, 1);
#line 1169
      cur_write_start = buf;
#line 1170
      write_count = 512;
#line 1171
      state = (enum __anonenum_state_57 )2;
      }
    }
#line 1173
    buf += 512;
#line 1174
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1177
    tmp___2 = buf_all_zeros(buf, 512);
    }
#line 1177
    if (tmp___2) {
      {
#line 1179
      tmp___1 = write(fildes, (void const   *)cur_write_start, (size_t )write_count);
#line 1179
      write_rc = (int )tmp___1;
#line 1180
      seek_count = 512;
#line 1181
      state = (enum __anonenum_state_57 )1;
      }
    } else {
#line 1185
      write_count += 512;
    }
#line 1187
    buf += 512;
#line 1188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1195
  if ((unsigned int )state == 1U) {
#line 1195
    goto case_1___0;
  }
#line 1195
  if ((unsigned int )state == 0U) {
#line 1195
    goto case_1___0;
  }
#line 1199
  if ((unsigned int )state == 2U) {
#line 1199
    goto case_2___0;
  }
#line 1192
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 1196
  delayed_seek_count = seek_count;
#line 1197
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 1200
  tmp___3 = write(fildes, (void const   *)cur_write_start, (size_t )write_count);
#line 1200
  write_rc = (int )tmp___3;
#line 1201
  delayed_seek_count = 0;
  }
#line 1202
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1205
  if (leftover_bytes_count != 0) {
#line 1207
    if (delayed_seek_count != 0) {
      {
#line 1209
      tmp___4 = lseek(fildes, (__off_t )delayed_seek_count, 1);
#line 1209
      lseek_rc = (int )tmp___4;
#line 1210
      delayed_seek_count = 0;
      }
    }
    {
#line 1212
    tmp___5 = write(fildes, (void const   *)buf, (size_t )leftover_bytes_count);
#line 1212
    write_rc = (int )tmp___5;
    }
  }
#line 1214
  return ((int )nbyte);
}
}
#line 1220 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void stat_to_cpio(struct cpio_file_stat *hdr , struct stat *st ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 1223
  tmp = (unsigned int )gnu_dev_major((unsigned long long )st->st_dev);
#line 1223
  hdr->c_dev_maj = (long )tmp;
#line 1224
  tmp___0 = (unsigned int )gnu_dev_minor((unsigned long long )st->st_dev);
#line 1224
  hdr->c_dev_min = (long )tmp___0;
#line 1225
  hdr->c_ino = st->st_ino;
#line 1230
  hdr->c_mode = st->st_mode & 4095U;
  }
#line 1231
  if ((st->st_mode & 61440U) == 32768U) {
#line 1232
    hdr->c_mode |= 32768U;
  } else
#line 1233
  if ((st->st_mode & 61440U) == 16384U) {
#line 1234
    hdr->c_mode |= 16384U;
  } else
#line 1236
  if ((st->st_mode & 61440U) == 24576U) {
#line 1237
    hdr->c_mode |= 24576U;
  } else
#line 1240
  if ((st->st_mode & 61440U) == 8192U) {
#line 1241
    hdr->c_mode |= 8192U;
  } else
#line 1244
  if ((st->st_mode & 61440U) == 4096U) {
#line 1245
    hdr->c_mode |= 4096U;
  } else
#line 1248
  if ((st->st_mode & 61440U) == 40960U) {
#line 1249
    hdr->c_mode |= 40960U;
  } else
#line 1252
  if ((st->st_mode & 61440U) == 49152U) {
#line 1253
    hdr->c_mode |= 49152U;
  }
#line 1259
  hdr->c_nlink = st->st_nlink;
#line 1260
  if (set_owner_flag) {
#line 1260
    hdr->c_uid = set_owner;
  } else {
#line 1260
    hdr->c_uid = st->st_uid;
  }
#line 1261
  if (set_group_flag) {
#line 1261
    hdr->c_gid = set_group;
  } else {
#line 1261
    hdr->c_gid = st->st_gid;
  }
  {
#line 1262
  tmp___1 = (unsigned int )gnu_dev_major((unsigned long long )st->st_rdev);
#line 1262
  hdr->c_rdev_maj = (long )tmp___1;
#line 1263
  tmp___2 = (unsigned int )gnu_dev_minor((unsigned long long )st->st_rdev);
#line 1263
  hdr->c_rdev_min = (long )tmp___2;
#line 1264
  hdr->c_mtime = st->st_mtim.tv_sec;
#line 1265
  hdr->c_filesize = st->st_size;
#line 1266
  hdr->c_chksum = 0UL;
#line 1267
  hdr->c_tar_linkname = (char *)((void *)0);
  }
#line 1268
  return;
}
}
#line 1270 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void cpio_to_stat(struct stat *st , struct cpio_file_stat *hdr ) 
{ 
  unsigned long long tmp ;
  unsigned long long tmp___0 ;

  {
  {
#line 1273
  memset((void *)st, 0, sizeof(*st));
#line 1274
  tmp = (unsigned long long )gnu_dev_makedev((unsigned int )hdr->c_dev_maj, (unsigned int )hdr->c_dev_min);
#line 1274
  st->st_dev = (__dev_t )tmp;
#line 1275
  st->st_ino = hdr->c_ino;
#line 1276
  st->st_mode = hdr->c_mode & 511U;
  }
#line 1277
  if (hdr->c_mode & 32768U) {
#line 1278
    st->st_mode |= 32768U;
  } else
#line 1279
  if (hdr->c_mode & 16384U) {
#line 1280
    st->st_mode |= 16384U;
  } else
#line 1282
  if (hdr->c_mode & 24576U) {
#line 1283
    st->st_mode |= 24576U;
  } else
#line 1286
  if (hdr->c_mode & 8192U) {
#line 1287
    st->st_mode |= 8192U;
  } else
#line 1294
  if (hdr->c_mode & 40960U) {
#line 1295
    st->st_mode |= 40960U;
  } else
#line 1298
  if (hdr->c_mode & 49152U) {
#line 1299
    st->st_mode |= 49152U;
  }
#line 1305
  st->st_nlink = hdr->c_nlink;
#line 1306
  if (set_owner_flag) {
#line 1306
    st->st_uid = set_owner;
  } else {
#line 1306
    st->st_uid = hdr->c_uid;
  }
#line 1307
  if (set_group_flag) {
#line 1307
    st->st_gid = set_group;
  } else {
#line 1307
    st->st_gid = hdr->c_gid;
  }
  {
#line 1308
  tmp___0 = (unsigned long long )gnu_dev_makedev((unsigned int )hdr->c_rdev_maj, (unsigned int )hdr->c_rdev_min);
#line 1308
  st->st_rdev = (__dev_t )tmp___0;
#line 1309
  st->st_mtim.tv_sec = hdr->c_mtime;
#line 1310
  st->st_size = hdr->c_filesize;
  }
#line 1311
  return;
}
}
#line 1320 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int fchown_or_chown(int fd , char const   *name , uid_t uid , uid_t gid ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1323
  if (fd != -1) {
    {
#line 1324
    tmp = fchown(fd, uid, gid);
    }
#line 1324
    return (tmp);
  } else {
    {
#line 1326
    tmp___0 = chown(name, uid, gid);
    }
#line 1326
    return (tmp___0);
  }
}
}
#line 1329 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int fchmod_or_chmod(int fd , char const   *name , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1332
  if (fd != -1) {
    {
#line 1333
    tmp = fchmod(fd, mode);
    }
#line 1333
    return (tmp);
  } else {
    {
#line 1335
    tmp___0 = chmod(name, mode);
    }
#line 1335
    return (tmp___0);
  }
}
}
#line 1338 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void set_perms(int fd , struct cpio_file_stat *header ) 
{ 
  uid_t uid ;
  uid_t tmp ;
  gid_t gid ;
  gid_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1341
  if (! no_chown_flag) {
#line 1343
    if (set_owner_flag) {
#line 1343
      tmp = set_owner;
    } else {
#line 1343
      tmp = header->c_uid;
    }
#line 1343
    uid = tmp;
#line 1344
    if (set_group_flag) {
#line 1344
      tmp___0 = set_group;
    } else {
#line 1344
      tmp___0 = header->c_gid;
    }
    {
#line 1344
    gid = tmp___0;
#line 1345
    tmp___1 = fchown_or_chown(fd, (char const   *)header->c_name, uid, gid);
    }
#line 1345
    if (tmp___1 < 0) {
      {
#line 1345
      tmp___2 = __errno_location();
      }
#line 1345
      if (*tmp___2 != 1) {
        {
#line 1347
        chown_error_details((char const   *)header->c_name, uid, gid);
        }
      }
    }
  }
  {
#line 1350
  tmp___3 = fchmod_or_chmod(fd, (char const   *)header->c_name, header->c_mode);
  }
#line 1350
  if (tmp___3 < 0) {
    {
#line 1351
    chmod_error_details((char const   *)header->c_name, header->c_mode);
    }
  }
#line 1358
  if (retain_time_flag) {
    {
#line 1359
    set_file_times(fd, (char const   *)header->c_name, (unsigned long )header->c_mtime,
                   (unsigned long )header->c_mtime);
    }
  }
#line 1360
  return;
}
}
#line 1362 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void set_file_times(int fd , char const   *name , unsigned long atime , unsigned long mtime ) 
{ 
  struct timespec ts[2] ;
  int tmp ;
  int *tmp___0 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 1368
  memset((void *)(& ts), 0, sizeof(ts));
#line 1370
  ts[0].tv_sec = (__time_t )atime;
#line 1371
  ts[1].tv_sec = (__time_t )mtime;
#line 1375
  tmp = gl_futimens(fd, name, (struct timespec  const  *)(ts));
  }
#line 1375
  if (tmp < 0) {
    {
#line 1375
    tmp___0 = __errno_location();
    }
#line 1375
    if (*tmp___0 != 30) {
      {
#line 1376
      utime_error(name);
      }
    }
  }
#line 1377
  return;
}
}
#line 1381 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void cpio_safer_name_suffix(char *name , _Bool link_target , _Bool absolute_names ,
                            _Bool strip_leading_dots ) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 1385
  tmp = safer_name_suffix((char const   *)name, link_target, absolute_names);
#line 1385
  p = tmp;
  }
#line 1386
  if (strip_leading_dots) {
    {
#line 1386
    tmp___0 = strcmp((char const   *)p, "./");
    }
#line 1386
    if (tmp___0) {
      {
#line 1388
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1388
        if ((int )*p == 46) {
#line 1388
          if (! ((int )*(p + 1) == 47)) {
#line 1388
            goto while_break;
          }
        } else {
#line 1388
          goto while_break;
        }
#line 1390
        p ++;
        {
#line 1391
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1391
          if (! ((int )*p == 47)) {
#line 1391
            goto while_break___0;
          }
#line 1392
          p ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1394
  if ((unsigned long )p != (unsigned long )name) {
    {
#line 1395
    tmp___1 = strlen((char const   *)p);
#line 1395
    memmove((void *)name, (void const   *)p, tmp___1 + 1UL);
    }
  }
#line 1396
  return;
}
}
#line 1418 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static struct delayed_set_stat *delayed_set_stat_head  ;
#line 1420 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void delay_cpio_set_stat(struct cpio_file_stat *file_stat , mode_t invert_permissions ) 
{ 
  size_t file_name_len ;
  size_t tmp ;
  struct delayed_set_stat *data ;
  void *tmp___0 ;

  {
  {
#line 1424
  tmp = strlen((char const   *)file_stat->c_name);
#line 1424
  file_name_len = tmp;
#line 1425
  tmp___0 = xmalloc((sizeof(struct delayed_set_stat ) + file_name_len) + 1UL);
#line 1425
  data = (struct delayed_set_stat *)tmp___0;
#line 1427
  data->next = delayed_set_stat_head;
#line 1428
  memcpy((void */* __restrict  */)(& data->stat), (void const   */* __restrict  */)file_stat,
         sizeof(data->stat));
#line 1429
  data->stat.c_name = (char *)(data + 1);
#line 1430
  strcpy((char */* __restrict  */)data->stat.c_name, (char const   */* __restrict  */)file_stat->c_name);
#line 1431
  data->invert_permissions = invert_permissions;
#line 1432
  delayed_set_stat_head = data;
  }
#line 1433
  return;
}
}
#line 1435 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void delay_set_stat(char const   *file_name___0 , struct stat *st , mode_t invert_permissions ) 
{ 
  struct cpio_file_stat fs ;
  void *__cil_tmp5 ;

  {
  {
#line 1441
  stat_to_cpio(& fs, st);
#line 1442
  fs.c_name = (char *)file_name___0;
#line 1443
  delay_cpio_set_stat(& fs, invert_permissions);
  }
#line 1444
  return;
}
}
#line 1450 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int repair_inter_delayed_set_stat(struct stat *dir_stat_info ) 
{ 
  struct delayed_set_stat *data ;
  struct stat st ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 1454
  data = delayed_set_stat_head;
  {
#line 1454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1454
    if (! data) {
#line 1454
      goto while_break;
    }
    {
#line 1457
    tmp = stat((char const   */* __restrict  */)data->stat.c_name, (struct stat */* __restrict  */)(& st));
    }
#line 1457
    if (tmp != 0) {
      {
#line 1459
      stat_error((char const   *)data->stat.c_name);
      }
#line 1460
      return (-1);
    }
#line 1463
    if (st.st_dev == dir_stat_info->st_dev) {
#line 1463
      if (st.st_ino == dir_stat_info->st_ino) {
        {
#line 1466
        stat_to_cpio(& data->stat, dir_stat_info);
#line 1467
        data->invert_permissions = ((dir_stat_info->st_mode ^ st.st_mode) & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & ~ newdir_umask;
        }
#line 1470
        return (0);
      }
    }
#line 1454
    data = data->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  return (1);
}
}
#line 1480 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int repair_delayed_set_stat(struct cpio_file_stat *file_hdr ) 
{ 
  struct delayed_set_stat *data ;
  int tmp ;

  {
#line 1484
  data = delayed_set_stat_head;
  {
#line 1484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1484
    if (! data) {
#line 1484
      goto while_break;
    }
    {
#line 1486
    tmp = strcmp((char const   *)file_hdr->c_name, (char const   *)data->stat.c_name);
    }
#line 1486
    if (tmp == 0) {
      {
#line 1488
      data->invert_permissions = (mode_t )0;
#line 1489
      memcpy((void */* __restrict  */)(& data->stat), (void const   */* __restrict  */)file_hdr,
             (unsigned long )(& ((struct cpio_file_stat *)0)->c_name));
      }
#line 1491
      return (0);
    }
#line 1484
    data = data->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  return (1);
}
}
#line 1497 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
void apply_delayed_set_stat(void) 
{ 
  struct delayed_set_stat *data ;

  {
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1500
    if (! delayed_set_stat_head) {
#line 1500
      goto while_break;
    }
#line 1502
    data = delayed_set_stat_head;
#line 1503
    if (data->invert_permissions) {
#line 1505
      data->stat.c_mode ^= data->invert_permissions;
    }
    {
#line 1507
    set_perms(-1, & data->stat);
#line 1508
    delayed_set_stat_head = data->next;
#line 1509
    free((void *)data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1511
  return;
}
}
#line 1514 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
static int cpio_mkdir(struct cpio_file_stat *file_hdr , int *setstat_delayed ) 
{ 
  int rc ;
  mode_t mode ;

  {
#line 1518
  mode = file_hdr->c_mode;
#line 1520
  if (! (file_hdr->c_mode & 128U)) {
    {
#line 1522
    rc = mkdir((char const   *)file_hdr->c_name, mode | 128U);
    }
#line 1523
    if (rc == 0) {
      {
#line 1525
      delay_cpio_set_stat(file_hdr, (mode_t )0);
#line 1526
      *setstat_delayed = 1;
      }
    }
  } else {
    {
#line 1531
    rc = mkdir((char const   *)file_hdr->c_name, mode);
#line 1532
    *setstat_delayed = 0;
    }
  }
#line 1534
  return (rc);
}
}
#line 1537 "/home/wslee/gnu_benchmarks/cpio-2.11/src/util.c"
int cpio_create_dir(struct cpio_file_stat *file_hdr , int existing_dir ) 
{ 
  int res ;
  int setstat_delayed ;
  struct stat file_stat ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1545
  setstat_delayed = 0;
#line 1547
  if (to_stdout_option) {
#line 1548
    return (0);
  }
  {
#line 1553
  strip_trailing_slashes(file_hdr->c_name);
  }
#line 1558
  if ((int )*(file_hdr->c_name + 0) == 46) {
#line 1558
    if ((int )*(file_hdr->c_name + 1) == 0) {
#line 1560
      return (0);
    }
  }
#line 1566
  if (! existing_dir) {
    {
#line 1581
    res = cpio_mkdir(file_hdr, & setstat_delayed);
    }
  } else {
#line 1584
    res = 0;
  }
#line 1585
  if (res < 0) {
#line 1585
    if (create_dir_flag) {
      {
#line 1587
      create_all_directories(file_hdr->c_name);
#line 1588
      res = cpio_mkdir(file_hdr, & setstat_delayed);
      }
    }
  }
#line 1590
  if (res < 0) {
    {
#line 1598
    tmp = __errno_location();
    }
#line 1598
    if (*tmp != 17) {
      {
#line 1600
      mkdir_error((char const   *)file_hdr->c_name);
      }
#line 1601
      return (-1);
    }
    {
#line 1603
    tmp___0 = lstat((char const   */* __restrict  */)file_hdr->c_name, (struct stat */* __restrict  */)(& file_stat));
    }
#line 1603
    if (tmp___0) {
      {
#line 1605
      stat_error((char const   *)file_hdr->c_name);
      }
#line 1606
      return (-1);
    }
#line 1608
    if (! ((file_stat.st_mode & 61440U) == 16384U)) {
      {
#line 1610
      tmp___1 = quotearg_colon((char const   *)file_hdr->c_name);
#line 1610
      tmp___2 = gettext("%s is not a directory");
#line 1610
      error(0, 0, (char const   *)tmp___2, tmp___1);
      }
#line 1612
      return (-1);
    }
  }
#line 1616
  if (! setstat_delayed) {
    {
#line 1616
    tmp___3 = repair_delayed_set_stat(file_hdr);
    }
#line 1616
    if (tmp___3) {
      {
#line 1617
      set_perms(-1, file_hdr);
      }
    }
  }
#line 1618
  return (0);
}
}
#line 30 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
enum archive_format archive_format ;
#line 70
int numeric_uid ;
#line 103
void warn_junk_bytes(long bytes_skipped ) ;
#line 146
void write_out_tar_header(struct cpio_file_stat *file_hdr , int out_des ) ;
#line 147
int null_block(long *block , int size ) ;
#line 148
void read_in_tar_header(struct cpio_file_stat *file_hdr , int in_des ) ;
#line 150
int is_tar_header(char *buf ) ;
#line 151
int is_tar_filename_too_long(char *name ) ;
#line 208
uintmax_t from_ascii(char const   *where , size_t digs , unsigned int logbase ) ;
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static char hold_tar_linkname[101]  ;
#line 34 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static char *stash_tar_linkname(char *linkname ) 
{ 


  {
  {
#line 39
  strncpy((char */* __restrict  */)(hold_tar_linkname), (char const   */* __restrict  */)linkname,
          (size_t )100);
#line 40
  hold_tar_linkname[100] = (char )'\000';
  }
#line 41
  return (hold_tar_linkname);
}
}
#line 47 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static size_t split_long_name(char const   *name , size_t length ) 
{ 
  size_t i ;

  {
#line 52
  if (length > 155UL) {
#line 53
    length = (size_t )157;
  }
#line 54
  i = length - 1UL;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i > 0UL)) {
#line 54
      goto while_break;
    }
#line 55
    if ((int const   )*(name + i) == 47) {
#line 56
      goto while_break;
    }
#line 54
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (i);
}
}
#line 65 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static char hold_tar_filename[257]  ;
#line 62 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static char *stash_tar_filename(char *prefix , char *filename ) 
{ 
  char *__cil_tmp3 ;

  {
#line 66
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
    {
#line 68
    strncpy((char */* __restrict  */)(hold_tar_filename), (char const   */* __restrict  */)filename,
            (size_t )100);
#line 69
    hold_tar_filename[100] = (char )'\000';
    }
  } else
#line 66
  if ((int )*prefix == 0) {
    {
#line 68
    strncpy((char */* __restrict  */)(hold_tar_filename), (char const   */* __restrict  */)filename,
            (size_t )100);
#line 69
    hold_tar_filename[100] = (char )'\000';
    }
  } else {
    {
#line 73
    strncpy((char */* __restrict  */)(hold_tar_filename), (char const   */* __restrict  */)prefix,
            (size_t )155);
#line 74
    hold_tar_filename[155] = (char )'\000';
#line 75
    strcat((char */* __restrict  */)(hold_tar_filename), (char const   */* __restrict  */)"/");
#line 76
    strncat((char */* __restrict  */)(hold_tar_filename), (char const   */* __restrict  */)filename,
            (size_t )100);
#line 77
    hold_tar_filename[255] = (char )'\000';
    }
  }
#line 79
  return (hold_tar_filename);
}
}
#line 94 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
static void to_oct(long value , int digits , char *where ) 
{ 


  {
#line 97
  digits --;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    digits --;
#line 102
    *(where + digits) = (char )(48 + (int )((char )(value & 7L)));
#line 103
    value >>= 3;
#line 100
    if (digits > 0) {
#line 100
      if (! (value != 0L)) {
#line 100
        goto while_break;
      }
    } else {
#line 100
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (digits > 0)) {
#line 108
      goto while_break___0;
    }
#line 109
    digits --;
#line 109
    *(where + digits) = (char )'0';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 117 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
unsigned int tar_checksum(struct tar_header *tar_hdr ) 
{ 
  unsigned int sum ;
  char *p ;
  char *q ;
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 120
  sum = 0U;
#line 121
  p = (char *)tar_hdr;
#line 122
  q = p + 512;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )p < (unsigned long )(tar_hdr->chksum))) {
#line 125
      goto while_break;
    }
#line 126
    tmp = p;
#line 126
    p ++;
#line 126
    sum += (unsigned int )((int )*tmp & 255);
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (! (i < 8)) {
#line 127
      goto while_break___0;
    }
#line 129
    sum += 32U;
#line 130
    p ++;
#line 127
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 132
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 132
      goto while_break___1;
    }
#line 133
    tmp___0 = p;
#line 133
    p ++;
#line 133
    sum += (unsigned int )((int )*tmp___0 & 255);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 134
  return (sum);
}
}
#line 140 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
void write_out_tar_header(struct cpio_file_stat *file_hdr , int out_des ) 
{ 
  int name_len ;
  union tar_record tar_rec ;
  struct tar_header *tar_hdr ;
  size_t tmp ;
  int prefix_len ;
  size_t tmp___0 ;
  char *name ;
  unsigned int tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 145
  tar_hdr = (struct tar_header *)(& tar_rec);
#line 147
  memset((void *)(& tar_rec), 0, sizeof(tar_rec));
#line 152
  tmp = strlen((char const   *)file_hdr->c_name);
#line 152
  name_len = (int )tmp;
  }
#line 153
  if (name_len <= 100) {
    {
#line 155
    strncpy((char */* __restrict  */)(tar_hdr->name), (char const   */* __restrict  */)file_hdr->c_name,
            (size_t )name_len);
    }
  } else {
    {
#line 160
    tmp___0 = split_long_name((char const   *)file_hdr->c_name, (size_t )name_len);
#line 160
    prefix_len = (int )tmp___0;
#line 162
    strncpy((char */* __restrict  */)(tar_hdr->prefix), (char const   */* __restrict  */)file_hdr->c_name,
            (size_t )prefix_len);
#line 163
    strncpy((char */* __restrict  */)(tar_hdr->name), (char const   */* __restrict  */)((file_hdr->c_name + prefix_len) + 1),
            (size_t )((name_len - prefix_len) - 1));
    }
  }
  {
#line 169
  to_oct((long )(file_hdr->c_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))),
         8, tar_hdr->mode);
#line 170
  to_oct((long )file_hdr->c_uid, 8, tar_hdr->uid);
#line 171
  to_oct((long )file_hdr->c_gid, 8, tar_hdr->gid);
#line 172
  to_oct(file_hdr->c_filesize, 12, tar_hdr->size);
#line 173
  to_oct(file_hdr->c_mtime, 12, tar_hdr->mtime);
  }
  {
#line 177
  if ((file_hdr->c_mode & 61440U) == 32768U) {
#line 177
    goto case_32768;
  }
#line 190
  if ((file_hdr->c_mode & 61440U) == 16384U) {
#line 190
    goto case_16384;
  }
#line 193
  if ((file_hdr->c_mode & 61440U) == 8192U) {
#line 193
    goto case_8192;
  }
#line 196
  if ((file_hdr->c_mode & 61440U) == 24576U) {
#line 196
    goto case_24576;
  }
#line 200
  if ((file_hdr->c_mode & 61440U) == 4096U) {
#line 200
    goto case_4096;
  }
#line 205
  if ((file_hdr->c_mode & 61440U) == 40960U) {
#line 205
    goto case_40960;
  }
#line 175
  goto switch_break;
  case_32768: /* CIL Label */ 
#line 178
  if (file_hdr->c_tar_linkname) {
    {
#line 182
    strncpy((char */* __restrict  */)(tar_hdr->linkname), (char const   */* __restrict  */)file_hdr->c_tar_linkname,
            (size_t )100);
#line 184
    tar_hdr->typeflag = (char )'1';
#line 185
    to_oct(0L, 12, tar_hdr->size);
    }
  } else {
#line 188
    tar_hdr->typeflag = (char )'0';
  }
#line 189
  goto switch_break;
  case_16384: /* CIL Label */ 
#line 191
  tar_hdr->typeflag = (char )'5';
#line 192
  goto switch_break;
  case_8192: /* CIL Label */ 
#line 194
  tar_hdr->typeflag = (char )'3';
#line 195
  goto switch_break;
  case_24576: /* CIL Label */ 
#line 197
  tar_hdr->typeflag = (char )'4';
#line 198
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 201
  tar_hdr->typeflag = (char )'6';
#line 202
  goto switch_break;
  case_40960: /* CIL Label */ 
  {
#line 206
  tar_hdr->typeflag = (char )'2';
#line 209
  strncpy((char */* __restrict  */)(tar_hdr->linkname), (char const   */* __restrict  */)file_hdr->c_tar_linkname,
          (size_t )100);
#line 211
  to_oct(0L, 12, tar_hdr->size);
  }
#line 212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 216
  if ((unsigned int )archive_format == 6U) {
    {
#line 220
    strncpy((char */* __restrict  */)(tar_hdr->magic), (char const   */* __restrict  */)"ustar",
            (size_t )6);
#line 221
    strncpy((char */* __restrict  */)(tar_hdr->version), (char const   */* __restrict  */)"00",
            (size_t )2);
#line 223
    name = getuser(file_hdr->c_uid);
    }
#line 224
    if (name) {
      {
#line 225
      strcpy((char */* __restrict  */)(tar_hdr->uname), (char const   */* __restrict  */)name);
      }
    }
    {
#line 226
    name = getgroup(file_hdr->c_gid);
    }
#line 227
    if (name) {
      {
#line 228
      strcpy((char */* __restrict  */)(tar_hdr->gname), (char const   */* __restrict  */)name);
      }
    }
    {
#line 230
    to_oct(file_hdr->c_rdev_maj, 8, tar_hdr->devmajor);
#line 231
    to_oct(file_hdr->c_rdev_min, 8, tar_hdr->devminor);
    }
  }
  {
#line 234
  tmp___1 = tar_checksum(tar_hdr);
#line 234
  to_oct((long )tmp___1, 8, tar_hdr->chksum);
#line 236
  tape_buffered_write((char *)(& tar_rec), out_des, (off_t )512);
  }
#line 237
  return;
}
}
#line 243 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
int null_block(long *block , int size ) 
{ 
  register long *p ;
  register int i ;
  long *tmp ;
  int tmp___0 ;

  {
#line 246
  p = block;
#line 247
  i = (int )((unsigned long )size / sizeof(long ));
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    tmp___0 = i;
#line 249
    i --;
#line 249
    if (! tmp___0) {
#line 249
      goto while_break;
    }
#line 250
    tmp = p;
#line 250
    p ++;
#line 250
    if (*tmp) {
#line 251
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (1);
}
}
#line 258 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
void read_in_tar_header(struct cpio_file_stat *file_hdr , int in_des ) 
{ 
  long bytes_skipped ;
  int warned___0 ;
  union tar_record tar_rec ;
  struct tar_header *tar_hdr ;
  uid_t *uidp ;
  gid_t *gidp ;
  int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;
  uintmax_t tmp___5 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  uintmax_t tmp___8 ;
  size_t tmp___9 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 261
  bytes_skipped = 0L;
#line 262
  warned___0 = 0;
#line 264
  tar_hdr = (struct tar_header *)(& tar_rec);
#line 268
  tape_buffered_read((char *)(& tar_rec), in_des, (off_t )512);
#line 271
  tmp = null_block((long *)(& tar_rec), 512);
  }
#line 271
  if (tmp) {
#line 285
    file_hdr->c_name = (char *)"TRAILER!!!";
#line 286
    return;
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    file_hdr->c_chksum = from_ascii((char const   *)(tar_hdr->chksum), sizeof(tar_hdr->chksum),
                                    3U);
#line 297
    tmp___1 = tar_checksum(tar_hdr);
    }
#line 297
    if (file_hdr->c_chksum != (unsigned long )tmp___1) {
#line 307
      if (! warned___0) {
        {
#line 309
        tmp___0 = gettext("invalid header: checksum error");
#line 309
        error(0, 0, (char const   *)tmp___0);
#line 310
        warned___0 = 1;
        }
      }
      {
#line 312
      memmove((void *)(& tar_rec), (void const   *)((char *)(& tar_rec) + 1), (size_t )511);
#line 313
      tape_buffered_read((char *)(& tar_rec) + 511, in_des, (off_t )1);
#line 314
      bytes_skipped ++;
      }
#line 315
      goto while_continue;
    }
#line 318
    if ((unsigned int )archive_format != 6U) {
      {
#line 319
      file_hdr->c_name = stash_tar_filename((char *)((void *)0), tar_hdr->name);
      }
    } else {
      {
#line 321
      file_hdr->c_name = stash_tar_filename(tar_hdr->prefix, tar_hdr->name);
      }
    }
    {
#line 322
    file_hdr->c_nlink = (size_t )1;
#line 323
    tmp___2 = from_ascii((char const   *)(tar_hdr->mode), sizeof(tar_hdr->mode), 3U);
#line 323
    file_hdr->c_mode = (mode_t )tmp___2;
#line 324
    file_hdr->c_mode &= 4095U;
    }
#line 328
    if ((unsigned int )archive_format == 6U) {
#line 328
      if (! numeric_uid) {
        {
#line 328
        uidp = getuidbyname(tar_hdr->uname);
        }
#line 328
        if (uidp) {
#line 330
          file_hdr->c_uid = *uidp;
        } else {
          {
#line 332
          tmp___3 = from_ascii((char const   *)(tar_hdr->uid), sizeof(tar_hdr->uid),
                               3U);
#line 332
          file_hdr->c_uid = (uid_t )tmp___3;
          }
        }
      } else {
        {
#line 332
        tmp___3 = from_ascii((char const   *)(tar_hdr->uid), sizeof(tar_hdr->uid),
                             3U);
#line 332
        file_hdr->c_uid = (uid_t )tmp___3;
        }
      }
    } else {
      {
#line 332
      tmp___3 = from_ascii((char const   *)(tar_hdr->uid), sizeof(tar_hdr->uid), 3U);
#line 332
      file_hdr->c_uid = (uid_t )tmp___3;
      }
    }
#line 334
    if ((unsigned int )archive_format == 6U) {
#line 334
      if (! numeric_uid) {
        {
#line 334
        gidp = getgidbyname(tar_hdr->gname);
        }
#line 334
        if (gidp) {
#line 336
          file_hdr->c_gid = *gidp;
        } else {
          {
#line 338
          tmp___4 = from_ascii((char const   *)(tar_hdr->gid), sizeof(tar_hdr->gid),
                               3U);
#line 338
          file_hdr->c_gid = (gid_t )tmp___4;
          }
        }
      } else {
        {
#line 338
        tmp___4 = from_ascii((char const   *)(tar_hdr->gid), sizeof(tar_hdr->gid),
                             3U);
#line 338
        file_hdr->c_gid = (gid_t )tmp___4;
        }
      }
    } else {
      {
#line 338
      tmp___4 = from_ascii((char const   *)(tar_hdr->gid), sizeof(tar_hdr->gid), 3U);
#line 338
      file_hdr->c_gid = (gid_t )tmp___4;
      }
    }
    {
#line 339
    tmp___5 = from_ascii((char const   *)(tar_hdr->size), sizeof(tar_hdr->size), 3U);
#line 339
    file_hdr->c_filesize = (off_t )tmp___5;
#line 340
    tmp___6 = from_ascii((char const   *)(tar_hdr->mtime), sizeof(tar_hdr->mtime),
                         3U);
#line 340
    file_hdr->c_mtime = (time_t )tmp___6;
#line 341
    tmp___7 = from_ascii((char const   *)(tar_hdr->devmajor), sizeof(tar_hdr->devmajor),
                         3U);
#line 341
    file_hdr->c_rdev_maj = (long )tmp___7;
#line 342
    tmp___8 = from_ascii((char const   *)(tar_hdr->devminor), sizeof(tar_hdr->devminor),
                         3U);
#line 342
    file_hdr->c_rdev_min = (long )tmp___8;
#line 343
    file_hdr->c_tar_linkname = (char *)((void *)0);
    }
    {
#line 352
    if ((int )tar_hdr->typeflag == 53) {
#line 352
      goto case_53;
    }
#line 355
    if ((int )tar_hdr->typeflag == 51) {
#line 355
      goto case_51;
    }
#line 372
    if ((int )tar_hdr->typeflag == 52) {
#line 372
      goto case_52;
    }
#line 378
    if ((int )tar_hdr->typeflag == 54) {
#line 378
      goto case_54;
    }
#line 384
    if ((int )tar_hdr->typeflag == 50) {
#line 384
      goto case_50;
    }
#line 392
    if ((int )tar_hdr->typeflag == 49) {
#line 392
      goto case_49;
    }
#line 398
    if ((int )tar_hdr->typeflag == 0) {
#line 398
      goto case_0;
    }
#line 349
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 350
    file_hdr->c_mode |= 32768U;
#line 351
    goto switch_break;
    case_53: /* CIL Label */ 
#line 353
    file_hdr->c_mode |= 16384U;
#line 354
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 356
    file_hdr->c_mode |= 8192U;
#line 362
    file_hdr->c_tar_linkname = stash_tar_linkname(tar_hdr->linkname);
#line 370
    file_hdr->c_filesize = (off_t )0;
    }
#line 371
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 373
    file_hdr->c_mode |= 24576U;
#line 374
    file_hdr->c_tar_linkname = stash_tar_linkname(tar_hdr->linkname);
#line 375
    file_hdr->c_filesize = (off_t )0;
    }
#line 376
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 379
    file_hdr->c_mode |= 4096U;
#line 380
    file_hdr->c_tar_linkname = stash_tar_linkname(tar_hdr->linkname);
#line 381
    file_hdr->c_filesize = (off_t )0;
    }
#line 382
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 386
    file_hdr->c_mode |= 40960U;
#line 387
    file_hdr->c_tar_linkname = stash_tar_linkname(tar_hdr->linkname);
#line 388
    file_hdr->c_filesize = (off_t )0;
    }
#line 389
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 393
    file_hdr->c_mode |= 32768U;
#line 394
    file_hdr->c_tar_linkname = stash_tar_linkname(tar_hdr->linkname);
#line 395
    file_hdr->c_filesize = (off_t )0;
    }
#line 396
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 401
    tmp___9 = strlen((char const   *)file_hdr->c_name);
    }
#line 401
    if ((int )*(file_hdr->c_name + (tmp___9 - 1UL)) == 47) {
#line 402
      file_hdr->c_mode |= 16384U;
    } else {
#line 404
      file_hdr->c_mode |= 32768U;
    }
#line 405
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 407
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (bytes_skipped > 0L) {
    {
#line 410
    warn_junk_bytes(bytes_skipped);
    }
  }
#line 411
  return;
}
}
#line 419 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
int is_tar_header(char *buf ) 
{ 
  struct tar_header *tar_hdr ;
  unsigned long chksum ;
  unsigned int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 422
  tar_hdr = (struct tar_header *)buf;
#line 425
  chksum = from_ascii((char const   *)(tar_hdr->chksum), sizeof(tar_hdr->chksum),
                      3U);
#line 427
  tmp = tar_checksum(tar_hdr);
  }
#line 427
  if (chksum != (unsigned long )tmp) {
#line 428
    return (0);
  }
  {
#line 433
  tmp___0 = strncmp((char const   *)(tar_hdr->magic), "ustar", (size_t )5);
  }
#line 433
  if (! tmp___0) {
#line 434
    return (2);
  }
#line 435
  return (1);
}
}
#line 452 "/home/wslee/gnu_benchmarks/cpio-2.11/src/tar.c"
int is_tar_filename_too_long(char *name ) 
{ 
  int whole_name_len ;
  int prefix_name_len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 458
  tmp = strlen((char const   *)name);
#line 458
  whole_name_len = (int )tmp;
  }
#line 459
  if (whole_name_len <= 100) {
#line 460
    return (0);
  }
#line 462
  if ((unsigned int )archive_format != 6U) {
#line 463
    return (1);
  }
#line 465
  if (whole_name_len > 256) {
#line 466
    return (1);
  }
  {
#line 470
  tmp___0 = split_long_name((char const   *)name, (size_t )whole_name_len);
#line 470
  prefix_name_len = (int )tmp___0;
  }
#line 475
  if (prefix_name_len == 0) {
#line 477
    return (1);
  } else
#line 475
  if ((whole_name_len - prefix_name_len) - 1 > 100) {
#line 477
    return (1);
  }
#line 479
  return (0);
}
}
#line 695 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int reset_time_flag ;
#line 34
int rename_flag ;
#line 35
char *rename_batch_file ;
#line 36
int table_flag ;
#line 37
int unconditional_flag ;
#line 38
int verbose_flag ;
#line 39
int dot_flag ;
#line 40
int link_flag ;
#line 44
int swap_bytes_flag ;
#line 45
int swap_halfwords_flag ;
#line 54
int quiet_flag ;
#line 56
int no_abs_paths_flag ;
#line 69
int copy_matching_files ;
#line 71
char *pattern_file_name ;
#line 75
int archive_des ;
#line 90
char *directory_name ;
#line 91
char **save_patterns ;
#line 92
int num_patterns ;
#line 93
char name_end ;
#line 117
void process_copy_out(void) ;
#line 120
void process_copy_pass(void) ;
#line 138
void process_args(int argc , char **argv ) ;
#line 139
void initialize_buffers(void) ;
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
char const   *program_authors[5]  = {      "Phil Nelson",      "David MacKenzie",      "John Oleynick",      "Sergey Poznyakoff", 
        (char const   *)((void *)0)};
#line 72 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
char const   *argp_program_bug_address  =    "<bug-cpio@gnu.org>";
#line 73 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static char doc[300]  = 
#line 73
  {      (char )'G',      (char )'N',      (char )'U',      (char )' ', 
        (char )'`',      (char )'c',      (char )'p',      (char )'i', 
        (char )'o',      (char )'\'',      (char )' ',      (char )'c', 
        (char )'o',      (char )'p',      (char )'i',      (char )'e', 
        (char )'s',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'f', 
        (char )'r',      (char )'o',      (char )'m',      (char )' ', 
        (char )'a',      (char )'r',      (char )'c',      (char )'h', 
        (char )'i',      (char )'v',      (char )'e',      (char )'s', 
        (char )'\n',      (char )'\n',      (char )'E',      (char )'x', 
        (char )'a',      (char )'m',      (char )'p',      (char )'l', 
        (char )'e',      (char )'s',      (char )':',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'#',      (char )' ', 
        (char )'C',      (char )'o',      (char )'p',      (char )'y', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'-',      (char )'l',      (char )'i',      (char )'s', 
        (char )'t',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'a',      (char )'r',      (char )'c', 
        (char )'h',      (char )'i',      (char )'v',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'c', 
        (char )'p',      (char )'i',      (char )'o',      (char )' ', 
        (char )'-',      (char )'o',      (char )' ',      (char )'<', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'l',      (char )'i', 
        (char )'s',      (char )'t',      (char )' ',      (char )'[', 
        (char )'>',      (char )' ',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )'i',      (char )'v', 
        (char )'e',      (char )']',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'#',      (char )' ',      (char )'E', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )'i',      (char )'v', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'c',      (char )'p',      (char )'i',      (char )'o', 
        (char )' ',      (char )'-',      (char )'i',      (char )' ', 
        (char )'[',      (char )'<',      (char )' ',      (char )'a', 
        (char )'r',      (char )'c',      (char )'h',      (char )'i', 
        (char )'v',      (char )'e',      (char )']',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'#',      (char )' ', 
        (char )'C',      (char )'o',      (char )'p',      (char )'y', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'-',      (char )'l',      (char )'i',      (char )'s', 
        (char )'t',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'d',      (char )'e',      (char )'s', 
        (char )'t',      (char )'i',      (char )'n',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'-',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'o', 
        (char )'r',      (char )'y',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'c',      (char )'p',      (char )'i', 
        (char )'o',      (char )' ',      (char )'-',      (char )'p', 
        (char )' ',      (char )'d',      (char )'e',      (char )'s', 
        (char )'t',      (char )'i',      (char )'n',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'-',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'o', 
        (char )'r',      (char )'y',      (char )' ',      (char )'<', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'l',      (char )'i', 
        (char )'s',      (char )'t',      (char )'\n',      (char )'\000'};
#line 89 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static struct argp_option options[51]  = 
#line 89
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Main operation mode:",
      10}, 
        {"create", 'o', (char const   *)0, 0, "Create the archive (run in copy-out mode)",
      10}, 
        {"extract", 'i', (char const   *)0, 0, "Extract files from an archive (run in copy-in mode)",
      10}, 
        {"pass-through", 'p', (char const   *)0, 0, "Run in copy-pass mode", 10}, 
        {"list", 't', (char const   *)0, 0, "Print a table of contents of the input",
      10}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid in any mode:",
      100}, 
        {"file", 'F', "[[USER@]HOST:]FILE-NAME", 0, "Use this FILE-NAME instead of standard input or output. Optional USER and HOST specify the user and host names in case of a remote archive",
      101}, 
        {"force-local", 264, (char const   *)0, 0, "Archive file is local, even if its name contains colons",
      101}, 
        {"format", 'H', "FORMAT", 0, "Use given archive FORMAT", 101}, 
        {(char const   *)((void *)0), 'B', (char const   *)((void *)0), 0, "Set the I/O block size to 5120 bytes",
      101}, 
        {"block-size", 266, "BLOCK-SIZE", 0, "Set the I/O block size to BLOCK-SIZE * 512 bytes",
      101}, 
        {(char const   *)((void *)0), 'c', (char const   *)((void *)0), 0, "Use the old portable (ASCII) archive format",
      101}, 
        {"dot", 'V', (char const   *)((void *)0), 0, "Print a \".\" for each file processed",
      101}, 
        {"io-size", 'C', "NUMBER", 0, "Set the I/O block size to the given NUMBER of bytes",
      101}, 
        {"message", 'M', "STRING", 0, "Print STRING when the end of a volume of the backup media is reached",
      101}, 
        {"nonmatching", 'f', (char const   *)0, 0, "Only copy files that do not match any of the given patterns",
      101}, 
        {"numeric-uid-gid", 'n', (char const   *)0, 0, "In the verbose table of contents listing, show numeric UID and GID",
      101}, 
        {"rsh-command", 261, "COMMAND", 0, "Use remote COMMAND instead of rsh", 101}, 
        {"quiet",
      262, (char const   *)((void *)0), 0, "Do not print the number of blocks copied",
      101}, 
        {"verbose", 'v', (char const   *)((void *)0), 0, "Verbosely list the files processed",
      101}, 
        {"warning", 'W', "FLAG", 0, "Control warning display. Currently FLAG is one of \'none\', \'truncate\', \'all\'. Multiple options accumulate.",
      101}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid only in copy-in mode:",
      200}, 
        {"pattern-file", 'E', "FILE", 0, "Read additional patterns specifying filenames to extract or list from FILE",
      210}, 
        {"only-verify-crc", 259, (char const   *)0, 0, "When reading a CRC format archive, only verify the CRC\'s of each file in the archive, don\'t actually extract the files",
      210}, 
        {"rename", 'r', (char const   *)0, 0, "Interactively rename files", 201}, 
        {"rename-batch-file", 260, "FILE", 2, "", 201}, 
        {"swap", 'b', (char const   *)((void *)0), 0, "Swap both halfwords of words and bytes of halfwords in the data. Equivalent to -sS",
      201}, 
        {"swap-bytes", 's', (char const   *)((void *)0), 0, "Swap the bytes of each halfword in the files",
      201}, 
        {"swap-halfwords", 'S', (char const   *)((void *)0), 0, "Swap the halfwords of each word (4 bytes) in the files",
      201}, 
        {"to-stdout", 267, (char const   *)((void *)0), 0, "Extract files to standard output",
      201}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid only in copy-out mode:",
      300}, 
        {"append", 'A', (char const   *)0, 0, "Append to an existing archive.", 301}, 
        {(char const   *)((void *)0),
      'O', "[[USER@]HOST:]FILE-NAME", 0, "Archive filename to use instead of standard output. Optional USER and HOST specify the user and host names in case of a remote archive",
      301}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid only in copy-pass mode:",
      400}, 
        {"link", 'l', (char const   *)0, 0, "Link files instead of copying them, when  possible",
      401}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid in copy-in and copy-out modes:",
      500}, 
        {"absolute-filenames", 257, (char const   *)0, 0, "Do not strip file system prefix components from the file names",
      501}, 
        {"no-absolute-filenames", 256, (char const   *)0, 0, "Create all files relative to the current directory",
      501}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid in copy-out and copy-pass modes:",
      600}, 
        {"null", '0', (char const   *)0, 0, "A list of filenames is terminated by a null character instead of a newline",
      601}, 
        {(char const   *)((void *)0), 'I', "[[USER@]HOST:]FILE-NAME", 0, "Archive filename to use instead of standard input. Optional USER and HOST specify the user and host names in case of a remote archive",
      601}, 
        {"dereference", 'L', (char const   *)0, 0, "Dereference  symbolic  links  (copy  the files that they point to instead of copying the links).",
      601}, 
        {"owner", 'R', "[USER][:.][GROUP]", 0, "Set the ownership of all files created to the specified USER and/or GROUP",
      601}, 
        {"reset-access-time", 'a', (char const   *)((void *)0), 0, "Reset the access times of files after reading them",
      601}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers valid in copy-in and copy-pass modes:",
      700}, 
        {"preserve-modification-time", 'm', (char const   *)0, 0, "Retain previous file modification times when creating files",
      701}, 
        {"make-directories", 'd', (char const   *)0, 0, "Create leading directories where needed",
      701}, 
        {"no-preserve-owner", 258, (char const   *)0, 0, "Do not change the ownership of the files",
      701}, 
        {"unconditional", 'u', (char const   *)((void *)0), 0, "Replace all files unconditionally",
      701}, 
        {"sparse", 263, (char const   *)((void *)0), 0, "Write files with large blocks of zeros as sparse files",
      701}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 234 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static char *input_archive_name  =    (char *)0;
#line 235 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static char *output_archive_name  =    (char *)0;
#line 240
static int warn_control(char *arg___0 ) ;
#line 240 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static struct warn_tab warn_tab[5]  = {      {(char *)"none", -1}, 
        {(char *)"truncate", 1}, 
        {(char *)"all", -1}, 
        {(char *)"interdir", 2}, 
        {(char *)((void *)0), 0}};
#line 237 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static int warn_control(char *arg___0 ) 
{ 
  struct warn_tab *wt ;
  int offset ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 251
  offset = 0;
#line 253
  tmp = strcmp((char const   *)arg___0, "none");
  }
#line 253
  if (tmp == 0) {
#line 255
    warn_option = 0U;
#line 256
    return (0);
  }
  {
#line 259
  tmp___0 = strlen((char const   *)arg___0);
  }
#line 259
  if (tmp___0 > 2UL) {
    {
#line 259
    tmp___1 = memcmp((void const   *)arg___0, (void const   *)"no-", (size_t )3);
    }
#line 259
    if (tmp___1 == 0) {
#line 260
      offset = 3;
    }
  }
#line 262
  wt = warn_tab;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! wt->name) {
#line 262
      goto while_break;
    }
    {
#line 263
    tmp___2 = strcmp((char const   *)(arg___0 + offset), (char const   *)wt->name);
    }
#line 263
    if (tmp___2 == 0) {
#line 265
      if (offset) {
#line 266
        warn_option &= (unsigned int )(~ wt->flag);
      } else {
#line 268
        warn_option |= (unsigned int )wt->flag;
      }
#line 269
      return (0);
    }
#line 262
    wt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (1);
}
}
#line 275 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static error_t parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *e ;
  char *u ;
  char *g ;
  char *tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 280
  if (key == 48) {
#line 280
    goto case_48;
  }
#line 284
  if (key == 97) {
#line 284
    goto case_97;
  }
#line 288
  if (key == 65) {
#line 288
    goto case_65;
  }
#line 292
  if (key == 98) {
#line 292
    goto case_98;
  }
#line 297
  if (key == 66) {
#line 297
    goto case_66;
  }
#line 301
  if (key == 266) {
#line 301
    goto case_266;
  }
#line 308
  if (key == 99) {
#line 308
    goto case_99;
  }
#line 318
  if (key == 67) {
#line 318
    goto case_67;
  }
#line 324
  if (key == 100) {
#line 324
    goto case_100;
  }
#line 328
  if (key == 102) {
#line 328
    goto case_102;
  }
#line 332
  if (key == 69) {
#line 332
    goto case_69;
  }
#line 336
  if (key == 70) {
#line 336
    goto case_70;
  }
#line 340
  if (key == 72) {
#line 340
    goto case_72;
  }
#line 365
  if (key == 105) {
#line 365
    goto case_105;
  }
#line 371
  if (key == 73) {
#line 371
    goto case_73;
  }
#line 375
  if (key == 107) {
#line 375
    goto case_107;
  }
#line 380
  if (key == 108) {
#line 380
    goto case_108;
  }
#line 384
  if (key == 76) {
#line 384
    goto case_76;
  }
#line 388
  if (key == 109) {
#line 388
    goto case_109;
  }
#line 392
  if (key == 77) {
#line 392
    goto case_77;
  }
#line 396
  if (key == 110) {
#line 396
    goto case_110;
  }
#line 400
  if (key == 256) {
#line 400
    goto case_256;
  }
#line 404
  if (key == 257) {
#line 404
    goto case_257;
  }
#line 408
  if (key == 258) {
#line 408
    goto case_258;
  }
#line 415
  if (key == 111) {
#line 415
    goto case_111;
  }
#line 421
  if (key == 79) {
#line 421
    goto case_79;
  }
#line 425
  if (key == 259) {
#line 425
    goto case_259;
  }
#line 429
  if (key == 112) {
#line 429
    goto case_112;
  }
#line 435
  if (key == 261) {
#line 435
    goto case_261;
  }
#line 439
  if (key == 114) {
#line 439
    goto case_114;
  }
#line 443
  if (key == 260) {
#line 443
    goto case_260;
  }
#line 447
  if (key == 262) {
#line 447
    goto case_262;
  }
#line 451
  if (key == 82) {
#line 451
    goto case_82;
  }
#line 475
  if (key == 115) {
#line 475
    goto case_115;
  }
#line 479
  if (key == 83) {
#line 479
    goto case_83;
  }
#line 483
  if (key == 116) {
#line 483
    goto case_116;
  }
#line 487
  if (key == 117) {
#line 487
    goto case_117;
  }
#line 491
  if (key == 118) {
#line 491
    goto case_118;
  }
#line 495
  if (key == 86) {
#line 495
    goto case_86;
  }
#line 499
  if (key == 87) {
#line 499
    goto case_87;
  }
#line 504
  if (key == 263) {
#line 504
    goto case_263;
  }
#line 508
  if (key == 264) {
#line 508
    goto case_264;
  }
#line 518
  if (key == 267) {
#line 518
    goto case_267;
  }
#line 522
  goto switch_default;
  case_48: /* CIL Label */ 
#line 281
  name_end = (char )'\000';
#line 282
  goto switch_break;
  case_97: /* CIL Label */ 
#line 285
  reset_time_flag = 1;
#line 286
  goto switch_break;
  case_65: /* CIL Label */ 
#line 289
  append_flag = 1;
#line 290
  goto switch_break;
  case_98: /* CIL Label */ 
#line 293
  swap_bytes_flag = 1;
#line 294
  swap_halfwords_flag = 1;
#line 295
  goto switch_break;
  case_66: /* CIL Label */ 
#line 298
  io_block_size = 5120;
#line 299
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 302
  io_block_size = atoi((char const   *)arg___0);
  }
#line 303
  if (io_block_size < 1) {
    {
#line 304
    tmp = gettext("invalid block size");
#line 304
    error(2, 0, (char const   *)tmp);
    }
  }
#line 305
  io_block_size *= 512;
#line 306
  goto switch_break;
  case_99: /* CIL Label */ 
#line 309
  if ((unsigned int )archive_format != 0U) {
    {
#line 310
    tmp___0 = gettext("Archive format multiply defined");
#line 310
    error(0, 1, (char const   *)tmp___0);
    }
  }
#line 314
  archive_format = (enum archive_format )2;
#line 316
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 319
  io_block_size = atoi((char const   *)arg___0);
  }
#line 320
  if (io_block_size < 1) {
    {
#line 321
    tmp___1 = gettext("invalid block size");
#line 321
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 322
  goto switch_break;
  case_100: /* CIL Label */ 
#line 325
  create_dir_flag = 1;
#line 326
  goto switch_break;
  case_102: /* CIL Label */ 
#line 329
  copy_matching_files = 0;
#line 330
  goto switch_break;
  case_69: /* CIL Label */ 
#line 333
  pattern_file_name = arg___0;
#line 334
  goto switch_break;
  case_70: /* CIL Label */ 
#line 337
  archive_name = arg___0;
#line 338
  goto switch_break;
  case_72: /* CIL Label */ 
#line 341
  if ((unsigned int )archive_format != 0U) {
    {
#line 342
    tmp___2 = gettext("Archive format multiply defined");
#line 342
    error(2, 0, (char const   *)tmp___2);
    }
  }
  {
#line 343
  tmp___11 = strcasecmp((char const   *)arg___0, "crc");
  }
#line 343
  if (tmp___11) {
    {
#line 345
    tmp___10 = strcasecmp((char const   *)arg___0, "newc");
    }
#line 345
    if (tmp___10) {
      {
#line 347
      tmp___9 = strcasecmp((char const   *)arg___0, "odc");
      }
#line 347
      if (tmp___9) {
        {
#line 349
        tmp___8 = strcasecmp((char const   *)arg___0, "bin");
        }
#line 349
        if (tmp___8) {
          {
#line 351
          tmp___7 = strcasecmp((char const   *)arg___0, "ustar");
          }
#line 351
          if (tmp___7) {
            {
#line 353
            tmp___6 = strcasecmp((char const   *)arg___0, "tar");
            }
#line 353
            if (tmp___6) {
              {
#line 355
              tmp___5 = strcasecmp((char const   *)arg___0, "hpodc");
              }
#line 355
              if (tmp___5) {
                {
#line 357
                tmp___4 = strcasecmp((char const   *)arg___0, "hpbin");
                }
#line 357
                if (tmp___4) {
                  {
#line 360
                  tmp___3 = gettext("invalid archive format `%s\'; valid formats are:\ncrc newc odc bin ustar tar (all-caps also recognized)");
#line 360
                  error(2, 0, (char const   *)tmp___3, arg___0);
                  }
                } else {
#line 358
                  archive_format = (enum archive_format )8;
                }
              } else {
#line 356
                archive_format = (enum archive_format )7;
              }
            } else {
#line 354
              archive_format = (enum archive_format )5;
            }
          } else {
#line 352
            archive_format = (enum archive_format )6;
          }
        } else {
#line 350
          archive_format = (enum archive_format )1;
        }
      } else {
#line 348
        archive_format = (enum archive_format )2;
      }
    } else {
#line 346
      archive_format = (enum archive_format )3;
    }
  } else {
#line 344
    archive_format = (enum archive_format )4;
  }
#line 363
  goto switch_break;
  case_105: /* CIL Label */ 
#line 366
  if ((unsigned long )copy_function != (unsigned long )((void (*)())0)) {
    {
#line 367
    tmp___12 = gettext("Mode already defined");
#line 367
    error(2, 0, (char const   *)tmp___12);
    }
  }
#line 368
  copy_function = & process_copy_in;
#line 369
  goto switch_break;
  case_73: /* CIL Label */ 
#line 372
  input_archive_name = arg___0;
#line 373
  goto switch_break;
  case_107: /* CIL Label */ 
#line 378
  goto switch_break;
  case_108: /* CIL Label */ 
#line 381
  link_flag = 1;
#line 382
  goto switch_break;
  case_76: /* CIL Label */ 
#line 385
  xstat = (int (*)())(& stat);
#line 386
  goto switch_break;
  case_109: /* CIL Label */ 
#line 389
  retain_time_flag = 1;
#line 390
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 393
  set_new_media_message(arg___0);
  }
#line 394
  goto switch_break;
  case_110: /* CIL Label */ 
#line 397
  numeric_uid = 1;
#line 398
  goto switch_break;
  case_256: /* CIL Label */ 
#line 401
  no_abs_paths_flag = 1;
#line 402
  goto switch_break;
  case_257: /* CIL Label */ 
#line 405
  no_abs_paths_flag = 0;
#line 406
  goto switch_break;
  case_258: /* CIL Label */ 
#line 409
  if (set_owner_flag) {
    {
#line 410
    tmp___13 = gettext("--no-preserve-owner cannot be used with --owner");
#line 410
    error(2, 0, (char const   *)tmp___13);
    }
  } else
#line 409
  if (set_group_flag) {
    {
#line 410
    tmp___13 = gettext("--no-preserve-owner cannot be used with --owner");
#line 410
    error(2, 0, (char const   *)tmp___13);
    }
  }
#line 412
  no_chown_flag = 1;
#line 413
  goto switch_break;
  case_111: /* CIL Label */ 
#line 416
  if ((unsigned long )copy_function != (unsigned long )((void (*)())0)) {
    {
#line 417
    tmp___14 = gettext("Mode already defined");
#line 417
    error(2, 0, (char const   *)tmp___14);
    }
  }
#line 418
  copy_function = & process_copy_out;
#line 419
  goto switch_break;
  case_79: /* CIL Label */ 
#line 422
  output_archive_name = arg___0;
#line 423
  goto switch_break;
  case_259: /* CIL Label */ 
#line 426
  only_verify_crc_flag = 1;
#line 427
  goto switch_break;
  case_112: /* CIL Label */ 
#line 430
  if ((unsigned long )copy_function != (unsigned long )((void (*)())0)) {
    {
#line 431
    tmp___15 = gettext("Mode already defined");
#line 431
    error(2, 0, (char const   *)tmp___15);
    }
  }
#line 432
  copy_function = & process_copy_pass;
#line 433
  goto switch_break;
  case_261: /* CIL Label */ 
#line 436
  rsh_command_option = arg___0;
#line 437
  goto switch_break;
  case_114: /* CIL Label */ 
#line 440
  rename_flag = 1;
#line 441
  goto switch_break;
  case_260: /* CIL Label */ 
#line 444
  rename_batch_file = arg___0;
#line 445
  goto switch_break;
  case_262: /* CIL Label */ 
#line 448
  quiet_flag = 1;
#line 449
  goto switch_break;
  case_82: /* CIL Label */ 
#line 452
  if (no_chown_flag) {
    {
#line 453
    tmp___16 = gettext("--owner cannot be used with --no-preserve-owner");
#line 453
    error(2, 0, (char const   *)tmp___16);
    }
  } else {
    {
#line 459
    e = (char *)parse_user_spec(arg___0, & set_owner, & set_group, & u, & g);
    }
#line 460
    if (e) {
      {
#line 461
      error(2, 0, "%s: %s", arg___0, e);
      }
    }
#line 462
    if (u) {
      {
#line 464
      free((void *)u);
#line 465
      set_owner_flag = 1;
      }
    }
#line 467
    if (g) {
      {
#line 469
      free((void *)g);
#line 470
      set_group_flag = 1;
      }
    }
  }
#line 473
  goto switch_break;
  case_115: /* CIL Label */ 
#line 476
  swap_bytes_flag = 1;
#line 477
  goto switch_break;
  case_83: /* CIL Label */ 
#line 480
  swap_halfwords_flag = 1;
#line 481
  goto switch_break;
  case_116: /* CIL Label */ 
#line 484
  table_flag = 1;
#line 485
  goto switch_break;
  case_117: /* CIL Label */ 
#line 488
  unconditional_flag = 1;
#line 489
  goto switch_break;
  case_118: /* CIL Label */ 
#line 492
  verbose_flag = 1;
#line 493
  goto switch_break;
  case_86: /* CIL Label */ 
#line 496
  dot_flag = 1;
#line 497
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 500
  tmp___18 = warn_control(arg___0);
  }
#line 500
  if (tmp___18) {
    {
#line 501
    tmp___17 = gettext("Invalid value for --warning option: %s");
#line 501
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp___17,
               arg___0);
    }
  }
#line 502
  goto switch_break;
  case_263: /* CIL Label */ 
#line 505
  sparse_flag = 1;
#line 506
  goto switch_break;
  case_264: /* CIL Label */ 
#line 509
  force_local_option = (_Bool)1;
#line 510
  goto switch_break;
  case_267: /* CIL Label */ 
#line 519
  to_stdout_option = (_Bool)1;
#line 520
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 523
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 525
  return (0);
}
}
#line 528 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
static struct argp argp  =    {(struct argp_option  const  *)(options), & parse_opt, "[destination-directory]",
    (char const   *)(doc), (struct argp_child  const  *)((void *)0), (char *(*)(int __key ,
                                                                                char const   *__text ,
                                                                                void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 541 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
void process_args(int argc , char **argv ) 
{ 
  void (*copy_in)() ;
  void (*copy_out)() ;
  int index___0 ;
  error_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  int *tmp___43 ;
  __uid_t tmp___44 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;

  {
  {
#line 548
  xstat = (int (*)())(& lstat);
#line 550
  tmp = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                   8U, (int */* __restrict  */)(& index___0), (void */* __restrict  */)((void *)0));
  }
#line 550
  if (tmp) {
    {
#line 551
    exit(2);
    }
  }
#line 555
  if ((unsigned long )copy_function == (unsigned long )((void (*)())0)) {
#line 557
    if (table_flag) {
#line 558
      copy_function = & process_copy_in;
    } else {
      {
#line 560
      tmp___0 = gettext("You must specify one of -oipt options.\nTry `%s --help\' or `%s --usage\' for more information.\n");
#line 560
      error(2, 0, (char const   *)tmp___0, program_name, program_name);
      }
    }
  }
#line 566
  copy_in = & process_copy_in;
#line 567
  copy_out = & process_copy_out;
#line 569
  if ((unsigned long )copy_function == (unsigned long )copy_in) {
#line 571
    archive_des = 0;
#line 572
    if (link_flag) {
      {
#line 572
      tmp___1 = gettext("%s is meaningless with %s");
#line 572
      error(2, 0, (char const   *)tmp___1, "--link", "--extract");
#line 572
      exit_status = 2;
      }
    }
#line 573
    if (reset_time_flag) {
      {
#line 573
      tmp___2 = gettext("%s is meaningless with %s");
#line 573
      error(2, 0, (char const   *)tmp___2, "--reset", "--extract");
#line 573
      exit_status = 2;
      }
    }
#line 574
    if ((unsigned long )xstat != (unsigned long )(& lstat)) {
      {
#line 574
      tmp___3 = gettext("%s is meaningless with %s");
#line 574
      error(2, 0, (char const   *)tmp___3, "--dereference", "--extract");
#line 574
      exit_status = 2;
      }
    }
#line 575
    if (append_flag) {
      {
#line 575
      tmp___4 = gettext("%s is meaningless with %s");
#line 575
      error(2, 0, (char const   *)tmp___4, "--append", "--extract");
#line 575
      exit_status = 2;
      }
    }
#line 576
    if (output_archive_name) {
      {
#line 576
      tmp___5 = gettext("%s is meaningless with %s");
#line 576
      error(2, 0, (char const   *)tmp___5, "-O", "--extract");
#line 576
      exit_status = 2;
      }
    }
#line 577
    if (to_stdout_option) {
#line 579
      if (create_dir_flag) {
        {
#line 579
        tmp___6 = gettext("%s is meaningless with %s");
#line 579
        error(2, 0, (char const   *)tmp___6, "--make-directories", "--to-stdout");
#line 579
        exit_status = 2;
        }
      }
#line 580
      if (rename_flag) {
        {
#line 580
        tmp___7 = gettext("%s is meaningless with %s");
#line 580
        error(2, 0, (char const   *)tmp___7, "--rename", "--to-stdout");
#line 580
        exit_status = 2;
        }
      }
#line 581
      if (no_chown_flag) {
        {
#line 581
        tmp___8 = gettext("%s is meaningless with %s");
#line 581
        error(2, 0, (char const   *)tmp___8, "--no-preserve-owner", "--to-stdout");
#line 581
        exit_status = 2;
        }
      }
#line 582
      if (set_owner_flag) {
        {
#line 582
        tmp___9 = gettext("%s is meaningless with %s");
#line 582
        error(2, 0, (char const   *)tmp___9, "--owner", "--to-stdout");
#line 582
        exit_status = 2;
        }
      } else
#line 582
      if (set_group_flag) {
        {
#line 582
        tmp___9 = gettext("%s is meaningless with %s");
#line 582
        error(2, 0, (char const   *)tmp___9, "--owner", "--to-stdout");
#line 582
        exit_status = 2;
        }
      }
#line 583
      if (retain_time_flag) {
        {
#line 583
        tmp___10 = gettext("%s is meaningless with %s");
#line 583
        error(2, 0, (char const   *)tmp___10, "--preserve-modification-time", "--to-stdout");
#line 583
        exit_status = 2;
        }
      }
    }
#line 587
    if (archive_name) {
#line 587
      if (input_archive_name) {
        {
#line 588
        tmp___11 = gettext("Both -I and -F are used in copy-in mode");
#line 588
        error(2, 0, (char const   *)tmp___11);
        }
      }
    }
#line 591
    if ((unsigned int )archive_format == 4U) {
#line 592
      crc_i_flag = 1;
    }
#line 593
    num_patterns = argc - index___0;
#line 594
    save_patterns = argv + index___0;
#line 595
    if (input_archive_name) {
#line 596
      archive_name = input_archive_name;
    }
  } else
#line 598
  if ((unsigned long )copy_function == (unsigned long )copy_out) {
#line 600
    if (index___0 != argc) {
      {
#line 601
      tmp___12 = gettext("Too many arguments");
#line 601
      error(2, 0, (char const   *)tmp___12);
      }
    }
#line 603
    archive_des = 1;
#line 604
    if (create_dir_flag) {
      {
#line 604
      tmp___13 = gettext("%s is meaningless with %s");
#line 604
      error(2, 0, (char const   *)tmp___13, "--make-directories", "--create");
#line 604
      exit_status = 2;
      }
    }
#line 605
    if (rename_flag) {
      {
#line 605
      tmp___14 = gettext("%s is meaningless with %s");
#line 605
      error(2, 0, (char const   *)tmp___14, "--rename", "--create");
#line 605
      exit_status = 2;
      }
    }
#line 606
    if (table_flag) {
      {
#line 606
      tmp___15 = gettext("%s is meaningless with %s");
#line 606
      error(2, 0, (char const   *)tmp___15, "--list", "--create");
#line 606
      exit_status = 2;
      }
    }
#line 607
    if (unconditional_flag) {
      {
#line 607
      tmp___16 = gettext("%s is meaningless with %s");
#line 607
      error(2, 0, (char const   *)tmp___16, "--unconditional", "--create");
#line 607
      exit_status = 2;
      }
    }
#line 608
    if (link_flag) {
      {
#line 608
      tmp___17 = gettext("%s is meaningless with %s");
#line 608
      error(2, 0, (char const   *)tmp___17, "--link", "--create");
#line 608
      exit_status = 2;
      }
    }
#line 609
    if (sparse_flag) {
      {
#line 609
      tmp___18 = gettext("%s is meaningless with %s");
#line 609
      error(2, 0, (char const   *)tmp___18, "--sparse", "--create");
#line 609
      exit_status = 2;
      }
    }
#line 610
    if (retain_time_flag) {
      {
#line 610
      tmp___19 = gettext("%s is meaningless with %s");
#line 610
      error(2, 0, (char const   *)tmp___19, "--preserve-modification-time", "--create");
#line 610
      exit_status = 2;
      }
    }
#line 612
    if (no_chown_flag) {
      {
#line 612
      tmp___20 = gettext("%s is meaningless with %s");
#line 612
      error(2, 0, (char const   *)tmp___20, "--no-preserve-owner", "--create");
#line 612
      exit_status = 2;
      }
    }
#line 613
    if (swap_bytes_flag) {
      {
#line 613
      tmp___21 = gettext("%s is meaningless with %s");
#line 613
      error(2, 0, (char const   *)tmp___21, "--swap-bytes (--swap)", "--create");
#line 613
      exit_status = 2;
      }
    }
#line 614
    if (swap_halfwords_flag) {
      {
#line 614
      tmp___22 = gettext("%s is meaningless with %s");
#line 614
      error(2, 0, (char const   *)tmp___22, "--swap-halfwords (--swap)", "--create");
#line 614
      exit_status = 2;
      }
    }
#line 616
    if (to_stdout_option) {
      {
#line 616
      tmp___23 = gettext("%s is meaningless with %s");
#line 616
      error(2, 0, (char const   *)tmp___23, "--to-stdout", "--create");
#line 616
      exit_status = 2;
      }
    }
#line 618
    if (append_flag) {
#line 618
      if (! archive_name) {
#line 618
        if (! output_archive_name) {
          {
#line 619
          tmp___24 = gettext("--append is used but no archive file name is given (use -F or -O options)");
#line 619
          error(2, 0, (char const   *)tmp___24);
          }
        }
      }
    }
#line 622
    if (rename_batch_file) {
      {
#line 622
      tmp___25 = gettext("%s is meaningless with %s");
#line 622
      error(2, 0, (char const   *)tmp___25, "--rename-batch-file", "--create");
#line 622
      exit_status = 2;
      }
    }
#line 623
    if (input_archive_name) {
      {
#line 623
      tmp___26 = gettext("%s is meaningless with %s");
#line 623
      error(2, 0, (char const   *)tmp___26, "-I", "--create");
#line 623
      exit_status = 2;
      }
    }
#line 624
    if (archive_name) {
#line 624
      if (output_archive_name) {
        {
#line 625
        tmp___27 = gettext("Both -O and -F are used in copy-out mode");
#line 625
        error(2, 0, (char const   *)tmp___27);
        }
      }
    }
#line 628
    if ((unsigned int )archive_format == 0U) {
#line 629
      archive_format = (enum archive_format )1;
    }
#line 630
    if (output_archive_name) {
#line 631
      archive_name = output_archive_name;
    }
  } else {
#line 636
    if (index___0 < argc - 1) {
      {
#line 637
      tmp___28 = gettext("Too many arguments");
#line 637
      error(2, 0, (char const   *)tmp___28);
      }
    } else
#line 638
    if (index___0 > argc - 1) {
      {
#line 639
      tmp___29 = gettext("Not enough arguments");
#line 639
      error(2, 0, (char const   *)tmp___29);
      }
    }
#line 641
    if ((unsigned int )archive_format != 0U) {
      {
#line 642
      tmp___30 = gettext("Archive format is not specified in copy-pass mode (use --format option)");
#line 642
      error(2, 0, (char const   *)tmp___30);
      }
    }
#line 645
    if (swap_bytes_flag) {
      {
#line 645
      tmp___31 = gettext("%s is meaningless with %s");
#line 645
      error(2, 0, (char const   *)tmp___31, "--swap-bytes (--swap)", "--pass-through");
#line 645
      exit_status = 2;
      }
    }
#line 646
    if (swap_halfwords_flag) {
      {
#line 646
      tmp___32 = gettext("%s is meaningless with %s");
#line 646
      error(2, 0, (char const   *)tmp___32, "--swap-halfwords (--swap)", "--pass-through");
#line 646
      exit_status = 2;
      }
    }
#line 648
    if (table_flag) {
      {
#line 648
      tmp___33 = gettext("%s is meaningless with %s");
#line 648
      error(2, 0, (char const   *)tmp___33, "--list", "--pass-through");
#line 648
      exit_status = 2;
      }
    }
#line 649
    if (rename_flag) {
      {
#line 649
      tmp___34 = gettext("%s is meaningless with %s");
#line 649
      error(2, 0, (char const   *)tmp___34, "--rename", "--pass-through");
#line 649
      exit_status = 2;
      }
    }
#line 650
    if (append_flag) {
      {
#line 650
      tmp___35 = gettext("%s is meaningless with %s");
#line 650
      error(2, 0, (char const   *)tmp___35, "--append", "--pass-through");
#line 650
      exit_status = 2;
      }
    }
#line 651
    if (rename_batch_file) {
      {
#line 651
      tmp___36 = gettext("%s is meaningless with %s");
#line 651
      error(2, 0, (char const   *)tmp___36, "--rename-batch-file", "--pass-through");
#line 651
      exit_status = 2;
      }
    }
#line 652
    if (no_abs_paths_flag) {
      {
#line 652
      tmp___37 = gettext("%s is meaningless with %s");
#line 652
      error(2, 0, (char const   *)tmp___37, "--no-absolute-pathnames", "--pass-through");
#line 652
      exit_status = 2;
      }
    }
#line 654
    if (no_abs_paths_flag) {
      {
#line 654
      tmp___38 = gettext("%s is meaningless with %s");
#line 654
      error(2, 0, (char const   *)tmp___38, "--absolute-pathnames", "--pass-through");
#line 654
      exit_status = 2;
      }
    }
#line 656
    if (to_stdout_option) {
      {
#line 656
      tmp___39 = gettext("%s is meaningless with %s");
#line 656
      error(2, 0, (char const   *)tmp___39, "--to-stdout", "--pass-through");
#line 656
      exit_status = 2;
      }
    }
#line 658
    directory_name = *(argv + index___0);
  }
#line 661
  if (archive_name) {
#line 663
    if ((unsigned long )copy_function != (unsigned long )copy_in) {
#line 663
      if ((unsigned long )copy_function != (unsigned long )copy_out) {
        {
#line 664
        tmp___40 = gettext("-F can be used only with --create or --extract");
#line 664
        error(2, 0, (char const   *)tmp___40);
        }
      }
    }
    {
#line 666
    archive_des = open_archive(archive_name);
    }
#line 667
    if (archive_des < 0) {
      {
#line 668
      tmp___41 = quotearg_colon((char const   *)archive_name);
#line 668
      tmp___42 = gettext("Cannot open %s");
#line 668
      tmp___43 = __errno_location();
#line 668
      error(2, *tmp___43, (char const   *)tmp___42, tmp___41);
      }
    }
  }
#line 675
  if (set_owner_flag == 0) {
#line 675
    if (set_group_flag == 0) {
      {
#line 675
      tmp___44 = geteuid();
      }
#line 675
      if (tmp___44) {
#line 676
        no_chown_flag = 1;
      }
    }
  }
#line 677
  return;
}
}
#line 683 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
void initialize_buffers(void) 
{ 
  int in_buf_size ;
  int out_buf_size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 688
  if ((unsigned long )copy_function == (unsigned long )(& process_copy_in)) {
#line 695
    if (io_block_size >= 512) {
#line 696
      in_buf_size = 2 * io_block_size;
    } else {
#line 698
      in_buf_size = 1024;
    }
#line 699
    out_buf_size = 512;
  } else
#line 701
  if ((unsigned long )copy_function == (unsigned long )(& process_copy_out)) {
#line 703
    in_buf_size = 512;
#line 704
    out_buf_size = io_block_size;
  } else {
#line 708
    in_buf_size = 512;
#line 709
    out_buf_size = 512;
  }
  {
#line 712
  tmp = xmalloc((size_t )in_buf_size);
#line 712
  input_buffer = (char *)tmp;
#line 713
  in_buff = input_buffer;
#line 714
  input_buffer_size = (size_t )in_buf_size;
#line 715
  input_size = (size_t )0;
#line 716
  input_bytes = (off_t )0;
#line 718
  tmp___0 = xmalloc((size_t )out_buf_size);
#line 718
  output_buffer = (char *)tmp___0;
#line 719
  out_buff = output_buffer;
#line 720
  output_size = (size_t )0;
#line 721
  output_bytes = (off_t )0;
  }
#line 722
  return;
}
}
#line 724 "/home/wslee/gnu_benchmarks/cpio-2.11/src/main.c"
int main(int argc , char **argv ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 727
  setlocale(6, "");
#line 728
  bindtextdomain("cpio", "/usr/local/share/locale");
#line 729
  textdomain("cpio");
#line 731
  set_program_name((char const   *)*(argv + 0));
#line 732
  argp_version_setup("cpio", (char const   * const  *)(program_authors));
#line 733
  process_args(argc, argv);
#line 735
  initialize_buffers();
#line 737
  (*copy_function)();
  }
#line 739
  if (archive_des >= 0) {
#line 739
    if (archive_des >= 1 << 30) {
      {
#line 739
      tmp___1 = rmt_close__(archive_des - (1 << 30));
#line 739
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 739
      tmp___2 = close(archive_des);
#line 739
      tmp___3 = tmp___2;
      }
    }
#line 739
    if (tmp___3 == -1) {
      {
#line 740
      tmp = gettext("error closing archive");
#line 740
      tmp___0 = __errno_location();
#line 740
      error(2, *tmp___0, (char const   *)tmp);
      }
    }
  }
  {
#line 742
  pax_exit();
  }
#line 743
  return (0);
}
}
#line 22 "/home/wslee/gnu_benchmarks/cpio-2.11/src/fatal.c"
 __attribute__((__noreturn__)) void fatal_exit(void) ;
#line 22 "/home/wslee/gnu_benchmarks/cpio-2.11/src/fatal.c"
void fatal_exit(void) 
{ 


  {
  {
#line 25
  exit(2);
  }
}
}
#line 49 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
uid_t set_owner  ;
#line 51 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
gid_t set_group  ;
#line 58 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
mode_t newdir_umask  ;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int archive_des  ;
#line 78 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
unsigned long crc  ;
#line 84 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
char *input_buffer  ;
#line 84 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
char *output_buffer  ;
#line 85 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
char *in_buff  ;
#line 85 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
char *out_buff  ;
#line 86 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
size_t input_buffer_size  ;
#line 87 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
size_t input_size  ;
#line 87 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
size_t output_size  ;
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
off_t input_bytes  ;
#line 88 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
off_t output_bytes  ;
#line 91 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
char **save_patterns  ;
#line 92 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int num_patterns  ;
#line 96
char input_is_seekable ;
#line 97
char output_is_seekable ;
#line 98 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int (*xstat)()  ;
#line 28 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int reset_time_flag  =    0;
#line 31 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int io_block_size  =    512;
#line 34 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
enum archive_format archive_format  =    (enum archive_format )0;
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int create_dir_flag  =    0;
#line 40 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int rename_flag  =    0;
#line 44 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *rename_batch_file  =    (char *)((void *)0);
#line 47 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int table_flag  =    0;
#line 50 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int unconditional_flag  =    0;
#line 53 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int verbose_flag  =    0;
#line 56 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int dot_flag  =    0;
#line 59 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int link_flag  =    0;
#line 62 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int retain_time_flag  =    0;
#line 66 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int crc_i_flag  =    0;
#line 69 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int append_flag  =    0;
#line 72 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int swap_bytes_flag  =    0;
#line 75 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int swap_halfwords_flag  =    0;
#line 78 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int swapping_halfwords  =    0;
#line 81 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int swapping_bytes  =    0;
#line 87 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int set_owner_flag  =    0;
#line 91 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int set_group_flag  =    0;
#line 95 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int no_chown_flag  =    0;
#line 98 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int sparse_flag  =    0;
#line 101 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int quiet_flag  =    0;
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int only_verify_crc_flag  =    0;
#line 108 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int no_abs_paths_flag  =    0;
#line 117 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int last_header_start  =    0;
#line 121 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int copy_matching_files  =    1;
#line 125 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
int numeric_uid  =    0;
#line 128 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *pattern_file_name  =    (char *)((void *)0);
#line 131 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *new_media_message  =    (char *)((void *)0);
#line 134 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *new_media_message_with_number  =    (char *)((void *)0);
#line 135 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *new_media_message_after_number  =    (char *)((void *)0);
#line 141 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *archive_name  =    (char *)((void *)0);
#line 144 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *rsh_command_option  =    (char *)((void *)0);
#line 164 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char *directory_name  =    (char *)((void *)0);
#line 169 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char name_end  =    (char )'\n';
#line 172 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char input_is_special  =    (char)0;
#line 173 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char output_is_special  =    (char)0;
#line 176 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char input_is_seekable  =    (char)0;
#line 179 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
char output_is_seekable  =    (char)0;
#line 182 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
unsigned int warn_option  =    0U;
#line 185 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
_Bool to_stdout_option  =    (_Bool)0;
#line 195 "/home/wslee/gnu_benchmarks/cpio-2.11/src/global.c"
void (*copy_function)()  =    (void (*)())0;
#line 48 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.h"
void ds_resize(dynamic_string *string , int size ) ;
#line 49
char *ds_fgetname(FILE *f , dynamic_string *s ) ;
#line 51
char *ds_fgetstr(FILE *f , dynamic_string *s , char eos ) ;
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.c"
void ds_init(dynamic_string *string , int size ) 
{ 
  char *tmp ;

  {
  {
#line 40
  string->ds_length = size;
#line 41
  tmp = xmalloc((unsigned int )size);
#line 41
  string->ds_string = tmp;
  }
#line 42
  return;
}
}
#line 46 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.c"
void ds_resize(dynamic_string *string , int size ) 
{ 
  char *tmp ;

  {
#line 49
  if (size > string->ds_length) {
    {
#line 51
    string->ds_length = size;
#line 52
    tmp = xrealloc(string->ds_string, (unsigned int )size);
#line 52
    string->ds_string = tmp;
    }
  }
#line 54
  return;
}
}
#line 63 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.c"
char *ds_fgetstr(FILE *f , dynamic_string *s , char eos ) 
{ 
  int insize ;
  int strsize ;
  int next_ch ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 71
  insize = 0;
#line 72
  strsize = s->ds_length;
#line 75
  next_ch = _IO_getc(f);
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (next_ch != (int )eos) {
#line 76
      if (! (next_ch != -1)) {
#line 76
        goto while_break;
      }
    } else {
#line 76
      goto while_break;
    }
#line 78
    if (insize >= strsize - 1) {
      {
#line 80
      ds_resize(s, strsize * 2 + 2);
#line 81
      strsize = s->ds_length;
      }
    }
    {
#line 83
    tmp = insize;
#line 83
    insize ++;
#line 83
    *(s->ds_string + tmp) = (char )next_ch;
#line 84
    next_ch = _IO_getc(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  tmp___0 = insize;
#line 86
  insize ++;
#line 86
  *(s->ds_string + tmp___0) = (char )'\000';
#line 88
  if (insize == 1) {
#line 88
    if (next_ch == -1) {
#line 89
      return ((char *)((void *)0));
    } else {
#line 91
      return (s->ds_string);
    }
  } else {
#line 91
    return (s->ds_string);
  }
}
}
#line 94 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.c"
char *ds_fgets(FILE *f , dynamic_string *s ) 
{ 
  char *tmp ;

  {
  {
#line 97
  tmp = ds_fgetstr(f, s, (char )'\n');
  }
#line 97
  return (tmp);
}
}
#line 100 "/home/wslee/gnu_benchmarks/cpio-2.11/src/dstring.c"
char *ds_fgetname(FILE *f , dynamic_string *s ) 
{ 
  char *tmp ;

  {
  {
#line 103
  tmp = ds_fgetstr(f, s, (char )'\000');
  }
#line 103
  return (tmp);
}
}
#line 26 "/home/wslee/gnu_benchmarks/cpio-2.11/src/defer.h"
struct deferment *create_deferment(struct cpio_file_stat *file_hdr ) ;
#line 27
void free_deferment(struct deferment *d ) ;
#line 28 "/home/wslee/gnu_benchmarks/cpio-2.11/src/defer.c"
struct deferment *create_deferment(struct cpio_file_stat *file_hdr ) 
{ 
  struct deferment *d ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 32
  tmp = xmalloc(sizeof(struct deferment ));
#line 32
  d = (struct deferment *)tmp;
#line 33
  d->header = *file_hdr;
#line 34
  tmp___0 = strlen((char const   *)file_hdr->c_name);
#line 34
  tmp___1 = xmalloc(tmp___0 + 1UL);
#line 34
  d->header.c_name = (char *)tmp___1;
#line 35
  strcpy((char */* __restrict  */)d->header.c_name, (char const   */* __restrict  */)file_hdr->c_name);
  }
#line 36
  return (d);
}
}
#line 39 "/home/wslee/gnu_benchmarks/cpio-2.11/src/defer.c"
void free_deferment(struct deferment *d ) 
{ 


  {
  {
#line 42
  free((void *)d->header.c_name);
#line 43
  free((void *)d);
  }
#line 44
  return;
}
}
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                  __mode_t __mode ,
                                                                                  __dev_t __dev ) ;
#line 479 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) lchown)(char const   *__file ,
                                                                                   __uid_t __owner ,
                                                                                   __gid_t __group ) ;
#line 806
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 819
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 851
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 121 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int link_to_maj_min_ino(char *file_name___0 , int st_dev_maj , int st_dev_min , ino_t st_ino ) ;
#line 123
int link_to_name(char *link_name , char *link_target ) ;
#line 37 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copypass.c"
static void set_copypass_perms(int fd , char const   *name , struct stat *st ) 
{ 
  struct cpio_file_stat header ;
  void *__cil_tmp5 ;

  {
  {
#line 41
  header.c_name = (char *)name;
#line 42
  stat_to_cpio(& header, st);
#line 43
  set_perms(fd, & header);
  }
#line 44
  return;
}
}
#line 49 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copypass.c"
void process_copy_pass(void) 
{ 
  dynamic_string input_name ;
  dynamic_string output_name ;
  int dirname_len ;
  int res ;
  char *slash ;
  struct stat in_file_stat ;
  struct stat out_file_stat ;
  int in_file_des ;
  int out_file_des ;
  int existing_dir ;
  size_t tmp ;
  int link_res ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  struct cpio_file_stat file_stat ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  char *link_name ;
  int link_size ;
  void *tmp___16 ;
  ssize_t tmp___17 ;
  uid_t uid ;
  uid_t tmp___18 ;
  gid_t gid ;
  gid_t tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t blocks ;
  char *tmp___24 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 67
  newdir_umask = umask((__mode_t )0);
#line 71
  tmp = strlen((char const   *)directory_name);
#line 71
  dirname_len = (int )tmp;
#line 72
  ds_init(& input_name, 128);
#line 73
  ds_init(& output_name, dirname_len + 2);
#line 74
  strcpy((char */* __restrict  */)output_name.ds_string, (char const   */* __restrict  */)directory_name);
#line 75
  *(output_name.ds_string + dirname_len) = (char )'/';
#line 76
  output_is_seekable = (char)1;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___23 = ds_fgetstr(stdin, & input_name, name_end);
    }
#line 79
    if (! ((unsigned long )tmp___23 != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
#line 81
    link_res = -1;
#line 84
    if ((int )*(input_name.ds_string + 0) == 0) {
      {
#line 86
      tmp___0 = gettext("blank line ignored");
#line 86
      error(0, 0, (char const   *)tmp___0);
      }
#line 87
      goto while_continue;
    }
#line 91
    if ((int )*(input_name.ds_string + 0) == 46) {
#line 91
      if ((int )*(input_name.ds_string + 1) == 0) {
#line 95
        goto while_continue;
      } else
#line 91
      if ((int )*(input_name.ds_string + 1) == 47) {
#line 91
        if ((int )*(input_name.ds_string + 2) == 0) {
#line 95
          goto while_continue;
        }
      }
    }
    {
#line 97
    tmp___1 = (*xstat)(input_name.ds_string, & in_file_stat);
    }
#line 97
    if (tmp___1 < 0) {
      {
#line 99
      stat_error((char const   *)input_name.ds_string);
      }
#line 100
      goto while_continue;
    }
#line 104
    slash = input_name.ds_string;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! ((int )*slash == 47)) {
#line 104
        goto while_break___0;
      }
#line 104
      slash ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 113
    tmp___2 = strlen((char const   *)slash);
#line 113
    ds_resize(& output_name, (int )(((size_t )dirname_len + tmp___2) + 2UL));
#line 114
    strcpy((char */* __restrict  */)((output_name.ds_string + dirname_len) + 1), (char const   */* __restrict  */)slash);
#line 116
    existing_dir = 0;
#line 117
    tmp___9 = lstat((char const   */* __restrict  */)output_name.ds_string, (struct stat */* __restrict  */)(& out_file_stat));
    }
#line 117
    if (tmp___9 == 0) {
#line 119
      if ((out_file_stat.st_mode & 61440U) == 16384U) {
#line 119
        if ((in_file_stat.st_mode & 61440U) == 16384U) {
#line 124
          existing_dir = 1;
        } else {
#line 119
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 126
      if (! unconditional_flag) {
#line 126
        if (in_file_stat.st_mtim.tv_sec <= out_file_stat.st_mtim.tv_sec) {
          {
#line 129
          tmp___3 = gettext("%s not created: newer or same age version exists");
#line 129
          error(0, 0, (char const   *)tmp___3, output_name.ds_string);
          }
#line 131
          goto while_continue;
        } else {
#line 126
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 133
        if ((out_file_stat.st_mode & 61440U) == 16384U) {
          {
#line 133
          tmp___6 = rmdir((char const   *)output_name.ds_string);
#line 133
          tmp___8 = tmp___6;
          }
        } else {
          {
#line 133
          tmp___7 = unlink((char const   *)output_name.ds_string);
#line 133
          tmp___8 = tmp___7;
          }
        }
#line 133
        if (tmp___8) {
          {
#line 137
          tmp___4 = gettext("cannot remove current %s");
#line 137
          tmp___5 = __errno_location();
#line 137
          error(0, *tmp___5, (char const   *)tmp___4, output_name.ds_string);
          }
#line 139
          goto while_continue;
        }
      }
    }
#line 144
    if ((in_file_stat.st_mode & 61440U) == 32768U) {
#line 148
      if (link_flag) {
        {
#line 152
        link_res = link_to_name(output_name.ds_string, input_name.ds_string);
        }
      }
#line 154
      if (link_res < 0) {
#line 154
        if (in_file_stat.st_nlink > 1UL) {
          {
#line 155
          tmp___10 = (unsigned int )gnu_dev_minor((unsigned long long )in_file_stat.st_dev);
#line 155
          tmp___11 = (unsigned int )gnu_dev_major((unsigned long long )in_file_stat.st_dev);
#line 155
          link_res = link_to_maj_min_ino(output_name.ds_string, (int )tmp___11, (int )tmp___10,
                                         in_file_stat.st_ino);
          }
        }
      }
#line 161
      if (link_res < 0) {
        {
#line 163
        in_file_des = open((char const   *)input_name.ds_string, 0, 0);
        }
#line 165
        if (in_file_des < 0) {
          {
#line 167
          open_error((char const   *)input_name.ds_string);
          }
#line 168
          goto while_continue;
        }
        {
#line 170
        out_file_des = open((char const   *)output_name.ds_string, 65, 384);
        }
#line 172
        if (out_file_des < 0) {
#line 172
          if (create_dir_flag) {
            {
#line 174
            create_all_directories(output_name.ds_string);
#line 175
            out_file_des = open((char const   *)output_name.ds_string, 65, 384);
            }
          }
        }
#line 178
        if (out_file_des < 0) {
          {
#line 180
          open_error((char const   *)output_name.ds_string);
#line 181
          close(in_file_des);
          }
#line 182
          goto while_continue;
        }
        {
#line 185
        copy_files_disk_to_disk(in_file_des, out_file_des, in_file_stat.st_size, input_name.ds_string);
#line 186
        disk_empty_output_buffer(out_file_des);
        }
#line 190
        if (delayed_seek_count > 0) {
          {
#line 192
          lseek(out_file_des, (__off_t )(delayed_seek_count - 1), 1);
#line 193
          write(out_file_des, (void const   *)"", (size_t )1);
#line 194
          delayed_seek_count = 0;
          }
        }
        {
#line 197
        set_copypass_perms(out_file_des, (char const   *)output_name.ds_string, & in_file_stat);
        }
#line 200
        if (reset_time_flag) {
          {
#line 202
          set_file_times(in_file_des, (char const   *)input_name.ds_string, (unsigned long )in_file_stat.st_atim.tv_sec,
                         (unsigned long )in_file_stat.st_mtim.tv_sec);
#line 206
          set_file_times(out_file_des, (char const   *)output_name.ds_string, (unsigned long )in_file_stat.st_atim.tv_sec,
                         (unsigned long )in_file_stat.st_mtim.tv_sec);
          }
        }
        {
#line 212
        tmp___12 = close(in_file_des);
        }
#line 212
        if (tmp___12 < 0) {
          {
#line 213
          close_error((char const   *)input_name.ds_string);
          }
        }
        {
#line 215
        tmp___13 = close(out_file_des);
        }
#line 215
        if (tmp___13 < 0) {
          {
#line 216
          close_error((char const   *)output_name.ds_string);
          }
        }
        {
#line 218
        warn_if_file_changed(input_name.ds_string, in_file_stat.st_size, in_file_stat.st_mtim.tv_sec);
        }
      }
    } else
#line 222
    if ((in_file_stat.st_mode & 61440U) == 16384U) {
      {
#line 226
      stat_to_cpio(& file_stat, & in_file_stat);
#line 227
      file_stat.c_name = output_name.ds_string;
#line 228
      cpio_create_dir(& file_stat, existing_dir);
      }
    } else
#line 230
    if ((in_file_stat.st_mode & 61440U) == 8192U) {
#line 230
      goto _L___1;
    } else
#line 230
    if ((in_file_stat.st_mode & 61440U) == 24576U) {
#line 230
      goto _L___1;
    } else
#line 230
    if ((in_file_stat.st_mode & 61440U) == 4096U) {
#line 230
      goto _L___1;
    } else
#line 230
    if ((in_file_stat.st_mode & 61440U) == 49152U) {
#line 230
      goto _L___1;
    } else
#line 230
    if (0) {
      _L___1: /* CIL Label */ 
#line 242
      if (link_flag) {
        {
#line 244
        link_res = link_to_name(output_name.ds_string, input_name.ds_string);
        }
      }
#line 246
      if (link_res < 0) {
#line 246
        if (in_file_stat.st_nlink > 1UL) {
          {
#line 247
          tmp___14 = (unsigned int )gnu_dev_minor((unsigned long long )in_file_stat.st_dev);
#line 247
          tmp___15 = (unsigned int )gnu_dev_major((unsigned long long )in_file_stat.st_dev);
#line 247
          link_res = link_to_maj_min_ino(output_name.ds_string, (int )tmp___15, (int )tmp___14,
                                         in_file_stat.st_ino);
          }
        }
      }
#line 252
      if (link_res < 0) {
        {
#line 254
        res = mknod((char const   *)output_name.ds_string, in_file_stat.st_mode, in_file_stat.st_rdev);
        }
#line 256
        if (res < 0) {
#line 256
          if (create_dir_flag) {
            {
#line 258
            create_all_directories(output_name.ds_string);
#line 259
            res = mknod((char const   *)output_name.ds_string, in_file_stat.st_mode,
                        in_file_stat.st_rdev);
            }
          }
        }
#line 262
        if (res < 0) {
          {
#line 264
          mknod_error((char const   *)output_name.ds_string);
          }
#line 265
          goto while_continue;
        }
        {
#line 267
        set_copypass_perms(-1, (char const   *)output_name.ds_string, & in_file_stat);
        }
      }
    } else
#line 272
    if ((in_file_stat.st_mode & 61440U) == 40960U) {
      {
#line 276
      tmp___16 = xmalloc((size_t )((unsigned int )in_file_stat.st_size + 1U));
#line 276
      link_name = (char *)tmp___16;
#line 278
      tmp___17 = (ssize_t )readlink((char const   */* __restrict  */)input_name.ds_string,
                                    (char */* __restrict  */)link_name, (size_t )in_file_stat.st_size);
#line 278
      link_size = (int )tmp___17;
      }
#line 280
      if (link_size < 0) {
        {
#line 282
        readlink_error((char const   *)input_name.ds_string);
#line 283
        free((void *)link_name);
        }
#line 284
        goto while_continue;
      }
      {
#line 286
      *(link_name + link_size) = (char )'\000';
#line 288
      res = symlink((char const   *)link_name, (char const   *)output_name.ds_string);
      }
#line 290
      if (res < 0) {
#line 290
        if (create_dir_flag) {
          {
#line 292
          create_all_directories(output_name.ds_string);
#line 293
          res = symlink((char const   *)link_name, (char const   *)output_name.ds_string);
          }
        }
      }
#line 296
      if (res < 0) {
        {
#line 298
        symlink_error((char const   *)output_name.ds_string, (char const   *)link_name);
#line 299
        free((void *)link_name);
        }
#line 300
        goto while_continue;
      }
#line 304
      if (! no_chown_flag) {
#line 306
        if (set_owner_flag) {
#line 306
          tmp___18 = set_owner;
        } else {
#line 306
          tmp___18 = in_file_stat.st_uid;
        }
#line 306
        uid = tmp___18;
#line 307
        if (set_group_flag) {
#line 307
          tmp___19 = set_group;
        } else {
#line 307
          tmp___19 = in_file_stat.st_gid;
        }
        {
#line 307
        gid = tmp___19;
#line 308
        tmp___20 = lchown((char const   *)output_name.ds_string, uid, gid);
        }
#line 308
        if (tmp___20 < 0) {
          {
#line 308
          tmp___21 = __errno_location();
          }
#line 308
          if (*tmp___21 != 1) {
            {
#line 310
            chown_error_details((char const   *)output_name.ds_string, uid, gid);
            }
          }
        }
      }
      {
#line 312
      free((void *)link_name);
      }
    } else {
      {
#line 317
      tmp___22 = gettext("%s: unknown file type");
#line 317
      error(0, 0, (char const   *)tmp___22, input_name.ds_string);
      }
    }
#line 320
    if (verbose_flag) {
      {
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              output_name.ds_string);
      }
    }
#line 322
    if (dot_flag) {
      {
#line 323
      fputc_unlocked('.', stderr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (dot_flag) {
    {
#line 327
    fputc_unlocked('\n', stderr);
    }
  }
  {
#line 329
  apply_delayed_set_stat();
  }
#line 331
  if (! quiet_flag) {
    {
#line 333
    blocks = (size_t )(((output_bytes + (off_t )io_block_size) - 1L) / (off_t )io_block_size);
#line 334
    tmp___24 = ngettext("%lu block\n", "%lu blocks\n", blocks);
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
            blocks);
    }
  }
#line 339
  return;
}
}
#line 349 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copypass.c"
int link_to_maj_min_ino(char *file_name___0 , int st_dev_maj , int st_dev_min , ino_t st_ino ) 
{ 
  int link_res ;
  char *link_name ;

  {
  {
#line 355
  link_res = -1;
#line 357
  link_name = find_inode_file(st_ino, (unsigned long )st_dev_maj, (unsigned long )st_dev_min);
  }
#line 360
  if ((unsigned long )link_name == (unsigned long )((void *)0)) {
    {
#line 361
    add_inode(st_ino, file_name___0, (unsigned long )st_dev_maj, (unsigned long )st_dev_min);
    }
  } else {
    {
#line 365
    link_res = link_to_name(file_name___0, link_name);
    }
  }
#line 366
  return (link_res);
}
}
#line 377 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copypass.c"
int link_to_name(char *link_name , char *link_target ) 
{ 
  int res ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 380
  tmp = link((char const   *)link_target, (char const   *)link_name);
#line 380
  res = tmp;
  }
#line 381
  if (res < 0) {
#line 381
    if (create_dir_flag) {
      {
#line 383
      create_all_directories(link_name);
#line 384
      res = link((char const   *)link_target, (char const   *)link_name);
      }
    }
  }
#line 386
  if (res == 0) {
#line 388
    if (verbose_flag) {
      {
#line 389
      tmp___0 = gettext("%s linked to %s");
#line 389
      error(0, 0, (char const   *)tmp___0, link_target, link_name);
      }
    }
  } else
#line 392
  if (link_flag) {
    {
#line 394
    tmp___1 = gettext("cannot link %s to %s");
#line 394
    tmp___2 = __errno_location();
#line 394
    error(0, *tmp___2, (char const   *)tmp___1, link_target, link_name);
    }
  }
#line 397
  return (res);
}
}
#line 116 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
int write_out_header(struct cpio_file_stat *file_hdr , int out_des ) ;
#line 36 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static unsigned long read_for_checksum(int in_file_des , int file_size , char *file_name___0 ) 
{ 
  unsigned long crc___0 ;
  char buf[8192] ;
  int bytes_left ;
  int bytes_read ;
  int i ;
  ssize_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  __off_t tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 45
  crc___0 = 0UL;
#line 47
  bytes_left = file_size;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (bytes_left > 0)) {
#line 47
      goto while_break;
    }
    {
#line 49
    tmp = (ssize_t )read(in_file_des, (void *)(buf), (size_t )8192);
#line 49
    bytes_read = (int )tmp;
    }
#line 50
    if (bytes_read < 0) {
      {
#line 51
      tmp___0 = gettext("cannot read checksum for %s");
#line 51
      tmp___1 = __errno_location();
#line 51
      error(1, *tmp___1, (char const   *)tmp___0, file_name___0);
      }
    }
#line 52
    if (bytes_read == 0) {
#line 53
      goto while_break;
    }
#line 54
    if (bytes_left < bytes_read) {
#line 55
      bytes_read = bytes_left;
    }
#line 56
    i = 0;
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 56
      if (! (i < bytes_read)) {
#line 56
        goto while_break___0;
      }
#line 57
      crc___0 += (unsigned long )((int )buf[i] & 255);
#line 56
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    bytes_left -= bytes_read;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___4 = lseek(in_file_des, 0L, 0);
  }
#line 59
  if (tmp___4) {
    {
#line 60
    tmp___2 = gettext("cannot read checksum for %s");
#line 60
    tmp___3 = __errno_location();
#line 60
    error(1, *tmp___3, (char const   *)tmp___2, file_name___0);
    }
  }
#line 62
  return (crc___0);
}
}
#line 68 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void tape_clear_rest_of_block(int out_file_des ) 
{ 


  {
  {
#line 71
  write_nuls_to_file((off_t )((size_t )io_block_size - output_size), out_file_des,
                     & tape_buffered_write);
  }
#line 73
  return;
}
}
#line 78 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void tape_pad_output(int out_file_des , int offset ) 
{ 
  size_t pad ;

  {
#line 83
  if ((unsigned int )archive_format == 3U) {
#line 84
    pad = (size_t )((4 - offset % 4) % 4);
  } else
#line 83
  if ((unsigned int )archive_format == 4U) {
#line 84
    pad = (size_t )((4 - offset % 4) % 4);
  } else
#line 85
  if ((unsigned int )archive_format == 5U) {
#line 86
    pad = (size_t )((512 - offset % 512) % 512);
  } else
#line 85
  if ((unsigned int )archive_format == 6U) {
#line 86
    pad = (size_t )((512 - offset % 512) % 512);
  } else
#line 87
  if ((unsigned int )archive_format != 2U) {
#line 87
    if ((unsigned int )archive_format != 7U) {
#line 88
      pad = (size_t )((2 - offset % 2) % 2);
    } else {
#line 90
      pad = (size_t )0;
    }
  } else {
#line 90
    pad = (size_t )0;
  }
#line 92
  if (pad != 0UL) {
    {
#line 93
    write_nuls_to_file((off_t )pad, out_file_des, & tape_buffered_write);
    }
  }
#line 94
  return;
}
}
#line 104 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
struct deferment *deferouts  =    (struct deferment *)((void *)0);
#line 109 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static int count_defered_links_to_dev_ino(struct cpio_file_stat *file_hdr ) 
{ 
  struct deferment *d ;
  ino_t ino ;
  int maj ;
  int min ;
  int count ;

  {
#line 117
  ino = file_hdr->c_ino;
#line 118
  maj = (int )file_hdr->c_dev_maj;
#line 119
  min = (int )file_hdr->c_dev_min;
#line 120
  count = 0;
#line 121
  d = deferouts;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 121
      goto while_break;
    }
#line 123
    if (d->header.c_ino == ino) {
#line 123
      if (d->header.c_dev_maj == (long )maj) {
#line 123
        if (d->header.c_dev_min == (long )min) {
#line 125
          count ++;
        }
      }
    }
#line 121
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (count);
}
}
#line 133 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static int last_link(struct cpio_file_stat *file_hdr ) 
{ 
  int other_files_sofar ;

  {
  {
#line 138
  other_files_sofar = count_defered_links_to_dev_ino(file_hdr);
  }
#line 139
  if (file_hdr->c_nlink == (size_t )(other_files_sofar + 1)) {
#line 141
    return (1);
  }
#line 143
  return (0);
}
}
#line 150 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void add_link_defer(struct cpio_file_stat *file_hdr ) 
{ 
  struct deferment *d ;

  {
  {
#line 154
  d = create_deferment(file_hdr);
#line 155
  d->next = deferouts;
#line 156
  deferouts = d;
  }
#line 157
  return;
}
}
#line 165 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void writeout_other_defers(struct cpio_file_stat *file_hdr , int out_des ) 
{ 
  struct deferment *d ;
  struct deferment *d_prev ;
  ino_t ino ;
  int maj ;
  int min ;
  struct deferment *d_free ;

  {
#line 173
  ino = file_hdr->c_ino;
#line 174
  maj = (int )file_hdr->c_dev_maj;
#line 175
  min = (int )file_hdr->c_dev_min;
#line 176
  d_prev = (struct deferment *)((void *)0);
#line 177
  d = deferouts;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 178
      goto while_break;
    }
#line 180
    if (d->header.c_ino == ino) {
#line 180
      if (d->header.c_dev_maj == (long )maj) {
#line 180
        if (d->header.c_dev_min == (long )min) {
          {
#line 184
          d->header.c_filesize = (off_t )0;
#line 185
          write_out_header(& d->header, out_des);
          }
#line 186
          if ((unsigned long )d_prev != (unsigned long )((void *)0)) {
#line 187
            d_prev->next = d->next;
          } else {
#line 189
            deferouts = d->next;
          }
          {
#line 190
          d_free = d;
#line 191
          d = d->next;
#line 192
          free_deferment(d_free);
          }
        } else {
#line 196
          d_prev = d;
#line 197
          d = d->next;
        }
      } else {
#line 196
        d_prev = d;
#line 197
        d = d->next;
      }
    } else {
#line 196
      d_prev = d;
#line 197
      d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 207 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void writeout_defered_file(struct cpio_file_stat *header , int out_file_des ) 
{ 
  int in_file_des ;
  struct cpio_file_stat file_hdr ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 213
  file_hdr = *header;
#line 216
  in_file_des = open((char const   *)header->c_name, 0, 0);
  }
#line 218
  if (in_file_des < 0) {
    {
#line 220
    open_error((char const   *)header->c_name);
    }
#line 221
    return;
  }
#line 224
  if ((unsigned int )archive_format == 4U) {
    {
#line 225
    file_hdr.c_chksum = read_for_checksum(in_file_des, (int )file_hdr.c_filesize,
                                          header->c_name);
    }
  }
  {
#line 229
  tmp = write_out_header(& file_hdr, out_file_des);
  }
#line 229
  if (tmp) {
#line 230
    return;
  }
  {
#line 231
  copy_files_disk_to_tape(in_file_des, out_file_des, file_hdr.c_filesize, header->c_name);
#line 233
  warn_if_file_changed(header->c_name, file_hdr.c_filesize, file_hdr.c_mtime);
  }
#line 235
  if ((unsigned int )archive_format == 5U) {
    {
#line 236
    add_inode(file_hdr.c_ino, file_hdr.c_name, (unsigned long )file_hdr.c_dev_maj,
              (unsigned long )file_hdr.c_dev_min);
    }
  } else
#line 235
  if ((unsigned int )archive_format == 6U) {
    {
#line 236
    add_inode(file_hdr.c_ino, file_hdr.c_name, (unsigned long )file_hdr.c_dev_maj,
              (unsigned long )file_hdr.c_dev_min);
    }
  }
  {
#line 239
  tape_pad_output(out_file_des, (int )file_hdr.c_filesize);
  }
#line 241
  if (reset_time_flag) {
    {
#line 242
    set_file_times(in_file_des, (char const   *)file_hdr.c_name, (unsigned long )file_hdr.c_mtime,
                   (unsigned long )file_hdr.c_mtime);
    }
  }
  {
#line 244
  tmp___0 = close(in_file_des);
  }
#line 244
  if (tmp___0 < 0) {
    {
#line 245
    close_error((char const   *)header->c_name);
    }
  }
#line 246
  return;
}
}
#line 254 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void writeout_final_defers(int out_des ) 
{ 
  struct deferment *d ;
  int other_count ;
  struct cpio_file_stat file_hdr ;
  void *__cil_tmp5 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )deferouts != (unsigned long )((void *)0))) {
#line 259
      goto while_break;
    }
    {
#line 261
    d = deferouts;
#line 262
    other_count = count_defered_links_to_dev_ino(& d->header);
    }
#line 263
    if (other_count == 1) {
      {
#line 265
      writeout_defered_file(& d->header, out_des);
      }
    } else {
      {
#line 270
      file_hdr = d->header;
#line 271
      file_hdr.c_filesize = (off_t )0;
#line 272
      write_out_header(& file_hdr, out_des);
      }
    }
#line 274
    deferouts = deferouts->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return;
}
}
#line 284
int to_ascii(char *where , uintmax_t v , size_t digits , unsigned int logbase ) ;
#line 284 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static char codetab[17]  = 
#line 284
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'\000'};
#line 281 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int to_ascii(char *where , uintmax_t v , size_t digits , unsigned int logbase ) 
{ 
  int i ;

  {
#line 285
  i = (int )digits;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    i --;
#line 289
    *(where + i) = codetab[v & (unsigned long )((1 << logbase) - 1)];
#line 290
    v >>= logbase;
#line 287
    if (! i) {
#line 287
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (v != 0UL);
}
}
#line 297 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void field_width_error(char const   *filename , char const   *fieldname ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 300
  tmp = gettext("%s: field width not sufficient for storing %s");
#line 300
  error(0, 0, (char const   *)tmp, filename, fieldname);
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void field_width_warning(char const   *filename , char const   *fieldname ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 307
  if (warn_option & 1U) {
    {
#line 308
    tmp = gettext("%s: truncating %s");
#line 308
    error(0, 0, (char const   *)tmp, filename, fieldname);
    }
  }
#line 309
  return;
}
}
#line 311 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
void to_ascii_or_warn(char *where , uintmax_t n , size_t digits , unsigned int logbase ,
                      char const   *filename , char const   *fieldname ) 
{ 
  int tmp ;

  {
  {
#line 316
  tmp = to_ascii(where, n, digits, logbase);
  }
#line 316
  if (tmp) {
    {
#line 317
    field_width_warning(filename, fieldname);
    }
  }
#line 318
  return;
}
}
#line 320 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int to_ascii_or_error(char *where , uintmax_t n , size_t digits , unsigned int logbase ,
                      char const   *filename , char const   *fieldname ) 
{ 
  int tmp ;

  {
  {
#line 325
  tmp = to_ascii(where, n, digits, logbase);
  }
#line 325
  if (tmp) {
    {
#line 327
    field_width_error(filename, fieldname);
    }
#line 328
    return (1);
  }
#line 330
  return (0);
}
}
#line 334 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int write_out_new_ascii_header(char const   *magic_string , struct cpio_file_stat *file_hdr ,
                               int out_des ) 
{ 
  char ascii_header[110] ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 341
  p = (char *)stpcpy((char */* __restrict  */)(ascii_header), (char const   */* __restrict  */)magic_string);
#line 342
  tmp = gettext("inode number");
#line 342
  to_ascii_or_warn(p, file_hdr->c_ino, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp);
#line 344
  p += 8;
#line 345
  tmp___0 = gettext("file mode");
#line 345
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_mode, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___0);
#line 347
  p += 8;
#line 348
  tmp___1 = gettext("uid");
#line 348
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_uid, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___1);
#line 350
  p += 8;
#line 351
  tmp___2 = gettext("gid");
#line 351
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_gid, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___2);
#line 353
  p += 8;
#line 354
  tmp___3 = gettext("number of links");
#line 354
  to_ascii_or_warn(p, file_hdr->c_nlink, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___3);
#line 356
  p += 8;
#line 357
  tmp___4 = gettext("modification time");
#line 357
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_mtime, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___4);
#line 359
  p += 8;
#line 360
  tmp___5 = gettext("file size");
#line 360
  tmp___6 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_filesize, (size_t )8, 4U,
                              (char const   *)file_hdr->c_name, (char const   *)tmp___5);
  }
#line 360
  if (tmp___6) {
#line 362
    return (1);
  }
  {
#line 363
  p += 8;
#line 364
  tmp___7 = gettext("device major number");
#line 364
  tmp___8 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_dev_maj, (size_t )8, 4U,
                              (char const   *)file_hdr->c_name, (char const   *)tmp___7);
  }
#line 364
  if (tmp___8) {
#line 366
    return (1);
  }
  {
#line 367
  p += 8;
#line 368
  tmp___9 = gettext("device minor number");
#line 368
  tmp___10 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_dev_min, (size_t )8, 4U,
                               (char const   *)file_hdr->c_name, (char const   *)tmp___9);
  }
#line 368
  if (tmp___10) {
#line 370
    return (1);
  }
  {
#line 371
  p += 8;
#line 372
  tmp___11 = gettext("rdev major");
#line 372
  tmp___12 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_rdev_maj, (size_t )8, 4U,
                               (char const   *)file_hdr->c_name, (char const   *)tmp___11);
  }
#line 372
  if (tmp___12) {
#line 374
    return (1);
  }
  {
#line 375
  p += 8;
#line 376
  tmp___13 = gettext("rdev minor");
#line 376
  tmp___14 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_rdev_min, (size_t )8, 4U,
                               (char const   *)file_hdr->c_name, (char const   *)tmp___13);
  }
#line 376
  if (tmp___14) {
#line 378
    return (1);
  }
  {
#line 379
  p += 8;
#line 380
  tmp___15 = gettext("name size");
#line 380
  tmp___16 = to_ascii_or_error(p, file_hdr->c_namesize, (size_t )8, 4U, (char const   *)file_hdr->c_name,
                               (char const   *)tmp___15);
  }
#line 380
  if (tmp___16) {
#line 382
    return (1);
  }
  {
#line 383
  p += 8;
#line 384
  to_ascii(p, file_hdr->c_chksum & 4294967295UL, (size_t )8, 4U);
#line 386
  tape_buffered_write(ascii_header, out_des, (off_t )sizeof(ascii_header));
#line 389
  tape_buffered_write(file_hdr->c_name, out_des, (long )file_hdr->c_namesize);
#line 390
  tape_pad_output(out_des, (int )(file_hdr->c_namesize + sizeof(ascii_header)));
  }
#line 391
  return (0);
}
}
#line 394 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int write_out_old_ascii_header(dev_t dev , dev_t rdev , struct cpio_file_stat *file_hdr ,
                               int out_des ) 
{ 
  char ascii_header[76] ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 399
  p = ascii_header;
#line 401
  to_ascii(p, (uintmax_t )file_hdr->c_magic, (size_t )6, 3U);
#line 402
  p += 6;
#line 403
  tmp = gettext("device number");
#line 403
  to_ascii_or_warn(p, dev, (size_t )6, 3U, (char const   *)file_hdr->c_name, (char const   *)tmp);
#line 404
  p += 6;
#line 405
  tmp___0 = gettext("inode number");
#line 405
  to_ascii_or_warn(p, file_hdr->c_ino, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___0);
#line 407
  p += 6;
#line 408
  tmp___1 = gettext("file mode");
#line 408
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_mode, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___1);
#line 410
  p += 6;
#line 411
  tmp___2 = gettext("uid");
#line 411
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_uid, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___2);
#line 412
  p += 6;
#line 413
  tmp___3 = gettext("gid");
#line 413
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_gid, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___3);
#line 414
  p += 6;
#line 415
  tmp___4 = gettext("number of links");
#line 415
  to_ascii_or_warn(p, file_hdr->c_nlink, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___4);
#line 417
  p += 6;
#line 418
  tmp___5 = gettext("rdev");
#line 418
  to_ascii_or_warn(p, rdev, (size_t )6, 3U, (char const   *)file_hdr->c_name, (char const   *)tmp___5);
#line 419
  p += 6;
#line 420
  tmp___6 = gettext("modification time");
#line 420
  to_ascii_or_warn(p, (uintmax_t )file_hdr->c_mtime, (size_t )11, 3U, (char const   *)file_hdr->c_name,
                   (char const   *)tmp___6);
#line 422
  p += 11;
#line 423
  tmp___7 = gettext("name size");
#line 423
  tmp___8 = to_ascii_or_error(p, file_hdr->c_namesize, (size_t )6, 3U, (char const   *)file_hdr->c_name,
                              (char const   *)tmp___7);
  }
#line 423
  if (tmp___8) {
#line 425
    return (1);
  }
  {
#line 426
  p += 6;
#line 427
  tmp___9 = gettext("file size");
#line 427
  tmp___10 = to_ascii_or_error(p, (uintmax_t )file_hdr->c_filesize, (size_t )11, 3U,
                               (char const   *)file_hdr->c_name, (char const   *)tmp___9);
  }
#line 427
  if (tmp___10) {
#line 429
    return (1);
  }
  {
#line 431
  tape_buffered_write(ascii_header, out_des, (off_t )sizeof(ascii_header));
#line 434
  tape_buffered_write(file_hdr->c_name, out_des, (off_t )file_hdr->c_namesize);
  }
#line 435
  return (0);
}
}
#line 438 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
void hp_compute_dev(struct cpio_file_stat *file_hdr , dev_t *pdev , dev_t *prdev ) 
{ 
  unsigned long long tmp ;
  dev_t tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;
  unsigned long long tmp___3 ;

  {
  {
#line 452
  if ((file_hdr->c_mode & 61440U) == 4096U) {
#line 452
    goto case_4096;
  }
#line 452
  if ((file_hdr->c_mode & 61440U) == 49152U) {
#line 452
    goto case_4096;
  }
#line 452
  if ((file_hdr->c_mode & 61440U) == 24576U) {
#line 452
    goto case_4096;
  }
#line 452
  if ((file_hdr->c_mode & 61440U) == 8192U) {
#line 452
    goto case_4096;
  }
#line 459
  goto switch_default;
  case_4096: /* CIL Label */ 
  case_49152: /* CIL Label */ 
  case_24576: /* CIL Label */ 
  case_8192: /* CIL Label */ 
  {
#line 454
  tmp = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                             (unsigned int )file_hdr->c_rdev_min);
#line 454
  file_hdr->c_filesize = (off_t )tmp;
#line 456
  tmp___1 = (unsigned long long )gnu_dev_makedev(0U, 1U);
#line 456
  tmp___0 = (dev_t )tmp___1;
#line 456
  *prdev = tmp___0;
#line 456
  *pdev = tmp___0;
  }
#line 457
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 460
  tmp___2 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_dev_maj,
                                                 (unsigned int )file_hdr->c_dev_min);
#line 460
  *pdev = (dev_t )tmp___2;
#line 461
  tmp___3 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                                 (unsigned int )file_hdr->c_rdev_min);
#line 461
  *prdev = (dev_t )tmp___3;
  }
#line 462
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 466 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int write_out_binary_header(dev_t rdev , struct cpio_file_stat *file_hdr , int out_des ) 
{ 
  struct old_cpio_header short_hdr ;
  unsigned long long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 472
  short_hdr.c_magic = (unsigned short)29127;
#line 473
  tmp = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_dev_maj, (unsigned int )file_hdr->c_dev_min);
#line 473
  short_hdr.c_dev = (unsigned short )tmp;
  }
#line 475
  if (warn_option & 1U) {
#line 475
    if (file_hdr->c_ino >> 16 != 0UL) {
      {
#line 476
      tmp___0 = gettext("%s: truncating inode number");
#line 476
      error(0, 0, (char const   *)tmp___0, file_hdr->c_name);
      }
    }
  }
#line 478
  short_hdr.c_ino = (unsigned short )(file_hdr->c_ino & 65535UL);
#line 479
  if ((ino_t )short_hdr.c_ino != file_hdr->c_ino) {
    {
#line 480
    tmp___1 = gettext("inode number");
#line 480
    field_width_warning((char const   *)file_hdr->c_name, (char const   *)tmp___1);
    }
  }
#line 482
  short_hdr.c_mode = (unsigned short )(file_hdr->c_mode & 65535U);
#line 483
  if ((mode_t )short_hdr.c_mode != file_hdr->c_mode) {
    {
#line 484
    tmp___2 = gettext("file mode");
#line 484
    field_width_warning((char const   *)file_hdr->c_name, (char const   *)tmp___2);
    }
  }
#line 486
  short_hdr.c_uid = (unsigned short )(file_hdr->c_uid & 65535U);
#line 487
  if ((uid_t )short_hdr.c_uid != file_hdr->c_uid) {
    {
#line 488
    tmp___3 = gettext("uid");
#line 488
    field_width_warning((char const   *)file_hdr->c_name, (char const   *)tmp___3);
    }
  }
#line 490
  short_hdr.c_gid = (unsigned short )(file_hdr->c_gid & 65535U);
#line 491
  if ((gid_t )short_hdr.c_gid != file_hdr->c_gid) {
    {
#line 492
    tmp___4 = gettext("gid");
#line 492
    field_width_warning((char const   *)file_hdr->c_name, (char const   *)tmp___4);
    }
  }
#line 494
  short_hdr.c_nlink = (unsigned short )(file_hdr->c_nlink & 65535UL);
#line 495
  if ((size_t )short_hdr.c_nlink != file_hdr->c_nlink) {
    {
#line 496
    tmp___5 = gettext("number of links");
#line 496
    field_width_warning((char const   *)file_hdr->c_name, (char const   *)tmp___5);
    }
  }
#line 498
  short_hdr.c_rdev = (unsigned short )rdev;
#line 499
  short_hdr.c_mtimes[0] = (unsigned short )(file_hdr->c_mtime >> 16);
#line 500
  short_hdr.c_mtimes[1] = (unsigned short )(file_hdr->c_mtime & 65535L);
#line 502
  short_hdr.c_namesize = (unsigned short )(file_hdr->c_namesize & 65535UL);
#line 503
  if ((size_t )short_hdr.c_namesize != file_hdr->c_namesize) {
    {
#line 505
    tmp___6 = gettext("name size");
#line 505
    field_width_error((char const   *)file_hdr->c_name, (char const   *)tmp___6);
    }
#line 506
    return (1);
  }
#line 509
  short_hdr.c_filesizes[0] = (unsigned short )(file_hdr->c_filesize >> 16);
#line 510
  short_hdr.c_filesizes[1] = (unsigned short )(file_hdr->c_filesize & 65535L);
#line 512
  if (((off_t )short_hdr.c_filesizes[0] << 16) + (off_t )short_hdr.c_filesizes[1] != file_hdr->c_filesize) {
    {
#line 515
    tmp___7 = gettext("file size");
#line 515
    field_width_error((char const   *)file_hdr->c_name, (char const   *)tmp___7);
    }
#line 516
    return (1);
  }
  {
#line 520
  tape_buffered_write((char *)(& short_hdr), out_des, (off_t )26);
#line 523
  tape_buffered_write(file_hdr->c_name, out_des, (off_t )file_hdr->c_namesize);
#line 525
  tape_pad_output(out_des, (int )(file_hdr->c_namesize + 26UL));
  }
#line 526
  return (0);
}
}
#line 533 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
int write_out_header(struct cpio_file_stat *file_hdr , int out_des ) 
{ 
  dev_t dev ;
  dev_t rdev ;
  int tmp ;
  int tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned long long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 541
  if ((unsigned int )archive_format == 3U) {
#line 541
    goto case_3;
  }
#line 544
  if ((unsigned int )archive_format == 4U) {
#line 544
    goto case_4;
  }
#line 547
  if ((unsigned int )archive_format == 2U) {
#line 547
    goto case_2;
  }
#line 554
  if ((unsigned int )archive_format == 7U) {
#line 554
    goto case_7;
  }
#line 559
  if ((unsigned int )archive_format == 6U) {
#line 559
    goto case_6;
  }
#line 559
  if ((unsigned int )archive_format == 5U) {
#line 559
    goto case_6;
  }
#line 568
  if ((unsigned int )archive_format == 1U) {
#line 568
    goto case_1;
  }
#line 573
  if ((unsigned int )archive_format == 8U) {
#line 573
    goto case_8;
  }
#line 578
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 542
  tmp = write_out_new_ascii_header("070701", file_hdr, out_des);
  }
#line 542
  return (tmp);
  case_4: /* CIL Label */ 
  {
#line 545
  tmp___0 = write_out_new_ascii_header("070702", file_hdr, out_des);
  }
#line 545
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 548
  tmp___1 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                                 (unsigned int )file_hdr->c_rdev_min);
#line 548
  tmp___2 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_dev_maj,
                                                 (unsigned int )file_hdr->c_dev_min);
#line 548
  tmp___3 = write_out_old_ascii_header((dev_t )tmp___2, (dev_t )tmp___1, file_hdr,
                                       out_des);
  }
#line 548
  return (tmp___3);
  case_7: /* CIL Label */ 
  {
#line 555
  hp_compute_dev(file_hdr, & dev, & rdev);
#line 556
  tmp___4 = write_out_old_ascii_header(dev, rdev, file_hdr, out_des);
  }
#line 556
  return (tmp___4);
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 560
  tmp___6 = is_tar_filename_too_long(file_hdr->c_name);
  }
#line 560
  if (tmp___6) {
    {
#line 562
    tmp___5 = gettext("%s: file name too long");
#line 562
    error(0, 0, (char const   *)tmp___5, file_hdr->c_name);
    }
#line 563
    return (1);
  }
  {
#line 565
  write_out_tar_header(file_hdr, out_des);
  }
#line 566
  return (0);
  case_1: /* CIL Label */ 
  {
#line 569
  tmp___7 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                                 (unsigned int )file_hdr->c_rdev_min);
#line 569
  tmp___8 = write_out_binary_header((dev_t )tmp___7, file_hdr, out_des);
  }
#line 569
  return (tmp___8);
  case_8: /* CIL Label */ 
  {
#line 574
  hp_compute_dev(file_hdr, & dev, & rdev);
#line 576
  tmp___9 = write_out_binary_header(rdev, file_hdr, out_des);
  }
#line 576
  return (tmp___9);
  switch_default: /* CIL Label */ 
  {
#line 579
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 583 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
static void assign_string(char **pvar , char *value ) 
{ 
  char *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 586
  tmp = strlen((char const   *)value);
#line 586
  tmp___0 = xrealloc((void *)*pvar, tmp + 1UL);
#line 586
  p = (char *)tmp___0;
#line 587
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)value);
#line 588
  *pvar = p;
  }
#line 589
  return;
}
}
#line 595 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyout.c"
void process_copy_out(void) 
{ 
  dynamic_string input_name ;
  struct stat file_stat ;
  struct cpio_file_stat file_hdr ;
  int in_file_des ;
  int out_file_des ;
  char *orig_file_name ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int len ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *otherfile ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *otherfile___0 ;
  int tmp___12 ;
  int tmp___13 ;
  char *link_name ;
  void *tmp___14 ;
  int link_size ;
  ssize_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  size_t blocks ;
  char *tmp___23 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 603
  orig_file_name = (char *)((void *)0);
#line 606
  ds_init(& input_name, 128);
#line 607
  file_hdr.c_magic = (unsigned short)29127;
#line 610
  out_file_des = archive_des;
  }
#line 611
  if (out_file_des >= 1 << 30) {
#line 613
    output_is_special = (char)1;
#line 614
    output_is_seekable = (char)0;
  } else {
    {
#line 618
    tmp___1 = fstat(out_file_des, & file_stat);
    }
#line 618
    if (tmp___1) {
      {
#line 619
      tmp = gettext("standard output is closed");
#line 619
      tmp___0 = __errno_location();
#line 619
      error(1, *tmp___0, (char const   *)tmp);
      }
    }
#line 620
    if ((file_stat.st_mode & 61440U) == 24576U) {
#line 620
      tmp___2 = 1;
    } else
#line 620
    if ((file_stat.st_mode & 61440U) == 8192U) {
#line 620
      tmp___2 = 1;
    } else {
#line 620
      tmp___2 = 0;
    }
#line 620
    output_is_special = (char )tmp___2;
#line 625
    output_is_seekable = (char )((file_stat.st_mode & 61440U) == 32768U);
  }
#line 628
  if (append_flag) {
    {
#line 630
    process_copy_in();
#line 631
    prepare_append(out_file_des);
    }
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 635
    tmp___22 = ds_fgetstr(stdin, & input_name, name_end);
    }
#line 635
    if (! ((unsigned long )tmp___22 != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
#line 638
    if ((int )*(input_name.ds_string + 0) == 0) {
      {
#line 640
      tmp___3 = gettext("blank line ignored");
#line 640
      error(0, 0, (char const   *)tmp___3);
      }
#line 641
      goto while_continue;
    }
    {
#line 645
    tmp___21 = (*xstat)(input_name.ds_string, & file_stat);
    }
#line 645
    if (tmp___21 < 0) {
      {
#line 646
      stat_error((char const   *)input_name.ds_string);
      }
    } else {
      {
#line 650
      stat_to_cpio(& file_hdr, & file_stat);
      }
#line 652
      if ((unsigned int )archive_format == 5U) {
#line 652
        goto _L;
      } else
#line 652
      if ((unsigned int )archive_format == 6U) {
        _L: /* CIL Label */ 
#line 654
        if (file_hdr.c_mode & 16384U) {
          {
#line 656
          tmp___4 = strlen((char const   *)input_name.ds_string);
#line 656
          len = (int )tmp___4;
          }
#line 658
          if ((int )*(input_name.ds_string + (len - 1)) != 47) {
            {
#line 660
            ds_resize(& input_name, len + 2);
#line 661
            *(input_name.ds_string + len) = (char )'/';
#line 662
            *(input_name.ds_string + (len + 1)) = (char)0;
            }
          }
        }
      }
      {
#line 667
      assign_string(& orig_file_name, input_name.ds_string);
#line 668
      cpio_safer_name_suffix(input_name.ds_string, (_Bool)0, (_Bool )(! no_abs_paths_flag),
                             (_Bool)1);
#line 671
      file_hdr.c_name = input_name.ds_string;
#line 672
      tmp___5 = strlen((char const   *)input_name.ds_string);
#line 672
      file_hdr.c_namesize = tmp___5 + 1UL;
      }
      {
#line 697
      if ((file_hdr.c_mode & 61440U) == 32768U) {
#line 697
        goto case_32768;
      }
#line 759
      if ((file_hdr.c_mode & 61440U) == 16384U) {
#line 759
        goto case_16384;
      }
#line 771
      if ((file_hdr.c_mode & 61440U) == 4096U) {
#line 771
        goto case_4096;
      }
#line 771
      if ((file_hdr.c_mode & 61440U) == 49152U) {
#line 771
        goto case_4096;
      }
#line 771
      if ((file_hdr.c_mode & 61440U) == 24576U) {
#line 771
        goto case_4096;
      }
#line 771
      if ((file_hdr.c_mode & 61440U) == 8192U) {
#line 771
        goto case_4096;
      }
#line 804
      if ((file_hdr.c_mode & 61440U) == 40960U) {
#line 804
        goto case_40960;
      }
#line 849
      goto switch_default;
      case_32768: /* CIL Label */ 
#line 698
      if ((unsigned int )archive_format == 5U) {
#line 698
        goto _L___0;
      } else
#line 698
      if ((unsigned int )archive_format == 6U) {
        _L___0: /* CIL Label */ 
        {
#line 701
        otherfile = find_inode_file(file_hdr.c_ino, (unsigned long )file_hdr.c_dev_maj,
                                    (unsigned long )file_hdr.c_dev_min);
        }
#line 701
        if (otherfile) {
          {
#line 705
          file_hdr.c_tar_linkname = otherfile;
#line 706
          tmp___6 = write_out_header(& file_hdr, out_file_des);
          }
#line 706
          if (tmp___6) {
#line 707
            goto while_continue;
          }
#line 708
          goto switch_break;
        }
      }
#line 711
      if ((unsigned int )archive_format == 3U) {
#line 711
        goto _L___1;
      } else
#line 711
      if ((unsigned int )archive_format == 4U) {
        _L___1: /* CIL Label */ 
#line 711
        if (file_hdr.c_nlink > 1UL) {
          {
#line 714
          tmp___7 = last_link(& file_hdr);
          }
#line 714
          if (tmp___7) {
            {
#line 716
            writeout_other_defers(& file_hdr, out_file_des);
            }
          } else {
            {
#line 720
            add_link_defer(& file_hdr);
            }
#line 721
            goto switch_break;
          }
        }
      }
      {
#line 724
      in_file_des = open((char const   *)orig_file_name, 0, 0);
      }
#line 726
      if (in_file_des < 0) {
        {
#line 728
        open_error((char const   *)orig_file_name);
        }
#line 729
        goto while_continue;
      }
#line 732
      if ((unsigned int )archive_format == 4U) {
        {
#line 733
        file_hdr.c_chksum = read_for_checksum(in_file_des, (int )file_hdr.c_filesize,
                                              orig_file_name);
        }
      }
      {
#line 737
      tmp___8 = write_out_header(& file_hdr, out_file_des);
      }
#line 737
      if (tmp___8) {
#line 738
        goto while_continue;
      }
      {
#line 739
      copy_files_disk_to_tape(in_file_des, out_file_des, file_hdr.c_filesize, orig_file_name);
#line 742
      warn_if_file_changed(orig_file_name, file_hdr.c_filesize, file_hdr.c_mtime);
      }
#line 745
      if ((unsigned int )archive_format == 5U) {
        {
#line 746
        add_inode(file_hdr.c_ino, orig_file_name, (unsigned long )file_hdr.c_dev_maj,
                  (unsigned long )file_hdr.c_dev_min);
        }
      } else
#line 745
      if ((unsigned int )archive_format == 6U) {
        {
#line 746
        add_inode(file_hdr.c_ino, orig_file_name, (unsigned long )file_hdr.c_dev_maj,
                  (unsigned long )file_hdr.c_dev_min);
        }
      }
      {
#line 749
      tape_pad_output(out_file_des, (int )file_hdr.c_filesize);
      }
#line 751
      if (reset_time_flag) {
        {
#line 752
        set_file_times(in_file_des, (char const   *)orig_file_name, (unsigned long )file_stat.st_atim.tv_sec,
                       (unsigned long )file_stat.st_mtim.tv_sec);
        }
      }
      {
#line 755
      tmp___9 = close(in_file_des);
      }
#line 755
      if (tmp___9 < 0) {
        {
#line 756
        close_error((char const   *)orig_file_name);
        }
      }
#line 757
      goto switch_break;
      case_16384: /* CIL Label */ 
      {
#line 760
      file_hdr.c_filesize = (off_t )0;
#line 761
      tmp___10 = write_out_header(& file_hdr, out_file_des);
      }
#line 761
      if (tmp___10) {
#line 762
        goto while_continue;
      }
#line 763
      goto switch_break;
      case_4096: /* CIL Label */ 
      case_49152: /* CIL Label */ 
      case_24576: /* CIL Label */ 
      case_8192: /* CIL Label */ 
#line 773
      if ((unsigned int )archive_format == 5U) {
        {
#line 775
        tmp___11 = gettext("%s not dumped: not a regular file");
#line 775
        error(0, 0, (char const   *)tmp___11, orig_file_name);
        }
#line 777
        goto while_continue;
      } else
#line 779
      if ((unsigned int )archive_format == 6U) {
        {
#line 782
        otherfile___0 = find_inode_file(file_hdr.c_ino, (unsigned long )file_hdr.c_dev_maj,
                                        (unsigned long )file_hdr.c_dev_min);
        }
#line 782
        if (otherfile___0) {
          {
#line 788
          file_hdr.c_mode = file_stat.st_mode & 4095U;
#line 789
          file_hdr.c_mode |= 32768U;
#line 790
          file_hdr.c_tar_linkname = otherfile___0;
#line 791
          tmp___12 = write_out_header(& file_hdr, out_file_des);
          }
#line 791
          if (tmp___12) {
#line 792
            goto while_continue;
          }
#line 793
          goto switch_break;
        }
        {
#line 795
        add_inode(file_hdr.c_ino, orig_file_name, (unsigned long )file_hdr.c_dev_maj,
                  (unsigned long )file_hdr.c_dev_min);
        }
      }
      {
#line 798
      file_hdr.c_filesize = (off_t )0;
#line 799
      tmp___13 = write_out_header(& file_hdr, out_file_des);
      }
#line 799
      if (tmp___13) {
#line 800
        goto while_continue;
      }
#line 801
      goto switch_break;
      case_40960: /* CIL Label */ 
      {
#line 806
      tmp___14 = xmalloc((size_t )(file_stat.st_size + 1L));
#line 806
      link_name = (char *)tmp___14;
#line 809
      tmp___15 = (ssize_t )readlink((char const   */* __restrict  */)orig_file_name,
                                    (char */* __restrict  */)link_name, (size_t )file_stat.st_size);
#line 809
      link_size = (int )tmp___15;
      }
#line 811
      if (link_size < 0) {
        {
#line 813
        readlink_warn((char const   *)orig_file_name);
#line 814
        free((void *)link_name);
        }
#line 815
        goto while_continue;
      }
      {
#line 817
      *(link_name + link_size) = (char)0;
#line 818
      cpio_safer_name_suffix(link_name, (_Bool)0, (_Bool )(! no_abs_paths_flag), (_Bool)1);
#line 820
      tmp___16 = strlen((char const   *)link_name);
#line 820
      link_size = (int )tmp___16;
#line 821
      file_hdr.c_filesize = (off_t )link_size;
      }
#line 822
      if ((unsigned int )archive_format == 5U) {
#line 822
        goto _L___2;
      } else
#line 822
      if ((unsigned int )archive_format == 6U) {
        _L___2: /* CIL Label */ 
#line 824
        if (link_size + 1 > 100) {
          {
#line 826
          tmp___17 = gettext("%s: symbolic link too long");
#line 826
          error(0, 0, (char const   *)tmp___17, file_hdr.c_name);
          }
        } else {
          {
#line 831
          *(link_name + link_size) = (char )'\000';
#line 832
          file_hdr.c_tar_linkname = link_name;
#line 833
          tmp___18 = write_out_header(& file_hdr, out_file_des);
          }
#line 833
          if (tmp___18) {
#line 834
            goto while_continue;
          }
        }
      } else {
        {
#line 839
        tmp___19 = write_out_header(& file_hdr, out_file_des);
        }
#line 839
        if (tmp___19) {
#line 840
          goto while_continue;
        }
        {
#line 841
        tape_buffered_write(link_name, out_file_des, (off_t )link_size);
#line 842
        tape_pad_output(out_file_des, link_size);
        }
      }
      {
#line 844
      free((void *)link_name);
      }
#line 846
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 850
      tmp___20 = gettext("%s: unknown file type");
#line 850
      error(0, 0, (char const   *)tmp___20, orig_file_name);
      }
      switch_break: /* CIL Label */ ;
      }
#line 853
      if (verbose_flag) {
        {
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                orig_file_name);
        }
      }
#line 855
      if (dot_flag) {
        {
#line 856
        fputc_unlocked('.', stderr);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  free((void *)orig_file_name);
#line 862
  writeout_final_defers(out_file_des);
#line 864
  file_hdr.c_ino = (ino_t )0;
#line 865
  file_hdr.c_mode = (mode_t )0;
#line 866
  file_hdr.c_uid = (uid_t )0;
#line 867
  file_hdr.c_gid = (gid_t )0;
#line 868
  file_hdr.c_nlink = (size_t )1;
#line 869
  file_hdr.c_dev_maj = 0L;
#line 870
  file_hdr.c_dev_min = 0L;
#line 871
  file_hdr.c_rdev_maj = 0L;
#line 872
  file_hdr.c_rdev_min = 0L;
#line 873
  file_hdr.c_mtime = (time_t )0;
#line 874
  file_hdr.c_chksum = 0UL;
#line 876
  file_hdr.c_filesize = (off_t )0;
#line 877
  file_hdr.c_namesize = (size_t )11;
#line 878
  file_hdr.c_name = (char *)"TRAILER!!!";
  }
#line 879
  if ((unsigned int )archive_format != 5U) {
#line 879
    if ((unsigned int )archive_format != 6U) {
      {
#line 880
      write_out_header(& file_hdr, out_file_des);
      }
    } else {
      {
#line 882
      write_nuls_to_file((off_t )1024, out_file_des, & tape_buffered_write);
      }
    }
  } else {
    {
#line 882
    write_nuls_to_file((off_t )1024, out_file_des, & tape_buffered_write);
    }
  }
  {
#line 885
  tape_clear_rest_of_block(out_file_des);
#line 886
  tape_empty_output_buffer(out_file_des);
  }
#line 887
  if (dot_flag) {
    {
#line 888
    fputc_unlocked('\n', stderr);
    }
  }
#line 889
  if (! quiet_flag) {
    {
#line 891
    blocks = (size_t )(((output_bytes + (off_t )io_block_size) - 1L) / (off_t )io_block_size);
#line 892
    tmp___23 = ngettext("%lu block\n", "%lu blocks\n", blocks);
#line 892
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
            blocks);
    }
  }
#line 896
  return;
}
}
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 258
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 105 "/home/wslee/gnu_benchmarks/cpio-2.11/src/extern.h"
void read_in_header(struct cpio_file_stat *file_hdr , int in_des ) ;
#line 106
void read_in_old_ascii(struct cpio_file_stat *file_hdr , int in_des ) ;
#line 107
void read_in_new_ascii(struct cpio_file_stat *file_hdr , int in_des ) ;
#line 108
void read_in_binary(struct cpio_file_stat *file_hdr , struct old_cpio_header *short_hdr ,
                    int in_des ) ;
#line 112
void long_format(struct cpio_file_stat *file_hdr , char *link_name ) ;
#line 113
void print_name_with_quoting(char *p ) ;
#line 129
extern void mode_string(unsigned int mode , char *str ) ;
#line 65 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 39 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void copyin_regular_file(struct cpio_file_stat *file_hdr , int in_file_des ) ;
#line 42 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void warn_junk_bytes(long bytes_skipped ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 45
  tmp = ngettext("warning: skipped %ld byte of junk", "warning: skipped %ld bytes of junk",
                 (unsigned long )bytes_skipped);
#line 45
  error(0, 0, (char const   *)tmp, bytes_skipped);
  }
#line 48
  return;
}
}
#line 56 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static dynamic_string new_name  ;
#line 57
static int query_rename(struct cpio_file_stat *file_hdr , FILE *tty_in , FILE *tty_out ,
                        FILE *rename_in ) ;
#line 57 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static int initialized_new_name  =    0;
#line 51 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static int query_rename(struct cpio_file_stat *file_hdr , FILE *tty_in , FILE *tty_out ,
                        FILE *rename_in ) 
{ 
  char *str_res ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 58
  if (! initialized_new_name) {
    {
#line 60
    ds_init(& new_name, 128);
#line 61
    initialized_new_name = 1;
    }
  }
#line 64
  if (rename_flag) {
    {
#line 66
    tmp = gettext("rename %s -> ");
#line 66
    fprintf((FILE */* __restrict  */)tty_out, (char const   */* __restrict  */)tmp,
            file_hdr->c_name);
#line 67
    fflush_unlocked(tty_out);
#line 68
    str_res = ds_fgets(tty_in, & new_name);
    }
  } else {
    {
#line 72
    str_res = ds_fgetstr(rename_in, & new_name, (char )'\n');
    }
  }
#line 74
  if ((unsigned long )str_res == (unsigned long )((void *)0)) {
#line 76
    return (-1);
  } else
#line 74
  if ((int )*(str_res + 0) == 0) {
#line 76
    return (-1);
  } else
#line 87
  if ((unsigned int )archive_format != 5U) {
#line 87
    if ((unsigned int )archive_format != 6U) {
      {
#line 89
      free((void *)file_hdr->c_name);
#line 90
      file_hdr->c_name = xstrdup((char const   *)new_name.ds_string);
      }
    } else {
#line 87
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 94
    tmp___1 = is_tar_filename_too_long(new_name.ds_string);
    }
#line 94
    if (tmp___1) {
      {
#line 95
      tmp___0 = gettext("%s: file name too long");
#line 95
      error(0, 0, (char const   *)tmp___0, new_name.ds_string);
      }
    } else {
      {
#line 98
      strcpy((char */* __restrict  */)file_hdr->c_name, (char const   */* __restrict  */)new_name.ds_string);
      }
    }
  }
#line 101
  return (0);
}
}
#line 110 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void tape_skip_padding(int in_file_des , off_t offset ) 
{ 
  off_t pad ;

  {
#line 115
  if ((unsigned int )archive_format == 4U) {
#line 116
    pad = (4L - offset % 4L) % 4L;
  } else
#line 115
  if ((unsigned int )archive_format == 3U) {
#line 116
    pad = (4L - offset % 4L) % 4L;
  } else
#line 117
  if ((unsigned int )archive_format == 1U) {
#line 118
    pad = (2L - offset % 2L) % 2L;
  } else
#line 117
  if ((unsigned int )archive_format == 8U) {
#line 118
    pad = (2L - offset % 2L) % 2L;
  } else
#line 119
  if ((unsigned int )archive_format == 5U) {
#line 120
    pad = (512L - offset % 512L) % 512L;
  } else
#line 119
  if ((unsigned int )archive_format == 6U) {
#line 120
    pad = (512L - offset % 512L) % 512L;
  } else {
#line 122
    pad = (off_t )0;
  }
#line 124
  if (pad != 0L) {
    {
#line 125
    tape_toss_input(in_file_des, pad);
    }
  }
#line 126
  return;
}
}
#line 129 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void list_file(struct cpio_file_stat *file_hdr , int in_file_des ) 
{ 
  char *link_name ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 132
  if (verbose_flag) {
#line 135
    if ((file_hdr->c_mode & 61440U) == 40960U) {
#line 137
      if ((unsigned int )archive_format != 5U) {
#line 137
        if ((unsigned int )archive_format != 6U) {
          {
#line 139
          link_name = (char *)((void *)0);
#line 141
          tmp = xmalloc((size_t )((unsigned int )file_hdr->c_filesize + 1U));
#line 141
          link_name = (char *)tmp;
#line 142
          *(link_name + file_hdr->c_filesize) = (char )'\000';
#line 143
          tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);
#line 144
          long_format(file_hdr, link_name);
#line 145
          free((void *)link_name);
#line 146
          tape_skip_padding(in_file_des, file_hdr->c_filesize);
          }
#line 147
          return;
        } else {
          {
#line 151
          long_format(file_hdr, file_hdr->c_tar_linkname);
          }
#line 152
          return;
        }
      } else {
        {
#line 151
        long_format(file_hdr, file_hdr->c_tar_linkname);
        }
#line 152
        return;
      }
    } else {
      {
#line 157
      long_format(file_hdr, (char *)0);
      }
    }
  } else {
    {
#line 165
    printf((char const   */* __restrict  */)"%s%c", file_hdr->c_name, (int )name_end);
    }
  }
  {
#line 168
  crc = 0UL;
#line 169
  tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 170
  tape_skip_padding(in_file_des, file_hdr->c_filesize);
  }
#line 171
  if (only_verify_crc_flag) {
#line 174
    if ((file_hdr->c_mode & 61440U) == 40960U) {
#line 176
      return;
    }
#line 179
    if (crc != file_hdr->c_chksum) {
      {
#line 181
      tmp___0 = gettext("%s: checksum error (0x%lx, should be 0x%lx)");
#line 181
      error(0, 0, (char const   *)tmp___0, file_hdr->c_name, crc, file_hdr->c_chksum);
      }
    }
  }
#line 185
  return;
}
}
#line 187 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static int try_existing_file(struct cpio_file_stat *file_hdr , int in_file_des , int *existing_dir ) 
{ 
  struct stat file_stat ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 193
  *existing_dir = 0;
#line 194
  tmp___5 = lstat((char const   */* __restrict  */)file_hdr->c_name, (struct stat */* __restrict  */)(& file_stat));
  }
#line 194
  if (tmp___5 == 0) {
#line 196
    if ((file_stat.st_mode & 61440U) == 16384U) {
#line 196
      if ((file_hdr->c_mode & 61440U) == 16384U) {
#line 202
        *existing_dir = 1;
#line 203
        return (0);
      } else {
#line 196
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 205
    if (! unconditional_flag) {
#line 205
      if (file_hdr->c_mtime <= file_stat.st_mtim.tv_sec) {
        {
#line 208
        tmp = gettext("%s not created: newer or same age version exists");
#line 208
        error(0, 0, (char const   *)tmp, file_hdr->c_name);
#line 210
        tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 211
        tape_skip_padding(in_file_des, file_hdr->c_filesize);
        }
#line 212
        return (-1);
      } else {
#line 205
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 214
      if ((file_stat.st_mode & 61440U) == 16384U) {
        {
#line 214
        tmp___2 = rmdir((char const   *)file_hdr->c_name);
#line 214
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 214
        tmp___3 = unlink((char const   *)file_hdr->c_name);
#line 214
        tmp___4 = tmp___3;
        }
      }
#line 214
      if (tmp___4) {
        {
#line 218
        tmp___0 = gettext("cannot remove current %s");
#line 218
        tmp___1 = __errno_location();
#line 218
        error(0, *tmp___1, (char const   *)tmp___0, file_hdr->c_name);
#line 220
        tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 221
        tape_skip_padding(in_file_des, file_hdr->c_filesize);
        }
#line 222
        return (-1);
      }
    }
  }
#line 225
  return (0);
}
}
#line 237 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
struct deferment *deferments  =    (struct deferment *)((void *)0);
#line 242 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void defer_copyin(struct cpio_file_stat *file_hdr ) 
{ 
  struct deferment *d ;

  {
  {
#line 246
  d = create_deferment(file_hdr);
#line 247
  d->next = deferments;
#line 248
  deferments = d;
  }
#line 249
  return;
}
}
#line 256 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void create_defered_links(struct cpio_file_stat *file_hdr ) 
{ 
  struct deferment *d ;
  struct deferment *d_prev ;
  ino_t ino ;
  int maj ;
  int min ;
  int link_res ;
  struct deferment *d_free ;
  char *tmp ;
  int *tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 265
  ino = file_hdr->c_ino;
#line 266
  maj = (int )file_hdr->c_dev_maj;
#line 267
  min = (int )file_hdr->c_dev_min;
#line 268
  d = deferments;
#line 269
  d_prev = (struct deferment *)((void *)0);
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 270
      goto while_break;
    }
#line 272
    if (d->header.c_ino == ino) {
#line 272
      if (d->header.c_dev_maj == (long )maj) {
#line 272
        if (d->header.c_dev_min == (long )min) {
          {
#line 276
          link_res = link_to_name(d->header.c_name, file_hdr->c_name);
          }
#line 277
          if (link_res < 0) {
            {
#line 279
            tmp = gettext("cannot link %s to %s");
#line 279
            tmp___0 = __errno_location();
#line 279
            error(0, *tmp___0, (char const   *)tmp, d->header.c_name, file_hdr->c_name);
            }
          }
#line 282
          if ((unsigned long )d_prev != (unsigned long )((void *)0)) {
#line 283
            d_prev->next = d->next;
          } else {
#line 285
            deferments = d->next;
          }
          {
#line 286
          d_free = d;
#line 287
          d = d->next;
#line 288
          free_deferment(d_free);
          }
        } else {
#line 292
          d_prev = d;
#line 293
          d = d->next;
        }
      } else {
#line 292
        d_prev = d;
#line 293
        d = d->next;
      }
    } else {
#line 292
      d_prev = d;
#line 293
      d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 303 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static int create_defered_links_to_skipped(struct cpio_file_stat *file_hdr , int in_file_des ) 
{ 
  struct deferment *d ;
  struct deferment *d_prev ;
  ino_t ino ;
  int maj ;
  int min ;

  {
#line 312
  if (file_hdr->c_filesize == 0L) {
#line 316
    return (-1);
  }
#line 318
  ino = file_hdr->c_ino;
#line 319
  maj = (int )file_hdr->c_dev_maj;
#line 320
  min = (int )file_hdr->c_dev_min;
#line 321
  d = deferments;
#line 322
  d_prev = (struct deferment *)((void *)0);
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 323
      goto while_break;
    }
#line 325
    if (d->header.c_ino == ino) {
#line 325
      if (d->header.c_dev_maj == (long )maj) {
#line 325
        if (d->header.c_dev_min == (long )min) {
#line 328
          if ((unsigned long )d_prev != (unsigned long )((void *)0)) {
#line 329
            d_prev->next = d->next;
          } else {
#line 331
            deferments = d->next;
          }
          {
#line 332
          free((void *)file_hdr->c_name);
#line 333
          file_hdr->c_name = xstrdup((char const   *)d->header.c_name);
#line 334
          free_deferment(d);
#line 335
          copyin_regular_file(file_hdr, in_file_des);
          }
#line 336
          return (0);
        } else {
#line 340
          d_prev = d;
#line 341
          d = d->next;
        }
      } else {
#line 340
        d_prev = d;
#line 341
        d = d->next;
      }
    } else {
#line 340
      d_prev = d;
#line 341
      d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (-1);
}
}
#line 353 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void create_final_defers(void) 
{ 
  struct deferment *d ;
  int link_res ;
  int out_file_des ;
  int tmp ;

  {
#line 360
  d = deferments;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 360
      goto while_break;
    }
    {
#line 368
    link_res = link_to_maj_min_ino(d->header.c_name, (int )d->header.c_dev_maj, (int )d->header.c_dev_min,
                                   d->header.c_ino);
    }
#line 371
    if (link_res == 0) {
#line 373
      goto __Cont;
    }
    {
#line 375
    out_file_des = open((char const   *)d->header.c_name, 65, 384);
    }
#line 377
    if (out_file_des < 0) {
#line 377
      if (create_dir_flag) {
        {
#line 379
        create_all_directories(d->header.c_name);
#line 380
        out_file_des = open((char const   *)d->header.c_name, 65, 384);
        }
      }
    }
#line 384
    if (out_file_des < 0) {
      {
#line 386
      open_error((char const   *)d->header.c_name);
      }
#line 387
      goto __Cont;
    }
    {
#line 390
    set_perms(out_file_des, & d->header);
#line 392
    tmp = close(out_file_des);
    }
#line 392
    if (tmp < 0) {
      {
#line 393
      close_error((char const   *)d->header.c_name);
      }
    }
    __Cont: /* CIL Label */ 
#line 360
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return;
}
}
#line 398 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void copyin_regular_file(struct cpio_file_stat *file_hdr , int in_file_des ) 
{ 
  int out_file_des ;
  int link_res ;
  int link_res___0 ;
  int link_res___1 ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 403
  if (to_stdout_option) {
#line 404
    out_file_des = 1;
  } else {
#line 408
    if (file_hdr->c_nlink > 1UL) {
#line 408
      if ((unsigned int )archive_format == 3U) {
#line 408
        goto _L___3;
      } else
#line 408
      if ((unsigned int )archive_format == 4U) {
        _L___3: /* CIL Label */ 
#line 413
        if (file_hdr->c_filesize == 0L) {
          {
#line 428
          defer_copyin(file_hdr);
#line 429
          tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 430
          tape_skip_padding(in_file_des, file_hdr->c_filesize);
          }
#line 431
          return;
        }
        {
#line 440
        link_res = link_to_maj_min_ino(file_hdr->c_name, (int )file_hdr->c_dev_maj,
                                       (int )file_hdr->c_dev_min, file_hdr->c_ino);
        }
#line 443
        if (link_res == 0) {
          {
#line 445
          tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 446
          tape_skip_padding(in_file_des, file_hdr->c_filesize);
          }
#line 447
          return;
        }
      } else {
#line 408
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 450
    if (file_hdr->c_nlink > 1UL) {
#line 450
      if ((unsigned int )archive_format != 5U) {
#line 450
        if ((unsigned int )archive_format != 6U) {
          {
#line 457
          link_res___0 = link_to_maj_min_ino(file_hdr->c_name, (int )file_hdr->c_dev_maj,
                                             (int )file_hdr->c_dev_min, file_hdr->c_ino);
          }
#line 461
          if (link_res___0 == 0) {
            {
#line 463
            tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 464
            tape_skip_padding(in_file_des, file_hdr->c_filesize);
            }
#line 465
            return;
          }
        } else {
#line 450
          goto _L___1;
        }
      } else {
#line 450
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 468
    if ((unsigned int )archive_format == 5U) {
#line 468
      goto _L;
    } else
#line 468
    if ((unsigned int )archive_format == 6U) {
      _L: /* CIL Label */ 
#line 468
      if (file_hdr->c_tar_linkname) {
#line 468
        if ((int )*(file_hdr->c_tar_linkname + 0) != 0) {
          {
#line 473
          link_res___1 = link_to_name(file_hdr->c_name, file_hdr->c_tar_linkname);
          }
#line 474
          if (link_res___1 < 0) {
            {
#line 476
            tmp = gettext("cannot link %s to %s");
#line 476
            tmp___0 = __errno_location();
#line 476
            error(0, *tmp___0, (char const   *)tmp, file_hdr->c_tar_linkname, file_hdr->c_name);
            }
          }
#line 479
          return;
        }
      }
    }
    {
#line 483
    out_file_des = open((char const   *)file_hdr->c_name, 65, 384);
    }
#line 486
    if (out_file_des < 0) {
#line 486
      if (create_dir_flag) {
        {
#line 488
        create_all_directories(file_hdr->c_name);
#line 489
        out_file_des = open((char const   *)file_hdr->c_name, 65, 384);
        }
      }
    }
#line 494
    if (out_file_des < 0) {
      {
#line 496
      open_error((char const   *)file_hdr->c_name);
#line 497
      tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 498
      tape_skip_padding(in_file_des, file_hdr->c_filesize);
      }
#line 499
      return;
    }
  }
#line 503
  crc = 0UL;
#line 504
  if (swap_halfwords_flag) {
#line 506
    if (file_hdr->c_filesize % 4L == 0L) {
#line 507
      swapping_halfwords = 1;
    } else {
      {
#line 509
      tmp___1 = gettext("cannot swap halfwords of %s: odd number of halfwords");
#line 509
      error(0, 0, (char const   *)tmp___1, file_hdr->c_name);
      }
    }
  }
#line 512
  if (swap_bytes_flag) {
#line 514
    if (file_hdr->c_filesize % 2L == 0L) {
#line 515
      swapping_bytes = 1;
    } else {
      {
#line 517
      tmp___2 = gettext("cannot swap bytes of %s: odd number of bytes");
#line 517
      error(0, 0, (char const   *)tmp___2, file_hdr->c_name);
      }
    }
  }
  {
#line 520
  copy_files_tape_to_disk(in_file_des, out_file_des, file_hdr->c_filesize);
#line 521
  disk_empty_output_buffer(out_file_des);
  }
#line 523
  if (to_stdout_option) {
#line 525
    if ((unsigned int )archive_format == 4U) {
#line 527
      if (crc != file_hdr->c_chksum) {
        {
#line 528
        tmp___3 = gettext("%s: checksum error (0x%lx, should be 0x%lx)");
#line 528
        error(0, 0, (char const   *)tmp___3, file_hdr->c_name, crc, file_hdr->c_chksum);
        }
      }
    }
    {
#line 531
    tape_skip_padding(in_file_des, file_hdr->c_filesize);
    }
#line 532
    return;
  }
#line 538
  if (delayed_seek_count > 0) {
    {
#line 540
    lseek(out_file_des, (__off_t )(delayed_seek_count - 1), 1);
#line 541
    write(out_file_des, (void const   *)"", (size_t )1);
#line 542
    delayed_seek_count = 0;
    }
  }
  {
#line 545
  set_perms(out_file_des, file_hdr);
#line 547
  tmp___4 = close(out_file_des);
  }
#line 547
  if (tmp___4 < 0) {
    {
#line 548
    close_error((char const   *)file_hdr->c_name);
    }
  }
#line 550
  if ((unsigned int )archive_format == 4U) {
#line 552
    if (crc != file_hdr->c_chksum) {
      {
#line 553
      tmp___5 = gettext("%s: checksum error (0x%lx, should be 0x%lx)");
#line 553
      error(0, 0, (char const   *)tmp___5, file_hdr->c_name, crc, file_hdr->c_chksum);
      }
    }
  }
  {
#line 557
  tape_skip_padding(in_file_des, file_hdr->c_filesize);
  }
#line 558
  if (file_hdr->c_nlink > 1UL) {
#line 558
    if ((unsigned int )archive_format == 3U) {
      {
#line 565
      create_defered_links(file_hdr);
      }
    } else
#line 558
    if ((unsigned int )archive_format == 4U) {
      {
#line 565
      create_defered_links(file_hdr);
      }
    }
  }
#line 567
  return;
}
}
#line 569 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void copyin_device(struct cpio_file_stat *file_hdr ) 
{ 
  int res ;
  int link_res ;
  int link_res___0 ;
  char *tmp ;
  int *tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;
  uid_t uid ;
  uid_t tmp___3 ;
  gid_t gid ;
  gid_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp16 ;

  {
#line 574
  if (to_stdout_option) {
#line 575
    return;
  }
#line 577
  if (file_hdr->c_nlink > 1UL) {
#line 577
    if ((unsigned int )archive_format != 5U) {
#line 577
      if ((unsigned int )archive_format != 6U) {
        {
#line 584
        link_res = link_to_maj_min_ino(file_hdr->c_name, (int )file_hdr->c_dev_maj,
                                       (int )file_hdr->c_dev_min, file_hdr->c_ino);
        }
#line 587
        if (link_res == 0) {
#line 589
          return;
        }
      } else {
#line 577
        goto _L___0;
      }
    } else {
#line 577
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 592
  if ((unsigned int )archive_format == 6U) {
#line 592
    if (file_hdr->c_tar_linkname) {
#line 592
      if ((int )*(file_hdr->c_tar_linkname + 0) != 0) {
        {
#line 597
        link_res___0 = link_to_name(file_hdr->c_name, file_hdr->c_tar_linkname);
        }
#line 599
        if (link_res___0 < 0) {
          {
#line 601
          tmp = gettext("cannot link %s to %s");
#line 601
          tmp___0 = __errno_location();
#line 601
          error(0, *tmp___0, (char const   *)tmp, file_hdr->c_tar_linkname, file_hdr->c_name);
          }
        }
#line 610
        return;
      }
    }
  }
  {
#line 613
  tmp___1 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                                 (unsigned int )file_hdr->c_rdev_min);
#line 613
  res = mknod((char const   *)file_hdr->c_name, file_hdr->c_mode, (__dev_t )tmp___1);
  }
#line 615
  if (res < 0) {
#line 615
    if (create_dir_flag) {
      {
#line 617
      create_all_directories(file_hdr->c_name);
#line 618
      tmp___2 = (unsigned long long )gnu_dev_makedev((unsigned int )file_hdr->c_rdev_maj,
                                                     (unsigned int )file_hdr->c_rdev_min);
#line 618
      res = mknod((char const   *)file_hdr->c_name, file_hdr->c_mode, (__dev_t )tmp___2);
      }
    }
  }
#line 621
  if (res < 0) {
    {
#line 623
    mknod_error((char const   *)file_hdr->c_name);
    }
#line 624
    return;
  }
#line 626
  if (! no_chown_flag) {
#line 628
    if (set_owner_flag) {
#line 628
      tmp___3 = set_owner;
    } else {
#line 628
      tmp___3 = file_hdr->c_uid;
    }
#line 628
    uid = tmp___3;
#line 629
    if (set_group_flag) {
#line 629
      tmp___4 = set_group;
    } else {
#line 629
      tmp___4 = file_hdr->c_gid;
    }
    {
#line 629
    gid = tmp___4;
#line 630
    tmp___5 = chown((char const   *)file_hdr->c_name, uid, gid);
    }
#line 630
    if (tmp___5 < 0) {
      {
#line 630
      tmp___6 = __errno_location();
      }
#line 630
      if (*tmp___6 != 1) {
        {
#line 632
        chown_error_details((char const   *)file_hdr->c_name, uid, gid);
        }
      }
    }
  }
  {
#line 635
  tmp___7 = chmod((char const   *)file_hdr->c_name, file_hdr->c_mode);
  }
#line 635
  if (tmp___7 < 0) {
    {
#line 636
    chmod_error_details((char const   *)file_hdr->c_name, file_hdr->c_mode);
    }
  }
#line 637
  if (retain_time_flag) {
    {
#line 638
    set_file_times(-1, (char const   *)file_hdr->c_name, (unsigned long )file_hdr->c_mtime,
                   (unsigned long )file_hdr->c_mtime);
    }
  }
#line 640
  return;
}
}
#line 642 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void copyin_link(struct cpio_file_stat *file_hdr , int in_file_des ) 
{ 
  char *link_name ;
  int res ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  uid_t uid ;
  uid_t tmp___4 ;
  gid_t gid ;
  gid_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *__cil_tmp16 ;

  {
#line 645
  link_name = (char *)((void *)0);
#line 648
  if (to_stdout_option) {
#line 649
    return;
  }
#line 651
  if ((unsigned int )archive_format != 5U) {
#line 651
    if ((unsigned int )archive_format != 6U) {
      {
#line 653
      tmp = xmalloc((size_t )((unsigned int )file_hdr->c_filesize + 1U));
#line 653
      link_name = (char *)tmp;
#line 654
      *(link_name + file_hdr->c_filesize) = (char )'\000';
#line 655
      tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);
#line 656
      tape_skip_padding(in_file_des, file_hdr->c_filesize);
      }
    } else {
      {
#line 660
      link_name = xstrdup((char const   *)file_hdr->c_tar_linkname);
      }
    }
  } else {
    {
#line 660
    link_name = xstrdup((char const   *)file_hdr->c_tar_linkname);
    }
  }
  {
#line 663
  res = symlink((char const   *)link_name, (char const   *)file_hdr->c_name);
  }
#line 665
  if (res < 0) {
#line 665
    if (create_dir_flag) {
      {
#line 667
      create_all_directories(file_hdr->c_name);
#line 668
      res = symlink((char const   *)link_name, (char const   *)file_hdr->c_name);
      }
    }
  }
#line 671
  if (res < 0) {
    {
#line 673
    tmp___0 = quote_n(1, (char const   *)file_hdr->c_name);
#line 673
    tmp___1 = quotearg_colon((char const   *)link_name);
#line 673
    tmp___2 = gettext("%s: Cannot symlink to %s");
#line 673
    tmp___3 = __errno_location();
#line 673
    error(0, *tmp___3, (char const   *)tmp___2, tmp___1, tmp___0);
#line 675
    free((void *)link_name);
    }
#line 676
    return;
  }
#line 678
  if (! no_chown_flag) {
#line 680
    if (set_owner_flag) {
#line 680
      tmp___4 = set_owner;
    } else {
#line 680
      tmp___4 = file_hdr->c_uid;
    }
#line 680
    uid = tmp___4;
#line 681
    if (set_group_flag) {
#line 681
      tmp___5 = set_group;
    } else {
#line 681
      tmp___5 = file_hdr->c_gid;
    }
    {
#line 681
    gid = tmp___5;
#line 682
    tmp___6 = lchown((char const   *)file_hdr->c_name, uid, gid);
    }
#line 682
    if (tmp___6 < 0) {
      {
#line 682
      tmp___7 = __errno_location();
      }
#line 682
      if (*tmp___7 != 1) {
        {
#line 684
        chown_error_details((char const   *)file_hdr->c_name, uid, gid);
        }
      }
    }
  }
  {
#line 686
  free((void *)link_name);
  }
#line 687
  return;
}
}
#line 689 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void copyin_file(struct cpio_file_stat *file_hdr , int in_file_des ) 
{ 
  int existing_dir ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 694
  if (! to_stdout_option) {
    {
#line 694
    tmp = try_existing_file(file_hdr, in_file_des, & existing_dir);
    }
#line 694
    if (tmp < 0) {
#line 696
      return;
    }
  }
  {
#line 701
  if ((file_hdr->c_mode & 61440U) == 32768U) {
#line 701
    goto case_32768;
  }
#line 705
  if ((file_hdr->c_mode & 61440U) == 16384U) {
#line 705
    goto case_16384;
  }
#line 715
  if ((file_hdr->c_mode & 61440U) == 4096U) {
#line 715
    goto case_4096;
  }
#line 715
  if ((file_hdr->c_mode & 61440U) == 49152U) {
#line 715
    goto case_4096;
  }
#line 715
  if ((file_hdr->c_mode & 61440U) == 24576U) {
#line 715
    goto case_4096;
  }
#line 715
  if ((file_hdr->c_mode & 61440U) == 8192U) {
#line 715
    goto case_4096;
  }
#line 721
  if ((file_hdr->c_mode & 61440U) == 40960U) {
#line 721
    goto case_40960;
  }
#line 726
  goto switch_default;
  case_32768: /* CIL Label */ 
  {
#line 702
  copyin_regular_file(file_hdr, in_file_des);
  }
#line 703
  goto switch_break;
  case_16384: /* CIL Label */ 
  {
#line 706
  cpio_create_dir(file_hdr, existing_dir);
  }
#line 707
  goto switch_break;
  case_4096: /* CIL Label */ 
  case_49152: /* CIL Label */ 
  case_24576: /* CIL Label */ 
  case_8192: /* CIL Label */ 
  {
#line 717
  copyin_device(file_hdr);
  }
#line 718
  goto switch_break;
  case_40960: /* CIL Label */ 
  {
#line 722
  copyin_link(file_hdr, in_file_des);
  }
#line 723
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 727
  tmp___0 = gettext("%s: unknown file type");
#line 727
  error(0, 0, (char const   *)tmp___0, file_hdr->c_name);
#line 728
  tape_toss_input(in_file_des, file_hdr->c_filesize);
#line 729
  tape_skip_padding(in_file_des, file_hdr->c_filesize);
  }
  switch_break: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 735 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static time_t current_time  ;
#line 742 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void long_format(struct cpio_file_stat *file_hdr , char *link_name ) 
{ 
  char mbuf[11] ;
  char tbuf[40] ;
  time_t when ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 749
  mode_string(file_hdr->c_mode, mbuf);
#line 750
  mbuf[10] = (char )'\000';
#line 753
  when = file_hdr->c_mtime;
#line 754
  tmp = ctime((time_t const   *)(& when));
#line 754
  strcpy((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)tmp);
  }
#line 755
  if (current_time - when > 15552000L) {
    {
#line 760
    strcpy((char */* __restrict  */)(tbuf + 11), (char const   */* __restrict  */)(tbuf + 19));
    }
  } else
#line 755
  if (current_time - when < 0L) {
    {
#line 760
    strcpy((char */* __restrict  */)(tbuf + 11), (char const   */* __restrict  */)(tbuf + 19));
    }
  }
  {
#line 762
  tbuf[16] = (char )'\000';
#line 764
  printf((char const   */* __restrict  */)"%s %3lu ", mbuf, file_hdr->c_nlink);
  }
#line 766
  if (numeric_uid) {
    {
#line 767
    printf((char const   */* __restrict  */)"%-8u %-8u ", file_hdr->c_uid, file_hdr->c_gid);
    }
  } else {
    {
#line 770
    tmp___0 = getgroup(file_hdr->c_gid);
#line 770
    tmp___1 = getuser(file_hdr->c_uid);
#line 770
    printf((char const   */* __restrict  */)"%-8.8s %-8.8s ", tmp___1, tmp___0);
    }
  }
#line 773
  if ((file_hdr->c_mode & 61440U) == 8192U) {
    {
#line 775
    printf((char const   */* __restrict  */)"%3lu, %3lu ", file_hdr->c_rdev_maj, file_hdr->c_rdev_min);
    }
  } else
#line 773
  if ((file_hdr->c_mode & 61440U) == 24576U) {
    {
#line 775
    printf((char const   */* __restrict  */)"%3lu, %3lu ", file_hdr->c_rdev_maj, file_hdr->c_rdev_min);
    }
  } else {
    {
#line 778
    printf((char const   */* __restrict  */)"%8lu ", (uintmax_t )file_hdr->c_filesize);
    }
  }
  {
#line 780
  printf((char const   */* __restrict  */)"%s ", tbuf + 4);
#line 782
  print_name_with_quoting(file_hdr->c_name);
  }
#line 783
  if (link_name) {
    {
#line 785
    printf((char const   */* __restrict  */)" -> ");
#line 786
    print_name_with_quoting(link_name);
    }
  }
  {
#line 788
  fputc_unlocked('\n', stdout);
  }
#line 789
  return;
}
}
#line 791 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void print_name_with_quoting(char *p ) 
{ 
  register unsigned char c ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    tmp = p;
#line 796
    p ++;
#line 796
    c = (unsigned char )*tmp;
#line 796
    if (! c) {
#line 796
      goto while_break;
    }
    {
#line 800
    if ((int )c == 92) {
#line 800
      goto case_92;
    }
#line 804
    if ((int )c == 10) {
#line 804
      goto case_10;
    }
#line 808
    if ((int )c == 8) {
#line 808
      goto case_8;
    }
#line 812
    if ((int )c == 13) {
#line 812
      goto case_13;
    }
#line 816
    if ((int )c == 9) {
#line 816
      goto case_9;
    }
#line 820
    if ((int )c == 12) {
#line 820
      goto case_12;
    }
#line 824
    if ((int )c == 32) {
#line 824
      goto case_32;
    }
#line 828
    if ((int )c == 34) {
#line 828
      goto case_34;
    }
#line 832
    goto switch_default;
    case_92: /* CIL Label */ 
    {
#line 801
    printf((char const   */* __restrict  */)"\\\\");
    }
#line 802
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 805
    printf((char const   */* __restrict  */)"\\n");
    }
#line 806
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 809
    printf((char const   */* __restrict  */)"\\b");
    }
#line 810
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 813
    printf((char const   */* __restrict  */)"\\r");
    }
#line 814
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 817
    printf((char const   */* __restrict  */)"\\t");
    }
#line 818
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 821
    printf((char const   */* __restrict  */)"\\f");
    }
#line 822
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 825
    printf((char const   */* __restrict  */)"\\ ");
    }
#line 826
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 829
    printf((char const   */* __restrict  */)"\\\"");
    }
#line 830
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 833
    if ((int )c > 32) {
#line 833
      if ((int )c < 127) {
        {
#line 834
        putchar_unlocked((int )c);
        }
      } else {
        {
#line 836
        printf((char const   */* __restrict  */)"\\%03o", (unsigned int )c);
        }
      }
    } else {
      {
#line 836
      printf((char const   */* __restrict  */)"\\%03o", (unsigned int )c);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 845 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static void read_pattern_file(void) 
{ 
  int max_new_patterns ;
  char **new_save_patterns ;
  int new_num_patterns ;
  int i ;
  dynamic_string pattern_name ;
  FILE *pattern_fp ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 855
  if (num_patterns < 0) {
#line 856
    num_patterns = 0;
  }
  {
#line 857
  max_new_patterns = 1 + num_patterns;
#line 858
  tmp = xmalloc((unsigned long )max_new_patterns * sizeof(char *));
#line 858
  new_save_patterns = (char **)tmp;
#line 859
  new_num_patterns = num_patterns;
#line 860
  ds_init(& pattern_name, 128);
#line 862
  pattern_fp = fopen((char const   */* __restrict  */)pattern_file_name, (char const   */* __restrict  */)"r");
  }
#line 863
  if ((unsigned long )pattern_fp == (unsigned long )((void *)0)) {
    {
#line 864
    open_error((char const   *)pattern_file_name);
    }
  }
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 865
    tmp___1 = ds_fgetstr(pattern_fp, & pattern_name, (char )'\n');
    }
#line 865
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 865
      goto while_break;
    }
#line 867
    if (new_num_patterns >= max_new_patterns) {
      {
#line 869
      max_new_patterns ++;
#line 870
      tmp___0 = xrealloc((void *)((char *)new_save_patterns), (unsigned long )max_new_patterns * sizeof(char *));
#line 870
      new_save_patterns = (char **)tmp___0;
      }
    }
    {
#line 874
    *(new_save_patterns + new_num_patterns) = xstrdup((char const   *)pattern_name.ds_string);
#line 875
    new_num_patterns ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 877
  tmp___2 = (int )ferror_unlocked(pattern_fp);
  }
#line 877
  if (tmp___2) {
    {
#line 878
    close_error((char const   *)pattern_file_name);
    }
  } else {
    {
#line 877
    tmp___3 = fclose(pattern_fp);
    }
#line 877
    if (tmp___3 == -1) {
      {
#line 878
      close_error((char const   *)pattern_file_name);
      }
    }
  }
#line 880
  i = 0;
  {
#line 880
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 880
    if (! (i < num_patterns)) {
#line 880
      goto while_break___0;
    }
#line 881
    *(new_save_patterns + i) = *(save_patterns + i);
#line 880
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 883
  save_patterns = new_save_patterns;
#line 884
  num_patterns = new_num_patterns;
#line 885
  return;
}
}
#line 895 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static char codetab___0[17]  = 
#line 895
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'\000'};
#line 888 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
uintmax_t from_ascii(char const   *where , size_t digs , unsigned int logbase ) 
{ 
  uintmax_t value ;
  char const   *buf ;
  char const   *end ;
  int overflow ;
  unsigned int d ;
  char *p ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 891
  value = (uintmax_t )0;
#line 892
  buf = where;
#line 893
  end = buf + digs;
#line 894
  overflow = 0;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! ((int const   )*buf == 32)) {
#line 897
      goto while_break;
    }
#line 899
    if ((unsigned long )buf == (unsigned long )end) {
#line 900
      return ((uintmax_t )0);
    }
#line 897
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  if ((unsigned long )buf == (unsigned long )end) {
#line 904
    return ((uintmax_t )0);
  } else
#line 903
  if ((int const   )*buf == 0) {
#line 904
    return ((uintmax_t )0);
  }
  {
#line 905
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 909
    tmp = (int )toupper((int )*buf);
#line 909
    tmp___0 = strchr((char const   *)(codetab___0), tmp);
#line 909
    p = tmp___0;
    }
#line 910
    if (! p) {
      {
#line 912
      tmp___1 = gettext("Malformed number %.*s");
#line 912
      error(0, 0, (char const   *)tmp___1, digs, where);
      }
#line 913
      goto while_break___0;
    }
#line 916
    d = (unsigned int )(p - codetab___0);
#line 917
    if (d >> logbase > 1U) {
      {
#line 919
      tmp___2 = gettext("Malformed number %.*s");
#line 919
      error(0, 0, (char const   *)tmp___2, digs, where);
      }
#line 920
      goto while_break___0;
    }
#line 922
    value += (uintmax_t )d;
#line 923
    buf ++;
#line 923
    if ((unsigned long )buf == (unsigned long )end) {
#line 924
      goto while_break___0;
    } else
#line 923
    if ((int const   )*buf == 0) {
#line 924
      goto while_break___0;
    }
#line 925
    overflow = (int )((unsigned long )overflow | (value ^ ((value << logbase) >> logbase)));
#line 926
    value <<= logbase;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 928
  if (overflow) {
    {
#line 929
    tmp___3 = gettext("Archive value %.*s is out of range");
#line 929
    error(0, 0, (char const   *)tmp___3, digs, where);
    }
  }
#line 931
  return (value);
}
}
#line 942 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void read_in_header(struct cpio_file_stat *file_hdr , int in_des ) 
{ 
  union __anonunion_magic_57 magic ;
  long bytes_skipped ;
  char tmpbuf[512] ;
  int check_tar ;
  int peeked_bytes ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 950
  bytes_skipped = 0L;
#line 954
  if ((unsigned int )archive_format == 0U) {
    {
#line 960
    while (1) {
      while_continue: /* CIL Label */ ;
#line 960
      if (! ((unsigned int )archive_format == 0U)) {
#line 960
        goto while_break;
      }
      {
#line 962
      peeked_bytes = tape_buffered_peek(tmpbuf, in_des, 512);
      }
#line 963
      if (peeked_bytes < 6) {
        {
#line 964
        tmp = gettext("premature end of archive");
#line 964
        error(1, 0, (char const   *)tmp);
        }
      }
      {
#line 966
      tmp___2 = strncmp((char const   *)(tmpbuf), "070701", (size_t )6);
      }
#line 966
      if (tmp___2) {
        {
#line 968
        tmp___1 = strncmp((char const   *)(tmpbuf), "070707", (size_t )6);
        }
#line 968
        if (tmp___1) {
          {
#line 970
          tmp___0 = strncmp((char const   *)(tmpbuf), "070702", (size_t )6);
          }
#line 970
          if (tmp___0) {
#line 975
            if ((int )*((unsigned short *)(tmpbuf)) == 29127) {
#line 977
              archive_format = (enum archive_format )1;
            } else
#line 975
            if ((int )*((unsigned short *)(tmpbuf)) == (((29127 << 8) & 65280) | ((29127 >> 8) & 255))) {
#line 977
              archive_format = (enum archive_format )1;
            } else
#line 978
            if (peeked_bytes >= 512) {
              {
#line 978
              check_tar = is_tar_header(tmpbuf);
              }
#line 978
              if (check_tar) {
#line 981
                if (check_tar == 2) {
#line 982
                  archive_format = (enum archive_format )6;
                } else {
#line 984
                  archive_format = (enum archive_format )5;
                }
              } else {
                {
#line 988
                tape_buffered_read(tmpbuf, in_des, 1L);
#line 989
                bytes_skipped ++;
                }
              }
            } else {
              {
#line 988
              tape_buffered_read(tmpbuf, in_des, 1L);
#line 989
              bytes_skipped ++;
              }
            }
          } else {
#line 972
            archive_format = (enum archive_format )4;
#line 973
            crc_i_flag = 1;
          }
        } else {
#line 969
          archive_format = (enum archive_format )2;
        }
      } else {
#line 967
        archive_format = (enum archive_format )3;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 994
  if ((unsigned int )archive_format == 5U) {
#line 994
    goto _L;
  } else
#line 994
  if ((unsigned int )archive_format == 6U) {
    _L: /* CIL Label */ 
#line 996
    if (append_flag) {
#line 997
      last_header_start = (int )((input_bytes - (off_t )io_block_size) + (in_buff - input_buffer));
    }
#line 999
    if (bytes_skipped > 0L) {
      {
#line 1000
      warn_junk_bytes(bytes_skipped);
      }
    }
    {
#line 1002
    read_in_tar_header(file_hdr, in_des);
    }
#line 1003
    return;
  }
  {
#line 1006
  file_hdr->c_tar_linkname = (char *)((void *)0);
#line 1008
  tape_buffered_read(magic.str, in_des, 6L);
  }
  {
#line 1009
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1011
    if (append_flag) {
#line 1012
      last_header_start = (int )(((input_bytes - (off_t )io_block_size) + (in_buff - input_buffer)) - 6L);
    }
#line 1014
    if ((unsigned int )archive_format == 3U) {
      {
#line 1014
      tmp___3 = strncmp((char const   *)(magic.str), "070701", (size_t )6);
      }
#line 1014
      if (! tmp___3) {
#line 1017
        if (bytes_skipped > 0L) {
          {
#line 1018
          warn_junk_bytes(bytes_skipped);
          }
        }
        {
#line 1019
        file_hdr->c_magic = (unsigned short)29121;
#line 1020
        read_in_new_ascii(file_hdr, in_des);
        }
#line 1021
        goto while_break___0;
      }
    }
#line 1023
    if ((unsigned int )archive_format == 4U) {
      {
#line 1023
      tmp___4 = strncmp((char const   *)(magic.str), "070702", (size_t )6);
      }
#line 1023
      if (! tmp___4) {
#line 1026
        if (bytes_skipped > 0L) {
          {
#line 1027
          warn_junk_bytes(bytes_skipped);
          }
        }
        {
#line 1028
        file_hdr->c_magic = (unsigned short)29122;
#line 1029
        read_in_new_ascii(file_hdr, in_des);
        }
#line 1030
        goto while_break___0;
      }
    }
#line 1032
    if ((unsigned int )archive_format == 2U) {
#line 1032
      goto _L___0;
    } else
#line 1032
    if ((unsigned int )archive_format == 7U) {
      _L___0: /* CIL Label */ 
      {
#line 1032
      tmp___5 = strncmp((char const   *)(magic.str), "070707", (size_t )6);
      }
#line 1032
      if (! tmp___5) {
#line 1035
        if (bytes_skipped > 0L) {
          {
#line 1036
          warn_junk_bytes(bytes_skipped);
          }
        }
        {
#line 1037
        file_hdr->c_magic = (unsigned short)29127;
#line 1038
        read_in_old_ascii(file_hdr, in_des);
        }
#line 1039
        goto while_break___0;
      }
    }
#line 1041
    if ((unsigned int )archive_format == 1U) {
#line 1041
      goto _L___2;
    } else
#line 1041
    if ((unsigned int )archive_format == 8U) {
      _L___2: /* CIL Label */ 
#line 1041
      if ((int )magic.num == 29127) {
#line 1041
        goto _L___1;
      } else
#line 1041
      if ((int )magic.num == (((29127 << 8) & 65280) | ((29127 >> 8) & 255))) {
        _L___1: /* CIL Label */ 
#line 1046
        if (bytes_skipped > 0L) {
          {
#line 1047
          warn_junk_bytes(bytes_skipped);
          }
        }
        {
#line 1048
        file_hdr->c_magic = (unsigned short)29127;
#line 1049
        read_in_binary(file_hdr, & magic.old_header, in_des);
        }
#line 1050
        goto while_break___0;
      }
    }
    {
#line 1052
    bytes_skipped ++;
#line 1053
    memmove((void *)(magic.str), (void const   *)(magic.str + 1), (size_t )5);
#line 1054
    tape_buffered_read(magic.str, in_des, 1L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1056
  return;
}
}
#line 1062 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void read_in_old_ascii(struct cpio_file_stat *file_hdr , int in_des ) 
{ 
  struct old_ascii_header ascii_header ;
  unsigned long dev ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  uintmax_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;

  {
  {
#line 1068
  tape_buffered_read(ascii_header.c_dev, in_des, (off_t )(sizeof(ascii_header) - sizeof(ascii_header.c_magic)));
#line 1070
  dev = from_ascii((char const   *)(ascii_header.c_dev), sizeof(ascii_header.c_dev),
                   3U);
#line 1071
  tmp = (unsigned int )gnu_dev_major((unsigned long long )dev);
#line 1071
  file_hdr->c_dev_maj = (long )tmp;
#line 1072
  tmp___0 = (unsigned int )gnu_dev_minor((unsigned long long )dev);
#line 1072
  file_hdr->c_dev_min = (long )tmp___0;
#line 1074
  file_hdr->c_ino = from_ascii((char const   *)(ascii_header.c_ino), sizeof(ascii_header.c_ino),
                               3U);
#line 1075
  tmp___1 = from_ascii((char const   *)(ascii_header.c_mode), sizeof(ascii_header.c_mode),
                       3U);
#line 1075
  file_hdr->c_mode = (mode_t )tmp___1;
#line 1076
  tmp___2 = from_ascii((char const   *)(ascii_header.c_uid), sizeof(ascii_header.c_uid),
                       3U);
#line 1076
  file_hdr->c_uid = (uid_t )tmp___2;
#line 1077
  tmp___3 = from_ascii((char const   *)(ascii_header.c_gid), sizeof(ascii_header.c_gid),
                       3U);
#line 1077
  file_hdr->c_gid = (gid_t )tmp___3;
#line 1078
  file_hdr->c_nlink = from_ascii((char const   *)(ascii_header.c_nlink), sizeof(ascii_header.c_nlink),
                                 3U);
#line 1079
  dev = from_ascii((char const   *)(ascii_header.c_rdev), sizeof(ascii_header.c_rdev),
                   3U);
#line 1080
  tmp___4 = (unsigned int )gnu_dev_major((unsigned long long )dev);
#line 1080
  file_hdr->c_rdev_maj = (long )tmp___4;
#line 1081
  tmp___5 = (unsigned int )gnu_dev_minor((unsigned long long )dev);
#line 1081
  file_hdr->c_rdev_min = (long )tmp___5;
#line 1083
  tmp___6 = from_ascii((char const   *)(ascii_header.c_mtime), sizeof(ascii_header.c_mtime),
                       3U);
#line 1083
  file_hdr->c_mtime = (time_t )tmp___6;
#line 1084
  file_hdr->c_namesize = from_ascii((char const   *)(ascii_header.c_namesize), sizeof(ascii_header.c_namesize),
                                    3U);
#line 1085
  tmp___7 = from_ascii((char const   *)(ascii_header.c_filesize), sizeof(ascii_header.c_filesize),
                       3U);
#line 1085
  file_hdr->c_filesize = (off_t )tmp___7;
  }
#line 1088
  if ((unsigned long )file_hdr->c_name != (unsigned long )((void *)0)) {
    {
#line 1089
    free((void *)file_hdr->c_name);
    }
  }
  {
#line 1090
  tmp___8 = xmalloc(file_hdr->c_namesize + 1UL);
#line 1090
  file_hdr->c_name = (char *)tmp___8;
#line 1091
  tape_buffered_read(file_hdr->c_name, in_des, (long )file_hdr->c_namesize);
  }
  {
#line 1107
  if ((file_hdr->c_mode & 61440U) == 4096U) {
#line 1107
    goto case_4096;
  }
#line 1107
  if ((file_hdr->c_mode & 61440U) == 49152U) {
#line 1107
    goto case_4096;
  }
#line 1107
  if ((file_hdr->c_mode & 61440U) == 24576U) {
#line 1107
    goto case_4096;
  }
#line 1107
  if ((file_hdr->c_mode & 61440U) == 8192U) {
#line 1107
    goto case_4096;
  }
#line 1118
  goto switch_default;
  case_4096: /* CIL Label */ 
  case_49152: /* CIL Label */ 
  case_24576: /* CIL Label */ 
  case_8192: /* CIL Label */ 
#line 1109
  if (file_hdr->c_filesize != 0L) {
#line 1109
    if (file_hdr->c_rdev_maj == 0L) {
#line 1109
      if (file_hdr->c_rdev_min == 1L) {
        {
#line 1113
        tmp___9 = (unsigned int )gnu_dev_major((unsigned long long )file_hdr->c_filesize);
#line 1113
        file_hdr->c_rdev_maj = (long )tmp___9;
#line 1114
        tmp___10 = (unsigned int )gnu_dev_minor((unsigned long long )file_hdr->c_filesize);
#line 1114
        file_hdr->c_rdev_min = (long )tmp___10;
#line 1115
        file_hdr->c_filesize = (off_t )0;
        }
      }
    }
  }
#line 1117
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1121
  return;
}
}
#line 1127 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void read_in_new_ascii(struct cpio_file_stat *file_hdr , int in_des ) 
{ 
  struct new_ascii_header ascii_header ;
  uintmax_t tmp ;
  uintmax_t tmp___0 ;
  uintmax_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;
  uintmax_t tmp___5 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  void *tmp___8 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;

  {
  {
#line 1132
  tape_buffered_read(ascii_header.c_ino, in_des, (off_t )(sizeof(ascii_header) - sizeof(ascii_header.c_magic)));
#line 1135
  file_hdr->c_ino = from_ascii((char const   *)(ascii_header.c_ino), sizeof(ascii_header.c_ino),
                               4U);
#line 1136
  tmp = from_ascii((char const   *)(ascii_header.c_mode), sizeof(ascii_header.c_mode),
                   4U);
#line 1136
  file_hdr->c_mode = (mode_t )tmp;
#line 1137
  tmp___0 = from_ascii((char const   *)(ascii_header.c_uid), sizeof(ascii_header.c_uid),
                       4U);
#line 1137
  file_hdr->c_uid = (uid_t )tmp___0;
#line 1138
  tmp___1 = from_ascii((char const   *)(ascii_header.c_gid), sizeof(ascii_header.c_gid),
                       4U);
#line 1138
  file_hdr->c_gid = (gid_t )tmp___1;
#line 1139
  file_hdr->c_nlink = from_ascii((char const   *)(ascii_header.c_nlink), sizeof(ascii_header.c_nlink),
                                 4U);
#line 1140
  tmp___2 = from_ascii((char const   *)(ascii_header.c_mtime), sizeof(ascii_header.c_mtime),
                       4U);
#line 1140
  file_hdr->c_mtime = (time_t )tmp___2;
#line 1141
  tmp___3 = from_ascii((char const   *)(ascii_header.c_filesize), sizeof(ascii_header.c_filesize),
                       4U);
#line 1141
  file_hdr->c_filesize = (off_t )tmp___3;
#line 1142
  tmp___4 = from_ascii((char const   *)(ascii_header.c_dev_maj), sizeof(ascii_header.c_dev_maj),
                       4U);
#line 1142
  file_hdr->c_dev_maj = (long )tmp___4;
#line 1143
  tmp___5 = from_ascii((char const   *)(ascii_header.c_dev_min), sizeof(ascii_header.c_dev_min),
                       4U);
#line 1143
  file_hdr->c_dev_min = (long )tmp___5;
#line 1144
  tmp___6 = from_ascii((char const   *)(ascii_header.c_rdev_maj), sizeof(ascii_header.c_rdev_maj),
                       4U);
#line 1144
  file_hdr->c_rdev_maj = (long )tmp___6;
#line 1145
  tmp___7 = from_ascii((char const   *)(ascii_header.c_rdev_min), sizeof(ascii_header.c_rdev_min),
                       4U);
#line 1145
  file_hdr->c_rdev_min = (long )tmp___7;
#line 1146
  file_hdr->c_namesize = from_ascii((char const   *)(ascii_header.c_namesize), sizeof(ascii_header.c_namesize),
                                    4U);
#line 1147
  file_hdr->c_chksum = from_ascii((char const   *)(ascii_header.c_chksum), sizeof(ascii_header.c_chksum),
                                  4U);
  }
#line 1150
  if ((unsigned long )file_hdr->c_name != (unsigned long )((void *)0)) {
    {
#line 1151
    free((void *)file_hdr->c_name);
    }
  }
  {
#line 1152
  tmp___8 = xmalloc(file_hdr->c_namesize);
#line 1152
  file_hdr->c_name = (char *)tmp___8;
#line 1153
  tape_buffered_read(file_hdr->c_name, in_des, (long )file_hdr->c_namesize);
#line 1158
  tape_skip_padding(in_des, (off_t )(file_hdr->c_namesize + 110UL));
  }
#line 1159
  return;
}
}
#line 1178 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
static int warned  =    0;
#line 1165 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void read_in_binary(struct cpio_file_stat *file_hdr , struct old_cpio_header *short_hdr ,
                    int in_des ) 
{ 
  char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *__cil_tmp12 ;

  {
  {
#line 1170
  file_hdr->c_magic = short_hdr->c_magic;
#line 1172
  tape_buffered_read((char *)short_hdr + 6, in_des, (off_t )(sizeof(*short_hdr) - 6UL));
  }
#line 1176
  if ((int )file_hdr->c_magic == (((29127 << 8) & 65280) | ((29127 >> 8) & 255))) {
#line 1182
    if (warned == 0) {
      {
#line 1184
      tmp = gettext("warning: archive header has reverse byte-order");
#line 1184
      error(0, 0, (char const   *)tmp);
#line 1185
      warned = 1;
      }
    }
    {
#line 1187
    swab_array((char *)short_hdr, 13);
    }
  }
  {
#line 1190
  tmp___0 = (unsigned int )gnu_dev_major((unsigned long long )short_hdr->c_dev);
#line 1190
  file_hdr->c_dev_maj = (long )tmp___0;
#line 1191
  tmp___1 = (unsigned int )gnu_dev_minor((unsigned long long )short_hdr->c_dev);
#line 1191
  file_hdr->c_dev_min = (long )tmp___1;
#line 1192
  file_hdr->c_ino = (ino_t )short_hdr->c_ino;
#line 1193
  file_hdr->c_mode = (mode_t )short_hdr->c_mode;
#line 1194
  file_hdr->c_uid = (uid_t )short_hdr->c_uid;
#line 1195
  file_hdr->c_gid = (gid_t )short_hdr->c_gid;
#line 1196
  file_hdr->c_nlink = (size_t )short_hdr->c_nlink;
#line 1197
  tmp___2 = (unsigned int )gnu_dev_major((unsigned long long )short_hdr->c_rdev);
#line 1197
  file_hdr->c_rdev_maj = (long )tmp___2;
#line 1198
  tmp___3 = (unsigned int )gnu_dev_minor((unsigned long long )short_hdr->c_rdev);
#line 1198
  file_hdr->c_rdev_min = (long )tmp___3;
#line 1199
  file_hdr->c_mtime = (time_t )(((unsigned long )short_hdr->c_mtimes[0] << 16) | (unsigned long )short_hdr->c_mtimes[1]);
#line 1202
  file_hdr->c_namesize = (size_t )short_hdr->c_namesize;
#line 1203
  file_hdr->c_filesize = (off_t )(((unsigned long )short_hdr->c_filesizes[0] << 16) | (unsigned long )short_hdr->c_filesizes[1]);
  }
#line 1207
  if ((unsigned long )file_hdr->c_name != (unsigned long )((void *)0)) {
    {
#line 1208
    free((void *)file_hdr->c_name);
    }
  }
  {
#line 1209
  tmp___4 = xmalloc(file_hdr->c_namesize);
#line 1209
  file_hdr->c_name = (char *)tmp___4;
#line 1210
  tape_buffered_read(file_hdr->c_name, in_des, (long )file_hdr->c_namesize);
  }
#line 1215
  if (file_hdr->c_namesize % 2UL) {
    {
#line 1216
    tape_toss_input(in_des, 1L);
    }
  }
  {
#line 1232
  if ((file_hdr->c_mode & 61440U) == 4096U) {
#line 1232
    goto case_4096;
  }
#line 1232
  if ((file_hdr->c_mode & 61440U) == 49152U) {
#line 1232
    goto case_4096;
  }
#line 1232
  if ((file_hdr->c_mode & 61440U) == 24576U) {
#line 1232
    goto case_4096;
  }
#line 1232
  if ((file_hdr->c_mode & 61440U) == 8192U) {
#line 1232
    goto case_4096;
  }
#line 1243
  goto switch_default;
  case_4096: /* CIL Label */ 
  case_49152: /* CIL Label */ 
  case_24576: /* CIL Label */ 
  case_8192: /* CIL Label */ 
#line 1234
  if (file_hdr->c_filesize != 0L) {
#line 1234
    if (file_hdr->c_rdev_maj == 0L) {
#line 1234
      if (file_hdr->c_rdev_min == 1L) {
        {
#line 1238
        tmp___5 = (unsigned int )gnu_dev_major((unsigned long long )file_hdr->c_filesize);
#line 1238
        file_hdr->c_rdev_maj = (long )tmp___5;
#line 1239
        tmp___6 = (unsigned int )gnu_dev_minor((unsigned long long )file_hdr->c_filesize);
#line 1239
        file_hdr->c_rdev_min = (long )tmp___6;
#line 1240
        file_hdr->c_filesize = (off_t )0;
        }
      }
    }
  }
#line 1242
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1244
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1246
  return;
}
}
#line 1251 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void swab_array(char *ptr , int count ) 
{ 
  char tmp ;
  int tmp___0 ;

  {
  {
#line 1256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1256
    tmp___0 = count;
#line 1256
    count --;
#line 1256
    if (! (tmp___0 > 0)) {
#line 1256
      goto while_break;
    }
#line 1258
    tmp = *ptr;
#line 1259
    *ptr = *(ptr + 1);
#line 1260
    ptr ++;
#line 1261
    *ptr = tmp;
#line 1262
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1264
  return;
}
}
#line 1269 "/home/wslee/gnu_benchmarks/cpio-2.11/src/copyin.c"
void process_copy_in(void) 
{ 
  char done ;
  FILE *tty_in ;
  FILE *tty_out ;
  FILE *rename_in ;
  struct stat file_stat ;
  struct cpio_file_stat file_hdr ;
  int in_file_des ;
  char skip_file ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t blocks ;
  char *tmp___11 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 1272
  done = (char)0;
#line 1273
  tty_in = (FILE *)((void *)0);
#line 1274
  tty_out = (FILE *)((void *)0);
#line 1275
  rename_in = (FILE *)((void *)0);
#line 1282
  newdir_umask = umask((__mode_t )0);
  }
#line 1286
  if (pattern_file_name) {
    {
#line 1288
    read_pattern_file();
    }
  }
#line 1290
  file_hdr.c_name = (char *)((void *)0);
#line 1292
  if (rename_batch_file) {
    {
#line 1294
    rename_in = fopen((char const   */* __restrict  */)rename_batch_file, (char const   */* __restrict  */)"r");
    }
#line 1295
    if ((unsigned long )rename_in == (unsigned long )((void *)0)) {
      {
#line 1297
      tmp = __errno_location();
#line 1297
      error(2, *tmp, "/dev/tty");
      }
    }
  } else
#line 1300
  if (rename_flag) {
    {
#line 1303
    tty_in = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
    }
#line 1304
    if ((unsigned long )tty_in == (unsigned long )((void *)0)) {
      {
#line 1306
      tmp___0 = __errno_location();
#line 1306
      error(2, *tmp___0, "/dev/tty");
      }
    }
    {
#line 1308
    tty_out = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w");
    }
#line 1309
    if ((unsigned long )tty_out == (unsigned long )((void *)0)) {
      {
#line 1311
      tmp___1 = __errno_location();
#line 1311
      error(2, *tmp___1, "/dev/tty");
      }
    }
  }
#line 1316
  if (table_flag) {
#line 1316
    if (verbose_flag) {
      {
#line 1318
      time(& current_time);
      }
    }
  }
#line 1322
  in_file_des = archive_des;
#line 1323
  if (in_file_des >= 1 << 30) {
#line 1325
    input_is_special = (char)1;
#line 1326
    input_is_seekable = (char)0;
  } else {
    {
#line 1330
    tmp___4 = fstat(in_file_des, & file_stat);
    }
#line 1330
    if (tmp___4) {
      {
#line 1331
      tmp___2 = gettext("standard input is closed");
#line 1331
      tmp___3 = __errno_location();
#line 1331
      error(1, *tmp___3, (char const   *)tmp___2);
      }
    }
#line 1332
    if ((file_stat.st_mode & 61440U) == 24576U) {
#line 1332
      tmp___5 = 1;
    } else
#line 1332
    if ((file_stat.st_mode & 61440U) == 8192U) {
#line 1332
      tmp___5 = 1;
    } else {
#line 1332
      tmp___5 = 0;
    }
#line 1332
    input_is_special = (char )tmp___5;
#line 1337
    input_is_seekable = (char )((file_stat.st_mode & 61440U) == 32768U);
  }
#line 1339
  output_is_seekable = (char)1;
  {
#line 1342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1342
    if (! (! done)) {
#line 1342
      goto while_break;
    }
    {
#line 1344
    swapping_bytes = 0;
#line 1344
    swapping_halfwords = swapping_bytes;
#line 1347
    read_in_header(& file_hdr, in_file_des);
#line 1371
    tmp___6 = strcmp("TRAILER!!!", (char const   *)file_hdr.c_name);
    }
#line 1371
    if (tmp___6 == 0) {
#line 1373
      done = (char)1;
#line 1374
      goto while_break;
    }
    {
#line 1377
    cpio_safer_name_suffix(file_hdr.c_name, (_Bool)0, (_Bool )(! no_abs_paths_flag),
                           (_Bool)0);
    }
#line 1381
    if (num_patterns <= 0) {
#line 1382
      skip_file = (char)0;
    } else {
#line 1385
      skip_file = (char )copy_matching_files;
#line 1386
      i = 0;
      {
#line 1386
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1386
        if (i < num_patterns) {
#line 1386
          if (! ((int )skip_file == copy_matching_files)) {
#line 1386
            goto while_break___0;
          }
        } else {
#line 1386
          goto while_break___0;
        }
        {
#line 1389
        tmp___7 = fnmatch((char const   *)*(save_patterns + i), (char const   *)file_hdr.c_name,
                          0);
        }
#line 1389
        if (tmp___7 == 0) {
#line 1390
          skip_file = (char )(! copy_matching_files);
        }
#line 1386
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1394
    if (skip_file) {
#line 1400
      if (file_hdr.c_nlink > 1UL) {
#line 1400
        if ((unsigned int )archive_format == 3U) {
#line 1400
          goto _L;
        } else
#line 1400
        if ((unsigned int )archive_format == 4U) {
          _L: /* CIL Label */ 
          {
#line 1403
          tmp___8 = create_defered_links_to_skipped(& file_hdr, in_file_des);
          }
#line 1403
          if (tmp___8 < 0) {
            {
#line 1405
            tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1406
            tape_skip_padding(in_file_des, file_hdr.c_filesize);
            }
          }
        } else {
          {
#line 1411
          tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1412
          tape_skip_padding(in_file_des, file_hdr.c_filesize);
          }
        }
      } else {
        {
#line 1411
        tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1412
        tape_skip_padding(in_file_des, file_hdr.c_filesize);
        }
      }
    } else
#line 1415
    if (table_flag) {
      {
#line 1417
      list_file(& file_hdr, in_file_des);
      }
    } else
#line 1419
    if (append_flag) {
      {
#line 1421
      tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1422
      tape_skip_padding(in_file_des, file_hdr.c_filesize);
      }
    } else
#line 1424
    if (only_verify_crc_flag) {
#line 1427
      if ((file_hdr.c_mode & 61440U) == 40960U) {
#line 1429
        if ((unsigned int )archive_format != 5U) {
#line 1429
          if ((unsigned int )archive_format != 6U) {
            {
#line 1431
            tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1432
            tape_skip_padding(in_file_des, file_hdr.c_filesize);
            }
#line 1433
            goto while_continue;
          }
        }
      }
      {
#line 1437
      crc = 0UL;
#line 1438
      tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1439
      tape_skip_padding(in_file_des, file_hdr.c_filesize);
      }
#line 1440
      if (crc != file_hdr.c_chksum) {
        {
#line 1442
        tmp___9 = gettext("%s: checksum error (0x%lx, should be 0x%lx)");
#line 1442
        error(0, 0, (char const   *)tmp___9, file_hdr.c_name, crc, file_hdr.c_chksum);
        }
      }
#line 1447
      if (verbose_flag) {
        {
#line 1449
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                file_hdr.c_name);
        }
      }
#line 1451
      if (dot_flag) {
        {
#line 1453
        fputc_unlocked('.', stderr);
        }
      }
    } else {
#line 1461
      if (rename_flag) {
#line 1461
        goto _L___0;
      } else
#line 1461
      if (rename_batch_file) {
        _L___0: /* CIL Label */ 
        {
#line 1463
        tmp___10 = query_rename(& file_hdr, tty_in, tty_out, rename_in);
        }
#line 1463
        if (tmp___10 < 0) {
          {
#line 1465
          tape_toss_input(in_file_des, file_hdr.c_filesize);
#line 1466
          tape_skip_padding(in_file_des, file_hdr.c_filesize);
          }
#line 1467
          goto while_continue;
        }
      }
      {
#line 1471
      copyin_file(& file_hdr, in_file_des);
      }
#line 1473
      if (verbose_flag) {
        {
#line 1474
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                file_hdr.c_name);
        }
      }
#line 1475
      if (dot_flag) {
        {
#line 1476
        fputc_unlocked('.', stderr);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1480
  if (dot_flag) {
    {
#line 1481
    fputc_unlocked('\n', stderr);
    }
  }
  {
#line 1483
  apply_delayed_set_stat();
  }
#line 1485
  if (append_flag) {
#line 1486
    return;
  }
#line 1488
  if ((unsigned int )archive_format == 3U) {
    {
#line 1490
    create_final_defers();
    }
  } else
#line 1488
  if ((unsigned int )archive_format == 4U) {
    {
#line 1490
    create_final_defers();
    }
  }
#line 1492
  if (! quiet_flag) {
    {
#line 1495
    blocks = (size_t )(((input_bytes + (off_t )io_block_size) - 1L) / (off_t )io_block_size);
#line 1496
    tmp___11 = ngettext("%lu block\n", "%lu blocks\n", blocks);
#line 1496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            blocks);
    }
  }
#line 1501
  return;
}
}
