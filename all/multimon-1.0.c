/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
enum gen_type {
    gentype_dtmf = 0,
    gentype_sine = 1,
    gentype_zvei = 2,
    gentype_ccir = 3,
    gentype_hdlc = 4
} ;
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_dtmf_2 {
   int duration ;
   int pause ;
   char str[256] ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_sine_3 {
   int duration ;
   int freq ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_zvei_4 {
   int duration ;
   int pause ;
   char str[256] ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_ccir_5 {
   int duration ;
   int pause ;
   char str[256] ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_hdlc_6 {
   int modulation ;
   int txdelay ;
   int pktlen ;
   unsigned char pkt[256] ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
union __anonunion_p_1 {
   struct __anonstruct_dtmf_2 dtmf ;
   struct __anonstruct_sine_3 sine ;
   struct __anonstruct_zvei_4 zvei ;
   struct __anonstruct_ccir_5 ccir ;
   struct __anonstruct_hdlc_6 hdlc ;
};
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct gen_params {
   enum gen_type type ;
   int ampl ;
   union __anonunion_p_1 p ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_dtmf_8 {
   int ch_idx ;
   int ph_row ;
   int ph_col ;
   int phinc_row ;
   int phinc_col ;
   int time ;
   int time2 ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_sine_9 {
   int ph ;
   int phinc ;
   int time ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_zvei_10 {
   int ch_idx ;
   int ph ;
   int phinc ;
   int time ;
   int time2 ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_ccir_11 {
   int ch_idx ;
   int ph ;
   int phinc ;
   int time ;
   int time2 ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct __anonstruct_hdlc_12 {
   int lastb ;
   int ch_idx ;
   int bitmask ;
   unsigned int ph ;
   unsigned int phinc ;
   unsigned int bitph ;
   unsigned int datalen ;
   unsigned char data[512] ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
union __anonunion_s_7 {
   struct __anonstruct_dtmf_8 dtmf ;
   struct __anonstruct_sine_9 sine ;
   struct __anonstruct_zvei_10 zvei ;
   struct __anonstruct_ccir_11 ccir ;
   struct __anonstruct_hdlc_12 hdlc ;
};
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
struct gen_state {
   union __anonunion_s_7 s ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 108 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
struct hdlctx {
   unsigned int bitstream ;
   unsigned int bitbuf ;
   int numbits ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 72 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
typedef void (*t_init_procs)(struct gen_params * , struct gen_state * );
#line 73 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
typedef int (*t_gen_procs)(short * , int  , struct gen_params * , struct gen_state * );
#line 179 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
union __anonunion_b_67 {
   short s[8192] ;
   unsigned char b[8192] ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_param;
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l2_state_hdlc {
   unsigned char rxbuf[512] ;
   unsigned char *rxptr ;
   unsigned int rxstate ;
   unsigned int rxbitstream ;
   unsigned int rxbitbuf ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l2_pocsag_rx {
   unsigned char rx_sync ;
   unsigned char rx_word ;
   unsigned char rx_bit ;
   char func ;
   unsigned long adr ;
   unsigned char buffer[128] ;
   unsigned int numnibbles ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l2_state_pocsag {
   unsigned long rx_data ;
   struct l2_pocsag_rx rx[2] ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
union __anonunion_l2_1 {
   struct l2_state_hdlc hdlc ;
   struct l2_state_pocsag pocsag ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_poc5 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int subsamp ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_poc12 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int subsamp ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_poc24 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_eas {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int lasts ;
   unsigned int subsamp ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_afsk12 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int lasts ;
   unsigned int subsamp ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_afsk24 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int lasts ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_hapn48 {
   unsigned int shreg ;
   unsigned int sphase ;
   float lvllo ;
   float lvlhi ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_fsk96 {
   unsigned int dcd_shreg ;
   unsigned int sphase ;
   unsigned int descram ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_dtmf {
   unsigned int ph[8] ;
   float energy[4] ;
   float tenergy[4][16] ;
   int blkcount ;
   int lastch ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_zvei {
   unsigned int ph[16] ;
   float energy[4] ;
   float tenergy[4][32] ;
   int blkcount ;
   int lastch ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_ccir {
   unsigned int ph[16] ;
   float energy[4] ;
   float tenergy[4][32] ;
   int blkcount ;
   int lastch ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct l1_state_scope {
   int datalen ;
   int dispnum ;
   float data[512] ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
union __anonunion_l1_2 {
   struct l1_state_poc5 poc5 ;
   struct l1_state_poc12 poc12 ;
   struct l1_state_poc24 poc24 ;
   struct l1_state_eas eas ;
   struct l1_state_afsk12 afsk12 ;
   struct l1_state_afsk24 afsk24 ;
   struct l1_state_hapn48 hapn48 ;
   struct l1_state_fsk96 fsk96 ;
   struct l1_state_dtmf dtmf ;
   struct l1_state_zvei zvei ;
   struct l1_state_ccir ccir ;
   struct l1_state_scope scope ;
};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_state {
   struct demod_param  const  *dem_par ;
   union __anonunion_l2_1 l2 ;
   union __anonunion_l1_2 l1 ;
};
#line 143 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_param {
   char const   *name ;
   unsigned int samplerate ;
   unsigned int overlap ;
   void (*init)(struct demod_state *s ) ;
   void (*demod)(struct demod_state *s , float *buffer , int length ) ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 173 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
union __anonunion_b_55 {
   short s[8192] ;
   unsigned char b[8192] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_5 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_5 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_42 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_43 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_42 __wait_terminated ;
   struct __anonstruct___wait_stopped_43 __wait_stopped ;
};
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_44 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_45 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_46 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_47 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_48 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_49 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_50 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_51 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_52 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_53 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_54 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_55 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_56 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_57 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_44 __annonCompField2 ;
   union __anonunion____missing_field_name_45 __annonCompField3 ;
   union __anonunion____missing_field_name_46 __annonCompField4 ;
   union __anonunion____missing_field_name_47 __annonCompField5 ;
   union __anonunion____missing_field_name_48 __annonCompField6 ;
   union __anonunion____missing_field_name_49 __annonCompField7 ;
   union __anonunion____missing_field_name_50 __annonCompField8 ;
   union __anonunion____missing_field_name_51 __annonCompField9 ;
   union __anonunion____missing_field_name_52 __annonCompField10 ;
   union __anonunion____missing_field_name_53 __annonCompField11 ;
   union __anonunion____missing_field_name_54 __annonCompField12 ;
   union __anonunion____missing_field_name_55 __annonCompField13 ;
   union __anonunion____missing_field_name_56 __annonCompField14 ;
   union __anonunion____missing_field_name_57 __annonCompField15 ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_72 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_72 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_73 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_73 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_74 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_74 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_75 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_75 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_76 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_76 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_77 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_77 XSetWindowAttributes;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_78 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_78 XWindowAttributes;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_82 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_82 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_91 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_91 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_92 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_93 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_94 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_95 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_96 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_97 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_98 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_99 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_100 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_101 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_102 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_103 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_104 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_105 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_106 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_107 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_108 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_109 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_109 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_110 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_111 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_112 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_113 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_113 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_114 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_114 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_115 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_115 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_116 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_116 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_117 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_117 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_118 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_118 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_120 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_119 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_120 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_119 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_121 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_121 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_122 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_122 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_123 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_123 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_124 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_124 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_125 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_125 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_151 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_150 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_151 min_aspect ;
   struct __anonstruct_min_aspect_151 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_150 XSizeHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 46 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
union comdata {
   short s[512] ;
   unsigned char b[0] ;
};
#line 74 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
struct xdisp {
   int used ;
   pid_t pid ;
   int cmdfd ;
   int datafd ;
};
#line 135 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
struct trtab {
   unsigned char code ;
   char *str ;
};
#line 5 "/home/wheatley/newnew/temp/multimon-1.0/costabi.c"
int const   costabi[1024]  = 
#line 5 "/home/wheatley/newnew/temp/multimon-1.0/costabi.c"
  {      32767,      32766,      32764,      32761, 
        32757,      32751,      32744,      32736, 
        32727,      32717,      32705,      32692, 
        32678,      32662,      32646,      32628, 
        32609,      32588,      32567,      32544, 
        32520,      32495,      32468,      32441, 
        32412,      32382,      32350,      32318, 
        32284,      32249,      32213,      32176, 
        32137,      32097,      32056,      32014, 
        31970,      31926,      31880,      31833, 
        31785,      31735,      31684,      31633, 
        31580,      31525,      31470,      31413, 
        31356,      31297,      31236,      31175, 
        31113,      31049,      30984,      30918, 
        30851,      30783,      30713,      30643, 
        30571,      30498,      30424,      30349, 
        30272,      30195,      30116,      30036, 
        29955,      29873,      29790,      29706, 
        29621,      29534,      29446,      29358, 
        29268,      29177,      29085,      28992, 
        28897,      28802,      28706,      28608, 
        28510,      28410,      28309,      28208, 
        28105,      28001,      27896,      27790, 
        27683,      27575,      27466,      27355, 
        27244,      27132,      27019,      26905, 
        26789,      26673,      26556,      26437, 
        26318,      26198,      26077,      25954, 
        25831,      25707,      25582,      25456, 
        25329,      25201,      25072,      24942, 
        24811,      24679,      24546,      24413, 
        24278,      24143,      24006,      23869, 
        23731,      23592,      23452,      23311, 
        23169,      23027,      22883,      22739, 
        22594,      22448,      22301,      22153, 
        22004,      21855,      21705,      21554, 
        21402,      21249,      21096,      20942, 
        20787,      20631,      20474,      20317, 
        20159,      20000,      19840,      19680, 
        19519,      19357,      19194,      19031, 
        18867,      18702,      18537,      18371, 
        18204,      18036,      17868,      17699, 
        17530,      17360,      17189,      17017, 
        16845,      16672,      16499,      16325, 
        16150,      15975,      15799,      15623, 
        15446,      15268,      15090,      14911, 
        14732,      14552,      14372,      14191, 
        14009,      13827,      13645,      13462, 
        13278,      13094,      12909,      12724, 
        12539,      12353,      12166,      11980, 
        11792,      11604,      11416,      11227, 
        11038,      10849,      10659,      10469, 
        10278,      10087,      9895,      9703, 
        9511,      9319,      9126,      8932, 
        8739,      8545,      8351,      8156, 
        7961,      7766,      7571,      7375, 
        7179,      6982,      6786,      6589, 
        6392,      6195,      5997,      5799, 
        5601,      5403,      5205,      5006, 
        4807,      4608,      4409,      4210, 
        4011,      3811,      3611,      3411, 
        3211,      3011,      2811,      2610, 
        2410,      2209,      2009,      1808, 
        1607,      1406,      1206,      1005, 
        804,      603,      402,      201, 
        0,      -201,      -402,      -603, 
        -804,      -1005,      -1206,      -1406, 
        -1607,      -1808,      -2009,      -2209, 
        -2410,      -2610,      -2811,      -3011, 
        -3211,      -3411,      -3611,      -3811, 
        -4011,      -4210,      -4409,      -4608, 
        -4807,      -5006,      -5205,      -5403, 
        -5601,      -5799,      -5997,      -6195, 
        -6392,      -6589,      -6786,      -6982, 
        -7179,      -7375,      -7571,      -7766, 
        -7961,      -8156,      -8351,      -8545, 
        -8739,      -8932,      -9126,      -9319, 
        -9511,      -9703,      -9895,      -10087, 
        -10278,      -10469,      -10659,      -10849, 
        -11038,      -11227,      -11416,      -11604, 
        -11792,      -11980,      -12166,      -12353, 
        -12539,      -12724,      -12909,      -13094, 
        -13278,      -13462,      -13645,      -13827, 
        -14009,      -14191,      -14372,      -14552, 
        -14732,      -14911,      -15090,      -15268, 
        -15446,      -15623,      -15799,      -15975, 
        -16150,      -16325,      -16499,      -16672, 
        -16845,      -17017,      -17189,      -17360, 
        -17530,      -17699,      -17868,      -18036, 
        -18204,      -18371,      -18537,      -18702, 
        -18867,      -19031,      -19194,      -19357, 
        -19519,      -19680,      -19840,      -20000, 
        -20159,      -20317,      -20474,      -20631, 
        -20787,      -20942,      -21096,      -21249, 
        -21402,      -21554,      -21705,      -21855, 
        -22004,      -22153,      -22301,      -22448, 
        -22594,      -22739,      -22883,      -23027, 
        -23169,      -23311,      -23452,      -23592, 
        -23731,      -23869,      -24006,      -24143, 
        -24278,      -24413,      -24546,      -24679, 
        -24811,      -24942,      -25072,      -25201, 
        -25329,      -25456,      -25582,      -25707, 
        -25831,      -25954,      -26077,      -26198, 
        -26318,      -26437,      -26556,      -26673, 
        -26789,      -26905,      -27019,      -27132, 
        -27244,      -27355,      -27466,      -27575, 
        -27683,      -27790,      -27896,      -28001, 
        -28105,      -28208,      -28309,      -28410, 
        -28510,      -28608,      -28706,      -28802, 
        -28897,      -28992,      -29085,      -29177, 
        -29268,      -29358,      -29446,      -29534, 
        -29621,      -29706,      -29790,      -29873, 
        -29955,      -30036,      -30116,      -30195, 
        -30272,      -30349,      -30424,      -30498, 
        -30571,      -30643,      -30713,      -30783, 
        -30851,      -30918,      -30984,      -31049, 
        -31113,      -31175,      -31236,      -31297, 
        -31356,      -31413,      -31470,      -31525, 
        -31580,      -31633,      -31684,      -31735, 
        -31785,      -31833,      -31880,      -31926, 
        -31970,      -32014,      -32056,      -32097, 
        -32137,      -32176,      -32213,      -32249, 
        -32284,      -32318,      -32350,      -32382, 
        -32412,      -32441,      -32468,      -32495, 
        -32520,      -32544,      -32567,      -32588, 
        -32609,      -32628,      -32646,      -32662, 
        -32678,      -32692,      -32705,      -32717, 
        -32727,      -32736,      -32744,      -32751, 
        -32757,      -32761,      -32764,      -32766, 
        -32767,      -32766,      -32764,      -32761, 
        -32757,      -32751,      -32744,      -32736, 
        -32727,      -32717,      -32705,      -32692, 
        -32678,      -32662,      -32646,      -32628, 
        -32609,      -32588,      -32567,      -32544, 
        -32520,      -32495,      -32468,      -32441, 
        -32412,      -32382,      -32350,      -32318, 
        -32284,      -32249,      -32213,      -32176, 
        -32137,      -32097,      -32056,      -32014, 
        -31970,      -31926,      -31880,      -31833, 
        -31785,      -31735,      -31684,      -31633, 
        -31580,      -31525,      -31470,      -31413, 
        -31356,      -31297,      -31236,      -31175, 
        -31113,      -31049,      -30984,      -30918, 
        -30851,      -30783,      -30713,      -30643, 
        -30571,      -30498,      -30424,      -30349, 
        -30272,      -30195,      -30116,      -30036, 
        -29955,      -29873,      -29790,      -29706, 
        -29621,      -29534,      -29446,      -29358, 
        -29268,      -29177,      -29085,      -28992, 
        -28897,      -28802,      -28706,      -28608, 
        -28510,      -28410,      -28309,      -28208, 
        -28105,      -28001,      -27896,      -27790, 
        -27683,      -27575,      -27466,      -27355, 
        -27244,      -27132,      -27019,      -26905, 
        -26789,      -26673,      -26556,      -26437, 
        -26318,      -26198,      -26077,      -25954, 
        -25831,      -25707,      -25582,      -25456, 
        -25329,      -25201,      -25072,      -24942, 
        -24811,      -24679,      -24546,      -24413, 
        -24278,      -24143,      -24006,      -23869, 
        -23731,      -23592,      -23452,      -23311, 
        -23169,      -23027,      -22883,      -22739, 
        -22594,      -22448,      -22301,      -22153, 
        -22004,      -21855,      -21705,      -21554, 
        -21402,      -21249,      -21096,      -20942, 
        -20787,      -20631,      -20474,      -20317, 
        -20159,      -20000,      -19840,      -19680, 
        -19519,      -19357,      -19194,      -19031, 
        -18867,      -18702,      -18537,      -18371, 
        -18204,      -18036,      -17868,      -17699, 
        -17530,      -17360,      -17189,      -17017, 
        -16845,      -16672,      -16499,      -16325, 
        -16150,      -15975,      -15799,      -15623, 
        -15446,      -15268,      -15090,      -14911, 
        -14732,      -14552,      -14372,      -14191, 
        -14009,      -13827,      -13645,      -13462, 
        -13278,      -13094,      -12909,      -12724, 
        -12539,      -12353,      -12166,      -11980, 
        -11792,      -11604,      -11416,      -11227, 
        -11038,      -10849,      -10659,      -10469, 
        -10278,      -10087,      -9895,      -9703, 
        -9511,      -9319,      -9126,      -8932, 
        -8739,      -8545,      -8351,      -8156, 
        -7961,      -7766,      -7571,      -7375, 
        -7179,      -6982,      -6786,      -6589, 
        -6392,      -6195,      -5997,      -5799, 
        -5601,      -5403,      -5205,      -5006, 
        -4807,      -4608,      -4409,      -4210, 
        -4011,      -3811,      -3611,      -3411, 
        -3211,      -3011,      -2811,      -2610, 
        -2410,      -2209,      -2009,      -1808, 
        -1607,      -1406,      -1206,      -1005, 
        -804,      -603,      -402,      -201, 
        0,      201,      402,      603, 
        804,      1005,      1206,      1406, 
        1607,      1808,      2009,      2209, 
        2410,      2610,      2811,      3011, 
        3211,      3411,      3611,      3811, 
        4011,      4210,      4409,      4608, 
        4807,      5006,      5205,      5403, 
        5601,      5799,      5997,      6195, 
        6392,      6589,      6786,      6982, 
        7179,      7375,      7571,      7766, 
        7961,      8156,      8351,      8545, 
        8739,      8932,      9126,      9319, 
        9511,      9703,      9895,      10087, 
        10278,      10469,      10659,      10849, 
        11038,      11227,      11416,      11604, 
        11792,      11980,      12166,      12353, 
        12539,      12724,      12909,      13094, 
        13278,      13462,      13645,      13827, 
        14009,      14191,      14372,      14552, 
        14732,      14911,      15090,      15268, 
        15446,      15623,      15799,      15975, 
        16150,      16325,      16499,      16672, 
        16845,      17017,      17189,      17360, 
        17530,      17699,      17868,      18036, 
        18204,      18371,      18537,      18702, 
        18867,      19031,      19194,      19357, 
        19519,      19680,      19840,      20000, 
        20159,      20317,      20474,      20631, 
        20787,      20942,      21096,      21249, 
        21402,      21554,      21705,      21855, 
        22004,      22153,      22301,      22448, 
        22594,      22739,      22883,      23027, 
        23169,      23311,      23452,      23592, 
        23731,      23869,      24006,      24143, 
        24278,      24413,      24546,      24679, 
        24811,      24942,      25072,      25201, 
        25329,      25456,      25582,      25707, 
        25831,      25954,      26077,      26198, 
        26318,      26437,      26556,      26673, 
        26789,      26905,      27019,      27132, 
        27244,      27355,      27466,      27575, 
        27683,      27790,      27896,      28001, 
        28105,      28208,      28309,      28410, 
        28510,      28608,      28706,      28802, 
        28897,      28992,      29085,      29177, 
        29268,      29358,      29446,      29534, 
        29621,      29706,      29790,      29873, 
        29955,      30036,      30116,      30195, 
        30272,      30349,      30424,      30498, 
        30571,      30643,      30713,      30783, 
        30851,      30918,      30984,      31049, 
        31113,      31175,      31236,      31297, 
        31356,      31413,      31470,      31525, 
        31580,      31633,      31684,      31735, 
        31785,      31833,      31880,      31926, 
        31970,      32014,      32056,      32097, 
        32137,      32176,      32213,      32249, 
        32284,      32318,      32350,      32382, 
        32412,      32441,      32468,      32495, 
        32520,      32544,      32567,      32588, 
        32609,      32628,      32646,      32662, 
        32678,      32692,      32705,      32717, 
        32727,      32736,      32744,      32751, 
        32757,      32761,      32764,      32766};
#line 105 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
void gen_init_ccir(struct gen_params *p , struct gen_state *s ) ;
#line 106
int gen_ccir(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 36 "/home/wheatley/newnew/temp/multimon-1.0/gen_ccir.c"
static unsigned int const   ccir_freq[16]  = 
#line 36 "/home/wheatley/newnew/temp/multimon-1.0/gen_ccir.c"
  {      (unsigned int const   )(((float )1981 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1124 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1197 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1275 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )1358 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1446 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1540 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1640 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )1747 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1860 * (float )65536) / (float )22050),      (unsigned int const   )(((float )2400 * (float )65536) / (float )22050),      (unsigned int const   )(((float )930 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )2247 * (float )65536) / (float )22050),      (unsigned int const   )(((float )991 * (float )65536) / (float )22050),      (unsigned int const   )(((float )2110 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1055 * (float )65536) / (float )22050)};
#line 50 "/home/wheatley/newnew/temp/multimon-1.0/gen_ccir.c"
void gen_init_ccir(struct gen_params *p , struct gen_state *s ) 
{ 


  {
  {
#line 52
  memset((void *)s, 0, sizeof(struct gen_state ));
  }
#line 53
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/multimon-1.0/gen_ccir.c"
int gen_ccir(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) 
{ 
  char c ;
  int num ;
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 58
  num = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (buflen > 0)) {
#line 60
      goto while_break;
    }
#line 61
    if (s->s.ccir.time <= 0) {
#line 62
      c = p->p.ccir.str[s->s.ccir.ch_idx];
#line 63
      if (! c) {
#line 64
        return (num);
      }
      {
#line 65
      (s->s.ccir.ch_idx) ++;
#line 66
      tmp___0 = __ctype_b_loc();
      }
#line 66
      if ((int const   )*(*tmp___0 + (int )c) & 4096) {
#line 70
        s->s.ccir.time = p->p.ccir.duration + p->p.ccir.pause;
#line 71
        s->s.ccir.time2 = p->p.ccir.duration;
#line 72
        if ((int )c >= 48) {
#line 72
          if ((int )c <= 57) {
#line 73
            i = (int )c - 48;
          } else {
#line 72
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 74
        if ((int )c >= 65) {
#line 74
          if ((int )c <= 70) {
#line 75
            i = ((int )c - 65) + 10;
          } else {
#line 77
            i = ((int )c - 97) + 10;
          }
        } else {
#line 77
          i = ((int )c - 97) + 10;
        }
#line 78
        s->s.ccir.phinc = (int )ccir_freq[i & 15];
      } else {
        {
#line 67
        tmp = 1;
#line 67
        s->s.ccir.time2 = tmp;
#line 67
        s->s.ccir.time = tmp;
#line 68
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: ccir; invalid char \'%c\'\n",
                (int )c);
        }
      }
    } else
#line 80
    if (! s->s.ccir.time2) {
#line 81
      s->s.ccir.phinc = 0;
#line 82
      s->s.ccir.ph = 49152;
    }
#line 84
    (s->s.ccir.time) --;
#line 85
    (s->s.ccir.time2) --;
#line 86
    *buf = (short )((int )*buf + (p->ampl * (int )costabi[(unsigned int )(s->s.ccir.ph >> 6) & 1023U] >> 15));
#line 87
    s->s.ccir.ph += s->s.ccir.phinc;
#line 60
    buflen --;
#line 60
    buf ++;
#line 60
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return (num);
}
}
#line 108 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
void gen_init_hdlc(struct gen_params *p , struct gen_state *s ) ;
#line 109
int gen_hdlc(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) ;
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
static unsigned short const   crc_ccitt_table[256]  = 
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
  {      (unsigned short const   )0,      (unsigned short const   )4489,      (unsigned short const   )8978,      (unsigned short const   )12955, 
        (unsigned short const   )17956,      (unsigned short const   )22445,      (unsigned short const   )25910,      (unsigned short const   )29887, 
        (unsigned short const   )35912,      (unsigned short const   )40385,      (unsigned short const   )44890,      (unsigned short const   )48851, 
        (unsigned short const   )51820,      (unsigned short const   )56293,      (unsigned short const   )59774,      (unsigned short const   )63735, 
        (unsigned short const   )4225,      (unsigned short const   )264,      (unsigned short const   )13203,      (unsigned short const   )8730, 
        (unsigned short const   )22181,      (unsigned short const   )18220,      (unsigned short const   )30135,      (unsigned short const   )25662, 
        (unsigned short const   )40137,      (unsigned short const   )36160,      (unsigned short const   )49115,      (unsigned short const   )44626, 
        (unsigned short const   )56045,      (unsigned short const   )52068,      (unsigned short const   )63999,      (unsigned short const   )59510, 
        (unsigned short const   )8450,      (unsigned short const   )12427,      (unsigned short const   )528,      (unsigned short const   )5017, 
        (unsigned short const   )26406,      (unsigned short const   )30383,      (unsigned short const   )17460,      (unsigned short const   )21949, 
        (unsigned short const   )44362,      (unsigned short const   )48323,      (unsigned short const   )36440,      (unsigned short const   )40913, 
        (unsigned short const   )60270,      (unsigned short const   )64231,      (unsigned short const   )51324,      (unsigned short const   )55797, 
        (unsigned short const   )12675,      (unsigned short const   )8202,      (unsigned short const   )4753,      (unsigned short const   )792, 
        (unsigned short const   )30631,      (unsigned short const   )26158,      (unsigned short const   )21685,      (unsigned short const   )17724, 
        (unsigned short const   )48587,      (unsigned short const   )44098,      (unsigned short const   )40665,      (unsigned short const   )36688, 
        (unsigned short const   )64495,      (unsigned short const   )60006,      (unsigned short const   )55549,      (unsigned short const   )51572, 
        (unsigned short const   )16900,      (unsigned short const   )21389,      (unsigned short const   )24854,      (unsigned short const   )28831, 
        (unsigned short const   )1056,      (unsigned short const   )5545,      (unsigned short const   )10034,      (unsigned short const   )14011, 
        (unsigned short const   )52812,      (unsigned short const   )57285,      (unsigned short const   )60766,      (unsigned short const   )64727, 
        (unsigned short const   )34920,      (unsigned short const   )39393,      (unsigned short const   )43898,      (unsigned short const   )47859, 
        (unsigned short const   )21125,      (unsigned short const   )17164,      (unsigned short const   )29079,      (unsigned short const   )24606, 
        (unsigned short const   )5281,      (unsigned short const   )1320,      (unsigned short const   )14259,      (unsigned short const   )9786, 
        (unsigned short const   )57037,      (unsigned short const   )53060,      (unsigned short const   )64991,      (unsigned short const   )60502, 
        (unsigned short const   )39145,      (unsigned short const   )35168,      (unsigned short const   )48123,      (unsigned short const   )43634, 
        (unsigned short const   )25350,      (unsigned short const   )29327,      (unsigned short const   )16404,      (unsigned short const   )20893, 
        (unsigned short const   )9506,      (unsigned short const   )13483,      (unsigned short const   )1584,      (unsigned short const   )6073, 
        (unsigned short const   )61262,      (unsigned short const   )65223,      (unsigned short const   )52316,      (unsigned short const   )56789, 
        (unsigned short const   )43370,      (unsigned short const   )47331,      (unsigned short const   )35448,      (unsigned short const   )39921, 
        (unsigned short const   )29575,      (unsigned short const   )25102,      (unsigned short const   )20629,      (unsigned short const   )16668, 
        (unsigned short const   )13731,      (unsigned short const   )9258,      (unsigned short const   )5809,      (unsigned short const   )1848, 
        (unsigned short const   )65487,      (unsigned short const   )60998,      (unsigned short const   )56541,      (unsigned short const   )52564, 
        (unsigned short const   )47595,      (unsigned short const   )43106,      (unsigned short const   )39673,      (unsigned short const   )35696, 
        (unsigned short const   )33800,      (unsigned short const   )38273,      (unsigned short const   )42778,      (unsigned short const   )46739, 
        (unsigned short const   )49708,      (unsigned short const   )54181,      (unsigned short const   )57662,      (unsigned short const   )61623, 
        (unsigned short const   )2112,      (unsigned short const   )6601,      (unsigned short const   )11090,      (unsigned short const   )15067, 
        (unsigned short const   )20068,      (unsigned short const   )24557,      (unsigned short const   )28022,      (unsigned short const   )31999, 
        (unsigned short const   )38025,      (unsigned short const   )34048,      (unsigned short const   )47003,      (unsigned short const   )42514, 
        (unsigned short const   )53933,      (unsigned short const   )49956,      (unsigned short const   )61887,      (unsigned short const   )57398, 
        (unsigned short const   )6337,      (unsigned short const   )2376,      (unsigned short const   )15315,      (unsigned short const   )10842, 
        (unsigned short const   )24293,      (unsigned short const   )20332,      (unsigned short const   )32247,      (unsigned short const   )27774, 
        (unsigned short const   )42250,      (unsigned short const   )46211,      (unsigned short const   )34328,      (unsigned short const   )38801, 
        (unsigned short const   )58158,      (unsigned short const   )62119,      (unsigned short const   )49212,      (unsigned short const   )53685, 
        (unsigned short const   )10562,      (unsigned short const   )14539,      (unsigned short const   )2640,      (unsigned short const   )7129, 
        (unsigned short const   )28518,      (unsigned short const   )32495,      (unsigned short const   )19572,      (unsigned short const   )24061, 
        (unsigned short const   )46475,      (unsigned short const   )41986,      (unsigned short const   )38553,      (unsigned short const   )34576, 
        (unsigned short const   )62383,      (unsigned short const   )57894,      (unsigned short const   )53437,      (unsigned short const   )49460, 
        (unsigned short const   )14787,      (unsigned short const   )10314,      (unsigned short const   )6865,      (unsigned short const   )2904, 
        (unsigned short const   )32743,      (unsigned short const   )28270,      (unsigned short const   )23797,      (unsigned short const   )19836, 
        (unsigned short const   )50700,      (unsigned short const   )55173,      (unsigned short const   )58654,      (unsigned short const   )62615, 
        (unsigned short const   )32808,      (unsigned short const   )37281,      (unsigned short const   )41786,      (unsigned short const   )45747, 
        (unsigned short const   )19012,      (unsigned short const   )23501,      (unsigned short const   )26966,      (unsigned short const   )30943, 
        (unsigned short const   )3168,      (unsigned short const   )7657,      (unsigned short const   )12146,      (unsigned short const   )16123, 
        (unsigned short const   )54925,      (unsigned short const   )50948,      (unsigned short const   )62879,      (unsigned short const   )58390, 
        (unsigned short const   )37033,      (unsigned short const   )33056,      (unsigned short const   )46011,      (unsigned short const   )41522, 
        (unsigned short const   )23237,      (unsigned short const   )19276,      (unsigned short const   )31191,      (unsigned short const   )26718, 
        (unsigned short const   )7393,      (unsigned short const   )3432,      (unsigned short const   )16371,      (unsigned short const   )11898, 
        (unsigned short const   )59150,      (unsigned short const   )63111,      (unsigned short const   )50204,      (unsigned short const   )54677, 
        (unsigned short const   )41258,      (unsigned short const   )45219,      (unsigned short const   )33336,      (unsigned short const   )37809, 
        (unsigned short const   )27462,      (unsigned short const   )31439,      (unsigned short const   )18516,      (unsigned short const   )23005, 
        (unsigned short const   )11618,      (unsigned short const   )15595,      (unsigned short const   )3696,      (unsigned short const   )8185, 
        (unsigned short const   )63375,      (unsigned short const   )58886,      (unsigned short const   )54429,      (unsigned short const   )50452, 
        (unsigned short const   )45483,      (unsigned short const   )40994,      (unsigned short const   )37561,      (unsigned short const   )33584, 
        (unsigned short const   )31687,      (unsigned short const   )27214,      (unsigned short const   )22741,      (unsigned short const   )18780, 
        (unsigned short const   )15843,      (unsigned short const   )11370,      (unsigned short const   )7921,      (unsigned short const   )3960};
#line 96 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
__inline static int calc_crc_ccitt(unsigned char const   *buf , int cnt ) 
{ 
  unsigned int crc ;
  unsigned char const   *tmp ;

  {
#line 98
  crc = 65535U;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (cnt > 0)) {
#line 100
      goto while_break;
    }
#line 101
    tmp = buf;
#line 101
    buf ++;
#line 101
    crc = (crc >> 8) ^ (unsigned int )crc_ccitt_table[(crc ^ (unsigned int )*tmp) & 255U];
#line 100
    cnt --;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  crc ^= 65535U;
#line 103
  return ((int )(crc & 65535U));
}
}
#line 114 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
static void txb_addbyte(struct gen_state *s , struct hdlctx *hdlctx , unsigned char bits ,
                        unsigned char stuff ) 
{ 
  unsigned int mask1 ;
  unsigned int mask2 ;
  unsigned int mask3 ;
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 121
  if (hdlctx->numbits >= 8) {
#line 122
    if ((unsigned long )s->s.hdlc.datalen >= sizeof(s->s.hdlc.data)) {
#line 123
      return;
    }
#line 124
    tmp = s->s.hdlc.datalen;
#line 124
    (s->s.hdlc.datalen) ++;
#line 124
    s->s.hdlc.data[tmp] = (unsigned char )hdlctx->bitbuf;
#line 125
    hdlctx->bitbuf >>= 8;
#line 126
    hdlctx->numbits -= 8;
  }
#line 128
  hdlctx->bitbuf |= (unsigned int )((int )bits << hdlctx->numbits);
#line 129
  hdlctx->bitstream >>= 8;
#line 130
  hdlctx->bitstream |= (unsigned int )((int )bits << 8);
#line 131
  mask1 = 496U;
#line 132
  mask2 = 256U;
#line 133
  mask3 = 4294967295U >> (31 - hdlctx->numbits);
#line 134
  hdlctx->numbits += 8;
#line 135
  if (! stuff) {
#line 136
    goto nostuff;
  }
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < 8)) {
#line 137
      goto while_break;
    }
#line 138
    if ((hdlctx->bitstream & mask1) != mask1) {
#line 139
      goto __Cont;
    }
#line 140
    hdlctx->bitstream &= ~ mask2;
#line 141
    hdlctx->bitbuf = (hdlctx->bitbuf & mask3) | ((hdlctx->bitbuf & ~ mask3) << 1);
#line 142
    (hdlctx->numbits) ++;
#line 143
    mask3 = (mask3 << 1) | 1U;
    __Cont: /* CIL Label */ 
#line 137
    i ++;
#line 137
    mask1 <<= 1;
#line 137
    mask2 <<= 1;
#line 137
    mask3 = (mask3 << 1) | 1U;
  }
  while_break: /* CIL Label */ ;
  }
  nostuff: 
#line 146
  if (hdlctx->numbits >= 8) {
#line 147
    if ((unsigned long )s->s.hdlc.datalen >= sizeof(s->s.hdlc.data)) {
#line 148
      return;
    }
#line 149
    tmp___0 = s->s.hdlc.datalen;
#line 149
    (s->s.hdlc.datalen) ++;
#line 149
    s->s.hdlc.data[tmp___0] = (unsigned char )hdlctx->bitbuf;
#line 150
    hdlctx->bitbuf >>= 8;
#line 151
    hdlctx->numbits -= 8;
  }
#line 153
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
void gen_init_hdlc(struct gen_params *p , struct gen_state *s ) 
{ 
  struct hdlctx hdlctx ;
  int i ;

  {
  {
#line 159
  hdlctx.bitstream = 0U;
#line 159
  hdlctx.bitbuf = 0U;
#line 159
  hdlctx.numbits = 0;
#line 162
  memset((void *)s, 0, sizeof(struct gen_state ));
#line 163
  s->s.hdlc.bitmask = 1;
#line 164
  i = 0;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < (p->p.hdlc.txdelay * 12) / 8)) {
#line 164
      goto while_break;
    }
    {
#line 165
    txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (i < p->p.hdlc.pktlen)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    txb_addbyte(s, & hdlctx, p->p.hdlc.pkt[i], (unsigned char)1);
#line 167
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 169
  i = calc_crc_ccitt((unsigned char const   *)(p->p.hdlc.pkt), p->p.hdlc.pktlen);
#line 170
  txb_addbyte(s, & hdlctx, (unsigned char )i, (unsigned char)1);
#line 171
  txb_addbyte(s, & hdlctx, (unsigned char )(i >> 8), (unsigned char)1);
#line 172
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 173
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 174
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 175
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 176
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
#line 177
  txb_addbyte(s, & hdlctx, (unsigned char)126, (unsigned char)0);
  }
#line 178
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/multimon-1.0/gen_hdlc.c"
int gen_hdlc(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) 
{ 
  int num ;

  {
#line 182
  num = 0;
#line 184
  if (! s) {
#line 185
    return (0);
  } else
#line 184
  if (s->s.hdlc.ch_idx < 0) {
#line 185
    return (0);
  } else
#line 184
  if ((unsigned int )s->s.hdlc.ch_idx >= s->s.hdlc.datalen) {
#line 185
    return (0);
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (buflen > 0)) {
#line 186
      goto while_break;
    }
#line 187
    s->s.hdlc.bitph += 3566U;
#line 188
    if (s->s.hdlc.bitph >= 65536U) {
#line 189
      s->s.hdlc.bitph &= 65535U;
#line 190
      s->s.hdlc.bitmask <<= 1;
#line 191
      if (s->s.hdlc.bitmask >= 256) {
#line 192
        s->s.hdlc.bitmask = 1;
#line 193
        (s->s.hdlc.ch_idx) ++;
#line 194
        if ((unsigned int )s->s.hdlc.ch_idx >= s->s.hdlc.datalen) {
#line 195
          return (num);
        }
      }
#line 197
      if (! ((int )s->s.hdlc.data[s->s.hdlc.ch_idx] & s->s.hdlc.bitmask)) {
#line 198
        s->s.hdlc.lastb = ! s->s.hdlc.lastb;
      }
#line 199
      if (s->s.hdlc.lastb) {
#line 199
        s->s.hdlc.phinc = 6538U;
      } else {
#line 199
        s->s.hdlc.phinc = 3566U;
      }
    }
#line 202
    *buf = (short )((int )*buf + (p->ampl * (int )costabi[(s->s.hdlc.ph >> 6) & 1023U] >> 15));
#line 203
    s->s.hdlc.ph += s->s.hdlc.phinc;
#line 186
    buflen --;
#line 186
    buf ++;
#line 186
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (num);
}
}
#line 96 "/home/wheatley/newnew/temp/multimon-1.0/gen.h"
void gen_init_dtmf(struct gen_params *p , struct gen_state *s ) ;
#line 97
int gen_dtmf(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) ;
#line 99
void gen_init_sine(struct gen_params *p , struct gen_state *s ) ;
#line 100
int gen_sine(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) ;
#line 102
void gen_init_zvei(struct gen_params *p , struct gen_state *s ) ;
#line 103
int gen_zvei(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static char const   *allowed_types[13]  = 
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
  {      "raw",      "aiff",      "au",      "hcom", 
        "sf",      "voc",      "cdr",      "dat", 
        "smp",      "wav",      "maud",      "vwe", 
        (char const   *)((void *)0)};
#line 75 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static t_init_procs const   init_procs[5]  = {      (t_init_procs const   )(& gen_init_dtmf),      (t_init_procs const   )(& gen_init_sine),      (t_init_procs const   )(& gen_init_zvei),      (t_init_procs const   )(& gen_init_ccir), 
        (t_init_procs const   )(& gen_init_hdlc)};
#line 79 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static t_gen_procs const   gen_procs[5]  = {      (t_gen_procs const   )(& gen_dtmf),      (t_gen_procs const   )(& gen_sine),      (t_gen_procs const   )(& gen_zvei),      (t_gen_procs const   )(& gen_ccir), 
        (t_gen_procs const   )(& gen_hdlc)};
#line 86 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static struct gen_params params[16]  ;
#line 87 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static struct gen_state state[16]  ;
#line 88 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static int num_gen  =    0;
#line 92 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static int process_buffer(short *buf , int len ) 
{ 
  int i ;
  int totnum ;
  int num ;

  {
  {
#line 95
  totnum = 0;
#line 97
  memset((void *)buf, 0, (unsigned long )len * sizeof(*(buf + 0)));
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < num_gen)) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )params[i].type >= sizeof(gen_procs) / sizeof(gen_procs[0])) {
#line 100
      goto while_break;
    }
#line 101
    if (! gen_procs[params[i].type]) {
#line 102
      goto while_break;
    }
    {
#line 103
    num = (*(gen_procs[params[i].type]))(buf, len, params + i, state + i);
    }
#line 104
    if (num > totnum) {
#line 105
      totnum = num;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (totnum);
}
}
#line 175 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static void output_sound(unsigned int sample_rate , char const   *ifname ) 
{ 
  int sndparam ;
  int fd ;
  union __anonunion_b_67 b ;
  int i ;
  short *sp ;
  unsigned char *bp ;
  int fmt ;
  int num ;
  int num2 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;

  {
#line 186
  fmt = 0;
#line 188
  if (ifname) {
#line 188
    tmp = ifname;
  } else {
#line 188
    tmp = "/dev/dsp";
  }
  {
#line 188
  fd = open(tmp, 1);
  }
#line 188
  if (fd < 0) {
    {
#line 189
    perror("open");
#line 190
    exit(10);
    }
  }
  {
#line 192
  sndparam = 16;
#line 194
  tmp___0 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 194
  if (tmp___0 == -1) {
    {
#line 195
    perror("ioctl: SNDCTL_DSP_SETFMT");
#line 196
    exit(10);
    }
  }
#line 198
  if (sndparam != 16) {
    {
#line 199
    fmt = 1;
#line 200
    sndparam = 8;
#line 201
    tmp___1 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                    & sndparam);
    }
#line 201
    if (tmp___1 == -1) {
      {
#line 202
      perror("ioctl: SNDCTL_DSP_SETFMT");
#line 203
      exit(10);
      }
    }
#line 205
    if (sndparam != 8) {
      {
#line 206
      perror("ioctl: SNDCTL_DSP_SETFMT");
#line 207
      exit(10);
      }
    }
  }
  {
#line 210
  sndparam = 0;
#line 211
  tmp___2 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 211
  if (tmp___2 == -1) {
    {
#line 212
    perror("ioctl: SNDCTL_DSP_STEREO");
#line 213
    exit(10);
    }
  }
#line 215
  if (sndparam != 0) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: Error, cannot set the channel number to 1\n");
#line 218
    exit(10);
    }
  }
  {
#line 220
  sndparam = (int )sample_rate;
#line 221
  tmp___3 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 221
  if (tmp___3 == -1) {
    {
#line 222
    perror("ioctl: SNDCTL_DSP_SPEED");
#line 223
    exit(10);
    }
  }
  {
#line 225
  tmp___4 = abs((int )((unsigned int )sndparam - sample_rate));
  }
#line 225
  if ((unsigned int )(10 * tmp___4) > sample_rate) {
    {
#line 226
    perror("ioctl: SNDCTL_DSP_SPEED");
#line 227
    exit(10);
    }
  }
#line 229
  if ((unsigned int )sndparam != sample_rate) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Sampling rate is %u, requested %u\n",
            sndparam, sample_rate);
    }
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    num = process_buffer(b.s, (int )(sizeof(b.s) / sizeof(b.s[0])));
#line 243
    num2 = num;
    }
#line 244
    if (fmt) {
#line 245
      bp = b.b;
#line 245
      sp = b.s;
#line 245
      i = (int )(sizeof(b.s) / sizeof(b.s[0]));
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 245
        if (! (i > 0)) {
#line 245
          goto while_break___0;
        }
#line 246
        *bp = (unsigned char )(128 + ((int )*sp >> 8));
#line 245
        i --;
#line 245
        bp ++;
#line 245
        sp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 247
      bp = b.b;
      {
#line 248
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 248
        if (! (num > 0)) {
#line 248
          goto while_break___1;
        }
        {
#line 249
        tmp___5 = write(fd, (void const   *)bp, (unsigned long )num * sizeof(*(bp + 0)));
#line 249
        i = (int )tmp___5;
        }
#line 250
        if (i < 0) {
          {
#line 250
          tmp___6 = __errno_location();
          }
#line 250
          if (*tmp___6 != 11) {
            {
#line 251
            perror("write");
#line 252
            exit(4);
            }
          }
        }
#line 254
        if (i > 0) {
#line 255
          if ((unsigned long )i % sizeof(*(bp + 0))) {
            {
#line 256
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: warning: write wrote noninteger number of samples\n");
            }
          }
#line 257
          num = (int )((unsigned long )num - (unsigned long )i / sizeof(*(bp + 0)));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 261
      sp = b.s;
      {
#line 262
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 262
        if (! (num > 0)) {
#line 262
          goto while_break___2;
        }
        {
#line 263
        tmp___7 = write(fd, (void const   *)sp, (unsigned long )num * sizeof(*(sp + 0)));
#line 263
        i = (int )tmp___7;
        }
#line 264
        if (i < 0) {
          {
#line 264
          tmp___8 = __errno_location();
          }
#line 264
          if (*tmp___8 != 11) {
            {
#line 265
            perror("write");
#line 266
            exit(4);
            }
          }
        }
#line 268
        if (i > 0) {
#line 269
          if ((unsigned long )i % sizeof(*(sp + 0))) {
            {
#line 270
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: warning: write wrote noninteger number of samples\n");
            }
          }
#line 271
          num = (int )((unsigned long )num - (unsigned long )i / sizeof(*(sp + 0)));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 242
    if (! (num2 > 0)) {
#line 242
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  close(fd);
  }
#line 277
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static void output_file(unsigned int sample_rate , char const   *fname , char const   *type ) 
{ 
  struct stat statbuf ;
  int pipedes[2] ;
  int pid ;
  int soxstat ;
  int fd ;
  int i ;
  int num ;
  int num2 ;
  short buffer[8192] ;
  short *sp ;
  int tmp ;
  int tmp___0 ;
  char srate[8] ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;

  {
#line 286
  pid = 0;
#line 296
  if (! type) {
#line 296
    goto _L;
  } else {
    {
#line 296
    tmp___2 = strcmp(type, "raw");
    }
#line 296
    if (tmp___2) {
      {
#line 302
      tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& statbuf));
      }
#line 302
      if (! tmp) {
        {
#line 303
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file already exists: %s\n",
                fname);
#line 304
        exit(10);
        }
      }
      {
#line 306
      tmp___0 = pipe((int *)(pipedes));
      }
#line 306
      if (tmp___0) {
        {
#line 307
        perror("pipe");
#line 308
        exit(10);
        }
      }
      {
#line 310
      pid = fork();
      }
#line 310
      if (! pid) {
        {
#line 316
        snprintf((char */* __restrict  */)(srate), sizeof(srate), (char const   */* __restrict  */)"%d",
                 sample_rate);
#line 317
        close(pipedes[1]);
#line 318
        close(0);
#line 319
        tmp___1 = dup2(pipedes[0], 0);
        }
#line 319
        if (tmp___1 < 0) {
          {
#line 320
          perror("dup2");
          }
        }
        {
#line 321
        close(pipedes[0]);
#line 322
        execlp("sox", "sox", "-t", "raw", "-s", "-2", "-r", srate, "-", "-t", type,
               fname, (void *)0);
#line 326
        perror("execlp");
#line 327
        exit(10);
        }
      }
#line 329
      if (pid < 0) {
        {
#line 330
        perror("fork");
#line 331
        exit(10);
        }
      }
      {
#line 333
      close(pipedes[0]);
#line 334
      fd = pipedes[1];
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 297
      fd = open(fname, 193, 511);
      }
#line 297
      if (fd < 0) {
        {
#line 298
        perror("open");
#line 299
        exit(10);
        }
      }
    }
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    sp = buffer;
#line 340
    num = process_buffer(sp, (int )(sizeof(buffer) / sizeof(buffer[0])));
#line 340
    num2 = num;
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (num > 0)) {
#line 341
        goto while_break___0;
      }
      {
#line 342
      tmp___3 = write(fd, (void const   *)sp, (unsigned long )num * sizeof(*(sp + 0)));
#line 342
      i = (int )tmp___3;
      }
#line 343
      if (i < 0) {
        {
#line 343
        tmp___4 = __errno_location();
        }
#line 343
        if (*tmp___4 != 11) {
          {
#line 344
          perror("write");
#line 345
          exit(4);
          }
        }
      }
#line 347
      if (i > 0) {
#line 348
        if ((unsigned long )i % sizeof(*(sp + 0))) {
          {
#line 349
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: warning: write wrote noninteger number of samples\n");
          }
        }
#line 350
        num = (int )((unsigned long )num - (unsigned long )i / sizeof(*(sp + 0)));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    if (! (num2 > 0)) {
#line 339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  close(fd);
#line 355
  waitpid(pid, & soxstat, 0);
  }
#line 356
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
static char const   usage_str[325]  = 
#line 360
  {      (char const   )'g',      (char const   )'e',      (char const   )'n',      (char const   )'\n', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'g',      (char const   )'n',      (char const   )'a', 
        (char const   )'l',      (char const   )'s',      (char const   )'\n',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'7',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'o',      (char const   )'m',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'S',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'H',      (char const   )'B',      (char const   )'9', 
        (char const   )'J',      (char const   )'N',      (char const   )'X',      (char const   )'/', 
        (char const   )'A',      (char const   )'E',      (char const   )'4',      (char const   )'W', 
        (char const   )'A',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'t',      (char const   )' ',      (char const   )'<', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'p', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )' ',      (char const   )'(',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'r',      (char const   )'a', 
        (char const   )'w',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'q',      (char const   )'u',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'x',      (char const   )')',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'a', 
        (char const   )' ',      (char const   )'<',      (char const   )'a',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )':',      (char const   )' ',      (char const   )'a', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'i', 
        (char const   )'t',      (char const   )'u',      (char const   )'d',      (char const   )'e', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'d',      (char const   )' ',      (char const   )'<',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )':',      (char const   )' ', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'D', 
        (char const   )'T',      (char const   )'M',      (char const   )'F',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'z',      (char const   )' ', 
        (char const   )'<',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )':',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'Z',      (char const   )'V',      (char const   )'E', 
        (char const   )'I',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'c',      (char const   )' ',      (char const   )'<',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )':',      (char const   )' ', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'C', 
        (char const   )'C',      (char const   )'I',      (char const   )'R',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'s',      (char const   )' ', 
        (char const   )'<',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'q',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )':',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'p',      (char const   )' ',      (char const   )'<', 
        (char const   )'t',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )':', 
        (char const   )' ',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )' ', 
        (char const   )'h',      (char const   )'d',      (char const   )'l',      (char const   )'c', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'k',      (char const   )'e',      (char const   )'t',      (char const   )'\n', 
        (char const   )'\000'};
#line 371 "/home/wheatley/newnew/temp/multimon-1.0/gen.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int errflg ;
  char **otype ;
  char *output_type ;
  char *cp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 374
  errflg = 0;
#line 376
  output_type = (char *)"hw";
#line 379
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"gen - (C) 1997 by Tom Sailer HB9JNX/AE4WA\n");
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    c = getopt(argc, (char * const  *)argv, "t:a:d:s:z:c:p:");
    }
#line 380
    if (! (c != -1)) {
#line 380
      goto while_break;
    }
    {
#line 382
    if (c == 63) {
#line 382
      goto case_63;
    }
#line 386
    if (c == 116) {
#line 386
      goto case_116;
    }
#line 401
    if (c == 97) {
#line 401
      goto case_97;
    }
#line 416
    if (c == 100) {
#line 416
      goto case_100;
    }
#line 430
    if (c == 115) {
#line 430
      goto case_115;
    }
#line 443
    if (c == 122) {
#line 443
      goto case_122;
    }
#line 457
    if (c == 99) {
#line 457
      goto case_99;
    }
#line 471
    if (c == 112) {
#line 471
      goto case_112;
    }
#line 381
    goto switch_break;
    case_63: /* CIL Label */ 
#line 383
    errflg ++;
#line 384
    goto switch_break;
    case_116: /* CIL Label */ 
#line 387
    otype = (char **)(allowed_types);
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 387
      if (! *otype) {
#line 387
        goto while_break___0;
      }
      {
#line 388
      tmp = strcmp((char const   *)*otype, (char const   *)optarg);
      }
#line 388
      if (! tmp) {
#line 389
        output_type = *otype;
#line 390
        goto outtypefound;
      }
#line 387
      otype ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid output type \"%s\"\nallowed types: ",
            optarg);
#line 394
    otype = (char **)(allowed_types);
    }
    {
#line 394
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 394
      if (! *otype) {
#line 394
        goto while_break___1;
      }
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              *otype);
#line 394
      otype ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 397
    errflg ++;
    }
    outtypefound: 
#line 399
    goto switch_break;
    case_97: /* CIL Label */ 
#line 402
    if (num_gen <= 0) {
      {
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: no generator selected\n");
#line 404
      errflg ++;
      }
    }
    {
#line 406
    cp = strstr((char const   *)optarg, "dB");
    }
#line 406
    if (! cp) {
      {
#line 407
      cp = strstr((char const   *)optarg, "db");
      }
    }
#line 408
    if (cp) {
      {
#line 409
      *cp = (char )'\000';
#line 410
      tmp___0 = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
#line 410
      tmp___1 = pow(10.0, tmp___0 / 20.0);
#line 410
      params[num_gen - 1].ampl = (int )(16384.0 * tmp___1);
      }
    } else {
      {
#line 412
      tmp___2 = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
#line 412
      params[num_gen - 1].ampl = (int )(16384.0 * tmp___2);
      }
    }
#line 414
    goto switch_break;
    case_100: /* CIL Label */ 
#line 417
    num_gen ++;
#line 418
    if (num_gen > 16) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many generators\n");
#line 420
      errflg ++;
      }
#line 421
      goto switch_break;
    }
    {
#line 423
    params[num_gen - 1].type = (enum gen_type )0;
#line 424
    params[num_gen - 1].ampl = 16384;
#line 425
    params[num_gen - 1].p.dtmf.duration = (int )(((float )100 * (float )22050) / (float )1000);
#line 426
    params[num_gen - 1].p.dtmf.pause = (int )(((float )100 * (float )22050) / (float )1000);
#line 427
    strncpy((char */* __restrict  */)(params[num_gen - 1].p.dtmf.str), (char const   */* __restrict  */)optarg,
            sizeof(params[num_gen - 1].p.dtmf.str));
    }
#line 428
    goto switch_break;
    case_115: /* CIL Label */ 
#line 431
    num_gen ++;
#line 432
    if (num_gen > 16) {
      {
#line 433
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many generators\n");
#line 434
      errflg ++;
      }
#line 435
      goto switch_break;
    }
    {
#line 437
    params[num_gen - 1].type = (enum gen_type )1;
#line 438
    params[num_gen - 1].ampl = 16384;
#line 439
    params[num_gen - 1].p.sine.duration = (int )(((float )1000 * (float )22050) / (float )1000);
#line 440
    tmp___3 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 440
    params[num_gen - 1].p.sine.freq = (int )tmp___3;
    }
#line 441
    goto switch_break;
    case_122: /* CIL Label */ 
#line 444
    num_gen ++;
#line 445
    if (num_gen > 16) {
      {
#line 446
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many generators\n");
#line 447
      errflg ++;
      }
#line 448
      goto switch_break;
    }
    {
#line 450
    params[num_gen - 1].type = (enum gen_type )2;
#line 451
    params[num_gen - 1].ampl = 16384;
#line 452
    params[num_gen - 1].p.zvei.duration = (int )(((float )50 * (float )22050) / (float )1000);
#line 453
    params[num_gen - 1].p.zvei.pause = (int )(((float )50 * (float )22050) / (float )1000);
#line 454
    strncpy((char */* __restrict  */)(params[num_gen - 1].p.zvei.str), (char const   */* __restrict  */)optarg,
            sizeof(params[num_gen - 1].p.dtmf.str));
    }
#line 455
    goto switch_break;
    case_99: /* CIL Label */ 
#line 458
    num_gen ++;
#line 459
    if (num_gen > 16) {
      {
#line 460
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many generators\n");
#line 461
      errflg ++;
      }
#line 462
      goto switch_break;
    }
    {
#line 464
    params[num_gen - 1].type = (enum gen_type )3;
#line 465
    params[num_gen - 1].ampl = 16384;
#line 466
    params[num_gen - 1].p.ccir.duration = (int )(((float )100 * (float )22050) / (float )1000);
#line 467
    params[num_gen - 1].p.ccir.pause = (int )(((float )10 * (float )22050) / (float )1000);
#line 468
    strncpy((char */* __restrict  */)(params[num_gen - 1].p.ccir.str), (char const   */* __restrict  */)optarg,
            sizeof(params[num_gen - 1].p.dtmf.str));
    }
#line 469
    goto switch_break;
    case_112: /* CIL Label */ 
#line 472
    num_gen ++;
#line 473
    if (num_gen > 16) {
      {
#line 474
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many generators\n");
#line 475
      errflg ++;
      }
#line 476
      goto switch_break;
    }
    {
#line 478
    params[num_gen - 1].type = (enum gen_type )4;
#line 479
    params[num_gen - 1].ampl = 16384;
#line 480
    params[num_gen - 1].p.hdlc.modulation = 0;
#line 481
    params[num_gen - 1].p.hdlc.txdelay = 100;
#line 482
    params[num_gen - 1].p.hdlc.pkt[0] = (unsigned char )(72 << 1);
#line 483
    params[num_gen - 1].p.hdlc.pkt[1] = (unsigned char )(66 << 1);
#line 484
    params[num_gen - 1].p.hdlc.pkt[2] = (unsigned char )(57 << 1);
#line 485
    params[num_gen - 1].p.hdlc.pkt[3] = (unsigned char )(74 << 1);
#line 486
    params[num_gen - 1].p.hdlc.pkt[4] = (unsigned char )(78 << 1);
#line 487
    params[num_gen - 1].p.hdlc.pkt[5] = (unsigned char )(88 << 1);
#line 488
    params[num_gen - 1].p.hdlc.pkt[6] = (unsigned char)0;
#line 489
    params[num_gen - 1].p.hdlc.pkt[7] = (unsigned char )(65 << 1);
#line 490
    params[num_gen - 1].p.hdlc.pkt[8] = (unsigned char )(69 << 1);
#line 491
    params[num_gen - 1].p.hdlc.pkt[9] = (unsigned char )(52 << 1);
#line 492
    params[num_gen - 1].p.hdlc.pkt[10] = (unsigned char )(87 << 1);
#line 493
    params[num_gen - 1].p.hdlc.pkt[11] = (unsigned char )(65 << 1);
#line 494
    params[num_gen - 1].p.hdlc.pkt[12] = (unsigned char )(32 << 1);
#line 495
    params[num_gen - 1].p.hdlc.pkt[13] = (unsigned char)1;
#line 496
    params[num_gen - 1].p.hdlc.pkt[14] = (unsigned char)3;
#line 497
    params[num_gen - 1].p.hdlc.pkt[15] = (unsigned char)240;
#line 498
    strncpy((char */* __restrict  */)(params[num_gen - 1].p.hdlc.pkt + 16), (char const   */* __restrict  */)optarg,
            sizeof(params[num_gen - 1].p.hdlc.pkt) - 16UL);
#line 500
    tmp___4 = strlen((char const   *)(params[num_gen - 1].p.hdlc.pkt + 16));
#line 500
    params[num_gen - 1].p.hdlc.pktlen = (int )(16UL + tmp___4);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  if (errflg) {
    {
#line 506
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage_str));
#line 507
    exit(2);
    }
  } else
#line 505
  if (num_gen <= 0) {
    {
#line 506
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage_str));
#line 507
    exit(2);
    }
  }
  {
#line 510
  memset((void *)(state), 0, sizeof(state));
#line 511
  c = 0;
  }
  {
#line 511
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 511
    if (! (c < num_gen)) {
#line 511
      goto while_break___2;
    }
#line 512
    if ((unsigned long )params[c].type >= sizeof(init_procs) / sizeof(init_procs[0])) {
#line 513
      goto while_break___2;
    }
#line 514
    if (! init_procs[params[c].type]) {
#line 515
      goto while_break___2;
    }
    {
#line 516
    (*(init_procs[params[c].type]))(params + c, state + c);
#line 511
    c ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 519
  tmp___5 = strcmp((char const   *)output_type, "hw");
  }
#line 519
  if (! tmp___5) {
#line 520
    if (argc - optind >= 1) {
      {
#line 521
      output_sound(22050U, (char const   *)*(argv + optind));
      }
    } else {
      {
#line 523
      output_sound(22050U, (char const   *)((void *)0));
      }
    }
    {
#line 524
    exit(0);
    }
  }
#line 526
  if (argc - optind < 1) {
    {
#line 527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no destination file specified\n");
#line 528
    exit(4);
    }
  }
  {
#line 530
  output_file(22050U, (char const   *)*(argv + optind), (char const   *)output_type);
#line 531
  exit(0);
  }
}
}
#line 29 "/home/wheatley/newnew/temp/multimon-1.0/gen_sin.c"
void gen_init_sine(struct gen_params *p , struct gen_state *s ) 
{ 


  {
  {
#line 31
  memset((void *)s, 0, sizeof(struct gen_state ));
#line 32
  s->s.sine.ph = 0;
#line 33
  s->s.sine.phinc = (int )(((float )65536 * (float )p->p.sine.freq) / (float )22050);
#line 34
  s->s.sine.time = p->p.sine.duration;
  }
#line 35
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/gen_sin.c"
int gen_sine(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) 
{ 
  int num ;

  {
#line 39
  num = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (buflen > 0) {
#line 41
      if (! (s->s.sine.time > 0)) {
#line 41
        goto while_break;
      }
    } else {
#line 41
      goto while_break;
    }
#line 42
    *buf = (short )((int )*buf + (p->ampl * (int )costabi[(unsigned int )(s->s.sine.ph >> 6) & 1023U] >> 15));
#line 43
    s->s.sine.ph += s->s.sine.phinc;
#line 41
    buflen --;
#line 41
    buf ++;
#line 41
    num ++;
#line 41
    (s->s.sine.time) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (num);
}
}
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 44 "/home/wheatley/newnew/temp/multimon-1.0/gen_dtmf.c"
static char const   *dtmf_transl  =    "123A456B789C*0#D";
#line 48 "/home/wheatley/newnew/temp/multimon-1.0/gen_dtmf.c"
static unsigned int const   row_freq[4]  = {      (unsigned int const   )(((float )697 * (float )65536) / (float )22050),      (unsigned int const   )(((float )770 * (float )65536) / (float )22050),      (unsigned int const   )(((float )852 * (float )65536) / (float )22050),      (unsigned int const   )(((float )941 * (float )65536) / (float )22050)};
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/gen_dtmf.c"
static unsigned int const   col_freq[4]  = {      (unsigned int const   )(((float )1209 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1336 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1477 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1633 * (float )65536) / (float )22050)};
#line 56 "/home/wheatley/newnew/temp/multimon-1.0/gen_dtmf.c"
void gen_init_dtmf(struct gen_params *p , struct gen_state *s ) 
{ 


  {
  {
#line 58
  memset((void *)s, 0, sizeof(struct gen_state ));
  }
#line 59
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/multimon-1.0/gen_dtmf.c"
int gen_dtmf(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) 
{ 
  char c ;
  char *cp ;
  int num ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 65
  num = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (buflen > 0)) {
#line 67
      goto while_break;
    }
#line 68
    if (s->s.dtmf.time <= 0) {
#line 69
      c = p->p.dtmf.str[s->s.dtmf.ch_idx];
#line 70
      if (! c) {
#line 71
        return (num);
      }
      {
#line 72
      (s->s.dtmf.ch_idx) ++;
#line 73
      tmp = toupper((int )c);
#line 73
      tmp___0 = memchr((void const   *)dtmf_transl, tmp, (size_t )16);
#line 73
      cp = (char *)tmp___0;
      }
#line 74
      if (! cp) {
        {
#line 75
        tmp___1 = 1;
#line 75
        s->s.dtmf.time2 = tmp___1;
#line 75
        s->s.dtmf.time = tmp___1;
#line 76
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: dtmf; invalid char \'%c\'\n",
                (int )c);
        }
      } else {
#line 78
        s->s.dtmf.time = p->p.dtmf.duration + p->p.dtmf.pause;
#line 79
        s->s.dtmf.time2 = p->p.dtmf.duration;
#line 80
        i = (int )(cp - (char *)dtmf_transl);
#line 81
        s->s.dtmf.phinc_row = (int )row_freq[(i >> 2) & 3];
#line 82
        s->s.dtmf.phinc_col = (int )col_freq[i & 3];
      }
    } else
#line 84
    if (! s->s.dtmf.time2) {
#line 85
      tmp___2 = 0;
#line 85
      s->s.dtmf.phinc_col = tmp___2;
#line 85
      s->s.dtmf.phinc_row = tmp___2;
#line 86
      tmp___3 = 49152;
#line 86
      s->s.dtmf.ph_col = tmp___3;
#line 86
      s->s.dtmf.ph_row = tmp___3;
    }
#line 88
    (s->s.dtmf.time) --;
#line 89
    (s->s.dtmf.time2) --;
#line 90
    *buf = (short )((int )*buf + ((p->ampl >> 1) * (int )(costabi[(unsigned int )(s->s.dtmf.ph_row >> 6) & 1023U] + costabi[(unsigned int )(s->s.dtmf.ph_col >> 6) & 1023U]) >> 15));
#line 91
    s->s.dtmf.ph_row += s->s.dtmf.phinc_row;
#line 92
    s->s.dtmf.ph_col += s->s.dtmf.phinc_col;
#line 67
    buflen --;
#line 67
    buf ++;
#line 67
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (num);
}
}
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen_zvei.c"
static unsigned int const   zvei_freq[16]  = 
#line 33 "/home/wheatley/newnew/temp/multimon-1.0/gen_zvei.c"
  {      (unsigned int const   )(((float )2400 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1060 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1160 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1270 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )1400 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1530 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1670 * (float )65536) / (float )22050),      (unsigned int const   )(((float )1830 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )2000 * (float )65536) / (float )22050),      (unsigned int const   )(((float )2200 * (float )65536) / (float )22050),      (unsigned int const   )(((float )2800 * (float )65536) / (float )22050),      (unsigned int const   )(((float )810 * (float )65536) / (float )22050), 
        (unsigned int const   )(((float )970 * (float )65536) / (float )22050),      (unsigned int const   )(((float )886 * (float )65536) / (float )22050),      (unsigned int const   )(((float )2600 * (float )65536) / (float )22050),      (unsigned int const   )(((float )0 * (float )65536) / (float )22050)};
#line 47 "/home/wheatley/newnew/temp/multimon-1.0/gen_zvei.c"
void gen_init_zvei(struct gen_params *p , struct gen_state *s ) 
{ 


  {
  {
#line 49
  memset((void *)s, 0, sizeof(struct gen_state ));
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/gen_zvei.c"
int gen_zvei(short *buf , int buflen , struct gen_params *p , struct gen_state *s ) 
{ 
  char c ;
  int num ;
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 55
  num = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (buflen > 0)) {
#line 57
      goto while_break;
    }
#line 58
    if (s->s.zvei.time <= 0) {
#line 59
      c = p->p.zvei.str[s->s.zvei.ch_idx];
#line 60
      if (! c) {
#line 61
        return (num);
      }
      {
#line 62
      (s->s.zvei.ch_idx) ++;
#line 63
      tmp___0 = __ctype_b_loc();
      }
#line 63
      if ((int const   )*(*tmp___0 + (int )c) & 4096) {
#line 67
        s->s.zvei.time = p->p.zvei.duration + p->p.zvei.pause;
#line 68
        s->s.zvei.time2 = p->p.zvei.duration;
#line 69
        if ((int )c >= 48) {
#line 69
          if ((int )c <= 57) {
#line 70
            i = (int )c - 48;
          } else {
#line 69
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 71
        if ((int )c >= 65) {
#line 71
          if ((int )c <= 70) {
#line 72
            i = ((int )c - 65) + 10;
          } else {
#line 74
            i = ((int )c - 97) + 10;
          }
        } else {
#line 74
          i = ((int )c - 97) + 10;
        }
#line 75
        s->s.zvei.phinc = (int )zvei_freq[i & 15];
      } else {
        {
#line 64
        tmp = 1;
#line 64
        s->s.zvei.time2 = tmp;
#line 64
        s->s.zvei.time = tmp;
#line 65
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gen: zvei; invalid char \'%c\'\n",
                (int )c);
        }
      }
    } else
#line 77
    if (! s->s.zvei.time2) {
#line 78
      s->s.zvei.phinc = 0;
#line 79
      s->s.zvei.ph = 49152;
    }
#line 81
    (s->s.zvei.time) --;
#line 82
    (s->s.zvei.time2) --;
#line 83
    *buf = (short )((int )*buf + (p->ampl * (int )costabi[(unsigned int )(s->s.zvei.ph >> 6) & 1023U] >> 15));
#line 84
    s->s.zvei.ph += s->s.zvei.phinc;
#line 57
    buflen --;
#line 57
    buf ++;
#line 57
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (num);
}
}
#line 164 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_param  const  demod_fsk9600 ;
#line 178
void verbprintf(int verb_level , char const   *fmt  , ...) ;
#line 180
void hdlc_init(struct demod_state *s ) ;
#line 181
void hdlc_rxbit(struct demod_state *s , int bit ) ;
#line 35 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int hweight32(unsigned int w )  __attribute__((__unused__)) ;
#line 37
__inline extern unsigned int hweight16(unsigned short w )  __attribute__((__unused__)) ;
#line 39
__inline extern unsigned int hweight8(unsigned char w )  __attribute__((__unused__)) ;
#line 42
__inline extern unsigned int hweight32(unsigned int w )  __attribute__((__unused__)) ;
#line 42 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
#line 44
  res = (w & 1431655765U) + ((w >> 1) & 1431655765U);
#line 45
  res = (res & 858993459U) + ((res >> 2) & 858993459U);
#line 46
  res = (res & 252645135U) + ((res >> 4) & 252645135U);
#line 47
  res = (res & 16711935U) + ((res >> 8) & 16711935U);
#line 48
  return ((res & 65535U) + ((res >> 16) & 65535U));
}
}
#line 51
__inline extern unsigned int hweight16(unsigned short w )  __attribute__((__unused__)) ;
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int hweight16(unsigned short w ) 
{ 
  unsigned short res ;

  {
#line 53
  res = (unsigned short )(((int )w & 21845) + (((int )w >> 1) & 21845));
#line 54
  res = (unsigned short )(((int )res & 13107) + (((int )res >> 2) & 13107));
#line 55
  res = (unsigned short )(((int )res & 3855) + (((int )res >> 4) & 3855));
#line 56
  return ((unsigned int )(((int )res & 255) + (((int )res >> 8) & 255)));
}
}
#line 59
__inline extern unsigned int hweight8(unsigned char w )  __attribute__((__unused__)) ;
#line 59 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int hweight8(unsigned char w ) 
{ 
  unsigned short res ;

  {
#line 61
  res = (unsigned short )(((int )w & 85) + (((int )w >> 1) & 85));
#line 62
  res = (unsigned short )(((int )res & 51) + (((int )res >> 2) & 51));
#line 63
  return ((unsigned int )(((int )res & 15) + (((int )res >> 4) & 15)));
}
}
#line 66
__inline extern unsigned int gcd(unsigned int x , unsigned int y )  __attribute__((__unused__)) ;
#line 68
__inline extern unsigned int lcm(unsigned int x , unsigned int y )  __attribute__((__unused__)) ;
#line 71
__inline extern unsigned int gcd(unsigned int x , unsigned int y )  __attribute__((__unused__)) ;
#line 71 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int gcd(unsigned int x , unsigned int y ) 
{ 


  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! x) {
#line 75
      return (y);
    }
#line 76
    if (! y) {
#line 77
      return (x);
    }
#line 78
    if (x > y) {
#line 79
      x %= y;
    } else {
#line 81
      y %= x;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 85
__inline extern unsigned int lcm(unsigned int x , unsigned int y )  __attribute__((__unused__)) ;
#line 85 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern unsigned int lcm(unsigned int x , unsigned int y ) 
{ 
  unsigned int tmp ;

  {
  {
#line 87
  tmp = gcd(x, y);
  }
#line 87
  return ((x * y) / tmp);
}
}
#line 93 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern float mac(float const   *a , float const   *b , unsigned int size ) 
{ 
  float sum ;
  unsigned int i ;
  float const   *tmp ;
  float const   *tmp___0 ;

  {
#line 95
  sum = (float )0;
#line 98
  i = 0U;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < size)) {
#line 98
      goto while_break;
    }
#line 99
    tmp = a;
#line 99
    a ++;
#line 99
    tmp___0 = b;
#line 99
    b ++;
#line 99
    sum += (float )(*tmp * *tmp___0);
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (sum);
}
}
#line 104 "/home/wheatley/newnew/temp/multimon-1.0/filter.h"
__inline extern float fsqr(float f ) 
{ 


  {
#line 106
  return (f * f);
}
}
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/demod_fsk96.c"
static float const   inp_filt[3][24]  = { {        (float const   )0.000440,        (float const   )(- 0.001198),        (float const   )(- 0.000493),        (float const   )0.003648, 
            (float const   )(- 0.000630),        (float const   )(- 0.008433),        (float const   )0.005567,        (float const   )0.015557, 
            (float const   )(- 0.019931),        (float const   )(- 0.026514),        (float const   )0.079822,        (float const   )0.181779, 
            (float const   )0.124956,        (float const   )(- 0.002471),        (float const   )(- 0.032062),        (float const   )0.008024, 
            (float const   )0.012568,        (float const   )(- 0.006559),        (float const   )(- 0.004235),        (float const   )0.003711, 
            (float const   )0.000909,        (float const   )(- 0.001520),        (float const   )(- 0.000018),        (float const   )0.000709}, 
   {        (float const   )0.000686,        (float const   )(- 0.000618),        (float const   )(- 0.001332),        (float const   )0.002494, 
            (float const   )0.002258,        (float const   )(- 0.007308),        (float const   )(- 0.001538),        (float const   )0.016708, 
            (float const   )(- 0.004897),        (float const   )(- 0.035748),        (float const   )0.034724,        (float const   )0.161417, 
            (float const   )0.161417,        (float const   )0.034724,        (float const   )(- 0.035748),        (float const   )(- 0.004897), 
            (float const   )0.016708,        (float const   )(- 0.001538),        (float const   )(- 0.007308),        (float const   )0.002258, 
            (float const   )0.002494,        (float const   )(- 0.001332),        (float const   )(- 0.000618),        (float const   )0.000686}, 
   {        (float const   )0.000709,        (float const   )(- 0.000018),        (float const   )(- 0.001520),        (float const   )0.000909, 
            (float const   )0.003711,        (float const   )(- 0.004235),        (float const   )(- 0.006559),        (float const   )0.012568, 
            (float const   )0.008024,        (float const   )(- 0.032062),        (float const   )(- 0.002471),        (float const   )0.124956, 
            (float const   )0.181779,        (float const   )0.079822,        (float const   )(- 0.026514),        (float const   )(- 0.019931), 
            (float const   )0.015557,        (float const   )0.005567,        (float const   )(- 0.008433),        (float const   )(- 0.000630), 
            (float const   )0.003648,        (float const   )(- 0.000493),        (float const   )(- 0.001198),        (float const   )0.000440}};
#line 77 "/home/wheatley/newnew/temp/multimon-1.0/demod_fsk96.c"
static void fsk96_init(struct demod_state *s ) 
{ 


  {
  {
#line 79
  hdlc_init(s);
#line 80
  memset((void *)(& s->l1.fsk96), 0, sizeof(s->l1.fsk96));
  }
#line 81
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/multimon-1.0/demod_fsk96.c"
static void fsk96_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float f ;
  unsigned char curbit ;
  int i ;
  unsigned int descx ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (length > 0)) {
#line 92
      goto while_break;
    }
#line 93
    i = 0;
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (! (i < 3)) {
#line 93
        goto while_break___0;
      }
      {
#line 94
      f = mac((float const   *)buffer, inp_filt[i], 24U);
#line 95
      s->l1.fsk96.dcd_shreg <<= 1;
#line 96
      s->l1.fsk96.dcd_shreg |= (unsigned int )(f > (float )0);
#line 97
      verbprintf(10, "%c", 48U + (s->l1.fsk96.dcd_shreg & 1U));
      }
#line 101
      if ((s->l1.fsk96.dcd_shreg ^ (s->l1.fsk96.dcd_shreg >> 1)) & 1U) {
#line 102
        if (s->l1.fsk96.sphase < 28013U) {
#line 103
          s->l1.fsk96.sphase += 1188U;
        } else {
#line 105
          s->l1.fsk96.sphase -= 1188U;
        }
      }
#line 107
      s->l1.fsk96.sphase += 9510U;
#line 108
      if (s->l1.fsk96.sphase >= 65536U) {
        {
#line 109
        s->l1.fsk96.sphase &= 65535U;
#line 110
        s->l1.fsk96.descram <<= 1;
#line 111
        s->l1.fsk96.descram |= s->l1.fsk96.dcd_shreg & 1U;
#line 112
        descx = s->l1.fsk96.descram ^ (s->l1.fsk96.descram >> 1);
#line 113
        curbit = (unsigned char )(((((descx >> 17) ^ (descx >> 12)) ^ descx) ^ 1U) & 1U);
#line 115
        verbprintf(9, " %c ", 48 + (int )curbit);
#line 116
        hdlc_rxbit(s, (int )curbit);
        }
      }
#line 93
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    length --;
#line 92
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/multimon-1.0/demod_fsk96.c"
struct demod_param  const  demod_fsk9600  =    {"FSK9600", 22050U, 24U, & fsk96_init, & fsk96_demod};
#line 157 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_param  const  demod_eas ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 60 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static float corr_mark_i[(int )((double )22050 / 520.83)]  ;
#line 61 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static float corr_mark_q[(int )((double )22050 / 520.83)]  ;
#line 62 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static float corr_space_i[(int )((double )22050 / 520.83)]  ;
#line 63 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static float corr_space_q[(int )((double )22050 / 520.83)]  ;
#line 67 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static void eas_init(struct demod_state *s ) 
{ 
  float f ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 72
  hdlc_init(s);
#line 73
  memset((void *)(& s->l1.eas), 0, sizeof(s->l1.eas));
#line 74
  f = (float )0;
#line 74
  i = 0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < (int )((double )22050 / 520.83))) {
#line 74
      goto while_break;
    }
    {
#line 75
    tmp = cos((double )f);
#line 75
    corr_mark_i[i] = (float )tmp;
#line 76
    tmp___0 = sin((double )f);
#line 76
    corr_mark_q[i] = (float )tmp___0;
#line 77
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * 1083.3) / (double )22050);
#line 74
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  f = (float )0;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i < (int )((double )22050 / 520.83))) {
#line 79
      goto while_break___0;
    }
    {
#line 80
    tmp___1 = cos((double )f);
#line 80
    corr_space_i[i] = (float )tmp___1;
#line 81
    tmp___2 = sin((double )f);
#line 81
    corr_space_q[i] = (float )tmp___2;
#line 82
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * 1562.5) / (double )22050);
#line 79
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
static void eas_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float f ;
  unsigned char curbit ;
  int numfill ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
#line 93
  if (s->l1.eas.subsamp) {
#line 94
    numfill = (int )(2U - s->l1.eas.subsamp);
#line 95
    if (length < numfill) {
#line 96
      s->l1.eas.subsamp += (unsigned int )length;
#line 97
      return;
    }
#line 99
    buffer += numfill;
#line 100
    length -= numfill;
#line 101
    s->l1.eas.subsamp = 0U;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (length >= 2)) {
#line 103
      goto while_break;
    }
    {
#line 104
    tmp = mac((float const   *)buffer, (float const   *)(corr_mark_i), (unsigned int )((int )((double )22050 / 520.83)));
#line 104
    tmp___0 = fsqr(tmp);
#line 104
    tmp___1 = mac((float const   *)buffer, (float const   *)(corr_mark_q), (unsigned int )((int )((double )22050 / 520.83)));
#line 104
    tmp___2 = fsqr(tmp___1);
#line 104
    tmp___3 = mac((float const   *)buffer, (float const   *)(corr_space_i), (unsigned int )((int )((double )22050 / 520.83)));
#line 104
    tmp___4 = fsqr(tmp___3);
#line 104
    tmp___5 = mac((float const   *)buffer, (float const   *)(corr_space_q), (unsigned int )((int )((double )22050 / 520.83)));
#line 104
    tmp___6 = fsqr(tmp___5);
#line 104
    f = ((tmp___0 + tmp___2) - tmp___4) - tmp___6;
#line 108
    s->l1.eas.dcd_shreg <<= 1;
#line 109
    s->l1.eas.dcd_shreg |= (unsigned int )(f > (float )0);
#line 110
    verbprintf(10, "%c", 48U + (s->l1.eas.dcd_shreg & 1U));
    }
#line 114
    if ((s->l1.eas.dcd_shreg ^ (s->l1.eas.dcd_shreg >> 1)) & 1U) {
#line 115
      if ((double )s->l1.eas.sphase < (double )32768U - ((((double )65536U * 520.83) * (double )2) / (double )22050) / (double )2) {
#line 116
        s->l1.eas.sphase = (unsigned int )((double )s->l1.eas.sphase + ((((double )65536U * 520.83) * (double )2) / (double )22050) / (double )8);
      } else {
#line 118
        s->l1.eas.sphase = (unsigned int )((double )s->l1.eas.sphase - ((((double )65536U * 520.83) * (double )2) / (double )22050) / (double )8);
      }
    }
#line 120
    s->l1.eas.sphase = (unsigned int )((double )s->l1.eas.sphase + (((double )65536U * 520.83) * (double )2) / (double )22050);
#line 121
    if (s->l1.eas.sphase >= 65536U) {
      {
#line 122
      s->l1.eas.sphase &= 65535U;
#line 123
      s->l1.eas.lasts <<= 1;
#line 124
      s->l1.eas.lasts |= s->l1.eas.dcd_shreg & 1U;
#line 125
      curbit = (unsigned char )(((s->l1.eas.lasts ^ (s->l1.eas.lasts >> 1)) ^ 1U) & 1U);
#line 127
      verbprintf(9, " %c ", 48 + (int )curbit);
#line 128
      hdlc_rxbit(s, (int )curbit);
      }
    }
#line 103
    length -= 2;
#line 103
    buffer += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  s->l1.eas.subsamp = (unsigned int )length;
#line 132
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/multimon-1.0/demod_eas.c"
struct demod_param  const  demod_eas  =    {"EAS", 22050U, (unsigned int )((int )((double )22050 / 520.83)), & eas_init, & eas_demod};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 153 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
struct demod_param  const  demod_poc5 ;
#line 154
struct demod_param  const  demod_poc12 ;
#line 155
struct demod_param  const  demod_poc24 ;
#line 159
struct demod_param  const  demod_afsk1200 ;
#line 160
struct demod_param  const  demod_afsk2400 ;
#line 161
struct demod_param  const  demod_afsk2400_2 ;
#line 163
struct demod_param  const  demod_hapn4800 ;
#line 166
struct demod_param  const  demod_dtmf ;
#line 167
struct demod_param  const  demod_zvei ;
#line 168
struct demod_param  const  demod_ccir ;
#line 170
struct demod_param  const  demod_scope ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 47 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static char const   *allowed_types___0[13]  = 
#line 47 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
  {      "raw",      "aiff",      "au",      "hcom", 
        "sf",      "voc",      "cdr",      "dat", 
        "smp",      "wav",      "maud",      "vwe", 
        (char const   *)((void *)0)};
#line 54 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static struct demod_param  const  *dem[13]  = 
#line 54
  {      & demod_poc5,      & demod_poc12,      & demod_poc24,      & demod_eas, 
        & demod_afsk1200,      & demod_afsk2400,      & demod_afsk2400_2,      & demod_hapn4800, 
        & demod_fsk9600,      & demod_dtmf,      & demod_zvei,      & demod_ccir, 
        & demod_scope};
#line 58 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static struct demod_state dem_st[sizeof(dem) / sizeof(dem[0])]  ;
#line 59 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static unsigned int dem_mask[(sizeof(dem) / sizeof(dem[0]) + 31UL) / 32UL]  ;
#line 67 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static int verbose_level  =    0;
#line 71 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
void verbprintf(int verb_level , char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 75
  __builtin_va_start(args, fmt);
  }
#line 76
  if (verb_level <= verbose_level) {
    {
#line 77
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
             args);
#line 78
    fflush(stdout);
    }
  }
  {
#line 80
  __builtin_va_end(args);
  }
#line 81
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static void process_buffer___0(float *buf , unsigned int len ) 
{ 
  int i ;

  {
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned long )i < sizeof(dem) / sizeof(dem[0]))) {
#line 89
      goto while_break;
    }
#line 90
    if (dem_mask[i >> 5] & (unsigned int )(1 << (i & 31))) {
#line 90
      if ((dem[i])->demod) {
        {
#line 91
        (*((dem[i])->demod))(dem_st + i, buf, (int )len);
        }
      }
    }
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static void input_sound(unsigned int sample_rate , unsigned int overlap , char const   *ifname ) 
{ 
  int sndparam ;
  int fd ;
  union __anonunion_b_55 b ;
  float fbuf[16384] ;
  unsigned int fbuf_cnt ;
  int i ;
  short *sp ;
  unsigned char *bp ;
  int fmt ;
  int stereo ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  unsigned int tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 178
  fbuf_cnt = 0U;
#line 182
  fmt = 0;
#line 183
  stereo = 0;
#line 185
  if (ifname) {
#line 185
    tmp = ifname;
  } else {
#line 185
    tmp = "/dev/dsp";
  }
  {
#line 185
  fd = open(tmp, 0);
  }
#line 185
  if (fd < 0) {
    {
#line 186
    perror("open");
#line 187
    exit(10);
    }
  }
  {
#line 189
  sndparam = 16;
#line 191
  tmp___0 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 191
  if (tmp___0 == -1) {
    {
#line 192
    perror("ioctl: SNDCTL_DSP_SETFMT");
#line 193
    exit(10);
    }
  }
#line 195
  if (sndparam != 16) {
    {
#line 196
    fmt = 1;
#line 197
    sndparam = 8;
#line 198
    tmp___1 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                    & sndparam);
    }
#line 198
    if (tmp___1 == -1) {
      {
#line 199
      perror("ioctl: SNDCTL_DSP_SETFMT");
#line 200
      exit(10);
      }
    }
#line 202
    if (sndparam != 8) {
      {
#line 203
      perror("ioctl: SNDCTL_DSP_SETFMT");
#line 204
      exit(10);
      }
    }
  }
  {
#line 207
  sndparam = 0;
#line 208
  tmp___2 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 208
  if (tmp___2 == -1) {
    {
#line 209
    perror("ioctl: SNDCTL_DSP_STEREO");
#line 210
    exit(10);
    }
  }
#line 212
  if (sndparam == 1) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"soundif: Warning, cannot set the channel number to 1, will use stereo\n");
#line 215
    stereo = 1;
    }
  } else
#line 217
  if (sndparam != 0) {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"soundif: Error, cannot set the channel number to 1\n");
#line 220
    exit(10);
    }
  }
  {
#line 222
  sndparam = (int )sample_rate;
#line 223
  tmp___3 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                  & sndparam);
  }
#line 223
  if (tmp___3 == -1) {
    {
#line 224
    perror("ioctl: SNDCTL_DSP_SPEED");
#line 225
    exit(10);
    }
  }
  {
#line 227
  tmp___4 = abs((int )((unsigned int )sndparam - sample_rate));
  }
#line 227
  if ((unsigned int )(10 * tmp___4) > sample_rate) {
    {
#line 228
    perror("ioctl: SNDCTL_DSP_SPEED");
#line 229
    exit(10);
    }
  }
#line 231
  if ((unsigned int )sndparam != sample_rate) {
    {
#line 232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Sampling rate is %u, requested %u\n",
            sndparam, sample_rate);
    }
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (fmt) {
      {
#line 246
      bp = b.b;
#line 246
      tmp___5 = read(fd, (void *)bp, sizeof(b.b));
#line 246
      i = (int )tmp___5;
      }
#line 247
      if (i < 0) {
        {
#line 247
        tmp___6 = __errno_location();
        }
#line 247
        if (*tmp___6 != 11) {
          {
#line 248
          perror("read");
#line 249
          exit(4);
          }
        }
      }
#line 251
      if (! i) {
#line 252
        goto while_break;
      }
#line 253
      if (i > 0) {
        {
#line 254
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 254
          if (! ((unsigned long )i >= sizeof(b.b[0]))) {
#line 254
            goto while_break___0;
          }
#line 255
          tmp___7 = fbuf_cnt;
#line 255
          fbuf_cnt ++;
#line 255
          fbuf[tmp___7] = (float )((double )((int )*bp - 128) * (1.0 / 128.0));
#line 254
          i = (int )((unsigned long )i - sizeof(b.b[0]));
#line 254
          sp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 256
        if (i) {
          {
#line 257
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: noninteger number of samples read\n");
          }
        }
#line 258
        if (fbuf_cnt > overlap) {
          {
#line 259
          process_buffer___0(fbuf, fbuf_cnt - overlap);
#line 260
          memmove((void *)(fbuf), (void const   *)((fbuf + fbuf_cnt) - overlap), (unsigned long )overlap * sizeof(fbuf[0]));
#line 261
          fbuf_cnt = overlap;
          }
        }
      }
    } else {
      {
#line 265
      sp = b.s;
#line 265
      tmp___8 = read(fd, (void *)sp, sizeof(b.s));
#line 265
      i = (int )tmp___8;
      }
#line 266
      if (i < 0) {
        {
#line 266
        tmp___9 = __errno_location();
        }
#line 266
        if (*tmp___9 != 11) {
          {
#line 267
          perror("read");
#line 268
          exit(4);
          }
        }
      }
#line 270
      if (! i) {
#line 271
        goto while_break;
      }
#line 272
      if (i > 0) {
#line 273
        if (stereo) {
          {
#line 274
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 274
            if (! ((unsigned long )i >= sizeof(b.s[0]))) {
#line 274
              goto while_break___1;
            }
#line 275
            tmp___10 = fbuf_cnt;
#line 275
            fbuf_cnt ++;
#line 275
            fbuf[tmp___10] = (float )((double )*sp * (1.0 / 32768.0));
#line 274
            i = (int )((unsigned long )i - sizeof(b.s[0]) * 2UL);
#line 274
            sp += 2;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 277
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 277
            if (! ((unsigned long )i >= sizeof(b.s[0]))) {
#line 277
              goto while_break___2;
            }
#line 278
            tmp___11 = fbuf_cnt;
#line 278
            fbuf_cnt ++;
#line 278
            fbuf[tmp___11] = (float )((double )*sp * (1.0 / 32768.0));
#line 277
            i = (int )((unsigned long )i - sizeof(b.s[0]));
#line 277
            sp ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 280
        if (i) {
          {
#line 281
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: noninteger number of samples read\n");
          }
        }
#line 282
        if (fbuf_cnt > overlap) {
          {
#line 283
          process_buffer___0(fbuf, fbuf_cnt - overlap);
#line 284
          memmove((void *)(fbuf), (void const   *)((fbuf + fbuf_cnt) - overlap), (unsigned long )overlap * sizeof(fbuf[0]));
#line 285
          fbuf_cnt = overlap;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  close(fd);
  }
#line 291
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static void input_file(unsigned int sample_rate , unsigned int overlap , char const   *fname ,
                       char const   *type ) 
{ 
  struct stat statbuf ;
  int pipedes[2] ;
  int pid ;
  int soxstat ;
  int fd ;
  int i ;
  short buffer[8192] ;
  float fbuf[16384] ;
  unsigned int fbuf_cnt ;
  short *sp ;
  int tmp ;
  int tmp___0 ;
  char srate[8] ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 301
  pid = 0;
#line 306
  fbuf_cnt = 0U;
#line 313
  if (! type) {
#line 313
    goto _L;
  } else {
    {
#line 313
    tmp___2 = strcmp(type, "raw");
    }
#line 313
    if (tmp___2) {
      {
#line 319
      tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& statbuf));
      }
#line 319
      if (tmp) {
        {
#line 320
        perror("stat");
#line 321
        exit(10);
        }
      }
      {
#line 323
      tmp___0 = pipe((int *)(pipedes));
      }
#line 323
      if (tmp___0) {
        {
#line 324
        perror("pipe");
#line 325
        exit(10);
        }
      }
      {
#line 327
      pid = fork();
      }
#line 327
      if (! pid) {
        {
#line 333
        sprintf((char */* __restrict  */)(srate), (char const   */* __restrict  */)"%d",
                sample_rate);
#line 334
        close(pipedes[0]);
#line 335
        close(1);
#line 336
        tmp___1 = dup2(pipedes[1], 1);
        }
#line 336
        if (tmp___1 < 0) {
          {
#line 337
          perror("dup2");
          }
        }
        {
#line 338
        close(pipedes[1]);
#line 339
        execlp("sox", "sox", "-t", type, fname, "-t", "raw", "-s", "-2", "-r", srate,
               "-", (void *)0);
#line 343
        perror("execlp");
#line 344
        exit(10);
        }
      }
#line 346
      if (pid < 0) {
        {
#line 347
        perror("fork");
#line 348
        exit(10);
        }
      }
      {
#line 350
      close(pipedes[1]);
#line 351
      fd = pipedes[0];
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 314
      fd = open(fname, 0);
      }
#line 314
      if (fd < 0) {
        {
#line 315
        perror("open");
#line 316
        exit(10);
        }
      }
    }
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 357
    sp = buffer;
#line 357
    tmp___3 = read(fd, (void *)sp, sizeof(buffer));
#line 357
    i = (int )tmp___3;
    }
#line 358
    if (i < 0) {
      {
#line 358
      tmp___4 = __errno_location();
      }
#line 358
      if (*tmp___4 != 11) {
        {
#line 359
        perror("read");
#line 360
        exit(4);
        }
      }
    }
#line 362
    if (! i) {
#line 363
      goto while_break;
    }
#line 364
    if (i > 0) {
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! ((unsigned long )i >= sizeof(buffer[0]))) {
#line 365
          goto while_break___0;
        }
#line 366
        tmp___5 = fbuf_cnt;
#line 366
        fbuf_cnt ++;
#line 366
        fbuf[tmp___5] = (float )((double )*sp * (1.0 / 32768.0));
#line 365
        i = (int )((unsigned long )i - sizeof(buffer[0]));
#line 365
        sp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 367
      if (i) {
        {
#line 368
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: noninteger number of samples read\n");
        }
      }
#line 369
      if (fbuf_cnt > overlap) {
        {
#line 370
        process_buffer___0(fbuf, fbuf_cnt - overlap);
#line 371
        memmove((void *)(fbuf), (void const   *)((fbuf + fbuf_cnt) - overlap), (unsigned long )overlap * sizeof(fbuf[0]));
#line 372
        fbuf_cnt = overlap;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  close(fd);
#line 377
  waitpid(pid, & soxstat, 0);
  }
#line 378
  return;
}
}
#line 382 "/home/wheatley/newnew/temp/multimon-1.0/unixinput.c"
static char const   usage_str___0[315]  = 
#line 382
  {      (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'\n',      (char const   )'D',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'u',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )' ',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'m', 
        (char const   )'i',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'s',      (char const   )'\n',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'6',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'o',      (char const   )'m',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'S',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'H',      (char const   )'B',      (char const   )'9', 
        (char const   )'J',      (char const   )'N',      (char const   )'X',      (char const   )'/', 
        (char const   )'A',      (char const   )'E',      (char const   )'4',      (char const   )'W', 
        (char const   )'A',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'t',      (char const   )' ',      (char const   )'<', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'p', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )' ',      (char const   )'(',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'r',      (char const   )'a', 
        (char const   )'w',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'q',      (char const   )'u',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'x',      (char const   )')',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'a', 
        (char const   )' ',      (char const   )'<',      (char const   )'d',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'>', 
        (char const   )' ',      (char const   )':',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'s',      (char const   )' ', 
        (char const   )'<',      (char const   )'d',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'>',      (char const   )' ', 
        (char const   )':',      (char const   )' ',      (char const   )'s',      (char const   )'u', 
        (char const   )'b',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'v',      (char const   )' ', 
        (char const   )'<',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )':',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'b',      (char const   )'o',      (char const   )'s', 
        (char const   )'i',      (char const   )'t',      (char const   )'y',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'v',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'(',      (char const   )'0', 
        (char const   )'-',      (char const   )'1',      (char const   )'0',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'q',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )':',      (char const   )' ', 
        (char const   )'q',      (char const   )'u',      (char const   )'i',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'m',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'a',      (char const   )'g',      (char const   )'e', 
        (char const   )'s',      (char const   )'\n',      (char const   )'\000'};
#line 183 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
void pocsag_init(struct demod_state *s ) ;
#line 184
void pocsag_rxbit(struct demod_state *s , int bit ) ;
#line 44 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc5.c"
static void poc5_init(struct demod_state *s ) 
{ 


  {
  {
#line 46
  pocsag_init(s);
#line 47
  memset((void *)(& s->l1.poc5), 0, sizeof(s->l1.poc5));
  }
#line 48
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc5.c"
static void poc5_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  int numfill ;

  {
#line 54
  if (s->l1.poc5.subsamp) {
#line 55
    numfill = (int )(5U - s->l1.poc5.subsamp);
#line 56
    if (length < numfill) {
#line 57
      s->l1.poc5.subsamp += (unsigned int )length;
#line 58
      return;
    }
#line 60
    buffer += numfill;
#line 61
    length -= numfill;
#line 62
    s->l1.poc5.subsamp = 0U;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (length >= 5)) {
#line 64
      goto while_break;
    }
    {
#line 65
    s->l1.poc5.dcd_shreg <<= 1;
#line 66
    s->l1.poc5.dcd_shreg |= (unsigned int )(*buffer > (float )0);
#line 67
    verbprintf(10, "%c", 48U + (s->l1.poc5.dcd_shreg & 1U));
    }
#line 71
    if ((s->l1.poc5.dcd_shreg ^ (s->l1.poc5.dcd_shreg >> 1)) & 1U) {
#line 72
      if (s->l1.poc5.sphase < 28964U) {
#line 73
        s->l1.poc5.sphase += 951U;
      } else {
#line 75
        s->l1.poc5.sphase -= 951U;
      }
    }
#line 77
    s->l1.poc5.sphase += 7608U;
#line 78
    if (s->l1.poc5.sphase >= 65536U) {
      {
#line 79
      s->l1.poc5.sphase &= 65535U;
#line 80
      pocsag_rxbit(s, (int )(s->l1.poc5.dcd_shreg & 1U));
      }
    }
#line 64
    length -= 5;
#line 64
    buffer += 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  s->l1.poc5.subsamp = (unsigned int )length;
#line 84
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc5.c"
struct demod_param  const  demod_poc5  =    {"POCSAG512", 22050U, 1U, & poc5_init, & poc5_demod};
#line 31 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
float const   costabf[1024] ;
#line 40 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
static unsigned int const   ccir_freq___0[16]  = 
#line 40 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
  {      (unsigned int const   )5887,      (unsigned int const   )3340,      (unsigned int const   )3557,      (unsigned int const   )3789, 
        (unsigned int const   )4036,      (unsigned int const   )4297,      (unsigned int const   )4577,      (unsigned int const   )4874, 
        (unsigned int const   )5192,      (unsigned int const   )5528,      (unsigned int const   )7133,      (unsigned int const   )2764, 
        (unsigned int const   )6678,      (unsigned int const   )2945,      (unsigned int const   )6271,      (unsigned int const   )3135};
#line 56 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
static void ccir_init(struct demod_state *s ) 
{ 


  {
  {
#line 58
  memset((void *)(& s->l1.ccir), 0, sizeof(s->l1.ccir));
  }
#line 59
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
static int find_max_idx(float const   *f ) 
{ 
  float en ;
  int idx ;
  int i ;

  {
#line 65
  en = (float )0;
#line 66
  idx = -1;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 16)) {
#line 68
      goto while_break;
    }
#line 69
    if (*(f + i) > (float const   )en) {
#line 70
      en = (float )*(f + i);
#line 71
      idx = i;
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (idx < 0) {
#line 74
    return (-1);
  }
#line 75
  en = (float )((double )en * 0.1);
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! (i < 16)) {
#line 76
      goto while_break___0;
    }
#line 77
    if (idx != i) {
#line 77
      if (*(f + i) > (float const   )en) {
#line 78
        return (-1);
      }
    }
#line 76
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 79
  return (idx);
}
}
#line 84 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
__inline static int process_block(struct demod_state *s ) 
{ 
  float tote ;
  float totte[32] ;
  int i ;
  int j ;
  float tmp ;
  float tmp___0 ;

  {
#line 90
  tote = (float )0;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
#line 92
    tote += s->l1.ccir.energy[i];
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 32)) {
#line 93
      goto while_break___0;
    }
#line 94
    totte[i] = (float )0;
#line 95
    j = 0;
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 95
      if (! (j < 4)) {
#line 95
        goto while_break___1;
      }
#line 96
      totte[i] += s->l1.ccir.tenergy[j][i];
#line 95
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 98
    if (! (i < 16)) {
#line 98
      goto while_break___2;
    }
    {
#line 99
    tmp = fsqr(totte[i]);
#line 99
    tmp___0 = fsqr(totte[i + 16]);
#line 99
    totte[i] = tmp + tmp___0;
#line 98
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 100
  memmove((void *)(s->l1.ccir.energy + 1), (void const   *)(s->l1.ccir.energy), sizeof(s->l1.ccir.energy) - sizeof(s->l1.ccir.energy[0]));
#line 102
  s->l1.ccir.energy[0] = (float )0;
#line 103
  memmove((void *)(s->l1.ccir.tenergy + 1), (void const   *)(s->l1.ccir.tenergy),
          sizeof(s->l1.ccir.tenergy) - sizeof(s->l1.ccir.tenergy[0]));
#line 105
  memset((void *)(s->l1.ccir.tenergy), 0, sizeof(s->l1.ccir.tenergy[0]));
#line 106
  tote = (float )((double )tote * ((double )880 * 0.5));
#line 107
  verbprintf(10, "CCIR: Energies: %8.5f  %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f\n",
             (double )tote, (double )totte[0], (double )totte[1], (double )totte[2],
             (double )totte[3], (double )totte[4], (double )totte[5], (double )totte[6],
             (double )totte[7], (double )totte[8], (double )totte[9], (double )totte[10],
             (double )totte[11], (double )totte[12], (double )totte[13], (double )totte[14],
             (double )totte[15]);
#line 111
  i = find_max_idx((float const   *)(totte));
  }
#line 111
  if (i < 0) {
#line 112
    return (-1);
  }
#line 113
  if ((double )tote * 0.4 > (double )totte[i]) {
#line 114
    return (-1);
  }
#line 115
  return (i);
}
}
#line 120 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
static void ccir_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float s_in ;
  int i ;
  float tmp ;
  int tmp___0 ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (length > 0)) {
#line 125
      goto while_break;
    }
    {
#line 126
    s_in = *buffer;
#line 127
    tmp = fsqr(s_in);
#line 127
    s->l1.ccir.energy[0] += tmp;
#line 128
    i = 0;
    }
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! (i < 16)) {
#line 128
        goto while_break___0;
      }
#line 129
      s->l1.ccir.tenergy[0][i] += (float )(costabf[(s->l1.ccir.ph[i] >> 6) & 1023U] * (float const   )s_in);
#line 130
      s->l1.ccir.tenergy[0][i + 16] += (float )(costabf[((s->l1.ccir.ph[i] + 49152U) >> 6) & 1023U] * (float const   )s_in);
#line 131
      s->l1.ccir.ph[i] += (unsigned int )ccir_freq___0[i];
#line 128
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    tmp___0 = s->l1.ccir.blkcount;
#line 133
    (s->l1.ccir.blkcount) --;
#line 133
    if (tmp___0 <= 0) {
      {
#line 134
      s->l1.ccir.blkcount = 220;
#line 135
      i = process_block(s);
      }
#line 136
      if (i != s->l1.ccir.lastch) {
#line 136
        if (i >= 0) {
          {
#line 137
          verbprintf(0, "CCIR: %1x\n", i);
          }
        }
      }
#line 138
      s->l1.ccir.lastch = i;
    }
#line 125
    length --;
#line 125
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 145 "/home/wheatley/newnew/temp/multimon-1.0/demod_ccir.c"
struct demod_param  const  demod_ccir  =    {"CCIR", 22050U, 0U, & ccir_init, & ccir_demod};
#line 186 "/home/wheatley/newnew/temp/multimon-1.0/multimon.h"
void xdisp_terminate(int cnum ) ;
#line 187
int xdisp_start(void) ;
#line 188
int xdisp_update(int cnum , float *f ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 168 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , union wait *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1534
extern int (*XSynchronize(Display * , int  ))(Display * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1777
extern Window XRootWindow(Display * , int  ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 2000
extern int XAllocNamedColor(Display * , Colormap  , char const   * , XColor * , XColor * ) ;
#line 2104
extern int XCheckIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                         XPointer  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2528
extern int XFree(void * ) ;
#line 2603
extern int XGetErrorDatabaseText(Display * , char const   * , char const   * , char const   * ,
                                 char * , int  ) ;
#line 2612
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3311
extern int XSetState(Display * , GC  , unsigned long  , unsigned long  , int  , unsigned long  ) ;
#line 3970
extern int XInternalConnectionNumbers(Display * , int ** , int * ) ;
#line 3976
extern void XProcessInternalConnection(Display * , int  ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 59 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static Display *display  =    (Display *)((void *)0);
#line 60 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static Window window  ;
#line 61 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static GC gc  ;
#line 62 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static Pixmap pixmap  ;
#line 63 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static unsigned long col_zeroline  ;
#line 64 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static unsigned long col_background  ;
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static unsigned long col_trace  ;
#line 67 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static int cmdpipe[2]  ;
#line 68 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static int datapipe[2]  ;
#line 83 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static struct xdisp cli[16]  = {      {0, 0, 0, 0}};
#line 87 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static int x_error_handler(Display *disp , XErrorEvent *evt ) 
{ 
  char err_buf[256] ;
  char mesg[256] ;
  char number[256] ;
  char *mtype ;

  {
  {
#line 90
  mtype = (char *)"XlibMessage";
#line 92
  XGetErrorText(disp, (int )evt->error_code, err_buf, (int )sizeof(err_buf));
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"X Error: %s\n",
          err_buf);
#line 94
  XGetErrorDatabaseText(disp, (char const   *)mtype, "MajorCode", "Request Major code %d",
                        mesg, (int )sizeof(mesg));
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(mesg),
          (int )evt->request_code);
#line 97
  sprintf((char */* __restrict  */)(number), (char const   */* __restrict  */)"%d",
          (int )evt->request_code);
#line 98
  XGetErrorDatabaseText(disp, "XRequest", (char const   *)(number), "", err_buf, (int )sizeof(err_buf));
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)\n",
          err_buf);
#line 102
  abort();
  }
}
}
#line 107 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static int predicate(Display *display___0 , XEvent *event , char *arg ) 
{ 


  {
#line 109
  return (1);
}
}
#line 118 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static char kbuf[32]  ;
#line 114 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static char *x_getkey(void) 
{ 
  XWindowAttributes winattrs ;
  XEvent evt ;
  int i ;
  int tmp ;

  {
#line 121
  if (! display) {
#line 122
    return ((char *)((void *)0));
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    tmp = XCheckIfEvent(display, & evt, & predicate, (XPointer )((void *)0));
    }
#line 123
    if (! tmp) {
#line 123
      goto while_break;
    }
    {
#line 125
    if (evt.type == 2) {
#line 125
      goto case_2;
    }
#line 133
    if (evt.type == 17) {
#line 133
      goto case_17;
    }
#line 136
    if (evt.type == 12) {
#line 136
      goto case_12;
    }
#line 141
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 126
    i = XLookupString((XKeyEvent *)(& evt), kbuf, (int )(sizeof(kbuf) - 1UL), (KeySym *)((void *)0),
                      (XComposeStatus *)((void *)0));
    }
#line 128
    if (i) {
#line 129
      kbuf[i] = (char)0;
#line 130
      return (kbuf);
    }
#line 132
    goto while_continue;
    case_17: /* CIL Label */ 
    {
#line 134
    XCloseDisplay(display);
#line 135
    exit(0);
    }
    case_12: /* CIL Label */ 
    {
#line 137
    XGetWindowAttributes(display, window, & winattrs);
#line 138
    XCopyArea(display, window, pixmap, gc, 0, 0, (unsigned int )winattrs.width, (unsigned int )winattrs.height,
              0, 0);
    }
#line 140
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 142
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return ((char *)((void *)0));
}
}
#line 150 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static void process_keystrokes(void) 
{ 
  char *cp ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    cp = x_getkey();
    }
#line 154
    if (! cp) {
#line 154
      goto while_break;
    }
    {
#line 155
    printf((char const   */* __restrict  */)"X: Keys pressed: %s\n", cp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static int do_x_select(int fd , int wr ) 
{ 
  int *xconn ;
  int xconnnum ;
  int max ;
  int i ;
  fd_set rmask ;
  fd_set wmask ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;

  {
  {
#line 164
  max = fd;
#line 167
  tmp = XInternalConnectionNumbers(display, & xconn, & xconnnum);
  }
#line 167
  if (! tmp) {
    {
#line 168
    perror("XInternalConnectionNumbers");
#line 169
    exit(1);
    }
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rmask.__fds_bits[0]): "memory");
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 172
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& wmask.__fds_bits[0]): "memory");
#line 172
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (wr) {
#line 174
    wmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 176
    rmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (! (i < xconnnum)) {
#line 177
      goto while_break___1;
    }
#line 178
    rmask.__fds_bits[*(xconn + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(xconn + i) % (8 * (int )sizeof(__fd_mask ));
#line 179
    if (*(xconn + i) > max) {
#line 180
      max = *(xconn + i);
    }
#line 177
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 182
  i = select(max + 1, (fd_set */* __restrict  */)(& rmask), (fd_set */* __restrict  */)(& wmask),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
  }
#line 183
  if (i < 0) {
    {
#line 184
    perror("select");
#line 185
    exit(1);
    }
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (! (i < xconnnum)) {
#line 187
      goto while_break___2;
    }
#line 188
    if ((rmask.__fds_bits[*(xconn + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(xconn + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 189
      XProcessInternalConnection(display, *(xconn + i));
      }
    }
#line 187
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 190
  XFree((void *)xconn);
#line 191
  process_keystrokes();
  }
#line 192
  if (wr) {
#line 193
    return ((wmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L);
  } else {
#line 195
    return ((rmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L);
  }
}
}
#line 200 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static void child_win_init(void) 
{ 
  XSetWindowAttributes attr ;
  XGCValues gcv ;
  XColor color ;
  XColor dummy ;
  XSizeHints sizehints ;
  Window tmp ;

  {
  {
#line 210
  display = XOpenDisplay((char const   *)((void *)0));
  }
#line 210
  if (! display) {
    {
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"X: Unable to open X display\n");
#line 212
    exit(1);
    }
  }
  {
#line 214
  XSetErrorHandler(& x_error_handler);
#line 215
  XAllocNamedColor(display, (((_XPrivDisplay )display)->screens + 0)->cmap, "red",
                   & color, & dummy);
#line 217
  col_zeroline = color.pixel;
#line 218
  col_background = (((_XPrivDisplay )display)->screens + 0)->white_pixel;
#line 219
  col_trace = (((_XPrivDisplay )display)->screens + 0)->black_pixel;
#line 220
  attr.background_pixel = col_background;
#line 221
  tmp = XRootWindow(display, 0);
#line 221
  window = XCreateWindow(display, tmp, 200, 200, 512U, 256U, 5U, (((_XPrivDisplay )display)->screens + 0)->root_depth,
                         1U, (((_XPrivDisplay )display)->screens + 0)->root_visual,
                         (unsigned long )(1L << 1), & attr);
#line 226
  pixmap = XCreatePixmap(display, window, 512U, 256U, (unsigned int )(((_XPrivDisplay )display)->screens + 0)->root_depth);
  }
#line 226
  if (! pixmap) {
    {
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"X: unable to open offscreen pixmap\n");
#line 229
    exit(1);
    }
  }
  {
#line 231
  XSelectInput(display, window, (1L | (1L << 17)) | (1L << 15));
#line 233
  gcv.line_width = 1;
#line 234
  gcv.line_style = 0;
#line 235
  gc = XCreateGC(display, pixmap, (unsigned long )((1L << 2) | (1L << 4)), & gcv);
#line 239
  memset((void *)(& sizehints), 0, sizeof(sizehints));
#line 240
  sizehints.max_width = 512;
#line 240
  sizehints.min_width = sizehints.max_width;
#line 241
  sizehints.max_height = 256;
#line 241
  sizehints.min_height = sizehints.max_height;
#line 242
  sizehints.flags = (1L << 4) | (1L << 5);
#line 243
  XSetWMNormalHints(display, window, & sizehints);
#line 244
  XMapWindow(display, window);
#line 245
  XSynchronize(display, 1);
  }
#line 246
  return;
}
}
#line 252 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static void child_process(void) 
{ 
  union comdata d ;
  unsigned char *bp ;
  int i ;
  int j ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 265
      tmp = do_x_select(cmdpipe[1], 1);
      }
#line 265
      if (tmp) {
#line 265
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 266
    tmp___0 = write(cmdpipe[1], (void const   *)"r", (size_t )1);
#line 266
    i = (int )tmp___0;
    }
#line 267
    if (i < 1) {
      {
#line 268
      perror("write");
#line 269
      exit(1);
      }
    }
#line 274
    j = (int )sizeof(d);
#line 274
    bp = d.b;
    {
#line 274
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 274
      if (! (j > 0)) {
#line 274
        goto while_break___1;
      }
      {
#line 275
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 275
        tmp___1 = do_x_select(datapipe[0], 0);
        }
#line 275
        if (tmp___1) {
#line 275
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 276
      tmp___2 = read(datapipe[0], (void *)bp, (size_t )j);
#line 276
      i = (int )tmp___2;
      }
#line 277
      if (i < 1) {
        {
#line 278
        perror("read");
#line 279
        exit(1);
        }
      }
#line 281
      j -= i;
#line 282
      bp += i;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 287
    XSetState(display, gc, col_background, col_background, 3, (unsigned long )(~ 0L));
#line 289
    XFillRectangle(display, pixmap, gc, 0, 0, 512U, 256U);
#line 294
    XSetForeground(display, gc, col_zeroline);
#line 295
    XDrawLine(display, pixmap, gc, 0, 128, 512, 128);
#line 300
    XSetForeground(display, gc, col_trace);
#line 301
    i = 1;
    }
    {
#line 301
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 301
      if (! (i < 512)) {
#line 301
        goto while_break___3;
      }
      {
#line 302
      XDrawLine(display, pixmap, gc, i - 1, ((int )d.s[i - 1] >> 8) + 128, i, ((int )d.s[i] >> 8) + 128);
#line 301
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 304
    XCopyArea(display, pixmap, window, gc, 0, 0, 512U, 256U, 0, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  XDestroyWindow(display, window);
#line 309
  XCloseDisplay(display);
  }
}
}
#line 314 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
static void sigchld_handler(int sig ) 
{ 
  pid_t pid ;
  int st ;
  unsigned int cnum ;

  {
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    pid = wait4(0, (union wait *)(& st), 1, (struct rusage *)((void *)0));
    }
#line 320
    if (! (pid != -1)) {
#line 320
      goto while_break;
    }
#line 321
    cnum = 0U;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! (cnum < 16U)) {
#line 321
        goto while_break___0;
      }
#line 322
      if (cli[cnum].used) {
#line 322
        if (cli[cnum].pid == pid) {
          {
#line 323
          cli[cnum].used = 0;
#line 324
          close(cli[cnum].cmdfd);
#line 325
          close(cli[cnum].datafd);
#line 326
          cli[cnum].pid = -1;
#line 327
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"child process %i died, status %i\n",
                  pid, st);
          }
        }
      }
#line 321
      cnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
void xdisp_terminate(int cnum ) 
{ 


  {
#line 337
  if (cnum < 0) {
#line 338
    return;
  } else
#line 337
  if (cnum >= 16) {
#line 338
    return;
  }
#line 339
  if (! cli[cnum].used) {
#line 340
    return;
  }
  {
#line 341
  kill(cli[cnum].pid, 15);
  }
#line 342
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
int xdisp_start(void) 
{ 
  unsigned int cnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  pid_t tmp___2 ;

  {
#line 353
  cnum = 0U;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (cnum < 16U) {
#line 353
      if (! cli[cnum].used) {
#line 353
        goto while_break;
      }
    } else {
#line 353
      goto while_break;
    }
#line 353
    cnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (cnum >= 16U) {
#line 355
    return (-1);
  }
  {
#line 356
  signal(17, & sigchld_handler);
#line 360
  tmp = pipe((int *)(cmdpipe));
  }
#line 360
  if (tmp) {
#line 361
    return (-1);
  }
  {
#line 362
  tmp___0 = pipe((int *)(datapipe));
  }
#line 362
  if (tmp___0) {
    {
#line 363
    close(cmdpipe[0]);
#line 364
    close(cmdpipe[1]);
    }
  }
  {
#line 366
  tmp___2 = fork();
#line 366
  cli[cnum].pid = tmp___2;
  }
#line 366
  if (tmp___2) {
#line 367
    if (cli[cnum].pid == -1) {
      {
#line 369
      close(cmdpipe[0]);
#line 370
      close(cmdpipe[1]);
#line 371
      close(datapipe[0]);
#line 372
      close(datapipe[1]);
      }
#line 373
      return (-1);
    }
    {
#line 376
    cli[cnum].cmdfd = cmdpipe[0];
#line 377
    close(cmdpipe[1]);
#line 378
    close(datapipe[0]);
#line 379
    cli[cnum].datafd = datapipe[1];
#line 380
    cli[cnum].used = 1;
#line 381
    tmp___1 = fcntl(cmdpipe[0], 3, 0);
#line 381
    fcntl(cmdpipe[0], 4, tmp___1 | 2048);
    }
#line 383
    return ((int )cnum);
  }
  {
#line 388
  close(cmdpipe[0]);
#line 389
  close(datapipe[1]);
#line 390
  close(0);
#line 391
  child_win_init();
#line 392
  child_process();
#line 393
  exit(0);
  }
}
}
#line 398 "/home/wheatley/newnew/temp/multimon-1.0/xdisplay.c"
int xdisp_update(int cnum , float *f ) 
{ 
  unsigned char *bp ;
  short *sp ;
  int i ;
  int j ;
  char c ;
  union comdata d ;
  ssize_t tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 406
  if (cnum < 0) {
#line 407
    return (0);
  } else
#line 406
  if (cnum >= 16) {
#line 407
    return (0);
  }
#line 408
  if (! cli[cnum].used) {
#line 409
    return (0);
  }
  {
#line 410
  tmp = read(cli[cnum].cmdfd, (void *)(& c), (size_t )1);
#line 410
  i = (int )tmp;
  }
#line 411
  if (i < 0) {
    {
#line 411
    tmp___0 = __errno_location();
    }
#line 411
    if (*tmp___0 != 11) {
      {
#line 412
      perror("read");
#line 413
      xdisp_terminate(cnum);
      }
#line 414
      return (0);
    }
  }
#line 416
  if (i < 1) {
#line 417
    return (0);
  }
#line 418
  if ((int )c != 114) {
#line 419
    return (0);
  }
#line 420
  sp = d.s;
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (i < 512)) {
#line 420
      goto while_break;
    }
#line 421
    if (*f >= (float )1) {
#line 422
      *sp = (short)32767;
    } else
#line 423
    if (*f <= (float )-1) {
#line 424
      *sp = (short)-32767;
    } else {
#line 426
      *sp = (short )(32767.0 * (double )*f);
    }
#line 420
    i ++;
#line 420
    sp ++;
#line 420
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  bp = d.b;
#line 429
  j = (int )sizeof(d);
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 430
    if (! (j > 0)) {
#line 430
      goto while_break___0;
    }
    {
#line 431
    tmp___1 = write(cli[cnum].datafd, (void const   *)bp, (size_t )j);
#line 431
    i = (int )tmp___1;
    }
#line 432
    if (i < 0) {
      {
#line 432
      tmp___2 = __errno_location();
      }
#line 432
      if (*tmp___2 != 11) {
        {
#line 433
        perror("write");
#line 434
        xdisp_terminate(cnum);
        }
#line 435
        return (0);
      }
    }
#line 437
    if (i > 0) {
#line 438
      bp += i;
#line 439
      j -= i;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 442
  return (1);
}
}
#line 48 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static float corr_mark_i___0[18]  ;
#line 49 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static float corr_mark_q___0[18]  ;
#line 50 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static float corr_space_i___0[18]  ;
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static float corr_space_q___0[18]  ;
#line 55 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static void afsk12_init(struct demod_state *s ) 
{ 
  float f ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 60
  hdlc_init(s);
#line 61
  memset((void *)(& s->l1.afsk12), 0, sizeof(s->l1.afsk12));
#line 62
  f = (float )0;
#line 62
  i = 0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < 18)) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp = cos((double )f);
#line 63
    corr_mark_i___0[i] = (float )tmp;
#line 64
    tmp___0 = sin((double )f);
#line 64
    corr_mark_q___0[i] = (float )tmp___0;
#line 65
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )1200) / (double )22050);
#line 62
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  f = (float )0;
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < 18)) {
#line 67
      goto while_break___0;
    }
    {
#line 68
    tmp___1 = cos((double )f);
#line 68
    corr_space_i___0[i] = (float )tmp___1;
#line 69
    tmp___2 = sin((double )f);
#line 69
    corr_space_q___0[i] = (float )tmp___2;
#line 70
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )2200) / (double )22050);
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
static void afsk12_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float f ;
  unsigned char curbit ;
  int numfill ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
#line 81
  if (s->l1.afsk12.subsamp) {
#line 82
    numfill = (int )(2U - s->l1.afsk12.subsamp);
#line 83
    if (length < numfill) {
#line 84
      s->l1.afsk12.subsamp += (unsigned int )length;
#line 85
      return;
    }
#line 87
    buffer += numfill;
#line 88
    length -= numfill;
#line 89
    s->l1.afsk12.subsamp = 0U;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (length >= 2)) {
#line 91
      goto while_break;
    }
    {
#line 92
    tmp = mac((float const   *)buffer, (float const   *)(corr_mark_i___0), 18U);
#line 92
    tmp___0 = fsqr(tmp);
#line 92
    tmp___1 = mac((float const   *)buffer, (float const   *)(corr_mark_q___0), 18U);
#line 92
    tmp___2 = fsqr(tmp___1);
#line 92
    tmp___3 = mac((float const   *)buffer, (float const   *)(corr_space_i___0), 18U);
#line 92
    tmp___4 = fsqr(tmp___3);
#line 92
    tmp___5 = mac((float const   *)buffer, (float const   *)(corr_space_q___0), 18U);
#line 92
    tmp___6 = fsqr(tmp___5);
#line 92
    f = ((tmp___0 + tmp___2) - tmp___4) - tmp___6;
#line 96
    s->l1.afsk12.dcd_shreg <<= 1;
#line 97
    s->l1.afsk12.dcd_shreg |= (unsigned int )(f > (float )0);
#line 98
    verbprintf(10, "%c", 48U + (s->l1.afsk12.dcd_shreg & 1U));
    }
#line 102
    if ((s->l1.afsk12.dcd_shreg ^ (s->l1.afsk12.dcd_shreg >> 1)) & 1U) {
#line 103
      if (s->l1.afsk12.sphase < 29202U) {
#line 104
        s->l1.afsk12.sphase += 891U;
      } else {
#line 106
        s->l1.afsk12.sphase -= 891U;
      }
    }
#line 108
    s->l1.afsk12.sphase += 7133U;
#line 109
    if (s->l1.afsk12.sphase >= 65536U) {
      {
#line 110
      s->l1.afsk12.sphase &= 65535U;
#line 111
      s->l1.afsk12.lasts <<= 1;
#line 112
      s->l1.afsk12.lasts |= s->l1.afsk12.dcd_shreg & 1U;
#line 113
      curbit = (unsigned char )(((s->l1.afsk12.lasts ^ (s->l1.afsk12.lasts >> 1)) ^ 1U) & 1U);
#line 115
      verbprintf(9, " %c ", 48 + (int )curbit);
#line 116
      hdlc_rxbit(s, (int )curbit);
      }
    }
#line 91
    length -= 2;
#line 91
    buffer += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  s->l1.afsk12.subsamp = (unsigned int )length;
#line 120
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk12.c"
struct demod_param  const  demod_afsk1200  =    {"AFSK1200", 22050U, 18U, & afsk12_init, & afsk12_demod};
#line 45 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc12.c"
static void poc12_init(struct demod_state *s ) 
{ 


  {
  {
#line 47
  pocsag_init(s);
#line 48
  memset((void *)(& s->l1.poc12), 0, sizeof(s->l1.poc12));
  }
#line 49
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc12.c"
static void poc12_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  int numfill ;

  {
#line 55
  if (s->l1.poc12.subsamp) {
#line 56
    numfill = (int )(2U - s->l1.poc12.subsamp);
#line 57
    if (length < numfill) {
#line 58
      s->l1.poc12.subsamp += (unsigned int )length;
#line 59
      return;
    }
#line 61
    buffer += numfill;
#line 62
    length -= numfill;
#line 63
    s->l1.poc12.subsamp = 0U;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (length >= 2)) {
#line 65
      goto while_break;
    }
    {
#line 66
    s->l1.poc12.dcd_shreg <<= 1;
#line 67
    s->l1.poc12.dcd_shreg |= (unsigned int )(*buffer > (float )0);
#line 68
    verbprintf(10, "%c", 48U + (s->l1.poc12.dcd_shreg & 1U));
    }
#line 72
    if ((s->l1.poc12.dcd_shreg ^ (s->l1.poc12.dcd_shreg >> 1)) & 1U) {
#line 73
      if (s->l1.poc12.sphase < 29202U) {
#line 74
        s->l1.poc12.sphase += 891U;
      } else {
#line 76
        s->l1.poc12.sphase -= 891U;
      }
    }
#line 78
    s->l1.poc12.sphase += 7133U;
#line 79
    if (s->l1.poc12.sphase >= 65536U) {
      {
#line 80
      s->l1.poc12.sphase &= 65535U;
#line 81
      pocsag_rxbit(s, (int )(s->l1.poc12.dcd_shreg & 1U));
      }
    }
#line 65
    length -= 2;
#line 65
    buffer += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  s->l1.poc12.subsamp = (unsigned int )length;
#line 85
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc12.c"
struct demod_param  const  demod_poc12  =    {"POCSAG1200", 22050U, 1U, & poc12_init, & poc12_demod};
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
static unsigned int const   zvei_freq___0[16]  = 
#line 37 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
  {      (unsigned int const   )7133,      (unsigned int const   )3150,      (unsigned int const   )3447,      (unsigned int const   )3774, 
        (unsigned int const   )4161,      (unsigned int const   )4547,      (unsigned int const   )4963,      (unsigned int const   )5439, 
        (unsigned int const   )5944,      (unsigned int const   )6538,      (unsigned int const   )8322,      (unsigned int const   )2407, 
        (unsigned int const   )2882,      (unsigned int const   )2633,      (unsigned int const   )7727,      (unsigned int const   )0};
#line 53 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
static void zvei_init(struct demod_state *s ) 
{ 


  {
  {
#line 55
  memset((void *)(& s->l1.zvei), 0, sizeof(s->l1.zvei));
  }
#line 56
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
static int find_max_idx___0(float const   *f ) 
{ 
  float en ;
  int idx ;
  int i ;

  {
#line 62
  en = (float )0;
#line 63
  idx = -1;
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < 16)) {
#line 65
      goto while_break;
    }
#line 66
    if (*(f + i) > (float const   )en) {
#line 67
      en = (float )*(f + i);
#line 68
      idx = i;
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  if (idx < 0) {
#line 71
    return (-1);
  }
#line 72
  en = (float )((double )en * 0.1);
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (i < 16)) {
#line 73
      goto while_break___0;
    }
#line 74
    if (idx != i) {
#line 74
      if (*(f + i) > (float const   )en) {
#line 75
        return (-1);
      }
    }
#line 73
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  return (idx);
}
}
#line 81 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
__inline static int process_block___0(struct demod_state *s ) 
{ 
  float tote ;
  float totte[32] ;
  int i ;
  int j ;
  float tmp ;
  float tmp___0 ;

  {
#line 87
  tote = (float )0;
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 4)) {
#line 88
      goto while_break;
    }
#line 89
    tote += s->l1.zvei.energy[i];
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < 32)) {
#line 90
      goto while_break___0;
    }
#line 91
    totte[i] = (float )0;
#line 92
    j = 0;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (! (j < 4)) {
#line 92
        goto while_break___1;
      }
#line 93
      totte[i] += s->l1.zvei.tenergy[j][i];
#line 92
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 90
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 95
    if (! (i < 16)) {
#line 95
      goto while_break___2;
    }
    {
#line 96
    tmp = fsqr(totte[i]);
#line 96
    tmp___0 = fsqr(totte[i + 16]);
#line 96
    totte[i] = tmp + tmp___0;
#line 95
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 97
  memmove((void *)(s->l1.zvei.energy + 1), (void const   *)(s->l1.zvei.energy), sizeof(s->l1.zvei.energy) - sizeof(s->l1.zvei.energy[0]));
#line 99
  s->l1.zvei.energy[0] = (float )0;
#line 100
  memmove((void *)(s->l1.zvei.tenergy + 1), (void const   *)(s->l1.zvei.tenergy),
          sizeof(s->l1.zvei.tenergy) - sizeof(s->l1.zvei.tenergy[0]));
#line 102
  memset((void *)(s->l1.zvei.tenergy), 0, sizeof(s->l1.zvei.tenergy[0]));
#line 103
  tote = (float )((double )tote * ((double )880 * 0.5));
#line 104
  verbprintf(10, "ZVEI: Energies: %8.5f  %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f\n",
             (double )tote, (double )totte[0], (double )totte[1], (double )totte[2],
             (double )totte[3], (double )totte[4], (double )totte[5], (double )totte[6],
             (double )totte[7], (double )totte[8], (double )totte[9], (double )totte[10],
             (double )totte[11], (double )totte[12], (double )totte[13], (double )totte[14],
             (double )totte[15]);
#line 108
  i = find_max_idx___0((float const   *)(totte));
  }
#line 108
  if (i < 0) {
#line 109
    return (-1);
  }
#line 110
  if ((double )tote * 0.4 > (double )totte[i]) {
#line 111
    return (-1);
  }
#line 112
  return (i);
}
}
#line 117 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
static void zvei_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float s_in ;
  int i ;
  float tmp ;
  int tmp___0 ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (length > 0)) {
#line 122
      goto while_break;
    }
    {
#line 123
    s_in = *buffer;
#line 124
    tmp = fsqr(s_in);
#line 124
    s->l1.zvei.energy[0] += tmp;
#line 125
    i = 0;
    }
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      if (! (i < 16)) {
#line 125
        goto while_break___0;
      }
#line 126
      s->l1.zvei.tenergy[0][i] += (float )(costabf[(s->l1.zvei.ph[i] >> 6) & 1023U] * (float const   )s_in);
#line 127
      s->l1.zvei.tenergy[0][i + 16] += (float )(costabf[((s->l1.zvei.ph[i] + 49152U) >> 6) & 1023U] * (float const   )s_in);
#line 128
      s->l1.zvei.ph[i] += (unsigned int )zvei_freq___0[i];
#line 125
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    tmp___0 = s->l1.zvei.blkcount;
#line 130
    (s->l1.zvei.blkcount) --;
#line 130
    if (tmp___0 <= 0) {
      {
#line 131
      s->l1.zvei.blkcount = 220;
#line 132
      i = process_block___0(s);
      }
#line 133
      if (i != s->l1.zvei.lastch) {
#line 133
        if (i >= 0) {
          {
#line 134
          verbprintf(0, "ZVEI: %1x\n", i);
          }
        }
      }
#line 135
      s->l1.zvei.lastch = i;
    }
#line 122
    length --;
#line 122
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/multimon-1.0/demod_zvei.c"
struct demod_param  const  demod_zvei  =    {"ZVEI", 22050U, 0U, & zvei_init, & zvei_demod};
#line 40 "/home/wheatley/newnew/temp/multimon-1.0/demod_hapn48.c"
static void hapn48_init(struct demod_state *s ) 
{ 


  {
  {
#line 42
  hdlc_init(s);
#line 43
  memset((void *)(& s->l1.hapn48), 0, sizeof(s->l1.hapn48));
  }
#line 44
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/multimon-1.0/demod_hapn48.c"
static void hapn48_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  int cursync ;
  unsigned int curbit ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (length > 0)) {
#line 53
      goto while_break;
    }
#line 54
    s->l1.hapn48.lvlhi = (float )((double )s->l1.hapn48.lvlhi * 0.999);
#line 55
    s->l1.hapn48.lvllo = (float )((double )s->l1.hapn48.lvllo * 0.999);
#line 56
    if (*(buffer + 1) > s->l1.hapn48.lvlhi) {
#line 57
      s->l1.hapn48.lvlhi = *(buffer + 1);
    }
#line 58
    if (*(buffer + 1) < s->l1.hapn48.lvllo) {
#line 59
      s->l1.hapn48.lvllo = *(buffer + 1);
    }
#line 60
    cursync = 0;
#line 61
    s->l1.hapn48.shreg = (s->l1.hapn48.shreg << 1) | (s->l1.hapn48.shreg & 1U);
#line 63
    if ((double )*(buffer + 1) > (double )s->l1.hapn48.lvlhi * 0.5) {
#line 64
      s->l1.hapn48.shreg |= 1U;
#line 65
      if (*(buffer + 1) > *(buffer + 0)) {
#line 65
        if (*(buffer + 1) > *(buffer + 2)) {
#line 65
          tmp = 1;
        } else {
#line 65
          tmp = 0;
        }
      } else {
#line 65
        tmp = 0;
      }
#line 65
      cursync = tmp;
    } else
#line 66
    if ((double )*(buffer + 1) < (double )s->l1.hapn48.lvllo * 0.5) {
#line 67
      s->l1.hapn48.shreg &= 4294967294U;
#line 68
      if (*(buffer + 1) < *(buffer + 0)) {
#line 68
        if (*(buffer + 1) < *(buffer + 2)) {
#line 68
          tmp___0 = 1;
        } else {
#line 68
          tmp___0 = 0;
        }
      } else {
#line 68
        tmp___0 = 0;
      }
#line 68
      cursync = tmp___0;
    }
    {
#line 70
    verbprintf(10, "%c", 48U + (s->l1.hapn48.shreg & 1U));
#line 71
    s->l1.hapn48.sphase += 14266U;
    }
#line 72
    if (((s->l1.hapn48.shreg >> 1) ^ s->l1.hapn48.shreg) & 1U) {
#line 73
      if (s->l1.hapn48.sphase >= 39901U) {
#line 74
        s->l1.hapn48.sphase -= 2048U;
      } else {
#line 76
        s->l1.hapn48.sphase += 2048U;
      }
    }
#line 86
    if (s->l1.hapn48.sphase >= 65536U) {
      {
#line 87
      s->l1.hapn48.sphase &= 65535U;
#line 88
      curbit = (((s->l1.hapn48.shreg >> 4) ^ s->l1.hapn48.shreg) ^ 1U) & 1U;
#line 89
      verbprintf(9, " %c ", 48U + curbit);
#line 90
      hdlc_rxbit(s, (int )curbit);
      }
    }
#line 53
    length --;
#line 53
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/multimon-1.0/demod_hapn48.c"
struct demod_param  const  demod_hapn4800  =    {"HAPN4800", 22050U, 3U, & hapn48_init, & hapn48_demod};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 61 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static unsigned char service_mask  =    (unsigned char)135;
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
__inline static unsigned char even_parity(unsigned long data ) 
{ 
  unsigned int temp ;

  {
#line 67
  temp = (unsigned int )(data ^ (data >> 16));
#line 69
  temp ^= temp >> 8;
#line 70
  temp ^= temp >> 4;
#line 71
  temp ^= temp >> 2;
#line 72
  temp ^= temp >> 1;
#line 73
  return ((unsigned char )(temp & 1U));
}
}
#line 96 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static unsigned int pocsag_syndrome(unsigned long data ) 
{ 
  unsigned long shreg ;
  unsigned long mask ;
  unsigned long coeff ;
  int n ;
  unsigned char tmp ;

  {
#line 98
  shreg = data >> 1;
#line 99
  mask = (unsigned long )(1L << 30);
#line 99
  coeff = (unsigned long )(1897 << 20);
#line 100
  n = 21;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (n > 0)) {
#line 102
      goto while_break;
    }
#line 103
    if (shreg & mask) {
#line 104
      shreg ^= coeff;
    }
#line 102
    mask >>= 1;
#line 102
    coeff >>= 1;
#line 102
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  tmp = even_parity(data);
  }
#line 105
  if (tmp) {
#line 106
    shreg |= (unsigned long )(1 << 10);
  }
  {
#line 107
  verbprintf(9, "BCH syndrome: data: %08lx syn: %08lx\n", data, shreg);
  }
#line 108
  return ((unsigned int )shreg);
}
}
#line 115
static void print_msg_numeric(struct l2_pocsag_rx *rx ) ;
#line 115 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static char const   *conv_table  =    "084 2.6]195-3U7[";
#line 113 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static void print_msg_numeric(struct l2_pocsag_rx *rx ) 
{ 
  unsigned char *bp ;
  int len ;
  char buf[256] ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 116
  bp = rx->buffer;
#line 117
  len = (int )rx->numnibbles;
#line 118
  cp = buf;
#line 120
  if ((unsigned long )len >= sizeof(buf)) {
#line 121
    len = (int )(sizeof(buf) - 1UL);
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (len > 0)) {
#line 122
      goto while_break;
    }
#line 123
    tmp = cp;
#line 123
    cp ++;
#line 123
    *tmp = (char )*(conv_table + (((int )*bp >> 4) & 15));
#line 124
    if (len > 1) {
#line 125
      tmp___0 = cp;
#line 125
      cp ++;
#line 125
      *tmp___0 = (char )*(conv_table + ((int )*bp & 15));
    }
#line 122
    bp ++;
#line 122
    len -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  *cp = (char )'\000';
#line 128
  verbprintf(0, "%s\n", buf);
  }
#line 129
  return;
}
}
#line 135
static char *translate_alpha(unsigned char chr ) ;
#line 135 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static struct trtab  const  trtab[39]  = 
#line 135
  {      {(unsigned char)0, (char *)"<NUL>"}, 
        {(unsigned char)1, (char *)"<SOH>"}, 
        {(unsigned char)2, (char *)"<STX>"}, 
        {(unsigned char)3, (char *)"<ETX>"}, 
        {(unsigned char)4, (char *)"<EOT>"}, 
        {(unsigned char)5, (char *)"<ENQ>"}, 
        {(unsigned char)6, (char *)"<ACK>"}, 
        {(unsigned char)7, (char *)"<BEL>"}, 
        {(unsigned char)8, (char *)"<BS>"}, 
        {(unsigned char)9, (char *)"<HT>"}, 
        {(unsigned char)10, (char *)"<LF>"}, 
        {(unsigned char)11, (char *)"<VT>"}, 
        {(unsigned char)12, (char *)"<FF>"}, 
        {(unsigned char)13, (char *)"<CR>"}, 
        {(unsigned char)14, (char *)"<SO>"}, 
        {(unsigned char)15, (char *)"<SI>"}, 
        {(unsigned char)16, (char *)"<DLE>"}, 
        {(unsigned char)17, (char *)"<DC1>"}, 
        {(unsigned char)18, (char *)"<DC2>"}, 
        {(unsigned char)19, (char *)"<DC3>"}, 
        {(unsigned char)20, (char *)"<DC4>"}, 
        {(unsigned char)21, (char *)"<NAK>"}, 
        {(unsigned char)22, (char *)"<SYN>"}, 
        {(unsigned char)23, (char *)"<ETB>"}, 
        {(unsigned char)24, (char *)"<CAN>"}, 
        {(unsigned char)25, (char *)"<EM>"}, 
        {(unsigned char)26, (char *)"<SUB>"}, 
        {(unsigned char)27, (char *)"<ESC>"}, 
        {(unsigned char)28, (char *)"<FS>"}, 
        {(unsigned char)29, (char *)"<GS>"}, 
        {(unsigned char)30, (char *)"<RS>"}, 
        {(unsigned char)31, (char *)"<US>"}, 
        {(unsigned char)91, (char *)"\304"}, 
        {(unsigned char)92, (char *)"\326"}, 
        {(unsigned char)93, (char *)"\334"}, 
        {(unsigned char)123, (char *)"\344"}, 
        {(unsigned char)124, (char *)"\366"}, 
        {(unsigned char)125, (char *)"\374"}, 
        {(unsigned char)126, (char *)"\337"}};
#line 133 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static char *translate_alpha(unsigned char chr ) 
{ 
  int min ;
  int max ;
  int mid ;
  struct trtab  const  *tb ;
  int cmp ;

  {
#line 187
  min = 0;
#line 187
  max = (int )(sizeof(trtab) / sizeof(trtab[0]) - 1UL);
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    mid = (min + max) >> 1;
#line 194
    tb = trtab + mid;
#line 195
    cmp = (int )tb->code - (int )chr;
#line 197
    if (! cmp) {
#line 198
      return ((char *)tb->str);
    }
#line 199
    if (cmp < 0) {
#line 200
      min = mid + 1;
#line 201
      if (min > max) {
#line 202
        return ((char *)((void *)0));
      }
    }
#line 204
    if (cmp > 0) {
#line 205
      max = mid - 1;
#line 206
      if (max < min) {
#line 207
        return ((char *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static void print_msg_alpha(struct l2_pocsag_rx *rx ) 
{ 
  unsigned long data ;
  int datalen ;
  unsigned char *bp ;
  int len ;
  char buf[256] ;
  char *cp ;
  int buffree ;
  unsigned char curchr ;
  char *tstr ;
  unsigned char *tmp ;
  int tlen ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 216
  data = 0UL;
#line 217
  datalen = 0;
#line 218
  bp = rx->buffer;
#line 219
  len = (int )rx->numnibbles;
#line 220
  cp = buf;
#line 221
  buffree = (int )(sizeof(buf) - 1UL);
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (len > 0)) {
#line 225
      goto while_break;
    }
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (datalen < 7) {
#line 226
        if (! (len > 0)) {
#line 226
          goto while_break___0;
        }
      } else {
#line 226
        goto while_break___0;
      }
#line 227
      if (len == 1) {
#line 228
        data = (data << 4) | (unsigned long )(((int )*bp >> 4) & 15);
#line 229
        datalen += 4;
#line 230
        len = 0;
      } else {
#line 232
        tmp = bp;
#line 232
        bp ++;
#line 232
        data = (data << 8) | (unsigned long )*tmp;
#line 233
        datalen += 8;
#line 234
        len -= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    if (datalen < 7) {
#line 238
      goto while_continue;
    }
    {
#line 239
    datalen -= 7;
#line 240
    curchr = (unsigned char )(((data >> datalen) & 127UL) << 1);
#line 241
    curchr = (unsigned char )((((int )curchr & 240) >> 4) | (((int )curchr & 15) << 4));
#line 242
    curchr = (unsigned char )((((int )curchr & 204) >> 2) | (((int )curchr & 51) << 2));
#line 243
    curchr = (unsigned char )((((int )curchr & 170) >> 1) | (((int )curchr & 85) << 1));
#line 244
    tstr = translate_alpha(curchr);
    }
#line 245
    if (tstr) {
      {
#line 246
      tmp___0 = strlen((char const   *)tstr);
#line 246
      tlen = (int )tmp___0;
      }
#line 247
      if (buffree >= tlen) {
        {
#line 248
        memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)tstr,
               (size_t )tlen);
#line 249
        cp += tlen;
#line 250
        buffree -= tlen;
        }
      }
    } else
#line 252
    if (buffree > 0) {
#line 253
      tmp___1 = cp;
#line 253
      cp ++;
#line 253
      *tmp___1 = (char )curchr;
#line 254
      buffree --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  *cp = (char )'\000';
#line 258
  verbprintf(0, "%s\n", buf);
  }
#line 259
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static void print_msg_skyper(struct l2_pocsag_rx *rx ) 
{ 
  unsigned long data ;
  int datalen ;
  unsigned char *bp ;
  int len ;
  char buf[256] ;
  char *cp ;
  int buffree ;
  unsigned char curchr ;
  char *tstr ;
  unsigned char *tmp ;
  int tlen ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 265
  data = 0UL;
#line 266
  datalen = 0;
#line 267
  bp = rx->buffer;
#line 268
  len = (int )rx->numnibbles;
#line 269
  cp = buf;
#line 270
  buffree = (int )(sizeof(buf) - 1UL);
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (len > 0)) {
#line 274
      goto while_break;
    }
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (datalen < 7) {
#line 275
        if (! (len > 0)) {
#line 275
          goto while_break___0;
        }
      } else {
#line 275
        goto while_break___0;
      }
#line 276
      if (len == 1) {
#line 277
        data = (data << 4) | (unsigned long )(((int )*bp >> 4) & 15);
#line 278
        datalen += 4;
#line 279
        len = 0;
      } else {
#line 281
        tmp = bp;
#line 281
        bp ++;
#line 281
        data = (data << 8) | (unsigned long )*tmp;
#line 282
        datalen += 8;
#line 283
        len -= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 286
    if (datalen < 7) {
#line 287
      goto while_continue;
    }
    {
#line 288
    datalen -= 7;
#line 289
    curchr = (unsigned char )(((data >> datalen) & 127UL) << 1);
#line 290
    curchr = (unsigned char )((((int )curchr & 240) >> 4) | (((int )curchr & 15) << 4));
#line 291
    curchr = (unsigned char )((((int )curchr & 204) >> 2) | (((int )curchr & 51) << 2));
#line 292
    curchr = (unsigned char )((((int )curchr & 170) >> 1) | (((int )curchr & 85) << 1));
#line 293
    tstr = translate_alpha((unsigned char )((int )curchr - 1));
    }
#line 294
    if (tstr) {
      {
#line 295
      tmp___0 = strlen((char const   *)tstr);
#line 295
      tlen = (int )tmp___0;
      }
#line 296
      if (buffree >= tlen) {
        {
#line 297
        memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)tstr,
               (size_t )tlen);
#line 298
        cp += tlen;
#line 299
        buffree -= tlen;
        }
      }
    } else
#line 301
    if (buffree > 0) {
#line 302
      tmp___1 = cp;
#line 302
      cp ++;
#line 302
      *tmp___1 = (char )((int )curchr - 1);
#line 303
      buffree --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  *cp = (char )'\000';
#line 307
  verbprintf(0, "%s\n", buf);
  }
#line 308
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static void pocsag_printmessage(struct demod_state *s , struct l2_pocsag_rx *rx ,
                                char const   *add_name ) 
{ 


  {
  {
#line 315
  verbprintf(0, "%s%s: Address: %7lu  Function: %1u\n", (s->dem_par)->name, add_name,
             rx->adr, (int )rx->func);
  }
#line 317
  if (! rx->numnibbles) {
#line 318
    return;
  }
#line 319
  if ((int )service_mask & (1 << (int )rx->func)) {
    {
#line 320
    verbprintf(0, "%s%s: Numeric: ", (s->dem_par)->name, add_name);
#line 321
    print_msg_numeric(rx);
    }
  }
#line 323
  if ((int )service_mask & (16 << (int )rx->func)) {
#line 324
    if ((int )rx->func == 3) {
#line 324
      if (rx->adr >= 4000UL) {
#line 324
        if (rx->adr <= 5000UL) {
          {
#line 326
          verbprintf(0, "%s%s: Alpha (SKYPER): ", (s->dem_par)->name, add_name);
#line 327
          print_msg_skyper(rx);
          }
        } else {
          {
#line 329
          verbprintf(0, "%s%s: Alpha: ", (s->dem_par)->name, add_name);
#line 330
          print_msg_alpha(rx);
          }
        }
      } else {
        {
#line 329
        verbprintf(0, "%s%s: Alpha: ", (s->dem_par)->name, add_name);
#line 330
        print_msg_alpha(rx);
        }
      }
    } else {
      {
#line 329
      verbprintf(0, "%s%s: Alpha: ", (s->dem_par)->name, add_name);
#line 330
      print_msg_alpha(rx);
      }
    }
  }
#line 333
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
void pocsag_init(struct demod_state *s ) 
{ 


  {
  {
#line 339
  memset((void *)(& s->l2.pocsag), 0, sizeof(s->l2.pocsag));
  }
#line 340
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
static void do_one_bit(struct demod_state *s , struct l2_pocsag_rx *rx , unsigned long rx_data ,
                       char const   *add_name ) 
{ 
  unsigned char rxword ;
  unsigned char tmp ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char tmp___2 ;
  unsigned long data ;
  unsigned char *bp ;
  unsigned char func ;
  unsigned long adr ;

  {
#line 349
  if (! rx->rx_sync) {
#line 350
    if (rx_data == 2094142936UL) {
#line 350
      goto _L;
    } else
#line 350
    if (rx_data == 2096239670UL) {
      _L: /* CIL Label */ 
#line 351
      rx->rx_sync = (unsigned char)2;
#line 352
      tmp = (unsigned char)0;
#line 352
      rx->rx_word = tmp;
#line 352
      rx->rx_bit = tmp;
#line 353
      rx->func = (char)-1;
#line 354
      return;
    }
#line 356
    return;
  }
#line 359
  rx->rx_bit = (unsigned char )((int )rx->rx_bit + 1);
#line 359
  if ((int )rx->rx_bit < 32) {
#line 360
    return;
  }
  {
#line 364
  rx->rx_bit = (unsigned char)0;
#line 368
  tmp___1 = pocsag_syndrome(rx_data);
  }
#line 368
  if (tmp___1) {
#line 372
    rx->rx_sync = (unsigned char )((int )rx->rx_sync - 1);
#line 373
    if (rx->rx_sync) {
#line 373
      tmp___0 = "";
    } else {
#line 373
      tmp___0 = "sync lost";
    }
    {
#line 373
    verbprintf(7, "%s: Bad codeword: %08lx%s\n", (s->dem_par)->name, rx_data, tmp___0);
    }
#line 376
    if (! ((int )rx->func & -4)) {
      {
#line 377
      verbprintf(0, "%s%s: Warning: message garbled\n", (s->dem_par)->name, add_name);
#line 379
      pocsag_printmessage(s, rx, add_name);
      }
    }
#line 381
    rx->func = (char)-1;
#line 382
    return;
  }
  {
#line 385
  verbprintf(8, "%s%s: Codeword: %08lx\n", (s->dem_par)->name, add_name, rx_data);
#line 386
  tmp___2 = rx->rx_word;
#line 386
  rx->rx_word = (unsigned char )((int )rx->rx_word + 1);
#line 386
  rxword = tmp___2;
  }
#line 387
  if ((int )rxword >= 16) {
#line 392
    rx->rx_word = (unsigned char)0;
#line 393
    if (rx_data == 2094142936UL) {
#line 395
      rx->rx_sync = (unsigned char)10;
    } else
#line 393
    if (rx_data == 2096239670UL) {
#line 395
      rx->rx_sync = (unsigned char)10;
    } else {
#line 397
      rx->rx_sync = (unsigned char )((int )rx->rx_sync - 2);
    }
#line 398
    return;
  }
#line 400
  if (rx_data == 2055848343UL) {
#line 404
    if (! ((int )rx->func & -4)) {
      {
#line 405
      pocsag_printmessage(s, rx, add_name);
      }
    }
#line 406
    rx->func = (char)-1;
#line 407
    return;
  }
#line 409
  if (rx_data & 2147483648UL) {
#line 416
    if ((int )rx->func & -4) {
      {
#line 420
      verbprintf(7, "%s%s: Lonesome data codeword: %08lx\n", (s->dem_par)->name, add_name,
                 rx_data);
      }
#line 422
      return;
    }
#line 424
    if ((unsigned long )rx->numnibbles > sizeof(rx->buffer) * 2UL - 5UL) {
      {
#line 425
      verbprintf(0, "%s%s: Warning: Message too long\n", (s->dem_par)->name, add_name);
#line 427
      pocsag_printmessage(s, rx, add_name);
#line 428
      rx->func = (char)-1;
      }
#line 429
      return;
    }
#line 431
    bp = rx->buffer + (rx->numnibbles >> 1);
#line 432
    data = rx_data >> 11;
#line 433
    if (rx->numnibbles & 1U) {
#line 434
      *(bp + 0) = (unsigned char )((unsigned long )((int )*(bp + 0) & 240) | ((data >> 16) & 15UL));
#line 435
      *(bp + 1) = (unsigned char )(data >> 8);
#line 436
      *(bp + 2) = (unsigned char )data;
    } else {
#line 438
      *(bp + 0) = (unsigned char )(data >> 12);
#line 439
      *(bp + 1) = (unsigned char )(data >> 4);
#line 440
      *(bp + 2) = (unsigned char )(data << 4);
    }
#line 442
    rx->numnibbles += 5U;
#line 443
    return;
  }
#line 448
  if (rx_data >= (unsigned long )((2000000 >> 3) << 13)) {
    {
#line 449
    func = (unsigned char )((rx_data >> 11) & 3UL);
#line 450
    adr = ((rx_data >> 10) & 2097144UL) | (unsigned long )(((int )rxword >> 1) & 7);
#line 453
    verbprintf(0, "%s%s: Nonstandard address codeword: %08lx func %1u adr %08lx\n",
               (s->dem_par)->name, add_name, rx_data, (int )func, adr);
    }
#line 456
    return;
  }
#line 458
  if (! ((int )rx->func & -4)) {
    {
#line 459
    pocsag_printmessage(s, rx, add_name);
    }
  }
#line 460
  rx->func = (char )((rx_data >> 11) & 3UL);
#line 461
  rx->adr = ((rx_data >> 10) & 2097144UL) | (unsigned long )(((int )rxword >> 1) & 7);
#line 462
  rx->numnibbles = 0U;
#line 463
  return;
}
}
#line 467 "/home/wheatley/newnew/temp/multimon-1.0/pocsag.c"
void pocsag_rxbit(struct demod_state *s , int bit ) 
{ 


  {
  {
#line 469
  s->l2.pocsag.rx_data <<= 1;
#line 470
  s->l2.pocsag.rx_data |= (unsigned long )(! bit);
#line 471
  verbprintf(9, " %c ", 49UL - (s->l2.pocsag.rx_data & 1UL));
#line 472
  do_one_bit(s, s->l2.pocsag.rx, ~ s->l2.pocsag.rx_data, "+");
#line 473
  do_one_bit(s, s->l2.pocsag.rx + 1, s->l2.pocsag.rx_data, "-");
  }
#line 474
  return;
}
}
#line 5 "/home/wheatley/newnew/temp/multimon-1.0/costabf.c"
float const   costabf[1024]  = 
#line 5 "/home/wheatley/newnew/temp/multimon-1.0/costabf.c"
  {      (float )1.000000000,      (float )0.999981165,      (float )0.999924719,      (float )0.999830604, 
        (float )0.999698818,      (float )0.999529421,      (float )0.999322355,      (float )0.999077737, 
        (float )0.998795450,      (float )0.998475552,      (float )0.998118103,      (float )0.997723043, 
        (float )0.997290432,      (float )0.996820271,      (float )0.996312618,      (float )0.995767415, 
        (float )0.995184720,      (float )0.994564593,      (float )0.993906975,      (float )0.993211925, 
        (float )0.992479563,      (float )0.991709769,      (float )0.990902662,      (float )0.990058184, 
        (float )0.989176512,      (float )0.988257587,      (float )0.987301409,      (float )0.986308098, 
        (float )0.985277653,      (float )0.984210074,      (float )0.983105481,      (float )0.981963873, 
        (float )0.980785251,      (float )0.979569793,      (float )0.978317380,      (float )0.977028131, 
        (float )0.975702107,      (float )0.974339366,      (float )0.972939968,      (float )0.971503913, 
        (float )0.970031261,      (float )0.968522072,      (float )0.966976464,      (float )0.965394437, 
        (float )0.963776052,      (float )0.962121427,      (float )0.960430503,      (float )0.958703458, 
        (float )0.956940353,      (float )0.955141187,      (float )0.953306019,      (float )0.951435030, 
        (float )0.949528158,      (float )0.947585583,      (float )0.945607305,      (float )0.943593442, 
        (float )0.941544056,      (float )0.939459205,      (float )0.937339008,      (float )0.935183525, 
        (float )0.932992816,      (float )0.930766940,      (float )0.928506076,      (float )0.926210225, 
        (float )0.923879504,      (float )0.921514034,      (float )0.919113874,      (float )0.916679084, 
        (float )0.914209783,      (float )0.911706030,      (float )0.909168005,      (float )0.906595707, 
        (float )0.903989315,      (float )0.901348829,      (float )0.898674488,      (float )0.895966232, 
        (float )0.893224299,      (float )0.890448749,      (float )0.887639642,      (float )0.884797096, 
        (float )0.881921291,      (float )0.879012227,      (float )0.876070082,      (float )0.873094976, 
        (float )0.870086968,      (float )0.867046237,      (float )0.863972843,      (float )0.860866964, 
        (float )0.857728601,      (float )0.854557991,      (float )0.851355195,      (float )0.848120332, 
        (float )0.844853580,      (float )0.841554999,      (float )0.838224709,      (float )0.834862888, 
        (float )0.831469595,      (float )0.828045070,      (float )0.824589312,      (float )0.821102500, 
        (float )0.817584813,      (float )0.814036310,      (float )0.810457170,      (float )0.806847572, 
        (float )0.803207517,      (float )0.799537241,      (float )0.795836926,      (float )0.792106569, 
        (float )0.788346410,      (float )0.784556568,      (float )0.780737221,      (float )0.776888490, 
        (float )0.773010433,      (float )0.769103348,      (float )0.765167236,      (float )0.761202395, 
        (float )0.757208824,      (float )0.753186822,      (float )0.749136388,      (float )0.745057762, 
        (float )0.740951121,      (float )0.736816585,      (float )0.732654274,      (float )0.728464365, 
        (float )0.724247098,      (float )0.720002532,      (float )0.715730846,      (float )0.711432219, 
        (float )0.707106769,      (float )0.702754736,      (float )0.698376238,      (float )0.693971455, 
        (float )0.689540565,      (float )0.685083687,      (float )0.680601001,      (float )0.676092684, 
        (float )0.671558976,      (float )0.666999936,      (float )0.662415802,      (float )0.657806695, 
        (float )0.653172851,      (float )0.648514390,      (float )0.643831551,      (float )0.639124453, 
        (float )0.634393275,      (float )0.629638255,      (float )0.624859512,      (float )0.620057225, 
        (float )0.615231574,      (float )0.610382795,      (float )0.605511069,      (float )0.600616455, 
        (float )0.595699310,      (float )0.590759695,      (float )0.585797846,      (float )0.580813944, 
        (float )0.575808167,      (float )0.570780754,      (float )0.565731823,      (float )0.560661554, 
        (float )0.555570245,      (float )0.550457954,      (float )0.545324981,      (float )0.540171444, 
        (float )0.534997642,      (float )0.529803634,      (float )0.524589658,      (float )0.519356012, 
        (float )0.514102757,      (float )0.508830130,      (float )0.503538370,      (float )0.498227656, 
        (float )0.492898196,      (float )0.487550169,      (float )0.482183784,      (float )0.476799220, 
        (float )0.471396744,      (float )0.465976506,      (float )0.460538715,      (float )0.455083579, 
        (float )0.449611336,      (float )0.444122136,      (float )0.438616246,      (float )0.433093816, 
        (float )0.427555084,      (float )0.422000259,      (float )0.416429549,      (float )0.410843164, 
        (float )0.405241311,      (float )0.399624199,      (float )0.393992037,      (float )0.388345033, 
        (float )0.382683426,      (float )0.377007425,      (float )0.371317208,      (float )0.365612984, 
        (float )0.359895051,      (float )0.354163527,      (float )0.348418683,      (float )0.342660725, 
        (float )0.336889863,      (float )0.331106305,      (float )0.325310290,      (float )0.319502026, 
        (float )0.313681751,      (float )0.307849646,      (float )0.302005947,      (float )0.296150893, 
        (float )0.290284663,      (float )0.284407526,      (float )0.278519690,      (float )0.272621363, 
        (float )0.266712755,      (float )0.260794103,      (float )0.254865646,      (float )0.248927608, 
        (float )0.242980182,      (float )0.237023607,      (float )0.231058106,      (float )0.225083917, 
        (float )0.219101235,      (float )0.213110313,      (float )0.207111374,      (float )0.201104641, 
        (float )0.195090324,      (float )0.189068660,      (float )0.183039889,      (float )0.177004218, 
        (float )0.170961887,      (float )0.164913118,      (float )0.158858150,      (float )0.152797192, 
        (float )0.146730468,      (float )0.140658244,      (float )0.134580702,      (float )0.128498107, 
        (float )0.122410677,      (float )0.116318628,      (float )0.110222206,      (float )0.104121633, 
        (float )0.098017141,      (float )0.091908954,      (float )0.085797310,      (float )0.079682440, 
        (float )0.073564567,      (float )0.067443922,      (float )0.061320737,      (float )0.055195246, 
        (float )0.049067676,      (float )0.042938258,      (float )0.036807224,      (float )0.030674804, 
        (float )0.024541229,      (float )0.018406730,      (float )0.012271538,      (float )0.006135885, 
        (float )0.000000000,      (float )(- 0.006135885),      (float )(- 0.012271538),      (float )(- 0.018406730), 
        (float )(- 0.024541229),      (float )(- 0.030674804),      (float )(- 0.036807224),      (float )(- 0.042938258), 
        (float )(- 0.049067676),      (float )(- 0.055195246),      (float )(- 0.061320737),      (float )(- 0.067443922), 
        (float )(- 0.073564567),      (float )(- 0.079682440),      (float )(- 0.085797310),      (float )(- 0.091908954), 
        (float )(- 0.098017141),      (float )(- 0.104121633),      (float )(- 0.110222206),      (float )(- 0.116318628), 
        (float )(- 0.122410677),      (float )(- 0.128498107),      (float )(- 0.134580702),      (float )(- 0.140658244), 
        (float )(- 0.146730468),      (float )(- 0.152797192),      (float )(- 0.158858150),      (float )(- 0.164913118), 
        (float )(- 0.170961887),      (float )(- 0.177004218),      (float )(- 0.183039889),      (float )(- 0.189068660), 
        (float )(- 0.195090324),      (float )(- 0.201104641),      (float )(- 0.207111374),      (float )(- 0.213110313), 
        (float )(- 0.219101235),      (float )(- 0.225083917),      (float )(- 0.231058106),      (float )(- 0.237023607), 
        (float )(- 0.242980182),      (float )(- 0.248927608),      (float )(- 0.254865646),      (float )(- 0.260794103), 
        (float )(- 0.266712755),      (float )(- 0.272621363),      (float )(- 0.278519690),      (float )(- 0.284407526), 
        (float )(- 0.290284663),      (float )(- 0.296150893),      (float )(- 0.302005947),      (float )(- 0.307849646), 
        (float )(- 0.313681751),      (float )(- 0.319502026),      (float )(- 0.325310290),      (float )(- 0.331106305), 
        (float )(- 0.336889863),      (float )(- 0.342660725),      (float )(- 0.348418683),      (float )(- 0.354163527), 
        (float )(- 0.359895051),      (float )(- 0.365612984),      (float )(- 0.371317208),      (float )(- 0.377007425), 
        (float )(- 0.382683426),      (float )(- 0.388345033),      (float )(- 0.393992037),      (float )(- 0.399624199), 
        (float )(- 0.405241311),      (float )(- 0.410843164),      (float )(- 0.416429549),      (float )(- 0.422000259), 
        (float )(- 0.427555084),      (float )(- 0.433093816),      (float )(- 0.438616246),      (float )(- 0.444122136), 
        (float )(- 0.449611336),      (float )(- 0.455083579),      (float )(- 0.460538715),      (float )(- 0.465976506), 
        (float )(- 0.471396744),      (float )(- 0.476799220),      (float )(- 0.482183784),      (float )(- 0.487550169), 
        (float )(- 0.492898196),      (float )(- 0.498227656),      (float )(- 0.503538370),      (float )(- 0.508830130), 
        (float )(- 0.514102757),      (float )(- 0.519356012),      (float )(- 0.524589658),      (float )(- 0.529803634), 
        (float )(- 0.534997642),      (float )(- 0.540171444),      (float )(- 0.545324981),      (float )(- 0.550457954), 
        (float )(- 0.555570245),      (float )(- 0.560661554),      (float )(- 0.565731823),      (float )(- 0.570780754), 
        (float )(- 0.575808167),      (float )(- 0.580813944),      (float )(- 0.585797846),      (float )(- 0.590759695), 
        (float )(- 0.595699310),      (float )(- 0.600616455),      (float )(- 0.605511069),      (float )(- 0.610382795), 
        (float )(- 0.615231574),      (float )(- 0.620057225),      (float )(- 0.624859512),      (float )(- 0.629638255), 
        (float )(- 0.634393275),      (float )(- 0.639124453),      (float )(- 0.643831551),      (float )(- 0.648514390), 
        (float )(- 0.653172851),      (float )(- 0.657806695),      (float )(- 0.662415802),      (float )(- 0.666999936), 
        (float )(- 0.671558976),      (float )(- 0.676092684),      (float )(- 0.680601001),      (float )(- 0.685083687), 
        (float )(- 0.689540565),      (float )(- 0.693971455),      (float )(- 0.698376238),      (float )(- 0.702754736), 
        (float )(- 0.707106769),      (float )(- 0.711432219),      (float )(- 0.715730846),      (float )(- 0.720002532), 
        (float )(- 0.724247098),      (float )(- 0.728464365),      (float )(- 0.732654274),      (float )(- 0.736816585), 
        (float )(- 0.740951121),      (float )(- 0.745057762),      (float )(- 0.749136388),      (float )(- 0.753186822), 
        (float )(- 0.757208824),      (float )(- 0.761202395),      (float )(- 0.765167236),      (float )(- 0.769103348), 
        (float )(- 0.773010433),      (float )(- 0.776888490),      (float )(- 0.780737221),      (float )(- 0.784556568), 
        (float )(- 0.788346410),      (float )(- 0.792106569),      (float )(- 0.795836926),      (float )(- 0.799537241), 
        (float )(- 0.803207517),      (float )(- 0.806847572),      (float )(- 0.810457170),      (float )(- 0.814036310), 
        (float )(- 0.817584813),      (float )(- 0.821102500),      (float )(- 0.824589312),      (float )(- 0.828045070), 
        (float )(- 0.831469595),      (float )(- 0.834862888),      (float )(- 0.838224709),      (float )(- 0.841554999), 
        (float )(- 0.844853580),      (float )(- 0.848120332),      (float )(- 0.851355195),      (float )(- 0.854557991), 
        (float )(- 0.857728601),      (float )(- 0.860866964),      (float )(- 0.863972843),      (float )(- 0.867046237), 
        (float )(- 0.870086968),      (float )(- 0.873094976),      (float )(- 0.876070082),      (float )(- 0.879012227), 
        (float )(- 0.881921291),      (float )(- 0.884797096),      (float )(- 0.887639642),      (float )(- 0.890448749), 
        (float )(- 0.893224299),      (float )(- 0.895966232),      (float )(- 0.898674488),      (float )(- 0.901348829), 
        (float )(- 0.903989315),      (float )(- 0.906595707),      (float )(- 0.909168005),      (float )(- 0.911706030), 
        (float )(- 0.914209783),      (float )(- 0.916679084),      (float )(- 0.919113874),      (float )(- 0.921514034), 
        (float )(- 0.923879504),      (float )(- 0.926210225),      (float )(- 0.928506076),      (float )(- 0.930766940), 
        (float )(- 0.932992816),      (float )(- 0.935183525),      (float )(- 0.937339008),      (float )(- 0.939459205), 
        (float )(- 0.941544056),      (float )(- 0.943593442),      (float )(- 0.945607305),      (float )(- 0.947585583), 
        (float )(- 0.949528158),      (float )(- 0.951435030),      (float )(- 0.953306019),      (float )(- 0.955141187), 
        (float )(- 0.956940353),      (float )(- 0.958703458),      (float )(- 0.960430503),      (float )(- 0.962121427), 
        (float )(- 0.963776052),      (float )(- 0.965394437),      (float )(- 0.966976464),      (float )(- 0.968522072), 
        (float )(- 0.970031261),      (float )(- 0.971503913),      (float )(- 0.972939968),      (float )(- 0.974339366), 
        (float )(- 0.975702107),      (float )(- 0.977028131),      (float )(- 0.978317380),      (float )(- 0.979569793), 
        (float )(- 0.980785251),      (float )(- 0.981963873),      (float )(- 0.983105481),      (float )(- 0.984210074), 
        (float )(- 0.985277653),      (float )(- 0.986308098),      (float )(- 0.987301409),      (float )(- 0.988257587), 
        (float )(- 0.989176512),      (float )(- 0.990058184),      (float )(- 0.990902662),      (float )(- 0.991709769), 
        (float )(- 0.992479563),      (float )(- 0.993211925),      (float )(- 0.993906975),      (float )(- 0.994564593), 
        (float )(- 0.995184720),      (float )(- 0.995767415),      (float )(- 0.996312618),      (float )(- 0.996820271), 
        (float )(- 0.997290432),      (float )(- 0.997723043),      (float )(- 0.998118103),      (float )(- 0.998475552), 
        (float )(- 0.998795450),      (float )(- 0.999077737),      (float )(- 0.999322355),      (float )(- 0.999529421), 
        (float )(- 0.999698818),      (float )(- 0.999830604),      (float )(- 0.999924719),      (float )(- 0.999981165), 
        (float )(- 1.000000000),      (float )(- 0.999981165),      (float )(- 0.999924719),      (float )(- 0.999830604), 
        (float )(- 0.999698818),      (float )(- 0.999529421),      (float )(- 0.999322355),      (float )(- 0.999077737), 
        (float )(- 0.998795450),      (float )(- 0.998475552),      (float )(- 0.998118103),      (float )(- 0.997723043), 
        (float )(- 0.997290432),      (float )(- 0.996820271),      (float )(- 0.996312618),      (float )(- 0.995767415), 
        (float )(- 0.995184720),      (float )(- 0.994564593),      (float )(- 0.993906975),      (float )(- 0.993211925), 
        (float )(- 0.992479563),      (float )(- 0.991709769),      (float )(- 0.990902662),      (float )(- 0.990058184), 
        (float )(- 0.989176512),      (float )(- 0.988257587),      (float )(- 0.987301409),      (float )(- 0.986308098), 
        (float )(- 0.985277653),      (float )(- 0.984210074),      (float )(- 0.983105481),      (float )(- 0.981963873), 
        (float )(- 0.980785251),      (float )(- 0.979569793),      (float )(- 0.978317380),      (float )(- 0.977028131), 
        (float )(- 0.975702107),      (float )(- 0.974339366),      (float )(- 0.972939968),      (float )(- 0.971503913), 
        (float )(- 0.970031261),      (float )(- 0.968522072),      (float )(- 0.966976464),      (float )(- 0.965394437), 
        (float )(- 0.963776052),      (float )(- 0.962121427),      (float )(- 0.960430503),      (float )(- 0.958703458), 
        (float )(- 0.956940353),      (float )(- 0.955141187),      (float )(- 0.953306019),      (float )(- 0.951435030), 
        (float )(- 0.949528158),      (float )(- 0.947585583),      (float )(- 0.945607305),      (float )(- 0.943593442), 
        (float )(- 0.941544056),      (float )(- 0.939459205),      (float )(- 0.937339008),      (float )(- 0.935183525), 
        (float )(- 0.932992816),      (float )(- 0.930766940),      (float )(- 0.928506076),      (float )(- 0.926210225), 
        (float )(- 0.923879504),      (float )(- 0.921514034),      (float )(- 0.919113874),      (float )(- 0.916679084), 
        (float )(- 0.914209783),      (float )(- 0.911706030),      (float )(- 0.909168005),      (float )(- 0.906595707), 
        (float )(- 0.903989315),      (float )(- 0.901348829),      (float )(- 0.898674488),      (float )(- 0.895966232), 
        (float )(- 0.893224299),      (float )(- 0.890448749),      (float )(- 0.887639642),      (float )(- 0.884797096), 
        (float )(- 0.881921291),      (float )(- 0.879012227),      (float )(- 0.876070082),      (float )(- 0.873094976), 
        (float )(- 0.870086968),      (float )(- 0.867046237),      (float )(- 0.863972843),      (float )(- 0.860866964), 
        (float )(- 0.857728601),      (float )(- 0.854557991),      (float )(- 0.851355195),      (float )(- 0.848120332), 
        (float )(- 0.844853580),      (float )(- 0.841554999),      (float )(- 0.838224709),      (float )(- 0.834862888), 
        (float )(- 0.831469595),      (float )(- 0.828045070),      (float )(- 0.824589312),      (float )(- 0.821102500), 
        (float )(- 0.817584813),      (float )(- 0.814036310),      (float )(- 0.810457170),      (float )(- 0.806847572), 
        (float )(- 0.803207517),      (float )(- 0.799537241),      (float )(- 0.795836926),      (float )(- 0.792106569), 
        (float )(- 0.788346410),      (float )(- 0.784556568),      (float )(- 0.780737221),      (float )(- 0.776888490), 
        (float )(- 0.773010433),      (float )(- 0.769103348),      (float )(- 0.765167236),      (float )(- 0.761202395), 
        (float )(- 0.757208824),      (float )(- 0.753186822),      (float )(- 0.749136388),      (float )(- 0.745057762), 
        (float )(- 0.740951121),      (float )(- 0.736816585),      (float )(- 0.732654274),      (float )(- 0.728464365), 
        (float )(- 0.724247098),      (float )(- 0.720002532),      (float )(- 0.715730846),      (float )(- 0.711432219), 
        (float )(- 0.707106769),      (float )(- 0.702754736),      (float )(- 0.698376238),      (float )(- 0.693971455), 
        (float )(- 0.689540565),      (float )(- 0.685083687),      (float )(- 0.680601001),      (float )(- 0.676092684), 
        (float )(- 0.671558976),      (float )(- 0.666999936),      (float )(- 0.662415802),      (float )(- 0.657806695), 
        (float )(- 0.653172851),      (float )(- 0.648514390),      (float )(- 0.643831551),      (float )(- 0.639124453), 
        (float )(- 0.634393275),      (float )(- 0.629638255),      (float )(- 0.624859512),      (float )(- 0.620057225), 
        (float )(- 0.615231574),      (float )(- 0.610382795),      (float )(- 0.605511069),      (float )(- 0.600616455), 
        (float )(- 0.595699310),      (float )(- 0.590759695),      (float )(- 0.585797846),      (float )(- 0.580813944), 
        (float )(- 0.575808167),      (float )(- 0.570780754),      (float )(- 0.565731823),      (float )(- 0.560661554), 
        (float )(- 0.555570245),      (float )(- 0.550457954),      (float )(- 0.545324981),      (float )(- 0.540171444), 
        (float )(- 0.534997642),      (float )(- 0.529803634),      (float )(- 0.524589658),      (float )(- 0.519356012), 
        (float )(- 0.514102757),      (float )(- 0.508830130),      (float )(- 0.503538370),      (float )(- 0.498227656), 
        (float )(- 0.492898196),      (float )(- 0.487550169),      (float )(- 0.482183784),      (float )(- 0.476799220), 
        (float )(- 0.471396744),      (float )(- 0.465976506),      (float )(- 0.460538715),      (float )(- 0.455083579), 
        (float )(- 0.449611336),      (float )(- 0.444122136),      (float )(- 0.438616246),      (float )(- 0.433093816), 
        (float )(- 0.427555084),      (float )(- 0.422000259),      (float )(- 0.416429549),      (float )(- 0.410843164), 
        (float )(- 0.405241311),      (float )(- 0.399624199),      (float )(- 0.393992037),      (float )(- 0.388345033), 
        (float )(- 0.382683426),      (float )(- 0.377007425),      (float )(- 0.371317208),      (float )(- 0.365612984), 
        (float )(- 0.359895051),      (float )(- 0.354163527),      (float )(- 0.348418683),      (float )(- 0.342660725), 
        (float )(- 0.336889863),      (float )(- 0.331106305),      (float )(- 0.325310290),      (float )(- 0.319502026), 
        (float )(- 0.313681751),      (float )(- 0.307849646),      (float )(- 0.302005947),      (float )(- 0.296150893), 
        (float )(- 0.290284663),      (float )(- 0.284407526),      (float )(- 0.278519690),      (float )(- 0.272621363), 
        (float )(- 0.266712755),      (float )(- 0.260794103),      (float )(- 0.254865646),      (float )(- 0.248927608), 
        (float )(- 0.242980182),      (float )(- 0.237023607),      (float )(- 0.231058106),      (float )(- 0.225083917), 
        (float )(- 0.219101235),      (float )(- 0.213110313),      (float )(- 0.207111374),      (float )(- 0.201104641), 
        (float )(- 0.195090324),      (float )(- 0.189068660),      (float )(- 0.183039889),      (float )(- 0.177004218), 
        (float )(- 0.170961887),      (float )(- 0.164913118),      (float )(- 0.158858150),      (float )(- 0.152797192), 
        (float )(- 0.146730468),      (float )(- 0.140658244),      (float )(- 0.134580702),      (float )(- 0.128498107), 
        (float )(- 0.122410677),      (float )(- 0.116318628),      (float )(- 0.110222206),      (float )(- 0.104121633), 
        (float )(- 0.098017141),      (float )(- 0.091908954),      (float )(- 0.085797310),      (float )(- 0.079682440), 
        (float )(- 0.073564567),      (float )(- 0.067443922),      (float )(- 0.061320737),      (float )(- 0.055195246), 
        (float )(- 0.049067676),      (float )(- 0.042938258),      (float )(- 0.036807224),      (float )(- 0.030674804), 
        (float )(- 0.024541229),      (float )(- 0.018406730),      (float )(- 0.012271538),      (float )(- 0.006135885), 
        (float )(- 0.000000000),      (float )0.006135885,      (float )0.012271538,      (float )0.018406730, 
        (float )0.024541229,      (float )0.030674804,      (float )0.036807224,      (float )0.042938258, 
        (float )0.049067676,      (float )0.055195246,      (float )0.061320737,      (float )0.067443922, 
        (float )0.073564567,      (float )0.079682440,      (float )0.085797310,      (float )0.091908954, 
        (float )0.098017141,      (float )0.104121633,      (float )0.110222206,      (float )0.116318628, 
        (float )0.122410677,      (float )0.128498107,      (float )0.134580702,      (float )0.140658244, 
        (float )0.146730468,      (float )0.152797192,      (float )0.158858150,      (float )0.164913118, 
        (float )0.170961887,      (float )0.177004218,      (float )0.183039889,      (float )0.189068660, 
        (float )0.195090324,      (float )0.201104641,      (float )0.207111374,      (float )0.213110313, 
        (float )0.219101235,      (float )0.225083917,      (float )0.231058106,      (float )0.237023607, 
        (float )0.242980182,      (float )0.248927608,      (float )0.254865646,      (float )0.260794103, 
        (float )0.266712755,      (float )0.272621363,      (float )0.278519690,      (float )0.284407526, 
        (float )0.290284663,      (float )0.296150893,      (float )0.302005947,      (float )0.307849646, 
        (float )0.313681751,      (float )0.319502026,      (float )0.325310290,      (float )0.331106305, 
        (float )0.336889863,      (float )0.342660725,      (float )0.348418683,      (float )0.354163527, 
        (float )0.359895051,      (float )0.365612984,      (float )0.371317208,      (float )0.377007425, 
        (float )0.382683426,      (float )0.388345033,      (float )0.393992037,      (float )0.399624199, 
        (float )0.405241311,      (float )0.410843164,      (float )0.416429549,      (float )0.422000259, 
        (float )0.427555084,      (float )0.433093816,      (float )0.438616246,      (float )0.444122136, 
        (float )0.449611336,      (float )0.455083579,      (float )0.460538715,      (float )0.465976506, 
        (float )0.471396744,      (float )0.476799220,      (float )0.482183784,      (float )0.487550169, 
        (float )0.492898196,      (float )0.498227656,      (float )0.503538370,      (float )0.508830130, 
        (float )0.514102757,      (float )0.519356012,      (float )0.524589658,      (float )0.529803634, 
        (float )0.534997642,      (float )0.540171444,      (float )0.545324981,      (float )0.550457954, 
        (float )0.555570245,      (float )0.560661554,      (float )0.565731823,      (float )0.570780754, 
        (float )0.575808167,      (float )0.580813944,      (float )0.585797846,      (float )0.590759695, 
        (float )0.595699310,      (float )0.600616455,      (float )0.605511069,      (float )0.610382795, 
        (float )0.615231574,      (float )0.620057225,      (float )0.624859512,      (float )0.629638255, 
        (float )0.634393275,      (float )0.639124453,      (float )0.643831551,      (float )0.648514390, 
        (float )0.653172851,      (float )0.657806695,      (float )0.662415802,      (float )0.666999936, 
        (float )0.671558976,      (float )0.676092684,      (float )0.680601001,      (float )0.685083687, 
        (float )0.689540565,      (float )0.693971455,      (float )0.698376238,      (float )0.702754736, 
        (float )0.707106769,      (float )0.711432219,      (float )0.715730846,      (float )0.720002532, 
        (float )0.724247098,      (float )0.728464365,      (float )0.732654274,      (float )0.736816585, 
        (float )0.740951121,      (float )0.745057762,      (float )0.749136388,      (float )0.753186822, 
        (float )0.757208824,      (float )0.761202395,      (float )0.765167236,      (float )0.769103348, 
        (float )0.773010433,      (float )0.776888490,      (float )0.780737221,      (float )0.784556568, 
        (float )0.788346410,      (float )0.792106569,      (float )0.795836926,      (float )0.799537241, 
        (float )0.803207517,      (float )0.806847572,      (float )0.810457170,      (float )0.814036310, 
        (float )0.817584813,      (float )0.821102500,      (float )0.824589312,      (float )0.828045070, 
        (float )0.831469595,      (float )0.834862888,      (float )0.838224709,      (float )0.841554999, 
        (float )0.844853580,      (float )0.848120332,      (float )0.851355195,      (float )0.854557991, 
        (float )0.857728601,      (float )0.860866964,      (float )0.863972843,      (float )0.867046237, 
        (float )0.870086968,      (float )0.873094976,      (float )0.876070082,      (float )0.879012227, 
        (float )0.881921291,      (float )0.884797096,      (float )0.887639642,      (float )0.890448749, 
        (float )0.893224299,      (float )0.895966232,      (float )0.898674488,      (float )0.901348829, 
        (float )0.903989315,      (float )0.906595707,      (float )0.909168005,      (float )0.911706030, 
        (float )0.914209783,      (float )0.916679084,      (float )0.919113874,      (float )0.921514034, 
        (float )0.923879504,      (float )0.926210225,      (float )0.928506076,      (float )0.930766940, 
        (float )0.932992816,      (float )0.935183525,      (float )0.937339008,      (float )0.939459205, 
        (float )0.941544056,      (float )0.943593442,      (float )0.945607305,      (float )0.947585583, 
        (float )0.949528158,      (float )0.951435030,      (float )0.953306019,      (float )0.955141187, 
        (float )0.956940353,      (float )0.958703458,      (float )0.960430503,      (float )0.962121427, 
        (float )0.963776052,      (float )0.965394437,      (float )0.966976464,      (float )0.968522072, 
        (float )0.970031261,      (float )0.971503913,      (float )0.972939968,      (float )0.974339366, 
        (float )0.975702107,      (float )0.977028131,      (float )0.978317380,      (float )0.979569793, 
        (float )0.980785251,      (float )0.981963873,      (float )0.983105481,      (float )0.984210074, 
        (float )0.985277653,      (float )0.986308098,      (float )0.987301409,      (float )0.988257587, 
        (float )0.989176512,      (float )0.990058184,      (float )0.990902662,      (float )0.991709769, 
        (float )0.992479563,      (float )0.993211925,      (float )0.993906975,      (float )0.994564593, 
        (float )0.995184720,      (float )0.995767415,      (float )0.996312618,      (float )0.996820271, 
        (float )0.997290432,      (float )0.997723043,      (float )0.998118103,      (float )0.998475552, 
        (float )0.998795450,      (float )0.999077737,      (float )0.999322355,      (float )0.999529421, 
        (float )0.999698818,      (float )0.999830604,      (float )0.999924719,      (float )0.999981165};
#line 49 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static float corr_mark_i___1[18]  ;
#line 50 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static float corr_mark_q___1[18]  ;
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static float corr_space_i___1[18]  ;
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static float corr_space_q___1[18]  ;
#line 56 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static void afsk24_init(struct demod_state *s ) 
{ 
  float f ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 61
  hdlc_init(s);
#line 62
  memset((void *)(& s->l1.afsk24), 0, sizeof(s->l1.afsk24));
#line 63
  f = (float )0;
#line 63
  i = 0;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 18)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = cos((double )f);
#line 64
    corr_mark_i___1[i] = (float )tmp;
#line 65
    tmp___0 = sin((double )f);
#line 65
    corr_mark_q___1[i] = (float )tmp___0;
#line 66
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )3970) / (double )22050);
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  f = (float )0;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i < 18)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    tmp___1 = cos((double )f);
#line 69
    corr_space_i___1[i] = (float )tmp___1;
#line 70
    tmp___2 = sin((double )f);
#line 70
    corr_space_q___1[i] = (float )tmp___2;
#line 71
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )2165) / (double )22050);
#line 68
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 73
    if (! (i < 18)) {
#line 73
      goto while_break___1;
    }
    {
#line 74
    tmp___3 = cos((((double )2 * 3.14159265358979323846) * (double )i) / (double )((float )17));
#line 74
    f = (float )(0.54 - 0.46 * tmp___3);
#line 75
    corr_mark_i___1[i] *= f;
#line 76
    corr_mark_q___1[i] *= f;
#line 77
    corr_space_i___1[i] *= f;
#line 78
    corr_space_q___1[i] *= f;
#line 73
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
static void afsk24_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float f ;
  unsigned char curbit ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (length > 0)) {
#line 89
      goto while_break;
    }
    {
#line 90
    tmp = mac((float const   *)buffer, (float const   *)(corr_mark_i___1), 18U);
#line 90
    tmp___0 = fsqr(tmp);
#line 90
    tmp___1 = mac((float const   *)buffer, (float const   *)(corr_mark_q___1), 18U);
#line 90
    tmp___2 = fsqr(tmp___1);
#line 90
    tmp___3 = mac((float const   *)buffer, (float const   *)(corr_space_i___1), 18U);
#line 90
    tmp___4 = fsqr(tmp___3);
#line 90
    tmp___5 = mac((float const   *)buffer, (float const   *)(corr_space_q___1), 18U);
#line 90
    tmp___6 = fsqr(tmp___5);
#line 90
    f = ((tmp___0 + tmp___2) - tmp___4) - tmp___6;
#line 94
    s->l1.afsk24.dcd_shreg <<= 1;
#line 95
    s->l1.afsk24.dcd_shreg |= (unsigned int )(f > (float )0);
#line 96
    verbprintf(10, "%c", 48U + (s->l1.afsk24.dcd_shreg & 1U));
    }
#line 100
    if ((s->l1.afsk24.dcd_shreg ^ (s->l1.afsk24.dcd_shreg >> 1)) & 1U) {
#line 101
      if (s->l1.afsk24.sphase < 29202U) {
#line 102
        s->l1.afsk24.sphase += 891U;
      } else {
#line 104
        s->l1.afsk24.sphase -= 891U;
      }
    }
#line 106
    s->l1.afsk24.sphase += 7133U;
#line 107
    if (s->l1.afsk24.sphase >= 65536U) {
      {
#line 108
      s->l1.afsk24.sphase &= 65535U;
#line 109
      s->l1.afsk24.lasts <<= 1;
#line 110
      s->l1.afsk24.lasts |= s->l1.afsk24.dcd_shreg & 1U;
#line 111
      curbit = (unsigned char )(((s->l1.afsk24.lasts ^ (s->l1.afsk24.lasts >> 1)) ^ 1U) & 1U);
#line 113
      verbprintf(9, " %c ", 48 + (int )curbit);
#line 114
      hdlc_rxbit(s, (int )curbit);
      }
    }
#line 89
    length --;
#line 89
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24.c"
struct demod_param  const  demod_afsk2400  =    {"AFSK2400", 22050U, 18U, & afsk24_init, & afsk24_demod};
#line 34 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
static unsigned short const   crc_ccitt_table___0[256]  = 
#line 34 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
  {      (unsigned short const   )0,      (unsigned short const   )4489,      (unsigned short const   )8978,      (unsigned short const   )12955, 
        (unsigned short const   )17956,      (unsigned short const   )22445,      (unsigned short const   )25910,      (unsigned short const   )29887, 
        (unsigned short const   )35912,      (unsigned short const   )40385,      (unsigned short const   )44890,      (unsigned short const   )48851, 
        (unsigned short const   )51820,      (unsigned short const   )56293,      (unsigned short const   )59774,      (unsigned short const   )63735, 
        (unsigned short const   )4225,      (unsigned short const   )264,      (unsigned short const   )13203,      (unsigned short const   )8730, 
        (unsigned short const   )22181,      (unsigned short const   )18220,      (unsigned short const   )30135,      (unsigned short const   )25662, 
        (unsigned short const   )40137,      (unsigned short const   )36160,      (unsigned short const   )49115,      (unsigned short const   )44626, 
        (unsigned short const   )56045,      (unsigned short const   )52068,      (unsigned short const   )63999,      (unsigned short const   )59510, 
        (unsigned short const   )8450,      (unsigned short const   )12427,      (unsigned short const   )528,      (unsigned short const   )5017, 
        (unsigned short const   )26406,      (unsigned short const   )30383,      (unsigned short const   )17460,      (unsigned short const   )21949, 
        (unsigned short const   )44362,      (unsigned short const   )48323,      (unsigned short const   )36440,      (unsigned short const   )40913, 
        (unsigned short const   )60270,      (unsigned short const   )64231,      (unsigned short const   )51324,      (unsigned short const   )55797, 
        (unsigned short const   )12675,      (unsigned short const   )8202,      (unsigned short const   )4753,      (unsigned short const   )792, 
        (unsigned short const   )30631,      (unsigned short const   )26158,      (unsigned short const   )21685,      (unsigned short const   )17724, 
        (unsigned short const   )48587,      (unsigned short const   )44098,      (unsigned short const   )40665,      (unsigned short const   )36688, 
        (unsigned short const   )64495,      (unsigned short const   )60006,      (unsigned short const   )55549,      (unsigned short const   )51572, 
        (unsigned short const   )16900,      (unsigned short const   )21389,      (unsigned short const   )24854,      (unsigned short const   )28831, 
        (unsigned short const   )1056,      (unsigned short const   )5545,      (unsigned short const   )10034,      (unsigned short const   )14011, 
        (unsigned short const   )52812,      (unsigned short const   )57285,      (unsigned short const   )60766,      (unsigned short const   )64727, 
        (unsigned short const   )34920,      (unsigned short const   )39393,      (unsigned short const   )43898,      (unsigned short const   )47859, 
        (unsigned short const   )21125,      (unsigned short const   )17164,      (unsigned short const   )29079,      (unsigned short const   )24606, 
        (unsigned short const   )5281,      (unsigned short const   )1320,      (unsigned short const   )14259,      (unsigned short const   )9786, 
        (unsigned short const   )57037,      (unsigned short const   )53060,      (unsigned short const   )64991,      (unsigned short const   )60502, 
        (unsigned short const   )39145,      (unsigned short const   )35168,      (unsigned short const   )48123,      (unsigned short const   )43634, 
        (unsigned short const   )25350,      (unsigned short const   )29327,      (unsigned short const   )16404,      (unsigned short const   )20893, 
        (unsigned short const   )9506,      (unsigned short const   )13483,      (unsigned short const   )1584,      (unsigned short const   )6073, 
        (unsigned short const   )61262,      (unsigned short const   )65223,      (unsigned short const   )52316,      (unsigned short const   )56789, 
        (unsigned short const   )43370,      (unsigned short const   )47331,      (unsigned short const   )35448,      (unsigned short const   )39921, 
        (unsigned short const   )29575,      (unsigned short const   )25102,      (unsigned short const   )20629,      (unsigned short const   )16668, 
        (unsigned short const   )13731,      (unsigned short const   )9258,      (unsigned short const   )5809,      (unsigned short const   )1848, 
        (unsigned short const   )65487,      (unsigned short const   )60998,      (unsigned short const   )56541,      (unsigned short const   )52564, 
        (unsigned short const   )47595,      (unsigned short const   )43106,      (unsigned short const   )39673,      (unsigned short const   )35696, 
        (unsigned short const   )33800,      (unsigned short const   )38273,      (unsigned short const   )42778,      (unsigned short const   )46739, 
        (unsigned short const   )49708,      (unsigned short const   )54181,      (unsigned short const   )57662,      (unsigned short const   )61623, 
        (unsigned short const   )2112,      (unsigned short const   )6601,      (unsigned short const   )11090,      (unsigned short const   )15067, 
        (unsigned short const   )20068,      (unsigned short const   )24557,      (unsigned short const   )28022,      (unsigned short const   )31999, 
        (unsigned short const   )38025,      (unsigned short const   )34048,      (unsigned short const   )47003,      (unsigned short const   )42514, 
        (unsigned short const   )53933,      (unsigned short const   )49956,      (unsigned short const   )61887,      (unsigned short const   )57398, 
        (unsigned short const   )6337,      (unsigned short const   )2376,      (unsigned short const   )15315,      (unsigned short const   )10842, 
        (unsigned short const   )24293,      (unsigned short const   )20332,      (unsigned short const   )32247,      (unsigned short const   )27774, 
        (unsigned short const   )42250,      (unsigned short const   )46211,      (unsigned short const   )34328,      (unsigned short const   )38801, 
        (unsigned short const   )58158,      (unsigned short const   )62119,      (unsigned short const   )49212,      (unsigned short const   )53685, 
        (unsigned short const   )10562,      (unsigned short const   )14539,      (unsigned short const   )2640,      (unsigned short const   )7129, 
        (unsigned short const   )28518,      (unsigned short const   )32495,      (unsigned short const   )19572,      (unsigned short const   )24061, 
        (unsigned short const   )46475,      (unsigned short const   )41986,      (unsigned short const   )38553,      (unsigned short const   )34576, 
        (unsigned short const   )62383,      (unsigned short const   )57894,      (unsigned short const   )53437,      (unsigned short const   )49460, 
        (unsigned short const   )14787,      (unsigned short const   )10314,      (unsigned short const   )6865,      (unsigned short const   )2904, 
        (unsigned short const   )32743,      (unsigned short const   )28270,      (unsigned short const   )23797,      (unsigned short const   )19836, 
        (unsigned short const   )50700,      (unsigned short const   )55173,      (unsigned short const   )58654,      (unsigned short const   )62615, 
        (unsigned short const   )32808,      (unsigned short const   )37281,      (unsigned short const   )41786,      (unsigned short const   )45747, 
        (unsigned short const   )19012,      (unsigned short const   )23501,      (unsigned short const   )26966,      (unsigned short const   )30943, 
        (unsigned short const   )3168,      (unsigned short const   )7657,      (unsigned short const   )12146,      (unsigned short const   )16123, 
        (unsigned short const   )54925,      (unsigned short const   )50948,      (unsigned short const   )62879,      (unsigned short const   )58390, 
        (unsigned short const   )37033,      (unsigned short const   )33056,      (unsigned short const   )46011,      (unsigned short const   )41522, 
        (unsigned short const   )23237,      (unsigned short const   )19276,      (unsigned short const   )31191,      (unsigned short const   )26718, 
        (unsigned short const   )7393,      (unsigned short const   )3432,      (unsigned short const   )16371,      (unsigned short const   )11898, 
        (unsigned short const   )59150,      (unsigned short const   )63111,      (unsigned short const   )50204,      (unsigned short const   )54677, 
        (unsigned short const   )41258,      (unsigned short const   )45219,      (unsigned short const   )33336,      (unsigned short const   )37809, 
        (unsigned short const   )27462,      (unsigned short const   )31439,      (unsigned short const   )18516,      (unsigned short const   )23005, 
        (unsigned short const   )11618,      (unsigned short const   )15595,      (unsigned short const   )3696,      (unsigned short const   )8185, 
        (unsigned short const   )63375,      (unsigned short const   )58886,      (unsigned short const   )54429,      (unsigned short const   )50452, 
        (unsigned short const   )45483,      (unsigned short const   )40994,      (unsigned short const   )37561,      (unsigned short const   )33584, 
        (unsigned short const   )31687,      (unsigned short const   )27214,      (unsigned short const   )22741,      (unsigned short const   )18780, 
        (unsigned short const   )15843,      (unsigned short const   )11370,      (unsigned short const   )7921,      (unsigned short const   )3960};
#line 71 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
__inline static int check_crc_ccitt(unsigned char const   *buf , int cnt ) 
{ 
  unsigned int crc ;
  unsigned char const   *tmp ;

  {
#line 73
  crc = 65535U;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (cnt > 0)) {
#line 75
      goto while_break;
    }
#line 76
    tmp = buf;
#line 76
    buf ++;
#line 76
    crc = (crc >> 8) ^ (unsigned int )crc_ccitt_table___0[(crc ^ (unsigned int )*tmp) & 255U];
#line 75
    cnt --;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((crc & 65535U) == 61624U);
}
}
#line 82 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
static void ax25_disp_packet(struct demod_state *s , unsigned char *bp , unsigned int len ) 
{ 
  unsigned char v1 ;
  unsigned char cmd ;
  unsigned char i ;
  unsigned char j ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 84
  v1 = (unsigned char)1;
#line 84
  cmd = (unsigned char)0;
#line 87
  if (! bp) {
#line 88
    return;
  } else
#line 87
  if (len < 10U) {
#line 88
    return;
  }
  {
#line 90
  tmp = check_crc_ccitt((unsigned char const   *)bp, (int )len);
  }
#line 90
  if (! tmp) {
#line 91
    return;
  }
#line 93
  len -= 2U;
#line 94
  if ((int )*(bp + 1) & 1) {
    {
#line 98
    v1 = (unsigned char)0;
#line 99
    cmd = (unsigned char )(((int )*(bp + 1) & 2) != 0);
#line 100
    verbprintf(0, "%s: fm ? to ", (s->dem_par)->name);
#line 101
    i = (unsigned char )(((int )*(bp + 2) >> 2) & 63);
    }
#line 102
    if (i) {
      {
#line 103
      verbprintf(0, "%c", (int )i + 32);
      }
    }
#line 104
    i = (unsigned char )((((int )*(bp + 2) << 4) | (((int )*(bp + 3) >> 4) & 15)) & 63);
#line 105
    if (i) {
      {
#line 106
      verbprintf(0, "%c", (int )i + 32);
      }
    }
#line 107
    i = (unsigned char )((((int )*(bp + 3) << 2) | (((int )*(bp + 4) >> 6) & 3)) & 63);
#line 108
    if (i) {
      {
#line 109
      verbprintf(0, "%c", (int )i + 32);
      }
    }
#line 110
    i = (unsigned char )((int )*(bp + 4) & 63);
#line 111
    if (i) {
      {
#line 112
      verbprintf(0, "%c", (int )i + 32);
      }
    }
#line 113
    i = (unsigned char )(((int )*(bp + 5) >> 2) & 63);
#line 114
    if (i) {
      {
#line 115
      verbprintf(0, "%c", (int )i + 32);
      }
    }
#line 116
    i = (unsigned char )((((int )*(bp + 5) << 4) | (((int )*(bp + 6) >> 4) & 15)) & 63);
#line 117
    if (i) {
      {
#line 118
      verbprintf(0, "%c", (int )i + 32);
      }
    }
    {
#line 119
    verbprintf(0, "-%u QSO Nr %u", (int )*(bp + 6) & 15, ((int )*(bp + 0) << 6) | ((int )*(bp + 1) >> 2));
#line 120
    bp += 7;
#line 121
    len -= 7U;
    }
  } else {
#line 126
    if (len < 15U) {
#line 127
      return;
    }
#line 128
    if (((int )*(bp + 6) & 128) != ((int )*(bp + 13) & 128)) {
#line 129
      v1 = (unsigned char)0;
#line 130
      cmd = (unsigned char )((int )*(bp + 6) & 128);
    }
    {
#line 132
    verbprintf(0, "%s: fm ", (s->dem_par)->name);
#line 133
    i = (unsigned char)7;
    }
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      if (! ((int )i < 13)) {
#line 133
        goto while_break;
      }
#line 134
      if (((int )*(bp + i) & 254) != 64) {
        {
#line 135
        verbprintf(0, "%c", (int )*(bp + i) >> 1);
        }
      }
#line 133
      i = (unsigned char )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 136
    verbprintf(0, "-%u to ", ((int )*(bp + 13) >> 1) & 15);
#line 137
    i = (unsigned char)0;
    }
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! ((int )i < 6)) {
#line 137
        goto while_break___0;
      }
#line 138
      if (((int )*(bp + i) & 254) != 64) {
        {
#line 139
        verbprintf(0, "%c", (int )*(bp + i) >> 1);
        }
      }
#line 137
      i = (unsigned char )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 140
    verbprintf(0, "-%u", ((int )*(bp + 6) >> 1) & 15);
#line 141
    bp += 14;
#line 142
    len -= 14U;
    }
#line 143
    if (! ((int )*(bp + -1) & 1)) {
#line 143
      if (len >= 7U) {
        {
#line 144
        verbprintf(0, " via ");
        }
      }
    }
    {
#line 145
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 145
      if (! ((int )*(bp + -1) & 1)) {
#line 145
        if (! (len >= 7U)) {
#line 145
          goto while_break___1;
        }
      } else {
#line 145
        goto while_break___1;
      }
#line 146
      i = (unsigned char)0;
      {
#line 146
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 146
        if (! ((int )i < 6)) {
#line 146
          goto while_break___2;
        }
#line 147
        if (((int )*(bp + i) & 254) != 64) {
          {
#line 148
          verbprintf(0, "%c", (int )*(bp + i) >> 1);
          }
        }
#line 146
        i = (unsigned char )((int )i + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 149
      verbprintf(0, "-%u", ((int )*(bp + 6) >> 1) & 15);
#line 150
      bp += 7;
#line 151
      len -= 7U;
      }
#line 152
      if (! ((int )*(bp + -1) & 1)) {
#line 152
        if (len >= 7U) {
          {
#line 153
          verbprintf(0, ",");
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 156
  if (! len) {
#line 157
    return;
  }
#line 158
  tmp___0 = bp;
#line 158
  bp ++;
#line 158
  i = *tmp___0;
#line 159
  len --;
#line 160
  if (v1) {
#line 160
    if ((int )i & 16) {
#line 160
      tmp___1 = '!';
    } else {
#line 160
      tmp___1 = ' ';
    }
#line 160
    j = (unsigned char )tmp___1;
  } else {
#line 160
    if ((int )i & 16) {
#line 160
      if (cmd) {
#line 160
        tmp___2 = '+';
      } else {
#line 160
        tmp___2 = '-';
      }
#line 160
      tmp___4 = tmp___2;
    } else {
#line 160
      if (cmd) {
#line 160
        tmp___3 = '^';
      } else {
#line 160
        tmp___3 = 'v';
      }
#line 160
      tmp___4 = tmp___3;
    }
#line 160
    j = (unsigned char )tmp___4;
  }
#line 162
  if (! ((int )i & 1)) {
    {
#line 166
    verbprintf(0, " I%u%u%c", ((int )i >> 5) & 7, ((int )i >> 1) & 7, (int )j);
    }
  } else
#line 167
  if ((int )i & 2) {
    {
#line 172
    if (((int )i & -17) == 3) {
#line 172
      goto case_3;
    }
#line 175
    if (((int )i & -17) == 47) {
#line 175
      goto case_47;
    }
#line 178
    if (((int )i & -17) == 67) {
#line 178
      goto case_67;
    }
#line 181
    if (((int )i & -17) == 15) {
#line 181
      goto case_15;
    }
#line 184
    if (((int )i & -17) == 99) {
#line 184
      goto case_99;
    }
#line 187
    if (((int )i & -17) == 135) {
#line 187
      goto case_135;
    }
#line 190
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 173
    verbprintf(0, " UI%c", (int )j);
    }
#line 174
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 176
    verbprintf(0, " SABM%c", (int )j);
    }
#line 177
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 179
    verbprintf(0, " DISC%c", (int )j);
    }
#line 180
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 182
    verbprintf(0, " DM%c", (int )j);
    }
#line 183
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 185
    verbprintf(0, " UA%c", (int )j);
    }
#line 186
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 188
    verbprintf(0, " FRMR%c", (int )j);
    }
#line 189
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 191
    verbprintf(0, " unknown U (0x%x)%c", (int )i & -17, (int )j);
    }
#line 192
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    if (((int )i & 15) == 1) {
#line 199
      goto case_1;
    }
#line 202
    if (((int )i & 15) == 5) {
#line 202
      goto case_5;
    }
#line 205
    if (((int )i & 15) == 9) {
#line 205
      goto case_9;
    }
#line 208
    goto switch_default___0;
    case_1: /* CIL Label */ 
    {
#line 200
    verbprintf(0, " RR%u%c", ((int )i >> 5) & 7, (int )j);
    }
#line 201
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 203
    verbprintf(0, " RNR%u%c", ((int )i >> 5) & 7, (int )j);
    }
#line 204
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 206
    verbprintf(0, " REJ%u%c", ((int )i >> 5) & 7, (int )j);
    }
#line 207
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 209
    verbprintf(0, " unknown S (0x%x)%u%c", (int )i & 15, ((int )i >> 5) & 7, (int )j);
    }
#line 211
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 214
  if (! len) {
    {
#line 215
    verbprintf(0, "\n");
    }
#line 216
    return;
  }
  {
#line 218
  tmp___5 = bp;
#line 218
  bp ++;
#line 218
  verbprintf(0, " pid=%02X\n", (int )*tmp___5);
#line 219
  len --;
#line 220
  j = (unsigned char)0;
  }
  {
#line 221
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 221
    if (! len) {
#line 221
      goto while_break___3;
    }
#line 222
    tmp___6 = bp;
#line 222
    bp ++;
#line 222
    i = *tmp___6;
#line 223
    if ((int )i >= 32) {
#line 223
      if ((int )i < 128) {
        {
#line 224
        verbprintf(0, "%c", (int )i);
        }
      } else {
#line 223
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 225
    if ((int )i == 13) {
#line 226
      if (j) {
        {
#line 227
        verbprintf(0, "\n");
        }
      }
#line 228
      j = (unsigned char)0;
    } else {
      {
#line 230
      verbprintf(0, ".");
      }
    }
#line 231
    if ((int )i >= 32) {
#line 232
      j = (unsigned char)1;
    }
#line 233
    len --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 235
  if (j) {
    {
#line 236
    verbprintf(0, "\n");
    }
  }
#line 237
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
void hdlc_init(struct demod_state *s ) 
{ 


  {
  {
#line 243
  memset((void *)(& s->l2.hdlc), 0, sizeof(s->l2.hdlc));
  }
#line 244
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/multimon-1.0/hdlc.c"
void hdlc_rxbit(struct demod_state *s , int bit ) 
{ 
  unsigned char *tmp ;

  {
#line 250
  s->l2.hdlc.rxbitstream <<= 1;
#line 251
  s->l2.hdlc.rxbitstream |= (unsigned int )(! (! bit));
#line 252
  if ((s->l2.hdlc.rxbitstream & 255U) == 126U) {
#line 253
    if (s->l2.hdlc.rxstate) {
#line 253
      if (s->l2.hdlc.rxptr - s->l2.hdlc.rxbuf > 2L) {
        {
#line 254
        ax25_disp_packet(s, s->l2.hdlc.rxbuf, (unsigned int )(s->l2.hdlc.rxptr - s->l2.hdlc.rxbuf));
        }
      }
    }
#line 255
    s->l2.hdlc.rxstate = 1U;
#line 256
    s->l2.hdlc.rxptr = s->l2.hdlc.rxbuf;
#line 257
    s->l2.hdlc.rxbitbuf = 128U;
#line 258
    return;
  }
#line 260
  if ((s->l2.hdlc.rxbitstream & 127U) == 127U) {
#line 261
    s->l2.hdlc.rxstate = 0U;
#line 262
    return;
  }
#line 264
  if (! s->l2.hdlc.rxstate) {
#line 265
    return;
  }
#line 266
  if ((s->l2.hdlc.rxbitstream & 63U) == 62U) {
#line 267
    return;
  }
#line 268
  if (s->l2.hdlc.rxbitstream & 1U) {
#line 269
    s->l2.hdlc.rxbitbuf |= 256U;
  }
#line 270
  if (s->l2.hdlc.rxbitbuf & 1U) {
#line 271
    if ((unsigned long )s->l2.hdlc.rxptr >= (unsigned long )(s->l2.hdlc.rxbuf + sizeof(s->l2.hdlc.rxbuf))) {
      {
#line 272
      s->l2.hdlc.rxstate = 0U;
#line 273
      verbprintf(1, "Error: packet size too large\n");
      }
#line 274
      return;
    }
#line 276
    tmp = s->l2.hdlc.rxptr;
#line 276
    (s->l2.hdlc.rxptr) ++;
#line 276
    *tmp = (unsigned char )(s->l2.hdlc.rxbitbuf >> 1);
#line 277
    s->l2.hdlc.rxbitbuf = 128U;
#line 278
    return;
  }
#line 280
  s->l2.hdlc.rxbitbuf >>= 1;
#line 281
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc24.c"
static void poc24_init(struct demod_state *s ) 
{ 


  {
  {
#line 45
  pocsag_init(s);
#line 46
  memset((void *)(& s->l1.poc24), 0, sizeof(s->l1.poc24));
  }
#line 47
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc24.c"
static void poc24_demod(struct demod_state *s , float *buffer , int length ) 
{ 


  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (length > 0)) {
#line 53
      goto while_break;
    }
    {
#line 54
    s->l1.poc24.dcd_shreg <<= 1;
#line 55
    s->l1.poc24.dcd_shreg |= (unsigned int )(*buffer > (float )0);
#line 56
    verbprintf(10, "%c", 48U + (s->l1.poc24.dcd_shreg & 1U));
    }
#line 60
    if ((s->l1.poc24.dcd_shreg ^ (s->l1.poc24.dcd_shreg >> 1)) & 1U) {
#line 61
      if (s->l1.poc24.sphase < 29202U) {
#line 62
        s->l1.poc24.sphase += 891U;
      } else {
#line 64
        s->l1.poc24.sphase -= 891U;
      }
    }
#line 66
    s->l1.poc24.sphase += 7133U;
#line 67
    if (s->l1.poc24.sphase >= 65536U) {
      {
#line 68
      s->l1.poc24.sphase &= 65535U;
#line 69
      pocsag_rxbit(s, (int )(s->l1.poc24.dcd_shreg & 1U));
      }
    }
#line 53
    length --;
#line 53
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/multimon-1.0/demod_poc24.c"
struct demod_param  const  demod_poc24  =    {"POCSAG2400", 22050U, 1U, & poc24_init, & poc24_demod};
#line 41 "/home/wheatley/newnew/temp/multimon-1.0/demod_display.c"
static void scope_init(struct demod_state *s ) 
{ 


  {
  {
#line 43
  memset((void *)(& s->l1.scope), 0, sizeof(s->l1.scope));
#line 44
  s->l1.scope.dispnum = xdisp_start();
  }
#line 45
  if (s->l1.scope.dispnum == -1) {
#line 46
    return;
  }
#line 47
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/multimon-1.0/demod_display.c"
static void scope_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float *src ;
  float *dst ;
  int i ;
  int tmp ;

  {
#line 58
  if (s->l1.scope.dispnum == -1) {
#line 59
    return;
  }
#line 60
  if ((unsigned long )length >= sizeof(s->l1.scope.data) / sizeof(s->l1.scope.data[0])) {
#line 61
    src = (buffer + length) - sizeof(s->l1.scope.data) / sizeof(s->l1.scope.data[0]);
#line 62
    dst = s->l1.scope.data;
#line 63
    i = (int )(sizeof(s->l1.scope.data) / sizeof(s->l1.scope.data[0]));
  } else {
    {
#line 65
    i = (int )(sizeof(s->l1.scope.data) / sizeof(s->l1.scope.data[0]) - (unsigned long )length);
#line 66
    memmove((void *)(s->l1.scope.data), (void const   *)(s->l1.scope.data + i), (unsigned long )i * sizeof(s->l1.scope.data[0]));
#line 68
    src = buffer;
#line 69
    dst = s->l1.scope.data + i;
#line 70
    i = length;
    }
  }
  {
#line 72
  s->l1.scope.datalen += i;
#line 73
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (unsigned long )i * sizeof(s->l1.scope.data[0]));
  }
#line 74
  if ((unsigned long )s->l1.scope.datalen < sizeof(s->l1.scope.data) / sizeof(s->l1.scope.data[0])) {
#line 75
    return;
  }
  {
#line 76
  tmp = xdisp_update(s->l1.scope.dispnum, s->l1.scope.data);
  }
#line 76
  if (tmp) {
#line 77
    s->l1.scope.datalen = 0;
  }
#line 78
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/multimon-1.0/demod_display.c"
struct demod_param  const  demod_scope  =    {"SCOPE", 22050U, 0U, & scope_init, & scope_demod};
#line 49 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
static char const   *dtmf_transl___0  =    "123A456B789C*0#D";
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
static unsigned int const   dtmf_phinc[8]  = 
#line 51
  {      (unsigned int const   )3593,      (unsigned int const   )3970,      (unsigned int const   )4389,      (unsigned int const   )4853, 
        (unsigned int const   )2071,      (unsigned int const   )2288,      (unsigned int const   )2532,      (unsigned int const   )2796};
#line 58 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
static void dtmf_init(struct demod_state *s ) 
{ 


  {
  {
#line 60
  memset((void *)(& s->l1.dtmf), 0, sizeof(s->l1.dtmf));
  }
#line 61
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
static int find_max_idx___1(float const   *f ) 
{ 
  float en ;
  int idx ;
  int i ;

  {
#line 67
  en = (float )0;
#line 68
  idx = -1;
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < 4)) {
#line 70
      goto while_break;
    }
#line 71
    if (*(f + i) > (float const   )en) {
#line 72
      en = (float )*(f + i);
#line 73
      idx = i;
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (idx < 0) {
#line 76
    return (-1);
  }
#line 77
  en = (float )((double )en * 0.1);
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! (i < 4)) {
#line 78
      goto while_break___0;
    }
#line 79
    if (idx != i) {
#line 79
      if (*(f + i) > (float const   )en) {
#line 80
        return (-1);
      }
    }
#line 78
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  return (idx);
}
}
#line 86 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
__inline static int process_block___1(struct demod_state *s ) 
{ 
  float tote ;
  float totte[16] ;
  int i ;
  int j ;
  float tmp ;
  float tmp___0 ;

  {
#line 92
  tote = (float )0;
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 4)) {
#line 93
      goto while_break;
    }
#line 94
    tote += s->l1.dtmf.energy[i];
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (i < 16)) {
#line 95
      goto while_break___0;
    }
#line 96
    totte[i] = (float )0;
#line 97
    j = 0;
    {
#line 97
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 97
      if (! (j < 4)) {
#line 97
        goto while_break___1;
      }
#line 98
      totte[i] += s->l1.dtmf.tenergy[j][i];
#line 97
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 95
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 100
    if (! (i < 8)) {
#line 100
      goto while_break___2;
    }
    {
#line 101
    tmp = fsqr(totte[i]);
#line 101
    tmp___0 = fsqr(totte[i + 8]);
#line 101
    totte[i] = tmp + tmp___0;
#line 100
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 102
  memmove((void *)(s->l1.dtmf.energy + 1), (void const   *)(s->l1.dtmf.energy), sizeof(s->l1.dtmf.energy) - sizeof(s->l1.dtmf.energy[0]));
#line 104
  s->l1.dtmf.energy[0] = (float )0;
#line 105
  memmove((void *)(s->l1.dtmf.tenergy + 1), (void const   *)(s->l1.dtmf.tenergy),
          sizeof(s->l1.dtmf.tenergy) - sizeof(s->l1.dtmf.tenergy[0]));
#line 107
  memset((void *)(s->l1.dtmf.tenergy), 0, sizeof(s->l1.dtmf.tenergy[0]));
#line 108
  tote = (float )((double )tote * ((double )880 * 0.5));
#line 109
  verbprintf(10, "DTMF: Energies: %8.5f  %8.5f %8.5f %8.5f %8.5f  %8.5f %8.5f %8.5f %8.5f\n",
             (double )tote, (double )totte[0], (double )totte[1], (double )totte[2],
             (double )totte[3], (double )totte[4], (double )totte[5], (double )totte[6],
             (double )totte[7]);
#line 111
  i = find_max_idx___1((float const   *)(totte));
  }
#line 111
  if (i < 0) {
#line 112
    return (-1);
  }
  {
#line 113
  j = find_max_idx___1((float const   *)(totte + 4));
  }
#line 113
  if (j < 0) {
#line 114
    return (-1);
  }
#line 115
  if ((double )tote * 0.4 > (double )(totte[i] + totte[j + 4])) {
#line 116
    return (-1);
  }
#line 117
  return ((i & 3) | ((j << 2) & 12));
}
}
#line 122 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
static void dtmf_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float s_in ;
  int i ;
  float tmp ;
  int tmp___0 ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (length > 0)) {
#line 127
      goto while_break;
    }
    {
#line 128
    s_in = *buffer;
#line 129
    tmp = fsqr(s_in);
#line 129
    s->l1.dtmf.energy[0] += tmp;
#line 130
    i = 0;
    }
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 130
      if (! (i < 8)) {
#line 130
        goto while_break___0;
      }
#line 131
      s->l1.dtmf.tenergy[0][i] += (float )(costabf[(s->l1.dtmf.ph[i] >> 6) & 1023U] * (float const   )s_in);
#line 132
      s->l1.dtmf.tenergy[0][i + 8] += (float )(costabf[((s->l1.dtmf.ph[i] + 49152U) >> 6) & 1023U] * (float const   )s_in);
#line 133
      s->l1.dtmf.ph[i] += (unsigned int )dtmf_phinc[i];
#line 130
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    tmp___0 = s->l1.dtmf.blkcount;
#line 135
    (s->l1.dtmf.blkcount) --;
#line 135
    if (tmp___0 <= 0) {
      {
#line 136
      s->l1.dtmf.blkcount = 220;
#line 137
      i = process_block___1(s);
      }
#line 138
      if (i != s->l1.dtmf.lastch) {
#line 138
        if (i >= 0) {
          {
#line 139
          verbprintf(0, "DTMF: %c\n", (int const   )*(dtmf_transl___0 + i));
          }
        }
      }
#line 140
      s->l1.dtmf.lastch = i;
    }
#line 127
    length --;
#line 127
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/multimon-1.0/demod_dtmf.c"
struct demod_param  const  demod_dtmf  =    {"DTMF", 22050U, 0U, & dtmf_init, & dtmf_demod};
#line 49 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static float corr_mark_i___2[18]  ;
#line 50 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static float corr_mark_q___2[18]  ;
#line 51 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static float corr_space_i___2[18]  ;
#line 52 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static float corr_space_q___2[18]  ;
#line 56 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static void afsk24_2_init(struct demod_state *s ) 
{ 
  float f ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 61
  hdlc_init(s);
#line 62
  memset((void *)(& s->l1.afsk24), 0, sizeof(s->l1.afsk24));
#line 63
  f = (float )0;
#line 63
  i = 0;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 18)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = cos((double )f);
#line 64
    corr_mark_i___2[i] = (float )tmp;
#line 65
    tmp___0 = sin((double )f);
#line 65
    corr_mark_q___2[i] = (float )tmp___0;
#line 66
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )3658) / (double )22050);
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  f = (float )0;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i < 18)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    tmp___1 = cos((double )f);
#line 69
    corr_space_i___2[i] = (float )tmp___1;
#line 70
    tmp___2 = sin((double )f);
#line 70
    corr_space_q___2[i] = (float )tmp___2;
#line 71
    f = (float )((double )f + ((2.0 * 3.14159265358979323846) * (double )1996) / (double )22050);
#line 68
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 73
    if (! (i < 18)) {
#line 73
      goto while_break___1;
    }
    {
#line 74
    tmp___3 = cos((((double )2 * 3.14159265358979323846) * (double )i) / (double )((float )17));
#line 74
    f = (float )(0.54 - 0.46 * tmp___3);
#line 75
    corr_mark_i___2[i] *= f;
#line 76
    corr_mark_q___2[i] *= f;
#line 77
    corr_space_i___2[i] *= f;
#line 78
    corr_space_q___2[i] *= f;
#line 73
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
static void afsk24_2_demod(struct demod_state *s , float *buffer , int length ) 
{ 
  float f ;
  unsigned char curbit ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (length > 0)) {
#line 89
      goto while_break;
    }
    {
#line 90
    tmp = mac((float const   *)buffer, (float const   *)(corr_mark_i___2), 18U);
#line 90
    tmp___0 = fsqr(tmp);
#line 90
    tmp___1 = mac((float const   *)buffer, (float const   *)(corr_mark_q___2), 18U);
#line 90
    tmp___2 = fsqr(tmp___1);
#line 90
    tmp___3 = mac((float const   *)buffer, (float const   *)(corr_space_i___2), 18U);
#line 90
    tmp___4 = fsqr(tmp___3);
#line 90
    tmp___5 = mac((float const   *)buffer, (float const   *)(corr_space_q___2), 18U);
#line 90
    tmp___6 = fsqr(tmp___5);
#line 90
    f = ((tmp___0 + tmp___2) - tmp___4) - tmp___6;
#line 94
    s->l1.afsk24.dcd_shreg <<= 1;
#line 95
    s->l1.afsk24.dcd_shreg |= (unsigned int )(f > (float )0);
#line 96
    verbprintf(10, "%c", 48U + (s->l1.afsk24.dcd_shreg & 1U));
    }
#line 100
    if ((s->l1.afsk24.dcd_shreg ^ (s->l1.afsk24.dcd_shreg >> 1)) & 1U) {
#line 101
      if (s->l1.afsk24.sphase < 29202U) {
#line 102
        s->l1.afsk24.sphase += 891U;
      } else {
#line 104
        s->l1.afsk24.sphase -= 891U;
      }
    }
#line 106
    s->l1.afsk24.sphase += 7133U;
#line 107
    if (s->l1.afsk24.sphase >= 65536U) {
      {
#line 108
      s->l1.afsk24.sphase &= 65535U;
#line 109
      s->l1.afsk24.lasts <<= 1;
#line 110
      s->l1.afsk24.lasts |= s->l1.afsk24.dcd_shreg & 1U;
#line 111
      curbit = (unsigned char )(((s->l1.afsk24.lasts ^ (s->l1.afsk24.lasts >> 1)) ^ 1U) & 1U);
#line 113
      verbprintf(9, " %c ", 48 + (int )curbit);
#line 114
      hdlc_rxbit(s, (int )curbit);
      }
    }
#line 89
    length --;
#line 89
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/multimon-1.0/demod_afsk24_2.c"
struct demod_param  const  demod_afsk2400_2  =    {"AFSK2400_2", 22050U, 18U, & afsk24_2_init, & afsk24_2_demod};
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
