/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 40 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
struct __anonstruct_mpeg_stream_info_t_8 {
   unsigned long packet_cnt ;
   unsigned long long size ;
};
#line 40 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_stream_info_t_8 mpeg_stream_info_t;
#line 45 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
struct __anonstruct_mpeg_shdr_t_9 {
   unsigned int size ;
   int fixed ;
   int csps ;
};
#line 45 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_shdr_t_9 mpeg_shdr_t;
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
struct __anonstruct_mpeg_packet_t_10 {
   unsigned int type ;
   unsigned int sid ;
   unsigned int ssid ;
   unsigned int size ;
   unsigned int offset ;
   char have_pts ;
   unsigned long long pts ;
   char have_dts ;
   unsigned long long dts ;
};
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_packet_t_10 mpeg_packet_t;
#line 65 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
struct __anonstruct_mpeg_pack_t_11 {
   unsigned int size ;
   unsigned int type ;
   unsigned long long scr ;
   unsigned long mux_rate ;
   unsigned int stuff ;
};
#line 65 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_pack_t_11 mpeg_pack_t;
#line 73 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
struct mpeg_demux_t {
   int close ;
   int free ;
   FILE *fp ;
   unsigned long long ofs ;
   unsigned int buf_i ;
   unsigned int buf_n ;
   unsigned char buf[4096] ;
   mpeg_shdr_t shdr ;
   mpeg_packet_t packet ;
   mpeg_pack_t pack ;
   unsigned long shdr_cnt ;
   unsigned long pack_cnt ;
   unsigned long packet_cnt ;
   unsigned long end_cnt ;
   unsigned long skip_cnt ;
   mpeg_stream_info_t streams[256] ;
   mpeg_stream_info_t substreams[256] ;
   void *ext ;
   int (*mpeg_skip)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_pack)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_system_header)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_packet)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_packet_check)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_end)(struct mpeg_demux_t *mpeg ) ;
};
#line 73 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
typedef struct mpeg_demux_t mpeg_demux_t;
#line 31 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.h"
struct __anonstruct_mpeg_buffer_t_12 {
   unsigned char *buf ;
   unsigned int cnt ;
   unsigned int max ;
};
#line 31 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.h"
typedef struct __anonstruct_mpeg_buffer_t_12 mpeg_buffer_t;
#line 135 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 32 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.h"
struct __anonstruct_mpegd_option_t_26 {
   short name1 ;
   unsigned short argcnt ;
   char const   *name2 ;
   char const   *argdesc ;
   char const   *optdesc ;
};
#line 32 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.h"
typedef struct __anonstruct_mpegd_option_t_26 mpegd_option_t;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 41 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.h"
void prt_err(char const   *msg  , ...) ;
#line 42
void prt_msg(char const   *msg  , ...) ;
#line 108 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
mpeg_demux_t *mpegd_open_fp(mpeg_demux_t *mpeg , FILE *fp___0 , int close ) ;
#line 110
void mpegd_close(mpeg_demux_t *mpeg ) ;
#line 113
int mpegd_skip(mpeg_demux_t *mpeg , unsigned int n ) ;
#line 119
unsigned int mpegd_read(mpeg_demux_t *mpeg , void *buf , unsigned int n ) ;
#line 122
int mpegd_parse(mpeg_demux_t *mpeg ) ;
#line 41 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.h"
void mpeg_buf_clear(mpeg_buffer_t *buf ) ;
#line 44
int mpeg_buf_read(mpeg_buffer_t *buf , mpeg_demux_t *mpeg , unsigned int cnt ) ;
#line 46
int mpeg_buf_write_clear(mpeg_buffer_t *buf , FILE *fp___0 ) ;
#line 30 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.h"
int mpeg_demux(FILE *inp , FILE *out ) ;
#line 48 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_stream[256] ;
#line 49
unsigned char par_substream[256] ;
#line 60
int par_drop ;
#line 63
int par_dvdac3 ;
#line 64
int par_dvdsub ;
#line 65
char *par_demux_name ;
#line 68
char *mpeg_get_name(char const   *base , unsigned int sid ) ;
#line 69
int mpeg_stream_excl(unsigned char sid , unsigned char ssid ) ;
#line 70
int mpeg_packet_check(mpeg_demux_t *mpeg ) ;
#line 72
int mpeg_copy(mpeg_demux_t *mpeg , FILE *fp___0 , unsigned int n ) ;
#line 36 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static FILE *fp[512]  ;
#line 38 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static mpeg_buffer_t packet  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44
static int mpeg_demux_copy_spu(mpeg_demux_t *mpeg , FILE *fp___0 , unsigned int cnt ) ;
#line 44 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static unsigned int spucnt  =    0U;
#line 45 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int half  =    0;
#line 41 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int mpeg_demux_copy_spu(mpeg_demux_t *mpeg , FILE *fp___0 , unsigned int cnt ) 
{ 
  unsigned int i ;
  unsigned int n ;
  unsigned char buf[8] ;
  unsigned long long pts ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 50
  if (half) {
    {
#line 51
    mpegd_read(mpeg, (void *)(buf), 1U);
#line 53
    tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp___0);
    }
#line 53
    if (tmp != 1UL) {
#line 54
      return (1);
    }
#line 57
    spucnt = (spucnt << 8) + (unsigned int )buf[0];
#line 58
    half = 0;
#line 60
    spucnt -= 2U;
#line 61
    cnt --;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (cnt > 0U)) {
#line 64
      goto while_break;
    }
#line 65
    if (spucnt == 0U) {
#line 66
      pts = mpeg->packet.pts;
#line 67
      i = 0U;
      {
#line 67
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 67
        if (! (i < 8U)) {
#line 67
          goto while_break___0;
        }
#line 68
        buf[7U - i] = (unsigned char )(pts & 255ULL);
#line 69
        pts >>= 8;
#line 67
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 72
      tmp___0 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )8,
                       (FILE */* __restrict  */)fp___0);
      }
#line 72
      if (tmp___0 != 8UL) {
#line 73
        return (1);
      }
#line 76
      if (cnt == 1U) {
        {
#line 77
        mpegd_read(mpeg, (void *)(buf), 1U);
#line 79
        tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1,
                         (FILE */* __restrict  */)fp___0);
        }
#line 79
        if (tmp___1 != 1UL) {
#line 80
          return (1);
        }
#line 83
        spucnt = (unsigned int )buf[0];
#line 84
        half = 1;
#line 86
        return (0);
      }
      {
#line 89
      mpegd_read(mpeg, (void *)(buf), 2U);
#line 91
      tmp___2 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )2,
                       (FILE */* __restrict  */)fp___0);
      }
#line 91
      if (tmp___2 != 2UL) {
#line 92
        return (1);
      }
#line 95
      spucnt = (unsigned int )(((int )buf[0] << 8) + (int )buf[1]);
#line 97
      if (spucnt < 2U) {
#line 98
        return (1);
      }
#line 101
      spucnt -= 2U;
#line 102
      cnt -= 2U;
    }
#line 105
    if (cnt < spucnt) {
#line 105
      n = cnt;
    } else {
#line 105
      n = spucnt;
    }
    {
#line 107
    mpeg_copy(mpeg, fp___0, n);
#line 108
    cnt -= n;
#line 109
    spucnt -= n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static FILE *mpeg_demux_open(mpeg_demux_t *mpeg , unsigned int sid , unsigned int ssid ) 
{ 
  FILE *fp___0 ;
  char *name ;
  unsigned int seq ;
  size_t tmp ;

  {
#line 122
  if ((unsigned long )par_demux_name == (unsigned long )((void *)0)) {
#line 123
    fp___0 = (FILE *)mpeg->ext;
  } else {
#line 126
    if (sid == 189U) {
#line 126
      seq = (sid << 8) + ssid;
    } else {
#line 126
      seq = sid;
    }
    {
#line 128
    name = mpeg_get_name((char const   *)par_demux_name, seq);
#line 130
    fp___0 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
    }
#line 131
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 132
      prt_err("can\'t open stream file (%s)\n", name);
      }
#line 134
      if (sid == 189U) {
#line 135
        par_substream[ssid] = (unsigned char )((int )par_substream[ssid] & -2);
      } else {
#line 138
        par_stream[sid] = (unsigned char )((int )par_stream[sid] & -2);
      }
      {
#line 141
      free((void *)name);
      }
#line 143
      return ((FILE *)((void *)0));
    }
    {
#line 146
    free((void *)name);
    }
  }
#line 149
  if (sid == 189U) {
#line 149
    if (par_dvdsub) {
      {
#line 150
      tmp = fwrite((void const   */* __restrict  */)"SPU ", (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)fp___0);
      }
#line 150
      if (tmp != 4UL) {
        {
#line 151
        fclose(fp___0);
        }
#line 152
        return ((FILE *)((void *)0));
      }
    }
  }
#line 156
  return (fp___0);
}
}
#line 159 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int mpeg_demux_system_header(mpeg_demux_t *mpeg ) 
{ 


  {
#line 162
  return (0);
}
}
#line 165 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int mpeg_demux_packet(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned int ssid ;
  unsigned int fpi ;
  unsigned int cnt ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 173
  sid = mpeg->packet.sid;
#line 174
  ssid = mpeg->packet.ssid;
#line 176
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
#line 176
  if (tmp) {
#line 177
    return (0);
  }
#line 180
  cnt = mpeg->packet.offset;
#line 182
  fpi = sid;
#line 185
  if (sid == 189U) {
#line 186
    fpi = 256U + ssid;
#line 187
    cnt ++;
#line 189
    if (par_dvdac3) {
#line 190
      cnt += 3U;
    }
  }
#line 194
  if (cnt > mpeg->packet.size) {
    {
#line 195
    prt_msg("demux: AC3 packet too small (sid=%02x size=%u)\n", sid, mpeg->packet.size);
    }
#line 199
    return (1);
  }
#line 202
  if ((unsigned long )fp[fpi] == (unsigned long )((void *)0)) {
    {
#line 203
    fp[fpi] = mpeg_demux_open(mpeg, sid, ssid);
    }
#line 204
    if ((unsigned long )fp[fpi] == (unsigned long )((void *)0)) {
#line 205
      return (1);
    }
  }
#line 209
  if (cnt > 0U) {
    {
#line 210
    mpegd_skip(mpeg, cnt);
    }
  }
#line 213
  cnt = mpeg->packet.size - cnt;
#line 215
  if (sid == 189U) {
#line 215
    if (par_dvdsub) {
      {
#line 216
      tmp___0 = mpeg_demux_copy_spu(mpeg, fp[fpi], cnt);
      }
#line 216
      return (tmp___0);
    }
  }
  {
#line 219
  r = 0;
#line 221
  tmp___1 = mpeg_buf_read(& packet, mpeg, cnt);
  }
#line 221
  if (tmp___1) {
    {
#line 222
    prt_msg("demux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet.cnt, cnt);
    }
#line 226
    if (par_drop) {
      {
#line 227
      mpeg_buf_clear(& packet);
      }
#line 228
      return (1);
    }
#line 231
    r = 1;
  }
  {
#line 234
  tmp___2 = mpeg_buf_write_clear(& packet, fp[fpi]);
  }
#line 234
  if (tmp___2) {
#line 235
    r = 1;
  }
#line 238
  return (r);
}
}
#line 241 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int mpeg_demux_pack(mpeg_demux_t *mpeg ) 
{ 


  {
#line 244
  return (0);
}
}
#line 247 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
static int mpeg_demux_end(mpeg_demux_t *mpeg ) 
{ 


  {
#line 250
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_demux.c"
int mpeg_demux(FILE *inp , FILE *out ) 
{ 
  unsigned int i ;
  int r ;
  mpeg_demux_t *mpeg ;

  {
#line 259
  i = 0U;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < 512U)) {
#line 259
      goto while_break;
    }
#line 260
    fp[i] = (FILE *)((void *)0);
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
#line 264
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 265
    return (1);
  }
  {
#line 268
  mpeg->mpeg_system_header = & mpeg_demux_system_header;
#line 269
  mpeg->mpeg_pack = & mpeg_demux_pack;
#line 270
  mpeg->mpeg_packet = & mpeg_demux_packet;
#line 271
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 272
  mpeg->mpeg_end = & mpeg_demux_end;
#line 274
  mpeg->ext = (void *)out;
#line 276
  r = mpegd_parse(mpeg);
#line 278
  mpegd_close(mpeg);
#line 280
  i = 0U;
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! (i < 512U)) {
#line 280
      goto while_break___0;
    }
#line 281
    if ((unsigned long )fp[i] != (unsigned long )((void *)0)) {
#line 281
      if ((unsigned long )fp[i] != (unsigned long )out) {
        {
#line 282
        fclose(fp[i]);
        }
      }
    }
#line 280
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  return (r);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 30 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.h"
int mpeg_list(FILE *inp , FILE *out ) ;
#line 53 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
int par_no_shdr ;
#line 54
int par_no_pack ;
#line 55
int par_no_packet ;
#line 56
int par_no_end ;
#line 71
void mpeg_print_stats(mpeg_demux_t *mpeg , FILE *fp___0 ) ;
#line 35 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static unsigned long long skip_ofs  =    0ULL;
#line 36 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static unsigned long skip_cnt  =    0UL;
#line 39 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static void mpeg_list_print_skip(FILE *fp___0 ) 
{ 


  {
#line 42
  if (skip_cnt > 0UL) {
    {
#line 43
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: skip %lu\n",
            (uintmax_t )skip_ofs, skip_cnt);
#line 47
    skip_cnt = 0UL;
    }
  }
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static int mpeg_list_skip(mpeg_demux_t *mpeg ) 
{ 


  {
#line 54
  if (skip_cnt == 0UL) {
#line 55
    skip_ofs = mpeg->ofs;
  }
#line 58
  skip_cnt ++;
#line 60
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static int mpeg_list_system_header(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;

  {
#line 68
  if (par_no_shdr) {
#line 69
    return (0);
  }
  {
#line 72
  fp___0 = (FILE *)mpeg->ext;
#line 74
  mpeg_list_print_skip(fp___0);
#line 76
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: system header[%lu]: size=%u fixed=%d csps=%d\n",
          (uintmax_t )mpeg->ofs, mpeg->shdr_cnt - 1UL, mpeg->shdr.size, mpeg->shdr.fixed,
          mpeg->shdr.csps);
  }
#line 83
  return (0);
}
}
#line 86 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static int mpeg_list_packet(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;

  {
#line 92
  if (par_no_packet) {
#line 93
    return (0);
  }
  {
#line 96
  sid = mpeg->packet.sid;
#line 97
  ssid = mpeg->packet.ssid;
#line 99
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
#line 99
  if (tmp) {
#line 100
    return (0);
  }
  {
#line 103
  fp___0 = (FILE *)mpeg->ext;
#line 105
  mpeg_list_print_skip(fp___0);
#line 107
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: packet[%lu]: sid=%02x",
          (uintmax_t )mpeg->ofs, mpeg->streams[sid].packet_cnt - 1UL, sid);
  }
#line 114
  if (sid == 189U) {
    {
#line 115
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
  } else {
    {
#line 118
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___0);
    }
  }
#line 121
  if (mpeg->packet.type == 1U) {
    {
#line 122
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___0);
    }
  } else
#line 124
  if (mpeg->packet.type == 2U) {
    {
#line 125
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___0);
    }
  } else {
    {
#line 128
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___0);
    }
  }
  {
#line 131
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" size=%u",
          mpeg->packet.size);
  }
#line 133
  if (mpeg->packet.have_pts) {
    {
#line 134
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" pts=%lu[%.4f] dts=%lu[%.4f]",
            (uintmax_t )mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, (uintmax_t )mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
  } else
#line 133
  if (mpeg->packet.have_dts) {
    {
#line 134
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" pts=%lu[%.4f] dts=%lu[%.4f]",
            (uintmax_t )mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, (uintmax_t )mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
  }
  {
#line 143
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___0);
  }
#line 145
  return (0);
}
}
#line 148 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static int mpeg_list_pack(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;

  {
#line 153
  if (par_no_pack) {
#line 154
    return (0);
  }
  {
#line 157
  fp___0 = (FILE *)mpeg->ext;
#line 159
  mpeg_list_print_skip(fp___0);
#line 161
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: pack[%lu]: type=%u scr=%lu[%.4f] mux=%lu[%.2f] stuff=%u\n",
          (uintmax_t )mpeg->ofs, mpeg->pack_cnt - 1UL, mpeg->pack.type, (uintmax_t )mpeg->pack.scr,
          (double )mpeg->pack.scr / 90000.0, mpeg->pack.mux_rate, 50.0 * (double )mpeg->pack.mux_rate,
          mpeg->pack.stuff);
#line 173
  fflush(fp___0);
  }
#line 175
  return (0);
}
}
#line 178 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
static int mpeg_list_end(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;

  {
#line 183
  if (par_no_end) {
#line 184
    return (0);
  }
  {
#line 187
  fp___0 = (FILE *)mpeg->ext;
#line 189
  mpeg_list_print_skip(fp___0);
#line 191
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: end\n",
          (uintmax_t )mpeg->ofs);
  }
#line 193
  return (0);
}
}
#line 196 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_list.c"
int mpeg_list(FILE *inp , FILE *out ) 
{ 
  int r ;
  mpeg_demux_t *mpeg ;

  {
  {
#line 201
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
#line 202
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 203
    return (1);
  }
  {
#line 206
  skip_cnt = 0UL;
#line 207
  skip_ofs = 0ULL;
#line 209
  mpeg->ext = (void *)out;
#line 211
  mpeg->mpeg_skip = & mpeg_list_skip;
#line 212
  mpeg->mpeg_system_header = & mpeg_list_system_header;
#line 213
  mpeg->mpeg_pack = & mpeg_list_pack;
#line 214
  mpeg->mpeg_packet = & mpeg_list_packet;
#line 215
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 216
  mpeg->mpeg_end = & mpeg_list_end;
#line 218
  r = mpegd_parse(mpeg);
#line 220
  mpeg_list_print_skip(out);
#line 222
  mpeg_print_stats(mpeg, out);
#line 224
  mpegd_close(mpeg);
  }
#line 226
  return (r);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 36 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.h"
void msg_set_level(unsigned int level ) ;
#line 37
unsigned int msg_get_level(void) ;
#line 39
void prt_message(unsigned int level , char const   *msg  , ...) ;
#line 43
void prt_deb(char const   *msg  , ...) ;
#line 32 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
static unsigned int msg_level  =    3U;
#line 35 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void msg_set_level(unsigned int level ) 
{ 


  {
#line 37
  msg_level = level;
#line 38
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
unsigned int msg_get_level(void) 
{ 


  {
#line 42
  return (msg_level);
}
}
#line 45 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void prt_msg_va(unsigned int level , char const   *msg , va_list va ) 
{ 


  {
#line 47
  if (level <= msg_level) {
    {
#line 48
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             va);
#line 49
    fflush(stderr);
    }
  }
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void prt_message(unsigned int level , char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 57
  if (level <= msg_level) {
    {
#line 58
    __builtin_va_start(va, msg);
#line 59
    prt_msg_va(level, msg, va);
#line 60
    __builtin_va_end(va);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void prt_err(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 68
  if (0U <= msg_level) {
    {
#line 69
    __builtin_va_start(va, msg);
#line 70
    prt_msg_va(0U, msg, va);
#line 71
    __builtin_va_end(va);
    }
  }
#line 73
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void prt_msg(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 79
  if (1U <= msg_level) {
    {
#line 80
    __builtin_va_start(va, msg);
#line 81
    prt_msg_va(1U, msg, va);
#line 82
    __builtin_va_end(va);
    }
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/message.c"
void prt_deb(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 90
  if (3U <= msg_level) {
    {
#line 91
    __builtin_va_start(va, msg);
#line 92
    prt_msg_va(3U, msg, va);
#line 93
    __builtin_va_end(va);
    }
  }
#line 95
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 109 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.h"
mpeg_demux_t *mpegd_open(mpeg_demux_t *mpeg , char const   *fname ) ;
#line 111
void mpegd_reset_stats(mpeg_demux_t *mpeg ) ;
#line 112
unsigned long mpegd_get_bits(mpeg_demux_t *mpeg , unsigned int i , unsigned int n ) ;
#line 121
int mpegd_set_offset(mpeg_demux_t *mpeg , unsigned long long ofs ) ;
#line 32 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
mpeg_demux_t *mpegd_open_fp(mpeg_demux_t *mpeg , FILE *fp___0 , int close ) 
{ 
  void *tmp ;

  {
#line 34
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
    {
#line 35
    tmp = malloc(sizeof(mpeg_demux_t ));
#line 35
    mpeg = (mpeg_demux_t *)tmp;
    }
#line 36
    if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 37
      return ((mpeg_demux_t *)((void *)0));
    }
#line 39
    mpeg->free = 1;
  } else {
#line 42
    mpeg->free = 0;
  }
  {
#line 45
  mpeg->fp = fp___0;
#line 46
  mpeg->close = close;
#line 48
  mpeg->ofs = 0ULL;
#line 50
  mpeg->buf_i = 0U;
#line 51
  mpeg->buf_n = 0U;
#line 53
  mpeg->ext = (void *)0;
#line 55
  mpeg->mpeg_skip = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 56
  mpeg->mpeg_system_header = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 57
  mpeg->mpeg_packet = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 58
  mpeg->mpeg_packet_check = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 59
  mpeg->mpeg_pack = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 60
  mpeg->mpeg_end = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 62
  mpegd_reset_stats(mpeg);
  }
#line 64
  return (mpeg);
}
}
#line 67 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
mpeg_demux_t *mpegd_open(mpeg_demux_t *mpeg , char const   *fname ) 
{ 
  FILE *fp___0 ;

  {
  {
#line 71
  fp___0 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"rb");
  }
#line 72
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 73
    return ((mpeg_demux_t *)((void *)0));
  }
  {
#line 76
  mpeg = mpegd_open_fp(mpeg, fp___0, 1);
  }
#line 78
  return (mpeg);
}
}
#line 81 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
void mpegd_close(mpeg_demux_t *mpeg ) 
{ 


  {
#line 83
  if (mpeg->close) {
    {
#line 84
    fclose(mpeg->fp);
    }
  }
#line 87
  if (mpeg->free) {
    {
#line 88
    free((void *)mpeg);
    }
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
void mpegd_reset_stats(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;

  {
#line 96
  mpeg->shdr_cnt = 0UL;
#line 97
  mpeg->pack_cnt = 0UL;
#line 98
  mpeg->packet_cnt = 0UL;
#line 99
  mpeg->end_cnt = 0UL;
#line 100
  mpeg->skip_cnt = 0UL;
#line 102
  i = 0U;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < 256U)) {
#line 102
      goto while_break;
    }
#line 103
    mpeg->streams[i].packet_cnt = 0UL;
#line 104
    mpeg->streams[i].size = 0ULL;
#line 105
    mpeg->substreams[i].packet_cnt = 0UL;
#line 106
    mpeg->substreams[i].size = 0ULL;
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_buffer_fill(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int n ;
  size_t r ;

  {
#line 116
  if (mpeg->buf_i > 0U) {
#line 116
    if (mpeg->buf_n > 0U) {
#line 117
      i = 0U;
      {
#line 117
      while (1) {
        while_continue: /* CIL Label */ ;
#line 117
        if (! (i < mpeg->buf_n)) {
#line 117
          goto while_break;
        }
#line 118
        mpeg->buf[i] = mpeg->buf[mpeg->buf_i + i];
#line 117
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 122
  mpeg->buf_i = 0U;
#line 124
  n = 4096U - mpeg->buf_n;
#line 126
  if (n > 0U) {
    {
#line 127
    r = fread((void */* __restrict  */)(mpeg->buf + mpeg->buf_n), (size_t )1, (size_t )n,
              (FILE */* __restrict  */)mpeg->fp);
    }
#line 128
    if (r < 0UL) {
#line 129
      return (1);
    }
#line 132
    mpeg->buf_n += (unsigned int )r;
  }
#line 135
  return (0);
}
}
#line 138 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_need_bits(mpeg_demux_t *mpeg , unsigned int n ) 
{ 


  {
#line 141
  n = (n + 7U) / 8U;
#line 143
  if (n > mpeg->buf_n) {
    {
#line 144
    mpegd_buffer_fill(mpeg);
    }
  }
#line 147
  if (n > mpeg->buf_n) {
#line 148
    return (1);
  }
#line 151
  return (0);
}
}
#line 154 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
unsigned long mpegd_get_bits(mpeg_demux_t *mpeg , unsigned int i , unsigned int n ) 
{ 
  unsigned long r ;
  unsigned long v ;
  unsigned long m ;
  unsigned int b_i ;
  unsigned int b_n ;
  unsigned char *buf ;
  int tmp ;

  {
  {
#line 161
  tmp = mpegd_need_bits(mpeg, i + n);
  }
#line 161
  if (tmp) {
#line 162
    return (0UL);
  }
#line 165
  buf = mpeg->buf + mpeg->buf_i;
#line 167
  r = 0UL;
#line 170
  if (((i | n) & 7U) == 0U) {
#line 171
    i /= 8U;
#line 172
    n /= 8U;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (n > 0U)) {
#line 173
        goto while_break;
      }
#line 174
      r = (r << 8) | (unsigned long )*(buf + i);
#line 175
      i ++;
#line 176
      n --;
    }
    while_break: /* CIL Label */ ;
    }
#line 178
    return (r);
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (n > 0U)) {
#line 182
      goto while_break___0;
    }
#line 183
    b_n = 8U - (i & 7U);
#line 184
    if (b_n > n) {
#line 185
      b_n = n;
    }
#line 188
    b_i = (8U - (i & 7U)) - b_n;
#line 190
    m = (unsigned long )((1 << b_n) - 1);
#line 191
    v = (unsigned long )((int )*(buf + (i >> 3)) >> b_i) & m;
#line 193
    r = (r << b_n) | v;
#line 195
    i += b_n;
#line 196
    n -= b_n;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  return (r);
}
}
#line 202 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
int mpegd_skip(mpeg_demux_t *mpeg , unsigned int n ) 
{ 
  size_t r ;

  {
#line 206
  mpeg->ofs += (unsigned long long )n;
#line 208
  if (n <= mpeg->buf_n) {
#line 209
    mpeg->buf_i += n;
#line 210
    mpeg->buf_n -= n;
#line 211
    return (0);
  }
#line 214
  n -= mpeg->buf_n;
#line 215
  mpeg->buf_i = 0U;
#line 216
  mpeg->buf_n = 0U;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (n > 0U)) {
#line 218
      goto while_break;
    }
#line 219
    if (n <= 4096U) {
      {
#line 220
      r = fread((void */* __restrict  */)(mpeg->buf), (size_t )1, (size_t )n, (FILE */* __restrict  */)mpeg->fp);
      }
    } else {
      {
#line 223
      r = fread((void */* __restrict  */)(mpeg->buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)mpeg->fp);
      }
    }
#line 226
    if (r <= 0UL) {
#line 227
      return (1);
    }
#line 230
    n -= (unsigned int )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 236 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
unsigned int mpegd_read(mpeg_demux_t *mpeg , void *buf , unsigned int n ) 
{ 
  unsigned int ret ;
  unsigned int i ;
  unsigned char *tmp ;
  size_t tmp___0 ;

  {
#line 242
  tmp = (unsigned char *)buf;
#line 244
  if (n < mpeg->buf_n) {
#line 244
    i = n;
  } else {
#line 244
    i = mpeg->buf_n;
  }
#line 246
  ret = i;
#line 248
  if (i > 0U) {
    {
#line 249
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(& mpeg->buf[mpeg->buf_i]),
           (size_t )i);
#line 251
    tmp += i;
#line 252
    mpeg->buf_i += i;
#line 253
    mpeg->buf_n -= i;
#line 254
    n -= i;
    }
  }
#line 257
  if (n > 0U) {
    {
#line 258
    tmp___0 = fread((void */* __restrict  */)tmp, (size_t )1, (size_t )n, (FILE */* __restrict  */)mpeg->fp);
#line 258
    ret = (unsigned int )((size_t )ret + tmp___0);
    }
  }
#line 261
  mpeg->ofs += (unsigned long long )ret;
#line 263
  return (ret);
}
}
#line 266 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
int mpegd_set_offset(mpeg_demux_t *mpeg , unsigned long long ofs ) 
{ 
  int tmp ;

  {
#line 268
  if (ofs == mpeg->ofs) {
#line 269
    return (0);
  }
#line 272
  if (ofs > mpeg->ofs) {
    {
#line 273
    tmp = mpegd_skip(mpeg, (unsigned int )((unsigned long )(ofs - mpeg->ofs)));
    }
#line 273
    return (tmp);
  }
#line 276
  return (1);
}
}
#line 279 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_seek_header(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    tmp___1 = mpegd_get_bits(mpeg, 0U, 24U);
    }
#line 284
    if (! (tmp___1 != 1UL)) {
#line 284
      goto while_break;
    }
#line 285
    ofs = mpeg->ofs + 1ULL;
#line 287
    if ((unsigned long )mpeg->mpeg_skip != (unsigned long )((void *)0)) {
      {
#line 288
      tmp = (*(mpeg->mpeg_skip))(mpeg);
      }
#line 288
      if (tmp) {
#line 289
        return (1);
      }
    }
    {
#line 293
    tmp___0 = mpegd_set_offset(mpeg, ofs);
    }
#line 293
    if (tmp___0) {
#line 294
      return (1);
    }
#line 297
    (mpeg->skip_cnt) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return (0);
}
}
#line 303 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_parse_system_header(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 308
  tmp = mpegd_get_bits(mpeg, 32U, 16U);
#line 308
  mpeg->shdr.size = (unsigned int )(tmp + 6UL);
#line 310
  tmp___0 = mpegd_get_bits(mpeg, 78U, 1U);
#line 310
  mpeg->shdr.fixed = (int )tmp___0;
#line 311
  tmp___1 = mpegd_get_bits(mpeg, 79U, 1U);
#line 311
  mpeg->shdr.csps = (int )tmp___1;
#line 313
  (mpeg->shdr_cnt) ++;
#line 315
  ofs = mpeg->ofs + (unsigned long long )mpeg->shdr.size;
  }
#line 317
  if ((unsigned long )mpeg->mpeg_system_header != (unsigned long )((void *)0)) {
    {
#line 318
    tmp___2 = (*(mpeg->mpeg_system_header))(mpeg);
    }
#line 318
    if (tmp___2) {
#line 319
      return (1);
    }
  }
  {
#line 323
  mpegd_set_offset(mpeg, ofs);
  }
#line 325
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_parse_packet1(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int val ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  {
#line 334
  mpeg->packet.type = 1U;
#line 336
  tmp___0 = mpegd_get_bits(mpeg, i, 2U);
  }
#line 336
  if (tmp___0 == 1UL) {
#line 337
    i += 16U;
  }
  {
#line 340
  tmp___1 = mpegd_get_bits(mpeg, i, 8U);
#line 340
  val = (unsigned int )tmp___1;
  }
#line 342
  if ((val & 240U) == 32U) {
    {
#line 343
    tmp___2 = mpegd_get_bits(mpeg, i + 4U, 3U);
#line 343
    tmp = (unsigned long long )tmp___2;
#line 344
    tmp___3 = mpegd_get_bits(mpeg, i + 8U, 15U);
#line 344
    tmp = (tmp << 15) | (unsigned long long )tmp___3;
#line 345
    tmp___4 = mpegd_get_bits(mpeg, i + 24U, 15U);
#line 345
    tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 347
    mpeg->packet.have_pts = (char)1;
#line 348
    mpeg->packet.pts = tmp;
#line 350
    i += 40U;
    }
  } else
#line 352
  if ((val & 240U) == 48U) {
    {
#line 353
    tmp___5 = mpegd_get_bits(mpeg, i + 4U, 3U);
#line 353
    tmp = (unsigned long long )tmp___5;
#line 354
    tmp___6 = mpegd_get_bits(mpeg, i + 8U, 15U);
#line 354
    tmp = (tmp << 15) | (unsigned long long )tmp___6;
#line 355
    tmp___7 = mpegd_get_bits(mpeg, i + 24U, 15U);
#line 355
    tmp = (tmp << 15) | (unsigned long long )tmp___7;
#line 357
    mpeg->packet.have_pts = (char)1;
#line 358
    mpeg->packet.pts = tmp;
#line 360
    tmp___8 = mpegd_get_bits(mpeg, i + 44U, 3U);
#line 360
    tmp = (unsigned long long )tmp___8;
#line 361
    tmp___9 = mpegd_get_bits(mpeg, i + 48U, 15U);
#line 361
    tmp = (tmp << 15) | (unsigned long long )tmp___9;
#line 362
    tmp___10 = mpegd_get_bits(mpeg, i + 64U, 15U);
#line 362
    tmp = (tmp << 15) | (unsigned long long )tmp___10;
#line 364
    mpeg->packet.have_dts = (char)1;
#line 365
    mpeg->packet.dts = tmp;
#line 367
    i += 80U;
    }
  } else
#line 369
  if (val == 15U) {
#line 370
    i += 8U;
  }
#line 373
  mpeg->packet.offset = i / 8U;
#line 375
  return (0);
}
}
#line 378 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_parse_packet2(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int pts_dts_flag ;
  unsigned int cnt ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;

  {
  {
#line 385
  mpeg->packet.type = 2U;
#line 387
  tmp___0 = mpegd_get_bits(mpeg, i + 8U, 2U);
#line 387
  pts_dts_flag = (unsigned int )tmp___0;
#line 388
  tmp___1 = mpegd_get_bits(mpeg, i + 16U, 8U);
#line 388
  cnt = (unsigned int )tmp___1;
  }
#line 390
  if (pts_dts_flag == 2U) {
    {
#line 391
    tmp___5 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
#line 391
    if (tmp___5 == 2UL) {
      {
#line 392
      tmp___2 = mpegd_get_bits(mpeg, i + 28U, 3U);
#line 392
      tmp = (unsigned long long )tmp___2;
#line 393
      tmp___3 = mpegd_get_bits(mpeg, i + 32U, 15U);
#line 393
      tmp = (tmp << 15) | (unsigned long long )tmp___3;
#line 394
      tmp___4 = mpegd_get_bits(mpeg, i + 48U, 15U);
#line 394
      tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 396
      mpeg->packet.have_pts = (char)1;
#line 397
      mpeg->packet.pts = tmp;
      }
    }
  } else
#line 400
  if ((pts_dts_flag & 3U) == 3U) {
    {
#line 401
    tmp___9 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
#line 401
    if (tmp___9 == 3UL) {
      {
#line 402
      tmp___6 = mpegd_get_bits(mpeg, i + 28U, 3U);
#line 402
      tmp = (unsigned long long )tmp___6;
#line 403
      tmp___7 = mpegd_get_bits(mpeg, i + 32U, 15U);
#line 403
      tmp = (tmp << 15) | (unsigned long long )tmp___7;
#line 404
      tmp___8 = mpegd_get_bits(mpeg, i + 48U, 15U);
#line 404
      tmp = (tmp << 15) | (unsigned long long )tmp___8;
#line 406
      mpeg->packet.have_pts = (char)1;
#line 407
      mpeg->packet.pts = tmp;
      }
    }
    {
#line 410
    tmp___13 = mpegd_get_bits(mpeg, i + 64U, 4U);
    }
#line 410
    if (tmp___13 == 1UL) {
      {
#line 411
      tmp___10 = mpegd_get_bits(mpeg, i + 68U, 3U);
#line 411
      tmp = (unsigned long long )tmp___10;
#line 412
      tmp___11 = mpegd_get_bits(mpeg, i + 72U, 15U);
#line 412
      tmp = (tmp << 15) | (unsigned long long )tmp___11;
#line 413
      tmp___12 = mpegd_get_bits(mpeg, i + 88U, 15U);
#line 413
      tmp = (tmp << 15) | (unsigned long long )tmp___12;
#line 415
      mpeg->packet.have_dts = (char)1;
#line 416
      mpeg->packet.dts = tmp;
      }
    }
  }
#line 420
  i += 8U * (cnt + 3U);
#line 422
  mpeg->packet.offset = i / 8U;
#line 424
  return (0);
}
}
#line 427 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_parse_packet(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 434
  mpeg->packet.type = 0U;
#line 436
  tmp = mpegd_get_bits(mpeg, 24U, 8U);
#line 436
  sid = (unsigned int )tmp;
#line 437
  ssid = 0U;
#line 439
  mpeg->packet.sid = sid;
#line 440
  mpeg->packet.ssid = ssid;
#line 442
  tmp___0 = mpegd_get_bits(mpeg, 32U, 16U);
#line 442
  mpeg->packet.size = (unsigned int )(tmp___0 + 6UL);
#line 443
  mpeg->packet.offset = 6U;
#line 445
  mpeg->packet.have_pts = (char)0;
#line 446
  mpeg->packet.pts = 0ULL;
#line 448
  mpeg->packet.have_dts = (char)0;
#line 449
  mpeg->packet.dts = 0ULL;
#line 451
  i = 48U;
  }
#line 453
  if (sid >= 192U) {
#line 453
    if (sid < 240U) {
#line 453
      goto _L;
    } else {
#line 453
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 453
  if (sid == 189U) {
    _L: /* CIL Label */ 
    {
#line 454
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 454
      tmp___1 = mpegd_get_bits(mpeg, i, 8U);
      }
#line 454
      if (! (tmp___1 == 255UL)) {
#line 454
        goto while_break;
      }
#line 455
      if (i > 176U) {
#line 456
        goto while_break;
      }
#line 458
      i += 8U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 461
    tmp___4 = mpegd_get_bits(mpeg, i, 2U);
    }
#line 461
    if (tmp___4 == 2UL) {
      {
#line 462
      tmp___2 = mpegd_parse_packet2(mpeg, i);
      }
#line 462
      if (tmp___2) {
#line 463
        return (1);
      }
    } else {
      {
#line 467
      tmp___3 = mpegd_parse_packet1(mpeg, i);
      }
#line 467
      if (tmp___3) {
#line 468
        return (1);
      }
    }
  } else
#line 472
  if (sid == 190U) {
#line 473
    mpeg->packet.type = 1U;
  }
#line 476
  if (sid == 189U) {
    {
#line 477
    tmp___5 = mpegd_get_bits(mpeg, 8U * mpeg->packet.offset, 8U);
#line 477
    ssid = (unsigned int )tmp___5;
#line 478
    mpeg->packet.ssid = ssid;
    }
  }
#line 481
  if ((unsigned long )mpeg->mpeg_packet_check != (unsigned long )((void *)0)) {
    {
#line 481
    tmp___8 = (*(mpeg->mpeg_packet_check))(mpeg);
    }
#line 481
    if (tmp___8) {
      {
#line 482
      tmp___6 = mpegd_skip(mpeg, 1U);
      }
#line 482
      if (tmp___6) {
#line 483
        return (1);
      }
    } else {
#line 481
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 487
    (mpeg->packet_cnt) ++;
#line 488
    (mpeg->streams[sid].packet_cnt) ++;
#line 489
    mpeg->streams[sid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
#line 491
    if (sid == 189U) {
#line 492
      (mpeg->substreams[ssid].packet_cnt) ++;
#line 493
      mpeg->substreams[ssid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
    }
#line 496
    ofs = mpeg->ofs + (unsigned long long )mpeg->packet.size;
#line 498
    if ((unsigned long )mpeg->mpeg_packet != (unsigned long )((void *)0)) {
      {
#line 499
      tmp___7 = (*(mpeg->mpeg_packet))(mpeg);
      }
#line 499
      if (tmp___7) {
#line 500
        return (1);
      }
    }
    {
#line 504
    mpegd_set_offset(mpeg, ofs);
    }
  }
#line 507
  return (0);
}
}
#line 510 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
static int mpegd_parse_pack(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;

  {
  {
#line 516
  tmp___7 = mpegd_get_bits(mpeg, 32U, 4U);
  }
#line 516
  if (tmp___7 == 2UL) {
    {
#line 517
    mpeg->pack.type = 1U;
#line 518
    tmp = mpegd_get_bits(mpeg, 36U, 3U);
#line 518
    mpeg->pack.scr = (unsigned long long )tmp;
#line 519
    tmp___0 = mpegd_get_bits(mpeg, 40U, 15U);
#line 519
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___0;
#line 520
    tmp___1 = mpegd_get_bits(mpeg, 56U, 15U);
#line 520
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___1;
#line 521
    mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 73U, 22U);
#line 522
    mpeg->pack.stuff = 0U;
#line 523
    mpeg->pack.size = 12U;
    }
  } else {
    {
#line 525
    tmp___6 = mpegd_get_bits(mpeg, 32U, 2U);
    }
#line 525
    if (tmp___6 == 1UL) {
      {
#line 526
      mpeg->pack.type = 2U;
#line 527
      tmp___2 = mpegd_get_bits(mpeg, 34U, 3U);
#line 527
      mpeg->pack.scr = (unsigned long long )tmp___2;
#line 528
      tmp___3 = mpegd_get_bits(mpeg, 38U, 15U);
#line 528
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___3;
#line 529
      tmp___4 = mpegd_get_bits(mpeg, 54U, 15U);
#line 529
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___4;
#line 530
      mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 80U, 22U);
#line 531
      tmp___5 = mpegd_get_bits(mpeg, 109U, 3U);
#line 531
      mpeg->pack.stuff = (unsigned int )tmp___5;
#line 532
      mpeg->pack.size = 14U + mpeg->pack.stuff;
      }
    } else {
#line 535
      mpeg->pack.type = 0U;
#line 536
      mpeg->pack.scr = 0ULL;
#line 537
      mpeg->pack.mux_rate = 0UL;
#line 538
      mpeg->pack.size = 4U;
    }
  }
#line 541
  ofs = mpeg->ofs + (unsigned long long )mpeg->pack.size;
#line 543
  (mpeg->pack_cnt) ++;
#line 545
  if ((unsigned long )mpeg->mpeg_pack != (unsigned long )((void *)0)) {
    {
#line 546
    tmp___8 = (*(mpeg->mpeg_pack))(mpeg);
    }
#line 546
    if (tmp___8) {
#line 547
      return (1);
    }
  }
  {
#line 551
  mpegd_set_offset(mpeg, ofs);
#line 553
  mpegd_seek_header(mpeg);
#line 555
  tmp___10 = mpegd_get_bits(mpeg, 0U, 32U);
  }
#line 555
  if (tmp___10 == 443UL) {
    {
#line 556
    tmp___9 = mpegd_parse_system_header(mpeg);
    }
#line 556
    if (tmp___9) {
#line 557
      return (1);
    }
    {
#line 560
    mpegd_seek_header(mpeg);
    }
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 563
    tmp___12 = mpegd_get_bits(mpeg, 0U, 24U);
    }
#line 563
    if (! (tmp___12 == 1UL)) {
#line 563
      goto while_break;
    }
    {
#line 564
    tmp___11 = mpegd_get_bits(mpeg, 24U, 8U);
#line 564
    sid = (unsigned int )tmp___11;
    }
#line 566
    if (sid == 186U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 185U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 187U) {
#line 567
      goto while_break;
    } else {
      {
#line 570
      mpegd_parse_packet(mpeg);
      }
    }
    {
#line 573
    mpegd_seek_header(mpeg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return (0);
}
}
#line 579 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_parse.c"
int mpegd_parse(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 584
    tmp = mpegd_seek_header(mpeg);
    }
#line 584
    if (tmp) {
#line 585
      return (0);
    }
    {
#line 588
    tmp___0 = mpegd_get_bits(mpeg, 0U, 32U);
    }
    {
#line 589
    if (tmp___0 == 442UL) {
#line 589
      goto case_442;
    }
#line 595
    if (tmp___0 == 441UL) {
#line 595
      goto case_441;
    }
#line 611
    goto switch_default;
    case_442: /* CIL Label */ 
    {
#line 590
    tmp___1 = mpegd_parse_pack(mpeg);
    }
#line 590
    if (tmp___1) {
#line 591
      return (1);
    }
#line 593
    goto switch_break;
    case_441: /* CIL Label */ 
#line 596
    (mpeg->end_cnt) ++;
#line 598
    ofs = mpeg->ofs + 4ULL;
#line 600
    if ((unsigned long )mpeg->mpeg_end != (unsigned long )((void *)0)) {
      {
#line 601
      tmp___2 = (*(mpeg->mpeg_end))(mpeg);
      }
#line 601
      if (tmp___2) {
#line 602
        return (1);
      }
    }
    {
#line 606
    tmp___3 = mpegd_set_offset(mpeg, ofs);
    }
#line 606
    if (tmp___3) {
#line 607
      return (1);
    }
#line 609
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 612
    ofs = mpeg->ofs + 1ULL;
#line 614
    if ((unsigned long )mpeg->mpeg_skip != (unsigned long )((void *)0)) {
      {
#line 615
      tmp___4 = (*(mpeg->mpeg_skip))(mpeg);
      }
#line 615
      if (tmp___4) {
#line 616
        return (1);
      }
    }
    {
#line 620
    tmp___5 = mpegd_set_offset(mpeg, ofs);
    }
#line 620
    if (tmp___5) {
#line 621
      return (0);
    }
#line 624
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return (0);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 39 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.h"
void mpeg_buf_init(mpeg_buffer_t *buf ) ;
#line 40
void mpeg_buf_free(mpeg_buffer_t *buf ) ;
#line 42
int mpeg_buf_set_max(mpeg_buffer_t *buf , unsigned int max ) ;
#line 43
int mpeg_buf_set_cnt(mpeg_buffer_t *buf , unsigned int cnt ) ;
#line 45
int mpeg_buf_write(mpeg_buffer_t *buf , FILE *fp___0 ) ;
#line 30 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
void mpeg_buf_init(mpeg_buffer_t *buf ) 
{ 


  {
#line 32
  buf->buf = (unsigned char *)((void *)0);
#line 33
  buf->max = 0U;
#line 34
  buf->cnt = 0U;
#line 35
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
void mpeg_buf_free(mpeg_buffer_t *buf ) 
{ 


  {
  {
#line 39
  free((void *)buf->buf);
#line 41
  buf->buf = (unsigned char *)((void *)0);
#line 42
  buf->cnt = 0U;
#line 43
  buf->max = 0U;
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
void mpeg_buf_clear(mpeg_buffer_t *buf ) 
{ 


  {
#line 48
  buf->cnt = 0U;
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
int mpeg_buf_set_max(mpeg_buffer_t *buf , unsigned int max ) 
{ 
  void *tmp ;

  {
#line 53
  if (buf->max == max) {
#line 54
    return (0);
  }
#line 57
  if (max == 0U) {
    {
#line 58
    free((void *)buf->buf);
#line 59
    buf->max = 0U;
#line 60
    buf->cnt = 0U;
    }
#line 61
    return (0);
  }
  {
#line 64
  tmp = realloc((void *)buf->buf, (size_t )max);
#line 64
  buf->buf = (unsigned char *)tmp;
  }
#line 65
  if ((unsigned long )buf->buf == (unsigned long )((void *)0)) {
#line 66
    buf->max = 0U;
#line 67
    buf->cnt = 0U;
#line 68
    return (1);
  }
#line 71
  buf->max = max;
#line 73
  if (buf->cnt > max) {
#line 74
    buf->cnt = max;
  }
#line 77
  return (0);
}
}
#line 80 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
int mpeg_buf_set_cnt(mpeg_buffer_t *buf , unsigned int cnt ) 
{ 
  int tmp ;

  {
#line 82
  if (cnt > buf->max) {
    {
#line 83
    tmp = mpeg_buf_set_max(buf, cnt);
    }
#line 83
    if (tmp) {
#line 84
      return (1);
    }
  }
#line 88
  buf->cnt = cnt;
#line 90
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
int mpeg_buf_read(mpeg_buffer_t *buf , mpeg_demux_t *mpeg , unsigned int cnt ) 
{ 
  int tmp ;

  {
  {
#line 95
  tmp = mpeg_buf_set_cnt(buf, cnt);
  }
#line 95
  if (tmp) {
#line 96
    return (1);
  }
  {
#line 99
  buf->cnt = mpegd_read(mpeg, (void *)buf->buf, cnt);
  }
#line 101
  if (buf->cnt != cnt) {
#line 102
    return (1);
  }
#line 105
  return (0);
}
}
#line 108 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
int mpeg_buf_write(mpeg_buffer_t *buf , FILE *fp___0 ) 
{ 
  size_t tmp ;

  {
#line 110
  if (buf->cnt > 0U) {
    {
#line 111
    tmp = fwrite((void const   */* __restrict  */)buf->buf, (size_t )1, (size_t )buf->cnt,
                 (FILE */* __restrict  */)fp___0);
    }
#line 111
    if (tmp != (size_t )buf->cnt) {
#line 112
      return (1);
    }
  }
#line 116
  return (0);
}
}
#line 119 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/buffer.c"
int mpeg_buf_write_clear(mpeg_buffer_t *buf , FILE *fp___0 ) 
{ 
  size_t tmp ;

  {
#line 121
  if (buf->cnt > 0U) {
    {
#line 122
    tmp = fwrite((void const   */* __restrict  */)buf->buf, (size_t )1, (size_t )buf->cnt,
                 (FILE */* __restrict  */)fp___0);
    }
#line 122
    if (tmp != (size_t )buf->cnt) {
#line 123
      buf->cnt = 0U;
#line 124
      return (1);
    }
  }
#line 128
  buf->cnt = 0U;
#line 130
  return (0);
}
}
#line 30 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.h"
int mpeg_remux(FILE *inp , FILE *out ) ;
#line 50 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_stream_map[256] ;
#line 51
unsigned char par_substream_map[256] ;
#line 57
int par_empty_pack ;
#line 58
int par_remux_skipped ;
#line 59
int par_split ;
#line 40 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static mpeg_buffer_t shdr  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 41 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static mpeg_buffer_t pack  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 42 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static mpeg_buffer_t packet___0  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static unsigned int sequence  =    0U;
#line 47 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_next_fp(mpeg_demux_t *mpeg ) 
{ 
  char *fname ;
  FILE *fp___0 ;

  {
#line 53
  fp___0 = (FILE *)mpeg->ext;
#line 54
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    {
#line 55
    fclose(fp___0);
#line 56
    mpeg->ext = (void *)0;
    }
  }
  {
#line 59
  fname = mpeg_get_name((char const   *)par_demux_name, sequence);
  }
#line 60
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 61
    return (1);
  }
  {
#line 64
  sequence ++;
#line 66
  fp___0 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"wb");
#line 68
  free((void *)fname);
  }
#line 70
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 71
    return (1);
  }
#line 74
  mpeg->ext = (void *)fp___0;
#line 76
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_skip(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;

  {
#line 82
  if (par_remux_skipped == 0) {
#line 83
    return (0);
  }
  {
#line 86
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 1U);
  }
#line 86
  if (tmp) {
#line 87
    return (1);
  }
#line 90
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_system_header(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if (par_no_shdr) {
#line 96
    if (mpeg->shdr_cnt > 1UL) {
#line 97
      return (0);
    }
  }
  {
#line 100
  tmp = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
  }
#line 100
  if (tmp) {
#line 101
    return (1);
  }
  {
#line 104
  tmp___0 = mpeg_buf_read(& shdr, mpeg, mpeg->shdr.size);
  }
#line 104
  if (tmp___0) {
#line 105
    return (1);
  }
  {
#line 108
  tmp___1 = mpeg_buf_write_clear(& shdr, (FILE *)mpeg->ext);
  }
#line 108
  if (tmp___1) {
#line 109
    return (1);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_packet(mpeg_demux_t *mpeg ) 
{ 
  int r ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 121
  sid = mpeg->packet.sid;
#line 122
  ssid = mpeg->packet.ssid;
#line 124
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
#line 124
  if (tmp) {
#line 125
    return (0);
  }
  {
#line 128
  r = 0;
#line 130
  tmp___0 = mpeg_buf_read(& packet___0, mpeg, mpeg->packet.size);
  }
#line 130
  if (tmp___0) {
    {
#line 131
    prt_msg("remux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet___0.cnt,
            mpeg->packet.size);
    }
#line 135
    if (par_drop) {
      {
#line 136
      mpeg_buf_clear(& packet___0);
      }
#line 137
      return (1);
    }
#line 140
    r = 1;
  }
#line 143
  if (packet___0.cnt >= 4U) {
#line 144
    *(packet___0.buf + 3) = par_stream_map[sid];
#line 146
    if (sid == 189U) {
#line 146
      if (packet___0.cnt > mpeg->packet.offset) {
#line 147
        *(packet___0.buf + mpeg->packet.offset) = par_substream_map[ssid];
      }
    }
  }
  {
#line 151
  tmp___1 = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
  }
#line 151
  if (tmp___1) {
#line 152
    return (1);
  }
  {
#line 155
  tmp___2 = mpeg_buf_write_clear(& packet___0, (FILE *)mpeg->ext);
  }
#line 155
  if (tmp___2) {
#line 156
    return (1);
  }
#line 159
  return (r);
}
}
#line 162 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_pack(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  tmp = mpeg_buf_read(& pack, mpeg, mpeg->pack.size);
  }
#line 165
  if (tmp) {
#line 166
    return (1);
  }
#line 169
  if (par_empty_pack) {
    {
#line 170
    tmp___0 = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
    }
#line 170
    if (tmp___0) {
#line 171
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
static int mpeg_remux_end(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 181
  if (par_no_end) {
#line 182
    return (0);
  }
  {
#line 185
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 4U);
  }
#line 185
  if (tmp) {
#line 186
    return (1);
  }
#line 189
  if (par_split) {
    {
#line 190
    tmp___0 = mpeg_remux_next_fp(mpeg);
    }
#line 190
    if (tmp___0) {
#line 191
      return (1);
    }
  }
#line 195
  return (0);
}
}
#line 198 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_remux.c"
int mpeg_remux(FILE *inp , FILE *out ) 
{ 
  int r ;
  mpeg_demux_t *mpeg ;
  int tmp ;
  unsigned char buf[4] ;
  size_t tmp___0 ;

  {
  {
#line 203
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
#line 204
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 205
    return (1);
  }
#line 208
  if (par_split) {
    {
#line 209
    mpeg->ext = (void *)0;
#line 210
    sequence = 0U;
#line 212
    tmp = mpeg_remux_next_fp(mpeg);
    }
#line 212
    if (tmp) {
#line 213
      return (1);
    }
  } else {
#line 217
    mpeg->ext = (void *)out;
  }
  {
#line 220
  mpeg->mpeg_skip = & mpeg_remux_skip;
#line 221
  mpeg->mpeg_system_header = & mpeg_remux_system_header;
#line 222
  mpeg->mpeg_pack = & mpeg_remux_pack;
#line 223
  mpeg->mpeg_packet = & mpeg_remux_packet;
#line 224
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 225
  mpeg->mpeg_end = & mpeg_remux_end;
#line 227
  mpeg_buf_init(& shdr);
#line 228
  mpeg_buf_init(& pack);
#line 229
  mpeg_buf_init(& packet___0);
#line 231
  r = mpegd_parse(mpeg);
  }
#line 233
  if (par_no_end) {
    {
#line 236
    buf[0] = (unsigned char )((441 >> 24) & 255);
#line 237
    buf[1] = (unsigned char )((441 >> 16) & 255);
#line 238
    buf[2] = (unsigned char )((441 >> 8) & 255);
#line 239
    buf[3] = (unsigned char)185;
#line 241
    tmp___0 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                     (FILE */* __restrict  */)((FILE *)mpeg->ext));
    }
#line 241
    if (tmp___0 != 4UL) {
#line 242
      r = 1;
    }
  }
#line 246
  if (par_split) {
    {
#line 247
    fclose((FILE *)mpeg->ext);
#line 248
    mpeg->ext = (void *)0;
    }
  }
  {
#line 251
  mpegd_close(mpeg);
#line 253
  mpeg_buf_free(& shdr);
#line 254
  mpeg_buf_free(& pack);
#line 255
  mpeg_buf_free(& packet___0);
  }
#line 257
  return (r);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.h"
void mpegd_getopt_help(char const   *tag , char const   *usage , mpegd_option_t *opt ) ;
#line 43
int mpegd_getopt(int argc , char **argv , char ***optarg , mpegd_option_t *opt ) ;
#line 31 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static int opt_cmp(mpegd_option_t const   *opt1 , mpegd_option_t const   *opt2 ) 
{ 
  int c1 ;
  int c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 36
  if ((int const   )opt1->name1 <= 255) {
    {
#line 36
    tmp = tolower((int )opt1->name1);
#line 36
    c1 = tmp;
    }
  } else {
#line 36
    c1 = (int )opt1->name1;
  }
#line 37
  if ((int const   )opt2->name1 <= 255) {
    {
#line 37
    tmp___0 = tolower((int )opt2->name1);
#line 37
    c2 = tmp___0;
    }
  } else {
#line 37
    c2 = (int )opt2->name1;
  }
#line 39
  if (c1 < c2) {
#line 40
    return (-1);
  } else
#line 42
  if (c1 > c2) {
#line 43
    return (1);
  } else
#line 45
  if ((int const   )opt1->name1 < (int const   )opt2->name1) {
#line 46
    return (1);
  } else
#line 48
  if ((int const   )opt1->name1 > (int const   )opt2->name1) {
#line 49
    return (-1);
  }
#line 52
  return (0);
}
}
#line 55 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static unsigned int opt_get_width(mpegd_option_t const   *opt ) 
{ 
  unsigned int n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 60
  if ((unsigned long )opt->optdesc == (unsigned long )((void *)0)) {
#line 61
    return (0U);
  }
#line 64
  n = 0U;
#line 66
  if ((int const   )opt->name1 <= 255) {
#line 67
    n += 2U;
#line 69
    if ((unsigned long )opt->name2 != (unsigned long )((void *)0)) {
#line 70
      n += 2U;
    }
  }
#line 74
  if ((unsigned long )opt->name2 != (unsigned long )((void *)0)) {
    {
#line 75
    tmp = strlen((char const   *)opt->name2);
#line 75
    n = (unsigned int )((size_t )n + (2UL + tmp));
    }
  }
#line 78
  if ((unsigned long )opt->argdesc != (unsigned long )((void *)0)) {
    {
#line 79
    tmp___0 = strlen((char const   *)opt->argdesc);
#line 79
    n = (unsigned int )((size_t )n + (1UL + tmp___0));
    }
  }
#line 82
  return (n);
}
}
#line 85 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static unsigned int opt_max_width(mpegd_option_t const   *opt ) 
{ 
  unsigned int i ;
  unsigned int n ;
  unsigned int w ;

  {
#line 90
  w = 0U;
#line 92
  i = 0U;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((int const   )(opt + i)->name1 >= 0)) {
#line 93
      goto while_break;
    }
    {
#line 94
    n = opt_get_width(opt + i);
    }
#line 96
    if (n > w) {
#line 97
      w = n;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (w);
}
}
#line 106 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static void sort_options(mpegd_option_t *opt ) 
{ 
  unsigned int i ;
  unsigned int j ;
  mpegd_option_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 112
  if ((int )(opt + 0)->name1 < 0) {
#line 113
    return;
  }
#line 116
  i = 1U;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((int )(opt + i)->name1 >= 0)) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp___0 = opt_cmp((mpegd_option_t const   *)(opt + i), (mpegd_option_t const   *)(opt + (i - 1U)));
    }
#line 118
    if (tmp___0 >= 0) {
#line 119
      i ++;
#line 120
      goto while_continue;
    }
#line 123
    j = i - 1U;
#line 125
    tmp = *(opt + i);
#line 126
    *(opt + i) = *(opt + j);
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (j > 0U) {
        {
#line 128
        tmp___1 = opt_cmp((mpegd_option_t const   *)(& tmp), (mpegd_option_t const   *)(opt + (j - 1U)));
        }
#line 128
        if (! (tmp___1 < 0)) {
#line 128
          goto while_break___0;
        }
      } else {
#line 128
        goto while_break___0;
      }
#line 129
      *(opt + j) = *(opt + (j - 1U));
#line 130
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    *(opt + j) = tmp;
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static void print_option(mpegd_option_t const   *opt , unsigned int w ) 
{ 
  unsigned int n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 144
  n = 0U;
#line 146
  if ((int const   )opt->name1 <= 255) {
    {
#line 147
    printf((char const   */* __restrict  */)"  -%c", (int const   )opt->name1);
#line 148
    n += 2U;
    }
#line 150
    if ((unsigned long )opt->name2 != (unsigned long )((void *)0)) {
      {
#line 151
      printf((char const   */* __restrict  */)", ");
#line 152
      n += 2U;
      }
    }
  } else {
    {
#line 156
    printf((char const   */* __restrict  */)"  ");
    }
  }
#line 159
  if ((unsigned long )opt->name2 != (unsigned long )((void *)0)) {
    {
#line 160
    printf((char const   */* __restrict  */)"--%s", opt->name2);
#line 161
    tmp = strlen((char const   *)opt->name2);
#line 161
    n = (unsigned int )((size_t )n + (2UL + tmp));
    }
  }
#line 164
  if ((unsigned long )opt->argdesc != (unsigned long )((void *)0)) {
    {
#line 165
    printf((char const   */* __restrict  */)" %s", opt->argdesc);
#line 166
    tmp___0 = strlen((char const   *)opt->argdesc);
#line 166
    n = (unsigned int )((size_t )n + (1UL + tmp___0));
    }
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (n < w)) {
#line 169
      goto while_break;
    }
    {
#line 170
    fputc(' ', stdout);
#line 171
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  printf((char const   */* __restrict  */)"%s\n", opt->optdesc);
  }
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
void mpegd_getopt_help(char const   *tag , char const   *usage , mpegd_option_t *opt ) 
{ 
  unsigned int w ;

  {
  {
#line 181
  sort_options(opt);
#line 183
  w = opt_max_width((mpegd_option_t const   *)opt);
  }
#line 185
  if ((unsigned long )tag != (unsigned long )((void *)0)) {
    {
#line 186
    printf((char const   */* __restrict  */)"%s\n\n", tag);
    }
  }
#line 189
  if ((unsigned long )usage != (unsigned long )((void *)0)) {
    {
#line 190
    printf((char const   */* __restrict  */)"%s\n", usage);
    }
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((int )opt->name1 >= 0)) {
#line 193
      goto while_break;
    }
    {
#line 194
    print_option((mpegd_option_t const   *)opt, w + 2U);
#line 195
    opt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static mpegd_option_t *find_option_name1(mpegd_option_t *opt , int name1 ) 
{ 


  {
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((int )opt->name1 >= 0)) {
#line 202
      goto while_break;
    }
#line 203
    if ((int )opt->name1 == name1) {
#line 204
      return (opt);
    }
#line 207
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return ((mpegd_option_t *)((void *)0));
}
}
#line 213 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static mpegd_option_t *find_option_name2(mpegd_option_t *opt , char const   *name2 ) 
{ 
  int tmp ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! ((int )opt->name1 >= 0)) {
#line 216
      goto while_break;
    }
    {
#line 217
    tmp = strcmp(opt->name2, name2);
    }
#line 217
    if (tmp == 0) {
#line 218
      return (opt);
    }
#line 221
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((mpegd_option_t *)((void *)0));
}
}
#line 230 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static int atend  =    0;
#line 231 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static int index1  =    -1;
#line 232 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static int index2  =    -1;
#line 233 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
static char const   *curopt  =    (char const   *)((void *)0);
#line 227 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/getopt.c"
int mpegd_getopt(int argc , char **argv , char ***optarg , mpegd_option_t *opt ) 
{ 
  mpegd_option_t *ret ;

  {
#line 235
  if (index1 < 0) {
#line 236
    atend = 0;
#line 237
    index1 = 0;
#line 238
    index2 = 1;
#line 239
    curopt = (char const   *)((void *)0);
  }
#line 242
  if (atend) {
#line 243
    if (index2 >= argc) {
#line 244
      return (-1);
    }
#line 247
    index1 = index2;
#line 248
    index2 ++;
#line 250
    *optarg = argv + index1;
#line 252
    return (0);
  }
#line 255
  if ((unsigned long )curopt == (unsigned long )((void *)0)) {
#line 255
    goto _L;
  } else
#line 255
  if ((int const   )*curopt == 0) {
    _L: /* CIL Label */ 
#line 256
    if (index2 >= argc) {
#line 257
      return (-1);
    }
#line 260
    index1 = index2;
#line 261
    index2 ++;
#line 263
    curopt = (char const   *)*(argv + index1);
#line 265
    if ((int const   )*(curopt + 0) != 45) {
#line 266
      *optarg = argv + index1;
#line 267
      curopt = (char const   *)((void *)0);
#line 268
      return (0);
    } else
#line 265
    if ((int const   )*(curopt + 1) == 0) {
#line 266
      *optarg = argv + index1;
#line 267
      curopt = (char const   *)((void *)0);
#line 268
      return (0);
    }
#line 271
    if ((int const   )*(curopt + 1) == 45) {
#line 272
      if ((int const   )*(curopt + 2) == 0) {
#line 273
        atend = 1;
#line 275
        if (index2 >= argc) {
#line 276
          return (-1);
        }
#line 279
        index1 = index2;
#line 280
        index2 ++;
#line 282
        *optarg = argv + index1;
#line 284
        return (0);
      }
      {
#line 287
      ret = find_option_name2(opt, curopt + 2);
      }
#line 289
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
        {
#line 290
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown option (%s)\n",
                *(argv + 0), curopt);
        }
#line 293
        return (-2);
      }
#line 296
      if (index2 + (int )ret->argcnt > argc) {
        {
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing option argument (%s)\n",
                *(argv + 0), curopt);
        }
#line 301
        return (-3);
      }
#line 304
      *optarg = argv + index2;
#line 305
      index2 += (int )ret->argcnt;
#line 306
      curopt = (char const   *)((void *)0);
#line 308
      return ((int )ret->name1);
    }
#line 311
    curopt ++;
  }
  {
#line 314
  ret = find_option_name1(opt, (int )*curopt);
  }
#line 316
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown option (-%c)\n",
            *(argv + 0), (int const   )*curopt);
    }
#line 320
    return (-2);
  }
#line 323
  if (index2 + (int )ret->argcnt > argc) {
    {
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing option argument (-%c)\n",
            *(argv + 0), (int const   )*curopt);
    }
#line 328
    return (-3);
  }
#line 331
  *optarg = argv + index2;
#line 332
  index2 += (int )ret->argcnt;
#line 333
  curopt ++;
#line 335
  return ((int )ret->name1);
}
}
#line 30 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.h"
int mpeg_scan(FILE *inp , FILE *out ) ;
#line 62 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
int par_first_pts ;
#line 35 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static unsigned long long pts1[256]  ;
#line 36 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static unsigned long long pts2[256]  ;
#line 39 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static int mpeg_scan_system_header(mpeg_demux_t *mpeg ) 
{ 


  {
#line 42
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static int mpeg_scan_packet(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;
  int skip ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 53
  sid = mpeg->packet.sid;
#line 54
  ssid = mpeg->packet.ssid;
#line 56
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
#line 56
  if (tmp) {
#line 57
    return (0);
  }
  {
#line 60
  fp___0 = (FILE *)mpeg->ext;
#line 62
  ofs = mpeg->ofs;
#line 64
  tmp___0 = mpegd_set_offset(mpeg, ofs + (unsigned long long )mpeg->packet.size);
  }
#line 64
  if (tmp___0) {
    {
#line 65
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: sid=%02x ssid=%02x incomplete packet\n",
            (uintmax_t )ofs, sid, ssid);
    }
  }
#line 71
  skip = 0;
#line 73
  if (sid == 189U) {
#line 74
    if (mpeg->substreams[ssid].packet_cnt > 1UL) {
#line 75
      if (! par_first_pts) {
#line 76
        return (0);
      }
#line 79
      if (! mpeg->packet.have_pts) {
#line 80
        return (0);
      }
#line 83
      if (mpeg->packet.pts >= pts2[ssid]) {
#line 84
        return (0);
      }
    }
#line 88
    if (mpeg->packet.pts < pts2[ssid]) {
#line 89
      pts2[ssid] = mpeg->packet.pts;
    }
  } else {
#line 93
    if (mpeg->streams[sid].packet_cnt > 1UL) {
#line 94
      if (! par_first_pts) {
#line 95
        return (0);
      }
#line 98
      if (! mpeg->packet.have_pts) {
#line 99
        return (0);
      }
#line 102
      if (mpeg->packet.pts >= pts1[sid]) {
#line 103
        return (0);
      }
    }
#line 107
    if (mpeg->packet.pts < pts1[sid]) {
#line 108
      pts1[sid] = mpeg->packet.pts;
    }
  }
  {
#line 112
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: sid=%02x",
          (uintmax_t )ofs, sid);
  }
#line 114
  if (sid == 189U) {
    {
#line 115
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
  } else {
    {
#line 118
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___0);
    }
  }
#line 121
  if (mpeg->packet.type == 1U) {
    {
#line 122
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___0);
    }
  } else
#line 124
  if (mpeg->packet.type == 2U) {
    {
#line 125
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___0);
    }
  } else {
    {
#line 128
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___0);
    }
  }
#line 131
  if (mpeg->packet.have_pts) {
    {
#line 132
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" pts=%lu[%.4f]",
            (uintmax_t )mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0);
    }
  }
  {
#line 138
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___0);
#line 140
  fflush(fp___0);
  }
#line 142
  return (0);
}
}
#line 145 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static int mpeg_scan_pack(mpeg_demux_t *mpeg ) 
{ 


  {
#line 148
  return (0);
}
}
#line 151 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
static int mpeg_scan_end(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___0 ;

  {
#line 156
  fp___0 = (FILE *)mpeg->ext;
#line 158
  if (! par_no_end) {
    {
#line 159
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%08lx: end code\n",
            (uintmax_t )mpeg->ofs);
    }
  }
#line 164
  return (0);
}
}
#line 167 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpeg_scan.c"
int mpeg_scan(FILE *inp , FILE *out ) 
{ 
  int r ;
  unsigned int i ;
  mpeg_demux_t *mpeg ;

  {
#line 173
  i = 0U;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < 256U)) {
#line 173
      goto while_break;
    }
#line 174
    pts1[i] = ~ 0ULL;
#line 175
    pts2[i] = ~ 0ULL;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
#line 179
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 180
    return (1);
  }
  {
#line 183
  mpeg->ext = (void *)out;
#line 185
  mpeg->mpeg_system_header = & mpeg_scan_system_header;
#line 186
  mpeg->mpeg_pack = & mpeg_scan_pack;
#line 187
  mpeg->mpeg_packet = & mpeg_scan_packet;
#line 188
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 189
  mpeg->mpeg_end = & mpeg_scan_end;
#line 191
  r = mpegd_parse(mpeg);
#line 193
  mpeg_print_stats(mpeg, out);
#line 195
  mpegd_close(mpeg);
  }
#line 197
  return (r);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 48 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_stream[256]  ;
#line 49 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_substream[256]  ;
#line 50 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_stream_map[256]  ;
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.h"
unsigned char par_substream_map[256]  ;
#line 61
int par_scan ;
#line 40 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static unsigned int par_mode  =    0U;
#line 42 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static FILE *par_inp  =    (FILE *)((void *)0);
#line 43 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static FILE *par_out  =    (FILE *)((void *)0);
#line 51 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_no_shdr  =    0;
#line 52 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_no_pack  =    0;
#line 53 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_no_packet  =    0;
#line 54 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_no_end  =    0;
#line 55 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_empty_pack  =    0;
#line 56 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_remux_skipped  =    0;
#line 57 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_split  =    0;
#line 58 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_drop  =    1;
#line 59 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_scan  =    0;
#line 60 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_first_pts  =    0;
#line 61 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_dvdac3  =    0;
#line 62 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int par_dvdsub  =    0;
#line 63 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
char *par_demux_name  =    (char *)((void *)0);
#line 64 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
unsigned int par_packet_max  =    0U;
#line 67 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static mpegd_option_t opts[25]  = 
#line 67
  {      {(short )'?', (unsigned short)0, "help", (char const   *)((void *)0), "Print usage information"}, 
        {(short )'a',
      (unsigned short)0, "ac3", (char const   *)((void *)0), "Assume DVD AC3 headers in private streams"}, 
        {(short )'b',
      (unsigned short)1, "base-name", "name", "Set the base name for demuxed streams"}, 
        {(short )'c',
      (unsigned short)0, "scan", (char const   *)((void *)0), "Scan the stream [default]"}, 
        {(short )'d',
      (unsigned short)0, "demux", (char const   *)((void *)0), "Demultiplex streams"}, 
        {(short )'D',
      (unsigned short)0, "no-drop", (char const   *)((void *)0), "Don\'t drop incomplete packets"}, 
        {(short )'e',
      (unsigned short)0, "no-end", (char const   *)((void *)0), "Don\'t list end codes [no]"}, 
        {(short )'E',
      (unsigned short)0, "empty-packs", (char const   *)((void *)0), "Remux empty packs [no]"}, 
        {(short )'F',
      (unsigned short)0, "first-pts", (char const   *)((void *)0), "Print packet with lowest PTS [no]"}, 
        {(short )'h',
      (unsigned short)0, "no-system-headers", (char const   *)((void *)0), "Don\'t list system headers"}, 
        {(short )'i',
      (unsigned short)1, "invalid", "id", "Select invalid streams [none]"}, 
        {(short )'k', (unsigned short)0, "no-packs", (char const   *)((void *)0), "Don\'t list packs"}, 
        {(short )'K',
      (unsigned short)0, "remux-skipped", (char const   *)((void *)0), "Copy skipped bytes when remuxing [no]"}, 
        {(short )'l',
      (unsigned short)0, "list", (char const   *)((void *)0), "List the stream contents"}, 
        {(short )'m',
      (unsigned short)1, "packet-max-size", "int", "Set the maximum packet size [0]"}, 
        {(short )'p',
      (unsigned short)1, "substream", "id", "Select substreams [none]"}, 
        {(short )'P', (unsigned short)2, "substream-map", "id1 id2", "Remap substream id1 to id2"}, 
        {(short )'r',
      (unsigned short)0, "remux", (char const   *)((void *)0), "Copy modified input to output"}, 
        {(short )'s',
      (unsigned short)1, "stream", "id", "Select streams [none]"}, 
        {(short )'S', (unsigned short)2, "stream-map", "id1 id2", "Remap stream id1 to id2"}, 
        {(short )'t',
      (unsigned short)0, "no-packets", (char const   *)((void *)0), "Don\'t list packets"}, 
        {(short )'u',
      (unsigned short)0, "spu", (char const   *)((void *)0), "Assume DVD subtitles in private streams"}, 
        {(short )'V',
      (unsigned short)0, "version", (char const   *)((void *)0), "Print version information"}, 
        {(short )'x',
      (unsigned short)0, "split", (char const   *)((void *)0), "Split sequences while remuxing [no]"}, 
        {(short)-1,
      (unsigned short)0, (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 96 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static void print_help(void) 
{ 


  {
  {
#line 99
  mpegd_getopt_help("mpegdemux: demultiplex MPEG1/2 system streams", "usage: mpegdemux [options] [input [output]]",
                    opts);
#line 105
  fflush(stdout);
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static void print_version(void) 
{ 


  {
  {
#line 111
  fputs((char const   */* __restrict  */)"mpegdemux version 0.1.4\n\nCopyright (C) 2003-2010 Hampa Hug <hampa@hampa.ch>\n",
        (FILE */* __restrict  */)stdout);
  }
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static char *str_clone(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 124
  tmp = strlen(str);
#line 124
  tmp___0 = malloc(tmp + 1UL);
#line 124
  ret = (char *)tmp___0;
  }
#line 125
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 126
    return ((char *)((void *)0));
  }
  {
#line 129
  strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
#line 131
  return (ret);
}
}
#line 134 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static char const   *str_skip_white(char const   *str ) 
{ 


  {
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((int const   )*str == 32)) {
#line 137
      if (! ((int const   )*str == 9)) {
#line 137
        goto while_break;
      }
    }
#line 138
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return (str);
}
}
#line 144 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
static int str_get_streams(char const   *str , unsigned char *stm , unsigned int msk ) 
{ 
  unsigned int i ;
  int incl ;
  char *tmp ;
  unsigned int stm1 ;
  unsigned int stm2 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 152
  incl = 1;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((int const   )*str != 0)) {
#line 154
      goto while_break;
    }
    {
#line 155
    str = str_skip_white(str);
    }
#line 157
    if ((int const   )*str == 43) {
#line 158
      str ++;
#line 159
      incl = 1;
    } else
#line 161
    if ((int const   )*str == 45) {
#line 162
      str ++;
#line 163
      incl = 0;
    } else {
#line 166
      incl = 1;
    }
    {
#line 169
    tmp___3 = strncmp(str, "all", (size_t )3);
    }
#line 169
    if (tmp___3 == 0) {
#line 170
      str += 3;
#line 171
      stm1 = 0U;
#line 172
      stm2 = 255U;
    } else {
      {
#line 174
      tmp___2 = strncmp(str, "none", (size_t )4);
      }
#line 174
      if (tmp___2 == 0) {
#line 175
        str += 4;
#line 176
        stm1 = 0U;
#line 177
        stm2 = 255U;
#line 178
        incl = ! incl;
      } else {
        {
#line 181
        tmp___0 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                          0);
#line 181
        stm1 = (unsigned int )tmp___0;
        }
#line 182
        if ((unsigned long )tmp == (unsigned long )str) {
#line 183
          return (1);
        }
#line 186
        str = (char const   *)tmp;
#line 188
        if ((int const   )*str == 45) {
          {
#line 189
          str ++;
#line 190
          tmp___1 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                            0);
#line 190
          stm2 = (unsigned int )tmp___1;
          }
#line 191
          if ((unsigned long )tmp == (unsigned long )str) {
#line 192
            return (1);
          }
#line 194
          str = (char const   *)tmp;
        } else {
#line 197
          stm2 = stm1;
        }
      }
    }
#line 201
    if (incl) {
#line 202
      i = stm1;
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 202
        if (! (i <= stm2)) {
#line 202
          goto while_break___0;
        }
#line 203
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) | msk);
#line 202
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 207
      i = stm1;
      {
#line 207
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 207
        if (! (i <= stm2)) {
#line 207
          goto while_break___1;
        }
#line 208
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) & ~ msk);
#line 207
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 212
    str = str_skip_white(str);
    }
#line 214
    if ((int const   )*str == 47) {
#line 215
      str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (0);
}
}
#line 222 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
char *mpeg_get_name(char const   *base , unsigned int sid ) 
{ 
  unsigned int n ;
  unsigned int dig ;
  char *ret ;
  void *tmp ;

  {
#line 228
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 229
    base = "stream_##.dat";
  }
#line 232
  n = 0U;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((int const   )*(base + n) != 0)) {
#line 233
      goto while_break;
    }
#line 234
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  n ++;
#line 239
  tmp = malloc((size_t )n);
#line 239
  ret = (char *)tmp;
  }
#line 240
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 241
    return ((char *)((void *)0));
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! (n > 0U)) {
#line 244
      goto while_break___0;
    }
#line 245
    n --;
#line 246
    *(ret + n) = (char )*(base + n);
#line 248
    if ((int )*(ret + n) == 35) {
#line 249
      dig = sid % 16U;
#line 250
      sid /= 16U;
#line 251
      if (dig < 10U) {
#line 252
        *(ret + n) = (char )(48U + dig);
      } else {
#line 255
        *(ret + n) = (char )((97U + dig) - 10U);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  return (ret);
}
}
#line 263 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int mpeg_stream_excl(unsigned char sid , unsigned char ssid ) 
{ 


  {
#line 265
  if (((int )par_stream[sid] & 1) == 0) {
#line 266
    return (1);
  }
#line 269
  if ((int )sid == 189) {
#line 270
    if (((int )par_substream[ssid] & 1) == 0) {
#line 271
      return (1);
    }
  }
#line 275
  return (0);
}
}
#line 279 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int mpeg_packet_check(mpeg_demux_t *mpeg ) 
{ 


  {
#line 281
  if (par_packet_max > 0U) {
#line 281
    if (mpeg->packet.size > par_packet_max) {
#line 282
      return (1);
    }
  }
#line 285
  if ((int )par_stream[mpeg->packet.sid] & 2) {
#line 286
    return (1);
  }
#line 289
  return (0);
}
}
#line 292 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
void mpeg_print_stats(mpeg_demux_t *mpeg , FILE *fp___0 ) 
{ 
  unsigned int i ;

  {
  {
#line 296
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"System headers: %lu\nPacks:          %lu\nPackets:        %lu\nEnd codes:      %lu\nSkipped:        %lu bytes\n",
          mpeg->shdr_cnt, mpeg->pack_cnt, mpeg->packet_cnt, mpeg->end_cnt, mpeg->skip_cnt);
#line 306
  i = 0U;
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < 256U)) {
#line 306
      goto while_break;
    }
#line 307
    if (mpeg->streams[i].packet_cnt > 0UL) {
      {
#line 308
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Stream %02x:      %lu packets / %lu bytes\n",
              i, mpeg->streams[i].packet_cnt, (uintmax_t )mpeg->streams[i].size);
      }
    }
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  i = 0U;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (i < 256U)) {
#line 317
      goto while_break___0;
    }
#line 318
    if (mpeg->substreams[i].packet_cnt > 0UL) {
      {
#line 319
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Substream %02x:   %lu packets / %lu bytes\n",
              i, mpeg->substreams[i].packet_cnt, (uintmax_t )mpeg->substreams[i].size);
      }
    }
#line 317
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 328
  fflush(fp___0);
  }
#line 329
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int mpeg_copy(mpeg_demux_t *mpeg , FILE *fp___0 , unsigned int n ) 
{ 
  unsigned char buf[4096] ;
  unsigned int i ;
  unsigned int j ;
  size_t tmp ;

  {
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (n > 0U)) {
#line 336
      goto while_break;
    }
#line 337
    if (n < 4096U) {
#line 337
      i = n;
    } else {
#line 337
      i = 4096U;
    }
    {
#line 339
    j = mpegd_read(mpeg, (void *)(buf), i);
    }
#line 341
    if (j > 0U) {
      {
#line 342
      tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )j,
                   (FILE */* __restrict  */)fp___0);
      }
#line 342
      if (tmp != (size_t )j) {
#line 343
        return (1);
      }
    }
#line 347
    if (i != j) {
#line 348
      return (1);
    }
#line 351
    n -= i;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  return (0);
}
}
#line 357 "/home/wheatley/newnew/temp/mpegdemux-0.1.4/src/mpegdemux.c"
int main(int argc , char **argv ) 
{ 
  unsigned int i ;
  int r ;
  unsigned int id1 ;
  unsigned int id2 ;
  char **optarg ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 364
  i = 0U;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < 256U)) {
#line 364
      goto while_break;
    }
#line 365
    par_stream[i] = (unsigned char)0;
#line 366
    par_substream[i] = (unsigned char)0;
#line 367
    par_stream_map[i] = (unsigned char )i;
#line 368
    par_substream_map[i] = (unsigned char )i;
#line 364
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 372
    r = mpegd_getopt(argc, argv, & optarg, opts);
    }
#line 374
    if (r == -1) {
#line 375
      goto while_break___0;
    }
#line 378
    if (r < 0) {
#line 379
      return (1);
    }
    {
#line 383
    if (r == 63) {
#line 383
      goto case_63;
    }
#line 387
    if (r == 97) {
#line 387
      goto case_97;
    }
#line 391
    if (r == 98) {
#line 391
      goto case_98;
    }
#line 398
    if (r == 99) {
#line 398
      goto case_99;
    }
#line 407
    if (r == 100) {
#line 407
      goto case_100;
    }
#line 411
    if (r == 68) {
#line 411
      goto case_68;
    }
#line 415
    if (r == 101) {
#line 415
      goto case_101;
    }
#line 419
    if (r == 69) {
#line 419
      goto case_69;
    }
#line 423
    if (r == 70) {
#line 423
      goto case_70;
    }
#line 427
    if (r == 104) {
#line 427
      goto case_104;
    }
#line 431
    if (r == 105) {
#line 431
      goto case_105;
    }
#line 450
    if (r == 107) {
#line 450
      goto case_107;
    }
#line 454
    if (r == 75) {
#line 454
      goto case_75;
    }
#line 458
    if (r == 108) {
#line 458
      goto case_108;
    }
#line 462
    if (r == 109) {
#line 462
      goto case_109;
    }
#line 466
    if (r == 112) {
#line 466
      goto case_112;
    }
#line 473
    if (r == 80) {
#line 473
      goto case_80;
    }
#line 479
    if (r == 114) {
#line 479
      goto case_114;
    }
#line 483
    if (r == 115) {
#line 483
      goto case_115;
    }
#line 490
    if (r == 83) {
#line 490
      goto case_83;
    }
#line 496
    if (r == 116) {
#line 496
      goto case_116;
    }
#line 500
    if (r == 117) {
#line 500
      goto case_117;
    }
#line 504
    if (r == 86) {
#line 504
      goto case_86;
    }
#line 508
    if (r == 120) {
#line 508
      goto case_120;
    }
#line 512
    if (r == 0) {
#line 512
      goto case_0;
    }
#line 551
    goto switch_default;
    case_63: /* CIL Label */ 
    {
#line 384
    print_help();
    }
#line 385
    return (0);
    case_97: /* CIL Label */ 
#line 388
    par_dvdac3 = 1;
#line 389
    goto switch_break;
    case_98: /* CIL Label */ 
#line 392
    if ((unsigned long )par_demux_name != (unsigned long )((void *)0)) {
      {
#line 393
      free((void *)par_demux_name);
      }
    }
    {
#line 395
    par_demux_name = str_clone((char const   *)*(optarg + 0));
    }
#line 396
    goto switch_break;
    case_99: /* CIL Label */ 
#line 399
    par_mode = 0U;
#line 401
    i = 0U;
    {
#line 401
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 401
      if (! (i < 256U)) {
#line 401
        goto while_break___1;
      }
#line 402
      par_stream[i] = (unsigned char )((int )par_stream[i] | 1);
#line 403
      par_substream[i] = (unsigned char )((int )par_substream[i] | 1);
#line 401
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 405
    goto switch_break;
    case_100: /* CIL Label */ 
#line 408
    par_mode = 3U;
#line 409
    goto switch_break;
    case_68: /* CIL Label */ 
#line 412
    par_drop = 0;
#line 413
    goto switch_break;
    case_101: /* CIL Label */ 
#line 416
    par_no_end = 1;
#line 417
    goto switch_break;
    case_69: /* CIL Label */ 
#line 420
    par_empty_pack = 1;
#line 421
    goto switch_break;
    case_70: /* CIL Label */ 
#line 424
    par_first_pts = 1;
#line 425
    goto switch_break;
    case_104: /* CIL Label */ 
#line 428
    par_no_shdr = 1;
#line 429
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 432
    tmp___0 = strcmp((char const   *)*(optarg + 0), "-");
    }
#line 432
    if (tmp___0 == 0) {
#line 433
      i = 0U;
      {
#line 433
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 433
        if (! (i < 256U)) {
#line 433
          goto while_break___2;
        }
#line 434
        if ((int )par_stream[i] & 1) {
#line 435
          par_stream[i] = (unsigned char )((int )par_stream[i] & -3);
        } else {
#line 438
          par_stream[i] = (unsigned char )((int )par_stream[i] | 2);
        }
#line 433
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 443
      tmp = str_get_streams((char const   *)*(optarg + 0), (unsigned char *)(par_stream),
                            2U);
      }
#line 443
      if (tmp) {
        {
#line 444
        prt_err("%s: bad stream id (%s)\n", *(argv + 0), *(optarg + 0));
        }
#line 445
        return (1);
      }
    }
#line 448
    goto switch_break;
    case_107: /* CIL Label */ 
#line 451
    par_no_pack = 1;
#line 452
    goto switch_break;
    case_75: /* CIL Label */ 
#line 455
    par_remux_skipped = 1;
#line 456
    goto switch_break;
    case_108: /* CIL Label */ 
#line 459
    par_mode = 1U;
#line 460
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 463
    tmp___1 = strtoul((char const   */* __restrict  */)*(optarg + 0), (char **/* __restrict  */)((void *)0),
                      0);
#line 463
    par_packet_max = (unsigned int )tmp___1;
    }
#line 464
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 467
    tmp___2 = str_get_streams((char const   *)*(optarg + 0), (unsigned char *)(par_substream),
                              1U);
    }
#line 467
    if (tmp___2) {
      {
#line 468
      prt_err("%s: bad substream id (%s)\n", *(argv + 0), *(optarg + 0));
      }
#line 469
      return (1);
    }
#line 471
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 474
    tmp___3 = strtoul((char const   */* __restrict  */)*(optarg + 0), (char **/* __restrict  */)((void *)0),
                      0);
#line 474
    id1 = (unsigned int )tmp___3;
#line 475
    tmp___4 = strtoul((char const   */* __restrict  */)*(optarg + 1), (char **/* __restrict  */)((void *)0),
                      0);
#line 475
    id2 = (unsigned int )tmp___4;
#line 476
    par_substream_map[id1 & 255U] = (unsigned char )(id2 & 255U);
    }
#line 477
    goto switch_break;
    case_114: /* CIL Label */ 
#line 480
    par_mode = 2U;
#line 481
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 484
    tmp___5 = str_get_streams((char const   *)*(optarg + 0), (unsigned char *)(par_stream),
                              1U);
    }
#line 484
    if (tmp___5) {
      {
#line 485
      prt_err("%s: bad stream id (%s)\n", *(argv + 0), *(optarg + 0));
      }
#line 486
      return (1);
    }
#line 488
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 491
    tmp___6 = strtoul((char const   */* __restrict  */)*(optarg + 0), (char **/* __restrict  */)((void *)0),
                      0);
#line 491
    id1 = (unsigned int )tmp___6;
#line 492
    tmp___7 = strtoul((char const   */* __restrict  */)*(optarg + 1), (char **/* __restrict  */)((void *)0),
                      0);
#line 492
    id2 = (unsigned int )tmp___7;
#line 493
    par_stream_map[id1 & 255U] = (unsigned char )(id2 & 255U);
    }
#line 494
    goto switch_break;
    case_116: /* CIL Label */ 
#line 497
    par_no_packet = 1;
#line 498
    goto switch_break;
    case_117: /* CIL Label */ 
#line 501
    par_dvdsub = 1;
#line 502
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 505
    print_version();
    }
#line 506
    return (0);
    case_120: /* CIL Label */ 
#line 509
    par_split = 1;
#line 510
    goto switch_break;
    case_0: /* CIL Label */ 
#line 513
    if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
      {
#line 514
      tmp___8 = strcmp((char const   *)*(optarg + 0), "-");
      }
#line 514
      if (tmp___8 == 0) {
#line 515
        par_inp = stdin;
      } else {
        {
#line 518
        par_inp = fopen((char const   */* __restrict  */)*(optarg + 0), (char const   */* __restrict  */)"rb");
        }
      }
#line 520
      if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
        {
#line 521
        prt_err("%s: can\'t open input file (%s)\n", *(argv + 0), *(optarg + 0));
        }
#line 525
        return (1);
      }
    } else
#line 528
    if ((unsigned long )par_out == (unsigned long )((void *)0)) {
      {
#line 529
      tmp___9 = strcmp((char const   *)*(optarg + 0), "-");
      }
#line 529
      if (tmp___9 == 0) {
#line 530
        par_out = stdout;
      } else {
        {
#line 533
        par_out = fopen((char const   */* __restrict  */)*(optarg + 0), (char const   */* __restrict  */)"wb");
        }
      }
#line 535
      if ((unsigned long )par_out == (unsigned long )((void *)0)) {
        {
#line 536
        prt_err("%s: can\'t open output file (%s)\n", *(argv + 0), *(optarg + 0));
        }
#line 540
        return (1);
      }
    } else {
      {
#line 544
      prt_err("%s: too many files (%s)\n", *(argv + 0), *(optarg + 0));
      }
#line 547
      return (1);
    }
#line 549
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 552
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 556
  if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
#line 557
    par_inp = stdin;
  }
#line 560
  if ((unsigned long )par_out == (unsigned long )((void *)0)) {
#line 561
    par_out = stdout;
  }
  {
#line 565
  if (par_mode == 0U) {
#line 565
    goto case_0___0;
  }
#line 569
  if (par_mode == 1U) {
#line 569
    goto case_1;
  }
#line 573
  if (par_mode == 2U) {
#line 573
    goto case_2;
  }
#line 577
  if (par_mode == 3U) {
#line 577
    goto case_3;
  }
#line 581
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 566
  r = mpeg_scan(par_inp, par_out);
  }
#line 567
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 570
  r = mpeg_list(par_inp, par_out);
  }
#line 571
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 574
  r = mpeg_remux(par_inp, par_out);
  }
#line 575
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 578
  r = mpeg_demux(par_inp, par_out);
  }
#line 579
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 582
  r = 1;
#line 583
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 586
  if (r) {
#line 587
    return (1);
  }
#line 590
  return (0);
}
}
