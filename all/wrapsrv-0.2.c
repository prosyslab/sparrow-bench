/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 98 "/usr/include/arpa/nameser.h"
enum __ns_sect {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4
} ;
#line 98 "/usr/include/arpa/nameser.h"
typedef enum __ns_sect ns_sect;
#line 114 "/usr/include/arpa/nameser.h"
struct __ns_msg {
   u_char const   *_msg ;
   u_char const   *_eom ;
   u_int16_t _id ;
   u_int16_t _flags ;
   u_int16_t _counts[4] ;
   u_char const   *_sections[4] ;
   ns_sect _sect ;
   int _rrnum ;
   u_char const   *_msg_ptr ;
};
#line 114 "/usr/include/arpa/nameser.h"
typedef struct __ns_msg ns_msg;
#line 138 "/usr/include/arpa/nameser.h"
struct __ns_rr {
   char name[1025] ;
   u_int16_t type ;
   u_int16_t rr_class ;
   u_int32_t ttl ;
   u_int16_t rdlength ;
   u_char const   *rdata ;
};
#line 138 "/usr/include/arpa/nameser.h"
typedef struct __ns_rr ns_rr;
#line 252
enum __ns_type {
    ns_t_invalid = 0,
    ns_t_a = 1,
    ns_t_ns = 2,
    ns_t_md = 3,
    ns_t_mf = 4,
    ns_t_cname = 5,
    ns_t_soa = 6,
    ns_t_mb = 7,
    ns_t_mg = 8,
    ns_t_mr = 9,
    ns_t_null = 10,
    ns_t_wks = 11,
    ns_t_ptr = 12,
    ns_t_hinfo = 13,
    ns_t_minfo = 14,
    ns_t_mx = 15,
    ns_t_txt = 16,
    ns_t_rp = 17,
    ns_t_afsdb = 18,
    ns_t_x25 = 19,
    ns_t_isdn = 20,
    ns_t_rt = 21,
    ns_t_nsap = 22,
    ns_t_nsap_ptr = 23,
    ns_t_sig = 24,
    ns_t_key = 25,
    ns_t_px = 26,
    ns_t_gpos = 27,
    ns_t_aaaa = 28,
    ns_t_loc = 29,
    ns_t_nxt = 30,
    ns_t_eid = 31,
    ns_t_nimloc = 32,
    ns_t_srv = 33,
    ns_t_atma = 34,
    ns_t_naptr = 35,
    ns_t_kx = 36,
    ns_t_cert = 37,
    ns_t_a6 = 38,
    ns_t_dname = 39,
    ns_t_sink = 40,
    ns_t_opt = 41,
    ns_t_apl = 42,
    ns_t_tkey = 249,
    ns_t_tsig = 250,
    ns_t_ixfr = 251,
    ns_t_axfr = 252,
    ns_t_mailb = 253,
    ns_t_maila = 254,
    ns_t_any = 255,
    ns_t_zxfr = 256,
    ns_t_max = 65536
} ;
#line 252 "/usr/include/arpa/nameser.h"
typedef enum __ns_type ns_type;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct __anonstruct_link_61 {
   struct srv *prev ;
   struct srv *next ;
};
#line 42 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct srv {
   struct __anonstruct_link_61 link ;
   char *tname ;
   uint16_t weight ;
   uint16_t port ;
};
#line 49 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct __anonstruct_link_62 {
   struct srv_prio *prev ;
   struct srv_prio *next ;
};
#line 49 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct __anonstruct_srv_list_63 {
   struct srv *head ;
   struct srv *tail ;
};
#line 49 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct srv_prio {
   struct __anonstruct_link_62 link ;
   struct __anonstruct_srv_list_63 srv_list ;
   uint16_t prio ;
};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
struct __anonstruct_srv_prio_list_65 {
   struct srv_prio *head ;
   struct srv_prio *tail ;
};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
typedef struct __anonstruct_srv_prio_list_65 srv_prio_list;
#line 337 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 472 "/usr/include/arpa/nameser.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_msg_getflag)(ns_msg  ,
                                                                                     int  ) ;
#line 477
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_initparse)(u_char const   * ,
                                                                                   int  ,
                                                                                   ns_msg * ) ;
#line 480
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_parserr)(ns_msg * ,
                                                                                 ns_sect  ,
                                                                                 int  ,
                                                                                 ns_rr * ) ;
#line 492
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_name_ntop)(u_char const   * ,
                                                                                   char * ,
                                                                                   size_t  ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 277
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_query)(char const   * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  u_char * ,
                                                                                  int  ) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static srv_prio_list prio_list  ;
#line 64
static char *subst_cmd(struct srv *se , char const   *cmd ) ;
#line 65
static char *target_name(unsigned char const   *target ) ;
#line 66
static int do_cmd(struct srv *se , int argc , char **argv ) ;
#line 67
static struct srv *next_tuple(void) ;
#line 68
static void free_tuples(void) ;
#line 69
static void insert_tuple(char *tname , uint16_t prio , uint16_t weight , uint16_t port ) ;
#line 70
static void parse_answer_section(ns_msg *msg ) ;
#line 71
static void usage(void) ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static struct srv *next_tuple(void) 
{ 
  struct srv_prio *pe ;
  struct srv *se ;
  uint16_t rnd ;
  unsigned int csum ;
  unsigned int wsum ;
  long tmp ;
  struct srv *tmp___0 ;

  {
#line 84
  csum = 0U;
#line 85
  wsum = 0U;
#line 87
  pe = prio_list.head;
#line 88
  if ((unsigned long )pe == (unsigned long )((void *)0)) {
#line 89
    return ((struct srv *)((void *)0));
  }
#line 91
  se = pe->srv_list.head;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )se != (unsigned long )((void *)0))) {
#line 91
      goto while_break;
    }
#line 95
    wsum += (unsigned int )se->weight;
#line 91
    se = se->link.next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  tmp = random();
#line 98
  rnd = (uint16_t )(tmp % (long )(wsum + 1U));
#line 100
  se = pe->srv_list.head;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )se != (unsigned long )((void *)0))) {
#line 100
      goto while_break___0;
    }
#line 104
    csum += (unsigned int )se->weight;
#line 106
    if (csum >= (unsigned int )rnd) {
      {
#line 107
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 107
        if (! ((unsigned long )((void *)se->link.prev) != (unsigned long )((void *)-1))) {
          {
#line 107
          __assert_fail("((void *)((se)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                        107U, "next_tuple");
          }
        }
        {
#line 107
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if ((unsigned long )se->link.next != (unsigned long )((void *)0)) {
#line 107
            (se->link.next)->link.prev = se->link.prev;
          } else {
#line 107
            if (! ((unsigned long )pe->srv_list.tail == (unsigned long )se)) {
              {
#line 107
              __assert_fail("(pe->srv_list).tail == (se)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                            107U, "next_tuple");
              }
            }
#line 107
            pe->srv_list.tail = se->link.prev;
          }
#line 107
          if ((unsigned long )se->link.prev != (unsigned long )((void *)0)) {
#line 107
            (se->link.prev)->link.next = se->link.next;
          } else {
#line 107
            if (! ((unsigned long )pe->srv_list.head == (unsigned long )se)) {
              {
#line 107
              __assert_fail("(pe->srv_list).head == (se)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                            107U, "next_tuple");
              }
            }
#line 107
            pe->srv_list.head = se->link.next;
          }
#line 107
          se->link.prev = (struct srv *)((void *)-1);
#line 107
          se->link.next = (struct srv *)((void *)-1);
#line 107
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 107
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 108
      goto while_break___0;
    }
#line 100
    se = se->link.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  if ((unsigned long )se == (unsigned long )((void *)0)) {
    {
#line 113
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 113
      if (! ((unsigned long )((void *)pe->link.prev) != (unsigned long )((void *)-1))) {
        {
#line 113
        __assert_fail("((void *)((pe)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                      113U, "next_tuple");
        }
      }
      {
#line 113
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 113
        if ((unsigned long )pe->link.next != (unsigned long )((void *)0)) {
#line 113
          (pe->link.next)->link.prev = pe->link.prev;
        } else {
#line 113
          if (! ((unsigned long )prio_list.tail == (unsigned long )pe)) {
            {
#line 113
            __assert_fail("(prio_list).tail == (pe)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          113U, "next_tuple");
            }
          }
#line 113
          prio_list.tail = pe->link.prev;
        }
#line 113
        if ((unsigned long )pe->link.prev != (unsigned long )((void *)0)) {
#line 113
          (pe->link.prev)->link.next = pe->link.next;
        } else {
#line 113
          if (! ((unsigned long )prio_list.head == (unsigned long )pe)) {
            {
#line 113
            __assert_fail("(prio_list).head == (pe)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          113U, "next_tuple");
            }
          }
#line 113
          prio_list.head = pe->link.next;
        }
#line 113
        pe->link.prev = (struct srv_prio *)((void *)-1);
#line 113
        pe->link.next = (struct srv_prio *)((void *)-1);
#line 113
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 113
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 114
    free((void *)pe);
#line 115
    tmp___0 = next_tuple();
    }
#line 115
    return (tmp___0);
  }
#line 123
  return (se);
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static void free_tuples(void) 
{ 
  struct srv_prio *pe ;
  struct srv_prio *pe_next ;
  struct srv *se ;
  struct srv *se_next ;

  {
#line 131
  pe = prio_list.head;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )pe != (unsigned long )((void *)0))) {
#line 132
      goto while_break;
    }
#line 133
    pe_next = pe->link.next;
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )((void *)pe->link.prev) != (unsigned long )((void *)-1))) {
        {
#line 134
        __assert_fail("((void *)((pe)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                      134U, "free_tuples");
        }
      }
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 134
        if ((unsigned long )pe->link.next != (unsigned long )((void *)0)) {
#line 134
          (pe->link.next)->link.prev = pe->link.prev;
        } else {
#line 134
          if (! ((unsigned long )prio_list.tail == (unsigned long )pe)) {
            {
#line 134
            __assert_fail("(prio_list).tail == (pe)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          134U, "free_tuples");
            }
          }
#line 134
          prio_list.tail = pe->link.prev;
        }
#line 134
        if ((unsigned long )pe->link.prev != (unsigned long )((void *)0)) {
#line 134
          (pe->link.prev)->link.next = pe->link.next;
        } else {
#line 134
          if (! ((unsigned long )prio_list.head == (unsigned long )pe)) {
            {
#line 134
            __assert_fail("(prio_list).head == (pe)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          134U, "free_tuples");
            }
          }
#line 134
          prio_list.head = pe->link.next;
        }
#line 134
        pe->link.prev = (struct srv_prio *)((void *)-1);
#line 134
        pe->link.next = (struct srv_prio *)((void *)-1);
#line 134
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 134
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    se = pe->srv_list.head;
    {
#line 137
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 137
      if (! ((unsigned long )se != (unsigned long )((void *)0))) {
#line 137
        goto while_break___2;
      }
#line 138
      se_next = se->link.next;
      {
#line 139
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 139
        if (! ((unsigned long )((void *)se->link.prev) != (unsigned long )((void *)-1))) {
          {
#line 139
          __assert_fail("((void *)((se)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                        139U, "free_tuples");
          }
        }
        {
#line 139
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 139
          if ((unsigned long )se->link.next != (unsigned long )((void *)0)) {
#line 139
            (se->link.next)->link.prev = se->link.prev;
          } else {
#line 139
            if (! ((unsigned long )pe->srv_list.tail == (unsigned long )se)) {
              {
#line 139
              __assert_fail("(pe->srv_list).tail == (se)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                            139U, "free_tuples");
              }
            }
#line 139
            pe->srv_list.tail = se->link.prev;
          }
#line 139
          if ((unsigned long )se->link.prev != (unsigned long )((void *)0)) {
#line 139
            (se->link.prev)->link.next = se->link.next;
          } else {
#line 139
            if (! ((unsigned long )pe->srv_list.head == (unsigned long )se)) {
              {
#line 139
              __assert_fail("(pe->srv_list).head == (se)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                            139U, "free_tuples");
              }
            }
#line 139
            pe->srv_list.head = se->link.next;
          }
#line 139
          se->link.prev = (struct srv *)((void *)-1);
#line 139
          se->link.next = (struct srv *)((void *)-1);
#line 139
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 139
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 140
      free((void *)se->tname);
#line 141
      free((void *)se);
#line 142
      se = se_next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 145
    free((void *)pe);
#line 146
    pe = pe_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static void insert_tuple(char *tname , uint16_t prio , uint16_t weight , uint16_t port ) 
{ 
  struct srv_prio *pe ;
  struct srv *se ;
  struct srv_prio *piter ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 155
  pe = prio_list.head;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )pe != (unsigned long )((void *)0))) {
#line 155
      goto while_break;
    }
#line 159
    if ((int )pe->prio == (int )prio) {
#line 160
      goto while_break;
    }
#line 155
    pe = pe->link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if ((unsigned long )pe == (unsigned long )((void *)0)) {
    {
#line 166
    tmp = malloc(sizeof(*pe));
#line 166
    pe = (struct srv_prio *)tmp;
    }
#line 167
    if (! ((unsigned long )pe != (unsigned long )((void *)0))) {
      {
#line 167
      __assert_fail("pe != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                    167U, "insert_tuple");
      }
    }
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      pe->link.prev = (struct srv_prio *)((void *)-1);
#line 169
      pe->link.next = (struct srv_prio *)((void *)-1);
#line 169
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 170
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 170
      pe->srv_list.head = (struct srv *)((void *)0);
#line 170
      pe->srv_list.tail = (struct srv *)((void *)0);
#line 170
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    pe->prio = prio;
#line 173
    piter = prio_list.head;
    {
#line 173
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 173
      if (! ((unsigned long )piter != (unsigned long )((void *)0))) {
#line 173
        goto while_break___2;
      }
#line 177
      if (! ((int )piter->prio != (int )prio)) {
        {
#line 177
        __assert_fail("piter->prio != prio", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                      177U, "insert_tuple");
        }
      }
#line 179
      if ((int )piter->prio > (int )prio) {
        {
#line 180
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 180
          if (! ((unsigned long )((void *)piter->link.prev) != (unsigned long )((void *)-1))) {
            {
#line 180
            __assert_fail("((void *)((piter)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          180U, "insert_tuple");
            }
          }
#line 180
          if (! (! ((unsigned long )((void *)pe->link.prev) != (unsigned long )((void *)-1)))) {
            {
#line 180
            __assert_fail("!((void *)((pe)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                          180U, "insert_tuple");
            }
          }
          {
#line 180
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 180
            if ((unsigned long )piter->link.prev == (unsigned long )((void *)0)) {
              {
#line 180
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 180
                if (! (! ((unsigned long )((void *)pe->link.prev) != (unsigned long )((void *)-1)))) {
                  {
#line 180
                  __assert_fail("!((void *)((pe)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                                180U, "insert_tuple");
                  }
                }
                {
#line 180
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 180
                  if ((unsigned long )prio_list.head != (unsigned long )((void *)0)) {
#line 180
                    (prio_list.head)->link.prev = pe;
                  } else {
#line 180
                    prio_list.tail = pe;
                  }
#line 180
                  pe->link.prev = (struct srv_prio *)((void *)0);
#line 180
                  pe->link.next = prio_list.head;
#line 180
                  prio_list.head = pe;
#line 180
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 180
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
            } else {
#line 180
              pe->link.prev = piter->link.prev;
#line 180
              piter->link.prev = pe;
#line 180
              (pe->link.prev)->link.next = pe;
#line 180
              pe->link.next = piter;
            }
#line 180
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 180
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 181
        goto while_break___2;
      }
#line 173
      piter = piter->link.next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 185
    if ((unsigned long )piter == (unsigned long )((void *)0)) {
      {
#line 186
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 186
        if (! (! ((unsigned long )((void *)pe->link.prev) != (unsigned long )((void *)-1)))) {
          {
#line 186
          __assert_fail("!((void *)((pe)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                        186U, "insert_tuple");
          }
        }
        {
#line 186
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 186
          if ((unsigned long )prio_list.tail != (unsigned long )((void *)0)) {
#line 186
            (prio_list.tail)->link.next = pe;
          } else {
#line 186
            prio_list.head = pe;
          }
#line 186
          pe->link.prev = prio_list.tail;
#line 186
          pe->link.next = (struct srv_prio *)((void *)0);
#line 186
          prio_list.tail = pe;
#line 186
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 186
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 189
  tmp___0 = malloc(sizeof(*se));
#line 189
  se = (struct srv *)tmp___0;
  }
#line 190
  if (! ((unsigned long )se != (unsigned long )((void *)0))) {
    {
#line 190
    __assert_fail("se != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                  190U, "insert_tuple");
    }
  }
  {
#line 192
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 192
    se->link.prev = (struct srv *)((void *)-1);
#line 192
    se->link.next = (struct srv *)((void *)-1);
#line 192
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 193
  se->tname = tname;
#line 194
  se->weight = weight;
#line 195
  se->port = port;
  {
#line 197
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 197
    if (! (! ((unsigned long )((void *)se->link.prev) != (unsigned long )((void *)-1)))) {
      {
#line 197
      __assert_fail("!((void *)((se)->link.prev) != (void *)(-1))", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                    197U, "insert_tuple");
      }
    }
    {
#line 197
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 197
      if ((unsigned long )pe->srv_list.tail != (unsigned long )((void *)0)) {
#line 197
        (pe->srv_list.tail)->link.next = se;
      } else {
#line 197
        pe->srv_list.head = se;
      }
#line 197
      se->link.prev = pe->srv_list.tail;
#line 197
      se->link.next = (struct srv *)((void *)0);
#line 197
      pe->srv_list.tail = se;
#line 197
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 197
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static char *target_name(unsigned char const   *target ) 
{ 
  char buf[1025] ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 226
  tmp = ns_name_ntop(target, buf, sizeof(buf));
  }
#line 226
  if (tmp == -1) {
    {
#line 227
    perror("ns_name_ntop");
#line 228
    exit(1);
    }
  }
  {
#line 230
  tmp___0 = strdup((char const   *)(buf));
  }
#line 230
  return (tmp___0);
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static void parse_answer_section(ns_msg *msg ) 
{ 
  int rrnum ;
  int rrmax ;
  ns_rr rr ;
  uint16_t prio ;
  uint16_t weight ;
  uint16_t port ;
  uint16_t len ;
  unsigned char const   *rdata ;
  char *tname ;
  int tmp ;
  u_char const   *t_cp ;
  u_char const   *t_cp___0 ;
  u_char const   *t_cp___1 ;

  {
#line 241
  rrmax = (int )msg->_counts[1];
#line 242
  rrnum = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (rrnum < rrmax)) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp = ns_parserr(msg, (ns_sect )1, rrnum, & rr);
    }
#line 243
    if (tmp) {
      {
#line 244
      perror("ns_parserr");
#line 245
      exit(1);
      }
    }
#line 247
    if ((unsigned int )((ns_type )((int )rr.type)) == 33U) {
#line 248
      len = (uint16_t )((int )rr.rdlength);
#line 249
      rdata = rr.rdata + 0;
#line 250
      if ((unsigned int )len > 6U) {
        {
#line 251
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 251
          t_cp = rdata;
#line 251
          prio = (uint16_t )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 251
          rdata += 2;
#line 251
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 252
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 252
          t_cp___0 = rdata;
#line 252
          weight = (uint16_t )(((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1)));
#line 252
          rdata += 2;
#line 252
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 253
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 253
          t_cp___1 = rdata;
#line 253
          port = (uint16_t )(((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1)));
#line 253
          rdata += 2;
#line 253
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 254
        len = (uint16_t )((unsigned int )len - 6U);
#line 255
        tname = target_name(rdata);
#line 256
        insert_tuple(tname, prio, weight, port);
        }
      }
    }
#line 242
    rrnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static char *subst_cmd(struct srv *se , char const   *cmd ) 
{ 
  char *q ;
  char *str ;
  char const   *p ;
  int ch ;
  int n_host ;
  int n_port ;
  size_t bufsz ;
  size_t len_tname ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 265
  p = cmd;
#line 267
  n_host = 0;
#line 268
  n_port = 0;
#line 272
  len_tname = strlen((char const   *)se->tname);
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    tmp = p;
#line 274
    p ++;
#line 274
    ch = (int )*tmp;
#line 274
    if (! (ch != 0)) {
#line 274
      goto while_break;
    }
#line 275
    if (ch == 37) {
#line 275
      if ((int const   )*p == 104) {
#line 276
        n_host ++;
      }
    }
#line 277
    if (ch == 37) {
#line 277
      if ((int const   )*p == 112) {
#line 278
        n_port ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  tmp___0 = strlen(cmd);
#line 281
  bufsz = tmp___0 + 1UL;
#line 282
  bufsz -= (size_t )(2 * (n_host + n_port));
#line 283
  bufsz += (size_t )(5 * n_port);
#line 284
  tmp___1 = strlen((char const   *)se->tname);
#line 284
  bufsz += (tmp___1 + 1UL) * (size_t )n_host;
#line 286
  tmp___2 = calloc((size_t )1, bufsz);
#line 286
  str = (char *)tmp___2;
  }
#line 287
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 287
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                  287U, "subst_cmd");
    }
  }
#line 289
  p = cmd;
#line 290
  q = str;
  {
#line 291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 291
    tmp___5 = p;
#line 291
    p ++;
#line 291
    ch = (int )*tmp___5;
#line 291
    if (! (ch != 0)) {
#line 291
      goto while_break___0;
    }
#line 292
    if (ch == 37) {
#line 292
      if ((int const   )*p == 104) {
        {
#line 293
        strcpy((char */* __restrict  */)q, (char const   */* __restrict  */)se->tname);
#line 294
        q += len_tname;
#line 295
        p ++;
        }
      } else {
#line 292
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 296
    if (ch == 37) {
#line 296
      if ((int const   )*p == 112) {
        {
#line 297
        tmp___3 = sprintf((char */* __restrict  */)q, (char const   */* __restrict  */)"%hu",
                          (int )se->port);
#line 297
        q += tmp___3;
#line 298
        p ++;
        }
      } else {
#line 300
        tmp___4 = q;
#line 300
        q ++;
#line 300
        *tmp___4 = (char )ch;
      }
    } else {
#line 300
      tmp___4 = q;
#line 300
      q ++;
#line 300
      *tmp___4 = (char )ch;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  return (str);
}
}
#line 307 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static int do_cmd(struct srv *se , int argc , char **argv ) 
{ 
  char *cmd ;
  char *scmd ;
  char *p ;
  int i ;
  int rc ;
  size_t bufsz ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  union __anonunion_66 __constr_expr_0 ;

  {
#line 311
  bufsz = (size_t )2;
#line 313
  i = 2;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i < argc)) {
#line 313
      goto while_break;
    }
    {
#line 314
    bufsz ++;
#line 315
    tmp = strlen((char const   *)*(argv + i));
#line 315
    bufsz += tmp;
#line 313
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  tmp___0 = malloc(bufsz);
#line 318
  cmd = (char *)tmp___0;
#line 318
  p = cmd;
  }
#line 319
  if (! ((unsigned long )cmd != (unsigned long )((void *)0))) {
    {
#line 319
    __assert_fail("cmd != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c",
                  319U, "do_cmd");
    }
  }
#line 321
  i = 2;
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (i < argc)) {
#line 321
      goto while_break___0;
    }
    {
#line 322
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)*(argv + i));
#line 323
    tmp___1 = strlen((char const   *)*(argv + i));
#line 323
    p += tmp___1;
    }
#line 324
    if (i != argc - 1) {
#line 325
      tmp___2 = p;
#line 325
      p ++;
#line 325
      *tmp___2 = (char )' ';
    }
#line 321
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 329
  scmd = subst_cmd(se, (char const   *)cmd);
#line 330
  free((void *)cmd);
#line 336
  rc = system((char const   *)scmd);
#line 337
  __constr_expr_0.__in = rc;
#line 337
  rc = (__constr_expr_0.__i & 65280) >> 8;
#line 339
  free((void *)scmd);
#line 340
  free((void *)se->tname);
#line 341
  free((void *)se);
  }
#line 346
  return (rc);
}
}
#line 349 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
static void usage(void) 
{ 


  {
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: wrapsrv <SRVNAME> <COMMAND> [OPTION]...\n");
#line 352
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%%h and %%p sequences will be converted to hostname and port.\n");
#line 354
  exit(1);
  }
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/wrapsrv-0.2/wrapsrv.c"
int main(int argc , char **argv ) 
{ 
  char *qname ;
  ns_msg msg ;
  int len ;
  int rc ;
  unsigned char answer[65535] ;
  unsigned int rcode ;
  struct srv *se ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 361
  rc = 0;
#line 366
  if (argc < 3) {
    {
#line 367
    usage();
    }
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    prio_list.head = (struct srv_prio *)((void *)0);
#line 369
    prio_list.tail = (struct srv_prio *)((void *)0);
#line 369
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  tmp = time((time_t *)((void *)0));
#line 371
  srandom((unsigned int )tmp);
#line 373
  __res_init();
#line 375
  qname = *(argv + 1);
#line 377
  len = __res_query((char const   *)qname, 1, 33, answer, (int )sizeof(answer));
  }
#line 378
  if (len < 0) {
    {
#line 379
    herror("res_query");
    }
#line 380
    return (1);
  }
  {
#line 383
  tmp___0 = ns_initparse((u_char const   *)(answer), len, & msg);
  }
#line 383
  if (tmp___0 < 0) {
    {
#line 384
    perror("ns_initparse");
    }
#line 385
    return (1);
  }
  {
#line 388
  tmp___1 = ns_msg_getflag(msg, 9);
#line 388
  rcode = (unsigned int )tmp___1;
  }
#line 389
  if (rcode != 0U) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wrapsrv: query for %s returned rcode %u\n",
            qname, rcode);
    }
#line 392
    return (1);
  }
#line 395
  if ((int )msg._counts[1] == 0) {
    {
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wrapsrv: query for %s returned no answers\n",
            qname);
    }
#line 398
    return (1);
  }
  {
#line 401
  parse_answer_section(& msg);
  }
  {
#line 407
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 407
    se = next_tuple();
    }
#line 407
    if (! ((unsigned long )se != (unsigned long )((void *)0))) {
#line 407
      goto while_break___0;
    }
    {
#line 408
    rc = do_cmd(se, argc, argv);
    }
#line 408
    if (rc == 0) {
#line 409
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 415
  free_tuples();
  }
#line 417
  return (rc);
}
}
