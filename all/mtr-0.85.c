/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_52 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_52 HEADER;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_59 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_59 __in6_u ;
};
#line 62 "/usr/include/search.h"
enum __anonenum_ACTION_64 {
    FIND = 0,
    ENTER = 1
} ;
#line 62 "/usr/include/search.h"
typedef enum __anonenum_ACTION_64 ACTION;
#line 69 "/usr/include/search.h"
struct entry {
   char *key ;
   void *data ;
};
#line 69 "/usr/include/search.h"
typedef struct entry ENTRY;
#line 56 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef struct in6_addr ip_t;
#line 65 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
typedef char *items_t[16];
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 24 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned char uint8;
#line 109 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
struct fields {
   unsigned char const   key ;
   char const   *descr ;
   char const   *title ;
   char const   *format ;
   int length ;
   int (*net_xxx)() ;
};
#line 129 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
struct mplslen {
   unsigned long label[8] ;
   uint8 exp[8] ;
   uint8 ttl[8] ;
   char s[8] ;
   char labels ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 105 "/home/wheatley/newnew/temp/mtr-0.85/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 118 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
struct names {
   char *name ;
   struct names *next ;
};
#line 118 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
typedef struct names names_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 31 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned short uint16;
#line 44 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned int uint32;
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdrctl {
   uint32_t ip6_un1_flow ;
   uint16_t ip6_un1_plen ;
   uint8_t ip6_un1_nxt ;
   uint8_t ip6_un1_hlim ;
};
#line 24 "/usr/include/netinet/ip6.h"
union __anonunion_ip6_ctlun_38 {
   struct ip6_hdrctl ip6_un1 ;
   uint8_t ip6_un2_vfc ;
};
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdr {
   union __anonunion_ip6_ctlun_38 ip6_ctlun ;
   struct in6_addr ip6_src ;
   struct in6_addr ip6_dst ;
};
#line 50 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct ICMPHeader {
   uint8 type ;
   uint8 code ;
   uint16 checksum ;
   uint16 id ;
   uint16 sequence ;
};
#line 59 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct UDPHeader {
   uint16 srcport ;
   uint16 dstport ;
   uint16 length ;
   uint16 checksum ;
};
#line 67 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct TCPHeader {
   uint16 srcport ;
   uint16 dstport ;
   uint32 seq ;
};
#line 74 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct UDPv4PHeader {
   uint32 saddr ;
   uint32 daddr ;
   uint8 zero ;
   uint8 protocol ;
   uint16 len ;
};
#line 83 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct IPHeader {
   uint8 version ;
   uint8 tos ;
   uint16 len ;
   uint16 id ;
   uint16 frag ;
   uint8 ttl ;
   uint8 protocol ;
   uint16 check ;
   uint32 saddr ;
   uint32 daddr ;
};
#line 110 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct nethost {
   ip_t addr ;
   ip_t addrs[8] ;
   int xmit ;
   int returned ;
   int sent ;
   int up ;
   long long var ;
   int last ;
   int best ;
   int worst ;
   int avg ;
   int gmean ;
   int jitter ;
   int javg ;
   int jworst ;
   int jinta ;
   int transit ;
   int saved[200] ;
   int saved_seq_offset ;
   struct mplslen mpls ;
   struct mplslen mplss[8] ;
};
#line 136 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sequence {
   int index ;
   int transit ;
   int saved_seq ;
   struct timeval time ;
   int socket ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_50 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_50 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_51 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_53 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_52 {
   char pad[52] ;
   struct __anonstruct__ext_53 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   unsigned int ipv6_unavail : 1 ;
   unsigned int unused : 23 ;
   struct __anonstruct_sort_list_51 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *__ns , u_char const   **__query ,
                            int *__querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *__ns , u_char const   *__query ,
                            int __querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_52 _u ;
};
#line 151 "/usr/include/resolv.h"
typedef struct __res_state *res_state;
#line 51 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned char byte;
#line 52 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned short word;
#line 53 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
typedef unsigned long dword;
#line 102 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve {
   struct resolve *next ;
   struct resolve *previous ;
   struct resolve *nextid ;
   struct resolve *previousid ;
   struct resolve *nextip ;
   struct resolve *previousip ;
   struct resolve *nexthost ;
   struct resolve *previoushost ;
   float expiretime ;
   char *hostname ;
   ip_t ip ;
   word id ;
   byte state ;
};
#line 193 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct __anonstruct_packetheader_69 {
   word id ;
   byte databyte_a ;
   byte databyte_b ;
   word qdcount ;
   word ancount ;
   word nscount ;
   word arcount ;
};
#line 193 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
typedef struct __anonstruct_packetheader_69 packetheader;
#line 266
struct logline;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 277
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_query)(char const   * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  u_char * ,
                                                                                  int  ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __dn_expand)(u_char const   * ,
                                                                                  u_char const   * ,
                                                                                  u_char const   * ,
                                                                                  char * ,
                                                                                  int  ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 87 "/usr/include/search.h"
extern  __attribute__((__nothrow__)) ENTRY *( __attribute__((__leaf__)) hsearch)(ENTRY __item ,
                                                                                 ACTION __action ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) hcreate)(size_t __nel ) ;
#line 93
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) hdestroy)(void) ;
#line 19 "/home/wheatley/newnew/temp/mtr-0.85/asn.h"
int ipinfo_no ;
#line 20
int ipinfo_max ;
#line 21
int iiwidth_len ;
#line 22
int iihash ;
#line 23
void asn_open(void) ;
#line 24
void asn_close(void) ;
#line 25
char *fmt_ipinfo(ip_t *addr ) ;
#line 26
int get_iiwidth(void) ;
#line 27
int is_printii(void) ;
#line 55 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int ipinfo_no  =    -1;
#line 56 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int ipinfo_max  =    -1;
#line 57 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int iihash  =    0;
#line 58 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char fmtinfo[32]  ;
#line 59
int af ;
#line 62 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int iiwidth[5]  = {      6,      19,      4,      8, 
        11};
#line 63 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int iiwidth_len  =    (int )(sizeof(iiwidth) / sizeof(iiwidth[0]));
#line 66 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
items_t items_a  ;
#line 67 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char txtrec[128]  ;
#line 68 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
items_t *items  =    & items_a;
#line 71 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char *ipinfo_lookup(char const   *domain ) 
{ 
  unsigned char answer[512] ;
  unsigned char *pt ;
  char host___0[128] ;
  char *txt ;
  int len ;
  int exp ;
  int size ;
  int txtlen ;
  int type ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  u_char const   *t_cp ;
  u_char const   *t_cp___0 ;
  u_char const   *t_cp___1 ;
  void *tmp___2 ;

  {
  {
#line 78
  tmp = __res_init();
  }
#line 78
  if (tmp < 0) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"@res_init failed\n");
    }
#line 80
    return ((char *)((void *)0));
  }
  {
#line 83
  memset((void *)(answer), 0, (size_t )512);
#line 84
  len = __res_query(domain, 1, 16, answer, 512);
  }
#line 84
  if (len < 0) {
#line 89
    if (iihash) {
      {
#line 89
      tmp___0 = strdup("???");
#line 89
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 89
      tmp___1 = "???";
    }
#line 89
    return ((char *)tmp___1);
  }
  {
#line 92
  pt = answer + sizeof(HEADER );
#line 94
  exp = __dn_expand((u_char const   *)(answer), (u_char const   *)(answer + len),
                    (u_char const   *)pt, host___0, (int )sizeof(host___0));
  }
#line 94
  if (exp < 0) {
    {
#line 95
    printf((char const   */* __restrict  */)"@dn_expand failed\n");
    }
#line 95
    return ((char *)((void *)0));
  }
#line 98
  pt += exp;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    t_cp = (u_char const   *)pt;
#line 100
    type = ((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1));
#line 100
    pt += 2;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (type != 16) {
    {
#line 102
    printf((char const   */* __restrict  */)"@Broken DNS reply.\n");
    }
#line 102
    return ((char *)((void *)0));
  }
  {
#line 105
  pt += 2;
#line 107
  exp = __dn_expand((u_char const   *)(answer), (u_char const   *)(answer + len),
                    (u_char const   *)pt, host___0, (int )sizeof(host___0));
  }
#line 107
  if (exp < 0) {
    {
#line 108
    printf((char const   */* __restrict  */)"@second dn_expand failed\n");
    }
#line 108
    return ((char *)((void *)0));
  }
#line 111
  pt += exp;
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 112
    t_cp___0 = (u_char const   *)pt;
#line 112
    type = ((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1));
#line 112
    pt += 2;
#line 112
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  if (type != 16) {
    {
#line 114
    printf((char const   */* __restrict  */)"@Not a TXT record\n");
    }
#line 114
    return ((char *)((void *)0));
  }
#line 117
  pt += 2;
#line 118
  pt += 4;
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    t_cp___1 = (u_char const   *)pt;
#line 119
    size = ((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1));
#line 119
    pt += 2;
#line 119
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 120
  txtlen = (int )*pt;
#line 123
  if (txtlen >= size) {
    {
#line 124
    printf((char const   */* __restrict  */)"@Broken TXT record (txtlen = %d, size = %d)\n",
           txtlen, size);
    }
#line 124
    return ((char *)((void *)0));
  } else
#line 123
  if (! txtlen) {
    {
#line 124
    printf((char const   */* __restrict  */)"@Broken TXT record (txtlen = %d, size = %d)\n",
           txtlen, size);
    }
#line 124
    return ((char *)((void *)0));
  }
#line 127
  if (txtlen > 127) {
#line 128
    txtlen = 127;
  }
#line 130
  if (iihash) {
    {
#line 131
    tmp___2 = malloc((size_t )(txtlen + 1));
#line 131
    txt = (char *)tmp___2;
    }
#line 131
    if (! txt) {
#line 132
      return ((char *)((void *)0));
    }
  } else {
#line 134
    txt = txtrec;
  }
  {
#line 136
  pt ++;
#line 137
  strncpy((char */* __restrict  */)txt, (char const   */* __restrict  */)((char *)pt),
          (size_t )txtlen);
#line 138
  *(txt + txtlen) = (char)0;
  }
#line 145
  return (txt);
}
}
#line 148 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char *trimsep(char *s ) 
{ 
  int l ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 150
  p = s;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((int )*p == 32)) {
#line 151
      if (! ((int )*p == 124)) {
#line 151
        goto while_break;
      }
    }
#line 152
    tmp = p;
#line 152
    p ++;
#line 152
    *tmp = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  tmp___0 = strlen((char const   *)p);
#line 153
  l = (int )(tmp___0 - 1UL);
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! ((int )*(p + l) == 32)) {
#line 153
      if (! ((int )*(p + l) == 124)) {
#line 153
        goto while_break___0;
      }
    }
#line 154
    *(p + l) = (char )'\000';
#line 153
    l --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  return (p);
}
}
#line 159 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char *split_txtrec(char *txtrec___0 ) 
{ 
  void *tmp ;
  char *prev ;
  char *tmp___0 ;
  char *next ;
  int i ;
  int j ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 160
  if (! txtrec___0) {
#line 161
    return ((char *)((void *)0));
  }
#line 162
  if (iihash) {
    {
#line 166
    tmp = malloc(sizeof(*items));
#line 166
    items = (items_t *)tmp;
    }
#line 166
    if (! items) {
      {
#line 170
      free((void *)txtrec___0);
      }
#line 171
      return ((char *)((void *)0));
    }
  }
  {
#line 175
  tmp___0 = trimsep(txtrec___0);
#line 175
  (*items)[0] = tmp___0;
#line 175
  prev = tmp___0;
#line 177
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    next = strchr((char const   *)prev, '|');
    }
#line 179
    if (next) {
#line 179
      if (! (i < 15)) {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
    {
#line 180
    tmp___1 = next;
#line 180
    next ++;
#line 180
    *tmp___1 = (char )'\000';
#line 181
    tmp___2 = i;
#line 181
    i ++;
#line 181
    (*items)[tmp___2] = trimsep(prev);
#line 182
    prev = trimsep(next);
#line 182
    (*items)[i] = prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (i < 15) {
#line 185
    i ++;
  }
#line 186
  j = i;
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (j <= 15)) {
#line 186
      goto while_break___0;
    }
#line 187
    (*items)[j] = (char *)((void *)0);
#line 186
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  if (i > ipinfo_max) {
#line 190
    ipinfo_max = i;
  }
#line 191
  if (ipinfo_no >= i) {
#line 192
    if (ipinfo_no >= ipinfo_max) {
#line 193
      ipinfo_no = 0;
    }
#line 194
    return ((*items)[0]);
  } else {
#line 196
    return ((*items)[ipinfo_no]);
  }
}
}
#line 201 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
void reverse_host6(struct in6_addr *addr , char *buff ) 
{ 
  int i ;
  char *b ;
  size_t tmp ;

  {
#line 203
  b = buff;
#line 204
  i = (int )(sizeof(*addr) / 2UL - 1UL);
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i >= 0)) {
#line 204
      goto while_break;
    }
    {
#line 205
    sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%x.%x.",
            (int )addr->__in6_u.__u6_addr8[i] & 15, (int )addr->__in6_u.__u6_addr8[i] >> 4);
#line 204
    i --;
#line 204
    b += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  tmp = strlen((char const   *)buff);
#line 206
  *(buff + (tmp - 1UL)) = (char )'\000';
  }
#line 207
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char *get_ipinfo(ip_t *addr ) 
{ 
  char key[127] ;
  char lookup_key[127] ;
  int tmp ;
  unsigned char buff[4] ;
  int tmp___0 ;
  int tmp___1 ;
  char *val ;
  ENTRY item ;
  ENTRY *found_item ;
  char *tmp___2 ;

  {
#line 211
  if (! addr) {
#line 212
    return ((char *)((void *)0));
  }
#line 217
  if (af == 10) {
    {
#line 219
    reverse_host6(addr, key);
#line 220
    tmp = snprintf((char */* __restrict  */)(lookup_key), (size_t )127, (char const   */* __restrict  */)"%s.origin6.asn.cymru.com",
                   key);
    }
#line 220
    if (tmp >= 127) {
#line 221
      return ((char *)((void *)0));
    }
  } else {
    {
#line 227
    memcpy((void */* __restrict  */)(buff), (void const   */* __restrict  */)addr,
           (size_t )4);
#line 228
    tmp___0 = snprintf((char */* __restrict  */)(key), (size_t )127, (char const   */* __restrict  */)"%d.%d.%d.%d",
                       (int )buff[3], (int )buff[2], (int )buff[1], (int )buff[0]);
    }
#line 228
    if (tmp___0 >= 127) {
#line 229
      return ((char *)((void *)0));
    }
    {
#line 230
    tmp___1 = snprintf((char */* __restrict  */)(lookup_key), (size_t )127, (char const   */* __restrict  */)"%s.origin.asn.cymru.com",
                       key);
    }
#line 230
    if (tmp___1 >= 127) {
#line 231
      return ((char *)((void *)0));
    }
  }
#line 234
  val = (char *)((void *)0);
#line 237
  if (iihash) {
    {
#line 241
    item.key = key;
#line 243
    found_item = hsearch(item, (ACTION )0);
    }
#line 243
    if (found_item) {
#line 244
      val = (*((items_t *)found_item->data))[ipinfo_no];
#line 244
      if (! val) {
#line 245
        val = (*((items_t *)found_item->data))[0];
      }
    }
  }
#line 252
  if (! val) {
    {
#line 256
    tmp___2 = ipinfo_lookup((char const   *)(lookup_key));
#line 256
    val = split_txtrec(tmp___2);
    }
#line 256
    if (val) {
#line 260
      if (iihash) {
        {
#line 261
        item.key = strdup((char const   *)(key));
        }
#line 261
        if (item.key) {
          {
#line 262
          item.data = (void *)items;
#line 263
          hsearch(item, (ACTION )1);
          }
        }
      }
    }
  }
#line 271
  return (val);
}
}
#line 274 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int get_iiwidth(void) 
{ 
  int tmp ;

  {
#line 275
  if (ipinfo_no < iiwidth_len) {
#line 275
    tmp = iiwidth[ipinfo_no];
  } else {
#line 275
    tmp = iiwidth[ipinfo_no % iiwidth_len];
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
char *fmt_ipinfo(ip_t *addr ) 
{ 
  char *ipinfo ;
  char *tmp ;
  char fmt[8] ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 279
  tmp = get_ipinfo(addr);
#line 279
  ipinfo = tmp;
#line 281
  tmp___0 = get_iiwidth();
  }
#line 281
  if (ipinfo_no) {
#line 281
    tmp___1 = "";
  } else {
#line 281
    tmp___1 = "AS";
  }
  {
#line 281
  snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%s%%-%ds",
           tmp___1, tmp___0);
  }
#line 282
  if (ipinfo) {
#line 282
    tmp___2 = (char const   *)ipinfo;
  } else {
#line 282
    tmp___2 = "???";
  }
  {
#line 282
  snprintf((char */* __restrict  */)(fmtinfo), sizeof(fmtinfo), (char const   */* __restrict  */)(fmt),
           tmp___2);
  }
#line 283
  return (fmtinfo);
}
}
#line 286 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
int is_printii(void) 
{ 
  int tmp ;

  {
#line 287
  if (ipinfo_no >= 0) {
#line 287
    if (ipinfo_no != ipinfo_max) {
#line 287
      tmp = 1;
    } else {
#line 287
      tmp = 0;
    }
  } else {
#line 287
    tmp = 0;
  }
#line 287
  return (tmp);
}
}
#line 290 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
void asn_open(void) 
{ 


  {
#line 291
  if (ipinfo_no >= 0) {
    {
#line 295
    iihash = hcreate((size_t )128);
    }
#line 295
    if (! iihash) {
      {
#line 296
      perror("ipinfo hash");
      }
    }
  }
#line 298
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/mtr-0.85/asn.c"
void asn_close(void) 
{ 


  {
#line 301
  if (iihash) {
    {
#line 305
    hdestroy();
#line 306
    iihash = 0;
    }
  }
#line 308
  return;
}
}
#line 76 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 711
extern int noecho(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 727
extern int raw(void) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 61 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
int enablempls ;
#line 63
int show_ips ;
#line 20 "/home/wheatley/newnew/temp/mtr-0.85/mtr-curses.h"
void mtr_curses_open(void) ;
#line 21
void mtr_curses_close(void) ;
#line 22
void mtr_curses_redraw(void) ;
#line 23
int mtr_curses_keyaction(void) ;
#line 24
void mtr_curses_clear(void) ;
#line 43 "/home/wheatley/newnew/temp/mtr-0.85/display.h"
int display_mode ;
#line 44
int display_offset ;
#line 40 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
int net_max(void) ;
#line 41
int net_min(void) ;
#line 43
ip_t *net_addr(int at ) ;
#line 44
void *net_mpls(int at ) ;
#line 45
void *net_mplss(int at , int i ) ;
#line 58
ip_t *net_addrs(int at , int i ) ;
#line 59
char *net_localaddr(void) ;
#line 70
int net_up(int at ) ;
#line 73
int *net_saved_pings(int at ) ;
#line 79
int addrcmp(char *a , char *b , int af___0 ) ;
#line 118
struct fields data_fields[20] ;
#line 122
int fld_index[256] ;
#line 123
unsigned char fld_active[40] ;
#line 124
char available_options[20] ;
#line 126 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
ip_t unspec_addr  ;
#line 49 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
char *dns_lookup(ip_t *ip ) ;
#line 52
char *strlongip(ip_t *ip ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 74 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
char LocalHostname[128] ;
#line 75
int fstTTL ;
#line 76
int maxTTL ;
#line 77
int cpacketsize ;
#line 78
int bitpattern ;
#line 79
int tos ;
#line 80
float WaitTime ;
#line 82
int mtrtype ;
#line 84 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static int __unused_int  ;
#line 86 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void pwcenter(char *str ) 
{ 
  int maxx ;
  int cx ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 91
  if (stdscr) {
#line 91
    __unused_int = (int )stdscr->_maxy + 1;
  } else {
#line 91
    __unused_int = -1;
  }
#line 91
  if (stdscr) {
#line 91
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 91
    maxx = -1;
  }
  {
#line 92
  tmp = strlen((char const   *)str);
#line 92
  cx = (int )((size_t )maxx - tmp) / 2;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    tmp___0 = cx;
#line 93
    cx --;
#line 93
    if (! (tmp___0 > 0)) {
#line 93
      goto while_break;
    }
    {
#line 94
    printw(" ");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  printw((char const   *)str);
  }
#line 96
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
int mtr_curses_keyaction(void) 
{ 
  int c ;
  int tmp ;
  int i ;
  float f ;
  char buf[21] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  __uid_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int pressanykey_row ;
  int tmp___28 ;
  int tmp___29 ;

  {
  {
#line 101
  tmp = wgetch(stdscr);
#line 101
  c = tmp;
#line 102
  i = 0;
#line 103
  f = (float )0.0;
  }
#line 106
  if (c == 113) {
#line 107
    return (1);
  }
#line 108
  if (c == 3) {
#line 109
    return (1);
  }
#line 110
  if (c == 12) {
#line 111
    return (4);
  }
#line 112
  if (c == 19) {
#line 113
    return (5);
  } else {
    {
#line 112
    tmp___0 = tolower(c);
    }
#line 112
    if (tmp___0 == 112) {
#line 113
      return (5);
    }
  }
#line 114
  if (c == 17) {
#line 115
    return (6);
  } else
#line 114
  if (c == 32) {
#line 115
    return (6);
  }
  {
#line 116
  tmp___1 = tolower(c);
  }
#line 116
  if (tmp___1 == 114) {
#line 117
    return (2);
  }
  {
#line 118
  tmp___2 = tolower(c);
  }
#line 118
  if (tmp___2 == 100) {
#line 119
    return (3);
  }
  {
#line 120
  tmp___3 = tolower(c);
  }
#line 120
  if (tmp___3 == 101) {
#line 121
    return (7);
  }
  {
#line 122
  tmp___4 = tolower(c);
  }
#line 122
  if (tmp___4 == 110) {
#line 123
    return (8);
  }
  {
#line 125
  tmp___5 = tolower(c);
  }
#line 125
  if (tmp___5 == 121) {
#line 126
    return (9);
  }
  {
#line 127
  tmp___6 = tolower(c);
  }
#line 127
  if (tmp___6 == 122) {
#line 128
    return (10);
  }
#line 130
  if (c == 43) {
#line 131
    return (11);
  }
#line 132
  if (c == 45) {
#line 133
    return (12);
  }
  {
#line 135
  tmp___8 = tolower(c);
  }
#line 135
  if (tmp___8 == 115) {
    {
#line 136
    mvprintw(2, 0, "Change Packet Size: %d\n", cpacketsize);
#line 137
    mvprintw(3, 0, "Size Range: %d-%d, < 0:random.\n", 28, 4470);
#line 138
    wmove(stdscr, 2, 20);
#line 139
    wrefresh(stdscr);
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 140
      c = wgetch(stdscr);
      }
#line 140
      if (c != 10) {
#line 140
        if (! (i < 20)) {
#line 140
          goto while_break;
        }
      } else {
#line 140
        goto while_break;
      }
      {
#line 141
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 141
      printw("%c", c);
#line 141
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 141
      wrefresh(stdscr);
#line 142
      tmp___7 = i;
#line 142
      i ++;
#line 142
      buf[tmp___7] = (char )c;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 144
    buf[i] = (char )'\000';
#line 145
    cpacketsize = atoi((char const   *)(buf));
    }
#line 146
    return (0);
  }
  {
#line 148
  tmp___10 = tolower(c);
  }
#line 148
  if (tmp___10 == 98) {
    {
#line 149
    mvprintw(2, 0, "Ping Bit Pattern: %d\n", bitpattern);
#line 150
    mvprintw(3, 0, "Pattern Range: 0(0x00)-255(0xff), <0 random.\n");
#line 151
    wmove(stdscr, 2, 18);
#line 152
    wrefresh(stdscr);
    }
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 153
      c = wgetch(stdscr);
      }
#line 153
      if (c != 10) {
#line 153
        if (! (i < 20)) {
#line 153
          goto while_break___0;
        }
      } else {
#line 153
        goto while_break___0;
      }
      {
#line 154
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 154
      printw("%c", c);
#line 154
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 154
      wrefresh(stdscr);
#line 155
      tmp___9 = i;
#line 155
      i ++;
#line 155
      buf[tmp___9] = (char )c;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    buf[i] = (char )'\000';
#line 158
    bitpattern = atoi((char const   *)(buf));
    }
#line 159
    if (bitpattern > 255) {
#line 159
      bitpattern = -1;
    }
#line 160
    return (0);
  }
#line 162
  if (c == 81) {
    {
#line 163
    mvprintw(2, 0, "Type of Service(tos): %d\n", tos);
#line 164
    mvprintw(3, 0, "default 0x00, min cost 0x02, rel 0x04,, thr 0x08, low del 0x10...\n");
#line 165
    wmove(stdscr, 2, 22);
#line 166
    wrefresh(stdscr);
    }
    {
#line 167
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 167
      c = wgetch(stdscr);
      }
#line 167
      if (c != 10) {
#line 167
        if (! (i < 20)) {
#line 167
          goto while_break___1;
        }
      } else {
#line 167
        goto while_break___1;
      }
      {
#line 168
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 168
      printw("%c", c);
#line 168
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 168
      wrefresh(stdscr);
#line 169
      tmp___11 = i;
#line 169
      i ++;
#line 169
      buf[tmp___11] = (char )c;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 171
    buf[i] = (char )'\000';
#line 172
    tos = atoi((char const   *)(buf));
    }
#line 173
    if (tos > 255) {
#line 174
      tos = 0;
    } else
#line 173
    if (tos < 0) {
#line 174
      tos = 0;
    }
#line 176
    return (0);
  }
  {
#line 178
  tmp___15 = tolower(c);
  }
#line 178
  if (tmp___15 == 105) {
    {
#line 179
    mvprintw(2, 0, "Interval : %0.0f\n\n", (double )WaitTime);
#line 180
    wmove(stdscr, 2, 11);
#line 181
    wrefresh(stdscr);
    }
    {
#line 182
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 182
      c = wgetch(stdscr);
      }
#line 182
      if (c != 10) {
#line 182
        if (! (i < 20)) {
#line 182
          goto while_break___2;
        }
      } else {
#line 182
        goto while_break___2;
      }
      {
#line 183
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 183
      printw("%c", c);
#line 183
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 183
      wrefresh(stdscr);
#line 184
      tmp___12 = i;
#line 184
      i ++;
#line 184
      buf[tmp___12] = (char )c;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 186
    buf[i] = (char )'\000';
#line 188
    tmp___13 = atof((char const   *)(buf));
#line 188
    f = (float )tmp___13;
    }
#line 190
    if ((double )f <= 0.0) {
#line 190
      return (0);
    }
    {
#line 191
    tmp___14 = getuid();
    }
#line 191
    if (tmp___14 != 0U) {
#line 191
      if ((double )f < 1.0) {
#line 192
        return (0);
      }
    }
#line 193
    WaitTime = f;
#line 195
    return (0);
  }
  {
#line 197
  tmp___17 = tolower(c);
  }
#line 197
  if (tmp___17 == 102) {
    {
#line 198
    mvprintw(2, 0, "First TTL: %d\n\n", fstTTL);
#line 199
    wmove(stdscr, 2, 11);
#line 200
    wrefresh(stdscr);
    }
    {
#line 201
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 201
      c = wgetch(stdscr);
      }
#line 201
      if (c != 10) {
#line 201
        if (! (i < 20)) {
#line 201
          goto while_break___3;
        }
      } else {
#line 201
        goto while_break___3;
      }
      {
#line 202
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 202
      printw("%c", c);
#line 202
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 202
      wrefresh(stdscr);
#line 203
      tmp___16 = i;
#line 203
      i ++;
#line 203
      buf[tmp___16] = (char )c;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 205
    buf[i] = (char )'\000';
#line 206
    i = atoi((char const   *)(buf));
    }
#line 208
    if (i < 1) {
#line 208
      return (0);
    } else
#line 208
    if (i > maxTTL) {
#line 208
      return (0);
    }
#line 209
    fstTTL = i;
#line 211
    return (0);
  }
  {
#line 213
  tmp___19 = tolower(c);
  }
#line 213
  if (tmp___19 == 109) {
    {
#line 214
    mvprintw(2, 0, "Max TTL: %d\n\n", maxTTL);
#line 215
    wmove(stdscr, 2, 9);
#line 216
    wrefresh(stdscr);
    }
    {
#line 217
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 217
      c = wgetch(stdscr);
      }
#line 217
      if (c != 10) {
#line 217
        if (! (i < 20)) {
#line 217
          goto while_break___4;
        }
      } else {
#line 217
        goto while_break___4;
      }
      {
#line 218
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 218
      printw("%c", c);
#line 218
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 218
      wrefresh(stdscr);
#line 219
      tmp___18 = i;
#line 219
      i ++;
#line 219
      buf[tmp___18] = (char )c;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 221
    buf[i] = (char )'\000';
#line 222
    i = atoi((char const   *)(buf));
    }
#line 224
    if (i < fstTTL) {
#line 224
      return (0);
    } else
#line 224
    if (i > 255) {
#line 224
      return (0);
    }
#line 225
    maxTTL = i;
#line 227
    return (0);
  }
  {
#line 230
  tmp___23 = tolower(c);
  }
#line 230
  if (tmp___23 == 111) {
    {
#line 231
    mvprintw(2, 0, "Fields: %s\n\n", fld_active);
#line 233
    i = 0;
    }
    {
#line 233
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 233
      if (! (i < 20)) {
#line 233
        goto while_break___5;
      }
#line 234
      if ((unsigned long )data_fields[i].descr != (unsigned long )((void *)0)) {
        {
#line 235
        printw("  %s\n", data_fields[i].descr);
        }
      }
#line 233
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 237
    printw("\n");
#line 238
    wmove(stdscr, 2, 8);
#line 239
    wrefresh(stdscr);
#line 241
    i = 0;
    }
    {
#line 242
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 242
      c = wgetch(stdscr);
      }
#line 242
      if (c != 10) {
#line 242
        if (! (i < 20)) {
#line 242
          goto while_break___6;
        }
      } else {
#line 242
        goto while_break___6;
      }
      {
#line 243
      tmp___21 = strchr((char const   *)(available_options), c);
      }
#line 243
      if (tmp___21) {
        {
#line 244
        wattr_on(stdscr, 1UL << 21, (void *)0);
#line 244
        printw("%c", c);
#line 244
        wattr_off(stdscr, 1UL << 21, (void *)0);
#line 244
        wrefresh(stdscr);
#line 245
        tmp___20 = i;
#line 245
        i ++;
#line 245
        buf[tmp___20] = (char )c;
        }
      } else {
        {
#line 247
        printf((char const   */* __restrict  */)"\a");
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 250
    buf[i] = (char )'\000';
#line 251
    tmp___22 = strlen((char const   *)(buf));
    }
#line 251
    if (tmp___22 > 0UL) {
      {
#line 251
      strcpy((char */* __restrict  */)(fld_active), (char const   */* __restrict  */)(buf));
      }
    }
#line 253
    return (0);
  }
  {
#line 255
  tmp___25 = tolower(c);
  }
#line 255
  if (tmp___25 == 106) {
    {
#line 256
    tmp___24 = index((char const   *)(fld_active), 'N');
    }
#line 256
    if (tmp___24) {
      {
#line 257
      strcpy((char */* __restrict  */)(fld_active), (char const   */* __restrict  */)"DR AGJMXI");
      }
    } else {
      {
#line 259
      strcpy((char */* __restrict  */)(fld_active), (char const   */* __restrict  */)"LS NABWV");
      }
    }
#line 261
    return (0);
  }
  {
#line 263
  tmp___26 = tolower(c);
  }
#line 263
  if (tmp___26 == 117) {
    {
#line 266
    if (mtrtype == 6) {
#line 266
      goto case_6;
    }
#line 266
    if (mtrtype == 1) {
#line 266
      goto case_6;
    }
#line 269
    if (mtrtype == 17) {
#line 269
      goto case_17;
    }
#line 264
    goto switch_break;
    case_6: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 267
    mtrtype = 17;
#line 268
    goto switch_break;
    case_17: /* CIL Label */ 
#line 270
    mtrtype = 1;
#line 271
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 273
    return (0);
  }
  {
#line 275
  tmp___27 = tolower(c);
  }
#line 275
  if (tmp___27 == 116) {
    {
#line 278
    if (mtrtype == 17) {
#line 278
      goto case_17___0;
    }
#line 278
    if (mtrtype == 1) {
#line 278
      goto case_17___0;
    }
#line 281
    if (mtrtype == 6) {
#line 281
      goto case_6___0;
    }
#line 276
    goto switch_break___0;
    case_17___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 279
    mtrtype = 6;
#line 280
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 282
    mtrtype = 1;
#line 283
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 285
    return (0);
  }
  {
#line 288
  tmp___28 = tolower(c);
  }
#line 288
  if (tmp___28 == 63) {
#line 288
    goto _L;
  } else {
    {
#line 288
    tmp___29 = tolower(c);
    }
#line 288
    if (tmp___29 == 104) {
      _L: /* CIL Label */ 
      {
#line 289
      pressanykey_row = 20;
#line 290
      mvprintw(2, 0, "Command:\n");
#line 291
      printw("  ?|h     help\n");
#line 292
      printw("  p       pause (SPACE to resume)\n");
#line 293
      printw("  d       switching display mode\n");
#line 294
      printw("  e       toggle MPLS information on/off\n");
#line 295
      printw("  n       toggle DNS on/off\n");
#line 296
      printw("  r       reset all counters\n");
#line 297
      printw("  o str   set the columns to display, default str=\'LRS N BAWV\'\n");
#line 298
      printw("  j       toggle latency(LS NABWV)/jitter(DR AGJMXI) stats\n");
#line 299
      printw("  c <n>   report cycle n, default n=infinite\n");
#line 300
      printw("  i <n>   set the ping interval to n seconds, default n=1\n");
#line 301
      printw("  f <n>   set the initial time-to-live(ttl), default n=1\n");
#line 302
      printw("  m <n>   set the max time-to-live, default n= # of hops\n");
#line 303
      printw("  s <n>   set the packet size to n or random(n<0)\n");
#line 304
      printw("  b <c>   set ping bit pattern to c(0..255) or random(c<0)\n");
#line 305
      printw("  Q <t>   set ping packet\'s TOS to t\n");
#line 306
      printw("  u       switch between ICMP ECHO and UDP datagrams\n");
#line 308
      printw("  y       switching IP info\n");
#line 309
      printw("  z       toggle ASN info on/off\n");
#line 310
      pressanykey_row += 2;
#line 312
      printw("\n");
#line 313
      mvprintw(pressanykey_row, 0, " press any key to go back...");
#line 315
      wgetch(stdscr);
      }
#line 316
      return (0);
    }
  }
#line 319
  return (0);
}
}
#line 323 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_hosts(int startstat ) 
{ 
  int max ;
  int at ;
  struct mplslen *mpls ;
  struct mplslen *mplss ;
  ip_t *addr ;
  ip_t *addrs ;
  int y ;
  char *name ;
  int i ;
  int j ;
  int k ;
  int hd_len ;
  char buf[1024] ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 336
  max = net_max();
#line 338
  tmp = net_min();
#line 338
  at = tmp + display_offset;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (at < max)) {
#line 338
      goto while_break;
    }
    {
#line 339
    printw("%2d. ", at + 1);
#line 340
    addr = net_addr(at);
#line 341
    tmp___0 = net_mpls(at);
#line 341
    mpls = (struct mplslen *)tmp___0;
#line 343
    tmp___17 = addrcmp((char *)((void *)addr), (char *)((void *)(& unspec_addr)),
                       af);
    }
#line 343
    if (tmp___17 != 0) {
      {
#line 344
      name = dns_lookup(addr);
#line 345
      tmp___1 = net_up(at);
      }
#line 345
      if (! tmp___1) {
        {
#line 346
        wattr_on(stdscr, 1UL << 21, (void *)0);
        }
      }
      {
#line 348
      tmp___3 = is_printii();
      }
#line 348
      if (tmp___3) {
        {
#line 349
        tmp___2 = fmt_ipinfo(addr);
#line 349
        printw((char const   *)tmp___2);
        }
      }
#line 351
      if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 352
        if (show_ips) {
          {
#line 352
          tmp___4 = strlongip(addr);
#line 352
          printw("%s (%s)", name, tmp___4);
          }
        } else {
          {
#line 353
          printw("%s", name);
          }
        }
      } else {
        {
#line 355
        tmp___5 = strlongip(addr);
#line 355
        printw("%s", tmp___5);
        }
      }
      {
#line 357
      wattr_off(stdscr, 1UL << 21, (void *)0);
      }
#line 359
      if (stdscr) {
#line 359
        y = (int )stdscr->_cury;
      } else {
#line 359
        y = -1;
      }
#line 359
      if (stdscr) {
#line 359
        __unused_int = (int )stdscr->_curx;
      } else {
#line 359
        __unused_int = -1;
      }
      {
#line 360
      wmove(stdscr, y, startstat);
#line 363
      hd_len = 0;
#line 364
      i = 0;
      }
      {
#line 364
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 364
        if (! (i < 20)) {
#line 364
          goto while_break___0;
        }
#line 368
        j = fld_index[fld_active[i]];
#line 369
        if (j == -1) {
#line 369
          goto __Cont;
        }
        {
#line 372
        tmp___8 = index(data_fields[j].format, 'f');
        }
#line 372
        if (tmp___8) {
          {
#line 373
          tmp___6 = (*(data_fields[j].net_xxx))(at);
#line 373
          sprintf((char */* __restrict  */)(buf + hd_len), (char const   */* __restrict  */)data_fields[j].format,
                  (double )tmp___6 / 1000.0);
          }
        } else {
          {
#line 376
          tmp___7 = (*(data_fields[j].net_xxx))(at);
#line 376
          sprintf((char */* __restrict  */)(buf + hd_len), (char const   */* __restrict  */)data_fields[j].format,
                  tmp___7);
          }
        }
#line 379
        hd_len += data_fields[j].length;
        __Cont: /* CIL Label */ 
#line 364
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 381
      buf[hd_len] = (char)0;
#line 382
      printw("%s", buf);
#line 384
      k = 0;
      }
      {
#line 384
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 384
        if (k < (int )mpls->labels) {
#line 384
          if (! enablempls) {
#line 384
            goto while_break___1;
          }
        } else {
#line 384
          goto while_break___1;
        }
#line 385
        if (k + 1 < (int )mpls->labels) {
          {
#line 387
          printw("\n    [MPLS: Lbl %lu Exp %u S %u TTL %u]", mpls->label[k], (int )mpls->exp[k],
                 (int )mpls->s[k], (int )mpls->ttl[k]);
          }
        } else
#line 385
        if ((int )mpls->labels == 1) {
          {
#line 387
          printw("\n    [MPLS: Lbl %lu Exp %u S %u TTL %u]", mpls->label[k], (int )mpls->exp[k],
                 (int )mpls->s[k], (int )mpls->ttl[k]);
          }
        } else {
          {
#line 390
          printw("\n    [MPLS: Lbl %lu Exp %u S %u TTL %u]", mpls->label[k], (int )mpls->exp[k],
                 (int )mpls->s[k], (int )mpls->ttl[k]);
          }
        }
#line 384
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 395
      i = 0;
      {
#line 395
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 395
        if (! (i < 8)) {
#line 395
          goto while_break___2;
        }
        {
#line 396
        addrs = net_addrs(at, i);
#line 397
        tmp___9 = net_mplss(at, i);
#line 397
        mplss = (struct mplslen *)tmp___9;
#line 398
        tmp___10 = addrcmp((char *)((void *)addrs), (char *)((void *)addr), af);
        }
#line 398
        if (tmp___10 == 0) {
#line 398
          goto __Cont___0;
        }
        {
#line 399
        tmp___11 = addrcmp((char *)((void *)addrs), (char *)((void *)(& unspec_addr)),
                           af);
        }
#line 399
        if (tmp___11 == 0) {
#line 399
          goto while_break___2;
        }
        {
#line 401
        name = dns_lookup(addrs);
#line 402
        tmp___12 = net_up(at);
        }
#line 402
        if (! tmp___12) {
          {
#line 402
          wattr_on(stdscr, 1UL << 21, (void *)0);
          }
        }
        {
#line 403
        printw("\n    ");
#line 405
        tmp___14 = is_printii();
        }
#line 405
        if (tmp___14) {
          {
#line 406
          tmp___13 = fmt_ipinfo(addrs);
#line 406
          printw((char const   *)tmp___13);
          }
        }
#line 408
        if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 409
          if (show_ips) {
            {
#line 409
            tmp___15 = strlongip(addrs);
#line 409
            printw("%s (%s)", name, tmp___15);
            }
          } else {
            {
#line 410
            printw("%s", name);
            }
          }
        } else {
          {
#line 412
          tmp___16 = strlongip(addrs);
#line 412
          printw("%s", tmp___16);
          }
        }
#line 414
        k = 0;
        {
#line 414
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 414
          if (k < (int )mplss->labels) {
#line 414
            if (! enablempls) {
#line 414
              goto while_break___3;
            }
          } else {
#line 414
            goto while_break___3;
          }
          {
#line 415
          printw("\n    [MPLS: Lbl %lu Exp %u S %u TTL %u]", mplss->label[k], (int )mplss->exp[k],
                 (int )mplss->s[k], (int )mplss->ttl[k]);
#line 414
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 417
        wattr_off(stdscr, 1UL << 21, (void *)0);
        }
        __Cont___0: /* CIL Label */ 
#line 395
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      printw("???");
      }
    }
    {
#line 424
    printw("\n");
#line 338
    at ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  wmove(stdscr, 2, 0);
  }
#line 427
  return;
}
}
#line 430 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static double factors[8]  ;
#line 431 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static int scale[8]  ;
#line 432 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static int low_ms  ;
#line 432 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static int high_ms  ;
#line 434 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_gen_scale(void) 
{ 
  int *saved ;
  int i ;
  int max ;
  int at ;
  int range ;

  {
#line 439
  low_ms = 1000000;
#line 440
  high_ms = -1;
#line 442
  i = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (i < 8)) {
#line 442
      goto while_break;
    }
#line 443
    scale[i] = 0;
#line 442
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  max = net_max();
#line 446
  at = display_offset;
  }
  {
#line 446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 446
    if (! (at < max)) {
#line 446
      goto while_break___0;
    }
    {
#line 447
    saved = net_saved_pings(at);
#line 448
    i = 0;
    }
    {
#line 448
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 448
      if (! (i < 200)) {
#line 448
        goto while_break___1;
      }
#line 449
      if (*(saved + i) < 0) {
#line 449
        goto __Cont;
      }
#line 450
      if (*(saved + i) < low_ms) {
#line 451
        low_ms = *(saved + i);
      }
#line 453
      if (*(saved + i) > high_ms) {
#line 454
        high_ms = *(saved + i);
      }
      __Cont: /* CIL Label */ 
#line 448
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 446
    at ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  range = high_ms - low_ms;
#line 459
  i = 0;
  {
#line 459
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 459
    if (! (i < 8)) {
#line 459
      goto while_break___2;
    }
#line 460
    scale[i] = (int )((double )low_ms + (double )range * factors[i]);
#line 459
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 462
  return;
}
}
#line 465 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
static char block_map[8]  ;
#line 467 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_init(void) 
{ 
  int i ;
  int block_split ;

  {
#line 472
  i = 0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (i < 8)) {
#line 472
      goto while_break;
    }
#line 473
    factors[i] = ((double )1 / (double )8) * (double )(i + 1);
#line 474
    factors[i] *= factors[i];
#line 472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  block_split = 3;
#line 479
  if (block_split > 9) {
#line 480
    block_split = 9;
  }
#line 482
  i = 1;
  {
#line 482
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 482
    if (! (i <= block_split)) {
#line 482
      goto while_break___0;
    }
#line 483
    block_map[i] = (char )(48 + i);
#line 482
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 485
  i = block_split + 1;
  {
#line 485
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 485
    if (! (i < 7)) {
#line 485
      goto while_break___1;
    }
#line 486
    block_map[i] = (char )(((97 + i) - block_split) - 1);
#line 485
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 488
  block_map[0] = (char )'.';
#line 489
  block_map[7] = (char )'>';
#line 490
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_print_scaled(int ms ) 
{ 
  int i ;

  {
#line 497
  i = 0;
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (i < 8)) {
#line 497
      goto while_break;
    }
#line 498
    if (ms <= scale[i]) {
      {
#line 499
      printw("%c", (int )block_map[i]);
      }
#line 500
      return;
    }
#line 497
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  printw(">");
  }
#line 504
  return;
}
}
#line 507 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_fill_graph(int at , int cols ) 
{ 
  int *saved ;
  int i ;

  {
  {
#line 512
  saved = net_saved_pings(at);
#line 513
  i = 200 - cols;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (i < 200)) {
#line 513
      goto while_break;
    }
#line 514
    if (*(saved + i) == -2) {
      {
#line 515
      printw(" ");
      }
    } else
#line 516
    if (*(saved + i) == -1) {
      {
#line 517
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 518
      printw("?");
#line 519
      wattr_off(stdscr, 1UL << 21, (void *)0);
      }
    } else
#line 521
    if (display_mode == 1) {
#line 522
      if (*(saved + i) > scale[6]) {
        {
#line 523
        printw("%c", (int )block_map[7]);
        }
      } else {
        {
#line 525
        printw(".");
        }
      }
    } else {
      {
#line 528
      mtr_print_scaled(*(saved + i));
      }
    }
#line 513
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 535 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_graph(int startstat , int cols ) 
{ 
  int max ;
  int at ;
  int y ;
  ip_t *addr ;
  char *name ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 541
  max = net_max();
#line 543
  at = display_offset;
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (at < max)) {
#line 543
      goto while_break;
    }
    {
#line 544
    printw("%2d. ", at + 1);
#line 546
    addr = net_addr(at);
    }
#line 547
    if (! addr) {
      {
#line 548
      printw("???\n");
      }
#line 549
      goto __Cont;
    }
    {
#line 552
    tmp = net_up(at);
    }
#line 552
    if (! tmp) {
      {
#line 553
      wattr_on(stdscr, 1UL << 21, (void *)0);
      }
    }
    {
#line 554
    tmp___4 = addrcmp((char *)((void *)addr), (char *)((void *)(& unspec_addr)), af);
    }
#line 554
    if (tmp___4) {
      {
#line 556
      tmp___1 = is_printii();
      }
#line 556
      if (tmp___1) {
        {
#line 557
        tmp___0 = fmt_ipinfo(addr);
#line 557
        printw((char const   *)tmp___0);
        }
      }
      {
#line 559
      name = dns_lookup(addr);
      }
#line 560
      if (name) {
#line 560
        tmp___3 = name;
      } else {
        {
#line 560
        tmp___2 = strlongip(addr);
#line 560
        tmp___3 = tmp___2;
        }
      }
      {
#line 560
      printw("%s", tmp___3);
      }
    } else {
      {
#line 562
      printw("???");
      }
    }
    {
#line 563
    wattr_off(stdscr, 1UL << 21, (void *)0);
    }
#line 565
    if (stdscr) {
#line 565
      y = (int )stdscr->_cury;
    } else {
#line 565
      y = -1;
    }
#line 565
    if (stdscr) {
#line 565
      __unused_int = (int )stdscr->_curx;
    } else {
#line 565
      __unused_int = -1;
    }
    {
#line 566
    wmove(stdscr, y, startstat);
#line 568
    printw(" ");
#line 569
    mtr_fill_graph(at, cols);
#line 570
    printw("\n");
    }
    __Cont: /* CIL Label */ 
#line 543
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  return;
}
}
#line 575 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_redraw(void) 
{ 
  int maxx ;
  int startstat ;
  int rowstat ;
  time_t t ;
  int i ;
  int j ;
  int hd_len ;
  char buf[1024] ;
  char fmt[16] ;
  char *tmp ;
  char *tmp___0 ;
  char msg[80] ;
  int padding ;
  int tmp___1 ;
  int tmp___2 ;
  int max_cols ;
  int tmp___3 ;

  {
  {
#line 583
  hd_len = 0;
#line 588
  werase(stdscr);
  }
#line 589
  if (stdscr) {
#line 589
    __unused_int = (int )stdscr->_maxy + 1;
  } else {
#line 589
    __unused_int = -1;
  }
#line 589
  if (stdscr) {
#line 589
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 589
    maxx = -1;
  }
  {
#line 591
  rowstat = 5;
#line 593
  wmove(stdscr, 0, 0);
#line 594
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 595
  pwcenter((char *)"My traceroute  [v0.85]");
#line 596
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 598
  tmp = net_localaddr();
#line 598
  mvprintw(1, 0, "%s (%s)", LocalHostname, tmp);
#line 614
  time(& t);
#line 615
  tmp___0 = ctime((time_t const   *)(& t));
#line 615
  mvprintw(1, maxx - 25, (char const   *)tmp___0);
#line 617
  printw("Keys:  ");
#line 618
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 618
  printw("H");
#line 618
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 618
  printw("elp   ");
#line 619
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 619
  printw("D");
#line 619
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 619
  printw("isplay mode   ");
#line 620
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 620
  printw("R");
#line 620
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 620
  printw("estart statistics   ");
#line 621
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 621
  printw("O");
#line 621
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 621
  printw("rder of fields   ");
#line 622
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 622
  printw("q");
#line 622
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 622
  printw("uit\n");
  }
#line 624
  if (display_mode == 0) {
#line 625
    i = 0;
    {
#line 625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 625
      if (! (i < 20)) {
#line 625
        goto while_break;
      }
#line 626
      j = fld_index[fld_active[i]];
#line 627
      if (j < 0) {
#line 627
        goto __Cont;
      }
      {
#line 629
      sprintf((char */* __restrict  */)(fmt), (char const   */* __restrict  */)"%%%ds",
              data_fields[j].length);
#line 630
      sprintf((char */* __restrict  */)(buf + hd_len), (char const   */* __restrict  */)(fmt),
              data_fields[j].title);
#line 631
      hd_len += data_fields[j].length;
      }
      __Cont: /* CIL Label */ 
#line 625
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 633
    wattr_on(stdscr, 1UL << 21, (void *)0);
#line 634
    mvprintw(rowstat - 1, 0, " Host");
#line 635
    mvprintw(rowstat - 1, (maxx - hd_len) - 1, "%s", buf);
#line 636
    mvprintw(rowstat - 2, (maxx - hd_len) - 1, "   Packets               Pings");
#line 637
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 639
    wmove(stdscr, rowstat, 0);
#line 640
    mtr_curses_hosts((maxx - hd_len) - 1);
    }
  } else {
    {
#line 644
    padding = 30;
#line 646
    tmp___2 = is_printii();
    }
#line 646
    if (tmp___2) {
      {
#line 647
      tmp___1 = get_iiwidth();
#line 647
      padding += tmp___1;
      }
    }
#line 649
    if (maxx <= 200 + padding) {
#line 649
      tmp___3 = maxx - padding;
    } else {
#line 649
      tmp___3 = 200;
    }
    {
#line 649
    max_cols = tmp___3;
#line 650
    startstat = padding - 2;
#line 652
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)" Last %3d pings",
            max_cols);
#line 653
    mvprintw(rowstat - 1, startstat, (char const   *)(msg));
#line 655
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 656
    wmove(stdscr, rowstat, 0);
#line 658
    mtr_gen_scale();
#line 659
    mtr_curses_graph(startstat, max_cols);
#line 661
    printw("\n");
#line 662
    wattr_on(stdscr, 1UL << 21, (void *)0);
#line 663
    printw("Scale:");
#line 664
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 666
    i = 0;
    }
    {
#line 666
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 666
      if (! (i < 7)) {
#line 666
        goto while_break___0;
      }
      {
#line 667
      printw("  %c:%d ms", (int )block_map[i], scale[i] / 1000);
#line 666
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 671
  wrefresh(stdscr);
  }
#line 672
  return;
}
}
#line 675 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_open(void) 
{ 


  {
  {
#line 677
  initscr();
#line 678
  raw();
#line 679
  noecho();
#line 681
  mtr_curses_init();
#line 682
  mtr_curses_redraw();
  }
#line 683
  return;
}
}
#line 686 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_close(void) 
{ 


  {
  {
#line 688
  printw("\n");
#line 689
  endwin();
  }
#line 690
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/mtr-0.85/curses.c"
void mtr_curses_clear(void) 
{ 


  {
  {
#line 695
  mtr_curses_close();
#line 696
  mtr_curses_open();
  }
#line 697
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 62 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
int dns ;
#line 22 "/home/wheatley/newnew/temp/mtr-0.85/raw.h"
void raw_rawping(int host___0 , int msec ) ;
#line 23
void raw_rawhost(int host___0 , ip_t *ip_addr ) ;
#line 50 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
char *dns_lookup2(ip_t *ip ) ;
#line 36 "/home/wheatley/newnew/temp/mtr-0.85/raw.c"
static int havename[256]  ;
#line 50 "/home/wheatley/newnew/temp/mtr-0.85/raw.c"
void raw_rawping(int host___0 , int msec ) 
{ 
  char *name ;
  ip_t *tmp ;

  {
#line 54
  if (dns) {
#line 54
    if (! havename[host___0]) {
      {
#line 55
      tmp = net_addr(host___0);
#line 55
      name = dns_lookup2(tmp);
      }
#line 56
      if (name) {
        {
#line 57
        (havename[host___0]) ++;
#line 58
        printf((char const   */* __restrict  */)"d %d %s\n", host___0, name);
        }
      }
    }
  }
  {
#line 61
  printf((char const   */* __restrict  */)"p %d %d\n", host___0, msec);
#line 62
  fflush(stdout);
  }
#line 63
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/mtr-0.85/raw.c"
void raw_rawhost(int host___0 , ip_t *ip_addr ) 
{ 
  char *tmp ;

  {
  {
#line 68
  tmp = strlongip(ip_addr);
#line 68
  printf((char const   */* __restrict  */)"h %d %s\n", host___0, tmp);
#line 69
  fflush(stdout);
  }
#line 70
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 76 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
char *trim(char *s ) ;
#line 21 "/home/wheatley/newnew/temp/mtr-0.85/report.h"
void report_open(void) ;
#line 22
void report_close(void) ;
#line 23
void txt_open(void) ;
#line 24
void txt_close(void) ;
#line 25
void xml_open(void) ;
#line 26
void xml_close(void) ;
#line 27
void csv_open(void) ;
#line 28
void csv_close(time_t now ) ;
#line 42 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
int net_last(int at ) ;
#line 55 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
struct hostent *addr2host(char const   *addr , int af___0 ) ;
#line 42 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
char *Hostname ;
#line 48
int MaxPing ;
#line 50
int reportwide ;
#line 53 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
char *get_time_string(void) 
{ 
  time_t now ;
  char *t ;
  size_t tmp ;

  {
  {
#line 57
  now = time((time_t *)((void *)0));
#line 58
  t = ctime((time_t const   *)(& now));
#line 59
  tmp = strlen((char const   *)t);
#line 59
  *(t + (tmp - 1UL)) = (char)0;
  }
#line 60
  return (t);
}
}
#line 63 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void report_open(void) 
{ 
  char *tmp ;

  {
  {
#line 65
  tmp = get_time_string();
#line 65
  printf((char const   */* __restrict  */)"Start: %s\n", tmp);
  }
#line 66
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
static size_t snprint_addr(char *dst , size_t dst_len , ip_t *addr ) 
{ 
  struct hostent *host___0 ;
  struct hostent *tmp ;
  struct hostent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 70
  tmp___7 = addrcmp((char *)((void *)addr), (char *)((void *)(& unspec_addr)), af);
  }
#line 70
  if (tmp___7) {
#line 71
    if (dns) {
      {
#line 71
      tmp = addr2host((char const   *)((void *)addr), af);
#line 71
      tmp___0 = tmp;
      }
    } else {
#line 71
      tmp___0 = (struct hostent *)((void *)0);
    }
#line 71
    host___0 = tmp___0;
#line 72
    if (! host___0) {
      {
#line 72
      tmp___1 = strlongip(addr);
#line 72
      tmp___2 = snprintf((char */* __restrict  */)dst, dst_len, (char const   */* __restrict  */)"%s",
                         tmp___1);
      }
#line 72
      return ((size_t )tmp___2);
    } else
#line 73
    if (dns) {
#line 73
      if (show_ips) {
        {
#line 74
        tmp___3 = strlongip(addr);
#line 74
        tmp___4 = snprintf((char */* __restrict  */)dst, dst_len, (char const   */* __restrict  */)"%s (%s)",
                           host___0->h_name, tmp___3);
        }
#line 74
        return ((size_t )tmp___4);
      } else {
        {
#line 75
        tmp___5 = snprintf((char */* __restrict  */)dst, dst_len, (char const   */* __restrict  */)"%s",
                           host___0->h_name);
        }
#line 75
        return ((size_t )tmp___5);
      }
    } else {
      {
#line 75
      tmp___5 = snprintf((char */* __restrict  */)dst, dst_len, (char const   */* __restrict  */)"%s",
                         host___0->h_name);
      }
#line 75
      return ((size_t )tmp___5);
    }
  } else {
    {
#line 76
    tmp___6 = snprintf((char */* __restrict  */)dst, dst_len, (char const   */* __restrict  */)"%s",
                       "???");
    }
#line 76
    return ((size_t )tmp___6);
  }
}
}
#line 81 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void print_mpls(struct mplslen *mpls ) 
{ 
  int k ;

  {
#line 83
  k = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (k < (int )mpls->labels)) {
#line 83
      goto while_break;
    }
    {
#line 84
    printf((char const   */* __restrict  */)"       [MPLS: Lbl %lu Exp %u S %u TTL %u]\n",
           mpls->label[k], (int )mpls->exp[k], (int )mpls->s[k], (int )mpls->ttl[k]);
#line 83
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void report_close(void) 
{ 
  int i ;
  int j ;
  int at ;
  int max ;
  int z ;
  int w ;
  struct mplslen *mpls ;
  struct mplslen *mplss ;
  ip_t *addr ;
  ip_t *addr2 ;
  char name[81] ;
  char buf[1024] ;
  char fmt[16] ;
  int len ;
  int len_hosts ;
  size_t tmp ;
  int nlen ;
  size_t tmp___0 ;
  int len_tmp ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int found ;
  int tmp___11 ;
  ip_t *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 93
  addr2 = (ip_t *)((void *)0);
#line 97
  len = 0;
#line 98
  len_hosts = 33;
#line 100
  if (reportwide) {
    {
#line 103
    tmp = strlen((char const   *)(LocalHostname));
#line 103
    len_hosts = (int )tmp;
#line 104
    max = net_max();
#line 105
    at = net_min();
    }
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! (at < max)) {
#line 106
        goto while_break;
      }
      {
#line 108
      addr = net_addr(at);
#line 109
      tmp___0 = snprint_addr(name, sizeof(name), addr);
#line 109
      nlen = (int )tmp___0;
      }
#line 109
      if (nlen) {
#line 110
        if (len_hosts < nlen) {
#line 111
          len_hosts = nlen;
        }
      }
#line 106
      at ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 116
  len_tmp = len_hosts;
#line 117
  if (ipinfo_no >= 0) {
#line 118
    ipinfo_no %= iiwidth_len;
#line 119
    if (reportwide) {
      {
#line 120
      len_hosts ++;
#line 121
      tmp___1 = get_iiwidth();
#line 121
      len_tmp += tmp___1;
      }
#line 122
      if (! ipinfo_no) {
#line 123
        len_tmp += 2;
      }
    }
  }
  {
#line 126
  snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"HOST: %%-%ds",
           len_tmp);
#line 130
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)(fmt),
           LocalHostname);
  }
#line 131
  if (reportwide) {
    {
#line 131
    tmp___2 = strlen((char const   *)(buf));
#line 131
    len = (int )tmp___2;
    }
  } else {
#line 131
    len = len_hosts;
  }
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 132
    if (! (i < 20)) {
#line 132
      goto while_break___0;
    }
#line 133
    j = fld_index[fld_active[i]];
#line 134
    if (j < 0) {
#line 134
      goto __Cont;
    }
    {
#line 136
    snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%%%ds",
             data_fields[j].length);
#line 137
    snprintf((char */* __restrict  */)(buf + len), sizeof(buf), (char const   */* __restrict  */)(fmt),
             data_fields[j].title);
#line 138
    len += data_fields[j].length;
    }
    __Cont: /* CIL Label */ 
#line 132
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 140
  printf((char const   */* __restrict  */)"%s\n", buf);
#line 142
  max = net_max();
#line 143
  at = net_min();
  }
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 144
    if (! (at < max)) {
#line 144
      goto while_break___1;
    }
    {
#line 145
    addr = net_addr(at);
#line 146
    tmp___3 = net_mpls(at);
#line 146
    mpls = (struct mplslen *)tmp___3;
#line 147
    snprint_addr(name, sizeof(name), addr);
#line 150
    tmp___5 = is_printii();
    }
#line 150
    if (tmp___5) {
      {
#line 151
      snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)" %%2d. %%s%%-%ds",
               len_hosts);
#line 152
      tmp___4 = fmt_ipinfo(addr);
#line 152
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)(fmt),
               at + 1, tmp___4, name);
      }
    } else {
      {
#line 155
      snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)" %%2d.|-- %%-%ds",
               len_hosts);
#line 156
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)(fmt),
               at + 1, name);
      }
    }
#line 160
    if (reportwide) {
      {
#line 160
      tmp___6 = strlen((char const   *)(buf));
#line 160
      len = (int )tmp___6;
      }
    } else {
#line 160
      len = len_hosts;
    }
#line 161
    i = 0;
    {
#line 161
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 161
      if (! (i < 20)) {
#line 161
        goto while_break___2;
      }
#line 162
      j = fld_index[fld_active[i]];
#line 163
      if (j < 0) {
#line 163
        goto __Cont___0;
      }
      {
#line 166
      tmp___9 = index(data_fields[j].format, 'f');
      }
#line 166
      if (tmp___9) {
        {
#line 167
        tmp___7 = (*(data_fields[j].net_xxx))(at);
#line 167
        snprintf((char */* __restrict  */)(buf + len), sizeof(buf), (char const   */* __restrict  */)data_fields[j].format,
                 (double )tmp___7 / 1000.0);
        }
      } else {
        {
#line 170
        tmp___8 = (*(data_fields[j].net_xxx))(at);
#line 170
        snprintf((char */* __restrict  */)(buf + len), sizeof(buf), (char const   */* __restrict  */)data_fields[j].format,
                 tmp___8);
        }
      }
#line 173
      len += data_fields[j].length;
      __Cont___0: /* CIL Label */ 
#line 161
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 175
    printf((char const   */* __restrict  */)"%s\n", buf);
#line 180
    z = 1;
    }
    {
#line 180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 180
      if (! (z < 8)) {
#line 180
        goto while_break___3;
      }
      {
#line 181
      addr2 = net_addrs(at, z);
#line 182
      tmp___10 = net_mplss(at, z);
#line 182
      mplss = (struct mplslen *)tmp___10;
#line 183
      found = 0;
#line 184
      tmp___11 = addrcmp((char *)((void *)(& unspec_addr)), (char *)((void *)addr2),
                         af);
      }
#line 184
      if (tmp___11 == 0) {
#line 185
        goto while_break___3;
      }
#line 186
      w = 0;
      {
#line 186
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 186
        if (! (w < z)) {
#line 186
          goto while_break___4;
        }
        {
#line 188
        tmp___12 = net_addrs(at, w);
#line 188
        tmp___13 = addrcmp((char *)((void *)addr2), (char *)((void *)tmp___12), af);
        }
#line 188
        if (tmp___13 == 0) {
#line 189
          found = 1;
#line 190
          goto while_break___4;
        }
#line 186
        w ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 193
      if (! found) {
        {
#line 196
        tmp___15 = is_printii();
        }
#line 196
        if (tmp___15) {
#line 197
          if (mpls->labels) {
#line 197
            if (z == 1) {
#line 197
              if (enablempls) {
                {
#line 198
                print_mpls(mpls);
                }
              }
            }
          }
          {
#line 199
          snprint_addr(name, sizeof(name), addr2);
#line 200
          tmp___14 = fmt_ipinfo(addr2);
#line 200
          printf((char const   */* __restrict  */)"     %s%s\n", tmp___14, name);
          }
#line 201
          if (enablempls) {
            {
#line 202
            print_mpls(mplss);
            }
          }
        }
      }
#line 180
      z ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 232
    tmp___16 = is_printii();
    }
#line 232
    if (tmp___16) {
#line 233
      if (mpls->labels) {
#line 233
        if (z == 1) {
#line 233
          if (enablempls) {
            {
#line 234
            print_mpls(mpls);
            }
          }
        }
      }
    }
#line 144
    at ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void txt_open(void) 
{ 


  {
#line 253
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void txt_close(void) 
{ 


  {
  {
#line 258
  report_close();
  }
#line 259
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void xml_open(void) 
{ 


  {
#line 265
  return;
}
}
#line 268 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void xml_close(void) 
{ 
  int i ;
  int j ;
  int at ;
  int max ;
  ip_t *addr ;
  char name[81] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 274
  printf((char const   */* __restrict  */)"<MTR SRC=%s DST=%s", LocalHostname, Hostname);
#line 275
  printf((char const   */* __restrict  */)" TOS=0x%X", tos);
  }
#line 276
  if (cpacketsize >= 0) {
    {
#line 277
    printf((char const   */* __restrict  */)" PSIZE=%d", cpacketsize);
    }
  } else {
    {
#line 279
    printf((char const   */* __restrict  */)" PSIZE=rand(%d-%d)", 28, - cpacketsize);
    }
  }
#line 281
  if (bitpattern >= 0) {
    {
#line 282
    printf((char const   */* __restrict  */)" BITPATTERN=0x%02X", (int )((unsigned char )bitpattern));
    }
  } else {
    {
#line 284
    printf((char const   */* __restrict  */)" BITPATTERN=rand(0x00-FF)");
    }
  }
  {
#line 286
  printf((char const   */* __restrict  */)" TESTS=%d>\n", MaxPing);
#line 288
  max = net_max();
#line 289
  at = net_min();
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (at < max)) {
#line 290
      goto while_break;
    }
    {
#line 291
    addr = net_addr(at);
#line 292
    snprint_addr(name, sizeof(name), addr);
#line 294
    printf((char const   */* __restrict  */)"    <HUB COUNT=%d HOST=%s>\n", at + 1,
           name);
#line 295
    i = 0;
    }
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < 20)) {
#line 295
        goto while_break___0;
      }
#line 296
      j = fld_index[fld_active[i]];
#line 297
      if (j < 0) {
#line 297
        goto __Cont;
      }
      {
#line 299
      strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)"        <%s>");
#line 300
      strcat((char */* __restrict  */)(name), (char const   */* __restrict  */)data_fields[j].format);
#line 301
      strcat((char */* __restrict  */)(name), (char const   */* __restrict  */)"</%s>\n");
#line 303
      tmp___1 = index(data_fields[j].format, 'f');
      }
#line 303
      if (tmp___1) {
        {
#line 304
        tmp = (*(data_fields[j].net_xxx))(at);
#line 304
        printf((char const   */* __restrict  */)(name), data_fields[j].title, (double )tmp / 1000.0,
               data_fields[j].title);
        }
      } else {
        {
#line 309
        tmp___0 = (*(data_fields[j].net_xxx))(at);
#line 309
        printf((char const   */* __restrict  */)(name), data_fields[j].title, tmp___0,
               data_fields[j].title);
        }
      }
      __Cont: /* CIL Label */ 
#line 295
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 315
    printf((char const   */* __restrict  */)"    </HUB>\n");
#line 290
    at ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  printf((char const   */* __restrict  */)"</MTR>\n");
  }
#line 318
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void csv_open(void) 
{ 


  {
#line 323
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtr-0.85/report.c"
void csv_close(time_t now ) 
{ 
  int i ;
  int j ;
  int at ;
  int max ;
  ip_t *addr ;
  char name[81] ;
  int last ;
  int tmp ;
  char *fmtinfo___0 ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 331
  i = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < 20)) {
#line 331
      goto while_break;
    }
#line 332
    j = fld_index[fld_active[i]];
#line 333
    if (j < 0) {

    }
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  max = net_max();
#line 337
  at = net_min();
  }
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (at < max)) {
#line 338
      goto while_break___0;
    }
    {
#line 339
    addr = net_addr(at);
#line 340
    snprint_addr(name, sizeof(name), addr);
#line 342
    tmp = net_last(at);
#line 342
    last = tmp;
    }
#line 343
    if (! ipinfo_no) {
      {
#line 344
      tmp___0 = fmt_ipinfo(addr);
#line 344
      fmtinfo___0 = tmp___0;
      }
#line 345
      if ((unsigned long )fmtinfo___0 != (unsigned long )((void *)0)) {
        {
#line 345
        fmtinfo___0 = trim(fmtinfo___0);
        }
      }
      {
#line 346
      printf((char const   */* __restrict  */)"MTR.%s;%lu;%s;%s;%d;%s;%s;%d", "0.85",
             now, "OK", Hostname, at + 1, name, fmtinfo___0, last);
      }
    } else {
      {
#line 349
      printf((char const   */* __restrict  */)"MTR.%s;%lu;%s;%s;%d;%s;%d", "0.85",
             now, "OK", Hostname, at + 1, name, last);
      }
    }
#line 353
    i = 0;
    {
#line 353
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 353
      if (! (i < 20)) {
#line 353
        goto while_break___1;
      }
#line 354
      j = fld_index[fld_active[j]];
#line 355
      if (j < 0) {
#line 355
        goto __Cont___0;
      }
      {
#line 358
      tmp___3 = index(data_fields[j].format, 'f');
      }
#line 358
      if (tmp___3) {
        {
#line 359
        tmp___1 = (*(data_fields[j].net_xxx))(at);
#line 359
        printf((char const   */* __restrict  */)", %.2f", (double )tmp___1 / 1000.0);
        }
      } else {
        {
#line 361
        tmp___2 = (*(data_fields[j].net_xxx))(at);
#line 361
        printf((char const   */* __restrict  */)", %d", tmp___2);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 353
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 364
    printf((char const   */* __restrict  */)"\n");
#line 338
    at ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 366
  return;
}
}
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 58 "./getopt.h"
extern char *optarg ;
#line 72
extern int optind ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 158 "/home/wheatley/newnew/temp/mtr-0.85/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 33 "/home/wheatley/newnew/temp/mtr-0.85/display.h"
void display_detect(int *argc , char ***argv ) ;
#line 34
void display_open(void) ;
#line 35
void display_close(time_t now ) ;
#line 40
void display_loop(void) ;
#line 43 "/home/wheatley/newnew/temp/mtr-0.85/display.h"
int display_mode  ;
#line 25 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
void dns_open(void) ;
#line 29 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
int net_preopen(void) ;
#line 30
int net_selectsocket(void) ;
#line 31
int net_open(struct hostent *host___0 ) ;
#line 33
int net_set_interfaceaddress(char *InterfaceAddress___0 ) ;
#line 35
void net_close(void) ;
#line 46
int net_loss(int at ) ;
#line 47
int net_drop(int at ) ;
#line 49
int net_best(int at ) ;
#line 50
int net_worst(int at ) ;
#line 51
int net_avg(int at ) ;
#line 52
int net_gmean(int at ) ;
#line 53
int net_stdev(int at ) ;
#line 54
int net_jitter(int at ) ;
#line 55
int net_jworst(int at ) ;
#line 56
int net_javg(int at ) ;
#line 57
int net_jinta(int at ) ;
#line 62
void net_end_transit(void) ;
#line 66
int net_returned(int at ) ;
#line 67
int net_xmit(int at ) ;
#line 122 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
int fld_index[256]  ;
#line 124 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
char available_options[20]  ;
#line 62 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int DisplayMode  ;
#line 64 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int Interactive  =    1;
#line 65 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int PrintVersion  =    0;
#line 66 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int PrintHelp  =    0;
#line 67 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int MaxPing  =    10;
#line 68 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int ForceMaxPing  =    0;
#line 69 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
float WaitTime  =    (float )1.0;
#line 70 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
char *Hostname  =    (char *)((void *)0);
#line 71 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
char *InterfaceAddress  =    (char *)((void *)0);
#line 72 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
char LocalHostname[128]  ;
#line 73 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int dns  =    1;
#line 74 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int show_ips  =    0;
#line 75 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int enablempls  =    0;
#line 76 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int cpacketsize  =    64;
#line 77 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int bitpattern  =    0;
#line 78 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int tos  =    0;
#line 79 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int reportwide  =    0;
#line 80 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int af  =    0;
#line 81 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int mtrtype  =    1;
#line 84 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int fstTTL  =    1;
#line 86 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int maxTTL  =    30;
#line 88 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int remoteport  =    80;
#line 89 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int timeout  =    10000000;
#line 93 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
unsigned char fld_active[40]  = 
#line 93
  {      (unsigned char )'L',      (unsigned char )'S',      (unsigned char )' ',      (unsigned char )'N', 
        (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'W',      (unsigned char )'V', 
        (unsigned char )'\000'};
#line 98 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
struct fields data_fields[20]  = 
#line 98
  {      {(unsigned char const   )' ', "<sp>: Space between fields", " ", " ", 1, (int (*)())(& net_drop)}, 
        {(unsigned char const   )'L',
      "L: Loss Ratio", "Loss%", " %4.1f%%", 6, (int (*)())(& net_loss)}, 
        {(unsigned char const   )'D', "D: Dropped Packets", "Drop", " %4d", 5, (int (*)())(& net_drop)}, 
        {(unsigned char const   )'R',
      "R: Received Packets", "Rcv", " %5d", 6, (int (*)())(& net_returned)}, 
        {(unsigned char const   )'S', "S: Sent Packets", "Snt", " %5d", 6, (int (*)())(& net_xmit)}, 
        {(unsigned char const   )'N',
      "N: Newest RTT(ms)", "Last", " %5.1f", 6, (int (*)())(& net_last)}, 
        {(unsigned char const   )'B', "B: Min/Best RTT(ms)", "Best", " %5.1f", 6, (int (*)())(& net_best)}, 
        {(unsigned char const   )'A',
      "A: Average RTT(ms)", "Avg", " %5.1f", 6, (int (*)())(& net_avg)}, 
        {(unsigned char const   )'W', "W: Max/Worst RTT(ms)", "Wrst", " %5.1f", 6, (int (*)())(& net_worst)}, 
        {(unsigned char const   )'V',
      "V: Standard Deviation", "StDev", " %5.1f", 6, (int (*)())(& net_stdev)}, 
        {(unsigned char const   )'G', "G: Geometric Mean", "Gmean", " %5.1f", 6, (int (*)())(& net_gmean)}, 
        {(unsigned char const   )'J',
      "J: Current Jitter", "Jttr", " %4.1f", 5, (int (*)())(& net_jitter)}, 
        {(unsigned char const   )'M', "M: Jitter Mean/Avg.", "Javg", " %4.1f", 5, (int (*)())(& net_javg)}, 
        {(unsigned char const   )'X',
      "X: Worst Jitter", "Jmax", " %4.1f", 5, (int (*)())(& net_jworst)}, 
        {(unsigned char const   )'I', "I: Interarrival Jitter", "Jint", " %4.1f", 5,
      (int (*)())(& net_jinta)}, 
        {(unsigned char const   )'\000', (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0), 0, (int (*)())((void *)0)}};
#line 122 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static names_t *names  =    (names_t *)((void *)0);
#line 124 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
char *trim(char *s ) 
{ 
  char *p ;
  int l ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 127
  p = s;
#line 128
  tmp = strlen((char const   *)p);
#line 128
  l = (int )tmp;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    tmp___0 = __ctype_b_loc();
    }
#line 130
    if ((int const   )*(*tmp___0 + (int )*(p + (l - 1))) & 8192) {
#line 130
      if (! l) {
#line 130
        goto while_break;
      }
    } else {
#line 130
      goto while_break;
    }
#line 130
    l --;
#line 130
    *(p + l) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (*p) {
      {
#line 131
      tmp___1 = __ctype_b_loc();
      }
#line 131
      if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
#line 131
        if (! l) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
    } else {
#line 131
      goto while_break___0;
    }
#line 131
    p ++;
#line 131
    l --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return (p);
}
}
#line 136 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static void append_to_names(char const   *progname , char const   *item ) 
{ 
  names_t *name ;
  void *tmp ;

  {
  {
#line 139
  tmp = calloc((size_t )1, sizeof(names_t ));
#line 139
  name = (names_t *)tmp;
  }
#line 140
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: memory allocation failure\n",
            progname);
#line 142
    exit(1);
    }
  }
  {
#line 144
  name->name = strdup(item);
#line 145
  name->next = names;
#line 146
  names = name;
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static void read_from_file(char const   *progname , char const   *filename ) 
{ 
  FILE *in ;
  char line[512] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 155
  if (! filename) {
    {
#line 156
    clearerr(stdin);
#line 157
    in = stdin;
    }
  } else {
    {
#line 155
    tmp___1 = strcmp(filename, "-");
    }
#line 155
    if (tmp___1 == 0) {
      {
#line 156
      clearerr(stdin);
#line 157
      in = stdin;
      }
    } else {
      {
#line 159
      in = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
#line 160
      if (! in) {
        {
#line 161
        tmp = __errno_location();
#line 161
        tmp___0 = strerror(*tmp);
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fopen: %s\n",
                progname, tmp___0);
#line 162
        exit(1);
        }
      }
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    tmp___3 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)in);
    }
#line 166
    if (! tmp___3) {
#line 166
      goto while_break;
    }
    {
#line 167
    tmp___2 = trim(line);
#line 167
    name = tmp___2;
#line 168
    append_to_names(progname, (char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  tmp___6 = ferror(in);
  }
#line 171
  if (tmp___6) {
    {
#line 172
    tmp___4 = __errno_location();
#line 172
    tmp___5 = strerror(*tmp___4);
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ferror: %s\n",
            progname, tmp___5);
#line 173
    exit(1);
    }
  }
#line 176
  if ((unsigned long )in != (unsigned long )stdin) {
    {
#line 176
    fclose(in);
    }
  }
#line 177
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static struct flock lock___0  ;
#line 186 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static void lock(char const   *progname , FILE *f ) 
{ 
  int fd ;
  struct stat buf ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 192
  if (! f) {
    {
#line 192
    __assert_fail("f", "/home/wheatley/newnew/temp/mtr-0.85/mtr.c", 192U, "lock");
    }
  }
  {
#line 194
  lock___0.l_type = (short)1;
#line 195
  lock___0.l_start = (__off_t )0;
#line 196
  lock___0.l_whence = (short)2;
#line 197
  lock___0.l_len = (__off_t )0;
#line 198
  lock___0.l_pid = getpid();
#line 200
  fd = fileno(f);
#line 201
  tmp___2 = fstat(fd, & buf);
  }
#line 201
  if (tmp___2 == 0) {
#line 201
    if ((buf.st_mode & 61440U) == 32768U) {
      {
#line 202
      tmp___1 = fcntl(fd, 7, & lock___0);
      }
#line 202
      if (tmp___1 == -1) {
        {
#line 203
        tmp = __errno_location();
#line 203
        tmp___0 = strerror(*tmp);
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fcntl: %s (ignored)\n",
                progname, tmp___0);
        }
      }
    }
  }
#line 207
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static struct flock lock___1  ;
#line 214 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static void unlock(char const   *progname , FILE *f ) 
{ 
  int fd ;
  struct stat buf ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 220
  if (! f) {
    {
#line 220
    __assert_fail("f", "/home/wheatley/newnew/temp/mtr-0.85/mtr.c", 220U, "unlock");
    }
  }
  {
#line 222
  lock___1.l_type = (short)2;
#line 223
  lock___1.l_start = (__off_t )0;
#line 224
  lock___1.l_whence = (short)2;
#line 225
  lock___1.l_len = (__off_t )0;
#line 226
  lock___1.l_pid = getpid();
#line 228
  fd = fileno(f);
#line 229
  tmp___2 = fstat(fd, & buf);
  }
#line 229
  if (tmp___2 == 0) {
#line 229
    if ((buf.st_mode & 61440U) == 32768U) {
      {
#line 230
      tmp___1 = fcntl(fd, 7, & lock___1);
      }
#line 230
      if (tmp___1 == -1) {
        {
#line 231
        tmp = __errno_location();
#line 231
        tmp___0 = strerror(*tmp);
#line 231
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fcntl: %s (ignored)\n",
                progname, tmp___0);
        }
      }
    }
  }
#line 235
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
void init_fld_options(void) 
{ 
  int i ;

  {
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 256)) {
#line 242
      goto while_break;
    }
#line 243
    fld_index[i] = -1;
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 245
    if (! ((int const   )data_fields[i].key != 0)) {
#line 245
      goto while_break___0;
    }
#line 246
    available_options[i] = (char )data_fields[i].key;
#line 247
    fld_index[data_fields[i].key] = i;
#line 245
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 249
  available_options[i] = (char)0;
#line 250
  return;
}
}
#line 257
void parse_arg(int argc , char **argv ) ;
#line 257 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
static struct option long_options[32]  = 
#line 257
  {      {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"report", 0, (int *)0, 'r'}, 
        {"report-wide", 0, (int *)0, 'w'}, 
        {"xml", 0, (int *)0, 'x'}, 
        {"curses", 0, (int *)0, 't'}, 
        {"gtk", 0, (int *)0, 'g'}, 
        {"raw", 0, (int *)0, 'l'}, 
        {"csv", 0, (int *)0, 'C'}, 
        {"split", 0, (int *)0, 'p'}, 
        {"order", 1, (int *)0, 'o'}, 
        {"interval", 1, (int *)0, 'i'}, 
        {"report-cycles", 1, (int *)0, 'c'}, 
        {"psize", 1, (int *)0, 's'}, 
        {"bitpattern", 1, (int *)0, 'B'}, 
        {"tos", 1, (int *)0, 'Q'}, 
        {"mpls", 0, (int *)0, 'e'}, 
        {"no-dns", 0, (int *)0, 'n'}, 
        {"show-ips", 0, (int *)0, 'b'}, 
        {"address", 1, (int *)0, 'a'}, 
        {"first-ttl", 1, (int *)0, 'f'}, 
        {"filename", 1, (int *)0, 'F'}, 
        {"max-ttl", 1, (int *)0, 'm'}, 
        {"udp", 0, (int *)0, 'u'}, 
        {"tcp", 0, (int *)0, 'T'}, 
        {"port", 1, (int *)0, 'P'}, 
        {"timeout", 1, (int *)0, 'Z'}, 
        {"inet", 0, (int *)0, '4'}, 
        {"inet6", 0, (int *)0, '6'}, 
        {"ipinfo", 1, (int *)0, 'y'}, 
        {"aslookup", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 253 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
void parse_arg(int argc , char **argv ) 
{ 
  int opt ;
  int i ;
  double tmp ;
  __uid_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 299
  opt = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    opt = getopt_long(argc, (char * const  *)argv, "vhrwxtglCpo:B:i:c:s:Q:ena:f:m:uTP:Zby:z46",
                      (struct option  const  *)(long_options), (int *)((void *)0));
    }
#line 304
    if (opt == -1) {
#line 305
      goto while_break;
    }
    {
#line 308
    if (opt == 118) {
#line 308
      goto case_118;
    }
#line 311
    if (opt == 104) {
#line 311
      goto case_104;
    }
#line 315
    if (opt == 114) {
#line 315
      goto case_114;
    }
#line 318
    if (opt == 119) {
#line 318
      goto case_119;
    }
#line 322
    if (opt == 116) {
#line 322
      goto case_116;
    }
#line 325
    if (opt == 103) {
#line 325
      goto case_103;
    }
#line 328
    if (opt == 112) {
#line 328
      goto case_112;
    }
#line 331
    if (opt == 108) {
#line 331
      goto case_108;
    }
#line 334
    if (opt == 67) {
#line 334
      goto case_67;
    }
#line 337
    if (opt == 120) {
#line 337
      goto case_120;
    }
#line 341
    if (opt == 99) {
#line 341
      goto case_99;
    }
#line 345
    if (opt == 115) {
#line 345
      goto case_115;
    }
#line 348
    if (opt == 97) {
#line 348
      goto case_97;
    }
#line 351
    if (opt == 101) {
#line 351
      goto case_101;
    }
#line 354
    if (opt == 110) {
#line 354
      goto case_110;
    }
#line 357
    if (opt == 105) {
#line 357
      goto case_105;
    }
#line 368
    if (opt == 102) {
#line 368
      goto case_102;
    }
#line 377
    if (opt == 70) {
#line 377
      goto case_70;
    }
#line 380
    if (opt == 109) {
#line 380
      goto case_109;
    }
#line 392
    if (opt == 111) {
#line 392
      goto case_111;
    }
#line 406
    if (opt == 66) {
#line 406
      goto case_66;
    }
#line 411
    if (opt == 81) {
#line 411
      goto case_81;
    }
#line 419
    if (opt == 117) {
#line 419
      goto case_117;
    }
#line 426
    if (opt == 84) {
#line 426
      goto case_84;
    }
#line 433
    if (opt == 98) {
#line 433
      goto case_98;
    }
#line 436
    if (opt == 80) {
#line 436
      goto case_80;
    }
#line 443
    if (opt == 90) {
#line 443
      goto case_90;
    }
#line 447
    if (opt == 52) {
#line 447
      goto case_52;
    }
#line 450
    if (opt == 54) {
#line 450
      goto case_54;
    }
#line 459
    if (opt == 121) {
#line 459
      goto case_121;
    }
#line 464
    if (opt == 122) {
#line 464
      goto case_122;
    }
#line 307
    goto switch_break;
    case_118: /* CIL Label */ 
#line 309
    PrintVersion = 1;
#line 310
    goto switch_break;
    case_104: /* CIL Label */ 
#line 312
    PrintHelp = 1;
#line 313
    goto switch_break;
    case_114: /* CIL Label */ 
#line 316
    DisplayMode = 0;
#line 317
    goto switch_break;
    case_119: /* CIL Label */ 
#line 319
    reportwide = 1;
#line 320
    DisplayMode = 0;
#line 321
    goto switch_break;
    case_116: /* CIL Label */ 
#line 323
    DisplayMode = 1;
#line 324
    goto switch_break;
    case_103: /* CIL Label */ 
#line 326
    DisplayMode = 2;
#line 327
    goto switch_break;
    case_112: /* CIL Label */ 
#line 329
    DisplayMode = 3;
#line 330
    goto switch_break;
    case_108: /* CIL Label */ 
#line 332
    DisplayMode = 4;
#line 333
    goto switch_break;
    case_67: /* CIL Label */ 
#line 335
    DisplayMode = 6;
#line 336
    goto switch_break;
    case_120: /* CIL Label */ 
#line 338
    DisplayMode = 5;
#line 339
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 342
    MaxPing = atoi((char const   *)optarg);
#line 343
    ForceMaxPing = 1;
    }
#line 344
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 346
    cpacketsize = atoi((char const   *)optarg);
    }
#line 347
    goto switch_break;
    case_97: /* CIL Label */ 
#line 349
    InterfaceAddress = optarg;
#line 350
    goto switch_break;
    case_101: /* CIL Label */ 
#line 352
    enablempls = 1;
#line 353
    goto switch_break;
    case_110: /* CIL Label */ 
#line 355
    dns = 0;
#line 356
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 358
    tmp = atof((char const   *)optarg);
#line 358
    WaitTime = (float )tmp;
    }
#line 359
    if ((double )WaitTime <= 0.0) {
      {
#line 360
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: wait time must be positive\n");
#line 361
      exit(1);
      }
    }
    {
#line 363
    tmp___0 = getuid();
    }
#line 363
    if (tmp___0 != 0U) {
#line 363
      if ((double )WaitTime < 1.0) {
        {
#line 364
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"non-root users cannot request an interval < 1.0 seconds\r\n");
#line 365
        exit(1);
        }
      }
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    fstTTL = atoi((char const   *)optarg);
    }
#line 370
    if (fstTTL > maxTTL) {
#line 371
      fstTTL = maxTTL;
    }
#line 373
    if (fstTTL < 1) {
#line 374
      fstTTL = 1;
    }
#line 376
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 378
    read_from_file((char const   *)*(argv + 0), (char const   *)optarg);
    }
#line 379
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 381
    maxTTL = atoi((char const   *)optarg);
    }
#line 382
    if (maxTTL > 255) {
#line 383
      maxTTL = 255;
    }
#line 385
    if (maxTTL < 1) {
#line 386
      maxTTL = 1;
    }
#line 388
    if (fstTTL > maxTTL) {
#line 389
      fstTTL = maxTTL;
    }
#line 391
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 394
    tmp___1 = strlen((char const   *)optarg);
    }
#line 394
    if (tmp___1 > 20UL) {
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many fields: %s\n",
              optarg);
#line 396
      exit(1);
      }
    }
#line 398
    i = 0;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! *(optarg + i)) {
#line 398
        goto while_break___0;
      }
      {
#line 399
      tmp___2 = strchr((char const   *)(available_options), (int )*(optarg + i));
      }
#line 399
      if (! tmp___2) {
        {
#line 400
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown field identifier: %c\n",
                (int )*(optarg + i));
#line 401
        exit(1);
        }
      }
#line 398
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 404
    strcpy((char */* __restrict  */)((char *)(fld_active)), (char const   */* __restrict  */)optarg);
    }
#line 405
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 407
    bitpattern = atoi((char const   *)optarg);
    }
#line 408
    if (bitpattern > 255) {
#line 409
      bitpattern = -1;
    }
#line 410
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 412
    tos = atoi((char const   *)optarg);
    }
#line 413
    if (tos > 255) {
#line 416
      tos = 0;
    } else
#line 413
    if (tos < 0) {
#line 416
      tos = 0;
    }
#line 418
    goto switch_break;
    case_117: /* CIL Label */ 
#line 420
    if (mtrtype != 1) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u and -T are mutually exclusive.\n");
#line 422
      exit(1);
      }
    }
#line 424
    mtrtype = 17;
#line 425
    goto switch_break;
    case_84: /* CIL Label */ 
#line 427
    if (mtrtype != 1) {
      {
#line 428
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u and -T are mutually exclusive.\n");
#line 429
      exit(1);
      }
    }
#line 431
    mtrtype = 6;
#line 432
    goto switch_break;
    case_98: /* CIL Label */ 
#line 434
    show_ips = 1;
#line 435
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 437
    remoteport = atoi((char const   *)optarg);
    }
#line 438
    if (remoteport > 65535) {
      {
#line 439
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal port number.\n");
#line 440
      exit(1);
      }
    } else
#line 438
    if (remoteport < 1) {
      {
#line 439
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal port number.\n");
#line 440
      exit(1);
      }
    }
#line 442
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 444
    timeout = atoi((char const   *)optarg);
#line 445
    timeout *= 1000000;
    }
#line 446
    goto switch_break;
    case_52: /* CIL Label */ 
#line 448
    af = 2;
#line 449
    goto switch_break;
    case_54: /* CIL Label */ 
#line 452
    af = 10;
#line 453
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 460
    ipinfo_no = atoi((char const   *)optarg);
    }
#line 461
    if (ipinfo_no < 0) {
#line 462
      ipinfo_no = 0;
    }
#line 463
    goto switch_break;
    case_122: /* CIL Label */ 
#line 465
    ipinfo_no = 0;
#line 466
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (DisplayMode == 0) {
#line 476
    Interactive = 0;
  } else
#line 471
  if (DisplayMode == 7) {
#line 476
    Interactive = 0;
  } else
#line 471
  if (DisplayMode == 5) {
#line 476
    Interactive = 0;
  } else
#line 471
  if (DisplayMode == 4) {
#line 476
    Interactive = 0;
  } else
#line 471
  if (DisplayMode == 6) {
#line 476
    Interactive = 0;
  }
#line 478
  if (optind > argc - 1) {
#line 479
    return;
  }
#line 481
  return;
}
}
#line 484 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
void parse_mtr_options(char *string ) 
{ 
  int argc ;
  char *argv[128] ;
  char *p ;
  int tmp ;

  {
#line 489
  if (! string) {
#line 489
    return;
  }
  {
#line 491
  argv[0] = (char *)"mtr";
#line 492
  argc = 1;
#line 493
  p = strtok((char */* __restrict  */)string, (char const   */* __restrict  */)" \t");
  }
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 494
      if (! ((size_t )argc < sizeof(argv) / sizeof(argv[0]))) {
#line 494
        goto while_break;
      }
    } else {
#line 494
      goto while_break;
    }
    {
#line 495
    tmp = argc;
#line 495
    argc ++;
#line 495
    argv[tmp] = p;
#line 496
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: extra arguments ignored: %s",
            p);
    }
  }
  {
#line 502
  parse_arg(argc, argv);
#line 503
  optind = 0;
  }
#line 504
  return;
}
}
#line 507 "/home/wheatley/newnew/temp/mtr-0.85/mtr.c"
int main(int argc , char **argv ) 
{ 
  struct hostent *host___0 ;
  int net_preopen_result ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  int error ;
  struct hostent trhost ;
  char *alptr[2] ;
  struct sockaddr_in *sa4 ;
  struct sockaddr_in6 *sa6 ;
  __gid_t tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;
  __gid_t tmp___5 ;
  __gid_t tmp___6 ;
  __pid_t tmp___7 ;
  char *tmp___8 ;
  char *name ;
  int tmp___9 ;
  int tmp___10 ;
  time_t now ;
  time_t tmp___11 ;
  names_t *head ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  names_t *item ;

  {
  {
#line 509
  host___0 = (struct hostent *)((void *)0);
#line 522
  net_preopen_result = net_preopen();
  }
#line 522
  if (net_preopen_result) {
    {
#line 523
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: unable to get raw sockets.\n");
#line 524
    exit(1);
    }
  }
  {
#line 528
  tmp = getgid();
#line 528
  tmp___0 = setgid(tmp);
  }
#line 528
  if (tmp___0) {
    {
#line 529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to drop permissions.\n");
#line 530
    exit(1);
    }
  } else {
    {
#line 528
    tmp___1 = getuid();
#line 528
    tmp___2 = setuid(tmp___1);
    }
#line 528
    if (tmp___2) {
      {
#line 529
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to drop permissions.\n");
#line 530
      exit(1);
      }
    }
  }
  {
#line 534
  tmp___3 = geteuid();
#line 534
  tmp___4 = getuid();
  }
#line 534
  if (tmp___3 != tmp___4) {
    {
#line 535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to drop permissions.\n");
#line 536
    exit(1);
    }
  } else {
    {
#line 534
    tmp___5 = getegid();
#line 534
    tmp___6 = getgid();
    }
#line 534
    if (tmp___5 != tmp___6) {
      {
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to drop permissions.\n");
#line 536
      exit(1);
      }
    }
  }
  {
#line 540
  tmp___7 = getpid();
#line 540
  srand((unsigned int )tmp___7);
#line 542
  display_detect(& argc, & argv);
#line 546
  init_fld_options();
#line 548
  tmp___8 = getenv("MTR_OPTIONS");
#line 548
  parse_mtr_options(tmp___8);
#line 550
  parse_arg(argc, argv);
  }
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! (optind < argc)) {
#line 552
      goto while_break;
    }
    {
#line 553
    tmp___9 = optind;
#line 553
    optind ++;
#line 553
    name = *(argv + tmp___9);
#line 554
    append_to_names((char const   *)*(argv + 0), (char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  tmp___10 = net_selectsocket();
  }
#line 558
  if (tmp___10 != 0) {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Couldn\'t determine raw socket type.\n");
#line 560
    exit(1);
    }
  }
#line 563
  if (PrintVersion) {
    {
#line 564
    printf((char const   */* __restrict  */)"mtr 0.85\n");
#line 565
    exit(0);
    }
  }
#line 568
  if (PrintHelp) {
    {
#line 569
    printf((char const   */* __restrict  */)"usage: %s [-hvrwctglspniuT46] [--help] [--version] [--report]\n\t\t[--report-wide] [--report-cycles=COUNT] [--curses] [--gtk]\n\t\t[--csv|-C] [--raw] [--split] [--mpls] [--no-dns] [--show-ips]\n\t\t[--address interface] [--filename=FILE|-F]\n\t\t[--ipinfo=item_no|-y item_no]\n\t\t[--aslookup|-z]\n\t\t[--psize=bytes/-s bytes]\n\t\t[--report-wide|-w] [-u|-T] [--port=PORT] [--timeout=SECONDS]\n\t\t[--interval=SECONDS] HOSTNAME\n",
           *(argv + 0));
#line 580
    exit(0);
    }
  }
  {
#line 583
  tmp___11 = time((time_t *)((void *)0));
#line 583
  now = tmp___11;
#line 584
  head = names;
  }
  {
#line 585
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 585
    if (! ((unsigned long )names != (unsigned long )((void *)0))) {
#line 585
      goto while_break___0;
    }
#line 587
    Hostname = names->name;
#line 588
    if ((unsigned long )Hostname == (unsigned long )((void *)0)) {
#line 588
      Hostname = (char *)"localhost";
    }
    {
#line 589
    tmp___12 = gethostname(LocalHostname, sizeof(LocalHostname));
    }
#line 589
    if (tmp___12) {
      {
#line 590
      strcpy((char */* __restrict  */)(LocalHostname), (char const   */* __restrict  */)"UNKNOWNHOST");
      }
    }
#line 593
    if (net_preopen_result != 0) {
      {
#line 594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to get raw socket.  (Executable not suid?)\n");
      }
#line 595
      if (DisplayMode != 6) {
        {
#line 595
        exit(1);
        }
      } else {
#line 597
        names = names->next;
#line 598
        goto while_continue___0;
      }
    }
    {
#line 604
    bzero((void *)(& hints), sizeof(hints));
#line 605
    hints.ai_family = af;
#line 606
    hints.ai_socktype = 2;
#line 607
    error = getaddrinfo((char const   */* __restrict  */)Hostname, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
    }
#line 608
    if (error) {
#line 609
      if (error == -11) {
        {
#line 610
        perror("Failed to resolve host");
        }
      } else {
        {
#line 612
        tmp___13 = gai_strerror(error);
#line 612
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to resolve host: %s\n",
                tmp___13);
        }
      }
#line 614
      if (DisplayMode != 6) {
        {
#line 614
        exit(1);
        }
      } else {
#line 616
        names = names->next;
#line 617
        goto while_continue___0;
      }
    }
    {
#line 621
    host___0 = & trhost;
#line 622
    bzero((void *)host___0, sizeof(trhost));
#line 623
    host___0->h_name = res->ai_canonname;
#line 624
    host___0->h_aliases = (char **)((void *)0);
#line 625
    host___0->h_addrtype = res->ai_family;
#line 626
    af = res->ai_family;
#line 627
    host___0->h_length = (int )res->ai_addrlen;
#line 628
    host___0->h_addr_list = alptr;
    }
    {
#line 630
    if (af == 2) {
#line 630
      goto case_2;
    }
#line 634
    if (af == 10) {
#line 634
      goto case_10;
    }
#line 638
    goto switch_default;
    case_2: /* CIL Label */ 
#line 631
    sa4 = (struct sockaddr_in *)res->ai_addr;
#line 632
    alptr[0] = (char *)((void *)(& sa4->sin_addr));
#line 633
    goto switch_break;
    case_10: /* CIL Label */ 
#line 635
    sa6 = (struct sockaddr_in6 *)res->ai_addr;
#line 636
    alptr[0] = (char *)((void *)(& sa6->sin6_addr));
#line 637
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr unknown address type\n");
    }
#line 640
    if (DisplayMode != 6) {
      {
#line 640
      exit(1);
      }
    } else {
#line 642
      names = names->next;
#line 643
      goto while_continue___0;
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 646
    alptr[1] = (char *)((void *)0);
#line 660
    tmp___14 = net_open(host___0);
    }
#line 660
    if (tmp___14 != 0) {
      {
#line 661
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Unable to start net module.\n");
      }
#line 662
      if (DisplayMode != 6) {
        {
#line 662
        exit(1);
        }
      } else {
#line 664
        names = names->next;
#line 665
        goto while_continue___0;
      }
    }
    {
#line 669
    tmp___15 = net_set_interfaceaddress(InterfaceAddress);
    }
#line 669
    if (tmp___15 != 0) {
      {
#line 670
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: Couldn\'t set interface address.\n");
      }
#line 671
      if (DisplayMode != 6) {
        {
#line 671
        exit(1);
        }
      } else {
#line 673
        names = names->next;
#line 674
        goto while_continue___0;
      }
    }
    {
#line 678
    lock((char const   *)*(argv + 0), stdout);
#line 679
    display_open();
#line 680
    dns_open();
#line 682
    display_mode = 0;
#line 683
    display_loop();
#line 685
    net_end_transit();
#line 686
    display_close(now);
#line 687
    unlock((char const   *)*(argv + 0), stdout);
    }
#line 689
    if (DisplayMode != 6) {
#line 689
      goto while_break___0;
    } else {
#line 690
      names = names->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 694
  net_close();
  }
  {
#line 696
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 696
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 696
      goto while_break___1;
    }
    {
#line 697
    item = head;
#line 698
    free((void *)item->name);
#line 698
    item->name = (char *)((void *)0);
#line 699
    head = head->next;
#line 700
    free((void *)item);
#line 700
    item = (names_t *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 702
  head = (names_t *)((void *)0);
#line 704
  return (0);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 64 "/home/wheatley/newnew/temp/mtr-0.85/mtr.h"
int use_dns ;
#line 36 "/home/wheatley/newnew/temp/mtr-0.85/display.h"
void display_redraw(void) ;
#line 39
int display_keyaction(void) ;
#line 41
void display_clear(void) ;
#line 26 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
int dns_waitfd(void) ;
#line 27
void dns_ack(void) ;
#line 29
int dns_waitfd6(void) ;
#line 30
void dns_ack6(void) ;
#line 48
void dns_events(double *sinterval ) ;
#line 34 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
void net_reset(void) ;
#line 36
int net_waitfd(void) ;
#line 37
void net_process_return(void) ;
#line 61
int net_send_batch(void) ;
#line 64
int calc_deltatime(float waittime ) ;
#line 82
void net_add_fds(fd_set *writefd , int *maxfd ) ;
#line 83
void net_process_fds(fd_set *writefd ) ;
#line 43 "/home/wheatley/newnew/temp/mtr-0.85/select.c"
double dnsinterval  ;
#line 46 "/home/wheatley/newnew/temp/mtr-0.85/select.c"
static struct timeval intervaltime  ;
#line 47 "/home/wheatley/newnew/temp/mtr-0.85/select.c"
int display_offset  =    0;
#line 50 "/home/wheatley/newnew/temp/mtr-0.85/select.c"
void select_loop(void) 
{ 
  fd_set readfd ;
  fd_set writefd ;
  int anyset ;
  int maxfd ;
  int dnsfd ;
  int netfd ;
  int dnsfd6 ;
  int NumPing ;
  int paused ;
  struct timeval lasttime ;
  struct timeval thistime ;
  struct timeval selecttime ;
  int dt ;
  int rv ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 53
  anyset = 0;
#line 54
  maxfd = 0;
#line 59
  NumPing = 0;
#line 60
  paused = 0;
#line 65
  gettimeofday((struct timeval */* __restrict  */)(& lasttime), (__timezone_ptr_t )((void *)0));
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    dt = calc_deltatime(WaitTime);
#line 69
    intervaltime.tv_sec = (__time_t )(dt / 1000000);
#line 70
    intervaltime.tv_usec = (__suseconds_t )(dt % 1000000);
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfd.__fds_bits[0]): "memory");
#line 72
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 73
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 73
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefd.__fds_bits[0]): "memory");
#line 73
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 75
    maxfd = 0;
#line 77
    if (Interactive) {
#line 78
      readfd.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 79
      maxfd = 1;
    }
#line 83
    if (dns) {
      {
#line 84
      dnsfd6 = dns_waitfd6();
#line 85
      readfd.__fds_bits[dnsfd6 / (8 * (int )sizeof(__fd_mask ))] |= 1L << dnsfd6 % (8 * (int )sizeof(__fd_mask ));
      }
#line 86
      if (dnsfd6 >= maxfd) {
#line 86
        maxfd = dnsfd6 + 1;
      }
    } else {
#line 88
      dnsfd6 = 0;
    }
#line 90
    if (dns) {
      {
#line 91
      dnsfd = dns_waitfd();
#line 92
      readfd.__fds_bits[dnsfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << dnsfd % (8 * (int )sizeof(__fd_mask ));
      }
#line 93
      if (dnsfd >= maxfd) {
#line 93
        maxfd = dnsfd + 1;
      }
    } else {
#line 95
      dnsfd = 0;
    }
    {
#line 97
    netfd = net_waitfd();
#line 98
    readfd.__fds_bits[netfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << netfd % (8 * (int )sizeof(__fd_mask ));
    }
#line 99
    if (netfd >= maxfd) {
#line 99
      maxfd = netfd + 1;
    }
#line 101
    if (mtrtype == 6) {
      {
#line 102
      net_add_fds(& writefd, & maxfd);
      }
    }
    {
#line 104
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 105
      if (anyset) {
        {
#line 106
        selecttime.tv_sec = (__time_t )0;
#line 107
        selecttime.tv_usec = (__suseconds_t )0;
#line 109
        rv = select(maxfd, (fd_set */* __restrict  */)((void *)(& readfd)), (fd_set */* __restrict  */)(& writefd),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& selecttime));
        }
      } else
#line 105
      if (paused) {
        {
#line 106
        selecttime.tv_sec = (__time_t )0;
#line 107
        selecttime.tv_usec = (__suseconds_t )0;
#line 109
        rv = select(maxfd, (fd_set */* __restrict  */)((void *)(& readfd)), (fd_set */* __restrict  */)(& writefd),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& selecttime));
        }
      } else {
#line 112
        if (Interactive) {
          {
#line 112
          display_redraw();
          }
        }
        {
#line 114
        gettimeofday((struct timeval */* __restrict  */)(& thistime), (__timezone_ptr_t )((void *)0));
        }
#line 116
        if (thistime.tv_sec > lasttime.tv_sec + intervaltime.tv_sec) {
#line 116
          goto _L;
        } else
#line 116
        if (thistime.tv_sec == lasttime.tv_sec + intervaltime.tv_sec) {
#line 116
          if (thistime.tv_usec >= lasttime.tv_usec + intervaltime.tv_usec) {
            _L: /* CIL Label */ 
#line 119
            lasttime = thistime;
#line 120
            if (NumPing >= MaxPing) {
#line 120
              if (! Interactive) {
#line 121
                return;
              } else
#line 120
              if (ForceMaxPing) {
#line 121
                return;
              }
            }
            {
#line 122
            tmp = net_send_batch();
            }
#line 122
            if (tmp) {
#line 123
              NumPing ++;
            }
          }
        }
#line 126
        selecttime.tv_usec = thistime.tv_usec - lasttime.tv_usec;
#line 127
        selecttime.tv_sec = thistime.tv_sec - lasttime.tv_sec;
#line 128
        if (selecttime.tv_usec < 0L) {
#line 129
          (selecttime.tv_sec) --;
#line 130
          selecttime.tv_usec += 1000000L;
        }
#line 132
        selecttime.tv_usec = intervaltime.tv_usec - selecttime.tv_usec;
#line 133
        selecttime.tv_sec = intervaltime.tv_sec - selecttime.tv_sec;
#line 134
        if (selecttime.tv_usec < 0L) {
#line 135
          (selecttime.tv_sec) --;
#line 136
          selecttime.tv_usec += 1000000L;
        }
#line 139
        if (dns) {
#line 140
          if (selecttime.tv_sec > (time_t )dnsinterval) {
#line 143
            selecttime.tv_sec = (time_t )dnsinterval;
#line 144
            selecttime.tv_usec = (time_t )(dnsinterval * (double )1000000) % 1000000L;
          } else
#line 140
          if (selecttime.tv_sec == (time_t )dnsinterval) {
#line 140
            if (selecttime.tv_usec > (time_t )(dnsinterval * (double )1000000) % 1000000L) {
#line 143
              selecttime.tv_sec = (time_t )dnsinterval;
#line 144
              selecttime.tv_usec = (time_t )(dnsinterval * (double )1000000) % 1000000L;
            }
          }
        }
        {
#line 148
        rv = select(maxfd, (fd_set */* __restrict  */)((void *)(& readfd)), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& selecttime));
        }
      }
#line 104
      if (rv < 0) {
        {
#line 104
        tmp___0 = __errno_location();
        }
#line 104
        if (! (*tmp___0 == 4)) {
#line 104
          goto while_break___2;
        }
      } else {
#line 104
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 152
    if (rv < 0) {
      {
#line 153
      perror("Select failed");
#line 154
      exit(1);
      }
    }
#line 156
    anyset = 0;
#line 159
    if ((readfd.__fds_bits[netfd / (8 * (int )sizeof(__fd_mask ))] & (1L << netfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 160
      net_process_return();
#line 161
      anyset = 1;
      }
    }
#line 164
    if (dns) {
      {
#line 166
      dnsinterval = (double )WaitTime;
#line 167
      dns_events(& dnsinterval);
      }
    }
#line 172
    if (dns) {
#line 172
      if ((readfd.__fds_bits[dnsfd6 / (8 * (int )sizeof(__fd_mask ))] & (1L << dnsfd6 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 173
        dns_ack6();
#line 174
        anyset = 1;
        }
      }
    }
#line 177
    if (dns) {
#line 177
      if ((readfd.__fds_bits[dnsfd / (8 * (int )sizeof(__fd_mask ))] & (1L << dnsfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 178
        dns_ack();
#line 179
        anyset = 1;
        }
      }
    }
#line 183
    if ((readfd.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 184
      tmp___1 = display_keyaction();
      }
      {
#line 185
      if (tmp___1 == 1) {
#line 185
        goto case_1;
      }
#line 188
      if (tmp___1 == 2) {
#line 188
        goto case_2;
      }
#line 191
      if (tmp___1 == 3) {
#line 191
        goto case_3;
      }
#line 194
      if (tmp___1 == 4) {
#line 194
        goto case_4;
      }
#line 197
      if (tmp___1 == 5) {
#line 197
        goto case_5;
      }
#line 200
      if (tmp___1 == 6) {
#line 200
        goto case_6;
      }
#line 203
      if (tmp___1 == 7) {
#line 203
        goto case_7;
      }
#line 207
      if (tmp___1 == 8) {
#line 207
        goto case_8;
      }
#line 214
      if (tmp___1 == 9) {
#line 214
        goto case_9;
      }
#line 221
      if (tmp___1 == 10) {
#line 221
        goto case_10;
      }
#line 227
      if (tmp___1 == 11) {
#line 227
        goto case_11;
      }
#line 230
      if (tmp___1 == 12) {
#line 230
        goto case_12;
      }
#line 184
      goto switch_break;
      case_1: /* CIL Label */ 
#line 186
      return;
#line 187
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 189
      net_reset();
      }
#line 190
      goto switch_break;
      case_3: /* CIL Label */ 
#line 192
      display_mode = (display_mode + 1) % 3;
#line 193
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 195
      display_clear();
      }
#line 196
      goto switch_break;
      case_5: /* CIL Label */ 
#line 198
      paused = 1;
#line 199
      goto switch_break;
      case_6: /* CIL Label */ 
#line 201
      paused = 0;
#line 202
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 204
      enablempls = ! enablempls;
#line 205
      display_clear();
      }
#line 206
      goto switch_break;
      case_8: /* CIL Label */ 
#line 208
      if (dns) {
        {
#line 209
        use_dns = ! use_dns;
#line 210
        display_clear();
        }
      }
#line 212
      goto switch_break;
      case_9: /* CIL Label */ 
#line 215
      if (ipinfo_no >= 0) {
#line 216
        ipinfo_no ++;
#line 217
        if (ipinfo_no > ipinfo_max) {
#line 218
          ipinfo_no = 0;
        }
      }
#line 220
      goto switch_break;
      case_10: /* CIL Label */ 
#line 222
      if (ipinfo_no >= 0) {
#line 223
        if (ipinfo_no) {
#line 223
          ipinfo_no = 0;
        } else {
#line 223
          ipinfo_no = ipinfo_max;
        }
      }
#line 224
      goto switch_break;
      case_11: /* CIL Label */ 
#line 228
      display_offset += 5;
#line 229
      goto switch_break;
      case_12: /* CIL Label */ 
#line 231
      display_offset -= 5;
#line 232
      if (display_offset < 0) {
#line 233
        display_offset = 0;
      }
#line 235
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 237
      anyset = 1;
    }
#line 241
    if (mtrtype == 6) {
      {
#line 242
      net_process_fds(& writefd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/mtr-0.85/split.h"
void split_open(void) ;
#line 23
void split_close(void) ;
#line 24
void split_redraw(void) ;
#line 25
int split_keyaction(void) ;
#line 65 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
char Lines[256][256]  ;
#line 66 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
int LineCount  ;
#line 72 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
void split_redraw(void) 
{ 
  int max ;
  int at ;
  ip_t *addr ;
  char newLine[256] ;
  int i ;
  char str[256] ;
  char *name ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 88
  max = net_max();
#line 89
  i = LineCount;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i > max)) {
#line 89
      goto while_break;
    }
    {
#line 90
    printf((char const   */* __restrict  */)"-%d\n", i);
#line 91
    LineCount --;
#line 89
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  at = 0;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! (at < max)) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    addr = net_addr(at);
#line 99
    tmp___6 = addrcmp((char *)((void *)addr), (char *)((void *)(& unspec_addr)), af);
    }
#line 99
    if (tmp___6) {
      {
#line 101
      name = dns_lookup(addr);
      }
#line 101
      if (! name) {
        {
#line 102
        name = strlongip(addr);
        }
      }
#line 103
      if (show_ips) {
        {
#line 104
        tmp = strlongip(addr);
#line 104
        snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"%s %s",
                 name, tmp);
#line 105
        name = str;
        }
      }
      {
#line 108
      tmp___0 = net_worst(at);
#line 108
      tmp___1 = net_avg(at);
#line 108
      tmp___2 = net_best(at);
#line 108
      tmp___3 = net_xmit(at);
#line 108
      tmp___4 = net_returned(at);
#line 108
      tmp___5 = net_loss(at);
#line 108
      snprintf((char */* __restrict  */)(newLine), sizeof(newLine), (char const   */* __restrict  */)"%s %d %d %d %d %d %d",
               name, tmp___5, tmp___4, tmp___3, tmp___2 / 1000, tmp___1 / 1000, tmp___0 / 1000);
      }
    } else {
      {
#line 114
      sprintf((char */* __restrict  */)(newLine), (char const   */* __restrict  */)"???");
      }
    }
    {
#line 117
    tmp___7 = strcmp((char const   *)(newLine), (char const   *)(Lines[at]));
    }
#line 117
    if (! (tmp___7 == 0)) {
      {
#line 123
      printf((char const   */* __restrict  */)"%d %s\n", at + 1, newLine);
#line 124
      fflush(stdout);
#line 125
      strcpy((char */* __restrict  */)(Lines[at]), (char const   */* __restrict  */)(newLine));
      }
#line 126
      if (LineCount < at + 1) {
#line 127
        LineCount = at + 1;
      }
    }
#line 97
    at ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
void split_open(void) 
{ 
  int i ;

  {
#line 140
  LineCount = -1;
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < 256)) {
#line 141
      goto while_break;
    }
    {
#line 142
    strcpy((char */* __restrict  */)(Lines[i]), (char const   */* __restrict  */)"???");
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
void split_close(void) 
{ 


  {
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/mtr-0.85/split.c"
int split_keyaction(void) 
{ 
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 172
  tmp = wgetch(stdscr);
#line 172
  c = (char )tmp;
#line 178
  tmp___0 = tolower((int )c);
  }
#line 178
  if (tmp___0 == 113) {
#line 179
    return (1);
  }
#line 180
  if ((int )c == 3) {
#line 181
    return (1);
  }
  {
#line 182
  tmp___1 = tolower((int )c);
  }
#line 182
  if (tmp___1 == 114) {
#line 183
    return (2);
  }
#line 185
  return (0);
}
}
#line 37 "/home/wheatley/newnew/temp/mtr-0.85/display.h"
void display_rawping(int host___0 , int msec ) ;
#line 38
void display_rawhost(int host___0 , ip_t *ip_addr ) ;
#line 67 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_detect(int *argc , char ***argv ) 
{ 


  {
#line 68
  DisplayMode = 0;
#line 71
  DisplayMode = 1;
#line 79
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_open(void) 
{ 


  {
  {
#line 86
  if (DisplayMode == 0) {
#line 86
    goto case_0;
  }
#line 89
  if (DisplayMode == 7) {
#line 89
    goto case_7;
  }
#line 92
  if (DisplayMode == 5) {
#line 92
    goto case_5;
  }
#line 95
  if (DisplayMode == 6) {
#line 95
    goto case_6;
  }
#line 98
  if (DisplayMode == 1) {
#line 98
    goto case_1;
  }
#line 105
  if (DisplayMode == 3) {
#line 105
    goto case_3;
  }
#line 108
  if (DisplayMode == 2) {
#line 108
    goto case_2;
  }
#line 84
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 87
  report_open();
  }
#line 88
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 90
  txt_open();
  }
#line 91
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 93
  xml_open();
  }
#line 94
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 96
  csv_open();
  }
#line 97
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 99
  mtr_curses_open();
  }
#line 101
  if (ipinfo_no >= 0) {
    {
#line 102
    asn_open();
    }
  }
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 106
  split_open();
  }
#line 107
  goto switch_break;
  case_2: /* CIL Label */ ;
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_close(time_t now ) 
{ 


  {
  {
#line 118
  if (DisplayMode == 0) {
#line 118
    goto case_0;
  }
#line 121
  if (DisplayMode == 7) {
#line 121
    goto case_7;
  }
#line 124
  if (DisplayMode == 5) {
#line 124
    goto case_5;
  }
#line 127
  if (DisplayMode == 6) {
#line 127
    goto case_6;
  }
#line 130
  if (DisplayMode == 1) {
#line 130
    goto case_1;
  }
#line 137
  if (DisplayMode == 3) {
#line 137
    goto case_3;
  }
#line 140
  if (DisplayMode == 2) {
#line 140
    goto case_2;
  }
#line 117
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 119
  report_close();
  }
#line 120
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 122
  txt_close();
  }
#line 123
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 125
  xml_close();
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 128
  csv_close(now);
  }
#line 129
  goto switch_break;
  case_1: /* CIL Label */ 
#line 132
  if (ipinfo_no >= 0) {
    {
#line 133
    asn_close();
    }
  }
  {
#line 135
  mtr_curses_close();
  }
#line 136
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 138
  split_close();
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ ;
#line 142
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_redraw(void) 
{ 


  {
  {
#line 151
  if (DisplayMode == 1) {
#line 151
    goto case_1;
  }
#line 155
  if (DisplayMode == 3) {
#line 155
    goto case_3;
  }
#line 159
  if (DisplayMode == 2) {
#line 159
    goto case_2;
  }
#line 149
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 152
  mtr_curses_redraw();
  }
#line 153
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 156
  split_redraw();
  }
#line 157
  goto switch_break;
  case_2: /* CIL Label */ ;
#line 161
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 166 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
int display_keyaction(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 169
  if (DisplayMode == 1) {
#line 169
    goto case_1;
  }
#line 172
  if (DisplayMode == 3) {
#line 172
    goto case_3;
  }
#line 175
  if (DisplayMode == 2) {
#line 175
    goto case_2;
  }
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 170
  tmp = mtr_curses_keyaction();
  }
#line 170
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 173
  tmp___0 = split_keyaction();
  }
#line 173
  return (tmp___0);
  case_2: /* CIL Label */ 
#line 176
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 178
  return (0);
}
}
#line 182 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_rawping(int host___0 , int msec ) 
{ 


  {
  {
#line 191
  if (DisplayMode == 2) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 1) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 3) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 6) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 5) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 7) {
#line 191
    goto case_2;
  }
#line 191
  if (DisplayMode == 0) {
#line 191
    goto case_2;
  }
#line 193
  if (DisplayMode == 4) {
#line 193
    goto case_4;
  }
#line 184
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 192
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 194
  raw_rawping(host___0, msec);
  }
#line 195
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_rawhost(int host___0 , ip_t *ip_addr ) 
{ 


  {
  {
#line 209
  if (DisplayMode == 2) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 1) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 3) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 6) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 5) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 7) {
#line 209
    goto case_2;
  }
#line 209
  if (DisplayMode == 0) {
#line 209
    goto case_2;
  }
#line 211
  if (DisplayMode == 4) {
#line 211
    goto case_4;
  }
#line 202
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 210
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 212
  raw_rawhost(host___0, ip_addr);
  }
#line 213
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_loop(void) 
{ 


  {
  {
#line 227
  if (DisplayMode == 4) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 1) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 3) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 6) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 5) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 7) {
#line 227
    goto case_4;
  }
#line 227
  if (DisplayMode == 0) {
#line 227
    goto case_4;
  }
#line 230
  if (DisplayMode == 2) {
#line 230
    goto case_2;
  }
#line 220
  goto switch_break;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 228
  select_loop();
  }
#line 229
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 231
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No GTK support. Sorry.\n");
#line 231
  exit(1);
  }
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 237 "/home/wheatley/newnew/temp/mtr-0.85/display.c"
void display_clear(void) 
{ 


  {
  {
#line 240
  if (DisplayMode == 1) {
#line 240
    goto case_1;
  }
#line 248
  if (DisplayMode == 4) {
#line 248
    goto case_4;
  }
#line 248
  if (DisplayMode == 3) {
#line 248
    goto case_4;
  }
#line 248
  if (DisplayMode == 6) {
#line 248
    goto case_4;
  }
#line 248
  if (DisplayMode == 5) {
#line 248
    goto case_4;
  }
#line 248
  if (DisplayMode == 7) {
#line 248
    goto case_4;
  }
#line 248
  if (DisplayMode == 0) {
#line 248
    goto case_4;
  }
#line 251
  if (DisplayMode == 2) {
#line 251
    goto case_2;
  }
#line 239
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 241
  mtr_curses_clear();
  }
#line 242
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 249
  goto switch_break;
  case_2: /* CIL Label */ 
#line 252
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 32 "/home/wheatley/newnew/temp/mtr-0.85/net.h"
void net_reopen(struct hostent *addr ) ;
#line 38
void net_harvest_fds(void) ;
#line 68
int net_transit(int at ) ;
#line 74
void net_save_xmit(int at ) ;
#line 75
void net_save_return(int at , int seq , int ms ) ;
#line 78
void sockaddrtop(struct sockaddr *saddr , char *strptr , size_t len ) ;
#line 80
void addrcpy(char *a , char *b , int af___0 ) ;
#line 137
void decodempls(int num , char *packet , struct mplslen *mpls , int offset ) ;
#line 154 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int BSDfix  =    0;
#line 156 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static struct nethost host[256]  ;
#line 157 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static struct sequence sequence[65536]  ;
#line 158 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static struct timeval reset  =    {(__time_t )0, (__suseconds_t )0};
#line 160 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int timestamp  ;
#line 161 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock4  ;
#line 162 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock4_icmp  ;
#line 163 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock4_udp  ;
#line 164 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int recvsock4  ;
#line 165 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock6  ;
#line 166 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock6_icmp  ;
#line 167 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock6_udp  ;
#line 168 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int recvsock6  ;
#line 169 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int sendsock  ;
#line 170 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int recvsock  ;
#line 173 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_storage sourcesockaddr_struct  ;
#line 174 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_storage remotesockaddr_struct  ;
#line 175 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_in6 *ssa6  =    (struct sockaddr_in6 *)(& sourcesockaddr_struct);
#line 176 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_in6 *rsa6  =    (struct sockaddr_in6 *)(& remotesockaddr_struct);
#line 182 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr *sourcesockaddr  =    (struct sockaddr *)(& sourcesockaddr_struct);
#line 183 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr *remotesockaddr  =    (struct sockaddr *)(& remotesockaddr_struct);
#line 184 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_in *ssa4  =    (struct sockaddr_in *)(& sourcesockaddr_struct);
#line 185 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
struct sockaddr_in *rsa4  =    (struct sockaddr_in *)(& remotesockaddr_struct);
#line 187 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
ip_t *sourceaddress  ;
#line 188 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
ip_t *remoteaddress  ;
#line 192 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
char localaddr[46]  ;
#line 200 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int batch_at  =    0;
#line 201 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int numhosts  =    10;
#line 206 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int packetsize  ;
#line 216 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int calc_deltatime(float waittime ) 
{ 


  {
#line 218
  waittime /= (float )numhosts;
#line 219
  return ((int )((float )1000000 * waittime));
}
}
#line 225 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int checksum(void *data , int sz ) 
{ 
  unsigned short *ch ;
  unsigned int sum ;
  unsigned short *tmp ;
  int tmp___0 ;

  {
#line 230
  sum = 0U;
#line 231
  ch = (unsigned short *)data;
#line 232
  sz /= 2;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    tmp___0 = sz;
#line 233
    sz --;
#line 233
    if (! tmp___0) {
#line 233
      goto while_break;
    }
#line 234
    tmp = ch;
#line 234
    ch ++;
#line 234
    sum += (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  sum = (sum >> 16) + (sum & 65535U);
#line 239
  return ((int )(~ sum & 65535U));
}
}
#line 244 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int udp_checksum(void *pheader , void *udata , int psize , int dsize ) 
{ 
  unsigned int tsize ;
  char *csumpacket ;
  unsigned long __lengthofcsumpacket ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct UDPv4PHeader *prepend ;
  struct UDPv4PHeader *udppheader ;
  struct UDPHeader *content ;
  struct UDPHeader *udpdata ;
  int tmp___2 ;

  {
  {
#line 246
  tsize = (unsigned int )(psize + dsize);
#line 247
  __lengthofcsumpacket = (unsigned long )tsize;
#line 247
  tmp = __builtin_alloca(sizeof(*csumpacket) * __lengthofcsumpacket);
#line 247
  csumpacket = (char *)tmp;
#line 248
  tmp___0 = abs((int )tsize);
#line 248
  tmp___1 = abs(bitpattern);
#line 248
  memset((void *)csumpacket, (int )((unsigned char )tmp___1), (size_t )tmp___0);
#line 250
  prepend = (struct UDPv4PHeader *)csumpacket;
#line 251
  udppheader = (struct UDPv4PHeader *)pheader;
#line 252
  prepend->saddr = udppheader->saddr;
#line 253
  prepend->daddr = udppheader->daddr;
#line 254
  prepend->zero = (uint8 )0;
#line 255
  prepend->protocol = udppheader->protocol;
#line 256
  prepend->len = udppheader->len;
#line 258
  content = (struct UDPHeader *)(csumpacket + psize);
#line 259
  udpdata = (struct UDPHeader *)udata;
#line 260
  content->srcport = udpdata->srcport;
#line 261
  content->dstport = udpdata->dstport;
#line 262
  content->length = udpdata->length;
#line 263
  content->checksum = udpdata->checksum;
#line 265
  tmp___2 = checksum((void *)csumpacket, (int )tsize);
  }
#line 265
  return (tmp___2);
}
}
#line 269 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void save_sequence(int index___0 , int seq ) 
{ 


  {
  {
#line 271
  sequence[seq].index = index___0;
#line 272
  sequence[seq].transit = 1;
#line 273
  (host[index___0].xmit) ++;
#line 273
  sequence[seq].saved_seq = host[index___0].xmit;
#line 274
  memset((void *)(& sequence[seq].time), 0, sizeof(sequence[seq].time));
#line 276
  host[index___0].transit = 1;
  }
#line 277
  if (host[index___0].sent) {
#line 278
    host[index___0].up = 0;
  }
  {
#line 279
  host[index___0].sent = 1;
#line 280
  net_save_xmit(index___0);
  }
#line 281
  return;
}
}
#line 285
int new_sequence(int index___0 ) ;
#line 285 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int next_sequence  =    33000;
#line 283 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int new_sequence(int index___0 ) 
{ 
  int seq ;
  int tmp ;

  {
#line 288
  tmp = next_sequence;
#line 288
  next_sequence ++;
#line 288
  seq = tmp;
#line 289
  if (next_sequence >= 65536) {
#line 290
    next_sequence = 33000;
  }
  {
#line 292
  save_sequence(index___0, seq);
  }
#line 294
  return (seq);
}
}
#line 298 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_send_tcp(int index___0 ) 
{ 
  int ttl ;
  int s ;
  int opt ;
  int port ;
  struct sockaddr_storage local ;
  struct sockaddr_storage remote ;
  struct sockaddr_in *local4 ;
  struct sockaddr_in6 *local6 ;
  struct sockaddr_in *remote4 ;
  struct sockaddr_in6 *remote6 ;
  socklen_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;

  {
  {
#line 301
  opt = 1;
#line 305
  local4 = (struct sockaddr_in *)(& local);
#line 306
  local6 = (struct sockaddr_in6 *)(& local);
#line 307
  remote4 = (struct sockaddr_in *)(& remote);
#line 308
  remote6 = (struct sockaddr_in6 *)(& remote);
#line 311
  ttl = index___0 + 1;
#line 313
  s = socket(af, 1, 0);
  }
#line 314
  if (s < 0) {
    {
#line 315
    display_clear();
#line 316
    perror("socket()");
#line 317
    exit(1);
    }
  }
  {
#line 320
  memset((void *)(& local), 0, sizeof(local));
#line 321
  memset((void *)(& remote), 0, sizeof(remote));
#line 322
  local.ss_family = (sa_family_t )af;
#line 323
  remote.ss_family = (sa_family_t )af;
  }
  {
#line 326
  if (af == 2) {
#line 326
    goto case_2;
  }
#line 332
  if (af == 10) {
#line 332
    goto case_10;
  }
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 327
  addrcpy((char *)((void *)(& local4->sin_addr)), (char *)((void *)(& ssa4->sin_addr)),
          af);
#line 328
  addrcpy((char *)((void *)(& remote4->sin_addr)), (char *)((void *)remoteaddress),
          af);
#line 329
  remote4->sin_port = htons((uint16_t )remoteport);
  }
#line 330
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 333
  addrcpy((char *)((void *)(& local6->sin6_addr)), (char *)((void *)(& ssa6->sin6_addr)),
          af);
#line 334
  addrcpy((char *)((void *)(& remote6->sin6_addr)), (char *)((void *)remoteaddress),
          af);
#line 335
  remote6->sin6_port = htons((uint16_t )remoteport);
  }
#line 336
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 340
  tmp = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& local)), (socklen_t )sizeof(local));
  }
#line 340
  if (tmp) {
    {
#line 341
    display_clear();
#line 342
    perror("bind()");
#line 343
    exit(1);
    }
  }
  {
#line 346
  len = (socklen_t )sizeof(local);
#line 347
  tmp___0 = getsockname(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& local)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 347
  if (tmp___0) {
    {
#line 348
    display_clear();
#line 349
    perror("getsockname()");
#line 350
    exit(1);
    }
  }
  {
#line 353
  opt = 1;
#line 354
  tmp___1 = ioctl(s, 21537UL, & opt);
  }
#line 354
  if (tmp___1) {
    {
#line 355
    display_clear();
#line 356
    perror("ioctl FIONBIO");
#line 357
    exit(1);
    }
  }
  {
#line 361
  if (af == 2) {
#line 361
    goto case_2___0;
  }
#line 374
  if (af == 10) {
#line 374
    goto case_10___0;
  }
#line 360
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 362
  tmp___2 = setsockopt(s, 0, 2, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
  }
#line 362
  if (tmp___2) {
    {
#line 363
    display_clear();
#line 364
    perror("setsockopt IP_TTL");
#line 365
    exit(1);
    }
  }
  {
#line 367
  tmp___3 = setsockopt(s, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 367
  if (tmp___3) {
    {
#line 368
    display_clear();
#line 369
    perror("setsockopt IP_TOS");
#line 370
    exit(1);
    }
  }
#line 372
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
  {
#line 375
  tmp___4 = setsockopt(s, 41, 16, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
  }
#line 375
  if (tmp___4) {
    {
#line 376
    display_clear();
#line 377
    perror("setsockopt IP_TTL");
#line 378
    exit(1);
    }
  }
#line 380
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 385
  if ((int )local.ss_family == 2) {
#line 385
    goto case_2___1;
  }
#line 389
  if ((int )local.ss_family == 10) {
#line 389
    goto case_10___1;
  }
#line 393
  goto switch_default;
  case_2___1: /* CIL Label */ 
  {
#line 386
  tmp___5 = ntohs(local4->sin_port);
#line 386
  port = (int )tmp___5;
  }
#line 387
  goto switch_break___1;
  case_10___1: /* CIL Label */ 
  {
#line 390
  tmp___6 = ntohs(local6->sin6_port);
#line 390
  port = (int )tmp___6;
  }
#line 391
  goto switch_break___1;
  switch_default: /* CIL Label */ 
  {
#line 394
  display_clear();
#line 395
  perror("unknown AF?");
#line 396
  exit(1);
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 399
  save_sequence(index___0, port);
#line 400
  gettimeofday((struct timeval */* __restrict  */)(& sequence[port].time), (__timezone_ptr_t )((void *)0));
#line 401
  sequence[port].socket = s;
#line 403
  connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& remote)), (socklen_t )sizeof(remote));
  }
#line 404
  return;
}
}
#line 424
void net_send_query(int index___0 ) ;
#line 424 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static int first  =    1;
#line 407 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_send_query(int index___0 ) 
{ 
  char packet[4470] ;
  struct IPHeader *ip ;
  struct ICMPHeader *icmp ;
  struct UDPHeader *udp ;
  struct UDPv4PHeader *udpp ;
  uint16 mypid ;
  int rv ;
  int ttl ;
  int iphsize ;
  int echotype ;
  int salen ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  ssize_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  ssize_t tmp___22 ;
  int *tmp___23 ;
  int *tmp___24 ;

  {
#line 409
  if (mtrtype == 6) {
    {
#line 410
    net_send_tcp(index___0);
    }
#line 411
    return;
  }
#line 416
  ip = (struct IPHeader *)(packet);
#line 417
  icmp = (struct ICMPHeader *)((void *)0);
#line 418
  udp = (struct UDPHeader *)((void *)0);
#line 419
  udpp = (struct UDPv4PHeader *)((void *)0);
#line 425
  iphsize = 0;
#line 425
  echotype = 0;
#line 425
  salen = 0;
#line 427
  ttl = index___0 + 1;
#line 431
  offset = 6;
#line 434
  if (packetsize < 28) {
#line 434
    packetsize = 28;
  }
#line 435
  if (packetsize > 4470) {
#line 435
    packetsize = 4470;
  }
  {
#line 437
  tmp = abs(packetsize);
#line 437
  tmp___0 = abs(bitpattern);
#line 437
  memset((void *)(packet), (int )((unsigned char )tmp___0), (size_t )tmp);
  }
  {
#line 440
  if (af == 2) {
#line 440
    goto case_2;
  }
#line 471
  if (af == 10) {
#line 471
    goto case_10;
  }
#line 439
  goto switch_break;
  case_2: /* CIL Label */ 
#line 452
  iphsize = (int )sizeof(struct IPHeader );
#line 454
  ip->version = (uint8 )69;
#line 455
  ip->tos = (uint8 )tos;
#line 456
  if (BSDfix) {
    {
#line 456
    tmp___1 = abs(packetsize);
#line 456
    ip->len = (uint16 )tmp___1;
    }
  } else {
    {
#line 456
    tmp___2 = abs(packetsize);
#line 456
    tmp___3 = htons((uint16_t )tmp___2);
#line 456
    ip->len = tmp___3;
    }
  }
  {
#line 457
  ip->id = (uint16 )0;
#line 458
  ip->frag = (uint16 )0;
#line 459
  ip->ttl = (uint8 )ttl;
#line 460
  ip->protocol = (uint8 )mtrtype;
#line 461
  ip->check = (uint16 )0;
#line 464
  addrcpy((char *)((void *)(& ip->saddr)), (char *)((void *)(& ssa4->sin_addr)), 2);
#line 465
  addrcpy((char *)((void *)(& ip->daddr)), (char *)((void *)remoteaddress), 2);
#line 467
  echotype = 8;
#line 468
  salen = (int )sizeof(struct sockaddr_in );
  }
#line 469
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 472
  iphsize = 0;
#line 473
  tmp___4 = setsockopt(sendsock, 41, 16, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
  }
#line 473
  if (tmp___4) {
    {
#line 475
    perror("setsockopt IPV6_UNICAST_HOPS");
#line 476
    exit(1);
    }
  }
#line 478
  echotype = 128;
#line 479
  salen = (int )sizeof(struct sockaddr_in6 );
#line 480
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 485
  if (mtrtype == 1) {
#line 485
    goto case_1;
  }
#line 497
  if (mtrtype == 17) {
#line 497
    goto case_17;
  }
#line 484
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 486
  icmp = (struct ICMPHeader *)(packet + iphsize);
#line 487
  icmp->type = (uint8 )echotype;
#line 488
  icmp->code = (uint8 )0;
#line 489
  icmp->checksum = (uint16 )0;
#line 490
  tmp___5 = getpid();
#line 490
  icmp->id = (uint16 )tmp___5;
#line 491
  tmp___6 = new_sequence(index___0);
#line 491
  icmp->sequence = (uint16 )tmp___6;
#line 492
  tmp___7 = abs(packetsize);
#line 492
  tmp___8 = checksum((void *)icmp, tmp___7 - iphsize);
#line 492
  icmp->checksum = (uint16 )tmp___8;
#line 494
  gettimeofday((struct timeval */* __restrict  */)(& sequence[icmp->sequence].time),
               (__timezone_ptr_t )((void *)0));
  }
#line 495
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
#line 498
  udp = (struct UDPHeader *)(packet + iphsize);
#line 499
  udp->checksum = (uint16 )0;
#line 500
  tmp___9 = getpid();
#line 500
  mypid = (uint16 )tmp___9;
  }
#line 501
  if ((int )mypid < 1024) {
#line 502
    mypid = (uint16 )((int )mypid + 1024);
  }
  {
#line 504
  udp->srcport = htons(mypid);
#line 505
  tmp___10 = abs(packetsize);
#line 505
  udp->length = (uint16 )(tmp___10 - iphsize);
  }
#line 506
  if (! BSDfix) {
    {
#line 507
    udp->length = htons(udp->length);
    }
  }
  {
#line 509
  tmp___11 = new_sequence(index___0);
#line 509
  udp->dstport = (uint16 )tmp___11;
#line 510
  gettimeofday((struct timeval */* __restrict  */)(& sequence[udp->dstport].time),
               (__timezone_ptr_t )((void *)0));
#line 511
  udp->dstport = htons(udp->dstport);
  }
#line 512
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 516
  if (af == 2) {
#line 516
    goto case_2___0;
  }
#line 534
  if (af == 10) {
#line 534
    goto case_10___0;
  }
#line 515
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 518
  if (mtrtype == 17) {
#line 518
    goto case_17___0;
  }
#line 517
  goto switch_break___2;
  case_17___0: /* CIL Label */ 
#line 520
  if (ip->saddr) {
    {
#line 521
    tmp___12 = malloc(sizeof(struct UDPv4PHeader ));
#line 521
    udpp = (struct UDPv4PHeader *)tmp___12;
#line 522
    udpp->saddr = ip->saddr;
#line 523
    udpp->daddr = ip->daddr;
#line 524
    udpp->protocol = ip->protocol;
#line 525
    udpp->len = udp->length;
#line 526
    tmp___13 = abs(packetsize);
#line 526
    tmp___14 = udp_checksum((void *)udpp, (void *)udp, (int )sizeof(struct UDPv4PHeader ),
                            tmp___13 - iphsize);
#line 526
    udp->checksum = (uint16 )tmp___14;
    }
  }
#line 528
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 531
  tmp___15 = abs(packetsize);
#line 531
  tmp___16 = checksum((void *)(packet), tmp___15);
#line 531
  ip->check = (uint16 )tmp___16;
  }
#line 532
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
  {
#line 536
  if (mtrtype == 17) {
#line 536
    goto case_17___1;
  }
#line 535
  goto switch_break___3;
  case_17___1: /* CIL Label */ 
  {
#line 538
  tmp___17 = setsockopt(sendsock, 41, 7, (void const   *)(& offset), (socklen_t )sizeof(offset));
  }
#line 538
  if (tmp___17) {
    {
#line 539
    perror("setsockopt IPV6_CHECKSUM");
#line 540
    exit(1);
    }
  }
#line 542
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 544
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 548
  tmp___18 = abs(packetsize);
#line 548
  tmp___19 = sendto(sendsock, (void const   *)(packet), (size_t )tmp___18, 0, (struct sockaddr  const  *)remotesockaddr,
                    (socklen_t )salen);
#line 548
  rv = (int )tmp___19;
  }
#line 550
  if (first) {
#line 550
    if (rv < 0) {
      {
#line 550
      tmp___23 = __errno_location();
      }
#line 550
      if (*tmp___23 == 22) {
#line 550
        goto _L;
      } else {
        {
#line 550
        tmp___24 = __errno_location();
        }
#line 550
        if (*tmp___24 == 90) {
          _L: /* CIL Label */ 
          {
#line 552
          tmp___20 = abs(packetsize);
#line 552
          ip->len = (uint16 )tmp___20;
#line 553
          tmp___21 = abs(packetsize);
#line 553
          tmp___22 = sendto(sendsock, (void const   *)(packet), (size_t )tmp___21,
                            0, (struct sockaddr  const  *)remotesockaddr, (socklen_t )salen);
#line 553
          rv = (int )tmp___22;
          }
#line 555
          if (rv >= 0) {
#line 556
            BSDfix = 1;
          }
        }
      }
    }
  }
#line 559
  first = 0;
#line 560
  return;
}
}
#line 565 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_process_ping(int seq , struct mplslen mpls , void *addr , struct timeval now ) 
{ 
  int index___0 ;
  int totusec ;
  int oldavg ;
  int oldjavg ;
  int i ;
  char addrcopy[sizeof(struct in6_addr )] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
  {
#line 579
  addrcpy((char *)((void *)(& addrcopy)), (char *)addr, af);
  }
#line 581
  if (seq < 0) {
#line 582
    return;
  } else
#line 581
  if (seq >= 65536) {
#line 582
    return;
  }
#line 584
  if (! sequence[seq].transit) {
#line 585
    return;
  }
#line 586
  sequence[seq].transit = 0;
#line 588
  if (sequence[seq].socket > 0) {
    {
#line 589
    close(sequence[seq].socket);
#line 590
    sequence[seq].socket = 0;
    }
  }
  {
#line 593
  index___0 = sequence[seq].index;
#line 595
  totusec = (int )((now.tv_sec - sequence[seq].time.tv_sec) * 1000000L + (now.tv_usec - sequence[seq].time.tv_usec));
#line 599
  tmp___2 = addrcmp((char *)((void *)(& host[index___0].addr)), (char *)((void *)(& unspec_addr)),
                    af);
  }
#line 599
  if (tmp___2 == 0) {
    {
#line 602
    addrcpy((char *)((void *)(& host[index___0].addr)), addrcopy, af);
#line 603
    host[index___0].mpls = mpls;
#line 604
    display_rawhost(index___0, (ip_t *)((void *)(& host[index___0].addr)));
#line 607
    addrcpy((char *)((void *)(& host[index___0].addrs[0])), addrcopy, af);
#line 608
    host[index___0].mplss[0] = mpls;
    }
  } else {
#line 610
    i = 0;
    {
#line 610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 610
      if (! (i < 8)) {
#line 610
        goto while_break;
      }
      {
#line 611
      tmp = addrcmp((char *)((void *)(& host[index___0].addrs[i])), (char *)((void *)(& addrcopy)),
                    af);
      }
#line 611
      if (tmp == 0) {
#line 614
        goto while_break;
      } else {
        {
#line 611
        tmp___0 = addrcmp((char *)((void *)(& host[index___0].addrs[i])), (char *)((void *)(& unspec_addr)),
                          af);
        }
#line 611
        if (tmp___0 == 0) {
#line 614
          goto while_break;
        }
      }
#line 615
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 617
    tmp___1 = addrcmp((char *)((void *)(& host[index___0].addrs[i])), addrcopy, af);
    }
#line 617
    if (tmp___1 != 0) {
#line 617
      if (i < 8) {
        {
#line 619
        addrcpy((char *)((void *)(& host[index___0].addrs[i])), addrcopy, af);
#line 620
        host[index___0].mplss[i] = mpls;
#line 621
        display_rawhost(index___0, (ip_t *)((void *)(& host[index___0].addrs[i])));
        }
      }
    }
  }
#line 625
  host[index___0].jitter = totusec - host[index___0].last;
#line 626
  if (host[index___0].jitter < 0) {
#line 626
    host[index___0].jitter = - host[index___0].jitter;
  }
#line 627
  host[index___0].last = totusec;
#line 629
  if (host[index___0].returned < 1) {
#line 630
    tmp___4 = totusec;
#line 630
    host[index___0].gmean = tmp___4;
#line 630
    tmp___3 = tmp___4;
#line 630
    host[index___0].worst = tmp___3;
#line 630
    host[index___0].best = tmp___3;
#line 631
    tmp___5 = 0LL;
#line 631
    host[index___0].var = tmp___5;
#line 631
    host[index___0].avg = (int )tmp___5;
#line 633
    tmp___7 = 0;
#line 633
    host[index___0].jinta = tmp___7;
#line 633
    tmp___6 = tmp___7;
#line 633
    host[index___0].jworst = tmp___6;
#line 633
    host[index___0].jitter = tmp___6;
  }
#line 647
  if (totusec < host[index___0].best) {
#line 647
    host[index___0].best = totusec;
  }
#line 648
  if (totusec > host[index___0].worst) {
#line 648
    host[index___0].worst = totusec;
  }
#line 650
  if (host[index___0].jitter > host[index___0].jworst) {
#line 651
    host[index___0].jworst = host[index___0].jitter;
  }
#line 653
  (host[index___0].returned) ++;
#line 654
  oldavg = host[index___0].avg;
#line 655
  host[index___0].avg = (int )((double )host[index___0].avg + ((double )(totusec - oldavg) + .0) / (double )host[index___0].returned);
#line 656
  host[index___0].var = (long long )((double )host[index___0].var + (((double )(totusec - oldavg) + .0) * (double )(totusec - host[index___0].avg)) / (double )1000000);
#line 658
  oldjavg = host[index___0].javg;
#line 659
  host[index___0].javg += (host[index___0].jitter - oldjavg) / host[index___0].returned;
#line 661
  host[index___0].jinta += host[index___0].jitter - ((host[index___0].jinta + 8) >> 4);
#line 663
  if (host[index___0].returned > 1) {
    {
#line 664
    tmp___8 = pow((double )host[index___0].gmean, ((double )host[index___0].returned - 1.0) / (double )host[index___0].returned);
#line 664
    tmp___9 = pow((double )totusec, 1.0 / (double )host[index___0].returned);
#line 664
    host[index___0].gmean = (int )(tmp___8 * tmp___9);
    }
  }
  {
#line 666
  host[index___0].sent = 0;
#line 667
  host[index___0].up = 1;
#line 668
  host[index___0].transit = 0;
#line 670
  net_save_return(index___0, sequence[seq].saved_seq, totusec);
#line 671
  display_rawping(index___0, totusec);
  }
#line 672
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_process_return(void) 
{ 
  char packet[4470] ;
  struct sockaddr_storage fromsockaddr_struct ;
  struct sockaddr_in6 *fsa6 ;
  struct sockaddr *fromsockaddr ;
  struct sockaddr_in *fsa4 ;
  socklen_t fromsockaddrsize ;
  int num ;
  struct ICMPHeader *header ;
  struct UDPHeader *udpheader ;
  struct TCPHeader *tcpheader ;
  struct timeval now ;
  ip_t *fromaddress ;
  int echoreplytype ;
  int timeexceededtype ;
  int unreachabletype ;
  int sequence___0 ;
  struct mplslen mpls ;
  ssize_t tmp ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;

  {
  {
#line 683
  fsa6 = (struct sockaddr_in6 *)(& fromsockaddr_struct);
#line 687
  fromsockaddr = (struct sockaddr *)(& fromsockaddr_struct);
#line 688
  fsa4 = (struct sockaddr_in *)(& fromsockaddr_struct);
#line 691
  header = (struct ICMPHeader *)((void *)0);
#line 692
  udpheader = (struct UDPHeader *)((void *)0);
#line 693
  tcpheader = (struct TCPHeader *)((void *)0);
#line 695
  fromaddress = (ip_t *)((void *)0);
#line 696
  echoreplytype = 0;
#line 696
  timeexceededtype = 0;
#line 696
  unreachabletype = 0;
#line 697
  sequence___0 = 0;
#line 701
  mpls.labels = (char)0;
#line 703
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
  {
#line 705
  if (af == 2) {
#line 705
    goto case_2;
  }
#line 713
  if (af == 10) {
#line 713
    goto case_10;
  }
#line 704
  goto switch_break;
  case_2: /* CIL Label */ 
#line 706
  fromsockaddrsize = (socklen_t )sizeof(struct sockaddr_in );
#line 707
  fromaddress = (ip_t *)(& fsa4->sin_addr);
#line 708
  echoreplytype = 0;
#line 709
  timeexceededtype = 11;
#line 710
  unreachabletype = 3;
#line 711
  goto switch_break;
  case_10: /* CIL Label */ 
#line 714
  fromsockaddrsize = (socklen_t )sizeof(struct sockaddr_in6 );
#line 715
  fromaddress = & fsa6->sin6_addr;
#line 716
  echoreplytype = 129;
#line 717
  timeexceededtype = 3;
#line 718
  unreachabletype = 1;
#line 719
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 723
  tmp = recvfrom(recvsock, (void */* __restrict  */)(packet), (size_t )4470, 0, (struct sockaddr */* __restrict  */)fromsockaddr,
                 (socklen_t */* __restrict  */)(& fromsockaddrsize));
#line 723
  num = (int )tmp;
  }
  {
#line 727
  if (af == 2) {
#line 727
    goto case_2___0;
  }
#line 733
  if (af == 10) {
#line 733
    goto case_10___0;
  }
#line 726
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 728
  if ((size_t )num < sizeof(struct IPHeader ) + sizeof(struct ICMPHeader )) {
#line 729
    return;
  }
#line 730
  header = (struct ICMPHeader *)(packet + sizeof(struct IPHeader ));
#line 731
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
#line 734
  if ((unsigned long )num < sizeof(struct ICMPHeader )) {
#line 735
    return;
  }
#line 737
  header = (struct ICMPHeader *)(packet);
#line 738
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 743
  if (mtrtype == 1) {
#line 743
    goto case_1;
  }
#line 789
  if (mtrtype == 17) {
#line 789
    goto case_17;
  }
#line 826
  if (mtrtype == 6) {
#line 826
    goto case_6;
  }
#line 742
  goto switch_break___1;
  case_1: /* CIL Label */ 
#line 744
  if ((int )header->type == echoreplytype) {
    {
#line 745
    tmp___0 = getpid();
    }
#line 745
    if ((int )header->id != (int )((uint16 )tmp___0)) {
#line 746
      return;
    }
#line 748
    sequence___0 = (int )header->sequence;
  } else
#line 749
  if ((int )header->type == timeexceededtype) {
    {
#line 751
    if (af == 2) {
#line 751
      goto case_2___1;
    }
#line 767
    if (af == 10) {
#line 767
      goto case_10___1;
    }
#line 750
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 753
    if ((size_t )num < ((sizeof(struct IPHeader ) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader )) + sizeof(struct ICMPHeader )) {
#line 757
      return;
    }
#line 758
    header = (struct ICMPHeader *)(((packet + sizeof(struct IPHeader )) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader ));
#line 762
    if (num > 160) {
      {
#line 763
      decodempls(num, packet, & mpls, 156);
      }
    }
#line 765
    goto switch_break___2;
    case_10___1: /* CIL Label */ 
#line 768
    if ((unsigned long )num < (sizeof(struct ICMPHeader ) + sizeof(struct ip6_hdr )) + sizeof(struct ICMPHeader )) {
#line 770
      return;
    }
#line 771
    header = (struct ICMPHeader *)((packet + sizeof(struct ICMPHeader )) + sizeof(struct ip6_hdr ));
#line 775
    if (num > 140) {
      {
#line 776
      decodempls(num, packet, & mpls, 136);
      }
    }
#line 778
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 782
    tmp___1 = getpid();
    }
#line 782
    if ((int )header->id != (int )((uint16 )tmp___1)) {
#line 783
      return;
    }
#line 785
    sequence___0 = (int )header->sequence;
  }
#line 787
  goto switch_break___1;
  case_17: /* CIL Label */ 
#line 790
  if ((int )header->type == timeexceededtype) {
#line 790
    goto _L;
  } else
#line 790
  if ((int )header->type == unreachabletype) {
    _L: /* CIL Label */ 
    {
#line 792
    if (af == 2) {
#line 792
      goto case_2___2;
    }
#line 808
    if (af == 10) {
#line 808
      goto case_10___2;
    }
#line 791
    goto switch_break___3;
    case_2___2: /* CIL Label */ 
#line 794
    if ((size_t )num < ((sizeof(struct IPHeader ) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader )) + sizeof(struct UDPHeader )) {
#line 798
      return;
    }
#line 799
    udpheader = (struct UDPHeader *)(((packet + sizeof(struct IPHeader )) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader ));
#line 803
    if (num > 160) {
      {
#line 804
      decodempls(num, packet, & mpls, 156);
      }
    }
#line 806
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
#line 809
    if ((unsigned long )num < (sizeof(struct ICMPHeader ) + sizeof(struct ip6_hdr )) + sizeof(struct UDPHeader )) {
#line 811
      return;
    }
#line 812
    udpheader = (struct UDPHeader *)((packet + sizeof(struct ICMPHeader )) + sizeof(struct ip6_hdr ));
#line 816
    if (num > 140) {
      {
#line 817
      decodempls(num, packet, & mpls, 136);
      }
    }
#line 819
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 822
    tmp___2 = ntohs(udpheader->dstport);
#line 822
    sequence___0 = (int )tmp___2;
    }
  }
#line 824
  goto switch_break___1;
  case_6: /* CIL Label */ 
#line 827
  if ((int )header->type == timeexceededtype) {
#line 827
    goto _L___0;
  } else
#line 827
  if ((int )header->type == unreachabletype) {
    _L___0: /* CIL Label */ 
    {
#line 829
    if (af == 2) {
#line 829
      goto case_2___3;
    }
#line 845
    if (af == 10) {
#line 845
      goto case_10___3;
    }
#line 828
    goto switch_break___4;
    case_2___3: /* CIL Label */ 
#line 831
    if ((size_t )num < ((sizeof(struct IPHeader ) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader )) + sizeof(struct TCPHeader )) {
#line 835
      return;
    }
#line 836
    tcpheader = (struct TCPHeader *)(((packet + sizeof(struct IPHeader )) + sizeof(struct ICMPHeader )) + sizeof(struct IPHeader ));
#line 840
    if (num > 160) {
      {
#line 841
      decodempls(num, packet, & mpls, 156);
      }
    }
#line 843
    goto switch_break___4;
    case_10___3: /* CIL Label */ 
#line 846
    if ((unsigned long )num < (sizeof(struct ICMPHeader ) + sizeof(struct ip6_hdr )) + sizeof(struct TCPHeader )) {
#line 848
      return;
    }
#line 849
    tcpheader = (struct TCPHeader *)((packet + sizeof(struct ICMPHeader )) + sizeof(struct ip6_hdr ));
#line 853
    if (num > 140) {
      {
#line 854
      decodempls(num, packet, & mpls, 136);
      }
    }
#line 856
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 859
    tmp___3 = ntohs(tcpheader->srcport);
#line 859
    sequence___0 = (int )tmp___3;
    }
  }
#line 861
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 864
  if (sequence___0) {
    {
#line 865
    net_process_ping(sequence___0, mpls, (void *)fromaddress, now);
    }
  }
#line 866
  return;
}
}
#line 869 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
ip_t *net_addr(int at ) 
{ 


  {
#line 871
  return (& host[at].addr);
}
}
#line 875 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
ip_t *net_addrs(int at , int i ) 
{ 


  {
#line 877
  return (& host[at].addrs[i]);
}
}
#line 880 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void *net_mpls(int at ) 
{ 


  {
#line 882
  return ((void *)((struct mplslen *)(& host[at].mplss)));
}
}
#line 885 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void *net_mplss(int at , int i ) 
{ 


  {
#line 887
  return ((void *)(& host[at].mplss[i]));
}
}
#line 890 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_loss(int at ) 
{ 


  {
#line 892
  if (host[at].xmit - host[at].transit == 0) {
#line 893
    return (0);
  }
#line 895
  return ((int )((double )1000 * ((double )100 - (100.0 * (double )host[at].returned) / (double )(host[at].xmit - host[at].transit))));
}
}
#line 899 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_drop(int at ) 
{ 


  {
#line 901
  return ((host[at].xmit - host[at].transit) - host[at].returned);
}
}
#line 905 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_last(int at ) 
{ 


  {
#line 907
  return (host[at].last);
}
}
#line 911 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_best(int at ) 
{ 


  {
#line 913
  return (host[at].best);
}
}
#line 917 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_worst(int at ) 
{ 


  {
#line 919
  return (host[at].worst);
}
}
#line 923 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_avg(int at ) 
{ 


  {
#line 925
  return (host[at].avg);
}
}
#line 929 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_gmean(int at ) 
{ 


  {
#line 931
  return (host[at].gmean);
}
}
#line 935 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_stdev(int at ) 
{ 
  double tmp ;

  {
#line 937
  if (host[at].returned > 1) {
    {
#line 938
    tmp = sqrt((double )host[at].var / ((double )host[at].returned - 1.0));
    }
#line 938
    return ((int )(1000.0 * tmp));
  } else {
#line 940
    return (0);
  }
}
}
#line 945 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_jitter(int at ) 
{ 


  {
#line 947
  return (host[at].jitter);
}
}
#line 951 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_jworst(int at ) 
{ 


  {
#line 953
  return (host[at].jworst);
}
}
#line 957 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_javg(int at ) 
{ 


  {
#line 959
  return (host[at].javg);
}
}
#line 963 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_jinta(int at ) 
{ 


  {
#line 965
  return (host[at].jinta);
}
}
#line 969 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_max(void) 
{ 
  int at ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 974
  max = 0;
#line 976
  at = 0;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! (at < maxTTL - 1)) {
#line 976
      goto while_break;
    }
    {
#line 977
    tmp___0 = addrcmp((char *)((void *)(& host[at].addr)), (char *)((void *)remoteaddress),
                      af);
    }
#line 977
    if (tmp___0 == 0) {
#line 979
      return (at + 1);
    } else {
      {
#line 980
      tmp = addrcmp((char *)((void *)(& host[at].addr)), (char *)((void *)(& unspec_addr)),
                    af);
      }
#line 980
      if (tmp != 0) {
#line 982
        max = at + 2;
      }
    }
#line 976
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return (max);
}
}
#line 990 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_min(void) 
{ 


  {
#line 992
  return (fstTTL - 1);
}
}
#line 996 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_returned(int at ) 
{ 


  {
#line 998
  return (host[at].returned);
}
}
#line 1002 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_xmit(int at ) 
{ 


  {
#line 1004
  return (host[at].xmit);
}
}
#line 1008 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_transit(int at ) 
{ 


  {
#line 1010
  return (host[at].transit);
}
}
#line 1014 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_up(int at ) 
{ 


  {
#line 1016
  return (host[at].up);
}
}
#line 1020 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
char *net_localaddr(void) 
{ 


  {
#line 1022
  return (localaddr);
}
}
#line 1026 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_end_transit(void) 
{ 
  int at ;

  {
#line 1030
  at = 0;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (at < 256)) {
#line 1030
      goto while_break;
    }
#line 1031
    host[at].transit = 0;
#line 1030
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1033
  return;
}
}
#line 1035 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_send_batch(void) 
{ 
  int n_unknown ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1037
  n_unknown = 0;
#line 1042
  if (batch_at < fstTTL) {
#line 1043
    if (cpacketsize < 0) {
      {
#line 1053
      tmp = rand();
#line 1053
      packetsize = 28 + tmp % (- cpacketsize - 28);
      }
    } else {
#line 1055
      packetsize = cpacketsize;
    }
#line 1057
    if (bitpattern < 0) {
      {
#line 1058
      tmp___0 = rand();
#line 1058
      bitpattern = - ((int )((double )256 + (double )255 * ((double )tmp___0 / ((double )2147483647 + 0.1))));
      }
    }
  }
  {
#line 1064
  net_send_query(batch_at);
#line 1066
  i = fstTTL - 1;
  }
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if (! (i < batch_at)) {
#line 1066
      goto while_break;
    }
    {
#line 1067
    tmp___1 = addrcmp((char *)((void *)(& host[i].addr)), (char *)((void *)(& unspec_addr)),
                      af);
    }
#line 1067
    if (tmp___1 == 0) {
#line 1068
      n_unknown ++;
    }
    {
#line 1075
    tmp___2 = addrcmp((char *)((void *)(& host[i].addr)), (char *)((void *)remoteaddress),
                      af);
    }
#line 1075
    if (tmp___2 == 0) {
#line 1078
      n_unknown = 256;
    }
#line 1066
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1081
  tmp___3 = addrcmp((char *)((void *)(& host[batch_at].addr)), (char *)((void *)remoteaddress),
                    af);
  }
#line 1081
  if (tmp___3 == 0) {
#line 1088
    numhosts = batch_at + 1;
#line 1089
    batch_at = fstTTL - 1;
#line 1090
    return (1);
  } else
#line 1081
  if (n_unknown > 5) {
#line 1088
    numhosts = batch_at + 1;
#line 1089
    batch_at = fstTTL - 1;
#line 1090
    return (1);
  } else
#line 1081
  if (batch_at >= maxTTL - 1) {
#line 1088
    numhosts = batch_at + 1;
#line 1089
    batch_at = fstTTL - 1;
#line 1090
    return (1);
  }
#line 1093
  batch_at ++;
#line 1094
  return (0);
}
}
#line 1098 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
static void set_fd_flags(int fd ) 
{ 
  int oldflags ;
  int tmp ;

  {
#line 1103
  if (fd < 0) {
#line 1103
    return;
  }
  {
#line 1105
  oldflags = fcntl(fd, 1);
  }
#line 1106
  if (oldflags == -1) {
    {
#line 1107
    perror("Couldn\'t get fd\'s flags");
    }
#line 1108
    return;
  }
  {
#line 1110
  tmp = fcntl(fd, 2, oldflags | 1);
  }
#line 1110
  if (tmp) {
    {
#line 1111
    perror("Couldn\'t set fd\'s flags");
    }
  }
#line 1113
  return;
}
}
#line 1115 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_preopen(void) 
{ 
  int trueopt ;
  int tmp ;

  {
  {
#line 1117
  trueopt = 1;
#line 1123
  sendsock4 = socket(2, 3, 255);
  }
#line 1125
  if (sendsock4 < 0) {
#line 1126
    return (-1);
  }
  {
#line 1128
  sendsock6_icmp = socket(10, 3, 58);
#line 1129
  sendsock6_udp = socket(10, 3, 17);
#line 1135
  tmp = setsockopt(sendsock4, 0, 3, (void const   *)(& trueopt), (socklen_t )sizeof(trueopt));
  }
#line 1135
  if (tmp) {
    {
#line 1136
    perror("setsockopt(IP_HDRINCL,1)");
    }
#line 1137
    return (-1);
  }
  {
#line 1141
  recvsock4 = socket(2, 3, 1);
  }
#line 1142
  if (recvsock4 < 0) {
#line 1143
    return (-1);
  }
  {
#line 1144
  set_fd_flags(recvsock4);
#line 1146
  recvsock6 = socket(10, 3, 58);
  }
#line 1147
  if (recvsock6 >= 0) {
    {
#line 1148
    set_fd_flags(recvsock6);
    }
  }
#line 1151
  return (0);
}
}
#line 1155 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_selectsocket(void) 
{ 


  {
#line 1167
  if (sendsock4 < 0) {
#line 1168
    return (-1);
  }
  {
#line 1171
  if (mtrtype == 1) {
#line 1171
    goto case_1;
  }
#line 1174
  if (mtrtype == 17) {
#line 1174
    goto case_17;
  }
#line 1170
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1172
  sendsock6 = sendsock6_icmp;
#line 1173
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1175
  sendsock6 = sendsock6_udp;
#line 1176
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1178
  if (sendsock6 < 0) {
#line 1178
    if (sendsock4 < 0) {
#line 1179
      return (-1);
    }
  }
#line 1182
  return (0);
}
}
#line 1186 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_open(struct hostent *host___0 ) 
{ 
  struct sockaddr_storage name_struct ;
  struct sockaddr *name ;
  socklen_t len ;

  {
  {
#line 1193
  name = (struct sockaddr *)(& name_struct);
#line 1196
  net_reset();
#line 1198
  remotesockaddr->sa_family = (sa_family_t )host___0->h_addrtype;
  }
  {
#line 1201
  if (host___0->h_addrtype == 2) {
#line 1201
    goto case_2;
  }
#line 1209
  if (host___0->h_addrtype == 10) {
#line 1209
    goto case_10;
  }
#line 1221
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1202
  sendsock = sendsock4;
#line 1203
  recvsock = recvsock4;
#line 1204
  addrcpy((char *)((void *)(& rsa4->sin_addr)), *(host___0->h_addr_list + 0), 2);
#line 1205
  sourceaddress = (ip_t *)(& ssa4->sin_addr);
#line 1206
  remoteaddress = (ip_t *)(& rsa4->sin_addr);
  }
#line 1207
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1210
  if (sendsock6 < 0) {
    {
#line 1211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open IPv6 socket\n");
#line 1212
    exit(1);
    }
  } else
#line 1210
  if (recvsock6 < 0) {
    {
#line 1211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open IPv6 socket\n");
#line 1212
    exit(1);
    }
  }
  {
#line 1214
  sendsock = sendsock6;
#line 1215
  recvsock = recvsock6;
#line 1216
  addrcpy((char *)((void *)(& rsa6->sin6_addr)), *(host___0->h_addr_list + 0), 10);
#line 1217
  sourceaddress = & ssa6->sin6_addr;
#line 1218
  remoteaddress = & rsa6->sin6_addr;
  }
#line 1219
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1222
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"net_open bad address type\n");
#line 1223
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1226
  len = (socklen_t )sizeof(name_struct);
#line 1227
  getsockname(recvsock, (struct sockaddr */* __restrict  */)name, (socklen_t */* __restrict  */)(& len));
#line 1228
  sockaddrtop(name, localaddr, sizeof(localaddr));
  }
#line 1233
  return (0);
}
}
#line 1237 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_reopen(struct hostent *addr ) 
{ 
  int at ;

  {
#line 1241
  at = 0;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (at < 256)) {
#line 1241
      goto while_break;
    }
    {
#line 1242
    memset((void *)(& host[at]), 0, sizeof(host[at]));
#line 1241
    at ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1245
  remotesockaddr->sa_family = (sa_family_t )addr->h_addrtype;
#line 1246
  addrcpy((char *)((void *)remoteaddress), *(addr->h_addr_list + 0), addr->h_addrtype);
  }
  {
#line 1249
  if (addr->h_addrtype == 2) {
#line 1249
    goto case_2;
  }
#line 1253
  if (addr->h_addrtype == 10) {
#line 1253
    goto case_10;
  }
#line 1257
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1250
  addrcpy((char *)((void *)(& rsa4->sin_addr)), *(addr->h_addr_list + 0), 2);
  }
#line 1251
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1254
  addrcpy((char *)((void *)(& rsa6->sin6_addr)), *(addr->h_addr_list + 0), 10);
  }
#line 1255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"net_reopen bad address type\n");
#line 1259
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1262
  net_reset();
#line 1263
  net_send_batch();
  }
#line 1264
  return;
}
}
#line 1267 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_reset(void) 
{ 
  int at ;
  int i ;

  {
#line 1272
  batch_at = fstTTL - 1;
#line 1273
  numhosts = 10;
#line 1275
  at = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! (at < 256)) {
#line 1275
      goto while_break;
    }
#line 1276
    host[at].xmit = 0;
#line 1277
    host[at].transit = 0;
#line 1278
    host[at].returned = 0;
#line 1279
    host[at].sent = 0;
#line 1280
    host[at].up = 0;
#line 1281
    host[at].last = 0;
#line 1282
    host[at].avg = 0;
#line 1283
    host[at].best = 0;
#line 1284
    host[at].worst = 0;
#line 1285
    host[at].gmean = 0;
#line 1286
    host[at].var = 0LL;
#line 1287
    host[at].jitter = 0;
#line 1288
    host[at].javg = 0;
#line 1289
    host[at].jworst = 0;
#line 1290
    host[at].jinta = 0;
#line 1291
    i = 0;
    {
#line 1291
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1291
      if (! (i < 200)) {
#line 1291
        goto while_break___0;
      }
#line 1292
      host[at].saved[i] = -2;
#line 1291
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1294
    host[at].saved_seq_offset = -198;
#line 1275
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  at = 0;
  {
#line 1297
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1297
    if (! (at < 65536)) {
#line 1297
      goto while_break___1;
    }
#line 1298
    sequence[at].transit = 0;
#line 1299
    if (sequence[at].socket > 0) {
      {
#line 1300
      close(sequence[at].socket);
#line 1301
      sequence[at].socket = 0;
      }
    }
#line 1297
    at ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1305
  gettimeofday((struct timeval */* __restrict  */)(& reset), (__timezone_ptr_t )((void *)0));
  }
#line 1306
  return;
}
}
#line 1309 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_set_interfaceaddress(char *InterfaceAddress___0 ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1311
  len = 0;
#line 1313
  if (! InterfaceAddress___0) {
#line 1313
    return (0);
  }
#line 1315
  sourcesockaddr->sa_family = (sa_family_t )af;
  {
#line 1317
  if (af == 2) {
#line 1317
    goto case_2;
  }
#line 1326
  if (af == 10) {
#line 1326
    goto case_10;
  }
#line 1316
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1318
  ssa4->sin_port = (in_port_t )0;
#line 1319
  tmp = inet_aton((char const   *)InterfaceAddress___0, & ssa4->sin_addr);
  }
#line 1319
  if (tmp < 1) {
    {
#line 1320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: bad interface address: %s\n",
            InterfaceAddress___0);
    }
#line 1321
    return (1);
  }
#line 1323
  len = (int )sizeof(struct sockaddr );
#line 1324
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1327
  ssa6->sin6_port = (in_port_t )0;
#line 1328
  tmp___0 = inet_pton(af, (char const   */* __restrict  */)InterfaceAddress___0, (void */* __restrict  */)(& ssa6->sin6_addr));
  }
#line 1328
  if (tmp___0 < 1) {
    {
#line 1329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mtr: bad interface address: %s\n",
            InterfaceAddress___0);
    }
#line 1330
    return (1);
  }
#line 1332
  len = (int )sizeof(struct sockaddr_in6 );
#line 1333
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1337
  tmp___1 = bind(sendsock, (struct sockaddr  const  *)sourcesockaddr, (socklen_t )len);
  }
#line 1337
  if (tmp___1 == -1) {
    {
#line 1338
    perror("mtr: failed to bind to interface");
    }
#line 1339
    return (1);
  }
#line 1341
  return (0);
}
}
#line 1346 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_close(void) 
{ 


  {
#line 1348
  if (sendsock4 >= 0) {
    {
#line 1349
    close(sendsock4_icmp);
#line 1350
    close(sendsock4_udp);
    }
  }
#line 1352
  if (recvsock4 >= 0) {
    {
#line 1352
    close(recvsock4);
    }
  }
#line 1353
  if (sendsock6 >= 0) {
    {
#line 1354
    close(sendsock6_icmp);
#line 1355
    close(sendsock6_udp);
    }
  }
#line 1357
  if (recvsock6 >= 0) {
    {
#line 1357
    close(recvsock6);
    }
  }
#line 1358
  return;
}
}
#line 1361 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int net_waitfd(void) 
{ 


  {
#line 1363
  return (recvsock);
}
}
#line 1367 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int *net_saved_pings(int at ) 
{ 


  {
#line 1369
  return (host[at].saved);
}
}
#line 1373 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_save_increment(void) 
{ 
  int at ;

  {
#line 1376
  at = 0;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! (at < 256)) {
#line 1376
      goto while_break;
    }
    {
#line 1377
    memmove((void *)(host[at].saved), (void const   *)(host[at].saved + 1), 199UL * sizeof(int ));
#line 1378
    host[at].saved[199] = -2;
#line 1379
    (host[at].saved_seq_offset) ++;
#line 1376
    at ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1381
  return;
}
}
#line 1384 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_save_xmit(int at ) 
{ 


  {
#line 1386
  if (host[at].saved[199] != -2) {
    {
#line 1387
    net_save_increment();
    }
  }
#line 1388
  host[at].saved[199] = -1;
#line 1389
  return;
}
}
#line 1392 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_save_return(int at , int seq , int ms ) 
{ 
  int idx ;

  {
#line 1395
  idx = seq - host[at].saved_seq_offset;
#line 1396
  if (idx < 0) {
#line 1397
    return;
  } else
#line 1396
  if (idx > 200) {
#line 1397
    return;
  }
#line 1399
  host[at].saved[idx] = ms;
#line 1400
  return;
}
}
#line 1403 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void sockaddrtop(struct sockaddr *saddr , char *strptr , size_t len ) 
{ 
  struct sockaddr_in *sa4 ;
  struct sockaddr_in6 *sa6 ;
  char *tmp ;

  {
  {
#line 1410
  if ((int )saddr->sa_family == 2) {
#line 1410
    goto case_2;
  }
#line 1416
  if ((int )saddr->sa_family == 10) {
#line 1416
    goto case_10;
  }
#line 1421
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1411
  sa4 = (struct sockaddr_in *)saddr;
#line 1412
  tmp = inet_ntoa(sa4->sin_addr);
#line 1412
  strncpy((char */* __restrict  */)strptr, (char const   */* __restrict  */)tmp, len - 1UL);
#line 1413
  *(strptr + (len - 1UL)) = (char )'\000';
  }
#line 1414
  return;
  case_10: /* CIL Label */ 
  {
#line 1417
  sa6 = (struct sockaddr_in6 *)saddr;
#line 1418
  inet_ntop((int )sa6->sin6_family, (void const   */* __restrict  */)(& sa6->sin6_addr),
            (char */* __restrict  */)strptr, (socklen_t )len);
  }
#line 1419
  return;
  switch_default: /* CIL Label */ 
  {
#line 1422
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sockaddrtop unknown address type\n");
#line 1423
  *(strptr + 0) = (char )'\000';
  }
#line 1424
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1429 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
int addrcmp(char *a , char *b , int af___0 ) 
{ 
  int rc ;

  {
#line 1430
  rc = -1;
  {
#line 1433
  if (af___0 == 2) {
#line 1433
    goto case_2;
  }
#line 1437
  if (af___0 == 10) {
#line 1437
    goto case_10;
  }
#line 1432
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1434
  rc = memcmp((void const   *)a, (void const   *)b, sizeof(struct in_addr ));
  }
#line 1435
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1438
  rc = memcmp((void const   *)a, (void const   *)b, sizeof(struct in6_addr ));
  }
#line 1439
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1443
  return (rc);
}
}
#line 1447 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void addrcpy(char *a , char *b , int af___0 ) 
{ 


  {
  {
#line 1450
  if (af___0 == 2) {
#line 1450
    goto case_2;
  }
#line 1454
  if (af___0 == 10) {
#line 1454
    goto case_10;
  }
#line 1449
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1451
  memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b, sizeof(struct in_addr ));
  }
#line 1452
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1455
  memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b, sizeof(struct in6_addr ));
  }
#line 1456
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1459
  return;
}
}
#line 1462 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void decodempls(int num , char *packet , struct mplslen *mpls , int offset ) 
{ 
  int i ;
  unsigned int ext_ver ;
  unsigned int ext_res ;
  unsigned int ext_chk ;
  unsigned int obj_hdr_len ;
  u_char obj_hdr_class ;
  u_char obj_hdr_type ;

  {
#line 1470
  ext_ver = (unsigned int )((int )*(packet + offset) >> 4);
#line 1471
  ext_res = (unsigned int )(((int )*(packet + offset) & 15) + (int )*(packet + (offset + 1)));
#line 1472
  ext_chk = ((unsigned int )*(packet + (offset + 2)) << 8) + (unsigned int )*(packet + (offset + 3));
#line 1475
  if (ext_ver == 2U) {
#line 1475
    if (ext_res == 0U) {
#line 1475
      if (ext_chk != 0U) {
#line 1475
        if (num >= offset + 6) {
#line 1476
          obj_hdr_len = (unsigned int )(((int )*(packet + (offset + 4)) << 8) + (int )*(packet + (offset + 5)));
#line 1477
          obj_hdr_class = (u_char )*(packet + (offset + 6));
#line 1478
          obj_hdr_type = (u_char )*(packet + (offset + 7));
#line 1481
          if (obj_hdr_len >= 8U) {
#line 1481
            if ((int )obj_hdr_class == 1) {
#line 1481
              if ((int )obj_hdr_type == 1) {
#line 1483
                mpls->labels = (char )((obj_hdr_len - 4U) / 4U);
#line 1486
                i = 0;
                {
#line 1486
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1486
                  if (i < (int )mpls->labels) {
#line 1486
                    if (i < 8) {
#line 1486
                      if (! (num >= (offset + 8) + i * 4)) {
#line 1486
                        goto while_break;
                      }
                    } else {
#line 1486
                      goto while_break;
                    }
                  } else {
#line 1486
                    goto while_break;
                  }
#line 1489
                  mpls->label[i] = ((unsigned long )(((int )*(packet + ((offset + 8) + i * 4)) << 12) & 1044480) + (unsigned long )((unsigned int )(((int )*(packet + ((offset + 9) + i * 4)) << 4) & 4080))) + (unsigned long )(((int )*(packet + ((offset + 10) + i * 4)) >> 4) & 15);
#line 1492
                  mpls->exp[i] = (uint8 )(((int )*(packet + ((offset + 10) + i * 4)) >> 1) & 7);
#line 1493
                  mpls->s[i] = (char )((int )*(packet + ((offset + 10) + i * 4)) & 1);
#line 1494
                  mpls->ttl[i] = (uint8 )*(packet + ((offset + 11) + i * 4));
#line 1486
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1498
  return;
}
}
#line 1501 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_add_fds(fd_set *writefd , int *maxfd ) 
{ 
  int at ;
  int fd ;

  {
#line 1504
  at = 0;
  {
#line 1504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1504
    if (! (at < 65536)) {
#line 1504
      goto while_break;
    }
#line 1505
    fd = sequence[at].socket;
#line 1506
    if (fd > 0) {
#line 1507
      writefd->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 1508
      if (fd >= *maxfd) {
#line 1509
        *maxfd = fd + 1;
      }
    }
#line 1504
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1512
  return;
}
}
#line 1515 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_process_fds(fd_set *writefd ) 
{ 
  int at ;
  int fd ;
  int r ;
  struct timeval now ;
  uint64_t unow ;
  uint64_t utime ;
  struct mplslen mpls ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1523
  mpls.labels = (char)0;
#line 1525
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 1526
  unow = (uint64_t )(now.tv_sec * 1000000L + now.tv_usec);
#line 1528
  at = 0;
  }
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! (at < 65536)) {
#line 1528
      goto while_break;
    }
#line 1529
    fd = sequence[at].socket;
#line 1530
    if (fd > 0) {
#line 1530
      if ((writefd->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1531
        tmp = write(fd, (void const   *)"G", (size_t )1);
#line 1531
        r = (int )tmp;
        }
#line 1535
        if (r == 1) {
          {
#line 1536
          net_process_ping(at, mpls, (void *)remoteaddress, now);
          }
        } else {
          {
#line 1535
          tmp___1 = __errno_location();
          }
#line 1535
          if (*tmp___1 == 111) {
            {
#line 1536
            net_process_ping(at, mpls, (void *)remoteaddress, now);
            }
          } else {
            {
#line 1537
            tmp___0 = __errno_location();
            }
#line 1537
            if (*tmp___0 != 11) {
              {
#line 1538
              close(fd);
#line 1539
              sequence[at].socket = 0;
              }
            }
          }
        }
      }
    }
#line 1542
    if (fd > 0) {
#line 1543
      utime = (uint64_t )(sequence[at].time.tv_sec * 1000000L + sequence[at].time.tv_usec);
#line 1544
      if (unow - utime > (uint64_t )timeout) {
        {
#line 1545
        close(fd);
#line 1546
        sequence[at].socket = 0;
        }
      }
    }
#line 1528
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1550
  return;
}
}
#line 1553 "/home/wheatley/newnew/temp/mtr-0.85/net.c"
void net_harvest_fds(void) 
{ 
  fd_set writefd ;
  int maxfd ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;

  {
#line 1556
  maxfd = 0;
  {
#line 1559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1559
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefd.__fds_bits[0]): "memory");
#line 1559
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1560
  tv.tv_sec = (__time_t )0;
#line 1561
  tv.tv_usec = (__suseconds_t )0;
#line 1562
  net_add_fds(& writefd, & maxfd);
#line 1563
  select(maxfd, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& writefd),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 1564
  net_process_fds(& writefd);
  }
#line 1565
  return;
}
}
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 366 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_ninit)(res_state  ) ;
#line 380
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_nmkquery)(res_state  ,
                                                                                     int  ,
                                                                                     char const   * ,
                                                                                     int  ,
                                                                                     int  ,
                                                                                     u_char const   * ,
                                                                                     int  ,
                                                                                     u_char const   * ,
                                                                                     u_char * ,
                                                                                     int  ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 776
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 51 "/home/wheatley/newnew/temp/mtr-0.85/dns.h"
struct hostent *dns_forward(char const   *name ) ;
#line 54
void addr2ip6arpa(ip_t *ip , char *buf ) ;
#line 124 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *opcodes[4]  = {      (char *)"standard query",      (char *)"inverse query",      (char *)"server status request",      (char *)"unknown"};
#line 132 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *responsecodes[7]  = {      (char *)"no error",      (char *)"format error in query",      (char *)"server failure",      (char *)"queried domain name does not exist", 
        (char *)"requested query type not implemented",      (char *)"refused by name server",      (char *)"unknown error"};
#line 143 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *resourcetypes[18]  = 
#line 143
  {      (char *)"unknown type",      (char *)"A: host address",      (char *)"NS: authoritative name server",      (char *)"MD: mail destination (OBSOLETE)", 
        (char *)"MF: mail forwarder (OBSOLETE)",      (char *)"CNAME: name alias",      (char *)"SOA: authority record",      (char *)"MB: mailbox domain name (EXPERIMENTAL)", 
        (char *)"MG: mail group member (EXPERIMENTAL)",      (char *)"MR: mail rename domain name (EXPERIMENTAL)",      (char *)"NULL: NULL RR (EXPERIMENTAL)",      (char *)"WKS: well known service description", 
        (char *)"PTR: domain name pointer",      (char *)"HINFO: host information",      (char *)"MINFO: mailbox or mail list information",      (char *)"MX: mail exchange", 
        (char *)"TXT: text string",      (char *)"unknown type"};
#line 165 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *classtypes[6]  = {      (char *)"unknown class",      (char *)"IN: the Internet",      (char *)"CS: CSNET (OBSOLETE)",      (char *)"CH: CHAOS", 
        (char *)"HS: Hesoid [Dyer 87]",      (char *)"unknown class"};
#line 174 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *rrtypes[5]  = {      (char *)"Unknown",      (char *)"Query",      (char *)"Answer",      (char *)"Authority reference", 
        (char *)"Resource reference"};
#line 259 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword resrecvbuf[519 >> 2]  ;
#line 261 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *idbash[8192]  ;
#line 262 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *ipbash[8192]  ;
#line 263 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *hostbash[8192]  ;
#line 264 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *expireresolves  =    (struct resolve *)((void *)0);
#line 265 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *lastresolve  =    (struct resolve *)((void *)0);
#line 266 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct logline *streamlog  =    (struct logline *)((void *)0);
#line 267 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct logline *lastlog  =    (struct logline *)((void *)0);
#line 269 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
ip_t alignedip  ;
#line 270 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
ip_t localhost  ;
#line 272 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
ip_t localhost6  ;
#line 275 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
double sweeptime  ;
#line 280 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int debug  =    0;
#line 283 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword mem  =    (dword )0;
#line 285 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_iplookupsuccess  =    (dword )0;
#line 286 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_reversesuccess  =    (dword )0;
#line 287 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_nxdomain  =    (dword )0;
#line 288 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_nserror  =    (dword )0;
#line 289 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_hostipmismatch  =    (dword )0;
#line 290 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_unknownid  =    (dword )0;
#line 291 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_resend  =    (dword )0;
#line 292 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword res_timeout  =    (dword )0;
#line 294 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword resolvecount  =    (dword )0;
#line 296 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
long idseed  =    3735928559L;
#line 297 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
long aseed  ;
#line 300 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct sockaddr_storage from_sastruct  ;
#line 301 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct sockaddr_in6 *from6  =    (struct sockaddr_in6 *)(& from_sastruct);
#line 306 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct sockaddr_in *from4  =    (struct sockaddr_in *)(& from_sastruct);
#line 307 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct sockaddr *from  =    (struct sockaddr *)(& from_sastruct);
#line 309 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int resfd  ;
#line 311 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int resfd6  ;
#line 313 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
socklen_t fromlen  =    (socklen_t )sizeof(from_sastruct);
#line 315 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char tempstring[16386]  ;
#line 316 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char sendstring[1025]  ;
#line 317 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char namestring[1025]  ;
#line 318 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char stackstring[1025]  ;
#line 320 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char nullstring[1]  = {      (char )'\000'};
#line 322 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int use_dns  =    1;
#line 328 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct __res_state myres  ;
#line 353 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void *statmalloc(size_t size ) 
{ 
  void *p ;
  size_t mallocsize ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 358
  mem += size;
#line 359
  mallocsize = size + sizeof(dword );
#line 361
  p = malloc(mallocsize);
  }
#line 362
  if (! p) {
    {
#line 363
    tmp = __errno_location();
#line 363
    tmp___0 = strerror(*tmp);
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc() of %u bytes failed: %s\n",
            (unsigned int )size, tmp___0);
#line 364
    exit(-1);
    }
  }
#line 366
  *((dword *)p) = size;
#line 373
  p = (void *)((dword *)p + 1);
#line 377
  return (p);
}
}
#line 381 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void statfree(void *p ) 
{ 


  {
#line 383
  if (p) {
#line 384
    if (*((dword *)p - 1) == 0UL) {
      {
#line 385
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Attempt to free pointer twice.\n");
#line 386
      abort();
#line 387
      exit(-1);
      }
    } else {
#line 389
      if (*((dword *)p - 1) > 8192UL) {
        {
#line 390
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Corrupted free() buffer. (header)\n");
#line 391
        abort();
#line 392
        exit(-1);
        }
      }
      {
#line 404
      mem -= *((dword *)p - 1);
#line 409
      free((void *)((dword *)p - 1));
      }
    }
  }
#line 412
  return;
}
}
#line 415 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *strtdiff(char *d , long signeddiff ) 
{ 
  dword diff ;
  dword seconds ;
  dword minutes ;
  dword hours ;
  long days ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;

  {
  {
#line 421
  tmp___2 = labs(signeddiff);
#line 421
  diff = (dword )tmp___2;
  }
#line 421
  if (diff) {
#line 422
    seconds = diff % 60UL;
#line 422
    diff /= 60UL;
#line 423
    minutes = diff % 60UL;
#line 423
    diff /= 60UL;
#line 424
    hours = diff % 24UL;
#line 425
    days = signeddiff / 86400L;
#line 426
    if (days) {
      {
#line 427
      sprintf((char */* __restrict  */)d, (char const   */* __restrict  */)"%lid",
              days);
      }
    } else {
#line 429
      *d = (char )'\000';
    }
#line 430
    if (hours) {
      {
#line 431
      tmp = strlen((char const   *)d);
#line 431
      sprintf((char */* __restrict  */)(d + tmp), (char const   */* __restrict  */)"%luh",
              hours);
      }
    }
#line 432
    if (minutes) {
      {
#line 433
      tmp___0 = strlen((char const   *)d);
#line 433
      sprintf((char */* __restrict  */)(d + tmp___0), (char const   */* __restrict  */)"%lum",
              minutes);
      }
    }
#line 434
    if (seconds) {
      {
#line 435
      tmp___1 = strlen((char const   *)d);
#line 435
      sprintf((char */* __restrict  */)(d + tmp___1), (char const   */* __restrict  */)"%lus",
              seconds);
      }
    }
  } else {
    {
#line 437
    sprintf((char */* __restrict  */)d, (char const   */* __restrict  */)"0s");
    }
  }
#line 438
  return (d);
}
}
#line 442 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int issetfd(fd_set *set , int fd ) 
{ 
  int tmp ;

  {
#line 444
  if ((set->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 444
    tmp = 1;
  } else {
#line 444
    tmp = 0;
  }
#line 444
  return (tmp);
}
}
#line 448 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void setfd(fd_set *set , int fd ) 
{ 


  {
#line 450
  set->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 451
  return;
}
}
#line 454 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void clearfd(fd_set *set , int fd ) 
{ 


  {
#line 456
  set->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 457
  return;
}
}
#line 460 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void clearset(fd_set *set ) 
{ 
  int __d0 ;
  int __d1 ;

  {
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& set->__fds_bits[0]): "memory");
#line 462
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return;
}
}
#line 469 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
static char addrstr[46]  ;
#line 466 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *strlongip(ip_t *ip ) 
{ 
  char const   *tmp ;

  {
  {
#line 471
  tmp = inet_ntop(af, (void const   */* __restrict  */)ip, (char */* __restrict  */)(addrstr),
                  (socklen_t )sizeof(addrstr));
  }
#line 471
  return ((char *)tmp);
}
}
#line 478 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int longipstr(char *s , ip_t *dst , int af___0 ) 
{ 
  int tmp ;

  {
  {
#line 481
  tmp = inet_pton(af___0, (char const   */* __restrict  */)s, (void */* __restrict  */)dst);
  }
#line 481
  return (tmp);
}
}
#line 488 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct hostent *dns_forward(char const   *name ) 
{ 
  struct hostent *host___0 ;

  {
  {
#line 492
  host___0 = gethostbyname(name);
  }
#line 492
  if (host___0) {
#line 493
    return (host___0);
  } else {
#line 495
    return ((struct hostent *)((void *)0));
  }
}
}
#line 499 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int dns_waitfd(void) 
{ 


  {
#line 501
  return (resfd);
}
}
#line 504 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int dns_waitfd6(void) 
{ 


  {
#line 506
  return (resfd6);
}
}
#line 511 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void dns_open(void) 
{ 
  int option ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  time_t tmp___9 ;
  time_t tmp___10 ;
  __pid_t tmp___11 ;

  {
#line 515
  if (! dns) {
#line 515
    return;
  }
  {
#line 516
  __res_ninit(& myres);
  }
#line 517
  if (! myres.nscount) {
    {
#line 518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No nameservers defined.\n");
#line 519
    exit(-1);
    }
  }
  {
#line 521
  myres.options |= 704UL;
#line 522
  resfd = socket(2, 2, 0);
  }
#line 523
  if (resfd == -1) {
    {
#line 524
    tmp = __errno_location();
#line 524
    tmp___0 = strerror(*tmp);
#line 524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate IPv4 socket for nameserver communication: %s\n",
            tmp___0);
#line 527
    exit(-1);
    }
  }
  {
#line 530
  resfd6 = socket(10, 2, 0);
  }
#line 531
  if (resfd6 == -1) {
    {
#line 532
    tmp___1 = __errno_location();
#line 532
    tmp___2 = strerror(*tmp___1);
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate IPv6 socket for nameserver communication: %s\n",
            tmp___2);
#line 535
    exit(-1);
    }
  }
  {
#line 538
  option = 1;
#line 539
  tmp___5 = setsockopt(resfd, 1, 6, (void const   *)((char *)(& option)), (socklen_t )sizeof(option));
  }
#line 539
  if (tmp___5) {
    {
#line 540
    tmp___3 = __errno_location();
#line 540
    tmp___4 = strerror(*tmp___3);
#line 540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to setsockopt() on IPv4 nameserver communication socket: %s\n",
            tmp___4);
#line 543
    exit(-1);
    }
  }
  {
#line 546
  tmp___8 = setsockopt(resfd6, 1, 6, (void const   *)((char *)(& option)), (socklen_t )sizeof(option));
  }
#line 546
  if (tmp___8) {
    {
#line 547
    tmp___6 = __errno_location();
#line 547
    tmp___7 = strerror(*tmp___6);
#line 547
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to setsockopt() on IPv6 nameserver communication socket: %s\n",
            tmp___7);
#line 550
    exit(-1);
    }
  }
  {
#line 553
  longipstr((char *)"127.0.0.1", & localhost, 2);
#line 555
  longipstr((char *)"::1", & localhost6, 10);
#line 557
  tmp___9 = time((time_t *)((void *)0));
#line 557
  tmp___10 = time((time_t *)((void *)0));
#line 557
  tmp___11 = getpid();
#line 557
  aseed = (long )((unsigned long )(tmp___9 ^ (tmp___10 << 3)) ^ (dword )tmp___11);
#line 558
  i = 0;
  }
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i < 8192)) {
#line 558
      goto while_break;
    }
#line 559
    idbash[i] = (struct resolve *)((void *)0);
#line 560
    hostbash[i] = (struct resolve *)((void *)0);
#line 558
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 565 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *allocresolve(void) 
{ 
  struct resolve *rp ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 569
  tmp = statmalloc(sizeof(struct resolve ));
#line 569
  rp = (struct resolve *)tmp;
  }
#line 570
  if (! rp) {
    {
#line 571
    tmp___0 = __errno_location();
#line 571
    tmp___1 = strerror(*tmp___0);
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"statmalloc() failed: %s\n",
            tmp___1);
#line 572
    exit(-1);
    }
  }
  {
#line 574
  memset((void *)rp, 0, sizeof(struct resolve ));
  }
#line 575
  return (rp);
}
}
#line 579 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword getidbash(word id ) 
{ 


  {
#line 581
  return ((dword )((int )id & 8191));
}
}
#line 585 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword getipbash(ip_t *ip ) 
{ 
  char *p ;
  int i ;
  int len ;
  dword bashvalue ;

  {
#line 587
  p = (char *)ip;
#line 588
  len = 0;
#line 589
  bashvalue = (dword )0;
  {
#line 592
  if (af == 2) {
#line 592
    goto case_2;
  }
#line 596
  if (af == 10) {
#line 596
    goto case_10;
  }
#line 591
  goto switch_break;
  case_2: /* CIL Label */ 
#line 593
  len = (int )sizeof(struct in_addr );
#line 594
  goto switch_break;
  case_10: /* CIL Label */ 
#line 597
  len = (int )sizeof(struct in6_addr );
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  i = 0;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! (i < len)) {
#line 601
      goto while_break;
    }
#line 602
    bashvalue ^= (unsigned long )*p;
#line 603
    bashvalue += (dword )((int )*p >> 1) + (bashvalue >> 1);
#line 601
    i ++;
#line 601
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return (bashvalue & 8191UL);
}
}
#line 609 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
dword gethostbash(char *host___0 ) 
{ 
  dword bashvalue ;

  {
#line 611
  bashvalue = (dword )0;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! *host___0) {
#line 613
      goto while_break;
    }
#line 614
    bashvalue ^= (unsigned long )*host___0;
#line 615
    bashvalue += (dword )((int )*host___0 >> 1) + (bashvalue >> 1);
#line 613
    host___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  return (bashvalue & 8191UL);
}
}
#line 621 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void linkresolveid(struct resolve *addrp ) 
{ 
  struct resolve *rp ;
  dword bashnum ;
  struct resolve *tmp ;

  {
  {
#line 626
  bashnum = getidbash(addrp->id);
#line 627
  rp = idbash[bashnum];
  }
#line 628
  if (rp) {
    {
#line 629
    while (1) {
      while_continue: /* CIL Label */ ;
#line 629
      if (rp->nextid) {
#line 629
        if (! ((int )addrp->id > (int )(rp->nextid)->id)) {
#line 629
          goto while_break;
        }
      } else {
#line 629
        goto while_break;
      }
#line 630
      rp = rp->nextid;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      if (rp->previousid) {
#line 631
        if (! ((int )addrp->id < (int )(rp->previousid)->id)) {
#line 631
          goto while_break___0;
        }
      } else {
#line 631
        goto while_break___0;
      }
#line 632
      rp = rp->previousid;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 633
    if ((int )rp->id < (int )addrp->id) {
#line 634
      addrp->previousid = rp;
#line 635
      addrp->nextid = rp->nextid;
#line 636
      if (rp->nextid) {
#line 637
        (rp->nextid)->previousid = addrp;
      }
#line 638
      rp->nextid = addrp;
    } else {
#line 640
      addrp->previousid = rp->previousid;
#line 641
      addrp->nextid = rp;
#line 642
      if (rp->previousid) {
#line 643
        (rp->previousid)->nextid = addrp;
      }
#line 644
      rp->previousid = addrp;
    }
  } else {
#line 647
    tmp = (struct resolve *)((void *)0);
#line 647
    addrp->previousid = tmp;
#line 647
    addrp->nextid = tmp;
  }
#line 648
  idbash[bashnum] = addrp;
#line 649
  return;
}
}
#line 652 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void unlinkresolveid(struct resolve *rp ) 
{ 
  dword bashnum ;

  {
  {
#line 656
  bashnum = getidbash(rp->id);
  }
#line 657
  if ((unsigned long )idbash[bashnum] == (unsigned long )rp) {
#line 658
    if (rp->previousid) {
#line 658
      idbash[bashnum] = rp->previousid;
    } else {
#line 658
      idbash[bashnum] = rp->nextid;
    }
  }
#line 659
  if (rp->nextid) {
#line 660
    (rp->nextid)->previousid = rp->previousid;
  }
#line 661
  if (rp->previousid) {
#line 662
    (rp->previousid)->nextid = rp->nextid;
  }
#line 663
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void linkresolvehost(struct resolve *addrp ) 
{ 
  struct resolve *rp ;
  dword bashnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct resolve *tmp___2 ;

  {
  {
#line 671
  bashnum = gethostbash(addrp->hostname);
#line 672
  rp = hostbash[bashnum];
  }
#line 673
  if (rp) {
    {
#line 674
    while (1) {
      while_continue: /* CIL Label */ ;
#line 674
      if (rp->nexthost) {
        {
#line 674
        tmp = strcasecmp((char const   *)addrp->hostname, (char const   *)(rp->nexthost)->hostname);
        }
#line 674
        if (! (tmp < 0)) {
#line 674
          goto while_break;
        }
      } else {
#line 674
        goto while_break;
      }
#line 675
      rp = rp->nexthost;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 676
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 676
      if (rp->previoushost) {
        {
#line 676
        tmp___0 = strcasecmp((char const   *)addrp->hostname, (char const   *)(rp->previoushost)->hostname);
        }
#line 676
        if (! (tmp___0 > 0)) {
#line 676
          goto while_break___0;
        }
      } else {
#line 676
        goto while_break___0;
      }
#line 677
      rp = rp->previoushost;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 678
    tmp___1 = strcasecmp((char const   *)addrp->hostname, (char const   *)rp->hostname);
    }
#line 678
    if (tmp___1 < 0) {
#line 679
      addrp->previoushost = rp;
#line 680
      addrp->nexthost = rp->nexthost;
#line 681
      if (rp->nexthost) {
#line 682
        (rp->nexthost)->previoushost = addrp;
      }
#line 683
      rp->nexthost = addrp;
    } else {
#line 685
      addrp->previoushost = rp->previoushost;
#line 686
      addrp->nexthost = rp;
#line 687
      if (rp->previoushost) {
#line 688
        (rp->previoushost)->nexthost = addrp;
      }
#line 689
      rp->previoushost = addrp;
    }
  } else {
#line 692
    tmp___2 = (struct resolve *)((void *)0);
#line 692
    addrp->previoushost = tmp___2;
#line 692
    addrp->nexthost = tmp___2;
  }
#line 693
  hostbash[bashnum] = addrp;
#line 694
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void unlinkresolvehost(struct resolve *rp ) 
{ 
  dword bashnum ;

  {
  {
#line 701
  bashnum = gethostbash(rp->hostname);
  }
#line 702
  if ((unsigned long )hostbash[bashnum] == (unsigned long )rp) {
#line 703
    if (rp->previoushost) {
#line 703
      hostbash[bashnum] = rp->previoushost;
    } else {
#line 703
      hostbash[bashnum] = rp->nexthost;
    }
  }
#line 704
  if (rp->nexthost) {
#line 705
    (rp->nexthost)->previoushost = rp->previoushost;
  }
#line 706
  if (rp->previoushost) {
#line 707
    (rp->previoushost)->nexthost = rp->nexthost;
  }
  {
#line 708
  statfree((void *)rp->hostname);
  }
#line 709
  return;
}
}
#line 712 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void linkresolveip(struct resolve *addrp ) 
{ 
  struct resolve *rp ;
  dword bashnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct resolve *tmp___2 ;

  {
  {
#line 717
  bashnum = getipbash(& addrp->ip);
#line 718
  rp = ipbash[bashnum];
  }
#line 719
  if (rp) {
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (rp->nextip) {
        {
#line 720
        tmp = addrcmp((char *)((void *)(& addrp->ip)), (char *)((void *)(& (rp->nextip)->ip)),
                      af);
        }
#line 720
        if (! (tmp > 0)) {
#line 720
          goto while_break;
        }
      } else {
#line 720
        goto while_break;
      }
#line 723
      rp = rp->nextip;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 724
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 724
      if (rp->previousip) {
        {
#line 724
        tmp___0 = addrcmp((char *)((void *)(& addrp->ip)), (char *)((void *)(& (rp->previousip)->ip)),
                          af);
        }
#line 724
        if (! (tmp___0 < 0)) {
#line 724
          goto while_break___0;
        }
      } else {
#line 724
        goto while_break___0;
      }
#line 727
      rp = rp->previousip;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 728
    tmp___1 = addrcmp((char *)((void *)(& rp->ip)), (char *)((void *)(& addrp->ip)),
                      af);
    }
#line 728
    if (tmp___1 < 0) {
#line 729
      addrp->previousip = rp;
#line 730
      addrp->nextip = rp->nextip;
#line 731
      if (rp->nextip) {
#line 732
        (rp->nextip)->previousip = addrp;
      }
#line 733
      rp->nextip = addrp;
    } else {
#line 735
      addrp->previousip = rp->previousip;
#line 736
      addrp->nextip = rp;
#line 737
      if (rp->previousip) {
#line 738
        (rp->previousip)->nextip = addrp;
      }
#line 739
      rp->previousip = addrp;
    }
  } else {
#line 742
    tmp___2 = (struct resolve *)((void *)0);
#line 742
    addrp->previousip = tmp___2;
#line 742
    addrp->nextip = tmp___2;
  }
#line 743
  ipbash[bashnum] = addrp;
#line 744
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void unlinkresolveip(struct resolve *rp ) 
{ 
  dword bashnum ;

  {
  {
#line 751
  bashnum = getipbash(& rp->ip);
  }
#line 752
  if ((unsigned long )ipbash[bashnum] == (unsigned long )rp) {
#line 753
    if (rp->previousip) {
#line 753
      ipbash[bashnum] = rp->previousip;
    } else {
#line 753
      ipbash[bashnum] = rp->nextip;
    }
  }
#line 754
  if (rp->nextip) {
#line 755
    (rp->nextip)->previousip = rp->previousip;
  }
#line 756
  if (rp->previousip) {
#line 757
    (rp->previousip)->nextip = rp->nextip;
  }
#line 758
  return;
}
}
#line 761 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void linkresolve(struct resolve *rp ) 
{ 
  struct resolve *irp ;

  {
#line 765
  if (expireresolves) {
#line 766
    irp = expireresolves;
    {
#line 767
    while (1) {
      while_continue: /* CIL Label */ ;
#line 767
      if (irp->next) {
#line 767
        if (! (rp->expiretime >= irp->expiretime)) {
#line 767
          goto while_break;
        }
      } else {
#line 767
        goto while_break;
      }
#line 767
      irp = irp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 768
    if (rp->expiretime >= irp->expiretime) {
#line 769
      rp->next = (struct resolve *)((void *)0);
#line 770
      rp->previous = irp;
#line 771
      irp->next = rp;
#line 772
      lastresolve = rp;
    } else {
#line 774
      rp->previous = irp->previous;
#line 775
      rp->next = irp;
#line 776
      if (irp->previous) {
#line 777
        (irp->previous)->next = rp;
      } else {
#line 779
        expireresolves = rp;
      }
#line 780
      irp->previous = rp;
    }
  } else {
#line 783
    rp->next = (struct resolve *)((void *)0);
#line 784
    rp->previous = (struct resolve *)((void *)0);
#line 785
    lastresolve = rp;
#line 785
    expireresolves = lastresolve;
  }
#line 787
  resolvecount ++;
#line 788
  return;
}
}
#line 791 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void lastlinkresolve(struct resolve *rp ) 
{ 
  struct resolve *irp ;

  {
#line 795
  if (lastresolve) {
#line 796
    irp = lastresolve;
    {
#line 797
    while (1) {
      while_continue: /* CIL Label */ ;
#line 797
      if (irp->previous) {
#line 797
        if (! (rp->expiretime < irp->expiretime)) {
#line 797
          goto while_break;
        }
      } else {
#line 797
        goto while_break;
      }
#line 797
      irp = irp->previous;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 798
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 798
      if (irp->next) {
#line 798
        if (! (rp->expiretime >= irp->expiretime)) {
#line 798
          goto while_break___0;
        }
      } else {
#line 798
        goto while_break___0;
      }
#line 798
      irp = irp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 799
    if (rp->expiretime >= irp->expiretime) {
#line 800
      rp->next = (struct resolve *)((void *)0);
#line 801
      rp->previous = irp;
#line 802
      irp->next = rp;
#line 803
      lastresolve = rp;
    } else {
#line 805
      rp->previous = irp->previous;
#line 806
      rp->next = irp;
#line 807
      if (irp->previous) {
#line 808
        (irp->previous)->next = rp;
      } else {
#line 810
        expireresolves = rp;
      }
#line 811
      irp->previous = rp;
    }
  } else {
#line 814
    rp->next = (struct resolve *)((void *)0);
#line 815
    rp->previous = (struct resolve *)((void *)0);
#line 816
    lastresolve = rp;
#line 816
    expireresolves = lastresolve;
  }
#line 818
  resolvecount ++;
#line 819
  return;
}
}
#line 822 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void untieresolve(struct resolve *rp ) 
{ 


  {
#line 824
  if (rp->previous) {
#line 825
    (rp->previous)->next = rp->next;
  } else {
#line 827
    expireresolves = rp->next;
  }
#line 828
  if (rp->next) {
#line 829
    (rp->next)->previous = rp->previous;
  } else {
#line 831
    lastresolve = rp->previous;
  }
#line 832
  resolvecount --;
#line 833
  return;
}
}
#line 836 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void unlinkresolve(struct resolve *rp ) 
{ 


  {
  {
#line 838
  untieresolve(rp);
#line 839
  unlinkresolveid(rp);
#line 840
  unlinkresolveip(rp);
  }
#line 841
  if (rp->hostname) {
    {
#line 842
    unlinkresolvehost(rp);
    }
  }
#line 843
  return;
}
}
#line 846 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *findid(word id ) 
{ 
  struct resolve *rp ;
  int bashnum ;
  dword tmp ;

  {
  {
#line 851
  tmp = getidbash(id);
#line 851
  bashnum = (int )tmp;
#line 852
  rp = idbash[bashnum];
  }
#line 853
  if (rp) {
    {
#line 854
    while (1) {
      while_continue: /* CIL Label */ ;
#line 854
      if (rp->nextid) {
#line 854
        if (! ((int )id >= (int )(rp->nextid)->id)) {
#line 854
          goto while_break;
        }
      } else {
#line 854
        goto while_break;
      }
#line 855
      rp = rp->nextid;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (rp->previousid) {
#line 856
        if (! ((int )id <= (int )(rp->previousid)->id)) {
#line 856
          goto while_break___0;
        }
      } else {
#line 856
        goto while_break___0;
      }
#line 857
      rp = rp->previousid;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 858
    if ((int )id == (int )rp->id) {
#line 859
      idbash[bashnum] = rp;
#line 860
      return (rp);
    } else {
#line 862
      return ((struct resolve *)((void *)0));
    }
  }
#line 864
  return (rp);
}
}
#line 868 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *findhost(char *hostname ) 
{ 
  struct resolve *rp ;
  int bashnum ;
  dword tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 873
  tmp = gethostbash(hostname);
#line 873
  bashnum = (int )tmp;
#line 874
  rp = hostbash[bashnum];
  }
#line 875
  if (rp) {
    {
#line 876
    while (1) {
      while_continue: /* CIL Label */ ;
#line 876
      if (rp->nexthost) {
        {
#line 876
        tmp___0 = strcasecmp((char const   *)hostname, (char const   *)(rp->nexthost)->hostname);
        }
#line 876
        if (! (tmp___0 >= 0)) {
#line 876
          goto while_break;
        }
      } else {
#line 876
        goto while_break;
      }
#line 877
      rp = rp->nexthost;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 878
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 878
      if (rp->previoushost) {
        {
#line 878
        tmp___1 = strcasecmp((char const   *)hostname, (char const   *)(rp->nexthost)->hostname);
        }
#line 878
        if (! (tmp___1 <= 0)) {
#line 878
          goto while_break___0;
        }
      } else {
#line 878
        goto while_break___0;
      }
#line 879
      rp = rp->previoushost;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 880
    tmp___2 = strcasecmp((char const   *)hostname, (char const   *)rp->hostname);
    }
#line 880
    if (tmp___2) {
#line 881
      return ((struct resolve *)((void *)0));
    } else {
#line 883
      hostbash[bashnum] = rp;
#line 884
      return (rp);
    }
  }
#line 887
  return (rp);
}
}
#line 891 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct resolve *findip(ip_t *ip ) 
{ 
  struct resolve *rp ;
  dword bashnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 896
  bashnum = getipbash(ip);
#line 897
  rp = ipbash[bashnum];
  }
#line 898
  if (rp) {
    {
#line 899
    while (1) {
      while_continue: /* CIL Label */ ;
#line 899
      if (rp->nextip) {
        {
#line 899
        tmp = addrcmp((char *)((void *)ip), (char *)((void *)(& (rp->nextip)->ip)),
                      af);
        }
#line 899
        if (! (tmp >= 0)) {
#line 899
          goto while_break;
        }
      } else {
#line 899
        goto while_break;
      }
#line 901
      rp = rp->nextip;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 902
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 902
      if (rp->previousip) {
        {
#line 902
        tmp___0 = addrcmp((char *)((void *)ip), (char *)((void *)(& (rp->previousip)->ip)),
                          af);
        }
#line 902
        if (! (tmp___0 <= 0)) {
#line 902
          goto while_break___0;
        }
      } else {
#line 902
        goto while_break___0;
      }
#line 904
      rp = rp->previousip;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 905
    tmp___1 = addrcmp((char *)((void *)ip), (char *)((void *)(& rp->ip)), af);
    }
#line 905
    if (tmp___1 == 0) {
#line 906
      ipbash[bashnum] = rp;
#line 907
      return (rp);
    } else {
#line 909
      return ((struct resolve *)((void *)0));
    }
  }
#line 911
  return (rp);
}
}
#line 915 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void restell(char *s ) 
{ 


  {
  {
#line 917
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stderr);
#line 918
  fputs((char const   */* __restrict  */)"\r", (FILE */* __restrict  */)stderr);
  }
#line 919
  return;
}
}
#line 922 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void dorequest(char *s , int type , word id ) 
{ 
  packetheader *hp ;
  int r ;
  int i ;
  unsigned char buf[512] ;

  {
  {
#line 928
  r = __res_nmkquery(& myres, 0, (char const   *)s, 1, type, (u_char const   *)((void *)0),
                     0, (u_char const   *)((void *)0), buf, 512);
  }
#line 929
  if (r == -1) {
    {
#line 930
    restell((char *)"Resolver error: Query too large.");
    }
#line 931
    return;
  }
#line 933
  hp = (packetheader *)(buf);
#line 934
  hp->id = id;
#line 936
  i = 0;
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! (i < (int )myres._u._ext.nscount6)) {
#line 936
      goto while_break;
    }
#line 937
    if (! myres._u._ext.nsaddrs[i]) {
#line 938
      goto __Cont;
    }
#line 939
    if ((int )(myres._u._ext.nsaddrs[i])->sin6_family == 10) {
      {
#line 940
      sendto(resfd6, (void const   *)(buf), (size_t )r, 0, (struct sockaddr  const  *)((struct sockaddr *)myres._u._ext.nsaddrs[i]),
             (socklen_t )sizeof(struct sockaddr_in6 ));
      }
    }
    __Cont: /* CIL Label */ 
#line 936
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 944
    if (! (i < myres.nscount)) {
#line 944
      goto while_break___0;
    }
#line 945
    if ((int )myres.nsaddr_list[i].sin_family == 2) {
      {
#line 946
      sendto(resfd, (void const   *)(buf), (size_t )r, 0, (struct sockaddr  const  *)((struct sockaddr *)(& myres.nsaddr_list[i])),
             (socklen_t )sizeof(struct sockaddr ));
      }
    }
#line 944
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 948
  return;
}
}
#line 950 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void resendrequest(struct resolve *rp , int type ) 
{ 
  char *tmp ;

  {
#line 952
  if (type == 1) {
    {
#line 953
    dorequest(rp->hostname, type, rp->id);
    }
#line 954
    if (debug) {
      {
#line 955
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Sent reverse authentication request for \"%s\".",
               rp->hostname);
#line 957
      restell(tempstring);
      }
    }
  } else
#line 959
  if (type == 12) {
    {
#line 961
    if (af == 2) {
#line 961
      goto case_2;
    }
#line 969
    if (af == 10) {
#line 969
      goto case_10;
    }
#line 960
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 962
    sprintf((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)"%u.%u.%u.%u.in-addr.arpa",
            (int )*((byte *)(& rp->ip) + 3), (int )*((byte *)(& rp->ip) + 2), (int )*((byte *)(& rp->ip) + 1),
            (int )*((byte *)(& rp->ip) + 0));
    }
#line 967
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 970
    addr2ip6arpa(& rp->ip, tempstring);
    }
#line 971
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 974
    dorequest(tempstring, type, rp->id);
    }
#line 975
    if (debug) {
      {
#line 976
      tmp = strlongip(& rp->ip);
#line 976
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Sent domain lookup request for \"%s\".",
               tmp);
#line 978
      restell(tempstring);
      }
    }
  }
#line 981
  return;
}
}
#line 983 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void sendrequest(struct resolve *rp , int type ) 
{ 
  time_t tmp ;
  struct resolve *tmp___0 ;

  {
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 986
    tmp = time((time_t *)((void *)0));
#line 986
    idseed = ((((idseed + idseed) | tmp) + idseed) - 88845642L) ^ aseed;
#line 987
    aseed ^= idseed;
#line 988
    rp->id = (word )idseed;
#line 985
    tmp___0 = findid(rp->id);
    }
#line 985
    if (! tmp___0) {
#line 985
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 990
  linkresolveid(rp);
#line 991
  resendrequest(rp, type);
  }
#line 992
  return;
}
}
#line 995 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void failrp(struct resolve *rp ) 
{ 


  {
#line 997
  if ((int )rp->state == 0) {
#line 998
    return;
  }
  {
#line 999
  rp->state = (byte )1;
#line 1000
  untieresolve(rp);
  }
#line 1001
  if (debug) {
    {
#line 1002
    restell((char *)"Resolver: Lookup failed.\n");
    }
  }
#line 1003
  return;
}
}
#line 1006 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void passrp(struct resolve *rp , long ttl ) 
{ 


  {
  {
#line 1008
  rp->state = (byte )0;
#line 1009
  rp->expiretime = (float )(sweeptime + (double )ttl);
#line 1010
  untieresolve(rp);
  }
#line 1011
  if (debug) {
    {
#line 1012
    snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Lookup successful: %s\n",
             rp->hostname);
#line 1013
    restell(tempstring);
    }
  }
#line 1015
  return;
}
}
#line 1018 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void parserespacket(byte *s , int l ) 
{ 
  struct resolve *rp ;
  packetheader *hp ;
  byte *eob ;
  byte *c ;
  long ttl ;
  int r ;
  int usefulanswer ;
  word rr ;
  word datatype ;
  word class ;
  word qdatatype ;
  word qclass ;
  byte rdatalength ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 1029
  if (l < (int )sizeof(packetheader )) {
    {
#line 1030
    restell((char *)"Resolver error: Packet smaller than standard header size.");
    }
#line 1031
    return;
  }
#line 1033
  if (l == (int )sizeof(packetheader )) {
    {
#line 1034
    restell((char *)"Resolver error: Packet has empty body.");
    }
#line 1035
    return;
  }
  {
#line 1037
  hp = (packetheader *)s;
#line 1040
  rp = findid(hp->id);
  }
#line 1041
  if (! rp) {
#line 1042
    res_unknownid ++;
#line 1043
    return;
  }
#line 1045
  if ((int )rp->state == 0) {
#line 1046
    return;
  } else
#line 1045
  if ((int )rp->state == 1) {
#line 1046
    return;
  }
  {
#line 1047
  hp->qdcount = ntohs(hp->qdcount);
#line 1048
  hp->ancount = ntohs(hp->ancount);
#line 1049
  hp->nscount = ntohs(hp->nscount);
#line 1050
  hp->arcount = ntohs(hp->arcount);
  }
#line 1051
  if (((int )hp->databyte_a >> 1) & 1) {
    {
#line 1052
    restell((char *)"Resolver error: Nameserver packet truncated.");
    }
#line 1053
    return;
  }
#line 1055
  if (! ((int )hp->databyte_a >> 7)) {
    {
#line 1056
    restell((char *)"Resolver error: Query packet received on nameserver communication socket.");
    }
#line 1057
    return;
  }
#line 1059
  if (((int )hp->databyte_a >> 3) & 15) {
    {
#line 1060
    restell((char *)"Resolver error: Invalid opcode in response packet.");
    }
#line 1061
    return;
  }
#line 1063
  eob = s + l;
#line 1064
  c = s + 12;
  {
#line 1066
  if (((int )hp->databyte_b & 15) == 0) {
#line 1066
    goto case_0;
  }
#line 1276
  if (((int )hp->databyte_b & 15) == 3) {
#line 1276
    goto case_3___0;
  }
#line 1282
  goto switch_default___1;
  case_0: /* CIL Label */ 
#line 1067
  if (hp->ancount) {
#line 1068
    if (debug) {
      {
#line 1069
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Received nameserver reply. (qd:%u an:%u ns:%u ar:%u)",
               (int )hp->qdcount, (int )hp->ancount, (int )hp->nscount, (int )hp->arcount);
#line 1071
      restell(tempstring);
      }
    }
#line 1073
    if ((int )hp->qdcount != 1) {
      {
#line 1074
      restell((char *)"Resolver error: Reply does not contain one query.");
      }
#line 1075
      return;
    }
#line 1077
    if ((unsigned long )c > (unsigned long )eob) {
      {
#line 1078
      restell((char *)"Resolver error: Reply too short.");
      }
#line 1079
      return;
    }
    {
#line 1084
    if ((int )rp->state == 4) {
#line 1084
      goto case_4;
    }
#line 1084
    if ((int )rp->state == 3) {
#line 1084
      goto case_4;
    }
#line 1084
    if ((int )rp->state == 2) {
#line 1084
      goto case_4;
    }
#line 1081
    goto switch_break___0;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1086
    if (af == 2) {
#line 1086
      goto case_2___0;
    }
#line 1094
    if (af == 10) {
#line 1094
      goto case_10;
    }
#line 1085
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 1087
    sprintf((char */* __restrict  */)(stackstring), (char const   */* __restrict  */)"%u.%u.%u.%u.in-addr.arpa",
            (int )*((byte *)(& rp->ip) + 3), (int )*((byte *)(& rp->ip) + 2), (int )*((byte *)(& rp->ip) + 1),
            (int )*((byte *)(& rp->ip) + 0));
    }
#line 1092
    goto switch_break___1;
    case_10: /* CIL Label */ 
    {
#line 1095
    addr2ip6arpa(& rp->ip, stackstring);
    }
#line 1096
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1100
    namestring[0] = (char )'\000';
#line 1101
    r = __dn_expand((u_char const   *)s, (u_char const   *)(s + l), (u_char const   *)c,
                    namestring, 1025);
    }
#line 1102
    if (r == -1) {
      {
#line 1103
      restell((char *)"Resolver error: dn_expand() failed while expanding query domain.");
      }
#line 1104
      return;
    }
    {
#line 1106
    tmp = strlen((char const   *)(stackstring));
#line 1106
    namestring[tmp] = (char )'\000';
#line 1107
    tmp___0 = strcasecmp((char const   *)(stackstring), (char const   *)(namestring));
    }
#line 1107
    if (tmp___0) {
#line 1108
      if (debug) {
        {
#line 1109
        snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Unknown query packet dropped. (\"%s\" does not match \"%s\")",
                 stackstring, namestring);
#line 1111
        restell(tempstring);
        }
      }
#line 1113
      return;
    }
#line 1115
    if (debug) {
      {
#line 1116
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Queried domain name: \"%s\"",
               namestring);
#line 1117
      restell(tempstring);
      }
    }
#line 1119
    c += r;
#line 1120
    if ((unsigned long )(c + 4) > (unsigned long )eob) {
      {
#line 1121
      restell((char *)"Resolver error: Query resource record truncated.");
      }
#line 1122
      return;
    }
#line 1124
    c += 2;
#line 1124
    qdatatype = (word )(((int )*(c + -2) << 8) | (int )*(c + -1));
#line 1125
    c += 2;
#line 1125
    qclass = (word )(((int )*(c + -2) << 8) | (int )*(c + -1));
#line 1126
    if ((int )qclass != 1) {
#line 1127
      if ((int )qclass < 5) {
#line 1127
        tmp___1 = classtypes[qclass];
      } else {
#line 1127
        tmp___1 = classtypes[5];
      }
      {
#line 1127
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Received unsupported query class: %u (%s)",
               (int )qclass, tmp___1);
#line 1130
      restell(tempstring);
      }
    }
    {
#line 1133
    if ((int )qdatatype == 12) {
#line 1133
      goto case_12;
    }
#line 1140
    goto switch_default;
    case_12: /* CIL Label */ 
#line 1134
    if (! ((int )rp->state == 2)) {
#line 1134
      if (! ((int )rp->state == 3)) {
#line 1134
        if (! ((int )rp->state == 4)) {
#line 1135
          if (debug) {
            {
#line 1136
            restell((char *)"Resolver warning: Ignoring response with unexpected query type \"PTR\".");
            }
#line 1137
            return;
          }
        }
      }
    }
#line 1139
    goto switch_break___2;
    switch_default: /* CIL Label */ 
#line 1141
    if ((int )qdatatype < 17) {
#line 1141
      tmp___2 = resourcetypes[qdatatype];
    } else {
#line 1141
      tmp___2 = resourcetypes[17];
    }
    {
#line 1141
    snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Received unimplemented query type: %u (%s)",
             (int )qdatatype, tmp___2);
#line 1144
    restell(tempstring);
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 1146
    rr = (word )(((int )hp->ancount + (int )hp->nscount) + (int )hp->arcount);
    {
#line 1146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1146
      if (! rr) {
#line 1146
        goto while_break;
      }
#line 1147
      if ((unsigned long )c > (unsigned long )eob) {
        {
#line 1148
        restell((char *)"Resolver error: Packet does not contain all specified resouce records.");
        }
#line 1149
        return;
      }
      {
#line 1151
      namestring[0] = (char )'\000';
#line 1152
      r = __dn_expand((u_char const   *)s, (u_char const   *)(s + l), (u_char const   *)c,
                      namestring, 1025);
      }
#line 1153
      if (r == -1) {
        {
#line 1154
        restell((char *)"Resolver error: dn_expand() failed while expanding answer domain.");
        }
#line 1155
        return;
      }
      {
#line 1157
      tmp___3 = strlen((char const   *)(stackstring));
#line 1157
      namestring[tmp___3] = (char )'\000';
#line 1158
      tmp___4 = strcasecmp((char const   *)(stackstring), (char const   *)(namestring));
      }
#line 1158
      if (tmp___4) {
#line 1159
        usefulanswer = 0;
      } else {
#line 1161
        usefulanswer = 1;
      }
#line 1162
      if (debug) {
        {
#line 1163
        snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: answered domain query: \"%s\"",
                 namestring);
#line 1164
        restell(tempstring);
        }
      }
#line 1166
      c += r;
#line 1167
      if ((unsigned long )(c + 10) > (unsigned long )eob) {
        {
#line 1168
        restell((char *)"Resolver error: Resource record truncated.");
        }
#line 1169
        return;
      }
#line 1171
      c += 2;
#line 1171
      datatype = (word )(((int )*(c + -2) << 8) | (int )*(c + -1));
#line 1172
      c += 2;
#line 1172
      class = (word )(((int )*(c + -2) << 8) | (int )*(c + -1));
#line 1173
      c += 4;
#line 1173
      ttl = (long )(((((int )*(c + -4) << 24) | ((int )*(c + -3) << 16)) | ((int )*(c + -2) << 8)) | (int )*(c + -1));
#line 1174
      c += 2;
#line 1174
      rdatalength = (byte )((word )(((int )*(c + -2) << 8) | (int )*(c + -1)));
#line 1175
      if ((int )class != (int )qclass) {
#line 1176
        if ((int )qclass < 5) {
#line 1176
          tmp___5 = classtypes[qclass];
        } else {
#line 1176
          tmp___5 = classtypes[5];
        }
        {
#line 1176
        snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"query class: %u (%s)",
                 (int )qclass, tmp___5);
#line 1178
        restell(tempstring);
        }
#line 1179
        if ((int )class < 5) {
#line 1179
          tmp___6 = classtypes[class];
        } else {
#line 1179
          tmp___6 = classtypes[5];
        }
        {
#line 1179
        snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"rr class: %u (%s)",
                 (int )class, tmp___6);
#line 1181
        restell(tempstring);
#line 1182
        restell((char *)"Resolver error: Answered class does not match queried class.");
        }
#line 1183
        return;
      }
#line 1185
      if (! rdatalength) {
        {
#line 1186
        restell((char *)"Resolver error: Zero size rdata.");
        }
#line 1187
        return;
      }
#line 1189
      if ((unsigned long )(c + (int )rdatalength) > (unsigned long )eob) {
        {
#line 1190
        restell((char *)"Resolver error: Specified rdata length exceeds packet size.");
        }
#line 1191
        return;
      }
#line 1193
      if ((int )datatype == (int )qdatatype) {
#line 1193
        goto _L;
      } else
#line 1193
      if ((int )datatype == 5) {
        _L: /* CIL Label */ 
#line 1194
        if (debug) {
          {
#line 1195
          tmp___7 = strtdiff(sendstring, ttl);
#line 1195
          snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: TTL: %s",
                   tmp___7);
#line 1196
          restell(tempstring);
          }
        }
#line 1198
        if (usefulanswer) {
          {
#line 1200
          if ((int )datatype == 1) {
#line 1200
            goto case_1;
          }
#line 1225
          if ((int )datatype == 5) {
#line 1225
            goto case_5;
          }
#line 1225
          if ((int )datatype == 12) {
#line 1225
            goto case_5;
          }
#line 1257
          goto switch_default___0;
          case_1: /* CIL Label */ 
#line 1201
          if ((int )rdatalength != 4) {
            {
#line 1202
            snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Unsupported rdata format for \"A\" type. (%u bytes)",
                     (int )rdatalength);
#line 1204
            restell(tempstring);
            }
#line 1205
            return;
          }
          {
#line 1207
          tmp___12 = addrcmp((char *)((void *)(& rp->ip)), (char *)((void *)c), af);
          }
#line 1207
          if (tmp___12 == 0) {
            {
#line 1208
            tmp___8 = strlongip(& rp->ip);
#line 1208
            snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Reverse authentication failed: %s != ",
                     tmp___8);
#line 1210
            addrcpy((char *)((void *)(& alignedip)), (char *)((void *)c), af);
#line 1211
            tmp___9 = strlongip(& alignedip);
#line 1211
            strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)tmp___9);
#line 1212
            restell(tempstring);
#line 1213
            res_hostipmismatch ++;
#line 1214
            failrp(rp);
            }
          } else {
#line 1216
            if (rp->hostname) {
#line 1216
              tmp___10 = rp->hostname;
            } else {
#line 1216
              tmp___10 = nullstring;
            }
            {
#line 1216
            tmp___11 = strlongip(& rp->ip);
#line 1216
            snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Reverse authentication complete: %s == \"%s\".",
                     tmp___11, tmp___10);
#line 1218
            restell(tempstring);
#line 1219
            res_reversesuccess ++;
#line 1220
            passrp(rp, ttl);
            }
#line 1221
            return;
          }
#line 1223
          goto switch_break___3;
          case_5: /* CIL Label */ 
          case_12___0: /* CIL Label */ 
          {
#line 1226
          namestring[0] = (char )'\000';
#line 1227
          r = __dn_expand((u_char const   *)s, (u_char const   *)(s + l), (u_char const   *)c,
                          namestring, 1025);
          }
#line 1228
          if (r == -1) {
            {
#line 1229
            restell((char *)"Resolver error: dn_expand() failed while expanding domain in rdata.");
            }
#line 1230
            return;
          }
#line 1232
          if (debug) {
            {
#line 1233
            snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Answered domain: \"%s\"",
                     namestring);
#line 1234
            restell(tempstring);
            }
          }
#line 1236
          if (r > 255) {
            {
#line 1237
            restell((char *)"Resolver error: Domain name too long.");
#line 1238
            failrp(rp);
            }
#line 1239
            return;
          }
#line 1241
          if ((int )datatype == 5) {
            {
#line 1242
            strcpy((char */* __restrict  */)(stackstring), (char const   */* __restrict  */)(namestring));
            }
#line 1243
            goto switch_break___3;
          }
#line 1245
          if (! rp->hostname) {
            {
#line 1246
            tmp___13 = strlen((char const   *)(namestring));
#line 1246
            tmp___14 = statmalloc(tmp___13 + 1UL);
#line 1246
            rp->hostname = (char *)tmp___14;
            }
#line 1247
            if (! rp->hostname) {
              {
#line 1248
              tmp___15 = __errno_location();
#line 1248
              tmp___16 = strerror(*tmp___15);
#line 1248
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"statmalloc() error: %s\n",
                      tmp___16);
#line 1249
              exit(-1);
              }
            }
            {
#line 1251
            strcpy((char */* __restrict  */)rp->hostname, (char const   */* __restrict  */)(namestring));
#line 1252
            linkresolvehost(rp);
#line 1253
            passrp(rp, ttl);
#line 1254
            res_iplookupsuccess ++;
            }
          }
#line 1256
          goto switch_break___3;
          switch_default___0: /* CIL Label */ 
#line 1258
          if ((int )datatype < 17) {
#line 1258
            tmp___17 = resourcetypes[datatype];
          } else {
#line 1258
            tmp___17 = resourcetypes[17];
          }
          {
#line 1258
          snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Received unimplemented data type: %u (%s)",
                   (int )datatype, tmp___17);
#line 1261
          restell(tempstring);
          }
          switch_break___3: /* CIL Label */ ;
          }
        }
      } else
#line 1264
      if (debug) {
#line 1265
        if ((int )datatype < 17) {
#line 1265
          tmp___18 = resourcetypes[datatype];
        } else {
#line 1265
          tmp___18 = resourcetypes[17];
        }
        {
#line 1265
        snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Ignoring resource type %u. (%s)",
                 (int )datatype, tmp___18);
#line 1268
        restell(tempstring);
        }
      }
#line 1271
      c += (int )rdatalength;
#line 1146
      rr = (word )((int )rr - 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1274
    restell((char *)"Resolver error: No error returned but no answers given.");
    }
  }
#line 1275
  goto switch_break;
  case_3___0: /* CIL Label */ 
#line 1277
  if (debug) {
    {
#line 1278
    restell((char *)"Resolver: Host not found.");
    }
  }
  {
#line 1279
  res_nxdomain ++;
#line 1280
  failrp(rp);
  }
#line 1281
  goto switch_break;
  switch_default___1: /* CIL Label */ 
#line 1283
  if (((int )hp->databyte_b & 15) < 6) {
#line 1283
    tmp___19 = responsecodes[(int )hp->databyte_b & 15];
  } else {
#line 1283
    tmp___19 = responsecodes[6];
  }
  {
#line 1283
  snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Received error response %u. (%s)",
           (int )hp->databyte_b & 15, tmp___19);
#line 1286
  restell(tempstring);
#line 1287
  res_nserror ++;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1289
  return;
}
}
#line 1292 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void dns_ack(void) 
{ 
  int r ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 1296
  tmp = recvfrom(resfd, (void */* __restrict  */)((byte *)(resrecvbuf)), (size_t )512,
                 0, (struct sockaddr */* __restrict  */)from, (socklen_t */* __restrict  */)(& fromlen));
#line 1296
  r = (int )tmp;
  }
#line 1298
  if (r > 0) {
    {
#line 1300
    tmp___3 = addrcmp((char *)((void *)(& from4->sin_addr)), (char *)((void *)(& localhost)),
                      2);
    }
#line 1300
    if (tmp___3 == 0) {
#line 1302
      i = 0;
      {
#line 1302
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1302
        if (! (i < myres.nscount)) {
#line 1302
          goto while_break;
        }
        {
#line 1303
        tmp___0 = addrcmp((char *)((void *)(& myres.nsaddr_list[i].sin_addr)), (char *)((void *)(& from4->sin_addr)),
                          2);
        }
#line 1303
        if (tmp___0 == 0) {
#line 1307
          goto while_break;
        } else {
          {
#line 1303
          tmp___1 = addrcmp((char *)((void *)(& myres.nsaddr_list[i].sin_addr)), (char *)((void *)(& unspec_addr)),
                            2);
          }
#line 1303
          if (tmp___1 == 0) {
#line 1307
            goto while_break;
          }
        }
#line 1302
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1309
      i = 0;
      {
#line 1309
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1309
        if (! (i < myres.nscount)) {
#line 1309
          goto while_break___0;
        }
        {
#line 1310
        tmp___2 = addrcmp((char *)((void *)(& myres.nsaddr_list[i].sin_addr)), (char *)((void *)(& from4->sin_addr)),
                          2);
        }
#line 1310
        if (tmp___2 == 0) {
#line 1312
          goto while_break___0;
        }
#line 1309
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1313
    if (i == myres.nscount) {
      {
#line 1314
      tmp___4 = inet_ntoa(from4->sin_addr);
#line 1314
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Received reply from unknown source: %s",
               tmp___4);
#line 1316
      restell(tempstring);
      }
    } else {
      {
#line 1318
      parserespacket((byte *)(resrecvbuf), r);
      }
    }
  } else {
    {
#line 1320
    tmp___5 = __errno_location();
#line 1320
    tmp___6 = strerror(*tmp___5);
#line 1320
    snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Socket error: %s",
             tmp___6);
#line 1321
    restell(tempstring);
    }
  }
#line 1323
  return;
}
}
#line 1328 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
static char addrstr___0[46]  ;
#line 1325 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void dns_ack6(void) 
{ 
  int r ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 1330
  tmp = recvfrom(resfd6, (void */* __restrict  */)((byte *)(resrecvbuf)), (size_t )512,
                 0, (struct sockaddr */* __restrict  */)from, (socklen_t */* __restrict  */)(& fromlen));
#line 1330
  r = (int )tmp;
  }
#line 1332
  if (r > 0) {
    {
#line 1334
    tmp___3 = addrcmp((char *)((void *)(& from6->sin6_addr)), (char *)((void *)(& localhost6)),
                      10);
    }
#line 1334
    if (tmp___3 == 0) {
#line 1336
      i = 0;
      {
#line 1336
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1336
        if (! (i < (int )myres._u._ext.nscount6)) {
#line 1336
          goto while_break;
        }
#line 1337
        if (! myres._u._ext.nsaddrs[i]) {
#line 1338
          goto __Cont;
        }
        {
#line 1340
        tmp___0 = addrcmp((char *)((void *)(& (myres._u._ext.nsaddrs[i])->sin6_addr)),
                          (char *)((void *)(& from6->sin6_addr)), 10);
        }
#line 1340
        if (tmp___0 == 0) {
#line 1344
          goto while_break;
        } else {
          {
#line 1340
          tmp___1 = addrcmp((char *)((void *)(& (myres._u._ext.nsaddrs[i])->sin6_addr)),
                            (char *)((void *)(& unspec_addr)), 10);
          }
#line 1340
          if (tmp___1 == 0) {
#line 1344
            goto while_break;
          }
        }
        __Cont: /* CIL Label */ 
#line 1336
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1347
      i = 0;
      {
#line 1347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1347
        if (! (i < (int )myres._u._ext.nscount6)) {
#line 1347
          goto while_break___0;
        }
#line 1348
        if (! myres._u._ext.nsaddrs[i]) {
#line 1349
          goto __Cont___0;
        }
        {
#line 1350
        tmp___2 = addrcmp((char *)((void *)(& (myres._u._ext.nsaddrs[i])->sin6_addr)),
                          (char *)((void *)(& from6->sin6_addr)), 10);
        }
#line 1350
        if (tmp___2 == 0) {
#line 1352
          goto while_break___0;
        }
        __Cont___0: /* CIL Label */ 
#line 1347
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1354
    if (i == (int )myres._u._ext.nscount6) {
      {
#line 1355
      tmp___4 = inet_ntop(10, (void const   */* __restrict  */)(& from6->sin6_addr),
                          (char */* __restrict  */)(addrstr___0), (socklen_t )sizeof(addrstr___0));
#line 1355
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver error: Received reply from unknown source: %s",
               tmp___4);
#line 1359
      restell(tempstring);
      }
    } else {
      {
#line 1361
      parserespacket((byte *)(resrecvbuf), r);
      }
    }
  } else {
    {
#line 1363
    tmp___5 = __errno_location();
#line 1363
    tmp___6 = strerror(*tmp___5);
#line 1363
    snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Socket error: %s",
             tmp___6);
#line 1364
    restell(tempstring);
    }
  }
#line 1366
  return;
}
}
#line 1370 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
int istime(double x , double *sinterval ) 
{ 


  {
#line 1372
  if (x) {
#line 1373
    if (x > sweeptime) {
#line 1374
      if (*sinterval > x - sweeptime) {
#line 1375
        *sinterval = x - sweeptime;
      }
    } else {
#line 1377
      return (1);
    }
  }
#line 1379
  return (0);
}
}
#line 1383 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void dns_events(double *sinterval ) 
{ 
  struct resolve *rp ;
  struct resolve *nextrp ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1387
  rp = expireresolves;
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (rp) {
#line 1387
      if (! (sweeptime >= (double )rp->expiretime)) {
#line 1387
        goto while_break;
      }
    } else {
#line 1387
      goto while_break;
    }
#line 1388
    nextrp = rp->next;
    {
#line 1391
    if ((int )rp->state == 1) {
#line 1391
      goto case_1;
    }
#line 1391
    if ((int )rp->state == 0) {
#line 1391
      goto case_1;
    }
#line 1400
    if ((int )rp->state == 2) {
#line 1400
      goto case_2;
    }
#line 1408
    if ((int )rp->state == 3) {
#line 1408
      goto case_3;
    }
#line 1416
    if ((int )rp->state == 4) {
#line 1416
      goto case_4;
    }
#line 1389
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1392
    if (debug) {
      {
#line 1393
      tmp = strlongip(& rp->ip);
      }
#line 1393
      if (rp->hostname) {
#line 1393
        tmp___0 = rp->hostname;
      } else {
#line 1393
        tmp___0 = nullstring;
      }
      {
#line 1393
      snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Cache record for \"%s\" (%s) has expired. (state: %u)  Marked for expire at: %g, time: %g.",
               tmp___0, tmp, (int )rp->state, (double )rp->expiretime, sweeptime);
#line 1396
      restell(tempstring);
      }
    }
    {
#line 1398
    unlinkresolve(rp);
    }
#line 1399
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1401
    resendrequest(rp, 12);
#line 1402
    restell((char *)"Resolver: Send #2 for \"PTR\" query...");
#line 1403
    rp->state = (byte )((int )rp->state + 1);
#line 1404
    rp->expiretime = (float )(sweeptime + (double )4);
#line 1405
    istime((double )rp->expiretime, sinterval);
#line 1406
    res_resend ++;
    }
#line 1407
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1409
    resendrequest(rp, 12);
#line 1410
    restell((char *)"Resolver: Send #3 for \"PTR\" query...");
#line 1411
    rp->state = (byte )((int )rp->state + 1);
#line 1412
    rp->expiretime = (float )(sweeptime + (double )5);
#line 1413
    istime((double )rp->expiretime, sinterval);
#line 1414
    res_resend ++;
    }
#line 1415
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1417
    restell((char *)"Resolver: \"PTR\" query timed out.");
#line 1418
    failrp(rp);
#line 1419
    istime((double )rp->expiretime, sinterval);
#line 1420
    res_timeout ++;
    }
#line 1421
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1387
    rp = nextrp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1424
  if (expireresolves) {
    {
#line 1425
    istime((double )expireresolves->expiretime, sinterval);
    }
  }
#line 1426
  return;
}
}
#line 1429 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *dns_lookup2(ip_t *ip ) 
{ 
  struct resolve *rp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1433
  rp = findip(ip);
  }
#line 1433
  if (rp) {
#line 1434
    if ((int )rp->state == 0) {
#line 1434
      goto _L___0;
    } else
#line 1434
    if ((int )rp->state == 1) {
      _L___0: /* CIL Label */ 
#line 1435
      if ((int )rp->state == 0) {
#line 1435
        if (rp->hostname) {
#line 1436
          if (debug) {
            {
#line 1437
            tmp = strlongip(ip);
#line 1437
            snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Used cached record: %s == \"%s\".\n",
                     tmp, rp->hostname);
#line 1439
            restell(tempstring);
            }
          }
#line 1441
          return (rp->hostname);
        } else {
#line 1435
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1443
        if (debug) {
          {
#line 1444
          tmp___0 = strlongip(ip);
#line 1444
          snprintf((char */* __restrict  */)(tempstring), sizeof(tempstring), (char const   */* __restrict  */)"Resolver: Used failed record: %s == ???\n",
                   tmp___0);
#line 1446
          restell(tempstring);
          }
        }
#line 1448
        return ((char *)((void *)0));
      }
    }
#line 1451
    return ((char *)((void *)0));
  }
#line 1453
  if (debug) {
    {
#line 1454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resolver: Added to new record.\n");
    }
  }
  {
#line 1455
  rp = allocresolve();
#line 1456
  rp->state = (byte )2;
#line 1457
  rp->expiretime = (float )(sweeptime + (double )3);
#line 1458
  addrcpy((char *)((void *)(& rp->ip)), (char *)((void *)ip), af);
#line 1459
  linkresolve(rp);
#line 1460
  addrcpy((char *)((void *)(& rp->ip)), (char *)((void *)ip), af);
#line 1461
  linkresolveip(rp);
#line 1462
  sendrequest(rp, 12);
  }
#line 1463
  return ((char *)((void *)0));
}
}
#line 1467 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
char *dns_lookup(ip_t *ip ) 
{ 
  char *t ;
  char *tmp ;

  {
#line 1471
  if (! dns) {
#line 1471
    return ((char *)((void *)0));
  }
  {
#line 1472
  t = dns_lookup2(ip);
  }
#line 1473
  if (t) {
#line 1473
    if (use_dns) {
#line 1473
      tmp = t;
    } else {
#line 1473
      tmp = (char *)((void *)0);
    }
  } else {
#line 1473
    tmp = (char *)((void *)0);
  }
#line 1473
  return (tmp);
}
}
#line 1478 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
void addr2ip6arpa(ip_t *ip , char *buf ) 
{ 
  unsigned char *p ;
  char *b ;
  int i ;

  {
#line 1479
  p = (unsigned char *)ip;
#line 1480
  b = buf;
#line 1483
  i = (int )(sizeof(struct in6_addr ) - 1UL);
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1483
    if (! (i >= 0)) {
#line 1483
      goto while_break;
    }
    {
#line 1484
    sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%x.%x.",
            (int )*(p + i) % 16, (int )*(p + i) >> 4);
#line 1485
    b += 4;
#line 1483
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1487
  sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"ip6.arpa");
  }
#line 1488
  return;
}
}
#line 1493 "/home/wheatley/newnew/temp/mtr-0.85/dns.c"
struct hostent *addr2host(char const   *addr , int af___0 ) 
{ 
  int len ;
  struct hostent *tmp ;

  {
#line 1494
  len = 0;
  {
#line 1496
  if (af___0 == 2) {
#line 1496
    goto case_2;
  }
#line 1500
  if (af___0 == 10) {
#line 1500
    goto case_10;
  }
#line 1495
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1497
  len = (int )sizeof(struct in_addr );
#line 1498
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1501
  len = (int )sizeof(struct in6_addr );
#line 1502
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1505
  tmp = gethostbyaddr((void const   *)addr, (__socklen_t )len, af___0);
  }
#line 1505
  return (tmp);
}
}
