/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 53 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
enum objtype {
    OBJTYPE_INDEX = 0,
    OBJTYPE_DATA = 1,
    OBJTYPE_SPECIAL = 2,
    OBJTYPE_INTERMEDIATE = 3
} ;
#line 53 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
typedef enum objtype objtype_t;
#line 60 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
struct object {
   struct object *parent ;
   struct object *children ;
   struct object *next ;
   struct object *prev ;
   DIR *dir ;
   ino_t ino ;
   int usage ;
   char empty ;
   char new ;
   char cullable ;
   objtype_t type ;
   time_t atime ;
   char name[1] ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 185
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) renameat)(int __oldfd ,
                                                                               char const   *__old ,
                                                                               int __newfd ,
                                                                               char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 743
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresuid)(__uid_t __ruid ,
                                                                                __uid_t __euid ,
                                                                                __uid_t __suid ) ;
#line 748
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresgid)(__gid_t __rgid ,
                                                                                __gid_t __egid ,
                                                                                __gid_t __sgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd ,
                                                                                               char const   *__name ,
                                                                                               int __flag ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 972 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 183
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec  const  *__timeout ,
                 __sigset_t const   *__ss ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 253
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat64)(int __fd ,
                                                                                                  char const   * __restrict  __file ,
                                                                                                  struct stat64 * __restrict  __buf ,
                                                                                                  int __flag ) ;
#line 77 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static struct object root  = 
#line 77 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
     {(struct object *)((void *)0), (struct object *)0, (struct object *)0, (struct object *)0,
    (DIR *)0, 0UL, 2, (char)0, (char)0, (char)0, (objtype_t )0, 0L, {(char)0}};
#line 83 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int nobjects  =    1;
#line 84 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int nopendir  =    0;
#line 87 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static struct object *scan  =    & root;
#line 88 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int jumpstart_scan  =    0;
#line 94 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned int culltable_size  =    4096U;
#line 95 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static struct object **cullbuild  ;
#line 96 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static struct object **cullready  ;
#line 98 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int oldest_build  =    -1;
#line 99 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int oldest_ready  =    -1;
#line 100 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int ncullable  =    0;
#line 103 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char const   *configfile  =    "/etc/cachefilesd.conf";
#line 104 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char const   *devfile  =    "/dev/cachefiles";
#line 105 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char const   *procfile  =    "/proc/fs/cachefiles";
#line 106 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char const   *pidfile  =    "/var/run/cachefilesd.pid";
#line 107 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char *cacheroot  ;
#line 107 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static char *graveyardpath  ;
#line 109 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int xdebug  ;
#line 109 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int xnolog  ;
#line 109 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int xopenedlog  ;
#line 110 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int stop  ;
#line 110 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int reap  ;
#line 110 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int cull  ;
#line 110 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int nocull  ;
#line 111 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int graveyardfd  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long brun  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long bcull  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long bstop  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long frun  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long fcull  ;
#line 112 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned long long fstop  ;
#line 116
static  __attribute__((__noreturn__)) void version(void) ;
#line 116 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void version(void) 
{ 


  {
  {
#line 119
  printf((char const   */* __restrict  */)"cachefilesd version 0.10.2\n");
#line 120
  exit(0);
  }
}
}
#line 123
static  __attribute__((__noreturn__)) void help(void) ;
#line 123 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void help(void) 
{ 


  {
  {
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Format:\n  /sbin/cachefilesd [-d]* [-s] [-n] [-p <pidfile>] [-f <configfile>]\n  /sbin/cachefilesd -v\n\nOptions:\n  -d\tIncrease debugging level (cumulative)\n  -n\tDon\'t daemonise the process\n  -s\tMessage output to stderr instead of syslog\n  -p <pidfile>\tWrite the PID into the file\n  -f <configfile>\n  -v\tPrint version and exit\n\tRead the specified configuration file instead of /etc/cachefiles.conf\n");
#line 141
  exit(2);
  }
}
}
#line 144
static  __attribute__((__noreturn__)) void ( /* format attribute */  __error)(int excode ,
                                                                              char const   *fmt 
                                                                              , ...) ;
#line 144 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void ( /* format attribute */  __error)(int excode , char const   *fmt  , ...) 
{ 
  va_list va ;

  {
#line 149
  if (xnolog) {
    {
#line 150
    __builtin_va_start(va, fmt);
#line 151
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
#line 152
    __builtin_va_end(va);
    }
  } else {
#line 155
    if (! xopenedlog) {
      {
#line 156
      openlog("cachefilesd", 1, 3 << 3);
#line 157
      xopenedlog = 1;
      }
    }
    {
#line 160
    __builtin_va_start(va, fmt);
#line 161
    vsyslog(3, fmt, va);
#line 162
    __builtin_va_end(va);
#line 164
    closelog();
    }
  }
  {
#line 167
  exit(excode);
  }
}
}
#line 175 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void ( /* format attribute */  __message)(int dlevel , int level , char const   *fmt 
                                                 , ...) 
{ 
  va_list va ;

  {
#line 180
  if (dlevel <= xdebug) {
#line 181
    if (xnolog) {
      {
#line 182
      __builtin_va_start(va, fmt);
#line 183
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
               va);
#line 184
      __builtin_va_end(va);
      }
    } else
#line 186
    if (! xnolog) {
#line 187
      if (! xopenedlog) {
        {
#line 188
        openlog("cachefilesd", 1, 3 << 3);
#line 189
        xopenedlog = 1;
        }
      }
      {
#line 192
      __builtin_va_start(va, fmt);
#line 193
      vsyslog(level, fmt, va);
#line 194
      __builtin_va_end(va);
#line 196
      closelog();
      }
    }
  }
#line 199
  return;
}
}
#line 205
static void open_cache(void) ;
#line 206
static  __attribute__((__noreturn__)) void cachefilesd(void) ;
#line 207
static void reap_graveyard(void) ;
#line 208
static void reap_graveyard_aux(char const   *dirname ) ;
#line 209
static void read_cache_state(void) ;
#line 210
static int is_object_in_use(char const   *filename ) ;
#line 211
static void cull_file(char const   *filename ) ;
#line 212
static void build_cull_table(void) ;
#line 213
static void decant_cull_table(void) ;
#line 214
static void insert_into_cull_table(struct object *object ) ;
#line 215
static void put_object(struct object *object ) ;
#line 216
static struct object *create_object(struct object *parent , char const   *name , struct stat64 *st ) ;
#line 217
static void destroy_unexpected_object(struct object *parent , struct dirent *de ) ;
#line 218
static int get_dir_fd(struct object *dir ) ;
#line 219
static void cull_object(struct object *object ) ;
#line 220
static void cull_objects(void) ;
#line 226 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void sigterm(int sig ) 
{ 


  {
#line 228
  stop = 1;
#line 229
  return;
}
}
#line 235 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void sigio(int sig ) 
{ 


  {
#line 237
  reap = 1;
#line 238
  return;
}
}
#line 244 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void sigalrm(int sig ) 
{ 


  {
#line 246
  jumpstart_scan = 1;
#line 247
  return;
}
}
#line 253 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void write_pidfile(void) 
{ 
  FILE *pf ;
  int *tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  pf = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
  }
#line 258
  if (! pf) {
    {
#line 259
    tmp = __errno_location();
#line 259
    __error(1, "Unable to open PID file: %s: errno %d (%m)\n", pidfile, *tmp);
    }
  }
  {
#line 261
  tmp___1 = getpid();
#line 261
  tmp___2 = fprintf((FILE */* __restrict  */)pf, (char const   */* __restrict  */)"%d\n",
                    tmp___1);
  }
#line 261
  if (tmp___2 < 0) {
    {
#line 263
    tmp___0 = __errno_location();
#line 263
    __error(1, "Unable to write PID file: %s: errno %d (%m)\n", pidfile, *tmp___0);
    }
  } else {
    {
#line 261
    tmp___3 = fclose(pf);
    }
#line 261
    if (tmp___3 == -1) {
      {
#line 263
      tmp___0 = __errno_location();
#line 263
      __error(1, "Unable to write PID file: %s: errno %d (%m)\n", pidfile, *tmp___0);
      }
    }
  }
#line 264
  return;
}
}
#line 270 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
int main(int argc , char **argv ) 
{ 
  struct stat st ;
  unsigned int lineno ;
  ssize_t n ;
  size_t m ;
  FILE *config ;
  char *line ;
  char *cp ;
  long page_size ;
  int _cachefd ;
  int nullfd ;
  int opt ;
  int loop ;
  int open_max ;
  int nodaemon ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  void *tmp___19 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned long cts ;
  char *sp ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  unsigned short const   **tmp___25 ;
  char *sp___0 ;
  unsigned short const   **tmp___26 ;
  size_t tmp___27 ;
  int *tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  unsigned short const   **tmp___32 ;
  int tmp___33 ;
  unsigned short const   **tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  size_t tmp___38 ;
  ssize_t tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  void *tmp___44 ;
  int *tmp___45 ;
  void *tmp___46 ;
  int *tmp___47 ;
  int *tmp___48 ;
  ssize_t tmp___49 ;
  __pid_t tmp___50 ;
  int *tmp___51 ;
  __pid_t tmp___52 ;

  {
#line 279
  nodaemon = 0;
#line 282
  if (argc == 2) {
    {
#line 282
    tmp = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 282
    if (tmp == 0) {
      {
#line 283
      help();
      }
    }
  }
#line 285
  if (argc == 2) {
    {
#line 285
    tmp___0 = strcmp((char const   *)*(argv + 1), "--version");
    }
#line 285
    if (tmp___0 == 0) {
      {
#line 286
      version();
      }
    }
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    opt = getopt(argc, (char * const  *)argv, "dsnf:p:v");
    }
#line 289
    if (! (opt != -1)) {
#line 289
      goto while_break;
    }
    {
#line 293
    if (opt == 100) {
#line 293
      goto case_100;
    }
#line 298
    if (opt == 115) {
#line 298
      goto case_115;
    }
#line 303
    if (opt == 110) {
#line 303
      goto case_110;
    }
#line 308
    if (opt == 102) {
#line 308
      goto case_102;
    }
#line 313
    if (opt == 112) {
#line 313
      goto case_112;
    }
#line 318
    if (opt == 118) {
#line 318
      goto case_118;
    }
#line 322
    goto switch_default;
    case_100: /* CIL Label */ 
#line 295
    xdebug ++;
#line 296
    goto switch_break;
    case_115: /* CIL Label */ 
#line 300
    xnolog = 1;
#line 301
    goto switch_break;
    case_110: /* CIL Label */ 
#line 305
    nodaemon = 1;
#line 306
    goto switch_break;
    case_102: /* CIL Label */ 
#line 310
    configfile = (char const   *)optarg;
#line 311
    goto switch_break;
    case_112: /* CIL Label */ 
#line 315
    pidfile = (char const   *)optarg;
#line 316
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 320
    version();
    }
    switch_default: /* CIL Label */ 
    {
#line 323
    __error(2, "Unknown commandline option \'%c\'\n", optopt);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  page_size = sysconf(30);
  }
#line 329
  if (page_size < 0L) {
    {
#line 330
    tmp___1 = __errno_location();
#line 330
    __error(1, "Unable to get page size: errno %d (%m)\n", *tmp___1);
    }
  }
  {
#line 332
  tmp___2 = sysconf(4);
#line 332
  open_max = (int )tmp___2;
  }
#line 333
  if (open_max < 0) {
    {
#line 334
    tmp___3 = __errno_location();
#line 334
    __error(1, "Unable to get max open files: errno %d (%m)\n", *tmp___3);
    }
  }
  {
#line 337
  tmp___5 = setresuid((__uid_t )0, (__uid_t )0, (__uid_t )0);
  }
#line 337
  if (tmp___5 < 0) {
    {
#line 338
    tmp___4 = __errno_location();
#line 338
    __error(1, "Unable to set UID to 0: errno %d (%m)\n", *tmp___4);
    }
  }
  {
#line 340
  tmp___7 = setresgid((__gid_t )0, (__gid_t )0, (__gid_t )0);
  }
#line 340
  if (tmp___7 < 0) {
    {
#line 341
    tmp___6 = __errno_location();
#line 341
    __error(1, "Unable to set GID to 0: errno %d (%m)\n", *tmp___6);
    }
  }
  {
#line 344
  sync();
#line 347
  _cachefd = open(devfile, 2);
  }
#line 348
  if (_cachefd < 0) {
    {
#line 349
    tmp___9 = __errno_location();
    }
#line 349
    if (*tmp___9 != 2) {
      {
#line 350
      tmp___8 = __errno_location();
#line 350
      __error(1, "Unable to open %s: errno %d (%m)\n", devfile, *tmp___8);
      }
    }
    {
#line 352
    _cachefd = open(procfile, 2);
    }
#line 353
    if (_cachefd < 0) {
      {
#line 354
      tmp___11 = __errno_location();
      }
#line 354
      if (*tmp___11 == 2) {
        {
#line 355
        tmp___10 = __errno_location();
#line 355
        __error(1, "Unable to open %s: errno %d (%m)\n", devfile, *tmp___10);
        }
      }
      {
#line 356
      tmp___12 = __errno_location();
#line 356
      __error(1, "Unable to open %s: errno %d (%m)\n", procfile, *tmp___12);
      }
    }
  }
#line 360
  if (_cachefd != 3) {
    {
#line 361
    tmp___14 = dup2(_cachefd, 3);
    }
#line 361
    if (tmp___14 < 0) {
      {
#line 362
      tmp___13 = __errno_location();
#line 362
      __error(1, "Unable to transfer cache fd to 3: errno %d (%m)\n", *tmp___13);
      }
    }
    {
#line 363
    tmp___16 = close(_cachefd);
    }
#line 363
    if (tmp___16 < 0) {
      {
#line 364
      tmp___15 = __errno_location();
#line 364
      __error(1, "Close of original cache fd failed: errno %d (%m)\n", *tmp___15);
      }
    }
  }
  {
#line 368
  nullfd = open("/dev/null", 2);
  }
#line 369
  if (nullfd < 0) {
    {
#line 370
    tmp___17 = __errno_location();
#line 370
    __error(1, "Unable to open /dev/null: errno %d (%m)\n", *tmp___17);
    }
  }
  {
#line 373
  config = fopen((char const   */* __restrict  */)configfile, (char const   */* __restrict  */)"r");
  }
#line 374
  if (! config) {
    {
#line 375
    tmp___18 = __errno_location();
#line 375
    __error(1, "Unable to open %s: errno %d (%m)\n", configfile, *tmp___18);
    }
  }
#line 378
  m = (size_t )0;
#line 379
  line = (char *)((void *)0);
#line 380
  lineno = 0U;
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 381
    n = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& m),
                (FILE */* __restrict  */)config);
    }
#line 381
    if (! (n != -1L)) {
#line 381
      goto while_break___0;
    }
#line 384
    lineno ++;
#line 386
    if (n >= page_size) {
      {
#line 387
      __error(2, "%s:%d:Line too long\n", configfile, lineno);
      }
    }
    {
#line 389
    tmp___19 = memchr((void const   *)line, 0, (size_t )n);
    }
#line 389
    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
      {
#line 390
      __error(2, "%s:%d:Line contains a NUL character\n", configfile, lineno);
      }
    }
    {
#line 393
    cp = strchr((char const   *)line, '\n');
    }
#line 394
    if (! cp) {
      {
#line 395
      __error(2, "%s:%d:Unterminated line\n", configfile, lineno);
      }
    }
#line 397
    if ((unsigned long )cp == (unsigned long )line) {
#line 398
      goto while_continue___0;
    }
#line 399
    *cp = (char )'\000';
#line 401
    cp = line;
    {
#line 401
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 401
      tmp___20 = __ctype_b_loc();
      }
#line 401
      if (! ((int const   )*(*tmp___20 + (int )*cp) & 8192)) {
#line 401
        goto while_break___1;
      }
#line 401
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 403
    if (! *cp) {
#line 404
      goto while_continue___0;
    }
#line 407
    if ((int )*cp == 35) {
#line 408
      goto while_continue___0;
    }
    {
#line 411
    tmp___21 = memcmp((void const   *)cp, (void const   *)"nocull", (size_t )6);
    }
#line 411
    if (tmp___21 == 0) {
#line 411
      if (! *(cp + 6)) {
#line 413
        nocull = 1;
      } else {
        {
#line 411
        tmp___22 = __ctype_b_loc();
        }
#line 411
        if ((int const   )*(*tmp___22 + (int )*(cp + 6)) & 8192) {
#line 413
          nocull = 1;
        }
      }
    }
    {
#line 417
    tmp___24 = memcmp((void const   *)cp, (void const   *)"culltable", (size_t )9);
    }
#line 417
    if (tmp___24 == 0) {
      {
#line 417
      tmp___25 = __ctype_b_loc();
      }
#line 417
      if ((int const   )*(*tmp___25 + (int )*(cp + 9)) & 8192) {
#line 421
        sp = cp + 10;
        {
#line 421
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 421
          tmp___23 = __ctype_b_loc();
          }
#line 421
          if (! ((int const   )*(*tmp___23 + (int )*sp) & 8192)) {
#line 421
            goto while_break___2;
          }
#line 421
          sp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 423
        cts = strtoul((char const   */* __restrict  */)sp, (char **/* __restrict  */)(& sp),
                      10);
        }
#line 424
        if (*sp) {
          {
#line 425
          __error(2, "%s:%d:Invalid cull table size number\n", configfile, lineno);
          }
        }
#line 426
        if (cts < 12UL) {
          {
#line 427
          __error(2, "%s:%d:Log2 of cull table size must be 12 <= N <= 20\n", configfile,
                  lineno);
          }
        } else
#line 426
        if (cts > 20UL) {
          {
#line 427
          __error(2, "%s:%d:Log2 of cull table size must be 12 <= N <= 20\n", configfile,
                  lineno);
          }
        }
#line 428
        culltable_size = (unsigned int )(1 << cts);
#line 429
        goto while_continue___0;
      }
    }
    {
#line 433
    tmp___31 = memcmp((void const   *)cp, (void const   *)"dir", (size_t )3);
    }
#line 433
    if (tmp___31 == 0) {
      {
#line 433
      tmp___32 = __ctype_b_loc();
      }
#line 433
      if ((int const   )*(*tmp___32 + (int )*(cp + 3)) & 8192) {
#line 436
        sp___0 = cp + 4;
        {
#line 436
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 436
          tmp___26 = __ctype_b_loc();
          }
#line 436
          if (! ((int const   )*(*tmp___26 + (int )*sp___0) & 8192)) {
#line 436
            goto while_break___3;
          }
#line 436
          sp___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 438
        tmp___27 = strlen((char const   *)sp___0);
        }
#line 438
        if (tmp___27 > 4086UL) {
          {
#line 439
          __error(2, "%s:%d:Cache pathname is too long\n", configfile, lineno);
          }
        }
        {
#line 441
        tmp___29 = stat((char const   */* __restrict  */)sp___0, (struct stat */* __restrict  */)(& st));
        }
#line 441
        if (tmp___29 < 0) {
          {
#line 442
          tmp___28 = __errno_location();
#line 442
          __error(1, "Can\'t confirm cache location: errno %d (%m)\n", *tmp___28);
          }
        }
        {
#line 444
        cacheroot = strdup((char const   *)sp___0);
        }
#line 445
        if (! cacheroot) {
          {
#line 446
          tmp___30 = __errno_location();
#line 446
          __error(1, "Can\'t copy cache name: errno %d (%m)\n", *tmp___30);
          }
        }
      }
    }
    {
#line 450
    tmp___33 = memcmp((void const   *)cp, (void const   *)"bind", (size_t )4);
    }
#line 450
    if (tmp___33 == 0) {
#line 450
      if (! *(cp + 4)) {
        {
#line 452
        __error(2, "%s:%d:\'bind\' command not permitted\n", configfile, lineno);
        }
      } else {
        {
#line 450
        tmp___34 = __ctype_b_loc();
        }
#line 450
        if ((int const   )*(*tmp___34 + (int )*(cp + 4)) & 8192) {
          {
#line 452
          __error(2, "%s:%d:\'bind\' command not permitted\n", configfile, lineno);
          }
        }
      }
    }
    {
#line 455
    tmp___38 = strlen((char const   *)line);
#line 455
    tmp___39 = write(3, (void const   *)line, tmp___38);
    }
#line 455
    if (tmp___39 < 0L) {
      {
#line 456
      tmp___36 = __errno_location();
      }
#line 456
      if (*tmp___36 == -12) {
        {
#line 457
        tmp___35 = __errno_location();
#line 457
        __error(1, "CacheFiles: errno %d (%m)\n", *tmp___35);
        }
      } else {
        {
#line 456
        tmp___37 = __errno_location();
        }
#line 456
        if (*tmp___37 == -5) {
          {
#line 457
          tmp___35 = __errno_location();
#line 457
          __error(1, "CacheFiles: errno %d (%m)\n", *tmp___35);
          }
        }
      }
      {
#line 458
      __error(2, "%s:%d:CacheFiles gave config error: %m\n", configfile, lineno);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 462
  if (line) {
    {
#line 463
    free((void *)line);
    }
  }
  {
#line 465
  tmp___41 = feof(config);
  }
#line 465
  if (! tmp___41) {
    {
#line 466
    tmp___40 = __errno_location();
#line 466
    __error(1, "Unable to read %s: errno %d (%m)\n", configfile, *tmp___40);
    }
  }
  {
#line 468
  tmp___43 = fclose(config);
  }
#line 468
  if (tmp___43 == -1) {
    {
#line 469
    tmp___42 = __errno_location();
#line 469
    __error(1, "Unable to close %s: errno %d (%m)\n", configfile, *tmp___42);
    }
  }
#line 472
  if (! nocull) {
    {
#line 473
    tmp___44 = calloc((size_t )culltable_size, sizeof(*(cullbuild + 0)));
#line 473
    cullbuild = (struct object **)tmp___44;
    }
#line 474
    if (! cullbuild) {
      {
#line 475
      tmp___45 = __errno_location();
#line 475
      __error(1, "calloc: errno %d (%m)\n", *tmp___45);
      }
    }
    {
#line 477
    tmp___46 = calloc((size_t )culltable_size, sizeof(*(cullready + 0)));
#line 477
    cullready = (struct object **)tmp___46;
    }
#line 478
    if (! cullready) {
      {
#line 479
      tmp___47 = __errno_location();
#line 479
      __error(1, "calloc: errno %d (%m)\n", *tmp___47);
      }
    }
  }
#line 483
  if (nullfd != 0) {
    {
#line 484
    dup2(nullfd, 0);
    }
  }
#line 485
  if (nullfd != 1) {
    {
#line 486
    dup2(nullfd, 1);
    }
  }
#line 488
  loop = 4;
  {
#line 488
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 488
    if (! (loop < open_max)) {
#line 488
      goto while_break___4;
    }
    {
#line 489
    close(loop);
#line 488
    loop ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 493
  openlog("cachefilesd", 1, 3 << 3);
#line 494
  xopenedlog = 1;
#line 495
  __message(0, 6, "About to bind cache\n");
#line 498
  tmp___49 = write(3, (void const   *)"bind", (size_t )4);
  }
#line 498
  if (tmp___49 < 0L) {
    {
#line 499
    tmp___48 = __errno_location();
#line 499
    __error(1, "CacheFiles bind failed: errno %d (%m)\n", *tmp___48);
    }
  }
  {
#line 501
  __message(0, 6, "Bound cache\n");
  }
#line 504
  if (! nodaemon) {
#line 505
    if (! xdebug) {
      {
#line 506
      dup2(1, 2);
      }
    }
    {
#line 508
    tmp___50 = fork();
    }
    {
#line 509
    if (tmp___50 == -1) {
#line 509
      goto case_neg_1;
    }
#line 512
    if (tmp___50 == 0) {
#line 512
      goto case_0;
    }
#line 523
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 510
    tmp___51 = __errno_location();
#line 510
    __error(1, "fork: errno %d (%m)\n", *tmp___51);
    }
    case_0: /* CIL Label */ 
#line 513
    if (xdebug) {
      {
#line 514
      tmp___52 = getpid();
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Daemon PID %d\n",
              tmp___52);
      }
    }
    {
#line 516
    signal(21, (void (*)(int  ))1);
#line 517
    signal(22, (void (*)(int  ))1);
#line 518
    signal(20, (void (*)(int  ))1);
#line 519
    setsid();
#line 520
    write_pidfile();
#line 521
    cachefilesd();
    }
    switch_default___0: /* CIL Label */ 
#line 524
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 528
    cachefilesd();
    }
  }
  {
#line 531
  exit(0);
  }
}
}
#line 538 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void open_cache(void) 
{ 
  struct statfs sfs ;
  char buffer[4097] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 544
  snprintf((char */* __restrict  */)(buffer), (size_t )4096, (char const   */* __restrict  */)"%s/cache",
           cacheroot);
#line 546
  root.dir = opendir((char const   *)(buffer));
  }
#line 547
  if (! root.dir) {
    {
#line 548
    tmp = __errno_location();
#line 548
    __error(1, "Unable to open cache directory: errno %d (%m)\n", *tmp);
    }
  }
  {
#line 549
  nopendir ++;
#line 552
  tmp___1 = asprintf((char **/* __restrict  */)(& graveyardpath), (char const   */* __restrict  */)"%s/graveyard",
                     cacheroot);
  }
#line 552
  if (tmp___1 < 0) {
    {
#line 553
    tmp___0 = __errno_location();
#line 553
    __error(1, "Unable to copy graveyard name: errno %d (%m)\n", *tmp___0);
    }
  }
  {
#line 555
  graveyardfd = open((char const   *)graveyardpath, 65536);
  }
#line 556
  if (graveyardfd < 0) {
    {
#line 557
    tmp___2 = __errno_location();
#line 557
    __error(1, "Unable to open graveyard directory: errno %d (%m)\n", *tmp___2);
    }
  }
  {
#line 559
  tmp___4 = fstatfs(graveyardfd, & sfs);
  }
#line 559
  if (tmp___4 < 0) {
    {
#line 560
    tmp___3 = __errno_location();
#line 560
    __error(1, "Unable to stat cache filesystem: errno %d (%m)\n", *tmp___3);
    }
  }
#line 562
  if (sfs.f_bsize == -1L) {
    {
#line 566
    __error(3, "Internal error: Backing filesystem returns unusable statistics through fstatfs()\n");
    }
  } else
#line 562
  if (sfs.f_blocks == 0xffffffffffffffffUL) {
    {
#line 566
    __error(3, "Internal error: Backing filesystem returns unusable statistics through fstatfs()\n");
    }
  } else
#line 562
  if (sfs.f_bfree == 0xffffffffffffffffUL) {
    {
#line 566
    __error(3, "Internal error: Backing filesystem returns unusable statistics through fstatfs()\n");
    }
  } else
#line 562
  if (sfs.f_bavail == 0xffffffffffffffffUL) {
    {
#line 566
    __error(3, "Internal error: Backing filesystem returns unusable statistics through fstatfs()\n");
    }
  }
#line 567
  return;
}
}
#line 573
static  __attribute__((__noreturn__)) void cachefilesd(void) ;
#line 573 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void cachefilesd(void) 
{ 
  sigset_t sigs ;
  sigset_t osigs ;
  struct pollfd pollfds[1] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 577
  pollfds[0].fd = 3;
#line 577
  pollfds[0].events = (short)1;
#line 577
  pollfds[0].revents = (short)0;
#line 584
  __message(0, 5, "Daemon Started\n");
#line 587
  open_cache();
#line 592
  sigemptyset(& sigs);
#line 593
  sigaddset(& sigs, 29);
#line 594
  sigaddset(& sigs, 2);
#line 595
  sigaddset(& sigs, 15);
#line 597
  signal(15, & sigterm);
#line 598
  signal(2, & sigterm);
#line 601
  reap_graveyard();
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (! stop)) {
#line 603
      goto while_break;
    }
    {
#line 604
    read_cache_state();
    }
#line 608
    if (! scan) {
#line 608
      if (! reap) {
#line 608
        if (! cull) {
          {
#line 609
          tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigs),
                                (sigset_t */* __restrict  */)(& osigs));
          }
#line 609
          if (tmp___0 < 0) {
            {
#line 610
            tmp = __errno_location();
#line 610
            __error(1, "Unable to block signals: errno %d (%m)\n", *tmp);
            }
          }
#line 612
          if (! reap) {
#line 612
            if (! cull) {
              {
#line 613
              tmp___2 = ppoll(pollfds, (nfds_t )1, (struct timespec  const  *)((void *)0),
                              (__sigset_t const   *)(& osigs));
              }
#line 613
              if (tmp___2 < 0) {
                {
#line 613
                tmp___3 = __errno_location();
                }
#line 613
                if (*tmp___3 != 4) {
                  {
#line 615
                  tmp___1 = __errno_location();
#line 615
                  __error(1, "Unable to suspend process: errno %d (%m)\n", *tmp___1);
                  }
                }
              }
            }
          }
          {
#line 618
          tmp___5 = sigprocmask(1, (sigset_t const   */* __restrict  */)(& sigs),
                                (sigset_t */* __restrict  */)((void *)0));
          }
#line 618
          if (tmp___5 < 0) {
            {
#line 619
            tmp___4 = __errno_location();
#line 619
            __error(1, "Unable to unblock signals: errno %d (%m)\n", *tmp___4);
            }
          }
          {
#line 621
          read_cache_state();
          }
        }
      }
    }
#line 624
    if (nocull) {
#line 625
      cull = 0;
    } else {
#line 627
      if (jumpstart_scan) {
#line 628
        jumpstart_scan = 0;
#line 629
        if (! stop) {
#line 629
          if (! scan) {
            {
#line 630
            __message(1, 7, "Refilling cull table\n");
#line 631
            (root.usage) ++;
#line 632
            scan = & root;
            }
          }
        }
      }
#line 636
      if (cull) {
#line 637
        if (oldest_ready >= 0) {
          {
#line 638
          cull_objects();
          }
        } else
#line 639
        if (oldest_build < 0) {
#line 640
          jumpstart_scan = 1;
        }
      }
#line 643
      if (scan) {
        {
#line 644
        build_cull_table();
        }
      }
#line 646
      if (! scan) {
#line 646
        if (oldest_ready < 0) {
#line 646
          if (oldest_build >= 0) {
            {
#line 647
            decant_cull_table();
            }
          }
        }
      }
    }
#line 650
    if (reap) {
      {
#line 651
      reap_graveyard();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 654
  __message(0, 5, "Daemon Terminated\n");
#line 655
  exit(0);
  }
}
}
#line 662 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void reap_graveyard(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 665
  reap = 0;
#line 666
  signal(29, & sigio);
#line 667
  tmp___0 = fcntl(graveyardfd, 1026, 4);
  }
#line 667
  if (tmp___0 < 0) {
    {
#line 668
    tmp = __errno_location();
#line 668
    __error(1, "unable to set notification on graveyard: errno %d (%m)\n", *tmp);
    }
  }
  {
#line 670
  reap_graveyard_aux((char const   *)graveyardpath);
  }
#line 671
  return;
}
}
#line 677 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void reap_graveyard_aux(char const   *dirname ) 
{ 
  struct dirent dirent ;
  struct dirent *de ;
  DIR *dir ;
  int deleted ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 683
  tmp___0 = chdir(dirname);
  }
#line 683
  if (tmp___0 < 0) {
    {
#line 684
    tmp = __errno_location();
#line 684
    __error(1, "chdir failed: errno %d (%m)\n", *tmp);
    }
  }
  {
#line 686
  dir = opendir(".");
  }
#line 687
  if (! dir) {
    {
#line 688
    tmp___1 = __errno_location();
#line 688
    __error(1, "Unable to open grave dir %s: errno %d (%m)\n", dirname, *tmp___1);
    }
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 693
    rewinddir(dir);
#line 694
    deleted = 0;
    }
    {
#line 696
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 696
      ret = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& dirent),
                      (struct dirent **/* __restrict  */)(& de));
      }
#line 696
      if (ret == 0) {
#line 696
        if ((unsigned long )de != (unsigned long )((void *)0)) {
#line 696
          tmp___7 = 1;
        } else {
#line 696
          tmp___7 = 0;
        }
      } else {
#line 696
        tmp___7 = 0;
      }
#line 696
      if (! tmp___7) {
#line 696
        goto while_break___0;
      }
#line 700
      if ((int )dirent.d_name[0] == 46) {
#line 701
        if ((int )dirent.d_name[1] == 0) {
#line 702
          goto while_continue___0;
        }
#line 703
        if ((int )dirent.d_name[1] == 46) {
#line 705
          goto while_continue___0;
        } else
#line 703
        if ((int )dirent.d_name[1] == 0) {
#line 705
          goto while_continue___0;
        }
      }
#line 708
      deleted = 1;
#line 711
      if ((int )dirent.d_type != 4) {
        {
#line 712
        __message(1, 7, "unlink %s\n", dirent.d_name);
#line 713
        tmp___2 = unlink((char const   *)(dirent.d_name));
        }
#line 713
        if (tmp___2 == 0) {
#line 714
          goto while_continue___0;
        }
        {
#line 715
        tmp___4 = __errno_location();
        }
#line 715
        if (*tmp___4 != 21) {
          {
#line 716
          tmp___3 = __errno_location();
#line 716
          __error(1, "Unable to unlink file %s: errno %d (%m)\n", dirent.d_name, *tmp___3);
          }
        }
      }
      {
#line 721
      memcpy((void */* __restrict  */)(& dirent), (void const   */* __restrict  */)de,
             sizeof(dirent));
#line 723
      reap_graveyard_aux((char const   *)(dirent.d_name));
#line 726
      __message(1, 7, "rmdir %s\n", dirent.d_name);
#line 727
      tmp___6 = rmdir((char const   *)(dirent.d_name));
      }
#line 727
      if (tmp___6 < 0) {
        {
#line 728
        tmp___5 = __errno_location();
#line 728
        __error(1, "Unable to remove dir %s: errno %d (%m)\n", dirent.d_name, *tmp___5);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 731
    if (ret < 0) {
      {
#line 732
      tmp___8 = __errno_location();
#line 732
      __error(1, "Unable to read dir %s: errno %d (%m)\n", dirname, *tmp___8);
      }
    }
#line 690
    if (! deleted) {
#line 690
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 735
  closedir(dir);
#line 737
  tmp___10 = chdir("..");
  }
#line 737
  if (tmp___10 < 0) {
    {
#line 738
    tmp___9 = __errno_location();
#line 738
    __error(1, "Unable to chdir to ..: errno %d (%m)\n", *tmp___9);
    }
  }
#line 739
  return;
}
}
#line 745 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void read_cache_state(void) 
{ 
  char buffer[4097] ;
  char *tok ;
  char *next ;
  char *arg ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 750
  tmp = read(3, (void *)(buffer), sizeof(buffer) - 1UL);
#line 750
  n = (int )tmp;
  }
#line 751
  if (n < 0) {
    {
#line 752
    tmp___0 = __errno_location();
#line 752
    __error(1, "Unable to read cache state: errno %d (%m)\n", *tmp___0);
    }
  }
#line 753
  buffer[n] = (char )'\000';
#line 755
  tok = buffer;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 757
    next = strpbrk((char const   *)tok, " \t");
    }
#line 758
    if (next) {
#line 759
      tmp___1 = next;
#line 759
      next ++;
#line 759
      *tmp___1 = (char )'\000';
    }
    {
#line 761
    arg = strchr((char const   *)tok, '=');
    }
#line 762
    if (arg) {
#line 763
      tmp___2 = arg;
#line 763
      arg ++;
#line 763
      *tmp___2 = (char )'\000';
    }
    {
#line 765
    tmp___10 = strcmp((char const   *)tok, "cull");
    }
#line 765
    if (tmp___10 == 0) {
      {
#line 766
      tmp___3 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                        0);
#line 766
      cull = (int )tmp___3;
      }
    } else {
      {
#line 767
      tmp___9 = strcmp((char const   *)tok, "brun");
      }
#line 767
      if (tmp___9 == 0) {
        {
#line 768
        brun = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                        16);
        }
      } else {
        {
#line 769
        tmp___8 = strcmp((char const   *)tok, "bcull");
        }
#line 769
        if (tmp___8 == 0) {
          {
#line 770
          bcull = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                           16);
          }
        } else {
          {
#line 771
          tmp___7 = strcmp((char const   *)tok, "bstop");
          }
#line 771
          if (tmp___7 == 0) {
            {
#line 772
            bstop = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                             16);
            }
          } else {
            {
#line 773
            tmp___6 = strcmp((char const   *)tok, "frun");
            }
#line 773
            if (tmp___6 == 0) {
              {
#line 774
              frun = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                              16);
              }
            } else {
              {
#line 775
              tmp___5 = strcmp((char const   *)tok, "fcull");
              }
#line 775
              if (tmp___5 == 0) {
                {
#line 776
                fcull = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                                 16);
                }
              } else {
                {
#line 777
                tmp___4 = strcmp((char const   *)tok, "fstop");
                }
#line 777
                if (tmp___4 == 0) {
                  {
#line 778
                  fstop = strtoull((char const   */* __restrict  */)arg, (char **/* __restrict  */)((void *)0),
                                   16);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 756
    tok = next;
#line 756
    if (! tok) {
#line 756
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return;
}
}
#line 787 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int is_object_in_use(char const   *filename ) 
{ 
  char buffer[285] ;
  int ret ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 792
  n = sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"inuse %s",
              filename);
#line 795
  tmp = write(3, (void const   *)(buffer), (size_t )n);
#line 795
  ret = (int )tmp;
  }
#line 796
  if (ret < 0) {
    {
#line 796
    tmp___1 = __errno_location();
    }
#line 796
    if (*tmp___1 != 116) {
      {
#line 796
      tmp___2 = __errno_location();
      }
#line 796
      if (*tmp___2 != 2) {
        {
#line 796
        tmp___3 = __errno_location();
        }
#line 796
        if (*tmp___3 != 16) {
          {
#line 797
          tmp___0 = __errno_location();
#line 797
          __error(1, "Failed to check object\'s in-use state: errno %d (%m)\n", *tmp___0);
          }
        }
      }
    }
  }
#line 799
  if (ret < 0) {
    {
#line 799
    tmp___6 = __errno_location();
    }
#line 799
    if (*tmp___6 == 16) {
#line 799
      tmp___5 = 1;
    } else {
#line 799
      tmp___5 = 0;
    }
  } else {
#line 799
    tmp___5 = 0;
  }
#line 799
  return (tmp___5);
}
}
#line 807 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void cull_file(char const   *filename ) 
{ 
  char buffer[285] ;
  int ret ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 812
  n = sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"cull %s",
              filename);
#line 815
  tmp = write(3, (void const   *)(buffer), (size_t )n);
#line 815
  ret = (int )tmp;
  }
#line 816
  if (ret < 0) {
    {
#line 816
    tmp___1 = __errno_location();
    }
#line 816
    if (*tmp___1 != 116) {
      {
#line 816
      tmp___2 = __errno_location();
      }
#line 816
      if (*tmp___2 != 2) {
        {
#line 816
        tmp___3 = __errno_location();
        }
#line 816
        if (*tmp___3 != 16) {
          {
#line 817
          tmp___0 = __errno_location();
#line 817
          __error(1, "Failed to cull object: errno %d (%m)\n", *tmp___0);
          }
        }
      }
    }
  }
#line 818
  return;
}
}
#line 825 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static struct object *create_object(struct object *parent , char const   *name , struct stat64 *st ) 
{ 
  struct object *object ;
  struct object *p ;
  struct object *pr ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 834
  pr = (struct object *)((void *)0);
#line 835
  p = parent->children;
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! p) {
#line 835
      goto while_break;
    }
#line 836
    if (p->ino <= st->st_ino) {
#line 837
      if (p->ino == st->st_ino) {
#line 839
        (p->usage) ++;
#line 840
        return (p);
      }
#line 843
      goto while_break;
    }
#line 835
    pr = p;
#line 835
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 850
  tmp = strlen(name);
#line 850
  len = (int )tmp;
#line 852
  tmp___0 = calloc((size_t )1, sizeof(struct object ) + (unsigned long )len);
#line 852
  object = (struct object *)tmp___0;
  }
#line 853
  if (! object) {
    {
#line 854
    tmp___1 = __errno_location();
#line 854
    __error(1, "Unable to alloc object: errno %d (%m)\n", *tmp___1);
    }
  }
  {
#line 856
  object->usage = 1;
#line 857
  object->new = (char)1;
#line 859
  object->ino = st->st_ino;
#line 860
  object->atime = st->st_atim.tv_sec;
#line 861
  memcpy((void */* __restrict  */)(object->name), (void const   */* __restrict  */)name,
         (size_t )(len + 1));
  }
  {
#line 865
  if ((int )object->name[0] == 74) {
#line 865
    goto case_74;
  }
#line 865
  if ((int )object->name[0] == 73) {
#line 865
    goto case_74;
  }
#line 869
  if ((int )object->name[0] == 69) {
#line 869
    goto case_69;
  }
#line 869
  if ((int )object->name[0] == 68) {
#line 869
    goto case_69;
  }
#line 873
  if ((int )object->name[0] == 84) {
#line 873
    goto case_84;
  }
#line 873
  if ((int )object->name[0] == 83) {
#line 873
    goto case_84;
  }
#line 877
  if ((int )object->name[0] == 64) {
#line 877
    goto case_64;
  }
#line 877
  if ((int )object->name[0] == 43) {
#line 877
    goto case_64;
  }
#line 880
  goto switch_default;
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 866
  object->type = (objtype_t )0;
#line 867
  goto switch_break;
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 870
  object->type = (objtype_t )1;
#line 871
  goto switch_break;
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
#line 874
  object->type = (objtype_t )2;
#line 875
  goto switch_break;
  case_64: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 878
  object->type = (objtype_t )3;
#line 879
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 881
  __error(3, "Internal error: Unexpected file type \'%c\'\n", (int )object->name[0]);
  }
  switch_break: /* CIL Label */ ;
  }
#line 885
  (parent->usage) ++;
#line 886
  object->parent = parent;
#line 887
  object->prev = pr;
#line 888
  object->next = p;
#line 889
  if (pr) {
#line 890
    pr->next = object;
  } else {
#line 892
    parent->children = object;
  }
#line 893
  if (p) {
#line 894
    p->prev = object;
  }
#line 896
  nobjects ++;
#line 897
  return (object);
}
}
#line 904 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void put_object(struct object *object ) 
{ 
  struct object *parent ;

  {
#line 908
  (object->usage) --;
#line 908
  if (object->usage > 0) {
#line 909
    return;
  }
#line 911
  nobjects --;
#line 913
  if (object->cullable) {
#line 914
    ncullable --;
  }
#line 917
  if ((unsigned long )object == (unsigned long )(& root)) {
    {
#line 918
    __error(3, "Internal error: Can\'t destroy root object representation\n");
    }
  }
#line 920
  if (object->children) {
    {
#line 921
    __error(3, "Internal error: Destroying object with children: \'%s\'\n", object->name);
    }
  }
#line 923
  if (object->dir) {
    {
#line 924
    closedir(object->dir);
#line 925
    nopendir --;
    }
  }
#line 928
  if (object->prev) {
#line 929
    (object->prev)->next = object->next;
  } else {
#line 931
    (object->parent)->children = object->next;
  }
#line 933
  if (object->next) {
#line 934
    (object->next)->prev = object->prev;
  }
  {
#line 936
  parent = object->parent;
#line 938
  memset((void *)object, 109, sizeof(struct object ));
#line 939
  free((void *)object);
  }
#line 941
  if (parent) {
    {
#line 942
    put_object(parent);
    }
  }
#line 943
  return;
}
}
#line 951 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static unsigned int uniquifier  ;
#line 949 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void destroy_unexpected_object(struct object *parent , struct dirent *de ) 
{ 
  struct timeval tv ;
  char namebuf[40] ;
  int fd ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  unsigned int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 956
  fd = dirfd(parent->dir);
  }
#line 958
  if ((int )de->d_type != 4) {
    {
#line 959
    tmp___0 = unlinkat(fd, (char const   *)(de->d_name), 0);
    }
#line 959
    if (tmp___0 < 0) {
      {
#line 959
      tmp___1 = __errno_location();
      }
#line 959
      if (*tmp___1 != 2) {
        {
#line 961
        tmp = __errno_location();
#line 961
        __error(1, "Unable to unlink unexpectedly named file: %s: errno %d (%m)\n",
                de->d_name, *tmp);
        }
      }
    }
  } else {
    {
#line 965
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 966
    tmp___2 = uniquifier;
#line 966
    uniquifier ++;
#line 966
    sprintf((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)"x%lxx%xx",
            tv.tv_sec, tmp___2);
#line 968
    tmp___4 = renameat(fd, (char const   *)(de->d_name), graveyardfd, (char const   *)(namebuf));
    }
#line 968
    if (tmp___4 < 0) {
      {
#line 968
      tmp___5 = __errno_location();
      }
#line 968
      if (*tmp___5 != 2) {
        {
#line 970
        tmp___3 = __errno_location();
#line 970
        __error(1, "Unable to rename unexpectedly named file: %s: errno %d (%m)\n",
                de->d_name, *tmp___3);
        }
      }
    }
  }
#line 973
  return;
}
}
#line 979 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void insert_into_cull_table(struct object *object ) 
{ 
  int y ;
  int o ;
  int m ;

  {
#line 983
  if (! object) {
    {
#line 984
    __error(3, "Internal error: NULL object pointer\n");
    }
  }
#line 987
  if (oldest_build == -1) {
#line 988
    (object->usage) ++;
#line 989
    oldest_build = 0;
#line 990
    *(cullbuild + 0) = object;
#line 991
    return;
  }
#line 995
  if ((unsigned int )oldest_build < culltable_size - 1U) {
#line 996
    (object->usage) ++;
#line 997
    oldest_build ++;
#line 1000
    if (object->atime <= (*(cullbuild + (oldest_build - 1)))->atime) {
#line 1001
      *(cullbuild + oldest_build) = object;
#line 1002
      return;
    }
#line 1006
    if (object->atime > (*(cullbuild + 0))->atime) {
      {
#line 1007
      memmove((void *)(cullbuild + 1), (void const   *)(cullbuild + 0), (unsigned long )oldest_build * sizeof(*(cullbuild + 0)));
#line 1011
      *(cullbuild + 0) = object;
      }
#line 1012
      return;
    }
#line 1016
    if (oldest_build == 2) {
#line 1017
      *(cullbuild + 2) = *(cullbuild + 1);
#line 1018
      *(cullbuild + 1) = object;
#line 1019
      return;
    }
#line 1026
    y = 1;
#line 1027
    o = oldest_build - 1;
    {
#line 1029
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1030
      m = (y + o) / 2;
#line 1032
      if (object->atime > (*(cullbuild + m))->atime) {
#line 1033
        o = m;
      } else {
#line 1035
        y = m + 1;
      }
#line 1029
      if (! (y < o)) {
#line 1029
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1039
    memmove((void *)(cullbuild + (y + 1)), (void const   *)(cullbuild + y), (unsigned long )(oldest_build - y) * sizeof(*(cullbuild + 0)));
#line 1043
    *(cullbuild + y) = object;
    }
#line 1044
    return;
  }
#line 1048
  if ((unsigned int )oldest_build > culltable_size - 1U) {
    {
#line 1049
    __error(3, "Internal error: Cull table overfull\n");
    }
  }
#line 1051
  if (object->atime >= (*(cullbuild + 0))->atime) {
#line 1052
    return;
  }
  {
#line 1055
  put_object(*(cullbuild + 0));
#line 1056
  *(cullbuild + 0) = (struct object *)((void *)1795163168);
#line 1057
  (object->usage) ++;
  }
#line 1060
  if (object->atime >= (*(cullbuild + 1))->atime) {
#line 1061
    *(cullbuild + 0) = object;
#line 1062
    return;
  }
#line 1066
  if (object->atime <= (*(cullbuild + (culltable_size - 1U)))->atime) {
    {
#line 1067
    memmove((void *)(cullbuild + 0), (void const   *)(cullbuild + 1), (unsigned long )(culltable_size - 1U) * sizeof(*(cullbuild + 0)));
#line 1071
    *(cullbuild + (culltable_size - 1U)) = object;
    }
#line 1072
    return;
  }
#line 1079
  *(cullbuild + 0) = *(cullbuild + 1);
#line 1081
  y = 2;
#line 1082
  o = (int )(culltable_size - 1U);
  {
#line 1084
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1085
    m = (y + o) / 2;
#line 1087
    if (object->atime >= (*(cullbuild + m))->atime) {
#line 1088
      o = m;
    } else {
#line 1090
      y = m + 1;
    }
#line 1084
    if (! (y < o)) {
#line 1084
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1094
  if (y == 2) {
#line 1095
    *(cullbuild + 1) = object;
#line 1096
    return;
  }
  {
#line 1099
  memmove((void *)(cullbuild + 1), (void const   *)(cullbuild + 2), (unsigned long )(y - 2) * sizeof(*(cullbuild + 0)));
#line 1103
  *(cullbuild + (y - 1)) = object;
  }
#line 1104
  return;
}
}
#line 1110 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void build_cull_table(void) 
{ 
  struct dirent dirent ;
  struct dirent *de ;
  struct object *curr ;
  struct object *child ;
  struct stat64 st ;
  int loop ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1117
  curr = scan;
#line 1119
  if (! curr->dir) {
    {
#line 1120
    curr->empty = (char)1;
#line 1122
    tmp = dirfd((curr->parent)->dir);
#line 1122
    fd = openat(tmp, (char const   *)(curr->name), 65536);
    }
#line 1123
    if (fd < 0) {
      {
#line 1124
      tmp___1 = __errno_location();
      }
#line 1124
      if (*tmp___1 != 2) {
        {
#line 1125
        tmp___0 = __errno_location();
#line 1125
        __error(1, "Failed to open directory: errno %d (%m)\n", *tmp___0);
        }
      }
#line 1126
      goto dir_read_complete;
    }
    {
#line 1129
    curr->dir = fdopendir(fd);
    }
#line 1130
    if (! curr->dir) {
      {
#line 1131
      tmp___2 = __errno_location();
#line 1131
      __error(1, "Failed to open directory: errno %d (%m)\n", *tmp___2);
      }
    }
#line 1133
    nopendir ++;
  }
  {
#line 1136
  __message(2, 7, "--> build_cull_table({%s})\n", curr->name);
#line 1138
  tmp___4 = dirfd(curr->dir);
#line 1138
  tmp___5 = fchdir(tmp___4);
  }
#line 1138
  if (tmp___5 < 0) {
    {
#line 1139
    tmp___3 = __errno_location();
#line 1139
    __error(1, "Failed to change current directory: errno %d (%m)\n", *tmp___3);
    }
  }
  next: 
  {
#line 1143
  tmp___8 = readdir_r((DIR */* __restrict  */)curr->dir, (struct dirent */* __restrict  */)(& dirent),
                      (struct dirent **/* __restrict  */)(& de));
  }
#line 1143
  if (tmp___8 < 0) {
    {
#line 1144
    tmp___6 = __errno_location();
    }
#line 1144
    if (*tmp___6 == 2) {
#line 1145
      goto dir_read_complete;
    }
    {
#line 1146
    tmp___7 = __errno_location();
#line 1146
    __error(1, "Unable to read directory: errno %d (%m)\n", *tmp___7);
    }
  }
#line 1149
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 1150
    goto dir_read_complete;
  }
#line 1152
  if ((int )dirent.d_name[0] == 46) {
#line 1153
    if (! dirent.d_name[1]) {
#line 1155
      goto next;
    } else
#line 1153
    if ((int )dirent.d_name[1] == 46) {
#line 1153
      if (! dirent.d_name[2]) {
#line 1155
        goto next;
      }
    }
  }
  {
#line 1158
  __message(2, 7, "readdir \'%s\'\n", dirent.d_name);
  }
  {
#line 1163
  if ((int )dirent.d_type == 8) {
#line 1163
    goto case_8;
  }
#line 1163
  if ((int )dirent.d_type == 4) {
#line 1163
    goto case_8;
  }
#line 1163
  if ((int )dirent.d_type == 0) {
#line 1163
    goto case_8;
  }
#line 1165
  goto switch_default;
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1164
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1166
  tmp___9 = __errno_location();
#line 1166
  __error(1, "readdir returned unsupported type %d: errno %d (%m)\n", (int )dirent.d_type,
          *tmp___9);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1170
  tmp___10 = memchr((void const   *)"IDSJET+@", (int )dirent.d_name[0], (size_t )8);
  }
#line 1170
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 1171
    goto found_unexpected_object;
  }
  {
#line 1174
  tmp___13 = dirfd(curr->dir);
#line 1174
  tmp___14 = fstatat64(tmp___13, (char const   */* __restrict  */)(dirent.d_name),
                       (struct stat64 */* __restrict  */)(& st), 0);
  }
#line 1174
  if (tmp___14 < 0) {
    {
#line 1175
    tmp___11 = __errno_location();
    }
#line 1175
    if (*tmp___11 == 2) {
#line 1176
      goto next;
    }
    {
#line 1177
    tmp___12 = __errno_location();
#line 1177
    __error(1, "Failed to stat directory: errno %d (%m)\n", *tmp___12);
    }
  }
#line 1180
  if (! ((st.st_mode & 61440U) == 16384U)) {
#line 1180
    if (! ((st.st_mode & 61440U) == 32768U)) {
#line 1186
      goto found_unexpected_object;
    } else
#line 1180
    if ((int )dirent.d_name[0] == 73) {
#line 1186
      goto found_unexpected_object;
    } else
#line 1180
    if ((int )dirent.d_name[0] == 74) {
#line 1186
      goto found_unexpected_object;
    } else
#line 1180
    if ((int )dirent.d_name[0] == 64) {
#line 1186
      goto found_unexpected_object;
    } else
#line 1180
    if ((int )dirent.d_name[0] == 43) {
#line 1186
      goto found_unexpected_object;
    }
  }
  {
#line 1189
  child = create_object(curr, (char const   *)(dirent.d_name), & st);
  }
#line 1190
  if (! child) {
    {
#line 1190
    tmp___15 = __errno_location();
    }
#line 1190
    if (*tmp___15 == 2) {
#line 1191
      goto next;
    }
  }
#line 1193
  curr->empty = (char)0;
#line 1195
  if (! child) {
    {
#line 1196
    tmp___16 = __errno_location();
#line 1196
    __error(1, "Unable to create object: errno %d (%m)\n", *tmp___16);
    }
  }
  {
#line 1202
  if ((unsigned int )child->type == 2U) {
#line 1202
    goto case_2;
  }
#line 1202
  if ((unsigned int )child->type == 1U) {
#line 1202
    goto case_2;
  }
#line 1273
  if ((unsigned int )child->type == 3U) {
#line 1273
    goto case_3;
  }
#line 1273
  if ((unsigned int )child->type == 0U) {
#line 1273
    goto case_3;
  }
#line 1282
  goto switch_default___0;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1203
  if (! child->new) {
    {
#line 1208
    __message(2, 7, "- old child\n");
    }
#line 1210
    if (st.st_atim.tv_sec <= child->atime) {
      {
#line 1212
      put_object(child);
      }
#line 1213
      goto next;
    }
#line 1216
    loop = 0;
    {
#line 1216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1216
      if (! (loop <= oldest_ready)) {
#line 1216
        goto while_break;
      }
#line 1217
      if ((unsigned long )*(cullready + loop) == (unsigned long )child) {
#line 1218
        goto while_break;
      }
#line 1216
      loop ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1220
    if (loop == oldest_ready) {
      {
#line 1222
      *(cullready + oldest_ready) = (struct object *)((void *)1795163334);
#line 1223
      oldest_ready --;
#line 1224
      put_object(child);
      }
#line 1225
      goto removed;
    } else
#line 1227
    if (loop < oldest_ready) {
      {
#line 1229
      memmove((void *)(cullready + loop), (void const   *)(cullready + (loop + 1)),
              (unsigned long )(oldest_ready - loop) * sizeof(*(cullready + 0)));
#line 1232
      *(cullready + oldest_ready) = (struct object *)((void *)1795163344);
#line 1233
      oldest_ready --;
#line 1234
      put_object(child);
      }
#line 1235
      goto removed;
    }
#line 1238
    loop = 0;
    {
#line 1238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1238
      if (! (loop <= oldest_build)) {
#line 1238
        goto while_break___0;
      }
#line 1239
      if ((unsigned long )*(cullbuild + loop) == (unsigned long )child) {
#line 1240
        goto while_break___0;
      }
#line 1238
      loop ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1242
    if (loop == oldest_build) {
      {
#line 1244
      *(cullbuild + oldest_build) = (struct object *)((void *)1795163356);
#line 1245
      oldest_build --;
#line 1246
      put_object(child);
      }
    } else
#line 1248
    if (loop < oldest_build) {
      {
#line 1250
      memmove((void *)(cullbuild + loop), (void const   *)(cullbuild + (loop + 1)),
              (unsigned long )(oldest_build - loop) * sizeof(*(cullbuild + 0)));
#line 1253
      *(cullbuild + oldest_build) = (struct object *)((void *)1795163365);
#line 1254
      oldest_build --;
#line 1255
      put_object(child);
      }
    }
    removed: ;
  }
  {
#line 1263
  tmp___17 = is_object_in_use((char const   *)(dirent.d_name));
  }
#line 1263
  if (! tmp___17) {
    {
#line 1264
    __message(2, 7, "- insert\n");
#line 1265
    child->new = (char)0;
#line 1266
    insert_into_cull_table(child);
    }
  }
  {
#line 1268
  put_object(child);
  }
#line 1269
  goto next;
  case_3: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 1274
  __message(2, 7, "- descend\n");
#line 1276
  child->new = (char)0;
#line 1277
  scan = child;
#line 1279
  __message(2, 7, "<-- build_cull_table({%s})\n", curr->name);
  }
#line 1280
  return;
  switch_default___0: /* CIL Label */ 
  {
#line 1283
  __error(3, "Internal error: Unexpected type\n");
  }
  switch_break___0: /* CIL Label */ ;
  }
  dir_read_complete: 
  {
#line 1288
  __message(2, 7, "dir_read_complete: u=%d e=%d %s\n", curr->usage, (int )curr->empty,
            curr->name);
  }
#line 1291
  if (curr->dir) {
#line 1292
    if ((unsigned long )curr != (unsigned long )(& root)) {
      {
#line 1293
      closedir(curr->dir);
#line 1294
      curr->dir = (DIR *)((void *)0);
#line 1295
      nopendir --;
      }
    } else {
      {
#line 1298
      rewinddir(curr->dir);
      }
    }
  }
#line 1302
  if (curr->usage == 1) {
#line 1302
    if (curr->empty) {
      {
#line 1305
      tmp___19 = dirfd((curr->parent)->dir);
#line 1305
      tmp___20 = fchdir(tmp___19);
      }
#line 1305
      if (tmp___20 < 0) {
        {
#line 1306
        tmp___18 = __errno_location();
#line 1306
        __error(1, "Failed to change current directory: errno %d (%m)\n", *tmp___18);
        }
      }
      {
#line 1309
      if ((unsigned int )curr->type == 0U) {
#line 1309
        goto case_0___1;
      }
#line 1313
      if ((unsigned int )curr->type == 3U) {
#line 1313
        goto case_3___0;
      }
#line 1318
      goto switch_default___1;
      case_0___1: /* CIL Label */ 
      {
#line 1310
      cull_file((char const   *)(curr->name));
      }
#line 1311
      goto switch_break___1;
      case_3___0: /* CIL Label */ 
      {
#line 1314
      tmp___21 = dirfd((curr->parent)->dir);
#line 1314
      unlinkat(tmp___21, (char const   *)(curr->name), 512);
      }
#line 1316
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 1319
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 1323
  scan = curr->parent;
#line 1324
  if (! scan) {
    {
#line 1325
    __message(1, 7, "Scan complete\n");
#line 1326
    decant_cull_table();
    }
  }
  {
#line 1329
  __message(2, 7, "<-- build_cull_table({%s})\n", curr->name);
#line 1330
  put_object(curr);
  }
#line 1331
  return;
  found_unexpected_object: 
  {
#line 1335
  __message(2, 7, "found_unexpected_object\n");
#line 1337
  destroy_unexpected_object(curr, & dirent);
  }
#line 1338
  goto next;
}
}
#line 1345 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void decant_cull_table(void) 
{ 
  int loop ;
  int space ;
  int avail ;
  int copy ;
  int leave ;
  int n ;

  {
#line 1349
  if (scan) {
    {
#line 1350
    __error(3, "Internal error: Can\'t decant cull table whilst scanning\n");
    }
  }
#line 1353
  if (oldest_build < 0) {
    {
#line 1354
    signal(14, & sigalrm);
#line 1355
    alarm(30U);
    }
#line 1356
    return;
  }
#line 1360
  loop = 0;
  {
#line 1360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1360
    if (! (loop <= oldest_build)) {
#line 1360
      goto while_break;
    }
#line 1361
    if (! (*(cullbuild + loop))->cullable) {
#line 1362
      (*(cullbuild + loop))->cullable = (char)1;
#line 1363
      ncullable ++;
    }
#line 1360
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1368
  if (oldest_ready == -1) {
    {
#line 1369
    copy = oldest_build + 1;
#line 1371
    __message(1, 7, "Decant (all %d)\n", copy);
#line 1373
    n = (int )((unsigned long )copy * sizeof(*(cullready + 0)));
#line 1374
    memcpy((void */* __restrict  */)cullready, (void const   */* __restrict  */)cullbuild,
           (size_t )n);
#line 1375
    memset((void *)cullbuild, 110, (size_t )n);
#line 1376
    oldest_ready = oldest_build;
#line 1377
    oldest_build = -1;
    }
#line 1378
    goto check;
  }
#line 1382
  space = (int )(culltable_size - (unsigned int )(oldest_ready + 1));
#line 1383
  if (space <= 0) {
#line 1384
    if (space < 0) {
      {
#line 1385
      __error(3, "Internal error: Less than zero space in ready table\n");
      }
    }
#line 1386
    goto check;
  }
#line 1390
  avail = oldest_build + 1;
#line 1390
  copy = avail;
#line 1391
  if (copy > space) {
#line 1392
    copy = space;
  }
  {
#line 1393
  leave = avail - copy;
#line 1395
  __message(1, 7, "Decant (%d/%d to %d)\n", copy, avail, space);
#line 1400
  n = oldest_ready + 1;
#line 1401
  memmove((void *)(cullready + copy), (void const   *)(cullready + 0), (unsigned long )n * sizeof(*(cullready + 0)));
#line 1402
  oldest_ready += copy;
#line 1404
  memcpy((void */* __restrict  */)(cullready + 0), (void const   */* __restrict  */)(cullbuild + leave),
         (unsigned long )copy * sizeof(*(cullready + 0)));
#line 1405
  memset((void *)(cullbuild + leave), 107, (unsigned long )copy * sizeof(*(cullbuild + 0)));
#line 1406
  oldest_build = leave - 1;
  }
#line 1408
  if ((unsigned int )(copy + leave) > culltable_size) {
    {
#line 1409
    __error(3, "Internal error: Scan table exceeded (%d+%d)\n", copy, leave);
    }
  }
  check: 
#line 1412
  loop = 0;
  {
#line 1412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1412
    if (! (loop < oldest_ready)) {
#line 1412
      goto while_break___0;
    }
#line 1413
    if (((long )*(cullready + loop) & 4026531840L) == 1610612736L) {
      {
#line 1414
      abort();
      }
    }
#line 1412
    loop ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1415
  return;
}
}
#line 1421 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static int get_dir_fd(struct object *dir ) 
{ 
  int parentfd ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1425
  __message(1, 7, "get_dir_fd(%s)\n", dir->name);
  }
#line 1427
  if (dir->dir) {
    {
#line 1428
    tmp = dirfd(dir->dir);
#line 1428
    fd = dup(tmp);
    }
#line 1429
    if (fd < 0) {
      {
#line 1430
      tmp___0 = __errno_location();
#line 1430
      __error(1, "Failed to dup fd: errno %d (%m)\n", *tmp___0);
      }
    }
    {
#line 1431
    __message(1, 7, "cache fd to %d\n", fd);
    }
#line 1432
    return (fd);
  }
  {
#line 1435
  parentfd = get_dir_fd(dir->parent);
#line 1437
  fd = openat(parentfd, (char const   *)(dir->name), 65536);
  }
#line 1438
  if (fd < 0) {
    {
#line 1438
    tmp___2 = __errno_location();
    }
#line 1438
    if (*tmp___2 != 2) {
      {
#line 1439
      tmp___1 = __errno_location();
#line 1439
      __error(1, "Failed to open directory: errno %d (%m)\n", *tmp___1);
      }
    }
  }
  {
#line 1442
  __message(1, 7, "<%d>/%s to %d\n", parentfd, dir->name, fd);
#line 1443
  close(parentfd);
  }
#line 1444
  return (fd);
}
}
#line 1451 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void cull_object(struct object *object ) 
{ 
  struct stat64 st ;
  int dirfd___0 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1456
  __message(1, 7, "CULL %s\n", object->name);
#line 1458
  dirfd___0 = get_dir_fd(object->parent);
  }
#line 1459
  if (dirfd___0 >= 0) {
    {
#line 1460
    tmp___1 = fstatat64(dirfd___0, (char const   */* __restrict  */)(object->name),
                        (struct stat64 */* __restrict  */)(& st), 0);
    }
#line 1460
    if (tmp___1 < 0) {
      {
#line 1461
      tmp___0 = __errno_location();
      }
#line 1461
      if (*tmp___0 != 2) {
        {
#line 1462
        tmp = __errno_location();
#line 1462
        __error(1, "Failed to re-stat object: errno %d (%m)\n", *tmp);
        }
      }
      {
#line 1464
      close(dirfd___0);
      }
#line 1465
      goto object_already_gone;
    }
    {
#line 1468
    tmp___3 = fchdir(dirfd___0);
    }
#line 1468
    if (tmp___3 < 0) {
      {
#line 1469
      tmp___2 = __errno_location();
#line 1469
      __error(1, "Failed to change current directory: errno %d (%m)\n", *tmp___2);
      }
    }
#line 1470
    if (object->atime >= st.st_atim.tv_sec) {
      {
#line 1471
      cull_file((char const   *)(object->name));
      }
    }
    {
#line 1473
    close(dirfd___0);
    }
  }
  object_already_gone: 
  {
#line 1477
  put_object(object);
  }
#line 1478
  return;
}
}
#line 1484 "/home/june/collector/temp/cachefilesd-0.10.5/cachefilesd.c"
static void cull_objects(void) 
{ 


  {
#line 1486
  if (ncullable <= 0) {
    {
#line 1487
    __error(3, "Internal error: Cullable object count is inconsistent\n");
    }
  }
#line 1489
  if ((*(cullready + oldest_ready))->cullable) {
    {
#line 1490
    cull_object(*(cullready + oldest_ready));
#line 1491
    *(cullready + oldest_ready) = (struct object *)((void *)1795163603);
#line 1492
    oldest_ready --;
    }
  }
#line 1496
  if (! scan) {
#line 1496
    if ((unsigned int )oldest_build <= culltable_size / 2U + 2U) {
      {
#line 1497
      decant_cull_table();
#line 1499
      __message(1, 7, "Refilling cull table\n");
#line 1500
      (root.usage) ++;
#line 1501
      scan = & root;
      }
    }
  }
#line 1503
  return;
}
}
